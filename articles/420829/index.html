<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Job System. Review on the other hand</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the new version of unity 2018, finally, they officially added a new system Entity component system or abbreviated ECS, which allows instead of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Job System. Review on the other hand</h1><div class="post__text post__text-html js-mediator-article">  In the new version of <b>unity</b> 2018, finally, they officially added a new system <b>Entity component system</b> or abbreviated <b>ECS,</b> which allows instead of the usual work with object components to work only with their data. <br><br>  An additional system of tasks suggests that you use parallel computing power to improve the performance of your code. <br><a name="habracut"></a><br>  Together, these two new systems ( <b>ECS</b> and <b>Job Systems</b> ) offer a new level of data processing. <br><br>  Specifically, in this article I will not disassemble the entire <b>ECS</b> system, which is currently available as a separately downloaded set of tools in the <b>unity</b> , and I will consider only the task system and how it can be used outside the <b>ECS</b> package. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  New system </h3><br>  Initially, in <b>unity</b> and earlier, it was possible to use multi-threaded calculations, but the developer needed to create all this on his own, solve the problems himself and bypass the pitfalls.  And if earlier it was necessary to work directly with such things as creating threads, closing threads, pools, synchronization, now all this work fell on the engine's shoulders, and all that is required of the developer is the creation of tasks and their execution. <br><br><h3>  Tasks </h3><br>  To perform any calculations in the new system, it is necessary to use tasks that are objects consisting of methods and data for calculation. <br><br>  Like any other data in the <b>ECS</b> system, tasks in the <b>Job System are</b> also represented as structures that inherit from one of the three interfaces. <br><br><h4>  Ijob </h4><br>  The simplest task interface contains one <b>Execute</b> method that takes nothing in the form of parameters and returns nothing. <br><br>  The task itself looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Ijob</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In the <b>Execute</b> method, you can perform the necessary calculations. <br><br><h4>  IJobParallelFor </h4><br>  Another interface with the same <b>Execute</b> method, which already in turn takes the <b>index</b> numeric parameter. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  This <b>IJobParallelFor</b> interface, unlike the <b>IJob</b> interface, offers to perform a task several times and not just to perform, but to break this implementation into blocks that will be distributed between the streams. <br><br>  <i>Unclear?</i>  <i>Do not worry about this, I'll tell you more.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  And the last, special interface, which, as the name implies, is designed to work with the object's transform.  Also contains the <b>Execute</b> method, with a numeric <b>index</b> parameter and a <b>TransformAccess</b> parameter where the position, size and rotation of the transform are located. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Due to the fact that you cannot work with <b>unity</b> objects directly in the task, this interface can only process the transform data as a separate <b>TransformAccess</b> structure. <br><br>  Done, now you know how task structures are created, you can proceed to practice. <br><br><h3>  Task performance </h3><br>  Let's create a simple task inherited from the <b>IJob</b> interface and execute it.  To do this, we need any simple <b>MonoBehaviour</b> script and the task structure itself. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Now cast this script on some object on the scene.  In the same script ( <b>TestJob</b> ) below we will write the structure of the task and do not forget to import the necessary libraries. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  In the <b>Execute</b> method, for example, we will display a simple line in the console. <br><br>  Now let's move to the <b>Start</b> method of the <b>TestJob</b> script, where we will create an instance of the task and then execute it. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  If you did everything as in the example, then after launching the game you will receive a simple message to the console as in the picture. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="image"><br><br>  What happens here: after calling the <b>Schedule</b> method, the scheduler places the task in the handle and now it can be done by calling the <b>Complete</b> method. <br><br>  It was an example of a task that simply output text to the console.  In order for the task to perform any parallel computing, you need to fill it with data. <br><br><h3>  Data in the task </h3><br>  As in the <b>ECS</b> system, in tasks there is no access to <b>unity</b> objects, you cannot transfer to the <b>GameObject</b> task and change its name there.  All you can do is pass some individual object parameters to the task, change these parameters, and after completing the task, apply these changes back to the object. <br><br>  There are also several limitations to the data in the task itself: firstly, it must be structures, secondly, it must be <a href="https://msdn.microsoft.com/ru-ru/library/ms173105(v%3Dvs.120).aspx">non-convertible</a> data types, that is, you cannot transfer the same <b>boolean</b> or <b>string</b> to the task. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  And the main condition: the data not enclosed in the container can be available only inside the task! <br><br><h3>  Containers </h3><br>  When working with multi-threaded computing, there is a need to somehow exchange data between threads.  In order to transfer data to them and read them back into the task system, containers exist for this purpose.  These containers are presented in the form of conventional structures and operate on the principle of a bridge according to which elementary data is synchronized between threads. <br><br>  There are several types of containers: <br>  <b>NativeArray</b> .  The simplest and most frequently used type of container is represented as a simple array with a fixed size. <br>  <b>NativeSlice</b> .  Another container - an array, as is clear from the translation, is designed to cut NativeArray into pieces. <br><br>  These are the two main containers available without connecting an <b>ECS</b> system.  In a more advanced version, there are several types of containers. <br><br>  <b>NativeList</b> .  It is a regular list of data. <br>  <b>NativeHashMap</b> .  Analog dictionary with key and value. <br>  <b>NativeMultiHashMap</b> .  The same <b>NativeHashMap</b> with only a few values ‚Äã‚Äãunder one key. <br>  <b>NativeQueue</b> .  List data queue. <br><br>  Since we work without connecting the <b>ECS</b> system, only <b>NativeArray</b> and <b>NativeSlice</b> are available to <b>us</b> . <br><br>  Before proceeding to the practical part, it is necessary to analyze the most important point - the creation of copies. <br><br><h3>  Creating containers </h3><br>  As I said before, these containers are a bridge over which data is synchronized between threads.  The task system opens this bridge before starting work and closes it after it is completed.  The opening process is called ‚Äú <i>allocation</i> ‚Äù ( <b>Allocation</b> ) or else <i>‚Äúmemory allocation‚Äù</i> , the closing process is called ‚Äú <i>resource release</i> ‚Äù ( <b>Dispose</b> ). <br><br>  It is the allocation that determines how long the task will be able to use the data in the container - in other words, how long the bridge will be open. <br><br>  In order to better understand these two processes, let's take a look at the picture below. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="image"><br><br>  The lower part shows the life cycle of the main thread ( <b>Main thread</b> ), which is calculated in the number of frames, in the first frame we create another parallel thread ( <b>New thread)</b> that exists a certain number of frames and then closes safely. <br>  In the same <b>New thread</b> and comes the task with the container. <br><br>  Now take a look at the top of the picture. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="image"><br><br>  The white <b>Allocation bar</b> shows the lifetime of the container.  In the first frame there is an <i>allocation of the</i> container - the opening of the bridge, until this point the container did not exist, after all the calculations in the task are completed, the container is released from memory and in the 9th frame the bridge is closed. <br><br>  Also on this strip ( <b>Allocation</b> ) there are time periods ( <b>Temp</b> , <b>TempJob</b> and <b>Presistent</b> ), each of these segments shows the estimated time of the existence of the container. <br><br>  What are these segments for !?  The fact is that the task may be different in duration, we can perform them directly in the same method where we created it, or we can stretch the time to complete the task if it is rather complicated, and these segments show how urgent and how long the task can use the data in a container. <br><br>  <i>If it is still not clear, I will analyze each type of allocation using an example.</i> <br><br>  Now you can go to the practical part of creating containers, to do this, go back to the <b>Start</b> method of the <b>TestJob</b> script and create a new instance of the <b>NativeArray</b> container and do not forget to include the necessary libraries. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  To create a new container instance, you need to specify the size and type of allocation in its constructor.  In this example, the <b>Temp</b> type is used, since the task will be executed only in the <b>Start</b> method. <br><br>  Now we initialize the exact same array variable in the <b>SimpleJob</b> task structure <b>itself</b> . <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Is done.  Now you can create the task itself and pass an array instance to it. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  To start the task this time, we will use its <b>JobHandle</b> handle to get it. Call the same <b>Schedule</b> method. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Now you can call the <b>Complete</b> method on its handle and check whether the task is completed to display the text in the console. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  If you run the task in this form, then after launching the game you will get a fat red error stating that you did not release the array container from the resources after completing the task. <br><br>  About this. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="image"><br><br>  To avoid this, call the <b>Dispose</b> method on the container after completing the task. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Then you can safely restart. <br>  But the task does not do anything!  - then add a couple of actions to it. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  In the <b>Execute</b> method, I multiply the index of each element of the array by itself and write it back to the array to output the result to the console in the <b>Start</b> method. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  What will be the result in the console if we display the last element of the array squared? </blockquote><br>  This is how you can create containers, put them in tasks and perform actions on them. <br><br>  This was an example using the <b>Temp</b> allocation type, which implies performing the task within one frame.  This type is better to use when you need to quickly perform calculations without loading the main thread, but you need to be careful if the task is too complicated or if there are too many of them, then sagging may occur, in this case it is better to use the <b>TempJob</b> type which I will analyze further. <br><br><h3>  TempJob </h3><br>  In this example, I will slightly <b>modify the</b> structure of the <b>SimpleJob</b> task and inherit it from another <b>IJobParallelFor</b> interface. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Also, once the task will be performed longer than one frame, we will execute and collect the results of the task in different <b>Awake</b> and <b>Start</b> methods presented in the form of coroutine.  To do this, change the appearance of the <b>TestJob</b> class a <b>bit</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  In the <b>Awake</b> method, we will create a task and a vector container, and in the <b>Start</b> method, output the data and release the resources. <br><br><div class="spoiler">  <b class="spoiler_title">Awake</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Here again the container <b>array</b> is created with the type of allocation <b>TempJob</b> , after which we create the task and get its handle by calling the <b>Schedule</b> method with minor changes. <br><br><div class="spoiler">  <b class="spoiler_title">Awake</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  The first parameter in the <b>Schedule</b> method indicates how many times the task is executed, here the same number as the size of the <b>array</b> . <br>  The second parameter indicates the number of blocks to share the task. <br><br>  <i>What other blocks?</i> <br>  Previously, in order to execute a task, the thread just called the <b>Execute</b> method once, but now it is necessary to call this method 100 times, so the scheduler, so as not to load any particular thread, splits these 100 times the repetitions into blocks that it distributes between the threads.  In the example, a hundred repetitions will be divided into 5 blocks of 20 repetitions each, that is, the scheduler will presumably distribute these 5 blocks into 5 threads, where each thread will call the <b>Execute</b> method 20 times.  In practice, of course, it‚Äôs not a fact that the scheduler will do just that, it all depends on the system load, so maybe all 100 repetitions will occur in one stream. <br><br>  Now you can call the <b>Complete</b> method on the task handle. <br><br><div class="spoiler">  <b class="spoiler_title">Awake</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  In Corutin <b>Start,</b> we will check the execution of the task and then clean up the container. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  We now turn to actions in the task itself. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  After completing the task in the <b>Start</b> method, we will display all the elements of the array in the console. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Done, you can run and see the result. <br><br>  To understand what the difference between <b>IJob</b> and <b>IJobParallelFor is,</b> take a look at the images below. <br>  For example, in <b>IJob</b> , you can use a simple <b>for</b> loop to perform calculations several times, but in any case, the thread can call the <b>Execute</b> method only once for the entire time the task runs - this is how to make one person perform hundreds of the same actions in a row. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="image"><br><br>  <b>IJobParallelFor</b> offers not just to perform the task in one stream several times, but also to distribute these repetitions among other threads. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="image"><br><br>  In general, the <b>TempJob</b> allocation <b>type is</b> great for most tasks that are performed over several frames. <br><br>  But what if you need to store data even after completing the task, what if after getting the result you don‚Äôt need to destroy it immediately.  To do this, you need to use the type of allocation <b>Persistent</b> , which implies the release of resources then ‚Äú <i>when you need it!‚Äù</i> . <br><br><h3>  Persistent </h3><br>  Again, go back to the <b>TestJob</b> class and change it.  Now we will create tasks in the <b>OnEnable</b> method, check their execution in the <b>Update</b> method and clean up resources in the <b>OnDisable</b> method. <br>  In the example, we will move the object in the <b>Update</b> method, to calculate the trajectory we will use two vector containers - <b>inputArray</b> into which we will place the current position and <b>outputArray</b> from where we will receive the results. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>We will</b> also slightly <b>modify the</b> structure of the <b>SimpleJob</b> task by inheriting it from the <b>IJob</b> interface <b>in</b> order to execute it once. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  In the task itself, we will also betray two vector containers, one position vector and a numeric delta, which will displace the object to the target. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  The <b>ReadOnly</b> and <b>WriteOnly</b> attributes show flow constraints in data-related actions inside containers.  <b>ReadOnly</b> offers the stream only to read data from the container, the <b>WriteOnly</b> attribute is the opposite - it allows the stream to only write data to the container.  If you need to perform two of these actions at once with one container then you do not need to mark it with an attribute at all. <br><br>  Let's <b>go to the OnEnable</b> method of the <b>TestJob</b> class where the containers will be initialized. <br><br><div class="spoiler">  <b class="spoiler_title">OnEnable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  The sizes of containers will be single since it is necessary to transmit and receive parameters only once.  The type of location will be <b>Persistent</b> . <br>  In the <b>OnDisable</b> method, <b>we</b> will free up container resources. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  Let's create a separate method <b>CreateJob</b> where we will create a task with its handle and in the same place we will fill it with data. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>In fact, <b>inputArray</b> is not really needed here, since you can transfer to the task and just the direction vector, but I think it will be better to understand why these <b>ReadOnly</b> and <b>WriteOnly</b> attributes are needed at all.</i> <br><br>  In the <b>Update</b> method, we will check whether the task is completed, after which we apply the result obtained to the object's transform and then run it again. <br><br><div class="spoiler">  <b class="spoiler_title">Update</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Before starting, we will slightly correct the <b>OnEnable</b> method so that the task is created immediately after the containers are initialized. <br><br><div class="spoiler">  <b class="spoiler_title">OnEnable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Done, now you can go to the task itself and perform the necessary calculations in the <b>Execute</b> method. <br><br><div class="spoiler">  <b class="spoiler_title">Execute</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  To see the result of the work, you can throw the <b>TestJob</b> script on some object and start the game. <br><br>  For example, my sprite just shifts to the right. <br><br><div class="spoiler">  <b class="spoiler_title">Animation</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="image"><br></div></div><br>  In general, the type of <b>persistent</b> allocation is great for reusable containers, which are not necessary to destroy and re-create each time. <br><br>  <i>So what type to use !?</i> <br>  The <b>Temp</b> type is better to use for quick calculations, but if the task is too complex and large, there may be a slack. <br>  Type <b>TempJob is</b> great for working with <b>unity</b> objects, so you can change the parameters of objects and apply them, for example, in the next frame. <br>  The <b>Persistent</b> type can be used when speed is not important to you, but you just need to constantly calculate some data on the side, for example, process data over the network, or the work of AI. <br><br><div class="spoiler">  <b class="spoiler_title">Invalid and None</b> <div class="spoiler_text">  <i>There are two more types of allocations <b>Invalid</b> and <b>None</b> , but they are needed more for debugging, and do not participate in the work.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  Separately, it is still worth analyzing the capabilities of the task handle, because apart from checking the task execution process, this small handle can still create entire networks of tasks through dependencies (although I prefer to call them queues). <br><br>  For example, if you need to perform two tasks in a certain sequence, then for this you just need to attach the handle of one task to the handle of another. <br><br>  It looks like this. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="image"><br><br>  Each individual handle initially contains its own task, but when combined we get a new handle with two tasks. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  Or so. <br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  The execution sequence is saved and the scheduler will not start to perform the next task until it is satisfied with the previous one, but it is important to remember that the property of the IsCompleted <b>handle</b> will wait for all the tasks in it to be completed. <br><br><h2>  Conclusion </h2><br><h3>  Containers </h3><br><ol><li>  When working with data in containers, do not forget that these are structures, so any rewriting of data in a container does not change them, but creates them again. </li><li>  <i>What will happen if I set the type of location Temp and do not clear the resources after the task is completed?</i>  Mistake. </li><li>  <i>Can I create my own containers?</i>  It is possible, the units described in detail <a href="https://docs.unity3d.com/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html">the</a> process of creating custom containers here, but it‚Äôs better to think a few times: is it worth it, maybe there are enough ordinary containers !? </li></ol><br><h4>  Security! </h4><br>  <i>Static data.</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not try to use static data in the task ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and others), any access to static data will violate the security of the system. In fact, at the moment you can access the static data, but only if you are sure that they do not change during work - that is, they are completely static and read-only. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to use the task system?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All these examples that are given here in the article are only conditional, and show how to work with this system, and not when to use it. The task system can be used without </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to understand that the system also consumes resources when working and that for any reason to immediately write tasks, creating heaps of containers is simply meaningless - everything will get worse. For example, recalculating an array of 10 thousand elements will not be correct - you will have more time to work with the scheduler, but recalculate all the polygons of the huge terrain or generate it altogether - the right solution, you can break the terrain into tasks and process each one in a separate stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, if you are constantly engaged in complex calculations in projects and are constantly looking for new opportunities to make this process less resource-intensive, then </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is exactly what you need. </font><font style="vertical-align: inherit;">If you constantly work with complex calculations inseparable from objects and you want your code to run faster and be supported on most platforms, then </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will help you with this. </font><font style="vertical-align: inherit;">If you create projects only for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then this is not for you, at the moment the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not support work in browsers, although this is already a problem not for the developers, but for the browser developers themselves. </font></font><br><br> <a href="http://rgho.st/6shJ4wKsl%26sa%3DD%26ust%3D1534786391145000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code with all the examples</font></font></a> <cut></cut></div><p>Source: <a href="https://habr.com/ru/post/420829/">https://habr.com/ru/post/420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420815/index.html">How ‚Äúdecoding of the digital world‚Äù exploded the hall: top 10 reports DotNext 2018 Piter</a></li>
<li><a href="../420819/index.html">Top 10 Python tools for machine learning and data-science</a></li>
<li><a href="../420821/index.html">Rule 10: 1 in programming and writing</a></li>
<li><a href="../420825/index.html">Today will be the first match between OpenAI and Dota 2 professionals (people won). Understanding how the bot works</a></li>
<li><a href="../420827/index.html">Create a simple maven project using Java EE + WildFly10 + JPA (Hibernate) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../420831/index.html">Apparatus for the issuance of cookies "Cooker 3000"</a></li>
<li><a href="../420833/index.html">The main mistakes monetization of the application [and how to fix them]</a></li>
<li><a href="../420835/index.html">"Kalashnikov" showed the concept of a combat robot and electric motorcycle for the civilian market</a></li>
<li><a href="../420837/index.html">Testing software RAIDs for NVMe devices using the SNIA technique</a></li>
<li><a href="../420841/index.html">Pre-hospital hotfix or ‚ÄúHey, Swagger! Where are my mistakes? ‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>