<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Yandex.Practicum won the front-end desync: acrobatic number with Redux-Saga, postMessage and Jupyter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My name is Artem Nesmiyanov, I am a full-stack developer at Yandex.Pratikum, I am mainly engaged in frontend. We believe that it is possible and neces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Yandex.Practicum won the front-end desync: acrobatic number with Redux-Saga, postMessage and Jupyter</h1><div class="post__text post__text-html js-mediator-article">  My name is Artem Nesmiyanov, I am a full-stack developer at Yandex.Pratikum, I am mainly engaged in frontend.  We believe that it is possible and necessary to learn programming, data analytics and other digital crafts with pleasure.  And start learning, and continue.  Any developer who does not give up on himself is always ‚Äúcontinuing.‚Äù  We, too.  Therefore, we perceive work tasks, including as a study format.  And one of the recent ones helped me and the guys to better understand in which direction to develop our frontend stack. <br><br><img src="https://habrastorage.org/webt/u2/uh/nx/u2uhnxzsc0hv3v7clkqskbzwnc0.png"><br><br><h3>  Who and what made the Workshop </h3><br>  Our development team is extremely compact.  There are only two people on the back end, four on the front end, including me, full stack.  Periodically, the guys from Yandex.Tutorial join us in the gain.  We work on Scrum with two-week sprints. <br><a name="habracut"></a><br>  Our frontend is based on React.js in conjunction with Redux / Redux-Saga, and we use Express to communicate with the backend.  Backend-part of the stack - in Python (more precisely, Django), DB - PostgreSQL, for individual tasks - Redis.  With Redux, we store stor with information, send actions that are processed by Redux and Redux-Saga.  All side effects, such as requests to the server, calls to Yandex.Metrica and redirects, are processed just in Redux-Saga.  And all data modifications occur in Redux reducers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  How not to overlook the log in your iframe </h3><br>  Now on our platform, open training in three professions: front-end developer, web developer, data analyst.  And we are actively sawing tools for each course. <br><br>  For the semi-annual <a href="https://praktikum.yandex.ru/data-analyst/%3Futm_source%3Dhabr%26utm_content%3Dpost300519">Data Analyst</a> course, we made an interactive simulator, where we teach users to work with <a href="https://jupyter.org/">Jupyter Notebook</a> .  This is a cool shell for interactive computing that data scientists rightly love.  All operations in the environment are performed inside the notebook, it is simply - a notebook (as I will call it later). <br><br>  Experience prompts, and we are sure: it is important that learning tasks are close to real ones.  Including in terms of the working environment.  Therefore, it was necessary to make it so that inside the lesson all the code could be written, launched and checked right in the notebook. <br><br>  There are no difficulties with the basic implementation.  The notebook itself was settled in a separate iframe, the logic of its verification was prescribed on the backend. <br><br><img src="https://habrastorage.org/webt/2z/_9/iy/2z_9iyuj7pmha0ielvj4evuyhic.png"><br>  <i>The student's notebook itself (right) is just an iframe, whose URL leads to a specific notebook at JupyterHub.</i> <br><br>  In the first approximation, everything functioned without a hitch, without a hitch.  However, when testing came out absurdities.  For example, you drive into a notebook is guaranteed the correct version of the code, but after clicking on the button ‚ÄúCheck task‚Äù the server responds that the answer is supposedly incorrect.  And why - a mystery. <br><br>  Well, what happens is that we realized the same day when we found the bug: it turned out that the current, just hammered into the Jupyter Notebook form, solution flew to the server, and the previous one, which was already erased.  The notebook itself did not have time to survive, and we braked the backend so that he checked the task in it.  What he could not do, of course. <br><br>  We had to get rid of the marshalling between saving the notebook and sending the request to the server to check it.  The snag turned out to be that it was required to force the iframe of the notebook to communicate with the parent window, that is, with the front-end, on which the lesson as a whole was spinning.  Of course, it was impossible to directly forward some kind of event between them: they live on different domains. <br><br>  In search of a solution, I learned that Jupyter Notebook allows plug-ins to be connected.  There is a Jupiter object - a notebook, - which can be operated.  Work with him provides for events, including the preservation of the notebook, as well as the challenge of the corresponding actions.  Having understood Jupyter's gut (it was necessary: ‚Äã‚Äãthere is no normal documentation for it), we did so with the guys - we built our own plug-in for it and, using the postMessage mechanism, achieved the coordinated work of the elements from which the Practicum lesson was assembled. <br><br>  We thought through the workaround taking into account the fact that the already mentioned Redux-Saga was originally included in our stack - to put it simply, the middleware on Redux, which makes it possible to work with side effects more flexibly.  For example, saving a notebook is just something like this side effect.  We are sending something to the backend, waiting for something, receiving something.  All this movement is processed inside Redux-Saga: it is this that throws events to the frontend, dictating to it how to display in the UI. <br><br>  What is the result?  It is created by postMessage and sent to the iframe with a notebook.  When the iframe sees that something has come to him from the outside, it parses the resulting string.  Realizing that he needs to keep the notebook, he performs this action and, in turn, sends a response postMessage about the execution of the request. <br><br>  When we click the "Check Task" button, the corresponding event is sent to the Redux Store: "So and so, we went to be checked."  Redux-Saga sees the action fly in and make a postMessage in the iframe.  Now she is waiting for the iframe to answer.  In the meantime, our student sees the download indicator on the ‚ÄúCheck Task‚Äù button and realizes that the simulator does not hang, but ‚Äúthinks‚Äù.  And only when postMessage comes back that the save is complete, Redux-Saga continues to work and sends a request to the backend.  On the server, the task is checked - the right decision or not, if mistakes are made, then what, and so on, - and this information is carefully stored in the Redux Store.  And from there, the front-end script pulls it into the lesson interface. <br><br>  Here is the scheme that came out in the end: <br><br><img src="https://habrastorage.org/webt/ks/gc/eu/ksgceup6hokoh9jtvqoajegbjfc.png"><br><br>  <i>(1) We press the button ‚ÄúCheck Task‚Äù (Check) ‚Üí (2) We send action CHECK_NOTEBOOK_REQUEST ‚Üí (3) We catch action check ‚Üí (4) Accept message ‚Üí (5) Notebook is saved ‚Üí (4) We receive an event from the Jupyter API that the notebook has been preserved and send postMessage notebook-saved ‚Üí (1) Receive an event ‚Üí (2) We send an action SAVE_NOTEBOOK_SUCCESS ‚Üí (3) We catch an action and send a request to check the notebook ‚Üí (6) ‚Üí (7) Check that this notebook is in the database ‚Üí (8) ‚Üí (7) Go behind the code of the notebook ‚Üí (5) Return the code ‚Üí (7) Start the code check ‚Üí (9 ) ‚Üí (7) We get a cut</i>  <i>tat check ‚Üí (6) ‚Üí (3) we send action CHECK_NOTEBOOK_SUCCESS ‚Üí (2) down to verify response sided ‚Üí (1) Draw result</i> <br><br>  We will understand how all this is arranged in the context of the code. <br><br>  We have trainer_type_jupyter.jsx on the frontend - the script of the page where our notebook is drawn. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__right-column"</span></span></span><span class="hljs-tag">&gt;</span></span> {notebookLinkIsLoading ? ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-frame"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.onIframeRef}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{notebookLink}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ) : ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spin</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"l"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-spin"</span></span></span><span class="hljs-tag"> /&gt;</span></span> )} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  After clicking the "Check task" button, the callCheckTasks method is called. <br><br><pre> <code class="xml hljs">handleCheckTasks = () =&gt; { const {checkNotebook, lesson} = this.props; checkNotebook({id: lesson.id, iframe: this.iframeRef}); };</code> </pre> <br>  In fact, handleCheckTasks is used to call a Redux-action with the parameters passed. <br><br><pre> <code class="xml hljs">export const checkNotebook = getAsyncActionsFactory(CHECK_NOTEBOOK).request;</code> </pre> <br>  This is a common action intended for Redux-Saga and asynchronous methods.  Here, getAsyncActionsFactory generates three actions: <br><br>  // utils / store-helpers / async.js <br><br><pre> <code class="xml hljs">export function getAsyncActionsFactory(type) { const ASYNC_CONSTANTS = getAsyncConstants(type); return { request: payload =&gt; ({type: ASYNC_CONSTANTS.REQUEST, payload}), error: (response, request) =&gt; ({type: ASYNC_CONSTANTS.ERROR, response, request}), success: (response, request) =&gt; ({type: ASYNC_CONSTANTS.SUCCESS, response, request}), } }</code> </pre> <br>  Accordingly, getAsyncConstants generates three constants of the form * _REQUEST, * _SUCCESS and * _ERROR. <br><br>  Now let's see how our Redux-Saga will handle all this farming: <br><br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* watchCheckNotebook() { const watcher = createAsyncActionSagaWatcher({ type: CHECK_NOTEBOOK, apiMethod: Api.checkNotebook, preprocessRequestGenerator: function* ({id, iframe}) { yield put(trainerActions.saveNotebook({iframe})); yield take(getAsyncConstants(SAVE_NOTEBOOK).SUCCESS); return {id}; }, successHandlerGenerator: function* ({response}) { const {completed_tests: completedTests} = response; for (let id of completedTests) { yield put(trainerActions.setTaskSolved(id)); } }, errorHandlerGenerator: function* ({response: error}) { yield put(appActions.setNetworkError(error)); } }); yield watcher(); }</code> </pre> <br>  Magic?  Nothing extraordinary.  As you can see, createAsyncActionSagaWatcher simply creates a manager that can process the data that gets into the action, make a request at a specific URL, dispatch an action * _REQUEST, and upon a successful response from the server dispatch * _SUCCESS and * _ERROR.  In addition, of course, handlers are provided for every variant inside of yesterday. <br><br>  You probably noticed that in the data preprocessor we call another Redux-Saga, wait until it finishes with SUCCESS, and only then we continue the work.  And of course, you do not need to send an iframe to the server, so we only give id. <br><br>  Take a closer look at the saveNotebook function: <br><br><pre> <code class="xml hljs">function* saveNotebook({payload: {iframe}}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'save-notebook' }), '*'); yield; }</code> </pre> <br>  We have reached the most important mechanism in the interaction of the iframe with the frontend - postMessage.  The above code snippet sends an action with the type save-notebook, which is processed inside the iframe. <br><br>  I already mentioned that we needed to write a plugin for Jupyter Notebook, which would be loaded inside the notebook.  These plugins look like this: <br><br><pre> <code class="xml hljs">define([ 'base/js/namespace', 'base/js/events' ], function( Jupyter, events ) {...});</code> </pre><br>  To create such extensions, you have to deal with the Jupyter Notebook API itself.  Unfortunately, there is no intelligible documentation on it.  But <a href="https://github.com/jupyter/notebook/tree/master/notebook/static/notebook/js">source codes</a> are available, I also penetrated into them.  Well at least that the code is readable there. <br><br>  The plugin should be taught to communicate with the parent window in the frontend of the lesson: after all, the dissynchronization between them is the cause of the bug with the task verification.  First of all, subscribe to all the messages that we receive: <br><br><pre> <code class="xml hljs">window.addEventListener('message', actionListener);</code> </pre> <br>  Now we will ensure their processing: <br><br><pre> <code class="xml hljs">function actionListener({data: eventString}) { let event = ''; try { event = JSON.parse(eventString); } catch(e) { return; } switch (event.type) { case 'save-notebook': Jupyter.actions.call('jupyter-notebook:save-notebook'); Break; ... default: break; } }</code> </pre> <br>  All events that do not fit us in the format, safely ignore. <br><br>  We see that the event save-notebook arrives, and we cause an action to save the notebook.  It remains only to send back a message that the notebook has been preserved: <br><br><pre> <code class="xml hljs">events.on('notebook_saved.Notebook', actionDispatcher); function actionDispatcher(event) { switch (event.type) { case 'select': const selectedCell = Jupyter.notebook.get_selected_cell(); dispatchEvent({ type: event.type, data: {taskId: getCellTaskId(selectedCell)} }); return; case 'notebook_saved': default: dispatchEvent({type: event.type}); } } function dispatchEvent(event) { return window.parent.postMessage( typeof event === 'string' ? event : JSON.stringify(event), '*' ); }</code> </pre><br>  In other words, simply send {type: 'notebook_saved'} to the top.  This means that the notebook has been preserved. <br><br>  Let's return to our component: <br><br>  //trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">componentDidMount() { const {getNotebookLink, lesson} = this.props; getNotebookLink({id: lesson.id}); window.addEventListener('message', this.handleWindowMessage); }</code> </pre> <br>  When the component is mounted, we request a link to the notebook from the server and subscribe to all actions that can fly to us: <br><br><pre> <code class="xml hljs">handleWindowMessage = ({data: eventString}) =&gt; { const {activeTaskId, history, match: {params}, setNotebookSaved, tasks} = this.props; let event = null; try { event = JSON.parse(eventString); } catch(e) { return; } const {type, data} = event; switch (type) { case 'app_initialized': this.selectTaskCell({taskId: activeTaskId}) return; case 'notebook_saved': setNotebookSaved(); return; case 'select': { const taskId = data &amp;&amp; data.taskId; if (!taskId) { return } const task = tasks.find(({id}) =&gt; taskId === id); if (task &amp;&amp; task.status === TASK_STATUSES.DISABLED) { this.selectTaskCell({taskId: null}) return; } history.push(reversePath(urls.trainerTask, {...params, taskId})); return; } default: break; } };</code> </pre> <br>  This is where the setNotebookSaved action dispatch is called, which will allow Redux-Saga to continue working and save the notebook. <br><br><h3>  Glitches of choice </h3><br>  We have mastered the notebook preservation bug.  And immediately switched to a new problem.  It was necessary to learn how to block tasks (tasks) that the student had not yet reached.  In other words, it was necessary to synchronize the navigation between our interactive simulator and the Jupyter Notebook: within one lesson we had one notebook in several iframes with several tasks, the transitions between which had to be coordinated with changes in the interface of the lesson as a whole.  For example, so that by clicking on the second task in the interface of the lesson in the notebook, there was a switch to the cell corresponding to the second task.  And vice versa: if in the Jupyter Notebook frame you select the cell associated with the third task, the URL in the address bar of the browser should immediately change and, accordingly, the accompanying text with the theory for the third task should appear in the interface of the lesson. <br><br>  There was also a more difficult task.  The fact is that our training program is designed for the consistent passage of lessons and assignments.  Meanwhile, by default, in the Jupiter's notebook, nothing prevents the user from opening any cell.  And in our case, each cell is a separate task.  It turned out that you can solve the first and third task, and skip the second.  From the risk of non-linear passage of the lesson had to get rid of. <br><br>  The basis of the decision was all the same postMessage.  Only we had to further delve into the Jupyter Notebook API, more specifically, what the Jupiter object itself can do.  And come up with a mechanism for checking which cell is tied to.  In the most general form, it is as follows.  In the structure of the notebook, the cells go one after another.  They may have metadata.  The metadata provides the "Tags" field, and the tags are just the task identifiers inside the lesson.  In addition, using cell tagging, you can determine whether they should be blocked by the student so far.  As a result, in accordance with the current model of the simulator, by sticking into a cell, we start sending postMessage from the iframe to our frontend, which, in turn, goes to the Redux Store and checks, based on the properties of the task, whether it is available to us now.  If unavailable, we switch to the previous active cell. <br><br>  So we have achieved that in the notebook you cannot select a cell that should not be available on the training timeline.  True, this gave rise to an uncritical, but a bug: you try to click on a cell with an inaccessible task, and it quickly ‚Äúblinks‚Äù: it is clear that it was activated for a moment, but was immediately blocked.  While we have not eliminated this roughness, it does not interfere with the lessons, but in the background we continue to think about how to cope with it (by the way, do you have thoughts?). <br><br>  A little bit about how we modified our frontend to solve the problem.  Turn again to trainer_type_jupyter.jsx - let's focus on app_initialized and select. <br><br>  With app_initialized, everything is elementary: the notebook has loaded, and we want to do something.  For example, select the current cell depending on the task you selected.  The plugin is described so that you can pass the taskId and switch to the first cell, this taskId is appropriate. <br><br>  Namely: <br><br>  // trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">selectTaskCell = ({taskId}) =&gt; { const {selectCell} = this.props; if (!this.iframeRef) { return; } selectCell({iframe: this.iframeRef, taskId}); };</code> </pre> <br>  // trainer.actions.js <br><br><pre> <code class="xml hljs">export const selectCell = ({iframe, taskId}) =&gt; ({ type: SELECT_CELL, iframe, taskId });</code> </pre> <br>  // trainer.saga.js <br><br><pre> <code class="xml hljs">function* selectCell({iframe, taskId}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'select-cell', data: {taskId} }), '*'); yield; } function* watchSelectCell() { yield takeEvery(SELECT_CELL, selectCell); }</code> </pre> <br>  // custom.js (Jupyter plugin) <br><br><pre> <code class="xml hljs">function getCellTaskId(cell) { const notebook = Jupyter.notebook; while (cell) { const tags = cell.metadata.tags; const taskId = tags &amp;&amp; tags[0]; if (taskId) { return taskId; } cell = notebook.get_prev_cell(cell); } return null; } function selectCell({taskId}) { const notebook = Jupyter.notebook; const selectedCell = notebook.get_selected_cell(); if (!taskId) { selectedCell.unselect(); return; } if (selectedCell &amp;&amp; selectedCell.selected &amp;&amp; getCellTaskId(selectedCell) === taskId) { return; } const index = notebook.get_cells() .findIndex(cell =&gt; getCellTaskId(cell) === taskId); if (index <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag">; } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">notebook.select</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">notebook.get_cell(index);</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell.element</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.scrollIntoView</span></span></span><span class="hljs-tag">({ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">behavior:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">smooth</span></span></span><span class="hljs-tag">', </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">block:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start</span></span></span><span class="hljs-tag">' }); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">actionListener</span></span></span><span class="hljs-tag">({</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">eventString</span></span></span><span class="hljs-tag">}) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">case</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select-cell</span></span></span><span class="hljs-tag">'</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">selectCell</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">event.data</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">break</span></span></span><span class="hljs-tag">;</span></span></code> </pre> <br>  Now you can switch cells and find out from the iframe that the cell has been switched. <br><br>  When switching a cell, we change the URL and fall into another task.  It remains only to do the opposite - when selecting another task in the interface, switch the cell.  Easy: <br><br><pre> <code class="xml hljs">componentDidUpdate({match: {params: {prevTaskId}}) { const {match: {params: {taskId}}} = this.props; if (taskId !== prevTaskId) { this.selectTaskCell({taskId});</code> </pre> <br><h3>  Separate perfectionists boiler </h3><br>  It would be cool to just brag about how good we are.  The solution in the bottom line is effective, although it looks a bit muddled: if we summarize, we have a method that processes any message coming from outside (in our case, from the iframe).  But in the system built by us, there are things that I personally, and colleagues, do not really like. <br><br>  ‚Ä¢ There is no flexibility in the interaction of elements: whenever we want to add new functionality, we will have to change the plugin to support both the old and the new communication format.  There is no single isolated mechanism for working between the iframe and our front-end component, which draws a Jupyter Notebook in the tutorial interface and works with our tasks.  Globally - there is a desire to make a more flexible system, so that in the future it will be easy to add new actions, events and process them.  And in the case of not only Jupiter's notebook, but with any iframe in the simulators.  So we look in the direction of passing the plugin code through postMessage and exchanging (eval) it inside the plugin. <br><br>  ‚Ä¢ Code snippets that solve problems are scattered throughout the project.  Communication with the iframe is made from both Redux-Saga and the component, which is certainly not optimal. <br><br>  ‚Ä¢ The very iframe with Jupyter Notebook rendering is sitting on another service.  It is slightly problematic to edit, especially with the observance of the principle of backward compatibility.  For example, if we want to change some logic on the front end and in the notebook itself, we have to do double work. <br><br>  ‚Ä¢ Much would like to implement easier.  Take at least React.  He has a lot of lifecycle-methods, and each of them needs to be processed.  In addition, I am confused by binding to the React itself.  Ideally, I would like to be able to work with our iframe no matter what your frontend framework is.  In general, the intersection of the technologies chosen by us imposes restrictions: the same Redux-Saga expects from us Redux-action games, and not postMessage. <br><br>  So what we‚Äôre doing is definitely not going to stop.  The textbook dilemma: you can go in the direction of beauty, but sacrifice optimal performance, or vice versa.  We have not found the best solution yet. <br><br>  Perhaps you have ideas? </div><p>Source: <a href="https://habr.com/ru/post/453876/">https://habr.com/ru/post/453876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453866/index.html">API Request with React Hooks, HOC or Render Prop</a></li>
<li><a href="../453868/index.html">Touch mini switch co with glass panel on nRF52832</a></li>
<li><a href="../453870/index.html">We write Reverse socks5 proxy on powershell. Part 1</a></li>
<li><a href="../453872/index.html">We restore photos using neural networks</a></li>
<li><a href="../453874/index.html">From Russian Roulette to secure LOTO: how to protect data center personnel</a></li>
<li><a href="../45388/index.html">Flower router</a></li>
<li><a href="../453882/index.html">Big guide to the profession of decision architect (+ list of useful links)</a></li>
<li><a href="../453884/index.html">Google Camera - HYIP or replacement SLR?</a></li>
<li><a href="../453886/index.html">The program works</a></li>
<li><a href="../453888/index.html">Maximum speed machine learning: Predictive Maintenance for four months</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>