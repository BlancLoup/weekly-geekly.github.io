<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods for constructing test functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the course of working with global optimization, there was a need to design multi-extremal test functions. Often the majority of ready-made function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods for constructing test functions</h1><div class="post__text post__text-html js-mediator-article">  In the course of working with global optimization, there was a need to design multi-extremal test functions.  Often the majority of ready-made functions, for example from <a href="https://en.wikipedia.org/wiki/Test_functions_for_optimization">Wikipedia</a> , are not suitable for correct evaluation of the operation of the algorithm.  Some of the functions are single-extremum, for such examples local search algorithms are more suitable, the other refers to gully.  For global optimization, it is necessary to use multi-extremes, where the extremes differ significantly in magnitude. <br><br>  Let us consider some methods that allow one to easily construct test multiextremal functions, while allowing one to set specific properties: the Feldbaum method, functions based on hyperbolic potentials, and functions based on exponential potentials.  In addition to these methods, there are harmonic multiextremal functions and various combinations thereof. <br><a name="habracut"></a><br><h3>  Feldbaum method </h3><br>  This method is based on simple power single-extremal functions of the form: <br><p><math> </math> $$ display $$ I_i (x-c_i) = \ sum_ {j = 1} ^ n a_ {ij} | x_j-c_ {ij} | ^ {p_ {ij}} + b_i, p_ {ij}&gt; 0 $ $ display $$ </p><br>  The above function will have a minimum at the point <math> </math> $ inline $ c_i $ inline $   , and the value at this point will be <math> </math> $ inline $ b_i $ inline $   . <br>  If a <math> </math> $ inline $ p_ {ij}&gt; 0 $ inline $   (degree of smoothness of the function in the region of extremum), then at the minimum point the function will be smooth, if <math> </math> $ inline $ 0 &lt;p_ {ij} \ le1 $ inline $   , then at the minimum point the function will be angular (not differentiable). <br><br>  Coefficient <math> </math> $ inline $ a $ inline $   responsible for the degree of coolness of the function in the region of the extremum. <br>  To construct a multi-extremal function, it is necessary to apply the minimum operator to the set of single-extremal functions.  The general view will be as follows: <br><p><math> </math> $$ display $$ I (x) = min \ {\ sum_ {j = 1} ^ m a_ {ij} | x_j-c_ {ij} | ^ {p_ {ij}} + b_i, i = \ overline {1 , N} \} $$ display $$ </p><br>  Example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Analytical function view</b> <div class="spoiler_text"><p><math> </math> $$ display $$ I_1 (x-c_1) = 7 | x_1 | ^ 2 + 7 | x_2 | ^ 2, $$ display $$ </p><br><p><math> </math> $$ display $$ I_2 (x-c_2) = 5 | x_1 + 2 | ^ {0.5} +5 | x_2 | ^ {0.5} +6, $$ display $$ </p><br><p><math> </math> $$ display $$ I_3 (x-c_3) = 5 | x_1 | ^ {1.3} +5 | x_2 + 2 | ^ {1.3} +5, $$ display $$ </p><br><p><math> </math> $$ display $$ I_4 (x-c_4) = 5 | x_1 | ^ {1} +5 | x_2-4 | ^ {1} +8, $$ display $$ </p><br><p><math> </math> $$ display $$ I_5 (x-c_5) = 4 | x_1-2 | ^ {1.5} +4 | x_2-2 | ^ {1.5} +7, $$ display $$ </p><br><p><math> </math> $$ display $$ I_6 (x-c_6) = 5 | x_1-4 | ^ {1.8} +5 | x_2 | ^ {1.8} +9, $$ display $$ </p><br><p><math> </math> $$ display $$ I_7 (x-c_7) = 6 | x_1-4 | ^ {0.6} +6 | x_2-4 | ^ {0.6} +4, $$ display $$ </p><br><p><math> </math> $$ display $$ I_8 (x-c_8) = 6 | x_1 + 4 | ^ {0.6} +6 | x_2-4 | ^ {1.6} +3, $$ display $$ </p><br><p><math> </math> $$ display $$ I_9 (x-c_9) = 3 | x_1 + 4 | ^ {1.2} +3 | x_2 + 4 | ^ {0.5} +7.5, $$ display $$ </p><br><p><math> </math> $$ display $$ I_ {10} (x-c_ {10}) = 2 | x_1-3 | ^ {0.9} +4 | x_2 + 5 | ^ {0.3} +8.5, $$ display $$ </p><br><p><math> </math> $$ display $$ I (x) = min \ {I_i (x-c_i), i = \ overline {1, N} \}. $$ display $$ </p><br></div></div><br>  The graph of lines of equal levels of the above function will be as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mo/uu/ob/mouuobhxuuihaj-heooaida6lhs.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_1 = x_2 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7p/z4/r2/7pz4r23-l6yni5_tdbtiw_aooeo.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_2 = 4 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/jo/xh/_1joxh4kin5cfvabfmm6ow2ntj4.png" alt="image"></div><br>  The above function has minima at the points: (0, 0), (-2, 0), (0, -2), (0, 4), (2, 2), (4, 0), (4, 4 ), (-4, 4), (-4, -4), (3, -5).  The minimum is global at the point (0, 0). <br>  Code to generate test functions: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_test_function_method_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: int, a: List[List[float]], c: List[List[float]], p: List[List[float]], b: List[float])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :param n:   :param a:    ,   ,    /      :param c:    :param p:       :param b:    :return:  ,       ,          """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> l = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(x)): res = res + a[i][j] * np.abs(x[j] - c[i][j]) ** p[i][j] res = res + b[i] l.append(res) res = np.array(l) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.min(res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func</code> </pre> <br><h3>  Hyperbolic potential functions </h3><br>  The single-extremal function is: <br><p><math> </math> $$ display $$ I_ {Y, i} (x-c_i) = - \ frac {1} {b_i * \ sum_ {j = 1} ^ m a_ {ij} | x_j-c {ij} | ^ {p_ {ij}} + d_i}, b_i&gt; 0, d_i&gt; 0 $$ display $$ </p><br>  This function also has a minimum at the point <math> </math> $ inline $ c_i $ inline $   its depth is determined by <math> </math> $ inline $ d_i $ inline $   .  The degree of slope is given by the coefficient <math> </math> $ inline $ b_i $ inline $   the bigger it is, the narrower the area of ‚Äã‚Äãthe extremum and the steeper the function. <br><br>  To obtain a multi-extremal function, it is necessary to apply the summation operator: <br><p><math> </math> $$ display $$ I (x) = \ sum_ {i = 1} ^ N I_ {Y, i} (x-c_i) $$ display $$ </p><br>  Example: <br><br><div class="spoiler">  <b class="spoiler_title">Analytical function view</b> <div class="spoiler_text"><p><math> </math> $$ display $$ I_1 (x-c_1) = - \ frac {1} {| x_1 + 4 | ^ 1 + | x_2 | ^ 1 + 0.25}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_2 (x-c_2) = - \ frac {1} {2 | x_1 | ^ 1 + 2 | x_2 | ^ 1 + 0.2}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_3 (x-c_3) = - \ frac {1} {0.5 | x_1 + 3 | ^ {0.6} +0.5 | x_2-3 | ^ {0.6} +0.1}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_4 (x-c_4) = - \ frac {1} {1.5 | x_1-2 | ^ 1 + 1.5 | x_2-2 | ^ 1 + 0.3}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_5 (x-c_5) = - \ frac {1} {0.8 | x_1 + 3 | ^ 1 + 0.8 | x_2 + 4 | ^ 1 + 0.35}, $$ display $$ </p><br><p><math> </math> $$ display $$ I (x_1, x_2) = \ sum_ {i = 1} ^ 5 I_ {Y, i} (x-c_i) $$ display $$ </p><br></div></div><br>  The graph of lines of equal levels of the above function will be as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/v5/f1/mkv5f1bwux91ddppu_e6dkqmiyk.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_1 = x_2 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wa/cm/1l/wacm1l2cnpwm2y9f0fhodptygei.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_2 = x_1 + 3 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n0/ov/y6/n0ovy68hgrejvsqfz2_y_ngyt9e.png" alt="image"></div><br>  The above function has minimum points: (-4, 0), (0, 0), (-3, 3), (2, 2), (-3, -4).  Global is the minimum at the point (-3, 3). <br><br>  Under the spoiler is the code for generating a test function with additive modular functions in the denominator. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_tf_hyperbolic_potential_abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: int, a: List[float], c: List[List[float]], p: List[List[float]], b: List[float])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :param n:   :param a: ,       :param c:    :param p:       :param b:  ,       """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(x)): res = res + np.abs(x[j] - c[i][j]) ** p[i][j] res = a[i] * res + b[i] res = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / res) value = value + res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func</code> </pre><br></div></div><br><h3>  Exponential Potential Functions </h3><br>  The single-extremal function is: <br><p><math> </math> $$ display $$ I_ {E, i} (x-c_i) = - d_i * exp \ {-b_i * sum_ {j = 1} ^ m a_ {ij} | x_j-c_ {ij} | ^ {p_ {ij}} \}, b_i&gt; 0, d_i&gt; 0 $$ display $$ </p><br>  Here all the letter designations carry the same meaning as in the previous method. <br>  To obtain a multiextremal function, we also use the summation operator: <br><p><math> </math> $$ display $$ I (x) = \ sum_ {i = 1} ^ N I_ {E, i} (x-c_i) $$ display $$ </p><br>  Example: <br><br><div class="spoiler">  <b class="spoiler_title">Analytical function view</b> <div class="spoiler_text"><p><math> </math> $$ display $$ I_ {U, 1} (x-c_1) = - 6 * exp \ {- 1 * [| x_1 + 4 | ^ {0.3} + | x_2 | ^ 1] \}, $$ display $ $ </p><br><p><math> </math> $$ display $$ I_ {E, 2} (x-c_2) = - 5 * exp \ {- 2 * [| x_1 | ^ {1} + | x_2 | ^ 1] \}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_ {E, 3} (x-c_3) = - 7 * exp \ {- 0.5 * [| x_1 + 3 | ^ {0.6} + | x_2-3 | ^ {1.1}] \}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_ {E, 4} (x-c_4) = - 4 * exp \ {- 1.5 * [| x_1-2 | ^ {1.3} + | x_2-2 | ^ {0.8}] \}, $$ display $$ </p><br><p><math> </math> $$ display $$ I_ {U, 5} (x-c_5) = - 4.5 * exp \ {- 0.8 * [| x_1 + 3 | ^ {1.5} + | x_2 + 4 | ^ 2] \}, $$ display $$ </p><br><p><math> </math> $$ display $$ I (x_1, x_2) = \ sum_ {i = 1} ^ 5 I_ {E, i} (x-c_i) $$ display $$ </p><br></div></div><br>  The graph of lines of equal levels is presented below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qs/1o/3g/qs1o3g84tx7kerl_xhpj511fiq4.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_1 = x_2 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kz/k1/nx/kzk1nxs0kiiib-e7toqe7y6svgo.png" alt="image"></div><br>  Slice function when <math> </math> $ inline $ x_2 = -x_1 $ inline $   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/6t/li/fi6tlik63nezfs9nkudl-_ofl5g.png" alt="image"></div><br>  The above function has minimum points: (-4, 0), (0, 0), (-3, 3), (2, 2), (-3, -4).  Global is the minimum at the point (-3, 3). <br><br><div class="spoiler">  <b class="spoiler_title">Code to generate an exponential potential function</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_tf_exponential_potential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: int, a: List[float], c: List[List[float]], p: List[List[float]], b: List[float])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :param n:   :param a: ,       :param c:   :param p:       :param b:      """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(x)): res = res + np.abs(x[j] - c[i][j]) ** p[i][j] res = (-b[i]) * np.exp((-a[i]) * res) value = value + res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func</code> </pre><br></div></div><br>  In addition to the above methods, harmonic functions can be used, however, their construction is a more complicated process.  And the main disadvantage is the inability to control all local minima.  You can also combine all of these methods to get even more complex functions. <br><br><h3>  Bibliography </h3><br>  Ruban A.I. Construction of multiextremal functions <br>  <a href="https://en.wikipedia.org/wiki/Test_functions_for_optimization">Wikipedia.</a>  <a href="https://en.wikipedia.org/wiki/Test_functions_for_optimization">Test functions for optimization</a> </div><p>Source: <a href="https://habr.com/ru/post/349660/">https://habr.com/ru/post/349660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349646/index.html">[Video] Speeches from the Yandex.Money PieMn mit about agile and coaching</a></li>
<li><a href="../349650/index.html">Continuous transitions between common elements: from RecyclerView to ViewPager</a></li>
<li><a href="../349652/index.html">How to make Java code simpler and clearer</a></li>
<li><a href="../349656/index.html">VLFs - Forgotten Enemy</a></li>
<li><a href="../349658/index.html">Case "Monitoring of the business loan portfolio of the bank with the help of three-dimensional visualization"</a></li>
<li><a href="../349662/index.html">We invite you to give lectures on the gaming industry on March 1 at VSBI</a></li>
<li><a href="../349664/index.html">HDR game analysis</a></li>
<li><a href="../349666/index.html">Overview lecture and the launch of the 2nd part of the course on the development of web services on Go</a></li>
<li><a href="../349668/index.html">Creating a company. Ideology - first</a></li>
<li><a href="../349672/index.html">Overview of the best European and not only QA conferences of this year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>