<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Review of physics in Sonic games. Part 1: hard tiles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator : this post is a translation of one of the parts of the large-scale physics review (Sonic Physics Guide) in the Sonic the Hedgehog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Review of physics in Sonic games. Part 1: hard tiles</h1><div class="post__text post__text-html js-mediator-article"><img width="640" src="https://habrastorage.org/files/b1c/806/fb5/b1c806fb5879485a8dc510ac19e49c25.png" alt="image"><br><br>  <b>From the translator</b> : this post is a translation of one of the parts of the large-scale physics review (Sonic Physics Guide) in the <i>Sonic the Hedgehog games</i> for Sega Genesis / Mega Drive and <i>Sonic CD</i> .  The following sections deal with such topics: running, jumping, spinning, loss of rings, underwater behavior, super speed, special features, camera, animations, and some others.  Since there are a lot of parts ( <a href="http://info.sonicretro.org/Sonic_Physics_Guide">14 pieces</a> ), I added a poll at the end of the post.  Is it worth it to continue - you decide. <br><a name="habracut"></a><br>  <b>Links to other parts of the series:</b> <br>  <a href="https://habrahabr.ru/post/276849/">Part 2: Running</a> <br>  <a href="https://habrahabr.ru/post/278373/">Parts 3 and 4: Jumping and Spinning</a> <br>  <a href="https://habrahabr.ru/post/305312/">Parts 5 and 6: the loss of rings and being under water</a> <br>  <a href="https://habrahabr.ru/post/306756/">Parts 7 and 8: springs and gizmos, super speeds</a> <br><br><ul><li>  <a href="https://habr.com/ru/post/276669/">1. Introduction</a> </li><li>  <a href="https://habr.com/ru/post/276669/">2 standing</a> </li><li>  <a href="https://habr.com/ru/post/276669/">3 Shot</a> </li><li>  <a href="https://habr.com/ru/post/276669/">4 Fall</a> </li><li>  <a href="https://habr.com/ru/post/276669/">5 Balancing on the edge</a> </li><li>  <a href="https://habr.com/ru/post/276669/">6 Ramps and curves</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">6.1 Masks of heights</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">6.1.1 Errors when using this method</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">6.2 Moving at angles</a> <ul><li>  <a href="https://habr.com/ru/post/276669/">6.2.1 Three variable speeds</a> </li><li>  <a href="https://habr.com/ru/post/276669/">6.2.2 Ramp factor</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">6.3 Jumping at angles</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">7 Mode switching</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">7.1 Four modes</a> </li><li>  <a href="https://habr.com/ru/post/276669/">7.2 Falling off walls and ceilings</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">7.2.1 Slipping back</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">8 State of being in the air</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">8.1 Airborne colliders</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">8.1.1 Horizontal collider</a> </li><li>  <a href="https://habr.com/ru/post/276669/">8.1.2 Vertical Colliders</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">8.2 Jumping "through" the floor</a> </li><li>  <a href="https://habr.com/ru/post/276669/">8.3 Land Re-Detection</a> <br><ul><li>  <a href="https://habr.com/ru/post/276669/">8.3.1 When driving down</a> </li><li>  <a href="https://habr.com/ru/post/276669/">8.3.2 When moving up</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/post/276669/">9 Reference: angle conversion</a> </li><li>  <a href="https://habr.com/ru/post/276669/">10 Notes</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Note</b> <br><br>  The article describes the collisions and interactions of Sonic with solid tiles.  Solid objects, such as monitors, moving platforms and blocks, have their own procedures for handling collisions with Sonic, which do not necessarily coincide with the behavior of solid tiles. <br><br><a name="Introduction"></a>  <b>Introduction</b> <br><br>  What are hard tiles?  In the zones (levels) of which Sonic games consist, there are a lot of solid objects, so the zone would require too much memory if the environment were entirely made up of solid objects, each of which occupies 64 bytes of RAM.  A smart move was made - the zone is created from tiles, so all that is required is to know whether the tile is solid (impenetrable) or not. <br><br>  You may know that the zones are divided into blocks of 128x128 pixels (or 256x256 pixels in <i>Sonic 1</i> and <i>Sonic CD</i> ), which, in turn, are divided into tiles of 16x16 pixels;  they are also broken into smaller tiles of 8x8 pixels.  All the magic of processing solid elements occurs at a 16x16 tile level, so in this review we will be interested only in them. <br><br>  Sonic's interactions and collisions with these hard tiles form the basic game engine.  They define the way to work with floors, walls, ceilings, ramps and hinges.  Since this is a voluminous and complex topic, my review will be different from other manuals on the physics of Sonic games, but I will try to limit the reasoning to a minimum. <br><br><a name="Standing"></a>  <b>Standing</b> <br><br><img width="128" src="https://habrastorage.org/files/63b/096/d15/63b096d15ce64c50803b0c07e92c07b4.PNG" alt="image"><br><br>  If we take the position of the earth on the Y axis equal to 736 ($ 02E0), then Sonic is standing above it in the coordinate 716 ($ 02CC).  This is 20 pixels above ground level. <br><br><a name="Pushing"></a>  <b>Pushing</b> <br><br>  Sonic should stop when hitting the wall.  This can be achieved by checking the line collision.  The collider line ( <i>from the translator: here and further in the article the term sensor is used, I chose, I think, an adequate analogue</i> ) should not be in its position on the Y axis, but slightly lower, otherwise it ‚Äúwill not notice‚Äù short steps.  She also can not be too low, otherwise she will "notice" the slopes and curves, from which Sonic should not make a start.  Its location in the Y + 4 coordinate from the location of Sonic is sufficient, because usually there are no stairs below 16 pixels in height (when there are such stairs, they consist of solid objects, and not tiles). <br><br>  How wide should the collider line be? <br><br><img width="256" src="https://habrastorage.org/files/fb3/4fa/b81/fb34fab81b7540c4a13668d134816ed5.PNG" alt="image"><br><br>  If we take the X coordinate of the left side of the wall to be 704 ($ 02C0), then Sonic should not be closer than 693 ($ 02B5).  If we take the X coordinate of the right side of the wall to be 831 ($ 033F), then Sonic should not be closer than 842 ($ 034A).  This is an 11 pixel difference in both directions. <br><br>  Therefore, the line of the collider must have a width of 20 pixels, and be stretched from X-10 to X + 10 of Sonic.  Every time a hard tile is detected, Sonic should be ‚Äúpushed out‚Äù by setting the coordinate of the tile minus (or plus) 11, and the speed of movement along the ground should be reset.  (It cannot be pushed out only 10 pixels, otherwise the point with coordinates X + 10 will still be inside the border pixel of the tile. A permanent collision will be registered and it will stick to the wall.) <br><br>  Since the border of the tile minus the position of Sonic should be 11, there are only 10 free pixels between the center of Sonic and the border of the tile.  The eleventh pixel from Sonic will be the very border of the tile.  Therefore, Sonic actually has a width of 20 pixels. <br><br><a name="Falling_Off"></a>  <b>The fall</b> <br><br>  Sonic should be able to run off the pads.  He cannot act like a coyote from Wile E. Coyote from cartoons, not noticing that there is nothing under him. <br><br><img src="https://habrastorage.org/files/46f/632/d19/46f632d1914b4baab5a01550b9fa0be8.jpg"><br><br>  This means that Sonic must also check for hard tiles below him.  This can be achieved by adding two more lines of colliders directed downwards.  One (A) should be on the left side of Sonic, at coordinate X-9.  The other (B) is on the right side, at X + 9.  They must begin with its position along the Y axis and descend not less than 16 pixels below its feet at ground level, which is located in Y + 20 (but not too low, or it will fall off when descending from low steps or stairs, we would not want to). <br><br>  If colliders A and B do not detect solid tiles, Sonic "falls" - a flag is set, informing the engine that it is in the air. <br><br>  We remember that when faced with walls Sonic has a width of 20 pixels.  However, earth detection colliders are only 18 pixels from the center.  It turns out that Sonic is ‚Äúthinner‚Äù by 2 pixels when running down from the pads than when hitting the walls. <br><br><a name="Balancing_On_Edges"></a>  <b>Edge balancing</b> <br><br>  Good detail - Sonic goes into the balancing animation, being close to the edge of the pad.  This happens only when he has stopped (his speed on the ground is 0). <br><br>  How does the engine know about this?  It's simple - at the moment when only one of the colliders is active, the Sonic is on the edge.  If A is active and B is not, then the pad is to the right of it.  Otherwise the playground is on the left. <br><br>  However, if Sonic starts to balance, as soon as one of the colliders finds anything, he will start balancing ‚Äúearly‚Äù and it will look silly.  Therefore, this happens when only one collider is active, <i>and</i> its position along the X axis is greater than the boundary of the solid tile detected by the active collider. <br><br><img width="384" src="https://habrastorage.org/files/58c/a73/e45/58ca73e4505f417190f6ca00371cb7bd.PNG"><br><br>  If we accept the coordinate of the right edge of the pad equal to 2655 ($ 0A5F), Sonic will begin to balance only at 2656 ($ 0A60).  It will fall at point 2665 ($ 0A69) when both colliders detect nothing. <br><br>  In <i>Sonic 2</i> and <i>Sonic CD,</i> if the pad is in the opposite direction from Sonic's view, then the second animation of balancing is turned on. <br><br>  In <i>Sonic 2</i> , <i>Sonic 3</i> and <i>Sonic &amp; Knuckles,</i> Sonic has a third balancing animation when he is even closer to the edge of the court.  Given the values ‚Äã‚Äãset above, it turns on when it is at coordinate 2662 ($ 0A66). <br><br>  Note: while balancing, some possibilities are not available (pressing to the ground, looking up, rotating, etc.).  In <i>Sonic 3 &amp; Knuckles, a</i> player can snuggle up to the ground and rotate (but not look up) when balancing on the ground, but not when balancing on an object. <br><br><a name="Slopes_And_Curves"></a>  <b>Ramps and curves</b> <br><br>  <i>Sonic the Hedgehog</i> was one of the first games to use curved surfaces and loops with a 360-degree turn.  In most games of that era, the environment was completely created from blocks (and sometimes from the slopes). <br><br>  The ability to work with smoothly changing shape objects is one of the fundamental aspects of the novelty and attractiveness of Sonic games.  Unfortunately, this is probably the most difficult aspect to recreate in fan games. <br><br>  How does it work? <br><br><a name="Height_Masks"></a>  <b>Height masks</b> <br><br>  Each time Collider A or B detects a solid tile, they return the height of that tile. <br><br>  How is the height of the tile? <br><br>  Each tile has an associated value associated with a mask stored in memory.  A mask is a simple array of 16 heights ranging from 0 ($ 00) to 16 ($ 10) and angle values. <br><br><img src="https://habrastorage.org/files/373/4d9/a45/3734d9a4540c4672b2c8b6d11ea5c12d.PNG"><br><br>  For example, this height mask has an array of heights 0 0 1 2 2 3 4 5 5 6 6 7 8 9 9 and an angle of 232 ($ 00 00 01 02 02 03 04 05 05 06 06 07 07 09 09 09 and an angle of $ E8). <br><br>  What is the value of the array of heights?  Subtract the position of the X tile from the position X of the collider.  The result will be the height index used by the array. <br><br>  If the height value found is 16 ($ 10), then the collider must check another tile higher than the first one found, and determine its height value. <br><br>  Whichever collider finds the greatest height, the Sonic Y coordinate is set equal to this height minus 20 pixels.  Its angle is also set to the angle of the solid tile that returned the greatest height. <br><br>  If the collider does not detect a solid tile, the leg level is returned by default (Y + 20). <br><br><a name="Bugs_Using_This_Method"></a>  <b>Errors when using this method</b> <br><br>  Unfortunately, due to the use of this method in the original engine there are a couple of annoying bugs. <br><br>  If Sonic is standing on an inclined platform, one of the colliders will not detect the tile, and will return the height of the legs.  This leads to the fact that Sonic is in the wrong position. <br><br><img width="384" src="https://habrastorage.org/files/f27/3a0/d63/f273a0d637b94b86ba53f4335e527d19.PNG"><br><br>  Sonic rises with Collider B when moving to the right.  When B ‚Äúfalls‚Äù off the landing, Sonic defaults to the level of collider A. Then he rises along with collider A as he continues to move to the right.  Therefore, he will first rise, fall and rise again when running down from the platform. <br><br>  There are only a few areas in which this is noticeable, but such a bug is present in all parts of the game for Genesis / Mega Drive, and it looks rather sloppy. <br><br>  The second bug occurs when there are two tiles of opposite slopes of one above the other, such as low hills at the levels of the <i>Green Hill Zone</i> and <i>Marble Zone</i> . <br><br><img width="384" src="https://habrastorage.org/files/75e/f48/446/75ef48446769422aaf8c6c7a74e51e82.PNG"><br><br>  Collider B begins to descend from the slope to the right, but Sonic still by default focuses on the level of the previous slope detected by collider A. Since such slopes are rather low, this results in lowering Sonic in the middle by about 1 pixel. <br><br>  But that is not all.  Sonic gets the angle data from the highest located collider, so even if it looks like he should be at the angle of the slope to the right (because he is closer to him), he will still have the angle of the slope to the left.  When jumping, he will jump at this angle, moving backwards, not forward, as expected. <br><br><a name="Moving_At_Angles"></a>  <b>Moving at angles</b> <br><br>  All this is very good and wonderful - Sonic moves smoothly over the surface with different heights.  However, the engine needs to do something else.  To be realistic, Sonic's speed should decrease on angled surfaces. <br><br>  There are two ways in which angles can affect the speed of Sonic.  The first one ensures that it does not run over a hill in the same time as on flat land of the same width.  The second slows it down when moving up the hill and speeds it up when moving down.  Let's look at each of them in turn. <br><br><a name="The_Three_Speed_Variables"></a>  <b>Three variable speeds</b> <br><br>  If Sonic were a normal platformer using only blocks, he would need only two variable speeds: movement along the X axis ( <i>Xsp</i> ) and along the Y axis ( <i>Ysp</i> ), the horizontal and vertical components of the speed of Sonic.  Acceleration ( <i>acc</i> ), deceleration ( <i>dec</i> ) and friction ( <i>frc</i> ) are added to <i>Xsp</i> ;  jump speed ( <i>jmp</i> ) and gravity ( <i>grv</i> ) are added to <i>Ysp</i> (when Sonic is in the air). <br><br>  However, when using slopes, when Sonic moves along the slope, it simultaneously moves horizontally and vertically.  This means that both <i>Xsp</i> and <i>Ysp</i> have nonzero values.  Simply adding <i>acc</i> , <i>dec</i> or <i>frc</i> to <i>Xsp</i> no longer works;  Imagine that Sonic is trying to run up the wall - adding to the horizontal speed will be useless, because he is trying to move up. <br><br>  The trick is to use the third variable speed (as the original engine does), let's call it the speed of movement on the ground ( <i>Gsp</i> ).  This is Sonic's speed along the ground, regardless of the angle.  The values <i>acc</i> , <i>dec</i> and <i>frc are</i> added to <i>Gsp</i> , not to <i>Xsp</i> or <i>Ysp</i> . <br><br>  When on the ground, <i>Xsp</i> and <i>Ysp</i> are extracted from <i>Gsp</i> at each step before moving Sonic.  I think an example in pseudocode would be appropriate here: <br><br><pre><code class="dos hljs">Xsp = Gsp*cos(angle); Ysp = Gsp*-sin(angle); X += Xsp; Y += Ysp;</code> </pre> <br>  Regardless of the change in the angle, the speed of <i>Gsp is</i> preserved, so the engine always knows with what speed Sonic is ‚Äútruly‚Äù moving. <br><br><a name="Slope_Factor"></a>  <b>Scat coefficient</b> <br><br>  Now Sonic can handle the interaction with any hills, keeping the exact speed.  However, it still needs to slow down when climbing and accelerate while descending. <br><br>  Fortunately, this is easily achieved by using the concept of a ramp coefficient ( <i>slp</i> ).  We simply add <i>slp</i> * sin ( <i>angle</i> ) to <i>Gsp</i> at the beginning of each step.  The value of <i>slp</i> when running is always equal to 0.125 ($ 0020), but differs during rotation.  When Sonic rotates, climbing up a hill (the sign of <i>Gsp is</i> not equal to the sign of sin ( <i>angle</i> )), <i>slp</i> is equal to 0.078125 ($ 001E).  When rotating down a hill (the sign of <i>Gsp</i> is equal to the sign of sin ( <i>angle</i> )) <i>slp</i> is 0.3125 ($ 0050). <br><br>  Note: it seems that in <i>Sonic 1 the</i> <i>slp</i> value <i>is</i> not added if the Sonic stops and is in the stand / wait cycle.  However, in <i>Sonic 3 &amp; Knuckles, the</i> value of <i>slp is</i> added even in this case, so Sonic cannot stand on steep slopes - he has to go backwards on them. <br><br><a name="Jumping_At_Angles"></a>  <b>Jumping at the corners</b> <br><br>  The angle at which Sonic stands at the moment of the jump also affects the jump.  He cannot simply assign <i>Ysp a</i> value of <i>jmp</i> , he needs to jump from the angle at which he stands.  Therefore, the <i>jmp</i> value needs to be assigned to both <i>Xsp</i> and <i>Ysp</i> , using cos () and sin () to get the correct values. <br><br>  A little more pseudocode: <br><br><pre> <code class="dos hljs">Xsp -= jmp*sin(angle); Ysp -= jmp*cos(angle);</code> </pre><br><a name="Switching_Mode"></a>  <b>Mode switching</b> <br><br>  So, Sonic can run on hills, slopes and grounds, and this is not bad.  But this is not enough.  He cannot travel from the ground to the walls and ceiling without an additional code. <br><br>  Why?  Land colliders A and B check for obstacles directly below them, finding the height of the ground.  They can not handle the transition to the walls, because the whole scheme is designed to move exactly up and down along the Y axis. <br><br>  How to solve this problem?  Using four different driving modes.  This requires a little explanation. <br><br><a name="The_Four_Modes"></a>  <b>Four modes</b> <br><br>  It is quite logical to assume that if Sonic can move 360 ‚Äã‚Äãdegrees, the engine handles all 360 degrees in about the same way.  In fact, the engine divides the angles into four quadrants, which greatly simplifies the work. <br><br>  For a better understanding of what I'm talking about, let's imagine a simpler platformer without complete loops, only with low hills and slopes.  All the character needs to do after the horizontal movement is to move up or down until he reaches the floor level.  Then you need to measure the angle of the floor.  Angle is used to lower <i>Gsp</i> , and nothing more.  The character will still always move horizontally and move strictly up and down to reach the floor level. <br><br>  Basically the same thing happens in games about Sonic.  Only if the angle gets too steep will Sonic change the ‚Äúquadrant‚Äù, switching from floor mode to right wall mode (then to ceiling mode, left wall, and back to floor mode, and so on).  At any given time and in any particular mode, Sonic behaves like a normal platformer.  Magic occurs when combining these four modes with cleverly made smooth switching between them. <br><br>  But how and when does Sonic switch between modes? <br><br>  If, while in floor mode, an angle greater than 224 ($ E0) is detected, the slider switches to the right wall mode.  Basically, everything remains the same, only the colliders check the right side instead of the bottom, and the Sonic moves to the ‚Äúfloor‚Äù level horizontally, not vertically. <br><br>  If, while in the right wall mode, an angle of less than 224 ($ E0) is detected, the slider switches back to the floor mode. <br><br>  Other transitions work in a similar way. <br><br>  A fair question may arise - where are the earth's colliders when we are in the right wall mode?  They are located there, but rotated 90 degrees.  Collider A is located relative to the center of Sonic in Y + 9 instead of X-9.  Collider B is in Y-9 instead of X + 9.  The collider lines become not vertical, but horizontal, stretching 16 pixels beyond the level of his legs (which is now 20 pixels ‚Äúlower‚Äù than Sonic, in the X + 20 coordinate). <br><br>  Yes, since the colliders are moving, Sonic can be ‚Äúpushed out‚Äù to a new position in the step where the mode is switched.  However, the movement is only a few pixels, and in the usual game completely unnoticed. <br><br>  Another aspect: as I said, solid tiles are made up of heights.  The key word here is "height."  How do they behave in the right wall mode?  Quite surprisingly, it turns out that in the original engine, each solid tile has two complementary array of heights;  one is used for horizontal and the other for vertical movement. <br><br>  What about left wall and ceiling modes?  Do not need four arrays of heights?  No, because tiles of such a form use ordinary heights, only inverted.  In ceiling mode, Sonic knows that the height value found should be used to move it down, not up. <br><br>  Thanks to these four modes, Sonic can move around all kinds of contours, internal and external curves, and so on.  Here are a couple of example images with angle values ‚Äã‚Äãthat will tell you what we are talking about: <br><br><img width="256" src="https://habrastorage.org/files/6ae/650/def/6ae650defe4849c29619c06406b5148b.PNG"><img width="144" src="https://habrastorage.org/files/828/e6e/3cf/828e6e3cfcee46a7b18a28ff5015c495.PNG"><br><br><img width="256" src="https://habrastorage.org/files/2f1/01f/08c/2f101f08c1e14516a53988921f8c1d40.PNG"><img width="144" src="https://habrastorage.org/files/97c/73f/ea6/97c73fea6a3940a2b650a90c81759139.PNG"><br><br><a name="Falling_Off_Of_Walls_And_Ceilings"></a>  <b>Falling off walls and ceilings</b> <br><br>  Being in the mode of the right wall, left wall or ceiling, Sonic falls when the absolute value of <i>Gsp</i> becomes lower than 2.5 ($ 0280) ( <i>Gsp</i> is equal to 0 at this moment, however <i>Xsp</i> and <i>Ysp</i> do not change, therefore Sonic can continue to move along its trajectory in the air ).  This happens even when there is earth beneath it. <br><br><a name="Sliding_Back_Down"></a>  <b>Slipping back</b> <br><br>  When Sonic falls as indicated above, the horizontal control lock timer is assigned a value of 31 ($ 1E) (the timer will not count down until Sonic touches the ground).  While the timer value is not zero, and Sonic is on the ground, he does not allow the player to change Sonic's speed with the "right" and "left" buttons.  The timer value is decremented by 1 with each step, so the lock lasts about half a second.  During this time, only the <i>slp</i> and the speed with which Sonic fell to the ground affect the movement, so Sonic will slide down the ramp. <br><br><a name="The_Air_State"></a>  <b>State of being in the air</b> <br><br>  When Sonic is in the air, no need to worry about the corners, <i>Gsp</i> , <i>slp</i> and so on.  All that is needed is to move using <i>Xsp</i> and <i>Ysp</i> until contact with the ground is detected, and then go to the ground mode. <br><br>  However, Sonic has an unusual set of colliders for movement in the air, which is worth considering in detail. <br><br><a name="Air_Sensors"></a>  <b>Airborne colliders</b> <br><br><a name="Horizontal_Sensor"></a>  <b>Horizontal collider</b> <br><br>  Sonic must hit the walls just as he does on the ground.  Therefore, there is a line of the horizontal collider, coming from its Y position and stretching from X-10 to X + 10.  When confronted with a hard tile, Sonic is ‚Äúpushed out‚Äù to the border of a tile plus / minus 11, just like being on the ground. <br><br>  The difference is that this line of the collider is wider than the vertical colliders A and B, which detect the presence of earth (we will return to them a little lower).  This means that the line of the horizontal collider can detect the block that Sonic flies past, even if he doesn't have an <i>Xsp</i> at all.  Therefore, it slips off solid objects when it strikes its outer edges. <br><br>  When Sonic detects a collision with this line of a horizontal collider, his <i>Xsp</i> is reset to zero only if he moves towards the wall, and not from it.  Otherwise, he would have stuck to the walls, flying past them. <br><br><a name="Vertical_Sensors"></a>  <b>Vertical Colliders</b> <br><br>  The colliders A and B of Sonic act in the air in about the same way as on the ground.  The difference is that when detecting a solid tile, Sonic's height is not immediately set to the height detected for the tile, minus 20 pixels.  Instead, such a height is set only when it is already below this height.  Otherwise he would have stuck to the floor as he approached him. <br><br>  If the colliders are stretched so much lower than his legs, why can't they discover the ground again in the step in which he jumps and not let him ever get off the floor?  It's simple: he ignores them, except for those moments when <i>Ysp</i> is equal to or greater than zero, so he only detects the earth when it moves down. <br><br>  Since the Sonic in the air can move both up and down, there must be two more colliders checking from above (C and D) so that he can hit the ceiling and the curves above it.  (C and D are exact mirror reflections of A and B - they have the same position X and length, only directed not down, but up.) Sonic detects ceilings and pushes them away, moving both up and down, unlike floors that show up only when moving down.  You can hit the ‚Äúceiling‚Äù (which is actually the bottom of the block) by moving down, leaning against a wall with a gap, or jumping to the side of the upper curve. <br><br><a name="Jumping_Through_Floors"></a>  <b>Jumps "through" the floor</b> <br><br>  There are platforms that Sonic can fly through through when jumping up.  They are often found in hilly green areas such as the <i>Green Hill Zone</i> , the <i>Emerald Hill Zone</i> , the <i>Palmtree Panic Zone</i> and so on.  Solid tiles that make up such sites are marked with a special type of engine, which can only be detected by colliders A and B. They are ignored by colliders C and D, as well as by the line of the horizontal collider. <br><br><a name="Reacquisition_Of_The_Ground"></a>  <b>Re-detection of land</b> <br><br>  When Sonic is on the ground, <i>Xsp</i> and <i>Ysp</i> are obtained from <i>Gsp</i> .  When it falls or is otherwise <i>lifted</i> from the ground, <i>Xsp</i> and <i>Ysp</i> already contain the necessary values ‚Äã‚Äãto continue the trajectory in the air.  But when Sonic lands, <i>Gsp</i> must be calculated from the <i>Xsp</i> and <i>Ysp</i> available at the time of landing.  You might think that cos () and sin () are used to get the exact value, but this is not true.  In fact, something much simpler happens, while the algorithms when hitting a curved ceiling and when landing on a curved ground differ, so I will consider them separately. <br><br><a name="When_Moving_Downward"></a>  <b>When moving down</b> <br><br>  If the angle of the detected earth is in the range of 240-255 ($ F0 ~ $ FF) (and their mirror reflections 0-15 ($ 00 ~ $ 0F)), <i>Gsp is</i> assigned the value <i>Xsp</i> .  If the angle is in the range of 224-239 ($ E0 ~ $ EF) (16-31 ($ 10 ~ $ 1F)), <i>Gsp is</i> assigned the value of <i>Xsp</i> , but only if the absolute value of <i>Xsp is</i> greater than <i>Ysp</i> .  Otherwise, <i>Gsp</i> is <i>Ysp</i> * 0.5 * -sign (cos ( <i>angle</i> )).  If the angle is in the range of 192-223 ($ C0 ~ $ DF) (32-63 ($ 20 ~ $ 3F)), <i>Gsp</i> is equal to <i>Xsp</i> if the absolute value of <i>Xsp is</i> greater than <i>Ysp</i> .  Otherwise, <i>Gsp is</i> assigned the value <i>Ysp</i> * -sign (cos ( <i>angle</i> )). <br><br><a name="When_Moving_Upward"></a>  <b>When moving up</b> <br><br>  If the angle of the detected ceiling is in the range of 160-191 ($ A0 ~ BF) (64-95 ($ 40 ~ $ 5F)), Sonic is attached to the ceiling, and <i>Gsp</i> takes the value <i>Ysp</i> * -sign (cos ( <i>angle</i> )).  If the angle is in the range of 96-159 ($ 60 ~ 9F), Sonic hits his head, as if it were a regular ceiling, and does not attach to it.  <i>Ysp</i> is reset, and <i>Xsp</i> does not change. <br><br><a name="Reference_Converting_Angles"></a>  <b>Help: Angle Conversion</b> <br><br>  Genesis / Mega Drive games use angles in hexadecimal format, from 0 ($ 00) to 255 ($ FF), so the circle is not divided into 360 parts, as we used to, but by 256. Worse, unlike angles in other languages, such as GML, they are counted counterclockwise, so 32 ($ 20) is not 45 ¬∞ as it should, but 315 ¬∞. <br><br>  To convert the original hexadecimal angles into angles that can be used in GML, use this formula (written in pseudocode): <br><br><pre> <code class="dos hljs">return (<span class="hljs-number"><span class="hljs-number">256</span></span>-hex_angle)*<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">40625</span></span>;</code> </pre><br><a name="Notes"></a>  <b>Notes</b> <br><br><ul><li>  Sonic can brake (‚Äúcreaking‚Äù with its feet) only in the floor mode. </li><li>  Sonic cannot jump if there is a low ceiling above him.  If a collision is detected in Y-25 with a collider line located from X-9 to X + 9, then Sonic will not start jumping. </li><li>  At different times, Sonic has different heights.  When he stands, runs, falls or takes off on a spring platform, he has a height of 40 pixels.  Its Y-axis position is always its center, so it always stands 20 pixels above the ground (and 20 pixels below the ceiling when it hits on them).  However, when jumping and rotating, it has a height of only 30 pixels, and is raised 15 pixels above the ground (and also lowered 15 pixels below the ceiling, etc.).  In the step in which the Sonic rotates or jumps, the slider adds 5 to its Y position, so despite the fact that it becomes shorter and its center changes position, the position of the lower point does not change.  When completing the rotation or landing after a jump, 5 pixels is subtracted from Y. The camera system must also take this offset into account, otherwise the appearance of the Sonic will also change. </li><li>  The colliders A, B, C, and D, described in this review, are located at coordinates X-9 and X + 9.  This is true only when walking, falling, pushing away from the spring platform, and so on - whenever it is not folded.  If Sonic rotates or jumps, they are in the coordinates X-7 and X + 7.  However, its line of the horizontal collider always remains the same. </li></ul><br><br>  <b>Update:</b> added decimal values. </div><p>Source: <a href="https://habr.com/ru/post/276669/">https://habr.com/ru/post/276669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276657/index.html">Undefined behavior is closer than you think.</a></li>
<li><a href="../276659/index.html">Live webcast of the Make Web conference, Not War from Montreal - February 5, Friday, at 17:00 (Moscow)</a></li>
<li><a href="../276661/index.html">Recommendations on stream</a></li>
<li><a href="../276663/index.html">Load testing from the cloud</a></li>
<li><a href="../276665/index.html">Is Tox as safe as it is painted?</a></li>
<li><a href="../276673/index.html">Monsieur, your problem solving skills are not up to par, or how I failed one interview</a></li>
<li><a href="../276675/index.html">Meet Apache Spark</a></li>
<li><a href="../276677/index.html">AI, BigData & HPC Digest # 4</a></li>
<li><a href="../276679/index.html">What's new Git 2.7 offers</a></li>
<li><a href="../276681/index.html">List of technical and IT conferences 2016. Part # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>