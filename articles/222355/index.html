<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Strategy (Translated from the English chapter of "Strategy" from the book "Pro Objective-C Design Patterns for iOS" by Carlo Chung)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do you remember when you last completed a block of code with many different algorithms and used spaghetti from if-else / switch-case conditions to det...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Strategy (Translated from the English chapter of "Strategy" from the book "Pro Objective-C Design Patterns for iOS" by Carlo Chung)</h1><div class="post__text post__text-html js-mediator-article"> Do you remember when you last completed a block of code with many different algorithms and used spaghetti from if-else / switch-case conditions to determine which one to use.  Algorithms could be a set of functions / methods of similar classes that solve similar problems.  For example, you have a procedure for validating input data.  The data itself can be of any type (for example, <code>CGFloat</code> , <code>NSString</code> , <code>NSInteger</code> , etc.).  Each data type requires different validation algorithms.  If you could encapsulate each algorithm as an object, then you could not use a group of if-else / switch-case statements to check the data and determine which algorithm is needed. <br><br><a name="habracut"></a>  In object-oriented programming, you can isolate related algorithms into different classes of strategies.  The design pattern that is used in such cases is called Strategy.  In this chapter, we will discuss the concepts and key features of the Strategy pattern.  We will also design and implement several classes for data validation in the form of strategies for validating the input of an <code>UITextField</code> text field <code>UITextField</code> later in this chapter. <br><br><h4>  What is the Strategy pattern? </h4><br>  One of the key roles in this pattern is played by the strategy class, which declares a common interface for all supported algorithms.  There are also specific classes of strategies that implement the algorithms using the strategy interface.  The context object is configured using an instance of a specific policy object.  The context object uses the strategy interface to invoke the algorithm defined in a particular strategy class.  Their relationships are illustrated in the class diagram in Figure 19-1. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e5e/215/fe0/e5e215fe0bde9685a7be87f0c5be60d0.png" alt="image"><br>  <b>Figure 19-1.</b>  Class structure structure Strategy <br><br>  A group or hierarchy of related algorithms in the form of <code>ConcreteStrategy</code> classes (A, B, and C) share a common <code>algorithmInterface</code> , so the <code>Context</code> can access different variants of the algorithms using the same interface. <br><br>  Note.  <b>Pattern Strategy</b> : defines a family of algorithms, encapsulates each of them, and makes them interchangeable.  The strategy allows algorithms to change independently of the customers who use them. * <br><br>  The original definition given in GoF‚Äôs Design Patterns (Addison-Wesley, 1994). <br><br>  <code>Context</code> Instance can be configured using various <code>ConcreteStrategy</code> objects at run time.  This can be viewed as a change in the "insides" of the <code>Context</code> object, since changes occur from within.  Decorators (see Chapter 16, the Decorator pattern and my previous article), in contrast, change the "skin" of the object, since the modifications dock from the outside.  Please refer to the section ‚ÄúChanging the" skin "of an object compared to changing the" viscera "in Chapter 16 (previous article) for more detailed information about the differences. <br><br>  <b>Pattern Strategy in Model-View-Controller</b> <br><br>  In the Model-View-Controller pattern, the controller determines when and how the view displays the data contained in the model.  The view itself knows how to display something, but does not know that, as long as the controller does not indicate it.  Working with another controller, but with the same appearance, the format of the output data may be the same, but the data types may be different according to different conclusions from the new controller.  The controller in this case is a strategy for the object of the species.  As we mentioned in previous chapters, the relationship between the controller and the view is based on the Strategy pattern. <br><br><h4>  When is the use of the Strategy pattern appropriate? </h4><br>  Using this pattern is advisable in the following cases: <br><br><ul><li>  Class logic uses many conditional operators to select the desired behavior.  You can move the conditional code to a separate strategy class. </li><li>  You need different variants of the algorithm. </li><li>  You would not want to expose complex and narrowly specific data structures (clients). </li></ul><br><h4>  Using data validation strategies using the example of the UITextField class </h4><br>  Let's create a simple example of implementing the Strategy pattern in the application.  Suppose we need some <code>UITextField</code> object in our application that accepts user input;  we will use the input results in our application later.  We have a text entry field that accepts only letters, that is, a ‚Äì z or A ‚Äì Z, and we also have a field that accepts only numeric data, that is, 0‚Äì9.  To make sure that the input in the fields is correct, each of them needs to have some kind of on-site data validation procedure that runs after the user finishes editing. <br><br>  We can put the necessary data validation into the <code>UITextField</code> delegate object method, <code>textFieldDidEndEditing:</code>  An instance of <code>UITextField</code> calls this method every time it loses focus.  In this method we can make sure that only numbers are entered in the numeric field, and only letters are entered in the letter field.  This method accepts as input a link to the current input field object (as a <code>textField</code> parameter), but which of these two objects exactly? <br><br>  Without the STRAGUE pattern, we would come up with code similar to that shown in Listing 19-1. <br><br>  <b>Listing 19-1.</b>  Typical script to check the contents of a UITextField in the delegate method of textFieldDidEndEditing <br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)textFieldDidEndEditing:(<span class="hljs-built_in"><span class="hljs-built_in">UITextField</span></span> *)textField { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textField == numericTextField) { <span class="hljs-comment"><span class="hljs-comment">//  [textField text]  , //    } else if (textField == alphaTextField) { //  [textField text]  , //      } }</span></span></code> </pre><br><br>  Of course, there can be more conditional statements if there are more input fields for different data.  We could make the code more manageable if we got rid of all these conditional expressions, which could greatly simplify our life in the future with the support of the code. <br><br>  Tip: If there are many conditional statements in your code, this may mean that they need to be refactored and separated into separate objects of the Strategy. <br><br>  Now our goal is to take on this verification code and scatter it across various classes of Strategies so that it can be reused in the delegate and other methods.  Each of our classes takes a string from the input field, then checks it based on the required strategy, and finally returns a value of type <code>BOOL</code> and an instance of <code>NSError</code> if the check failed.  The returned <code>NSError</code> object will help determine why the check was not successful.  Since the verification of both numeric and alphabetic inputs are related to each other (they have the same type of input and output), they can be combined with one interface.  Our set of classes is shown in the class diagram in Figure 19-2. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45a/a5f/87b/45aa5f87b9b511e4b60289c8717e9db5.png" alt="image"><br>  <b>Figure 19‚Äì2.</b>  The class diagram shows the relationship between the CustomTextField and its associated strategies. <br><br>  We will declare this interface not as a protocol, but as an abstract base class.  The abstract base class is more convenient in this case, because it is easier to refactor the behavior common to all specific classes of strategies.  Our abstract base class will look like Listing 19‚Äì2. <br><br>  <b>Listing 19‚Äì2.</b>  Class declaration InputValidator in InputValidator.h <br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputValidator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//      - (BOOL) validateInput:(UITextField *)input error:(NSError **) error; @end</span></span></code> </pre><br><br>  The <code>validateInput: error:</code> method takes a link to a <code>UITextField</code> as an input parameter, so it can check everything in the input field and return the <code>BOOL</code> value as a result of the check.  The method also accepts a reference to a pointer to an <code>NSError</code> .  When an error occurs (that is, the method could not verify the input), the method will create an instance of <code>NSError</code> and assign it to a pointer, therefore, in whatever context the verification class is used, it is always possible to get more detailed error information from this object. <br><br>  The default implementation of this method only sets the error pointer to <code>nil</code> and returns <code>NO</code> , as shown in Listing 19-3. <br><br>  <b>Listing 19‚Äì3.</b>  The default implementation of the class InputValidator in InputValidator.m <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InputValidator.h"</span></span></span><span class="hljs-meta"> @implementation InputValidator //      - (BOOL) validateInput:(UITextField *)input error:(NSError **) error { if (error) { *error = nil; } return NO; } @end</span></span></code> </pre><br><br>  Why we did not use <code>NSString</code> as an input parameter?  In this case, any action inside the strategy object will be one-sided.  This means that the validator will simply do the check and return the result without modifying the original value.  With an input parameter of type <code>UITextField</code> we can combine the two approaches.  Our scan objects will be able to change the original value of the text field (for example, by deleting the wrong characters) or simply view the value without changing it. <br><br>  Another question - why don't we just throw an <code>NSException</code> exception if the check fails?  This is because throwing your own exception and intercepting it in a try-catch block in the Cocoa Touch framework is a very resource-intensive operation and is not recommended (but try-catch system exceptions are another matter).  It is relatively cheaper to return an <code>NSError</code> object, as recommended in the Cocoa Touch Developer's Guide.  If we look at the Cocoa Touch framework documentation, we notice that there are many APIs that return an instance of <code>NSError</code> when an abnormal situation occurs.  A common example is one of the <code>NSFileManager</code> methods, <code>(BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error</code> .  If an error occurs, when <code>NSFileManager</code> tries to move a file from one place to another, it will create a new instance of <code>NSError</code> that describes the problem.  The caller may use the information contained in the returned <code>NSError</code> object for further error handling.  Thus, the purpose of the <code>NSError</code> object in our method is to provide information about a failure in operation. <br><br>  Now we have defined how a good input validation class should behave.  Now we can do the creation of this verifier.  Let's first create the one for entering numbers, as shown in Listing 19-4. <br><br>  <b>Listing 19‚Äì4.</b>  NumericInputValidator class declaration in NumericInputValidator.h <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InputValidator.h"</span></span></span><span class="hljs-meta"> @interface NumericInputValidator : InputValidator { } //  ,  ,     // ,   0-9 - (BOOL) validateInput:(UITextField *)input error:(NSError **) error; @end</span></span></code> </pre><br><br>  <code>NumericInputValidator</code> inherits from the abstract base class <code>InputValidator</code> and overrides its <code>validateInput: error:</code> method.  We declare the method again to emphasize that this subclass implements or redefines it.  This is not mandatory, but is good practice. <br><br>  The implementation of the method is shown in Listing 19-5. <br><br>  <b>Listing 19-5.</b>  Implementing the NumericInputValidator Class in NumericInputValidator.m <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"NumericInputValidator.h"</span></span></span><span class="hljs-meta"> @implementation NumericInputValidator - (BOOL) validateInput:(UITextField *)input error:(NSError**) error { NSError *regError = nil; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"^[0-9]*$"</span></span></span><span class="hljs-meta"> options:NSRegularExpressionAnchorsMatchLines error:¬ÆError]; NSUInteger numberOfMatches = [regex numberOfMatchesInString:[input text] options:NSMatchingAnchored range:NSMakeRange(0, [[input text] length])]; //   , //     NO if (numberOfMatches == 0) { if (error != nil) { NSString *description = NSLocalizedString(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Input Validation Failed"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); NSString *reason = NSLocalizedString(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The input can contain only numerical values"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); NSArray *objArray = [NSArray arrayWithObjects:description, reason, nil]; NSArray *keyArray = [NSArray arrayWithObjects:NSLocalizedDescriptionKey, NSLocalizedFailureReasonErrorKey, nil]; NSDictionary *userInfo = [NSDictionary dictionaryWithObjects:objArray forKeys:keyArray]; *error = [NSError errorWithDomain:InputValidationErrorDomain code:1001 userInfo:userInfo]; } return NO; } return YES; } @end</span></span></code> </pre><br><br>  The implementation of the <code>validateInput:error:</code> method focuses mainly on two aspects: <br><br><ol><li>  It checks the number of coincidences of numerical data in the input field with the previously created <code>NSRegularExpression</code> object.  The regular expression we used is ‚Äú^ [0‚Äì9] * $‚Äù.  It means that from the beginning of the entire line (indicated by ‚Äú^‚Äù) and the end (indicated by ‚Äú$‚Äù), there must be more or more characters (indicated by ‚Äú*‚Äù) from the set that contains only numbers (indicated by ‚Äú[0‚Äì9] "). </li><li>  If there is no match at all, it creates a new <code>NSError</code> object that contains the message ‚ÄúThe input can contain only numerical values‚Äù and assigns it to the input pointer to the <code>NSError</code> .  It then finally returns a <code>BOOL</code> value indicating the success or failure of the operation.  The error is associated with the special code 1001 and the specific value of the error domain, defined in the header file of the <code>InputValidator</code> class <code>InputValidator</code> approximately as shown below: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InputValidationErrorDomain = <span class="hljs-string"><span class="hljs-string">@"InputValidationErrorDomain"</span></span>;</code> </pre></li></ol><br>  The brother of the <code>NumericInputValidator</code> class, which checks for the presence of only letters in the input, called <code>AlphaInputValidator</code> , contains a similar algorithm for checking the content of the input field.  <code>AlphaInputValidator</code> overrides the same method as <code>NumericInputValidator</code> .  Obviously, this algorithm verifies that the input string contains only letters, as shown in Listing 19-6. <br><br>  <b>Listing 19-6.</b>  Implementing the AlphaInputValidator Class in AlphaInputValidator.m <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AlphaInputValidator.h"</span></span></span><span class="hljs-meta"> @implementation AlphaInputValidator - (BOOL) validateInput:(UITextField *)input error:(NSError**) error { NSError *regError = nil; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"^[a-zA-Z]*$"</span></span></span><span class="hljs-meta"> options:NSRegularExpressionAnchorsMatchLines error:¬ÆError]; NSUInteger numberOfMatches = [regex numberOfMatchesInString:[input text] options:NSMatchingAnchored range:NSMakeRange(0, [[input text] length])]; //   , //     NO if (numberOfMatches == 0) { if (error != nil) { NSString *description = NSLocalizedString(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Input Validation Failed"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); NSString *reason = NSLocalizedString(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The input can contain only letters"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">); NSArray *objArray = [NSArray arrayWithObjects:description, reason, nil]; NSArray *keyArray = [NSArray arrayWithObjects:NSLocalizedDescriptionKey, NSLocalizedFailureReasonErrorKey, nil]; NSDictionary *userInfo = [NSDictionary dictionaryWithObjects:objArray forKeys:keyArray]; *error = [NSError errorWithDomain:InputValidationErrorDomain code:1002 userInfo:userInfo]; } return NO; } return YES; } @end</span></span></code> </pre><br><br>  Our class <code>AlphaInputValidator</code> also a type of <code>InputValidator</code> and implements the <code>validateInput:</code> method.  It has a brother- <code>NumericInputValidator</code> , a code structure and algorithm, except that it uses another regular expression in the <code>NSRegularExpression</code> object, and the error code and message are specific to literal checking.  The regular expression we use to test the letters is ‚Äú^ [a-zA-Z] * $‚Äù.  It is similar to the expression for his fellow numeric checker, except that the set of valid characters contains letters of both lower and upper case.  As we can see, in both versions a lot of duplicate code.  Both algorithms have a similar structure;  you can refactor a structure into a template method (see chapter 18) into an abstract base class.  Specific subclasses of <code>InputValidator</code> can override the primitive operations defined in <code>InputValidator</code> to return unique information to the template algorithm ‚Äî for example, a regular expression and various construction attributes of an <code>NSError</code> object, etc. I will leave this to you as an exercise. <br><br>  We now have test classes ready for use in the application.  However, <code>UITextFiel</code> d does not know about them, so we need our own version of <code>UITextField</code> , which understands everything.  We will create a subclass of <code>UITextField</code> that contains a reference to <code>InputValidator</code> and a <code>validate</code> method, as shown in Listing 19-7. <br><br>  <b>Listing 19-7.</b>  Class declaration CustomTextField in CustomTextField.h <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InputValidator.h"</span></span></span><span class="hljs-meta"> @interface CustomTextField : UITextField { @private InputValidator *inputValidator_; } @property (nonatomic, retain) IBOutlet InputValidator *inputValidator; - (BOOL) validate; @end</span></span></code> </pre><br><br>  <code>CustomTextField</code> contains a property that holds ( <code>retain</code> ) a reference to <code>InputValidator</code> .  When its <code>validate</code> method is called, it uses a reference to <code>InputValidator</code> to start the validation.  We can see this in the implementation shown in Listing 19-8. <br><br>  <b>Listing 19-8.</b>  Implementing the CustomTextField class in CustomTextField.m <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CustomTextField.h"</span></span></span><span class="hljs-meta"> @implementation CustomTextField @synthesize inputValidator=inputValidator_; - (BOOL) validate { NSError *error = nil; BOOL validationResult = [inputValidator_ validateInput:self error:&amp;error]; if (!validationResult) { UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:[error localizedDescription] message:[error localizedFailureReason] delegate:nil cancelButtonTitle:NSLocalizedString(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"OK"</span></span></span><span class="hljs-meta">, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">) otherButtonTitles:nil]; [alertView show]; [alertView release]; } return validationResult; } - (void) dealloc { [inputValidator_ release]; [super dealloc]; } @end</span></span></code> </pre><br><br>  In the <code>validate</code> method, a message is sent <code>[inputValidator_ validateInput:self <br> error:&amp;error]</code> <code>[inputValidator_ validateInput:self <br> error:&amp;error]</code>  <code>[inputValidator_ validateInput:self <br> error:&amp;error]</code> <code>inputValidator_</code> link.  The beauty of the pattern is that <code>CustomTextField</code> does not need to know what type of <code>InputValidator</code> it uses or any details of the algorithm.  Therefore, if in the future we add some new <code>InputValidator</code> , the <code>CustomTextField</code> object will use the new <code>InputValidator</code> as well. <br><br>  So, all the preparatory work done.  Suppose the client is a <code>UIViewController</code> , which implements the <code>UITextFieldDelegate</code> protocol and contains two <code>IBOutlets</code> type <code>CustomTextField</code> , as shown in Listing 19‚Äì9. <br><br>  <b>Listing 19‚Äì9.</b>  Declaring the StrategyViewController class in StrategyViewController.h <br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"NumericInputValidator.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"AlphaInputValidator.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CustomTextField.h"</span></span></span><span class="hljs-meta"> @interface StrategyViewController : UIViewController </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UITextFieldDelegate&gt;</span></span></span><span class="hljs-meta"> { @private CustomTextField *numericTextField_; CustomTextField *alphaTextField_; } @property (nonatomic, retain) IBOutlet CustomTextField *numericTextField; @property (nonatomic, retain) IBOutlet CustomTextField *alphaTextField; @end</span></span></code> </pre><br><br>  We decided to allow the controller to implement the delegate <code>(void)textFieldDidEndEditing:(UITextField *)textField</code> and put the check there.  This method will be called each time the value in the input field changes and the focus is lost.  When the user finishes input, our <code>CustomTextField</code> class will call this delegate method, illustrated in Listing 19-10. <br><br>  <b>Listing 19-10.</b>  Client code defined in the textFieldDidEndEditing: delegate method that validates the CustomTextField instance using a strategy object (InputValidator) <br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategyViewController</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">synthesize</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">numericTextField</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alphaTextField</span></span></span><span class="hljs-class">; // ... //    // ... #</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pragma</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mark</span></span></span><span class="hljs-class"> - #</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pragma</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mark</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITextFieldDelegate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">methods</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textFieldDidEndEditing</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITextField</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">textField</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([textField isKindOfClass:[CustomTextField <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]]) { [(CustomTextField*)textField validate]; } } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br><br>  When calling <code>textFieldDidEndEditing:</code> when editing in one of the fields is completed, the method checks that the <code>textField</code> object belongs to the <code>CustomTextField</code> class.  If so, he sends a <code>validate</code> message to him to start the process of checking the entered text.  As we can see, we no longer need these conditional statements.  Instead, we have a much simpler code for the same purpose.  Except for the additional verification that the <code>textField</code> object is a <code>CustomTextField</code> type, there is nothing more complicated. <br><br>  But wait a minute.  Something doesn't look good.  How could we assign the correct <code>InputValidator numericTextField_</code> and <code>alphaTextField_</code> defined in <code>StrategyViewController</code> ?  Both input fields are declared as <code>IBOutlet</code> in Listing 19‚Äì9.  We can pick them up in the Interface Builder view controller through <code>IBOutlet</code> , as we do with other buttons and so on.  Similarly, in the declaration of the <code>CustomTextField</code> class in Listing 19-7, its <code>inputValidator</code> property <code>inputValidator</code> also <code>IBOutlet</code> , which means that we can assign an instance of <code>InputValidator</code> to the <code>*TextField</code> object in Interface Builder, too.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, everything can be constructed by using Interface Builder reference connections if you declare certain class properties as </font></font><code>IBOutlet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For a more detailed discussion of how to use custom Interface Builder objects, refer to ‚ÄúUsing </font></font><code>CoordinatingController</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface Builder‚Äù in Chapter 11, which talks about the Mediator pattern.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we discussed the concepts of the Strategy pattern and how this pattern can be used for clients to use various related algorithms. </font><font style="vertical-align: inherit;">An example of the implementation of input checks for custom </font></font><code>UITextField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shows how various validation classes can change the "insides" of an object. </font><font style="vertical-align: inherit;">Pattern Strategy is somewhat similar to the Pattern Decorator (Chapter 16 and my previous article). </font><font style="vertical-align: inherit;">Decorators extend the object's behavior from the outside while various strategies are encapsulated inside the object. </font><font style="vertical-align: inherit;">As they say, decorators change the "skin" of the object, and strategies - "insides". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next chapter we will see another pattern, which is also associated with the encapsulation of algorithms. </font><font style="vertical-align: inherit;">The encapsulated algorithm is mainly used for deferred execution of a command as a separate object.</font></font></div><p>Source: <a href="https://habr.com/ru/post/222355/">https://habr.com/ru/post/222355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222337/index.html">Bleeding Heart Status: Upgrade to Broken</a></li>
<li><a href="../222343/index.html">Cross compilation of libraries under iOS, doing it right</a></li>
<li><a href="../222345/index.html">Two projects of mass online collaboration</a></li>
<li><a href="../222347/index.html">Headset AfterShokz Bluez. Sound directly to the brain</a></li>
<li><a href="../222353/index.html">Comprehensive analytics of an online project using Google Analytics and Google Docs</a></li>
<li><a href="../222357/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ108 (May 4 - 10, 2014)</a></li>
<li><a href="../222359/index.html">Simpson's Paradox in Mobile Analytics</a></li>
<li><a href="../222367/index.html">Microsoft and Adobe released a set of updates, May 2014</a></li>
<li><a href="../222371/index.html">Machu Picchu and the faraway Google office</a></li>
<li><a href="../222373/index.html">Organized freelance. Part 2. Artists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>