<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qlie visual story engine disassembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Amateur translation of visual stories, when compared with translations of other games, has a number of features and involves working with a large amou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qlie visual story engine disassembly</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/sq/zf/bbsqzfse3pqjvnyef8jnfv3lecy.png"></div><br><br>  Amateur translation of visual stories, when compared with translations of other games, has a number of features and involves working with a large amount of text.  Perhaps the overwhelming majority of all visual novels were released in Japanese, only a few were translated into English (officially or by amateurs), and even less were translated into other languages. <br><br>  Therefore, when working with translation, one has to deal with Japanese engines, many of which are not very friendly to localizers.  Because of this, it quickly comes to the realization that the availability of translation skills, language skills, great enthusiasm and free time does not mean that the translated version of the game will soon be released. <br><a name="habracut"></a><br>  Very roughly, the translation process of any game (not only visual stories) implies: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Unpacking game resources (if they are not publicly available) </li><li>  Translation of the necessary parts </li><li>  Reverse packing transfer </li></ul><br>  However, in the case of Japanese visual novels, this usually looks like this: <br><br><ul><li>  Unpacking game resources </li><li>  Translation of the text part of the game (game script) </li><li>  Translation of the graphic part of the game </li><li>  Reverse packing transfer </li><li>  Engine redesign to make it work with translated content </li></ul><br>  I hope our experience will be useful for someone. <br><br>  Back in 2013 (and possibly earlier), I decided to translate the Bishoujo Mangekyou -Norowareshi Densetsu no Shoujo- visual novel from Japanese (美少女  華 鏡 呪 呪 少女)) from Japanese.  I already had experience in translating games, but before I had to translate only short stories on relatively simple and well-known engines like <a href="http://kirikirikag.sourceforge.net/contents/index.html">Kirikiri</a> . <br><br>  Here, our team of translators had to open the engine of this novel, even before getting to the actual text itself. <br><br>  Let's start with the description of the .exe file, where the words QLIE and IMOSURUME are mentioned.  The file itself contains the string FastMM Borland Edition 2004, 2005 Pierre le Riche, which means the engine is most likely written in Delphi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ss/sg/kxsssg_foyhzeykfu1e4s5pneok.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/ge/zc/zogezc8m47t1cflh-yqpzl85fby.png"></div><br>  With a quick google it is possible to find out that Qlie is the name of the visual novel engine released by Warmth Entertainment.  Apparently, IMOSURUME is the internal name of the script engine, and Qlie is a commercial name.  There is a site <a href="http://qlie.net/">qlie.net</a> , which lists the games released on this engine and the official site of the company Warmth Entertainment. <br><br>  But nowhere in the public domain there are neither official tools for working with the engine, nor documentation for it, which is expected. <br><br>  Therefore, you have to deal with the game yourself, relying on unofficial utilities.  To get started is to find all the parts of the game that will need to be translated. <br><br>  Game archives are in the data0.pack, data1.pack, and data7.pack files in the \ GameData subfolder.  The screensavers are in the \ GameData \ Movie folder, but you can still not touch them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/fh/on/grfhont7xq1rascbvzu8v1mhkec.png"></div><br>  The hex editor shows that there are no recognizable headers for the game .pack archives, but at the end of the file there is a piece similar to the table of contents and the FilePackVer3.0 label <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yf/qd/1q/yfqd1qyy7ozx0ygvq_bj_tmkms4.png"></div><br>  Fortunately, there is already a unpacker for this format and not even one.  We used the console exfp3_v3 from asmodean. <br><br>  Unpacking is not as simple as it may seem.  Since the engine supports several archive formats (FilePackVer1.0, FilePackVer1.0, FilePackVer3.0), and in this case, FilePackVer3.0 is used, for special unpacking you also need a special key file key.fkey, which encrypts the archive.  It is located in the \ Dll subfolder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/fq/qe/fafqqeqgfwisqr1ijhg9qpcmsm4.png"></div><br>  In addition, exfp3_v3 should clarify the archive from which particular game it is unpacking. <br>  Therefore, you also need to specify the number of the game from the list offered by the unpacker (Bishoujo Mangekyou games there at number 15), or specify the executable file of the game as the third parameter for the unpacker. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/nr/-z/9rnr-zngqxajz8pysxwv3v8u8gk.png"></div><br>  Already after unpacking the game files, a logical thought appeared: how to pack the game in the future with a ready translation?  After all, the unpacker does not support reverse operation. <br>  At our request, w8m (thanks a lot to him for this) added arc_conv.exe to his program to pack game archives.  It is enough to pack all the modified files into a new archive (for example, data8.pack), place it in the GameData folder, and they will automatically pull themselves up into the game. <br><br>  Let's return to the unpacked resources.  The game scenario files from the data0.pack archive can be found in the \ scenario \ ks_01 \ subfolder <br><br>  All script files with the .s extension are encoded in the far from the most convenient Shift Jis encoding, and the engine does not support any Unicode encodings.  Strings to translate look something like this: <br><br><pre><code class="python hljs">【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1478％ 「へえ……分かっているじゃない」 私が献上したロシアンティーを見て、キリエは嬉しそうに目を細める。 ^cface,,赤目微笑<span class="hljs-number"><span class="hljs-number">01</span></span> 【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1479％ 「日本人は、ジャムを紅茶に入れて飲むのが、ロシアンティーだと勘違いしている人が多いのだけれど……」</code> </pre> <br>  You can see that each phrase in Japanese is preceded by the name of the hero in Japanese brackets.  (【】), Which this phrase is pronounced (in the game it is displayed in the upper part of the window with the text).  Or, if these are the words of the author, the name is not added. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/d_/dz/wsd_dzwzrz-sjk_0shl7zw3ov5k.png"></div><br>  But there are still service teams. <br><br>  The engine commands in the script are somewhat reminiscent of the TeX markup language, but are much more <a href="http://kirikirikag.sourceforge.net/contents/index.html">unintuitive</a> and inconvenient compared to the <a href="http://kirikirikag.sourceforge.net/contents/index.html">Kirikiri</a> or <a href="https://www.renpy.org/">RenPy commands</a> . <br><br>  Here are some of them: <br><br>  <code>@@@</code> is a triple dog.  Often script files begin with this command.  Apparently, loading definitions from third-party files. <br><br>  For example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@@Library\Avg\header.s</span></span></code> </pre> <br>  <code>@@</code> is a double dog.  Label in the script file.  You can go to it later. <br><br>  <code>％1_kiri1478％</code> - play the voice file.  These commands are inserted between the name of the hero and the text that is displayed on the screen.  “1_kiri1478” - in this case, the file name from the \ voice \ folder of the data1.pack file. It is interesting that the Japanese percent (％) is used in the command, and not the usual one. <br><br>  <code>^savedate, ^saveroute, ^savescene,</code> are the three teams that are most likely used in the game's save system and must enter the save information on the place and time of the player’s save. <br><br>  For example: <br><br><pre> <code class="python hljs">^savedate,<span class="hljs-string"><span class="hljs-string">"現在"</span></span> ^saveroute,<span class="hljs-string"><span class="hljs-string">"美少女万華鏡－１－"</span></span> ^savescene,<span class="hljs-string"><span class="hljs-string">"呪われし伝説の少女 オープニング"</span></span></code> </pre> <br>  That is, date: present moment, branch: Bishoujo Mangekyou -1-, scene: Norowareshi Densetsu no Shoujo Opening.  This data should have been displayed in the save slot, but apparently the developers decided to refuse it.  As a result, <code>^saveroute</code> in all parts of the scenario, <code>^savedate</code> changes from “present moment” to “daydreaming”, and in-game days (in-game nights) change. <br><br>  <code>^facewindow,</code> - the state of the textbox with text displayed on the screen.  (Shown - 1 or not - 0) <br><br>  <code>^sload,</code> - playing in-game sounds from the \ sound \ folder on the corresponding channel. <br><br><pre> <code class="python hljs">sload,Env1,◆セミ<span class="hljs-number"><span class="hljs-number">01</span></span>アブラゼミ</code> </pre> <br>  Playing cicada sound on Env1 channel <br><br>  The team has two optional parameters, the first is responsible for the looping of the sound, and the second is still a mystery, but it is rarely used in the game. <br><br><pre> <code class="python hljs">^sload,SE1,■クチュ音<span class="hljs-number"><span class="hljs-number">01</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Playing a looped sound on channel SE1. <br><br>  <code>^eeffect</code> - output a special effect for a certain number of seconds.  Apparently, supports consistent output of several effects. <br><br><pre> <code class="python hljs">^eeffect,WhiteFlash</code> </pre> <br>  The effect of a white flash. <br><br>  <code>^ffade</code> - transition effect when changing screen. <br>  It has a whole bunch of additional parameters, but only a few are really useful: the name of the transition effect, an additional picture, if it is required, and the transition time. <br><br><pre> <code class="python hljs">^ffade,Overlap,,<span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Dissolving of one picture in another, in 1 second. <br><br>  <code>^iload</code> - download background image on the screen.  You can assign an id to an image to access it in the future. <br><br><pre> <code class="python hljs">^iload,BG1,<span class="hljs-number"><span class="hljs-number">0</span></span>_black.png</code> </pre> <br>  Output file 0_black.png as background with id BG1 <br><br>  <code>^we</code> and <code>^wd</code> - turn on and off the image in the window. <br><br>  <code>^facewindow,1</code> and <code>^facewindow,0</code> Turns on and off the image of the hero in the dialog box. <br><br>  <code>^mload</code> - playing music on a specific channel. <br><br><pre> <code class="python hljs">^mload,BGM1,nbgm13</code> </pre> <br>  Playing the track nbgm13 on channel BGM1 <br><br>  Some of the most important teams are: <br>  <code>\jmp</code> - go to the label with the specified name. <br><br>  <code>^select</code> - displays a selection window on the screen where the player must select one of the options. <br><br>  For example: <br><br><pre> <code class="python hljs">^select, ,  \jmp,<span class="hljs-string"><span class="hljs-string">"@@route01a"</span></span>+ResultBtnInt[<span class="hljs-number"><span class="hljs-number">0</span></span>] @@route01a0</code> </pre> <br>  Here the transition will be performed after answering the question, and the answer number (0 or 1) is returned from ResultBtnInt [0].  As a result, <code>\jmp</code> move the narration to the @@ route01a tag + answer number.  That is, @@ route01a0 or @@ route01a1 <br><br>  The unpleasant feature is that the usual comma in these commands serves as a separator and cannot be used in the answer variants themselves.  The Japanese have no such problem, they use the Japanese comma (、).  In this case, we can replace the comma with ‚(U + 201A SINGLE LOW-9 QUOTATION MARK). <br><br>  For example: <br><br><pre> <code class="python hljs">^select, ‚  , ‚ </code> </pre> <br>  The remaining teams are not so important in the first approximation. <br><br>  Of course, before translating, the script should be recoded into something more convenient, for example in UTF-8, in order to combine Cyrillic and Japanese characters. <br><br>  After the change of the engine (about the next part), the game accepts both Russian and Japanese text.  But for the time being, compatibility requires encoding Japanese characters in Shift Jis, and Cyrillic characters in cp1251 encoding. <br><br>  We quickly sketched a Python program for transcoding, taking into account the Cyrillic alphabet: <br><br><div class="spoiler">  <b class="spoiler_title">UTF8 to cp1251 and ShiftJIS</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # UTF8 to cp1251 and ShiftJIS recoder # by Chtobi and Nazon, 2016 import codecs import argparse from os import path JAPANESE_CODEPAGE = 'shift_jis' UTF_CODEPAGE = 'utf-8' RUS_CODEPAGE = 'cp1251' def nonrus_handler(e): if e.object[e.start:e.end] == '～': # UTF-8: 0xEFBD9E -&gt; SHIFT-JIS: 0x8160 japstr_byte = b'\x81\x60' elif e.object[e.start:e.end] == '－': # UTF-8: 0xEFBC8D -&gt; SHIFT-JIS: 0x817C japstr_byte = b'\x81\x7c' else: japstr_byte = (e.object[e.start:e.end]).encode(JAPANESE_CODEPAGE) return japstr_byte, e.end if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="Recode to cp1251 and ShiftJIS", description="Program to encode UTF8 text file to " "cp1251 for all cyrillic symbols and ShiftJIS for others. " "Output file will be inputfilename.s", usage="recode_to_cp1251_shiftjis.py file_name") arg_parser.add_argument('file_name', nargs=1, type=argparse.FileType(mode='r', bufsize=-1), help="Input text file name. Only files coded in UTF8 are allowed.\n") codecs.register_error('nonrus_handler', nonrus_handler) input_name = arg_parser.parse_args().file_name[0].name output_name = path.splitext(input_name)[0] + ".s" with open(input_name, 'rt', encoding=UTF_CODEPAGE) as input_file: with open(output_name, 'wb') as output_file: for line in input_file: for char1 in line: bytes_out = bytes(line, UTF_CODEPAGE) output_file.write(char1.encode(RUS_CODEPAGE, "nonrus_handler")) print("Done.")</span></span></code> </pre><br></div></div><br>  However, it was not without problems.  The program, when attempting to transcode a tilde  (U + FF5E FULLWIDTH TILDE), gave the error "UnicodeEncodeError: 'Shift Jis' codec can't be encoded character '\ uff5e' in position 0: illegal multibyte sequence" <br><br>  At first I sinned on Python, but in the end I found out a rather unusual nuance.  There is uncertainty between the Unicode and non-Unicode Japanese encoding method, depending on the specific implementation. <br><br>  As a result, Windows associates the Shift Jis symbol with the code 0x8160 with Unicode ～ (U + FF5E FULLWIDTH TILDE), and other transcoders (for example, the iconv utility) correlate the same symbol with 〜 (U + 301C WAVE DASH), according to the official Unicode Ratio table - <a href="">ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFT JIS.TXT</a> <br><br>  To determine the correspondences between the symbols of Microsoft, apparently decided to use the scheme from its cp932 encoding, which is an enhanced version of Shift Jis. <br><br>  The same situation with the symbol with the code 0x817C, which is converted to UTF8 as - (U + FF0D FULLWIDTH HYPHEN-MINUS) in Windows, or as - (U + 2212 MINUS SIGN) in iconv. <br><br>  Since all the script files were first converted from Shift Jis to UTF8 using Notepad ++ (and it uses the matching table adopted in Windows), the reverse conversion from UTF8 to Shift Jis through our Python program appeared. <br><br>  Therefore, we had to consider the occurrence of ～ and ～separate conditions. <br><br>  There were other minor flaws - for example, dots ... (U + 2026 HORIZONTAL ELLIPSIS) were replaced by Cyrillic dots from cp1251, and not Japanese from Shift Jis. <br><br>  After translating the text, you can proceed to work with game graphics. <br><br>  Graphic files of the game are in the same pack archives, but after unpacking, they still have to work hard.  For example, almost all png images are unpacked as files like sample + DPNG000 + x32y0.png In other words, png images are cut into horizontal strips, 88 pixels thick, and each strip is recorded in a separate file.  The file name contains the sequence number of the bar (DPNG000 ... 009) and the x, y coordinates. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/ak/x_/gjakx_76ep3syu_gf9qfobolmj8.png"></div><br>  I'm still wondering why this was necessary.  If it is difficult to rip resources from a game, then this is clearly not the best method. <br><br>  In order to glue the cut png files, a small merge_dpng permo script from asmodeus was created, which uses ImageMagick.  Unfortunately, and with him problems.  First, I needed Pearl, which I did not use, and even after installing it, it turned out that the script did not work correctly. <br><br>  On this occasion, we wrote a similar program on python: <br><br><div class="spoiler">  <b class="spoiler_title">Qlie engine dpng files merger</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Qlie engine dpng files merger # by Chtobi and Nazon, 2016 # Requires ImageMagick magick.exe on the path. import os import glob import re import argparse import subprocess IMGMAGIC = os.path.dirname(os.path.abspath(__file__)) + '\\' + 'magick.exe' IMGMAGIC_PARAMS1 = ['-background', 'rgba(0,0,0,0)'] IMGMAGIC_PARAMS2 = ['-mosaic'] INPUT_FILES_MASK = '*+DPNG[0-9][0-9][0-9]+*.png' SPLIT_MASK = '+DPNG' x_y_ajusts_re = re.compile('(.+)\+DPNG[0-9][0-9][0-9]\+x(\d+)y(\d+)\.') if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="DPNG Merger\n" "Program to merge sliced png files from QLIE engine. " "All files with mask *+DPNG[0-9][0-9][0-9]+*.png" "into the input directory will be merged and copied to the" "output directory.\n", usage="connect_png.py input_dir [output_dir]\n") arg_parser.add_argument("input_dir_param", nargs=1, help="Full path to the input directory.\n") arg_parser.add_argument("output_dir_param", nargs='?', default=os.path.dirname(os.path.abspath(__file__)), help="Full path to the output directory. " "It would be a script parent directory if not specified.\n") input_dir = arg_parser.parse_args().input_dir_param[0] output_dir = arg_parser.parse_args().output_dir_param[0] os.chdir(input_dir) all_append_files = glob.glob(INPUT_FILES_MASK) # Select only files with DPNG prep_bunches = [] for file_in_dir in all_append_files: # Check all files and put all splices that should be connected in separate list for num, bunch in enumerate(prep_bunches): name_first_part = bunch[0].partition(SPLIT_MASK)[0] # Part of the filename before +DPNG should be unique if name_first_part == file_in_dir.partition(SPLIT_MASK)[0]: prep_bunches[num].append(file_in_dir) break else: prep_bunches.append([file_in_dir]) os.chdir(os.path.dirname(os.path.abspath(__file__))) # Go to the script parent dir for prepared_bunch in prep_bunches: sorted_bunch = sorted(prepared_bunch) # Prepare -page params for imgmagic png_pages_params = [["(", "-page", "+{0}+{1}".format(*[(x_y_ajusts_re.match(part_file).group(2)), x_y_ajusts_re.match(part_file).group(3)]), input_dir+part_file, ")"] for part_file in sorted_bunch] connect_png_list = \ [imgmagick_page for imgmagick_pages in png_pages_params for imgmagick_page in imgmagick_pages] output_file = output_dir + sorted_bunch[0].partition(SPLIT_MASK)[0] + ".png" subprocess.check_output([IMGMAGIC] + IMGMAGIC_PARAMS1 + connect_png_list + IMGMAGIC_PARAMS2 + [output_file])</span></span></code> </pre> <br></div></div><br>  It would seem that now we got the whole set of pictures that appears in the game?  Not at all - if you view all the connected pictures from all the archives, it still turns out that some are missing, although they are in the game.  The fact is that in the engine there is another type of files - with the extension .b.  This is something like an animation with images and sounds recorded inside. <br><br>  The resources stored inside are quite easy to get, but, alas, none of the ready unpackers of .b files in our case worked as it should.  Either some files remained unpacked, or there were errors due to Japanese names, and I did not want to boot from the Japanese locale. <br><br>  Here one more our script came in handy.  Since then we were not familiar with something like <a href="https://github.com/kaitai-io/kaitai_struct">Kaitai Struct</a> , we had to act almost from scratch. <br><br>  The .b file format was simple and, moreover, our unpacker was required to unpack resources only from this game.  In other games on the Qlie engine, additional types of resources appeared inside the .b files, but we will not dwell on them in detail. <br><br>  So, open any .b file in a hex editor and look at the beginning.  Before evaluation, it should be noted that the byte order of all numeric values ​​will be Little-endian. <br><br><ul><li>  Header file abmp12 </li><li>  Ten bytes 0x00 </li><li>  The header of the first section abdata12 with service information. </li><li>  Eight bytes 0x00 </li><li>  The size of the abdata12 section, a four-byte integer.  You can safely skip it. </li><li>  Header section abimage10 </li><li>  Seven bytes 0x00 </li><li>  The number of files in the section, single-byte integer.  In this case, in the section one file. </li><li>  Header section abgimgdat13 </li><li>  Six bytes 0x00 </li><li>  The length of the file name within the section, a two-byte integer.  In this case, the length is 4 bytes. </li><li>  Shift Jis file name </li><li>  The length of the file checksum entry, a two-byte integer. </li><li>  The checksum file itself. </li><li>  Unknown byte, apparently, is always 0x03 or 0x02 </li><li>  Twelve unknown bytes possibly related to animation. </li><li>  The size of the png file inside the section, four-byte integer. </li></ul><br>  And finally, the png file itself. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/v4/yc/64v4ycd37hyu-pyqsxyb2g1ahqa.png"></div><br>  The absound section is similar in structure to abimage. <br><br><div class="spoiler">  <b class="spoiler_title">AnimatedBMP extractor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract b # AnimatedBMP extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse from collections import namedtuple b_hdr = b'abmp12'+bytes(10) signa_len = 16 b_abdata = (b'abdata10'+bytes(8), b'abdata11'+bytes(8), b'abdata12'+bytes(8), b'abdata13'+bytes(8)) b_imgdat = (b'abimgdat10'+bytes(6), b'abimgdat11'+bytes(6), b'abimgdat14'+bytes(6)) b_img = (b'abimage10'+bytes(7), b'abimage11'+bytes(7), b'abimage12'+bytes(7), b'abimage13'+bytes(7), b'abimage14'+bytes(7)) b_sound = (b'absound10'+bytes(7), b'absound11'+bytes(7), b'absound12'+bytes(7)) # not sure about structure of sound11 and sound12 b_snd = (b'absnddat11'+bytes(7), b'absnddat10'+bytes(7), b'absnddat12'+bytes(7)) Abimgdat13_pattern = namedtuple('Abimgdat13', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'unknown2_len', 'data_size_len']) Abimgdat13 = Abimgdat13_pattern(signa=b'abimgdat13'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=1, unknown2_len=12, data_size_len=4) Abimgdat14_pattern = namedtuple('Abimgdat14', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Abimgdat14 = Abimgdat14_pattern(signa=b'abimgdat14'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=77, data_size_len=4) Abimgdat_pattern = namedtuple('Abimgdat', ['name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) # probably, abimgdat10,abimgdat11 and others Other_imgdat = Abimgdat_pattern(name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) Absnddat11_pattern = namedtuple('Absnddat11', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Absnddat11 = Absnddat11_pattern(signa=b'absnddat11'+bytes(7), name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) def create_parser(): arg_parser = argparse.ArgumentParser(prog='AnimatedBMP extractor\n', usage='extract_b input_file_name output_dir\n', description='AnimatedBMP extractor for QLIE engine *.b files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs=1, help="Output directory.\n") return arg_parser def check_type(file_buf): if file_buf.startswith(b'\x89' + b'PNG'): return '.png' elif file_buf.startswith(b'BM'): return '.bmp' elif file_buf.startswith(b'JFIF', 6): return '.jpg' elif file_buf.startswith(b'IMOAVI'): return '.imoavi' elif file_buf.startswith(b'OggS'): return '.ogg' elif file_buf.startswith(b'RIFF'): return '.wav' else: return '' def bytes_shiftjis_to_utf8(shiftjis_bytes): shiftjis_str = shiftjis_bytes.decode('shift_jis', 'strict') utf_str = shiftjis_str.encode('utf-8', 'strict').decode('utf-8', 'strict') return utf_str def check_signa(f_buffer): if f_buffer.endswith(b_abdata): return 'abdata' elif f_buffer.endswith(b_img): return 'abimgdat' elif f_buffer.endswith(b_sound): return 'absound' def prepare_filename(out_file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(out_file_name) + postfix return ready_name def create_file(file_name_hndl, out_buffer): if len(out_buffer) != 0: with open(file_name_hndl, 'wb') as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def check_file_header(file_handle, bytes_num): file_handle.seek(0) readed_bytes = file_handle.read(bytes_num) if readed_bytes == b_hdr: print("File is valid abmp") return True else: print("Can't read header. Probably, wrong file...") return False if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_b_files = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for b_file in all_b_files: file_buffer = bytearray(b'') with open(b_file, 'rb') as bfile_h: check_file_header(bfile_h, len(b_hdr)) read_byte = bfile_h.read(1) file_buffer.extend(read_byte) while read_byte: read_byte = bfile_h.read(1) file_buffer.extend(read_byte) # Finding content sections signature check_result = check_signa(file_buffer) if check_result: if check_result == 'abdata': file_buffer = bytearray(b'') read_length = bfile_h.read(4) size = struct.unpack('&lt;L', read_length)[0] file_buffer.extend(bfile_h.read(size)) # Adding _abdata to separate from other parts outfile_name = prepare_filename(b_file, output_dir, '_abdata') create_file(outfile_name, file_buffer) elif check_result == 'abimgdat': images_number = struct.unpack('B', bfile_h.read(1))[0] # Number of pictures in section for i1 in range(images_number): file_buffer = bytearray(b'') file_name = '' imgsec_hdr = bfile_h.read(signa_len) if imgsec_hdr == Abimgdat13.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.name_size_len))[0] # Decode filename to utf8 file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) # CRC size hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.hash_size_len))[0] # Picture CRC (don't need it) pic_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Abimgdat13.unknown1_len) unknown2 = bfile_h.read(Abimgdat13.unknown2_len) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat13.data_size_len))[0] print("pic_size:", pic_size) file_buffer.extend(bfile_h.read(pic_size)) elif imgsec_hdr == Abimgdat14.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Abimgdat14.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat14.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) else: # probably abimgdat10, abimgdat11... file_name_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Other_imgdat.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Other_imgdat.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) for i, letter in enumerate(file_name): # Replace any unusable symbols from filename with _ if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name = file_name.replace(letter, "_") # Checking file signature and adding proper extension outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) create_file(outfile_name, file_buffer) file_buffer = bytearray(b'') elif check_result == 'absound': sound_files_number = struct.unpack('B', bfile_h.read(1))[0] for i2 in range(sound_files_number): file_buffer = bytearray(b'') file_name = '' sndsec_hdr = bfile_h.read(signa_len) if sndsec_hdr == Absnddat11.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) else: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) for i, letter in enumerate(file_name): if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name[i] = '_' outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) print("create absound") create_file(outfile_name, file_buffer) file_buffer = bytearray(b'')</span></span></code> </pre><br></div></div><br>  The script should automatically unpack found png, jpg, bmp, ogg and wav files.  But beyond that, the unknown imoavi files also come across. <br><br>  The point is that in the game all the animations are made either as a full-fledged video in ogv format, or as images animated by the engine, which are recorded in .b files, or as animated jpg files in imoavi format. <br><br>  In this case, we were interested in jpg images, so we had to deal with them as well. <br><br>  There are two sections in imoavi: SOUND and MOVIE.  In the MOVIE section, 47 bytes after the header, there are four bytes of the jpg file size.  The files are recorded one after another in the original form, separated by a sequence of 19 bytes, where the size of the next file is recorded. <br><br>  The imoavi voiced in the game did not come across, therefore the SOUND section is always empty. <br><br>  Well, since we started to engage in pulling out all the resources of the game, a small script was also written at the same time to pull out jpg from imoavi. <br><br><div class="spoiler">  <b class="spoiler_title">Imoavi extractor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract imoavi # Imoavi extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse imoavi_hdr = b'IMOAVI' hdr_len = len(imoavi_hdr) def create_file(file_name, out_buffer, wr_mode='wb'): if len(out_buffer) != 0: with open(file_name, wr_mode) as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def prepare_filename(file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(file_name) + postfix return ready_name def create_parser(): arg_parser = argparse.ArgumentParser(prog='Imoavi extractor\n', usage='extract_imoavi input_file_name output_dir\n', description='Imoavi extractor for QLIE engine *.imoavi files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs='+', help="Output directory.\n") return arg_parser if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_imoavi = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for imoavi_f in all_imoavi: file_buffer = bytearray(b'') with open(imoavi_f, 'rb') as imoavi_h: # Read imoavi file header imoavi_h.read(hdr_len) imoavi_h.seek(2, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(5, os.SEEK_CUR) # SOUND imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(11, os.SEEK_CUR) imoavi_h.seek(5, os.SEEK_CUR) # Movie imoavi_h.seek(3, os.SEEK_CUR) # 00 ?? imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # ?? imoavi_h.seek(1, os.SEEK_CUR) # Number of jpg files in section imoavi_h.seek(4, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x05 ??? imoavi_h.seek(2, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # 720 ?? imoavi_h.seek(4, os.SEEK_CUR) # Full size without header? to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] # Bytes till next header imoavi_h.seek(16, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_num = 0 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer) while to_next_size != 0: file_buffer = bytearray(b'') to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] if to_next_size == 24: # 0x1C header for index part file_buffer.extend(imoavi_h.read(to_next_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + '.index') create_file(outfile_name, file_buffer, 'ab') # concatenate with index file else: imoavi_h.seek(2, os.SEEK_CUR) # unknown imoavi_h.seek(2, os.SEEK_CUR) # Unknown, almost always FF FF or FF FE file_num = struct.unpack('B', imoavi_h.read(1))[0] # File number imoavi_h.seek(11, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer)</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After unpacking, you can make sure that the animation from the screen saver in the menu is stored just in the 1_ イ ト ル 画面 ム ム ー ビ ー .b file in imoavi format.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/81/_r/lo81_rlqvf55nia7relrkbsckey.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this game with all the resources. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, during the translation process, several more unpleasant nuances emerged that could not be overcome. The game, as I already wrote, does not support Unicode encodings. Therefore, all translated text is displayed at the wrong letter spacing. There were a few more problems with back-packing files and running the game without changing the system encoding to Japanese. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At some point, we (or rather, the one who was responsible for the technical part of the translation in our team) thought: maybe we shouldn't hang around with the old engine, but port the novelty to the Renpy engine, at the same time getting a cross-platform format? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps we hurried, but at some point, it was a pity to quit, and there was nothing left but to finish the translation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What did we have to face during porting? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About this in the second part.</font></font><br><br>  References: <br><br> <a href="https://bitbucket.org/Chtobi/qlie-tools/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our bitbucket scripts </font></font></a> <br><br> <a href="https://ja.wikipedia.org/wiki/%25E3%2583%2597%25E3%2583%25AD%25E3%2582%25B8%25E3%2582%25A7%25E3%2582%25AF%25E3%2583%2588:%25E7%25BE%258E%25E5%25B0%2591%25E5%25A5%25B3%25E3%2582%25B2%25E3%2583%25BC%25E3%2583%25A0%25E7%25B3%25BB/%25E3%2582%25B2%25E3%2583%25BC%25E3%2583%25A0%25E3%2582%25A8%25E3%2583%25B3%25E3%2582%25B8%25E3%2583%25B3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the Qlie engine in Japanese </font></font></a> <br><br> <a href="http://www.rikai.com/library/kanjitables/kanji_codes.sjis.shtml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shift Jis encoding table </font></font></a> <br><br> <a href="http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More about the problem of transcoding from Shift Jis to UTF-8 </font></font></a> <br><br> <a href="http://asmodean.reverse.net/pages/exfp3.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utility exfp3_v3 from asmodean</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/426431/">https://habr.com/ru/post/426431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426421/index.html">EHCI in Russian</a></li>
<li><a href="../426423/index.html">mmWave in smartphones: how Qualcomm made the impossible possible</a></li>
<li><a href="../426425/index.html">The whole truth about the RTOS. Article # 14. Memory sections: introduction and basic services</a></li>
<li><a href="../426427/index.html">Useful things to "things": a small selection with low prices</a></li>
<li><a href="../426429/index.html">Installing FreeSWITCH 1.8 on Debian 9 (Raspbian Stretch, the basic image of the SmartDomain system MajorDoMo on Rasbperri Pi)</a></li>
<li><a href="../426433/index.html">Delicious SMM for restaurant</a></li>
<li><a href="../426435/index.html">The best specialists are those that I myself have prepared: a course on testing games from the experts of Mail.Ru Group</a></li>
<li><a href="../426437/index.html">How face recognition helps you find test phones</a></li>
<li><a href="../426439/index.html">Forgery of charts, substitution of quotes and price manipulation: how to hack applications for trading on the stock exchange</a></li>
<li><a href="../426441/index.html">Mail.Ru Group 20 years: Checkpoint code and technology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>