<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Page segmentation - overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago (oh, god, a year has passed!) To the question whether anyone would be interested in a review on modern methods of image document page se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Page segmentation - overview</h1><div class="post__text post__text-html js-mediator-article">  Some time ago (oh, god, a year has passed!) To the question whether anyone would be interested in a review on modern methods of image document page segmentation, I received a positive answer (from <a href="https://habrahabr.ru/users/massimus/" class="user_link">massimus</a> ).  And today I finally decided to make this review. <br><br><img src="https://habrastorage.org/files/9e3/77d/7cf/9e377d7cf4bb4cd2a6eb14d4c8253e33.jpg" align="left" alt="Something like this page segmented">  But for starters - a small digression.  The text recognition system in our products can be described very simply.  We have a page with text, we parse it into text blocks, then we parse the blocks into separate lines, lines into words, words into letters, we recognize letters, then we collect everything back to the text of the page further down the chain.  The segmentation task is set like this: there is a page, it is necessary to decompose it into text and non-text elements. <br><br>  Further, the task can be clarified and clarified ( <a href="https://habrahabr.ru/company/abbyy/blog/266551/">here</a> I‚Äôm already fed up with explanations that the correct formulation of the problem is already half a step to solving it; you can be sure that I got my colleagues <s>and bosses</s> even stronger).  Scientists from different countries, the authors of the methods cited, want to do science, not casuistry, so they formulate their task more simply: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The page has text and pictures.  It is required to break the text into blocks and select pictures. <a name="habracut"></a><br><br>  The inspiration for me was the article <a href="http://www.keysers.net/daniel/files/Shafait--Layout-Analysis-Comparison--DAS2006.pdf">F. Shafait, D. Keysers, and Th.</a>  <a href="http://www.keysers.net/daniel/files/Shafait--Layout-Analysis-Comparison--DAS2006.pdf">Breuel.</a>  <a href="http://www.keysers.net/daniel/files/Shafait--Layout-Analysis-Comparison--DAS2006.pdf">Performance Comparison of Six Algorithms for Page Segmentation</a> (hereinafter, I will call it SKB, after the initial letters of the authors' last names), where a comparative assessment of almost all the given segmentation methods is given.  So if you want to immediately dig into the original sources - it is better to take it and follow the links.  A description of the algorithms themselves, details and discussion - here. <br><br>  So, we need to break the text into blocks and select images.  As you can see, there is no talk about tables, charts and other delights;  moreover, they often assume that the pictures are high-contrast and at the same time well binarized - that is, their borders can in principle be found by working only with a monochrome image. <br><br>  Also in research often use the concept of "Manhattan" and "non-Manhattan" layout.  ‚ÄúManhattan‚Äù is one in which the boundaries of all blocks are straight (each block is either rectangular or consists of several rectangles with some vertices and parts of the sides common), the ‚Äúnon-Manhattan‚Äù does not satisfy such restrictions. <br><br>  To begin, we will examine some algorithms designed to work with the "Manhattan" document. <br><br><h3>  Smearing </h3><br>  This is the most ancient algorithm - perhaps the first thing that comes to mind when faced with the task of segmentation.  First described back in 1982, in an article by KY Wong, RG Casey, FM Wahl.  Document Analysis System. <br><br>  In a nutshell, it works like this: let's spread the words vertically and horizontally a little, the resulting connected areas will be ready-made blocks. <br><br>  If you describe a little more, it turns out like this: <br><br><ol><li>  We take the image of the page in the <a href="https://habrahabr.ru/post/141827">RLE-representation</a> </li><li>  Remove white RLE strokes (= sequence of white pixels) with a length less than lT_horz.  We receive the image Image_1 </li><li>  The original image is rotated 90 degrees and on the rotated image we delete white RLE-strokes with a length less than lT_vert.  Rotate the image back and get the image Image_2 </li><li>  We do AND of images Image_1 and Image_2 <br></li><li>  On the resulting image, we will remove the white strokes with a length less than T_Final <br></li></ol><br>  The associated areas in the captured image are the finished blocks.  They should be divided into text and non-text.  In 1982, there was still no such arsenal of machine learning tools, without them it was difficult - the decision tree was painted by hand. <br><br>  This is how intermediate images and end blocks look like: <br><br><img src="https://habrastorage.org/files/cd4/037/9a2/cd40379a2bf044a68d7f8321bcaecff4.png"><br><br>  In the original article, the authors worked with a picture with a resolution of 240 dpi and picked up the values ‚Äã‚Äãof T_horz = 300 T_vert = 500 and T_final = 30. Somewhat surprisingly, the values ‚Äã‚Äãturned out so large (T_vert as much as two inches with hook), apparently this is due to what is being done AND. <br><br>  The advantages of the algorithm are clear - it is simple, it works with the RLE image and only with it, and therefore it is fast.  The algorithm itself nowhere clearly relies on the fact that the input document is ‚ÄúManhattan‚Äù.  However, if you think about it, then the algorithm will not work on a ‚Äúnon-Manhattan‚Äù one ‚Äî in the example below, the text will be glued to the picture. <br><br><img src="https://habrastorage.org/files/f8c/3b6/bf0/f8c3b6bf0a614734b8cf19feaf953583.png" width="658" height="554"><br><br>  The really bad news is that on the ‚ÄúManhattan‚Äù document the glueing of text and ‚Äúnon-text‚Äù is also very frequent, in SKB this is noticed. <br><br><h3>  Recursive XY cut </h3><br>  A couple of years later, in 1984, a more advanced method of page segmentation was described, which is called recursive XY cut.  He is described in the article G. Nagy and S. Seth.  The ‚Äúhierarchical representation of optically scanned documents‚Äù was also actively developed in the 1990s. <br><br>  This method is already explicitly stated that it is suitable only for the Manhattan document.  The essence of the method is that we divide the page into blocks alternately, dividing the blocks vertically or horizontally.  That is, an algorithm like this: <br><br><ul><li>  Preparing the page, clearing it from small debris </li><li>  Select the connected areas.  You can even combine them a little and get something like words, if suddenly someone knows how to build such associations safely.  But within the framework of this post we will call them ‚Äúconnected areas‚Äù. </li><li>  We calculate the global parameters of the algorithm, for example, the median height and width of the symbol. </li></ul><br>  Then we start the algorithm recursively, starting from the whole page: <br><br><ul><li>  We are looking for how to divide the block in a vertical or horizontal cut. </li><li>  If we could, we divide and recursively start the division of each of the parts. </li><li>  If we could not, stop. </li></ul><br><br>  As for the item on how to divide the block.  Two ways are proposed - either in white clearance (it can be found on the projection of the block on the horizontal or vertical axis, respectively) or along a long and fairly well-isolated black straight line. <br><br>  As a result of all these divisions, the tree structure is obtained, as in the figure below: <br><br><img src="https://habrastorage.org/files/e3d/488/79f/e3d48879f8584750b966892908b2bc60.png"><br><br>  The authors of the original article seem to consider this tree view as their main merit.  They also noticed that even for the ‚ÄúManhattan‚Äù document it is possible that this algorithm will not achieve the goal: for example, if the blocks are arranged like this <br><br><img src="https://habrastorage.org/files/25b/365/36a/25b36536ae684f6a99314d41d5362b3d.png"><br><br>  Frankly, not the most common configuration, even for newspapers, not to mention the magazines and office documents.  But found in the newspapers for sure. <br><br>  A more serious problem of the algorithm seems to be its submission to the thresholds.  Let's say on such a fragment it will be difficult to separate the title from the text without breaking the title: <br><br><img src="https://habrastorage.org/files/bc3/0e2/a5b/bc30e2a5bd114b59aac3e73b217be945.png"><br><br>  And here it will be quite difficult to separate the picture from the text, relying only on the thresholds for the distance: <br><br><img src="https://habrastorage.org/files/a8f/f24/97c/a8ff2497c61a45e5893b1ffa01bd1a5c.jpg"><br><br>  Of course, problems that are common to all of the algorithms presented in this post are relevant - how not to tear the numbering from the numbered list and how to get rid of the restrictions that I indicated at the beginning (which is only text and high-contrast pictures). <br><br><h3>  Segmentation using maximum white rectangles </h3><br>  Now tell about the idea of ‚Äã‚Äãsegmenting the page using the maximum white rectangles.  What is a ‚Äúmax white rectangle‚Äù?  White - this means that there are no black dots in it (it is clear that the image must first get rid of small debris).  Maximum means that it cannot be increased either left or right, up or down so that it remains white.  Further, instead of black points, we will consider connected domains.  As in the recursive sections, we can group them somehow, but again we will not stop there.  It is clear that almost every scanned page of such white rectangles - tens of thousands.  But for segmentation purposes, only the largest ones may be required.  The algorithm for their search is proposed in the article by Thomas M. Breuel.  Two Geometric Algorithms for Layout Analysis <br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  The second algorithm from these ‚Äútwo‚Äù selects lines between these white delimiters, but, as it seems to me, it is not particularly prominent, if anyone is interested, see the article. </div></div><br><br>  Let us return to the task of finding the maximum white rectangles.  You can enter the concept of "quality" for the rectangle. <br><br>  Let us call the quality function Q (r) for a rectangle r <i>monotonic</i> , if for r1 r2, Q (r1) &lt;= Q (r2) is fulfilled - that is, if one rectangle lies inside another, then the quality of the inner cannot be greater than the quality of the outer.  It is possible to think up monotonous qualities mass.  The area is good.  The perimeter is good.  A square of height plus a square of width is suitable.  In general, what fantasy enough for. <br><br>  If the quality is monotonous, then apply the following algorithm, search for maximum white rectangles, in order of decreasing quality. <br><br><ul><li>  We get a queue with priorities for rectangles.  Priority is equal to quality. </li><li>  We put in a queue a rectangle of the whole page.  He is exactly the first. </li></ul><br>  Next in the loop: <br><br><ul><li>  Get out of the queue rectangle.  If it is empty, then this is another found maximum white rectangle. </li><li>  If not, from the connected areas in the rectangle under investigation, select one ‚Äúreference‚Äù area (similar to the median in QSort).  Here it is better not to rely on chance, but to consciously choose something more centrally. </li><li>  Note that the maximum white rectangle can be either entirely above this area, or entirely below it, or to its right or left (green rectangles in the figure below). </li><li>  Add green rectangles to the queue. </li></ul><br><br><img src="https://habrastorage.org/files/35a/131/0a4/35a1310a4d4f44499b36df7b8f62e5e9.jpg"><br><br>  The condition for exiting the cycle can be either a sufficient number of the rectangles found, or the quality of the current rectangle taken from the queue ... What fantasy is enough for. <br><br>  Well, we found the maximum white rectangles.  Let's see what you can do next. <br><br>  In the same article, Thomas M. Breuel does not really bother about this topic and writes that the entire analysis is done in four steps: <br><br><ol><li>  Find all the high maximum white rectangles and evaluate them as candidates for column breaks. </li><li>  According to the column structure found, find the rows </li><li>  Looking at the found lines, find paragraphs, header structure, footers </li><li>  Restore the reading order using both geometric and linguistic information </li></ol><br><br>  Further, some reasonable considerations are mentioned in the paper on how exactly white rectangles should be classified.  I admit that there are not so many deficiencies in the evaluation function - here we will rather rest on the limitations of the method than on the incorrect evaluation. <br><br>  Henry Baird describes a slightly different approach in his work. Background structure in document images.  This paper describes a very interesting algorithm, but the implementation of some functions leaves a feeling that they are specifically ‚Äúfinely tuned‚Äù to a specific experimental base.  So, it is proposed to place all the found maximum white rectangles in the priority queue.  I will not give a specific priority function, you can look at the work.  Intuitively, the larger the area of ‚Äã‚Äãthe rectangle and the higher the rectangle, the higher the priority should be. <br><br>  Next, we take out rectangles from this queue to put some of them into a special list L. For each rectangle taken out, we apply the trimming rule: if this rectangle intersects with some elements of the list L, then we subtract from it the already processed and what is left, put it back in line.  Otherwise, we add it to the list L. The condition for getting out of the cycle is somewhat tricky (I would just indicate the priority threshold, but the authors have a harder time). <br><br>  Cut out all the rectangles of the list L from the page. The remaining connected areas in the image are declared ready-made text or picture blocks. <br><br>  As a small summary of the maximum white rectangles, we can say that the maximum white rectangle is a very important concept, extremely useful for solving the problem of page segmentation.  According to an experiment from SKB, both of the algorithms presented here work better on both recursive sections and Smearing.  Another thing is that in the above algorithms the question is ‚Äúhushed up‚Äù even with pictures, not to mention more complex concepts. <br><br><h1>  Non-manhattan layout </h1><br>  We have analyzed several algorithms for Manhattan documents.  But what to do if we got a document like this: <br><br><img src="https://habrastorage.org/files/5be/458/64f/5be45864f2e34b58be6002a9937e9d14.JPG"><br><br>  Well, specifically the answer is quite simple - no this is not a document, but just the wallpaper in my closet, so what exactly the document processing program will do with this picture is not so important. <br><br>  If to speak seriously, the ‚Äúnon-Manhattan‚Äù layout is not so big exotic, it can be found in newspapers, in magazines, and sometimes even in books.  Here is a typical newspaper example: <br><br><img src="https://habrastorage.org/files/d3c/fe2/9dd/d3cfe29ddcad41b5968fbd128d884a35.png"><br><br>  Below we analyze two algorithms that cope with the "non-Manhattan" documents. <br><br><h3>  Docstrum </h3><br>  The word Docstrum is derived from the Carroll productive model portmanteau word - by gluing together the words Document and Spectrum (I love this model, by the way) and denotes the segmentation algorithm for ‚Äúnon-Manhattan‚Äù documents.  O'Gorman described it in his article The 1993 spectrum for page layout analysis in 1993.  The method itself was invented for pages that lay on the scanner is not perfectly smooth, but at a slight angle.  We describe how this algorithm works. <br><br>  To begin, we will prepare the page by removing small debris and large, obviously non-text objects (well, or pretend that there are no pictures on the pages - is this the first time?).  We believe that all that remains on the page are small letters.  We cluster these letters in size (the author proposed exactly two clusters, but those who used this method tried three, and four, and even more).  Let's look at the distances from each letter to k (usually taking k equal to 4 or 5) of the nearest neighbors from the same cluster.  Let's write down distances in the histogram.  Let's look at the first three peaks of the histogram.  It is argued that the smallest peak is the distance between the letters in the word, the second is the line spacing, and the third is the space.  If we use this assumption, we can correct the bias, by the way. <br><br>  For the segmentation of the page, we do a transitive closure by the close components - we merge the words inside the lines and the close lines with each other, we get ready blocks. <br><br>  Besides the fact that this method is positioned as working with ‚Äúnon-Manhattan‚Äù documents, it explicitly uses an important idea.  I mean the property that the threshold values ‚Äã‚Äãof distances, on which our solution depends (put two words in one block or not), are selected depending on the height of the words.  This means that this method has at least some chance of regularly coping with the problem ‚Äúover-segmenting of large fonts‚Äù that has been repeatedly mentioned by researchers. <br><br>  On the other hand, here too, the authors deftly hushed up the question of what to do with pictures and more complex objects.  Yes, and other shortcomings of the idea of ‚Äã‚Äãrelying only on the thresholds for the distance we have already discussed above. <br><br><h3>  Voronoi diagram </h3><br>  The Voronoi diagram is an interesting object that is constructed from an arbitrary set of points of the plane (in our case, by the centers of the letters).  The points along which the Voronoi diagram is constructed will be called <i>reference points here</i> .  It is a partition of the plane into areas;  each area corresponds to one reference point and is a set of points of the plane for which this reference point is closer than any other reference point.  In more detail about <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE">the Voronoi diagram</a> and its connection with another curious object - <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F_%25D0%2594%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B5">Delaunay triangulation</a> , the easiest way to read is through the links in Wikipedia. <br><br>  About how to build them, it is worth reading the beautiful <a href="http://e-maxx.ru/bookz/files/skvortsov.pdf">AV</a> Booklet already quoted many times on Habr√© <a href="http://e-maxx.ru/bookz/files/skvortsov.pdf">.</a>  <a href="http://e-maxx.ru/bookz/files/skvortsov.pdf">Skvortsova "Delone Triangulation and its application."</a>  I will talk about the 1998 article K. Kise, A. Sato, and M. Iwata.  Segmentation of page images using the area voronoi diagram.  That is, how the Voronoi diagram was applied to the solution of the segmentation problem.  By the way, today this method is considered a ‚Äúscientific standard‚Äù until science has proposed an algorithm that would be recognized better than this one.  And in SKB, the authors write that the Voronoi diagram noticeably outperforms both white rectangles, Docstrum, and recursive sections. <br><br>  So, with a familiar gesture, we clear the image of garbage (everything, for the last time for this post, pretend that it is really so easy to do), we declare the centers of the remaining connected regions as anchor points and build the Voronoi diagram on them.  Then we note which of the cells in the diagram should be merged.  We merge cells in two cases: <br><br><ol><li>  Or the distance d between the reference points (centers of connected components) is less than the threshold T1.  The threshold T1 is chosen in such a way that this rule deals with the union of adjacent letters in words </li><li>  Or, d has the following relation: d / T2 + ar / Ta &lt;1 where ar is the ratio of the area of ‚Äã‚Äãthe larger connected area to the area of ‚Äã‚Äãthe smaller (ie, ar&gt; = 1), and T2 and Ta are two more thresholds.  The meaning of this condition is that it is necessary to combine two words in a line, but if these two words have different heights, then you need to combine the cells with more caution. </li></ol><br>  After we have found all the cells that need to be merged, we merge them - and the Voronoi diagram turns into a ready segmentation. <br><br>  Later, different researchers tried to improve the work of the Voronoi diagram.  For example, in the 2009 Voronoi ++ article: A Dynamic Page Segmentation approach based on Voronoi and Docstrum features, the authors M. Agrawal and D.Doermann tell how to use the Docstrum and even other strange witches to choose the T2 threshold.  I will not write about this ‚Äúimprovement‚Äù here in detail, but the very existence of articles on the development of a segmentation algorithm based on the Voronoi diagram, and even written by such eminent scientists as David Doermann hints to us where the wind blows. <br><br>  The drawbacks of the Voronoi diagram are the same again - the limitations depend only on the thresholds, the same ambiguity with pictures.  The undoubted advantage of this method lies in the fact that it contains only three parameters that must be selected - and these parameters are explicitly indicated. <br><br>  This concludes my review of the scientific advances related to page segmentation.  And science, I think, will still say its word :) </div><p>Source: <a href="https://habr.com/ru/post/306510/">https://habr.com/ru/post/306510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306500/index.html">Elixir: Registering Processes - A Practical Guide</a></li>
<li><a href="../306502/index.html">Content marketing: how to write clear and minimally annoying email text</a></li>
<li><a href="../306504/index.html">Open source initiative Docker4Drupal.org</a></li>
<li><a href="../306506/index.html">30 questions for which you must have an answer during the interview</a></li>
<li><a href="../306508/index.html">According to Rambler.iOS # 7</a></li>
<li><a href="../306512/index.html">Validation of forms in React</a></li>
<li><a href="../306514/index.html">Unite Europe 2016: Review of the report ‚ÄúOverthrowing the MonoBehavior your tyranny in a glorious ScriptableObject revolution‚Äù</a></li>
<li><a href="../306516/index.html">Customer focus vs customer focus</a></li>
<li><a href="../306518/index.html">Windows and SSH. Continuation</a></li>
<li><a href="../306520/index.html">Destroy SSD in 7 seconds: tactical protection of information from unauthorized access</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>