<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In-depth training in the garage - Data Brotherhood</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do you also find emoticons the most fun phenomenon? 
 In prehistoric times, when I was still a schoolboy and was just beginning to comprehend the deli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In-depth training in the garage - Data Brotherhood</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/eaa/c58/190/eaac5819027b4eda83204be2aac317b7.png" width="520" alt="An example of the system"><br>  Do you also find emoticons the most fun phenomenon? <br>  In prehistoric times, when I was still a schoolboy and was just beginning to comprehend the delights of the Internet, from the very first contacts I added to ICQ, I was amused every day: well, really, imagine that your interlocutor makes a face that he sends you a smile! <br><br>  Since then, a lot of water has flowed, but I have not matured: everyone sometimes continues to smile at the smiles sent to me, representing the sender with eyes of different sizes or a foolish smile on his entire face.  But not everything is so bad, because on the other hand I became a developer and expert in data analysis and machine learning!  And so, last year, my attention was attracted by a relatively new, but interesting and disturbing imagination technology of deep learning.  Hundreds of the smartest scientists and the coolest engineers of the planet have been working on its problems for years, and finally, it became no more difficult to train deep neural networks with ‚Äúclassical‚Äù methods, such as ordinary regressions and wooden ensembles.  And then I remembered smiles! <br><br>  Imagine that to send a smile, you really could make a face, how cool would it be?  This is a great deep learning exercise, I decided, and got to work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In-depth training in the garage - Data Brotherhood <br>  <a href="https://habrahabr.ru/post/277345/">In-depth training in the garage - Two networks</a> <br>  <a href="https://habrahabr.ru/post/277403/">In-depth training in the garage - Return smiles</a> <br><a name="habracut"></a><br>  Those who opened the post entirely, try not to disappoint, and not to repeat the storyline of countless posts on the Internet, which take the finished model from the article, pour tons of data into the network and magically everything turns out.  I tried to approach the matter more methodically, to conduct a lot of experiments, study the results in detail and draw reasonable (haha, I hope!) Conclusions.  Moreover, to obtain as a result, if not a model ready for use in real production, then at least conceptually capable of working in real-time with the application of understandable engineering efforts. <br><br>  My story is not a fairy tale about how incredible results are obtained by the wave of a hand and the launch of a simple script.  This story of successive failures that were slowly but surely overcome by long studies of modern and not-so-many articles and countless experiments. <br><br><h2>  Disclaimer </h2><br>  Many questions in this series of articles were not covered: how to select and change the learning rate, how to set up topologies, how to specifically handle the used data sets.  I wanted to write about the project as a whole and talk about the fundamental problems facing me and their possible solutions, and not dig into the details. <br><br>  I also want to apologize in advance for a wild amount of Anglicism: there is almost no Russian-language literature in this area, and I wrote as I was used to, although I tried to use Russian analogues in some places. <br><br>  <i>All materials, data sets, pictures and videos are taken from open sources and are used exclusively for educational purposes.</i> <br><br><h2>  Oars into the water! </h2><br>  To begin with, tulchein: I decided to choose for myself a rather adult, but at the same time most flexible toolkit.  This immediately discarded Caffe and various hardcore C ++ libraries, after all, this is a research project! <br>  In principle, (at that time) only Theano and Torch remained (tensorflow has not yet come out).  Both Python and Lua I know well and have quite a lot of experience with both languages, so the choice was purely tasteful: I chose Theano simply because it seemed to me more flexible, because even though it supports deep learning primitives, it generally builds arbitrary symbolic expressions, and seems more generalized.  To compensate for the finished brick layers that Torch has and Theano doesn't have, I decided to use Lasagne, essentially the same bricks, but on top of Theano. <br><br>  I‚Äôll say right away that I didn‚Äôt choose well enough, that is, without having any experience with networks, so in the process I felt sorry for many times and turned back that I didn‚Äôt choose Torch.  As a result, I still have not decided what is best :) <br><br>  So, choose a platform, you can code!  But what? <br><br><h1>  Task </h1><br>  The product is more or less clear: I want to send smiles without choosing them from the list, but depicting them on their faces.  So, I want to make a face, be photographed, and the system, ideally, should understand for me what kind of smile I paint and write it in the message.  <i>Immediately disappoint: the prototype in the form of a plug-in for Skype, VTSAP or HENAUT never reached (for now?), There is not enough time, I only completed the system from the networks.</i> <br><br>  Fortunately, such product requirements can be easily transformed into technological ones: we need, in simple words, to be able to transform a selfie into a smile! <br><br>  In order to convert a face into a smile, you must first find and highlight it (we don‚Äôt want to force the user to align the face on the screen, right?). <br><br>  So, the algorithm: <br><br><ol><li>  Looking for a face. </li><li>  Cut out. </li><li>  Convert to smile. </li><li>  ?????? </li><li>  PROFIT! </li></ol><br><h2>  Everything can be taught! </h2><br>  Just what?  First, let's deal with the detection of faces.  Internets are full of articles about the classification of images.  But we, first of all, need not a classification, but detection!  And it is much more difficult.  Fortunately, here comes the first important insight: detection can be reduced to classification.  Let's take our network and apply it not to the whole image, but to all the square windows inside this image.  Or rather, not to all, but to windows of several sizes with an offset (4 <em>i, 4</em> j) in (x, y), where i, j from (0, ceil (w / 4)), (0, ceil (h / four)). <br>  It turns out the algorithm (pseudo-code): <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img)</span></span></span><span class="hljs-function">:</span></span> window_size = min(img.height, img.width) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> not_too_small(window_size): y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> y &lt; img.height: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; img.width: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (x, y, x + window_size, y + window_size) x += dx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pixels_x_left_unyilded(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (img.width - window_size, y, img.width, y + window_size) y += dy <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pixels_y_left_unyilded(): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; img.width: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> (x, img.hight - window_size, x + window_size, img.hight + window_size) x += dx window_size /= resizing_factor dx /= resizing_factor dy /= resizing_factor</code> </pre> <br>  So, we resize the image at several different scales and for each scale we go by a fixed-size window in increments of 4 pixels.  And we carry out the classification of each square person / not person.  After that, of course, we will have a lot of squares, which are lit up for each person, so that they will have to somehow be drained.  Algorithms can come up with different, clever and not so, but I just choose the best lit square among the highly intersecting ones: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter_frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(frames)</span></span></span><span class="hljs-function">:</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(frames) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: frames.sort(by=probability_of_face) res.append(frames[<span class="hljs-number"><span class="hljs-number">0</span></span>]) frames = frames[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> frames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> intersection(res[<span class="hljs-number"><span class="hljs-number">-1</span></span>], f) &gt; big_enough: frames.remove(f)</code> </pre> <br><h2>  Taki are learning? </h2><br>  Why?  By no means fortunate, I already armed myself with knowledge from several text and video courses on deep learning, several interesting blogs and a fairly large set of read articles on modern research (large by the standards of the month, at that time of preparation, but nevertheless, I enough). <br><br>  If we want to work with images, we use convolutional networks.  No exceptions. <br><br>  In fact, there is another opinion from the great minds in this field: the correct use of ordinary layers, and the convolutions from the evil one.  After all, in essence, they are nothing more than ordinary layers, but with the ‚Äúhard-coded‚Äù property of independence from the position of the object.  But this property, firstly, could be learned by the network itself, and secondly, it is generally not correct, because during the detection the position is just important for us! <br><br>  The bad news for this approach is the inability of its implementation on modern hardware, so we postpone this option for a dozen years and make convolutionary networks. <br><br>  And here we are very lucky, because it's pretty simple!  Following the example of the first epic breakthrough of CNN - AlexNet, whose architecture is quite simple to repeat: take yourself convoluted-pooling layers, how much you can afford, and on top a couple of fully connected ones.  The larger the network, the better, except for the fact that it is very easy to retrain, but, thank Hinton, it is very easy to cope with this using a technique called dropout and a small attenuation of the scales, just in case. <br><br><img src="https://habrastorage.org/files/701/964/39b/70196439b7be45aab7f6199f146af9ce.png" width="600" alt="AlexNet"><br>  My first, still small, network: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_net12</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> network = lasagne.layers.InputLayer(shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), input_var=input) network = lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.1</span></span>) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">16</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nonlin=relu) network = max_pool(network) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">16</span></span>, nonlin=relu) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), num_units=<span class="hljs-number"><span class="hljs-number">2</span></span>, nonlin=relu) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> network</code> </pre> <br>  It is small mainly because at that time I did not have available GPUs and I optimized on the CPU, which is very slow. <br><br><h2>  Well, we are learning at last? </h2><br>  And on what?  Fortunately, good people have created many open datasets for the tasks of recognition and detection of faces.  I first took dataset called FFDB.  There are a lot of photos in it, in which faces are highlighted with ellipses (not directly over the photos, but the parameters of the ellipse are separately written in a text file).  This dataset can only be used for educational purposes, but we have such goals, right?  :) Additionally, I got there some data marked by me and obtained from photos similar to KDVV. <br><br><h2>  Everything is there, let's go teach! </h2><br>  Let's go.  And immediately, magically, it came out! <br><br><img src="https://habrastorage.org/files/ed2/95b/f5f/ed295bf5faba464dae3bdfa87f9ebd17.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/c52/bcd/e60/c52bcde6067a47c68feee2dc8df7a734.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/095/547/c79/095547c796694ebe830a896b7c4feda3.png" height="264" alt="Detection Example"><br><br>  <i>Screenshots were made in a specially developed system for monitoring neural network learning called DeepEvent, which I will write in a separate article if you are interested.</i> <br><br>  The first 10 iterations of training are cut off simply because they say little and depend heavily on the random initialization of weights. <br>  In the example of work, all the windows in which the network has found a face are marked in red, the windows left after filtering are marked in green. <br>  <i>I also confess that there is a small deception: all the graphics were made much later not on the very experiments, but on slightly more advanced ones and where they need to be repaired, but similar.</i>  <i>The fact is that DeepEvent was not developed immediately and the results of the first experiments were lost forever.</i>  <i>Although, as I remember now, this network at the very beginning did not give 92%, but about 89.5%.</i> <br><br>  And here we see that although the network shows transcendental for such small efforts on the part of me 92%, the present quality of detection leaves much to be desired.  What to do?  Need to learn more network! <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_net48</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> network = lasagne.layers.InputLayer(shape=(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>), input_var=input) network = lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.1</span></span>) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = max_pool(network) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), nolin=relu) network = max_pool(network) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) network = max_pool(network) network = conv(network, num_filters=<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), nolin=relu) network = max_pool(network) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), nolin=relu, num_units=<span class="hljs-number"><span class="hljs-number">256</span></span>) network = DenseLayer(lasagne.layers.dropout(network, p=<span class="hljs-number"><span class="hljs-number">.5</span></span>), nolin=relu, num_units=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> network</code> </pre> <br>  And nothing comes out.  It turns out that they often forget to tell in articles, for deep learning you need a lot of data.  Lots of.  With the above dataset, it was worthy of me to train a small model, but a small model did not give the quality I wanted.  The big model did not converge to normal minimums, and if you decrease the dropout thresholds, it quickly retrained, which is logical: it is not difficult for a large model to just remember a small amount of training data. <br><br><h2>  Augmentation </h2><br>  Well, I judged, we need more data - we will make more data!  And I implemented a process that, as I later learned, is called data augmentation: this is when transformations are applied to the initial data, which effectively increases the size of the training sample hundreds or even thousands of times. <br><br>  So, for each example, with a probability of 0.5, we reflect it horizontally, because this does not change the class of the person / person.  Also, for each face I took not the original square, obtained from the ellipse that was present in the dataset, but, first, the square was accidentally slightly increased (or decreased) in a certain interval, and secondly, after that, it was slightly shifted in x and y at some intervals. <br>  Additionally, later I still thought of taking this square itself, but of it, but accidentally slightly stretched either in x or y (50/50).  As a result, it turns out a rectangle cut out from a picture with a face, which then must be turned into a square by compression.  The difference of this transformation is that the previous one changes the size and position of the square but does not deform the face itself, and this transformation deforms the face: slightly stretches / compresses it either vertically or horizontally. <br><br>  Pseudocode augmentation: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_rnd_img_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(img, box, net_input_size)</span></span></span><span class="hljs-function">:</span></span> box = move_box(box, random(minx, maxx), random(miny, maxy)) box = scale_box(box, random(minscale, maxscale)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> random.random() &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>: stretch_x, stretch_y = random(<span class="hljs-number"><span class="hljs-number">1.</span></span>, stretchx), <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: stretch_x, stretch_y = <span class="hljs-number"><span class="hljs-number">1</span></span>, random(<span class="hljs-number"><span class="hljs-number">1.</span></span>, stretchy) box = stretch_box(box, stretch_x, stretch_y) frame = img.crop(box) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>: frame = mirror(frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.resize((net_input_size.x, net_input_size.y))</code> </pre> <br>  Using the above combinations, I got an effectively infinite set of data: the probability of repeating a picture for 500 epochs of learning, according to my estimates, was somewhere around a tenth of a percent for my image size. <br><br>  Here are the results of the same small model, but with added training and test sets: <br><img src="https://habrastorage.org/files/999/6b1/5f6/9996b15f6ca749e0ad587d73240a4c2a.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/f9e/aa9/a7c/f9eaa9a7c4b64e449fc491862976230f.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/9bf/9b5/f9a/9bf9b5f9a3d543a0b5a2fd18f809f15d.png" height="264" alt="Detection Example"><br><br>  On the example of work, there are now blue squares, due to the fact that I divided the filtering into two stages: first, only windows of each size are filtered individually, choosing the best among their size (blue), and globally among all sizes (green), at the same time, for some reason I have reduced the window sliding step. <br><br><h2>  Optimization I </h2><br>  True, instead of a small amount of training data, I received another problem: a potentially infinite amount of data needs a potentially infinitely powerful computer!  Or a clever trick.  Since I specialize more in the software part, I decided that I would build a potentially infinitely powerful computer next time, and solve the current problem with a clever trick: I will not generate data for learning in advance and load it entirely into memory, and build an index in advance with The original unfinished dataset, which I will complement right in runtime.  In essence, right during the iteration for each object in the mini-batche, I call the above algorithm and get updated data generated on the fly. <br><br>  With this, by the way, is a funny story.  When I debugged all this on the CPU and went to run on the GPU, I saw a furious performance drop: judge for yourself, the augmentation algorithm contains a bunch of logic, after which there is also a reflection and resize of the picture!  And so for all 1024 elements of the mini-match, multiply by several dozen mini-batches per iteration! <br><br>  In general, of course, it categorically did not suit me, and I went to understand.  And it turned out that everything is quite logical: in a single-threaded python program, the GPU simply sleeps while the CPU slowly generates a minibatch.  Laziness is bad, we have to fight it, and I decided that the GPU should pry, like a galley slave, every moment I have! <br><br>  Decision?  Do not block the GPU!  Let's, the CPU will asynchronously prepare the next batch, while the GPU learns the network on the current one.  So I did.  And I was absolutely confident in the success of this operation, but I was disappointed: it almost did not help.  It turned out that the CPU runs much longer than the GPU, especially on small networks, and the GPU still sleeps most of the time. <br><br>  Well, in vain, have I designed all these web services?  How to optimize parallel approximately the same read-only processing of a large array of objects?  Sharding (it is MapReduce)!  Let‚Äôs, I decided, we‚Äôll run a lot of processes and give each one a piece of the mini-batches that they will process, put the results into a queue and then, without waiting, process the piece of the next mini-match if the queue is not full.  Additionally, we will launch another process that will listen to this queue, understand to which mini-match a piece belongs, collect from the mini-fitch pieces and put it in the second turn, from which the main process working with the GPU already takes the data. <br><br>  And, finally, having armed with a server with 32 cores and running the generation of augmented data in 32 processes (+ two almost always waiting in a queue or a GPU) and loading it I don‚Äôt want to, since the second era, the GPU almost stopped sleeping. <br><br><h2>  Hurray, we learn! </h2><br>  So, now you can teach not a toy model of normal size and success!, If properly tuned, it does not retrain and does not hang out of minimums. <br><br><img src="https://habrastorage.org/files/ffd/60e/91b/ffd60e91b56849aa95cb5a2c6af6e28e.png" width="340" height="264" alt="Mistake"><img src="https://habrastorage.org/files/04f/435/276/04f4352765e24ee4ab6021e33e35f6f4.png" width="340" height="264" alt="Accuracy"><img src="https://habrastorage.org/files/1fb/fca/aa1/1fbfcaaa1b8749ba8987fcf44d9068ab.png" height="264" alt="Detection Example"><br><br>  Here, it is clearly seen how dumb bursts appear in the learning process (why it will be next), but in the end everything becomes more or less good, although it is still a little more talkative. <br><br>  <i>In the following series:</i> <i><br></i>  <i>Even more data, even more networks, calibration, mind-blowing ensembles of networks, modern technologies, more pictures, girls and drama!</i> <i><br></i> <br></div><p>Source: <a href="https://habr.com/ru/post/277267/">https://habr.com/ru/post/277267/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277255/index.html">What's wrong with javascript in a big project? What problems did we face and how did we solve them</a></li>
<li><a href="../277257/index.html">List of technical and IT conferences 2016. Part # 3</a></li>
<li><a href="../277259/index.html">Opinion: Why spam is so hard to beat</a></li>
<li><a href="../277261/index.html">How ill-conceived compiler warnings help to spoil completely correct code.</a></li>
<li><a href="../277265/index.html">Zabbix 3.0 released</a></li>
<li><a href="../277269/index.html">I'm sitting in the cloud, working</a></li>
<li><a href="../277273/index.html">Java rake</a></li>
<li><a href="../277275/index.html">Finger Math: Least Squares</a></li>
<li><a href="../277279/index.html">Safety means of security: ACS</a></li>
<li><a href="../277283/index.html">Meeting report Moscow CocoaHeads January 29</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>