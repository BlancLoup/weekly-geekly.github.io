<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We understand C, studying the assembler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation by David Albert - Understanding C by learning assembly . 

 Last time, Allan O'Donnell talked about how to study C using GDB . Today I wan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We understand C, studying the assembler</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation by David Albert - <a href="https://www.hackerschool.com/blog/7-understanding-c-by-learning-assembly">Understanding C by learning assembly</a> .</i> <br><br>  Last time, Allan O'Donnell talked about how <a href="http://habrahabr.ru/post/181738/">to study C using GDB</a> .  Today I want to show how using GDB can help in understanding assembler. <br><br>  Levels of abstraction are great tools for creating things, but sometimes they can become an obstacle to learning.  The purpose of this post is to convince you that for a solid understanding of C, you also need to have a good understanding of the assembler code that the compiler generates.  I will do this using the example of disassembling and parsing a simple C program using GDB, and then we use GDB and the assembly knowledge gained to study how static local variables are structured in C. <br><a name="habracut"></a><br>  <i>Author's note:</i> All code from this article was compiled on x86_64 processor under Mac OS X 10.8.1 using Clang 4.0 with optimization disabled ( <i>-O0</i> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Learning assembler with GDB </h4><br>  Let's start with disassembling a program with GDB and learn how to read the output.  Type the following program text and save it in the file <i>simple.c</i> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a + <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Now compile it in debug mode and with optimization turned off and run GDB. <br><br><pre> <code class="bash hljs">$ CFLAGS=<span class="hljs-string"><span class="hljs-string">"-g -O0"</span></span> make simple cc -g -O0 simple.c -o simple $ gdb simple</code> </pre><br>  Put a breakpoint on the <i>main</i> function and continue execution until you reach the <i>return statement</i> .  Enter the number 2 after the <i>next</i> statement to indicate that we want to execute it twice: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> main (gdb) run (gdb) next 2</code> </pre><br>  Now use the <i>disassemble</i> command to display the assembler instructions for the current function.  You can also pass the <i>function</i> name to the <i>disassemble</i> command to specify a different function to examine. <br><br><pre> <code class="bash hljs">(gdb) disassemble Dump of assembler code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> main: 0x0000000100000f50 &lt;main+0&gt;: push %rbp 0x0000000100000f51 &lt;main+1&gt;: mov %rsp,%rbp 0x0000000100000f54 &lt;main+4&gt;: mov <span class="hljs-variable"><span class="hljs-variable">$0x0</span></span>,%eax 0x0000000100000f59 &lt;main+9&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x0</span></span>,-0x4(%rbp) 0x0000000100000f60 &lt;main+16&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x5</span></span>,-0x8(%rbp) 0x0000000100000f67 &lt;main+23&gt;: mov -0x8(%rbp),%ecx 0x0000000100000f6a &lt;main+26&gt;: add <span class="hljs-variable"><span class="hljs-variable">$0x6</span></span>,%ecx 0x0000000100000f70 &lt;main+32&gt;: mov %ecx,-0xc(%rbp) 0x0000000100000f73 &lt;main+35&gt;: pop %rbp 0x0000000100000f74 &lt;main+36&gt;: retq End of assembler dump.</code> </pre><br>  By default, the <i>disassemble</i> command displays the instructions in AT &amp; T syntax, which is the same syntax used by the GNU assembler.  The AT &amp; T syntax has the format: <i>mnemonic</i> <i>source</i> , <i>destination</i> .  Where <i>mnemonic</i> is the names of instructions that the person understands.  And <i>source</i> and <i>destination</i> are operands, which can be immediate values, registers, memory addresses, or labels.  In turn, the immediate values ‚Äã‚Äãare constants, they have the prefix <i>$</i> .  For example, <i>$ 0x5</i> corresponds to the number 5 in hexadecimal notation.  Register names are written with the <i>%</i> prefix. <br><br><h5>  Registers </h5><br>  It is worth spending some time studying registers.  Registers are data storage locations that are located directly on the central processor.  With some exceptions, the size or <i>width of the</i> registers of the processor determines its architecture.  Therefore, if you have a 64-bit CPU, then its registers will have a width of 64 bits.  The same applies to 32-bit and 16-bit processors, etc. The speed of access to registers is very high and it is because of this that operands of arithmetic and logical operations are often stored in them. <br><br>  The x86 family of processors has a number of special and general purpose registers.  General-purpose registers can be used for any operations, and the data stored in them does not have special meaning for the processor.  On the other hand, the processor in its work relies on special registers, and the data that is stored in them, have a certain value depending on the specific register.  In our example, <i>% eax</i> and <i>% ecx</i> are general registers, while <i>% rbp</i> and <i>% rsp</i> are special registers.  The <i>% rbp</i> register is a base pointer that points to the base of the current stack frame, and <i>% rsp</i> is a stack pointer that points to the top of the current stack frame.  The <i>% rbp</i> register is always more important than <i>% rsp</i> , because the stack always starts with the highest memory address and grows towards the lower addresses.  If you are not familiar with the concept of ‚Äúcall stack‚Äù, then you can find a good <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B2">explanation on Wikipedia</a> . <br><br>  The feature of the x86 family of processors is that they retain full compatibility with 16-bit 8086 processors. During the transition of x86 architecture from 16-bit to 32-bit and finally to 64-bit, the registers were expanded and received new names, to maintain compatibility with code that was written for earlier processors. <br><br>  Take the general-purpose register AX, which is 16 bits wide.  The high byte is accessed by the name AH, and the low byte is named AL.  When the 32-bit 80386 appeared, the expanded (Extended) AX or EAX became a 32-bit register, while AX remained 16-bit and became the lower half of the EAX register.  Similarly, when x86_64 appeared, the ‚ÄúR‚Äù prefix was used and EAX became the younger half of the 64-bit RAX register.  Below is a diagram based on a Wikipedia article to illustrate the above links: <br><br><pre> <code class="bash hljs">|__64__|__56__|__48__|__40__|__32__|__24__|__16__|__8___| |__________________________RAX__________________________| |xxxxxxxxxxxxxxxxxxxxxxxxxxx|____________EAX____________| |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|_____AX______| |xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx|__AH__|__AL__|</code> </pre><br><br><h5>  Back to code </h5><br>  This should already be enough to proceed to the analysis of our disassembled program: <br><br><pre> <code class="bash hljs">0x0000000100000f50 &lt;main+0&gt;: push %rbp 0x0000000100000f51 &lt;main+1&gt;: mov %rsp,%rbp</code> </pre><br>  The first two instructions are called a function prologue or preamble.  First of all, we write the old base pointer onto the stack in order to save it for the future.  Then we copy the value of the stack pointer into the base pointer.  After this, <i>% rbp</i> points to the base segment of the <i>main</i> frame's stack frame. <br><br><pre> <code class="bash hljs">0x0000000100000f54 &lt;main+4&gt;: mov <span class="hljs-variable"><span class="hljs-variable">$0x0</span></span>,%eax</code> </pre><br>  This instruction copies 0 to <i>% eax</i> .  The x86 call convention states that the values ‚Äã‚Äãreturned by the function are stored in the <i>% eax</i> register, so the above instruction tells us to return 0 at the end of our function. <br><br><pre> <code class="bash hljs">0x0000000100000f59 &lt;main+9&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x0</span></span>,-0x4(%rbp)</code> </pre><br>  Here we have something with which we have never met: <i>-0x4 (% rbp)</i> .  Parentheses make it clear to us that this is a memory address.  In this fragment, <i>% rbp</i> , the so-called base register, and <i>-0x4</i> , which is the offset.  This is equivalent to writing <i>% rbp + -0x4</i> .  As the stack grows downward, subtracting 4 from the base stack frame moves us to the actual frame itself, where the local variable is stored.  This means that this instruction saves 0 at <i>% rbp - 4</i> .  It took me some time to figure out what this line is for, and it seems to me that Clang allocates a hidden local variable for an implicit return value from the <i>main</i> function. <br><br>  You may also notice that <i>mnemonic</i> has the suffix <i>l</i> .  This means that the operand will be of type <i><b><u>l</u></b> ong</i> (32 bits for integers).  Other possible suffixes are <i><b><u>b</u></b> yte</i> , <i><b><u>s</u></b> hort</i> , <i><b><u>w</u></b> ord</i> , <i><b><u>q</u></b> uad</i> , and <i><b><u>t</u></b> en</i> .  If you get an instruction that does not have a suffix, the size of such an instruction will be implied from the size of the source or destination register.  For example, in the previous line, <i>% eax</i> is 32 bits wide, so the <i>mov</i> instruction is in fact <i>movl</i> . <br><br><pre> <code class="bash hljs">0x0000000100000f60 &lt;main+16&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x5</span></span>,-0x8(%rbp)</code> </pre><br>  Now we go to the very core of our test program.  The assembler line shown is the first line in C in the function <i>main</i> , and it places the number 5 in the next available slot of a local variable ( <i>% rbp - 0x8</i> ), 4 bytes lower from our previous local variable.  This is the location of the variable <i>a</i> .  We can use GDB to test this: <br><br><pre> <code class="bash hljs">(gdb) x &amp;a 0x7fff5fbff768: 0x00000005 (gdb) x <span class="hljs-variable"><span class="hljs-variable">$rbp</span></span> - 8 0x7fff5fbff768: 0x00000005</code> </pre><br>  Note that the memory address is the same.  You may also notice that GDB sets variables for our registers, so, like all variables in GDB, their name is preceded by the <i>$</i> prefix, while the <i>%</i> prefix is ‚Äã‚Äãused in AT &amp; T's assembler. <br><br><pre> <code class="bash hljs">0x0000000100000f67 &lt;main+23&gt;: mov -0x8(%rbp),%ecx 0x0000000100000f6a &lt;main+26&gt;: add <span class="hljs-variable"><span class="hljs-variable">$0x6</span></span>,%ecx 0x0000000100000f70 &lt;main+32&gt;: mov %ecx,-0xc(%rbp)</code> </pre><br>  Next, we put the variable <i>a</i> in <i>% ecx</i> , one of our general-purpose registers, add the number 6 to it and store the result in <i>% rbp - 0xc</i> .  This is the second line of the <i>main</i> function.  You could already guess that the address <i>% rbp - 0xc</i> corresponds to the variable <i>b</i> , which we can also check with GDB: <br><br><pre> <code class="bash hljs">(gdb) x &amp;b 0x7fff5fbff764: 0x0000000b (gdb) x <span class="hljs-variable"><span class="hljs-variable">$rbp</span></span> - 0xc 0x7fff5fbff764: 0x0000000b</code> </pre><br>  The rest of the <i>main</i> function is simply a process of cleaning, which is also called an epilogue. <br><br><pre> <code class="bash hljs">0x0000000100000f73 &lt;main+35&gt;: pop %rbp 0x0000000100000f74 &lt;main+36&gt;: retq</code> </pre><br>  We retrieve the old base pointer and put it back in <i>% rbp</i> , and then the <i>retq</i> instruction throws us to the return address, which is also stored in the stack frame. <br><br>  Up to this point, we used GDB to disassemble a small C program, went through AT &amp; T's assembler syntax reading and uncovered the topic of registers and operands of memory addresses.  We also used GDB to check where the local variables are stored relative to <i>% rbp</i> .  Now we use the acquired knowledge to explain the principles of operation of static local variables. <br><br><h4>  Understanding static local variables </h4><br>  Static local variables are a very cool feature of C. In a nutshell, these are local variables that are initialized once and retain their value between calls to the function in which they were declared.  A simple example of using static local variables is a Python-style generator.  Here is one that generates all natural numbers up to INT_MAX. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* static.c */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int natural_generator() { int a = 1; static int b = -1; b += 1; return a + b; } int main() { printf("%d\n", natural_generator()); printf("%d\n", natural_generator()); printf("%d\n", natural_generator()); return 0; }</span></span></span></span></code> </pre><br>  When you compile and run this program, it will output the first three positive integers: <br><br><pre> <code class="bash hljs">$ CFLAGS=<span class="hljs-string"><span class="hljs-string">"-g -O0"</span></span> make static cc -g -O0 static.c -o static $ ./static 1 2 3</code> </pre><br>  But how does this work?  To find out, go to GDB and look at the assembler code.  I deleted the address information that GDB adds to the disassembled output and now everything fits on the screen: <br><br><pre> <code class="bash hljs">$ gdb static (gdb) <span class="hljs-built_in"><span class="hljs-built_in">break</span></span> natural_generator (gdb) run (gdb) disassemble Dump of assembler code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> natural_generator: push %rbp mov %rsp,%rbp movl <span class="hljs-variable"><span class="hljs-variable">$0x1</span></span>,-0x4(%rbp) mov 0x177(%rip),%eax <span class="hljs-comment"><span class="hljs-comment"># 0x100001018 &lt;natural_generator.b&gt; add $0x1,%eax mov %eax,0x16c(%rip) # 0x100001018 &lt;natural_generator.b&gt; mov -0x4(%rbp),%eax add 0x163(%rip),%eax # 0x100001018 &lt;natural_generator.b&gt; pop %rbp retq End of assembler dump.</span></span></code> </pre><br>  The first thing we need to do is find out what instruction we are currently on.  We can do this by examining the instruction pointer or the team counter.  The instruction pointer is a register that stores the address of the next instruction.  In the x86_64 architecture, this register is called <i>% rip</i> .  We can access the instruction pointer with the <i>$ rip</i> variable, or, alternatively, we can use the architecturally independent variable <i>$ pc</i> : <br><br><pre> <code class="bash hljs">(gdb) x/i <span class="hljs-variable"><span class="hljs-variable">$pc</span></span> 0x100000e94 &lt;natural_generator+4&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x1</span></span>,-0x4(%rbp)</code> </pre><br>  The instruction pointer contains a pointer to the next instruction to execute, which means that the third instruction has not yet been executed, but is about to be. <br><br>  Since knowing the next instruction is very useful, we will make GDB show us the next instruction every time the program stops.  In GDB 7.0 and above, you can simply execute the <i>set disassemble-next-line on</i> command, which shows all the instructions that will be executed in the next line of program code.  But I‚Äôm using Mac OS X, which comes with GDB 6.3, so I‚Äôll have to use the <i>display</i> command.  This command is similar to <i>x</i> , except that it shows the value of the expression after each program stop: <br><br><pre> <code class="cs hljs">(gdb) display/i $pc <span class="hljs-number"><span class="hljs-number">1</span></span>: x/i $pc <span class="hljs-number"><span class="hljs-number">0x100000e94</span></span> &lt;natural_generator+<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;: movl $<span class="hljs-number"><span class="hljs-number">0x1</span></span>,<span class="hljs-number"><span class="hljs-number">-0x4</span></span>(%rbp)</code> </pre><br>  GDB is now configured to always show the next instruction before its output. <br><br>  We have already passed the prologue function, which was considered earlier, so we will start immediately with the third instruction.  It corresponds to the first line of code, which assigns 1 to the variable <i>a</i> .  Instead of the <i>next</i> command, which goes to the next line of code, we will use <i>nexti</i> , which goes to the next assembler instruction.  Now examine the address <i>% rbp - 0x4</i> to test the hypothesis that the variable <i>a</i> is stored exactly here: <br><br><pre> <code class="bash hljs">(gdb) nexti 7 b += 1; 1: x/i <span class="hljs-variable"><span class="hljs-variable">$pc</span></span> mov 0x177(%rip),%eax <span class="hljs-comment"><span class="hljs-comment"># 0x100001018 &lt;natural_generator.b&gt; (gdb) x $rbp - 0x4 0x7fff5fbff78c: 0x00000001 (gdb) x &amp;a 0x7fff5fbff78c: 0x00000001</span></span></code> </pre><br>  And we see that the addresses are the same, as we expected.  The following instruction is more interesting: <br><br><pre> <code class="bash hljs">mov 0x177(%rip),%eax <span class="hljs-comment"><span class="hljs-comment"># 0x100001018 &lt;natural_generator.b&gt;</span></span></code> </pre><br>  Here we expected to see the execution of the instructions in the string <i>static int b = -1;</i>  , but it looks significantly different than what we have met before.  On the one hand, there are no references to the stack frame, where we expected to see local variables.  There is not even <i>-0x1</i> !  In place of this, we have an instruction that loads something from the address <i>0x100001018</i> , located somewhere after the instruction pointer, into the register <i>% eax</i> .  GDB gives us a useful commentary with the result of calculating the memory operand, which suggests that <i>natural_generator.b</i> is located at this address.  Let's follow the instructions and see what happens: <br><br><pre> <code class="bash hljs">(gdb) nexti (gdb) p <span class="hljs-variable"><span class="hljs-variable">$rax</span></span> <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 4294967295 (gdb) p/x <span class="hljs-variable"><span class="hljs-variable">$rax</span></span> <span class="hljs-variable"><span class="hljs-variable">$5</span></span> = 0xffffffff</code> </pre><br>  Although the disassembler shows the <i>% eax</i> register as the receiver, we <i>print $ rax</i> , since GDB sets the variables for the full width of the register. <br><br>  In this situation, we must remember that while variables have types that define signed or unsigned, registers of these types do not have, so GDB displays the value of the <i>% rax register</i> as unsigned.  Let's try again by <i>casting the</i> value of <i>% rax</i> to a signed integer: <br><br><pre> <code class="bash hljs">(gdb) p (int)<span class="hljs-variable"><span class="hljs-variable">$rax</span></span> <span class="hljs-variable"><span class="hljs-variable">$11</span></span> = -1</code> </pre><br>  Looks like we found <i>b</i> .  We can re-verify this using the <i>x</i> command: <br><br><pre> <code class="bash hljs">(gdb) x/d 0x100001018 0x100001018 &lt;natural_generator.b&gt;: -1 (gdb) x/d &amp;b 0x100001018 &lt;natural_generator.b&gt;: -1</code> </pre><br>  So, the variable <i>b is</i> not only stored in another part of the memory, out of the stack, but also initialized to the value -1 before the <i>natural_generator</i> function is <i>called</i> .  In fact, even if you disassemble the entire program, you will not find any code that sets <i>b</i> to -1.  All this is because the value of the variable <i>b is</i> wired in another section of the executable file of our program, and it is loaded into memory along with all the machine code of the operating system loader when the process is started. <br><br>  With this approach, things start to make sense.  After saving <i>b</i> in <i>% eax</i> , we move on to the next line of code where we increment <i>b</i> .  This corresponds to the following instructions: <br><br><pre> <code class="bash hljs">add <span class="hljs-variable"><span class="hljs-variable">$0x1</span></span>,%eax mov %eax,0x16c(%rip) <span class="hljs-comment"><span class="hljs-comment"># 0x100001018 &lt;natural_generator.b&gt;</span></span></code> </pre><br>  Here we add 1 to <i>% eax</i> and write the result back to memory.  Let's follow these instructions and see the result: <br><br><pre> <code class="bash hljs">(gdb) nexti 2 (gdb) x/d &amp;b 0x100001018 &lt;natural_generator.b&gt;: 0 (gdb) p (int)<span class="hljs-variable"><span class="hljs-variable">$rax</span></span> <span class="hljs-variable"><span class="hljs-variable">$15</span></span> = 0</code> </pre><br>  The following two instructions are responsible for returning the result <i>a + b</i> : <br><br><pre> <code class="bash hljs">mov -0x4(%rbp),%eax add 0x163(%rip),%eax <span class="hljs-comment"><span class="hljs-comment"># 0x100001018 &lt;natural_generator.b&gt;</span></span></code> </pre><br>  Here we load the variable <i>a</i> in <i>% eax</i> , and then add <i>b</i> .  At this stage, we expect the value of 1 to be stored in <i>% eax</i> . Let's check: <br><br><pre> <code class="bash hljs">(gdb) nexti 2 (gdb) p <span class="hljs-variable"><span class="hljs-variable">$rax</span></span> <span class="hljs-variable"><span class="hljs-variable">$16</span></span> = 1</code> </pre><br>  The <i>% eax</i> register is used to store the value returned by the <i>natural_generator</i> function, and we are waiting for an <i>epilog</i> that will clear the stack and result in a return: <br><br><pre> <code class="bash hljs">pop %rbp retq</code> </pre><br>  We figured out how variable <i>b is</i> initialized.  Now let's see what happens when the <i>natural_generator</i> function <i>is</i> called again: <br><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span> Continuing. 1 Breakpoint 1, natural_generator () at static.c:5 5 int a = 1; 1: x/i <span class="hljs-variable"><span class="hljs-variable">$pc</span></span> 0x100000e94 &lt;natural_generator+4&gt;: movl <span class="hljs-variable"><span class="hljs-variable">$0x1</span></span>,-0x4(%rbp) (gdb) x &amp;b 0x100001018 &lt;natural_generator.b&gt;: 0</code> </pre><br>  Since <i>b is</i> not stored on the stack with the other variables, it is still 0 when you call <i>natural_generator again</i> .  No matter how many times our generator will be called, the variable <i>b</i> will always keep its previous value.  All this is because it is stored outside the stack and initialized when the loader puts the program into memory, and not according to any of our machine codes. <br><br><h4>  Conclusion </h4><br>  We started by parsing the assembler commands and learned how to disassemble the program using GDB.  Subsequently, we analyzed how static local variables work, which we could not have done without disassembling the executable file. <br>  We spent a lot of time alternating reading assembly instructions and testing our hypotheses using GBD.  This may seem boring, but there is a good reason for the following approach: the best way to learn something abstract is to make it more concrete, and one of the best ways to make something more concrete is to use tools that will help you look behind the layers of abstraction.  The best way to learn these tools is to force yourself to use them until it becomes commonplace for you. <br><br>  <i>From the translator: Low-level programming is not my profile, so if I made some inaccuracies, I would be glad to know about them in the LAN.</i> </div><p>Source: <a href="https://habr.com/ru/post/183376/">https://habr.com/ru/post/183376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183358/index.html">Some Coffee</a></li>
<li><a href="../183360/index.html">Perfect code and real projects</a></li>
<li><a href="../183366/index.html">Records launch reports RAD Studio XE4</a></li>
<li><a href="../183372/index.html">FleX ‚Ñ¢ Silicon-on-Polymer ‚Ñ¢ - the first serial flexible microcontroller</a></li>
<li><a href="../183374/index.html">Paradox evidence</a></li>
<li><a href="../183378/index.html">Finalists determined for the IBM SmartCamp competition</a></li>
<li><a href="../183382/index.html">Tomato technique in Russian</a></li>
<li><a href="../183386/index.html">Copywriting strike a new blow: Vkontakte began removing music</a></li>
<li><a href="../183388/index.html">Leak: iOS 7 on iPad</a></li>
<li><a href="../183392/index.html">Colossus on clay feet. Principles for managing a fast-paced gaming studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>