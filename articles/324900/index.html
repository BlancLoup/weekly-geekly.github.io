<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIPSfpga and interrupts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article provides several examples of how to configure and use MIPS32 Release 2 interrupts, including a detailed description of the configuration s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIPSfpga and interrupts</h1><div class="post__text post__text-html js-mediator-article"><p>  The article provides several examples of how to configure and use MIPS32 Release 2 interrupts, including a detailed description of the configuration set in this case, and how to work with an external interrupt controller. </p><br><p>  All the code described is published on github as part of the mipsfpga-plus [ <a href="https://github.com/MIPSfpga/mipsfpga-plus">L3</a> ] project. </p><br><p><img src="https://habrastorage.org/files/f3a/b48/538/f3ab4853852145308ccc31bc3ac0e9d2.png" alt="image"></p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  It is assumed that the reader: </p><br><ul><li>  familiar with the subject area in the Harris-Harris volume [ <a href="https://habrahabr.ru/post/259505/">L1</a> ]; </li><li>  has some programming experience in microcontrollers (of any architecture), including the use of timers and interrupts; </li><li>  has access to the source codes MIPSfpga [ <a href="https://habrahabr.ru/post/275215/">L2</a> ] and mipsfpga-plus [ <a href="https://github.com/MIPSfpga/mipsfpga-plus">L3</a> ]; </li></ul><br><p>  By writing this article I do not set a goal to comprehensively present all the features of work with interruptions for the MIPS microAptiv cores, since  this would require extensive translation of documentation and writing about the same amount of comments.  The goal is to show working examples of configuration and use of interrupts in three possible modes: backward compatibility, vector, and using an external controller.  Therefore, in order to make the reader feel more comfortable, it is recommended to get acquainted with the following sections of the documentation: </p><br><ul><li>  MIPS32 MicroAptiv UP Processor Core Family Integrator's Guide [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D1_MicroAptiv_UP_Integrators_Guide_MD00941.pdf">D1</a> ] <br>  (section 4 "Interrupt Interface"); </li><li>  MIPS32 MicroAptiv UP Processor Core Family Software User Manual [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ] <br>  (sections: 5.1-5.6 "Exceptions and Interrupts in the microAptiv UP Core", 6.2.13 "Count Register", 6.2.15 "Compare Register", 6.2.16 "Status Register", 6.2.17 "IntCtl Register", 6.2 .22 "Cause Register", 6.2.28 "EBase Register", 6.2.33 "Config3 Register"); </li><li>  Codescape GNU Tools for MIPS Programmer's Guide [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D3_MIPS_Toolchain_Codescape_GNU_Tools_for_MIPS_Programmers_Guide_1.1.97.pdf">D3</a> ] <br>  (sections: 15.5. "Exceptions", 15.6. "Interrupts"). </li></ul><br><p>  In all examples, for clarity, the launch is described on the mipsfpga-plus system operating in the simulator.  With equal success, this can also be done on hardware - the performance of the entire code has been tested on a Terasic DE10-Lite board [ <a href="http://de10-lite.terasic.com/">L4</a> ]. </p><br><h3 id="prinyatye-oboznacheniya">  Accepted notation </h3><br><p>  Signal names are in italics ( <em>SI_Int [7: 0]</em> ), unless otherwise indicated, all signals are interface signals for the top-level module of the MIPSfpga system (m14k_top).  For registers, a saturated font ( <strong>Count</strong> ) is used, the names of individual bits (fields) are given through a dot indicating the registers to which they relate ( <strong>Cause.DC</strong> ), on separate extracts from the documentation the register fields can be indicated by subscripts ( <strong>Cause <sub>IV</sub></strong> ).  For all registers x32 width is assumed, if it is not specified separately.  When specifying constants in the extracts from the documentation, there is an indication of the number system before the "lattice" symbol (16 # 180, 2 # 00001). </p><br><p>  Since  In MIPSfpga, unfortunately, the option "GPR Shadow Registers" (Shadow Register Set, SRS) is not available, then the article omits the details related to general purpose shadow registers.  Where this functionality is found in the diagrams, it is reflected in a gray (faded) color. </p><br><h2 id="obrabotka-isklyucheniy">  Exception Handling </h2><br><p>  Exceptions are all events that lead to the transition of the processor in kernel mode: memory access errors, division by zero, etc., including interrupt requests from external devices.  Handling all possible exceptions is an extensive topic that is not properly considered in isolation from the operating system (OS) kernel, which is clearly beyond the scope of this article.  However, even if the use of the OS is not supposed (Bare Metal code), the developer should still provide for a minimal set of handlers in memory in order to learn about the occurrence of an exception and to prevent the program execution from going into ‚Äúfree float‚Äù. </p><br><div class="spoiler">  <b class="spoiler_title">Slightly abbreviated algorithm for determining the address of the processor</b> <div class="spoiler_text"><pre><code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Status.EXL = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vectorOffset ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#<span class="hljs-number"><span class="hljs-number">180</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ExceptionType = TLBRefill <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vectorOffset ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#<span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (ExceptionType = Interrupt) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cause.IV = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vectorOffset ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#<span class="hljs-number"><span class="hljs-number">180</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Status.BEV = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (IntCtl.VS = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vectorOffset ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#<span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Config3.VEIC = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> VecNum ‚Üê Cause.RIPL <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> VecNum ‚Üê VIntPriorityEncoder() endif vectorOffset ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#<span class="hljs-number"><span class="hljs-number">200</span></span> + (VecNum √ó (IntCtl.VS || <span class="hljs-number"><span class="hljs-number">2</span></span>#<span class="hljs-number"><span class="hljs-number">00000</span></span>)) endif endif endif endif Cause.ExcCode ‚Üê ExceptionType //  ,          Status.EXL ‚Üê <span class="hljs-number"><span class="hljs-number">1</span></span> //   ,    <span class="hljs-string"><span class="hljs-string">" "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Status.BEV = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vectorBase ‚Üê <span class="hljs-number"><span class="hljs-number">16</span></span>#BFC00200 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //   EBase[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">30</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'b10 //       kseg0  kseg1 vectorBase ‚Üê EBase[31:12] || 16#000 endif //     //      vectorBase  vectorOffset //    29   30     PC ‚Üê {vectorBase[31:30], (vectorBase[29:0] + vectorOffset[29:0])}</span></span></code> </pre> </div></div><br><p>  The following algorithm is not taken into account in the above algorithm: </p><br><ul><li>  exceptions that cause the processor to reset (Reset, SoftReset, NMI - cause a transition to 16 # BFC00000); </li><li>  EJTAG exceptions; </li><li>  Cache / SPRAM Parity error, which when <strong>Status.BEV</strong> = 0 instead of the cached kseg0 segment, is mapped to the non-cacheable kseg1 segment ( <strong>vectorBase [29]</strong> = 1'b1) and <strong>EBase [29:12]</strong> = 0 in this particular case means not 16 # 80000000 , and 16 # A0000000.  In our case, this is not critical, since  in the MIPSfpga project, the memory segments overlap (see the RTL code of the mfp_ahb_lite_decoder module) and the upper three bits of the address are ignored when accessing the memory; </li><li>  XTLB Refil exception with offset 0x80, which is not described in [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ], but is mentioned in [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D3_MIPS_Toolchain_Codescape_GNU_Tools_for_MIPS_Programmers_Guide_1.1.97.pdf">D3</a> ] and all supplied code examples.  If someone from readers can clarify this point - I will be grateful for the information. </li></ul><br><p>  Full details of the exceptions can be found in [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ]. </p><br><p>  Thus, even without using interrupts, the developer should ensure that exception handlers are available at the following offsets: </p><br><ul><li>  16 # 000 - TLB Refill Handler; </li><li>  16 # 080 - XTLB Refil; </li><li>  16 # 100 - Cache / SPRAM Parity error; </li><li>  16 # 180 - General Exception Handler. </li></ul><br><h2 id="rezhimy-obrabotki-preryvaniy">  Interrupt Handling Modes </h2><br><p>  There are only three of them: </p><br><ul><li>  Interrupt Compatibility mode - compatibility mode; </li><li>  Vector Interrupt (VI) mode - vector mode; </li><li>  External Interrupt Controller (EIC) mode - external interrupt controller mode. </li></ul><br><p>  By default, the processor starts in compatibility mode (Compatibility).  Further, it can be changed by setting the corresponding values ‚Äã‚Äãof bits (fields): </p><br><ul><li>  <strong>Status.BEV</strong> - determines the base address from which the offset of the interrupt handler vector is calculated, is set programmatically, the value after reset is 1; </li><li>  <strong>Cause.IV</strong> - defines the offset of the interrupt handler vector, is set by software, the value after reset is not defined; </li><li>  <strong>IntCtl.VS</strong> - Vector Spacing, determines the offset between the vectors, is set programmatically, the value after reset is 0; </li><li>  <strong>Config3.VINT</strong> - Vectored interrupts, read-only, equal to 1 for all microAptiv cores, incl.  and for MIPSfpga; </li><li>  <strong>Config3.VEIC</strong> - detects the presence of an external interrupt controller, is read-only, the value is set by the <em>SI_EICPresent</em> signal. </li></ul><br><p>  A full description of the listed bits (fields) and registers to which they relate is given in the documentation, we note the impact of the totality of their values ‚Äã‚Äãon the interrupt handling mode: </p><br><p><img src="https://habrastorage.org/files/95b/00a/3a7/95b00a3a78d846e39168f1719f97233f.png" alt="image"></p><br><h2 id="sistemnyy-taymer">  System timer </h2><br><p>  Before proceeding to the description of work with interruptions consider one of their most frequent sources - the system timer.  It is extremely simple in its capabilities, but it is part of the processor core and can work even in the power saving mode, which means it is available in any environment. </p><br><p>  Two registers are used to work with it: </p><br><ul><li>  <strong>Count</strong> - Counter register.  If <strong>Cause.DC</strong> == 0 (disable count register, default = 0), is incremented by one for each processor tick.  The only way to reset the counter values ‚Äã‚Äãis to write a new value (for example, zero) to it, a timer interrupt signal (caused by the equality <strong>Count</strong> == <strong>Compare</strong> ) does not automatically reset the counter; </li><li>  <strong>Compare</strong> - The comparison register.  When <strong>Count</strong> == <strong>Compare</strong> and <strong>Compare</strong> ! = 0, the <em>SI_TimerInt</em> signal, which serves as the source of the interrupt, is set to one, and the <strong>Cause.TI</strong> (timer interrupt) bit is simultaneously set.  To reset this signal, you need to write to <strong>Compare</strong> . </li></ul><br><p>  To work with these registers, it is convenient to use the mips32_setcompare and mips32_setcount macros, which are declared in mips / cpu.h, to initialize and reset the timer, in fact, use the same code [ <a href="">S0</a> ]: </p><br><pre> <code class="cpp hljs">mips32_setcompare(MIPS_TIMER_PERIOD); <span class="hljs-comment"><span class="hljs-comment">//set compare (TOP) value to turn on /reset timer mips32_setcount(0); //reset counter</span></span></code> </pre> <br><p>  The screenshot below shows the moments of timer initialization and reset when processing an interrupt. </p><br><p><img src="https://habrastorage.org/files/2a6/8c8/355/2a68c835553c41028c537ac7c027c6b7.png" alt="image"></p><br><p>  The presence of the <em>SI_TimerInt</em> signal <em>is</em> not sufficient to <em>trigger</em> an interrupt.  In order for it to be processed, it must be correctly routed at the RTL level, which depends on the current interrupt mode (Interrupt mode), which will be discussed below. </p><br><h2 id="interrupt-compatibility-mode">  Interrupt Compatibility mode </h2><br><p>  Backward compatibility mode with MIPS32 Release 1. Key features: </p><br><ul><li>  8 external interrupts are available: inputs <em>SI_Int [7: 0]</em> , which correspond to the flags <strong>Cause.IP9</strong> - <strong>IP2</strong> ; </li><li>  2 software interrupts are available: <strong>Cause.IP1</strong> - <strong>IP0</strong> ; </li><li>  regardless of the input at which the interrupt occurred, control is transferred to a single handler, which, among other things, is responsible for handling exceptions; </li><li>  hardware interrupt prioritization is missing; </li><li>  the definition of the highest priority interrupt is left to the developer and is performed inside the handler by analyzing <strong>Cause.IP9</strong> - <strong>IP0</strong> , <strong>Cause.TI</strong> . </li><li>  the timer interrupt output ( <em>SI_TimerInt</em> ) must be associated with one of the <em>SI_Int [7: 0]</em> inputs.  For this, it is not necessary to explicitly connect the signals to each other, you can use the input <em>SI_IPTI [2: 0]</em> , the value at which 0x2 means that <em>SI_TimerInt is</em> connected to <em>SI_Int [0]</em> , respectively, 0x7 will mean connection to <em>SI_Int [5]</em> .  Connection to <em>SI_Int [5]</em> is considered traditional. </li><li>  if we talk about MIPS32 Release 1 processors, only 6 external interrupts were available in them ( <strong>Cause.IP9</strong> - <strong>IP8</strong> are missing) [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D4_MIPS32_r1_Vol3.pdf">D4</a> ], hence the inability to switch the timer interrupt using <em>SI_IPTI [2: 0]</em> to any port more than <em>SI_Int [5]</em> .  Thus, the backward compatibility mode provides several more options than was originally available in MIPS32 Release 1. </li></ul><br><p>  Those who received the first experience of development for embedded systems on relatively modern microcontrollers may experience some confusion from "only" 6 external interrupts and one common handler for everything, including the lion's share of exceptions.  Here we should take into account some historicity of the MIPS architecture: it was assumed that the interrupt sources will be connected hierarchically, it was taken into account that the entry code in (exit) interrupt is common for all handlers, and since  external devices are inherently slow (events rarely occur), then there is no particular loss in performance from "manual" checking of sources and priorities, and there is even some room for possible optimizations.  An example of such a connection from [ <a href="http://rus-linux.net/MyLDP/BOOKS/Embedded_Linux_system_design_and_development_ru.pdf">L5</a> ] is shown below. </p><br><p><img src="https://habrastorage.org/files/38a/767/c8a/38a767c8a904428283be8ce3d8b70213.png" alt="image"></p><br><p>  Even if these features are considered a ‚Äúflaw‚Äù, they are easily compensated by the possibility of using an external interrupt controller connected via the corresponding interface of the MIPSfpga processor core, which will be discussed in the corresponding section. </p><br><h3 id="primer">  Example </h3><br><h4 id="poryadok-zapuska">  Start order </h4><br><ul><li>  Check that the following settings are set in the mfp_ahb_lite_matrix_config.vh file (the setting for using the external interrupt controller must be commited) [ <a href="">S1</a> ]: </li></ul><br><pre> <code class="hljs objectivec">`define MFP_USE_WORD_MEMORY <span class="hljs-comment"><span class="hljs-comment">//`define MFP_USE_IRQ_EIC</span></span></code> </pre> <br><ul><li>  Go to the directory mipsfpga-plus / programs / 06_timer_irq /; </li><li>  In the main.c file, install [ <a href="">S2</a> ]: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RUNTYPE COMPATIBILITY</span></span></code> </pre> </li><li>  Run the build program and run it in the simulator: <br><pre> <code class="hljs css">02_<span class="hljs-selector-tag"><span class="hljs-selector-tag">compile_and_link</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 05_<span class="hljs-selector-tag"><span class="hljs-selector-tag">generate_verilog_readmemh_file</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 06_<span class="hljs-selector-tag"><span class="hljs-selector-tag">simulate_with_modelsim</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span></code> </pre> </li><li>  After the completion of the simulation script, press "no" to prevent the simulator from closing; </li></ul><br><h4 id="opisanie-programmy-i-konfiguracii-sistemy">  Program Description and System Configuration </h4><br><ul><li><p>  The settings set in the RTL header files lead to the following configuration of the interrupt interface of the processor core [ <a href="">S3</a> ]: </p><br><pre> <code class="hljs vhdl">assign SI_Offset = <span class="hljs-number"><span class="hljs-number">17</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> used assign SI_EISS = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> used assign SI_Int[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign SI_Int[<span class="hljs-number"><span class="hljs-number">3</span></span>] = uart_interrupt; assign SI_Int[<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign SI_EICVector = <span class="hljs-number"><span class="hljs-number">6</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> used assign SI_EICPresent = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; //no external interrupt controller assign SI_IPTI = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h7</span></span>; //enable MIPS timer interrupt <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> HW5</code> </pre> <br></li><li><p>  The file exceptions.S contains the necessary interrupt vectors for operation, they are practically of the same type [ <a href="">S4</a> ]: </p><br><pre> <code class="hljs vbscript"> .org <span class="hljs-number"><span class="hljs-number">0x200</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> symbol offset from section beginning .weak __mips_isr_sw0 # <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the symbol does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> already exist, it will be created __isr_vec_sw0: la $k1, __mips_isr_sw0 # load interrupt handler (__mips_isr_sw0) addr beqz $k1, __general_exception # <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> present <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> generic nop jr $k1 # jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> irq_sw0 nop</code> </pre> <br></li><li><p>  Exception vectors differ from interrupt vectors in that if the corresponding handler is not defined in the program, the code is looped [ <a href="">S5</a> ]: </p><br><pre> <code class="hljs vhdl"> .org <span class="hljs-number"><span class="hljs-number">0</span></span>x0 # set symbol offset from section beginning .weak _mips_tlb_refill # <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the symbol does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> already exist, it will be created __tlb_refill: la $k1, _mips_tlb_refill # load exception handler (_mips_tlb_refill) addr beqz $k1, __tlb_refill # <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _mips_tlb_refill doen <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exist <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> just <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> here nop jr $k1 # jump <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> _mips_tlb_refill. # we can <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'j</span></span> _mips_tlb_refill' nop # but it works only <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>st <span class="hljs-number"><span class="hljs-number">28</span></span> bits <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> addr</code> </pre> <br></li><li><p>  In the mian.c file, the timer [ <a href="">S0</a> ] is sequentially initialized: </p><br><pre> <code class="cpp hljs">mips32_setcompare(MIPS_TIMER_PERIOD); <span class="hljs-comment"><span class="hljs-comment">//set compare (TOP) value to turn timer on mips32_setcount(0); //reset counter</span></span></code> </pre> <br></li><li><p>  Interrupt initialization [ <a href="">S6</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//compatibility mode, one common handler // Status.BEV 0 - place handlers in kseg0 (0x80000000) mips32_bicsr (SR_BEV); // Cause.IV, 0 - general exception handler (offset 0x180) mips32_biccr (CR_IV); // interrupt enable, HW5, SR_SINT1 - unmasked mips32_bissr (SR_IE | SR_HINT5 | SR_SINT1);</span></span></code> </pre> <br></li><li><p>  And their processing in a single handler, assuming sequential: checking whether the exception is an interrupt, determining which interrupt is needed to be processed, and the processing itself [ <a href="">S7</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked)) _mips_general_exception () { MFP_RED_LEDS = MFP_RED_LEDS | <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cause = mips32_getcr(); <span class="hljs-comment"><span class="hljs-comment">//check that this is interrupt exception if((cause &amp; CR_XMASK) == 0) { //check for timer interrupt if(cause &amp; CR_HINT5) { MFP_RED_LEDS = MFP_RED_LEDS | 0x10; n++; mipsTimerReset(); mips32_biscr(CR_SINT1); //request for software interrupt 1 MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x10; } //check for software interrupt 1 else if (cause &amp; CR_SINT1) { MFP_RED_LEDS = MFP_RED_LEDS | 0x8; mips32_biccr(CR_SINT1); //clear software interrupt 1 flag MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x8; } } MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x1; }</span></span></code> </pre> <br></li><li>  In this example, the associated interrupt flag (HW5) is used to check the interrupt of the system timer, for the same purpose you can use <strong>Cause.TI</strong> (macro CR_TI); </li><li>  Each of the stages of the program is reflected by the corresponding state of MFP_RED_LEDS; </li><li><p>  In the timer interrupt (HW5), the counter is incremented, the timer is reset, and the program interrupt request flag SW1 is set [ <a href="">S8</a> ]: </p><br><pre> <code class="cpp hljs">n++; mipsTimerReset(); mips32_biscr(CR_SINT1);</code> </pre> <br></li><li><p>  In interrupt SW1, only the interrupt flag is reset [ <a href="">S9</a> ]: </p><br><pre> <code class="cpp hljs">mips32_biccr(CR_SINT1);</code> </pre> <br></li><li>  All flag macros used for this are declared in mips / cpu.h; </li><li><p>  In the code of the main function, the counter is cyclically outputted to 7-segment indicators [ <a href="">S10</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) MFP_7_SEGMENT_HEX = n;</code> </pre> <br></li><li>  The result of the program is a signal diagram similar to the one below.  Please note that we can observe the values ‚Äã‚Äãof the registers, in particular <strong>Cause</strong> and <strong>Status</strong> , <strong>PC</strong> , <strong>Count</strong> and <strong>ompare</strong> , in real time, which greatly simplifies debugging. </li></ul><br><p><img src="https://habrastorage.org/files/038/851/847/0388518473e841f1bb060cd7cab98a22.png" alt="image"></p><br><h2 id="vector-interrupt-mode">  Vector Interrupt mode </h2><br><p>  Interrupt vector mode. </p><br><p><img src="https://habrastorage.org/files/cdf/bfb/08d/cdfbfb08dd214db88439a1ac78ac7451.png" alt="image"></p><br><p>  Key Features: </p><br><ul><li>  the number and composition of interrupts processed (8 external and 2 software), as well as the procedure for working with SI_TimerInt are completely similar to Interrupt Compatibility mode; </li><li>  to handle each of the interrupts using its own handler (vector); </li><li>  interrupts have priorities that determine the order in which they are processed by the processor core.  In order of increasing priority: SW0, SW1 (software interrupts), HW0-HW7 (hardware interrupts, correspond to SI_Int signals [7: 0]) </li></ul><br><p><img src="https://habrastorage.org/files/5ed/cd7/e53/5edcd7e53bf949898492e47de792bdcf.png" alt="image"></p><br><ul><li>  the first of the vector interrupt handlers is placed at offset 0x200; </li><li>  the offset between the first and second, as well as all subsequent processors is determined by the field <strong>IntCtl.VS</strong> .  So for <strong>IntCtl.VS</strong> = 1, this offset will be 0x20: </li></ul><br><p><img src="https://habrastorage.org/files/28a/4de/6c4/28a4de6c42be4794a73efe77b9d4334d.png" alt="image"></p><br><h3 id="primer-1">  Example </h3><br><h4 id="poryadok-zapuska-1">  Start order </h4><br><ul><li>  It is completely analogous to that for backward compatibility mode, except for the need to install [ <a href="">S2</a> ] in the main.c file: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RUNTYPE VECTOR</span></span></code> </pre> <br><h4 id="opisanie-programmy-i-konfiguracii-sistemy-1">  Program Description and System Configuration </h4><br><ul><li>  RTL system configuration is similar to that for backward compatibility mode; </li><li>  It uses the same file exceptions.S [ <a href="">S4</a> , <a href="">S5</a> ] and absolutely identical timer initialization order [ <a href="">S0</a> ]; </li><li><p>  Setting up interrupt operation is as follows [ <a href="">S11</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//vector mode, multiple handlers // Status.BEV 0 - place handlers in kseg0 (0x80000000) mips32_bicsr (SR_BEV); // Cause.IV, 1 - special int vector (offset 0x200), // where 0x200 - base for other vectors mips32_biscr (CR_IV); // get IntCtl reg value uint32_t intCtl = mips32_getintctl(); // set interrupt table vector spacing (0x20 in our case) // see exceptions.S for details mips32_setintctl(intCtl | INTCTL_VS_32); // interrupt enable, HW5 and SW0,SW1 - unmasked mips32_bissr (SR_IE | SR_HINT5 | SR_SINT0 | SR_SINT1);</span></span></code> </pre> <br></li><li><p>  The program operation procedure is absolutely similar to the previously described one, except that the timer interrupt (HW5) is used to set not one but two program interrupt flags (SW0 and SW1), which will then be processed in order of priority [ <a href="">S12</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked)) __mips_isr_hw5 () { MFP_RED_LEDS = MFP_RED_LEDS | <span class="hljs-number"><span class="hljs-number">0x4</span></span>; n++; mipsTimerReset(); mips32_biscr(CR_SINT0); <span class="hljs-comment"><span class="hljs-comment">//request for software interrupt 0 mips32_biscr(CR_SINT1); //request for software interrupt 1 MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x4; }</span></span></code> </pre> <br></li><li><p>  For interrupt handling SW0, a separate vector is used [ <a href="">S13</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked)) __mips_isr_sw0 () { MFP_RED_LEDS = MFP_RED_LEDS | <span class="hljs-number"><span class="hljs-number">0x2</span></span>; mips32_biccr(CR_SINT0); <span class="hljs-comment"><span class="hljs-comment">//clear software interrupt 0 flag MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x2; }</span></span></code> </pre> <br></li><li>  SW1 processing is performed by the same _mips_general_exception as in the case of backward compatibility mode, but with an important addition: the transition to this function is not because the processor immediately went to the offset 0x180.  Execution is transmitted to 0x220, but since  the <strong>mips_isr_sw1</strong> function <strong>is not declared, then goes to</strong> general_exception (this is done by the assembler code from exceptions.S, which is given above) [ <a href="">S14</a> ]. </li><li>  The result of the program is a signal diagram similar to the following: </li></ul><br><p><img src="https://habrastorage.org/files/972/a82/ff9/972a82ff9d49406b9292d6cef82218ca.png" alt="image"></p><br><h2 id="external-interrupt-controller-mode">  External Interrupt Controller mode </h2><br><h3 id="kontroller-vneshnih-preryvaniy">  External Interrupt Controller </h3><br><p><img src="https://habrastorage.org/files/f8f/acc/9d5/f8facc9d504f481397a491f9f218826a.png" alt="image"></p><br><p>  Before proceeding to the description of work in the External Interrupt Controller mode, consider how this module interacts with the processor core and what it is like. <br>  The controller's task is to register external interrupts and issue information on the most priority among them to the Interrupt Interface: </p><br><ul><li>  <em>SI_EICPresent</em> - sign of the presence of an external interrupt controller; </li><li>  <em>SI_Int [7: 0]</em> - the priority of the requested interrupt; </li><li>  <em>SI_EISS [3: 0]</em> - determines the number of the set of shadow registers (shadow set number), in the case of MIPSfpga - not used; </li><li>  <em>SI_EICVector</em> - vector number of the requested interrupt; </li><li>  <em>SI_Offset [17: 1]</em> - offset of the requested interrupt; </li></ul><br><p>  Accepting the next interrupt request for processing, the processor informs the controller: </p><br><ul><li>  <em>SI_IAck a</em> single impulse informs about the start of interrupt processing; </li><li>  <em>SI_IPL [7: 0]</em> - the priority of the processed interrupt; </li><li>  <em>SI_IVN [5: 0]</em> - the number of the vector of the interrupt being processed; </li><li>  <em>SI_ION [17: 0]</em> - offset of the interrupt being processed; </li></ul><br><p>  The typical interaction between the controller and the processor core is shown below: </p><br><p><img src="https://habrastorage.org/files/88f/073/049/88f073049d524ccfbefdbe74bdc4c7fc.png" alt="image"></p><br><p>  You should also consider: </p><br><ul><li>  Since  In this case, interrupt prioritization is performed by a non-processor core, then all interrupts generated by it should also be sent to the controller input: a system timer interrupt ( <em>SI_TimerInt</em> signal <em>Cause.TI</em> flag), program interrupts ( <em>SI_SWInt</em> signals <em>[1: 0]</em> , <strong>Cause.IP1</strong> flags - <strong>IP0</strong> ) and others - is reflected in more detail in [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ]; </li><li>  How the kernel calculates the address of the handler offset: takes it directly from <em>SI_Offset [17: 1]</em> , or converts from <em>SI_EICVector</em> is determined by the currently activated option: "Option 1 - Explicit Vector Number" or "Option 2 - Explicit Vector Offset".  In the first case - 64 vectors are available to us, in the second - we have 256K memory counted from the base to accommodate our vectors in it, which should be enough even for the most demanding task interruption.  MIPS microAptiv core commercial customers set this parameter in the graphical configurator.  It is not available in MIPSfpga, but this setting can be done in the file m14k_cpz_eicoffset_stub.v: 84.  To do this, it is necessary to replace the value of <em>eic_offset</em> with one: </li></ul><br><pre> <code class="hljs lisp">assign eic_offset = <span class="hljs-number"><span class="hljs-number">1</span></span>'b1<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><ul><li>  The decision to process the interrupt requested by the controller is made by the processor on the basis of the minimum acceptable priority (set in <strong>Status.IPL</strong> ), all interrupts with a priority lower than the specified one will be ignored; </li></ul><br><h3 id="kontroller-preryvaniy-mipsfpga-plus">  MIPSfpga-plus Interrupt Controller </h3><br><p>  Main characteristics: </p><br><ul><li>  It is part of the MIPSfpga-plus [ <a href="https://github.com/MIPSfpga/mipsfpga-plus">L3</a> ] system; </li><li>  Up to 64 interrupts are available, the exact number of which can be specified in the configuration file (mfp_eic_core.vh) [ <a href="">S15</a> ]; </li><li>  Two types of input channels are implemented: direct (direct channel) and sensitivity setting (sense channel).  For the first, an indication of the interrupt request is a high signal level.  For the second, this parameter can be configured: front, decay, low signal level, any change in signal; </li><li>  The maximum number of channels such as sense channel is 32; </li><li>  The simplicity of the controller allows, if necessary, to implement even more interrupts, for this you will need to make small changes to the code, in particular, to add configuration registers; </li><li>  All signals input to the controller must be synchronized; </li><li>  The work is supported both in the mode "Option 1 - Explicit Vector Number" and "Option 2 - Explicit Vector Offset"; </li><li>  The program can automatically configure the function of automatically lowering the interrupt flag at the beginning of its processing by the processor core; </li><li>  If necessary, a separate sandbox with a controller is available on github, in which its work was debugged [ <a href="https://github.com/zhelnio/ahb_lite_eic">L6</a> ]; </li><li>  The controller is connected to the processor core at the top level of MIPSfpga-plus (mfp_system.v), <em>EIC_input</em> - signals from interrupt sources, other I / <em>Os</em> refer to the processor interrupt interface [ <a href="">S21</a> ]: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-string"><span class="hljs-string">`ifdef MFP_USE_IRQ_EIC .EIC_input ( EIC_input ), .EIC_Offset ( SI_Offset ), .EIC_ShadowSet ( SI_EISS ), .EIC_Interrupt ( SI_Int ), .EIC_Vector ( SI_EICVector ), .EIC_Present ( SI_EICPresent ), .EIC_IAck ( SI_IAck ), .EIC_IPL ( SI_IPL ), .EIC_IVN ( SI_IVN ), .EIC_ION ( SI_ION ), `</span></span>endif <span class="hljs-comment"><span class="hljs-comment">//MFP_USE_IRQ_EIC</span></span></code> </pre> <br><p>  The controller includes the following files: </p><br><ul><li>  mfp_eic_core.v - controller core [ <a href="">S17</a> ]; </li><li>  mfp_eic_core.vh - main configuration file (see comments inside) [ <a href="">S15</a> ]; </li><li>  mfp_eic_handler.v - contains logic for converting the interrupt number to vector / offset and back (see comments inside) [ <a href="">S18</a> ]; </li><li>  mfp_eic_priority_encoder.v - priority encoder with a hierarchical (tree) organization [ <a href="">S19</a> ]; </li><li>  mfp_ahb_lite_eic.v is a top-level module that provides an interface with the AHB-Lite bus [ <a href="">S20</a> ]. </li></ul><br><p>  In order to form a general idea of ‚Äã‚Äãthe configuration of the controller, we list its configuration registers, their full description in [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D5_20170320_mfp_EIC.pdf">D5</a> ].  For all registers except <strong>EICR</strong> , <strong>EISMSK_0</strong> and <strong>EISMSK_1,</strong> it is assumed that the bit number corresponds to the controller's input number.  So, for example, <strong>EIFR_0 [3]</strong> = 1 - means that an unhandled interrupt is waiting for input 3. </p><br><p><img src="https://habrastorage.org/files/69f/a18/a22/69fa18a22fb543878ca2024f59a36be9.png" alt="image"></p><br><h3 id="primer-2">  Example </h3><br><h4 id="poryadok-zapuska-2">  Start order </h4><br><ul><li>  Check that the following mode [ <a href="">S1</a> ] is set in the file mfp_ahb_lite_matrix_config.vh: <br><pre> <code class="hljs markdown"><span class="hljs-code"><span class="hljs-code">`define MFP_USE_IRQ_EIC `</span></span>define MFP<span class="hljs-emphasis"><span class="hljs-emphasis">_USE_</span></span>WORD_MEMORY</code> </pre> </li><li>  Check that the m14k_cpz_eicoffset_stub.v file is set to: <br><pre> <code class="hljs lisp">assign eic_offset = <span class="hljs-number"><span class="hljs-number">1</span></span>'b0<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  Go to the directory mipsfpga-plus / programs / 07_eic /; </li><li>  Run the build program and run it in the simulator: <br><pre> <code class="hljs css">02_<span class="hljs-selector-tag"><span class="hljs-selector-tag">compile_and_link</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 05_<span class="hljs-selector-tag"><span class="hljs-selector-tag">generate_verilog_readmemh_file</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span> 06_<span class="hljs-selector-tag"><span class="hljs-selector-tag">simulate_with_modelsim</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bat</span></span></code> </pre> </li><li>  After the completion of the simulation script, press "no" to prevent the simulator from closing; </li></ul><br><h4 id="opisanie-programmy-i-konfiguracii-sistemy-2">  Program Description and System Configuration </h4><br><ul><li><p>  The settings set in the RTL header files lead to the following configuration [ <a href="">S16</a> ]: </p><br><pre> <code class="hljs scala">wire [ `<span class="hljs-type"><span class="hljs-type">EIC_CHANNELS</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> ] <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[`<span class="hljs-type"><span class="hljs-type">EIC_CHANNELS</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>] = {`<span class="hljs-type"><span class="hljs-type">EIC_CHANNELS</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>}}; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-type"><span class="hljs-type">SI_TimerInt</span></span>; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>] = uart_interrupt; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-type"><span class="hljs-type">SI_SWInt</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; assign <span class="hljs-type"><span class="hljs-type">EIC_input</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-type"><span class="hljs-type">SI_SWInt</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; assign <span class="hljs-type"><span class="hljs-type">SI_IPTI</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>;</code> </pre> <br></li><li>  Interrupt Interface bus signals are processed by the mfp_ahb_lite_eic module, as shown above; </li><li><p>  The file exceptions.S is similar to the two previous examples, except for the naming of interrupts and their number.  So, the latest HW63 is located at offset 0x9E0 [ <a href="">S22</a> ]: </p><br><pre> <code class="hljs perl"> .org <span class="hljs-number"><span class="hljs-number">0x9E0</span></span> .weak __mips_isr_eic63 __isr_vec_eic63: la $k1, __mips_isr_eic63 beqz $k1, __general_exception nop jr $k1 nop</code> </pre> <br></li><li>  All macros necessary for working with the registers of the controller are moved to the file eic.h [ <a href="">S23</a> ]; </li><li>  The timer is initialized in main.c in the same way as before; </li><li><p>  Initialization of interrupts [ <a href="">S24</a> ]: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//eic mode //unmask interrupt MFP_EIC_EIMSK_0 = (1 &lt;&lt; IRQSW0) | (1 &lt;&lt; IRQSW1) | (1 &lt;&lt; IRQTIMER); MFP_EIC_EIMSK_1 = (1 &lt;&lt; IRQ63); //enable auto clear MFP_EIC_EIACM_0 = (1 &lt;&lt; IRQSW0) | (1 &lt;&lt; IRQSW1) | (1 &lt;&lt; IRQTIMER); //set interrupt on rising edge of the signal MFP_EIC_EISMSK_0 = (SMSK_RIZE &lt;&lt; SMSKSW0) | (SMSK_RIZE &lt;&lt; SMSKSW1) | (SMSK_RIZE &lt;&lt; SMSKTIMER); // Status.BEV 0 - vector interrupt mode mips32_bicsr (SR_BEV); // Cause.IV, 1 - special int vector (0x200) // where 0x200 - base when Status.BEV = 0; mips32_biscr (CR_IV); // get IntCtl reg value uint32_t intCtl = mips32_getintctl(); // set interrupt table vector spacing (0x20 in our case) // see exceptions.S for details mips32_setintctl(intCtl | INTCTL_VS_32); // enable external interrupt controller // enable interrupts MFP_EIC_EICR = 0x1; mips32_bissr (SR_IE);</span></span></code> </pre> <br></li><li>          RTL : interrupt_sence ‚Äî        [ <a href="">S28</a> ], interrupt_channel ‚Äî          <strong>EIFR</strong> [ <a href="">S29</a> ].          priority_encoder        ‚Äî     <em>EIC_input</em> ,     [ <a href="">S19</a> ].       handler_params_encoder [ <a href="">S18</a> ],      /; </li><li><p>  ,       (Option 2 ‚Äî Explicit Vector Offset),       (m14k_cpz_eicoffset_stub.v),    mfp_eic_core.vh [ <a href="">S15</a> ]  </p><br><pre> <code class="hljs">`define EIC_USE_EXPLICIT_VECTOR_OFFSET</code> </pre> <br></li><li>       /        , ..  ,   mfp_eic_handler.v    <strong>IntCtl.VS</strong> = 1 (32 ) [ <a href="">S25</a> ]; </li><li><p>      ,     [ <a href="">S26</a> ]: </p><br><pre> <code class="cpp hljs">ISR(IH_SW0) { MFP_RED_LEDS = MFP_RED_LEDS | <span class="hljs-number"><span class="hljs-number">0x1</span></span>; mips32_biccr(CR_SINT0); <span class="hljs-comment"><span class="hljs-comment">//clear software interrupt 0 flag MFP_RED_LEDS = MFP_RED_LEDS &amp; ~0x1; }</span></span></code> </pre> <br></li><li>  ISR  EH_GENERAL   eic.h [ <a href="">S27</a> ]; </li><li>      : </li></ul><br><p><img src="https://habrastorage.org/files/38a/0c0/0bc/38a0c00bc50d4e1daf43cb0520a356cf.png" alt="image"></p><br><ul><li>     : </li></ul><br><p><img src="https://habrastorage.org/files/8df/f09/780/8dff09780fd94bc89c2aeae958d49d8c.png" alt="image"></p><br><h2 id="podderzhka-kompilyatorom">   </h2><br><p>         ,      , ..         [ <a href="https://community.imgtec.com/developers/mips/tools/codescape-mips-sdk/">L7</a> ].       . <br><br>  [ <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D3_MIPS_Toolchain_Codescape_GNU_Tools_for_MIPS_Programmers_Guide_1.1.97.pdf">D3</a> ]    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt)) v0 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, use_shadow_register_set)) v1 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked)) v2 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, use_debug_exception_return)) v3 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, use_shadow_register_set, keep_interrupts_masked)) v4 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, use_shadow_register_set, use_debug_exception_return)) v5 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, keep_interrupts_masked, use_debug_exception_return)) v6 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt, use_shadow_register_set, keep_interrupts_masked, use_debug_exception_return)) v7 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt(<span class="hljs-string"><span class="hljs-string">"eic"</span></span>))) v8 (); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __attribute__ ((interrupt(<span class="hljs-string"><span class="hljs-string">"vector=hw3"</span></span>))) v9 ();</code> </pre> <br><p>      : </p><br><ul><li>  use_shadow_register_set      , ..       MIPSfpga; </li><li>    interrupt("vector=hw3")       ; </li><li> ,    (interrupt, keep_interrupts_masked),       : </li></ul><br><div class="spoiler"> <b class="spoiler_title">(interrupt, keep_interrupts_masked)</b> <div class="spoiler_text"><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__attribute__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((interrupt, keep_interrupts_masked)</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__mips_isr_sw0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">80001544</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span>b7000 mfc0 k1,c0_epc <span class="hljs-number"><span class="hljs-number">80001548</span></span>: <span class="hljs-number"><span class="hljs-number">27</span></span>bdfff0 addiu sp,sp,-<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">8000154</span></span>c: afbb000c sw k1,<span class="hljs-number"><span class="hljs-number">12</span></span>(sp) <span class="hljs-number"><span class="hljs-number">80001550</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span>b6000 mfc0 k1,c0_status <span class="hljs-number"><span class="hljs-number">80001554</span></span>: afbb0008 sw k1,<span class="hljs-number"><span class="hljs-number">8</span></span>(sp) <span class="hljs-comment"><span class="hljs-comment">//  k1    status.exl,.erl,.um, .ie; 80001558: 7c1b2004 ins k1,zero,0x0,0x5 // status 8000155c: 409b6000 mtc0 k1,c0_status 80001560: afbe0004 sw s8,4(sp) 80001564: 03a0f025 move s8,sp ... } 80001568: 03c0e825 move sp,s8 8000156c: 8fbe0004 lw s8,4(sp) 80001570: 8fbb000c lw k1,12(sp) 80001574: 409b7000 mtc0 k1,c0_epc 80001578: 8fbb0008 lw k1,8(sp) 8000157c: 27bd0010 addiu sp,sp,16 80001580: 409b6000 mtc0 k1,c0_status 80001584: 42000018 eret</span></span></code> </pre> </div></div><br><ul><li> ,    (interrupt),       : </li></ul><br><div class="spoiler"> <b class="spoiler_title">(interrupt)</b> <div class="spoiler_text"><pre> <code class="hljs ruby">void __attribute_<span class="hljs-number"><span class="hljs-number">_</span></span> ((interrupt)) __mips_isr_hw5 () { <span class="hljs-number"><span class="hljs-number">80001588</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span>a680<span class="hljs-number"><span class="hljs-number">0</span></span> mfc<span class="hljs-number"><span class="hljs-number">0</span></span> k<span class="hljs-number"><span class="hljs-number">0</span></span>,c0_cause <span class="hljs-number"><span class="hljs-number">8000158</span></span><span class="hljs-symbol"><span class="hljs-symbol">c:</span></span> <span class="hljs-number"><span class="hljs-number">401</span></span>b700<span class="hljs-number"><span class="hljs-number">0</span></span> mfc<span class="hljs-number"><span class="hljs-number">0</span></span> k1,c0_epc <span class="hljs-number"><span class="hljs-number">80001590</span></span>: <span class="hljs-number"><span class="hljs-number">27</span></span>bdfff<span class="hljs-number"><span class="hljs-number">0</span></span> addiu sp,sp,-<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">80001594</span></span>: afbb000c sw k1,<span class="hljs-number"><span class="hljs-number">12</span></span>(sp) <span class="hljs-number"><span class="hljs-number">80001598</span></span>: <span class="hljs-number"><span class="hljs-number">401</span></span>b600<span class="hljs-number"><span class="hljs-number">0</span></span> mfc<span class="hljs-number"><span class="hljs-number">0</span></span> k1,c0_status /<span class="hljs-regexp"><span class="hljs-regexp">/   k0  cause.ip7-ip2 8000159c: 001ad282 srl k0,k0,0xa 800015a0: afbb0008 sw k1,8(sp) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  k1  cause.ip6-ip2   status.im7-im2 800015a4: 7f5b7a84 ins k1,k0,0xa,0x6 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  k1    status.exl,.erl,.um; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ .ie     ( 1) 800015a8: 7c1b2044 ins k1,zero,0x1,0x4 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ status 800015ac: 409b6000 mtc0 k1,c0_status 800015b0: afbe0004 sw s8,4(sp) 800015b4: 03a0f025 move s8,sp ... } 800015b8: 03c0e825 move sp,s8 800015bc: 8fbe0004 lw s8,4(sp) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/disable interrupts (status.ie = 0) 800015c0: 41606000 di 800015c4: 000000c0 ehb 800015c8: 8fbb000c lw k1,12(sp) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ epc 800015cc: 409b7000 mtc0 k1,c0_epc 800015d0: 8fbb0008 lw k1,8(sp) 800015d4: 27bd0010 addiu sp,sp,16 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ status   800015d8: 409b6000 mtc0 k1,c0_status 800015dc: 42000018 eret</span></span></code> </pre> </div></div><br><ul><li>  ,     keep_interrupts_masked,            ,        .                     . </li></ul><br><h2 id="blagodarnosti">  Thanks </h2><br><p>  The author is grateful to the <a href="https://habrahabr.ru/post/259505/">team of translators of the</a> textbook by David Harris and Sarah Harris ‚ÄúDigital Circuit Design and Computer Architecture‚Äù, by <a href="https://www.imgtec.com/">Imagination Technologies</a> for the academic license for a modern processor core and personally for Yuri Panchul <a href="https://habrahabr.ru/users/yuripanchul/" class="user_link">YuriPanchul</a> for his work on promoting MIPSfpga. </p><br><h2 id="ssylki">  Links </h2><br><p>  [L1] - <a href="https://habrahabr.ru/post/259505/">Digital circuit design and computer architecture</a> ; <br>  [L2] - <a href="https://habrahabr.ru/post/275215/">How to start working with MIPSfpga</a> ; <br>  [L3] - <a href="https://github.com/MIPSfpga/mipsfpga-plus">MIPSfpga-plus project on github</a> ; <br> [L4] ‚Äî <a href="http://de10-lite.terasic.com/">FPGA  Terasic DE10-Lite</a> ; <br> [L5] ‚Äî <a href="https://pixhawk.ethz.ch/_media/dev/literature/embedded_linux_system_design_and_development.pdf">Embedded Linux System Design and Development P. Raghavan, Amol Lad, Sriram Neelakandan</a> ( <a href="http://rus-linux.net/MyLDP/BOOKS/Embedded_Linux_system_design_and_development_ru.pdf"></a> ); <br> [L6] ‚Äî <a href="https://github.com/zhelnio/ahb_lite_eic"> ahb_lite_eic  github</a> ; <br> [L7] ‚Äî <a href="https://community.imgtec.com/developers/mips/tools/codescape-mips-sdk/">Codescape MIPS SDK</a> ; </p><br><h2 id="dokumentaciya">  Documentation </h2><br><p> [D1] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D1_MicroAptiv_UP_Integrators_Guide_MD00941.pdf">MIPS32 microAptiv UP Processor Core Family Integrator's Guide</a> ; <br> [D2] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">MIPS32 microAptiv UP Processor Core Family Software User's Manual</a> ; <br> [D3] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D3_MIPS_Toolchain_Codescape_GNU_Tools_for_MIPS_Programmers_Guide_1.1.97.pdf">Codescape GNU Tools for MIPS Programmer's Guide</a> ; <br> [D4] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D4_MIPS32_r1_Vol3.pdf">MIPS32 Architecture For Programmers Volume III: The MIPS32 Privileged Resource Architecture</a> ; <br> [D5] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D5_20170320_mfp_EIC.pdf">MIPSfpga+ External Interrupt Controller</a> ; <br> [D6] ‚Äî <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D6_MicroAptiv_UP_Datasheet_MD00939.pdf">MIPS32 microAptiv UP Processor Core Family Datasheet</a> ; </p><br><h2 id="izobrazheniya-i-tablicy">  Images and tables </h2><br><p> [P0] ‚Äî <a href="">MIPS 32 microAptiv UP Core Block Diagram</a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D6_MicroAptiv_UP_Datasheet_MD00939.pdf">D6</a> ); <br> [P1] ‚Äî <a href="">     </a> ; <br> [P2] ‚Äî <a href="">   MIPS. </a> (); <br> [P3] ‚Äî <a href="">     </a> (: <a href="https://pixhawk.ethz.ch/_media/dev/literature/embedded_linux_system_design_and_development.pdf">L5</a> ); <br> [P4] ‚Äî <a href="">    . </a> (); <br> [P5] ‚Äî <a href="">    </a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ); <br> [P6] ‚Äî <a href="">    </a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ); <br> [P7] ‚Äî <a href="">     </a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ); <br> [P8] ‚Äî <a href="">   . </a> (); <br> [P9] ‚Äî <a href="">      </a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D2_MicroAptiv_UP_Software_Users_Manual_MD00942.pdf">D2</a> ); <br> [P10] ‚Äî <a href="">   </a> (: <a href="https://github.com/zhelnio/memos/blob/master/public/01_mips_interrupts/doc/D1_MicroAptiv_UP_Integrators_Guide_MD00941.pdf">D1</a> ); <br> [P11] ‚Äî <a href="">   </a> (: <a href="https://github.com/zhelnio/ahb_lite_eic">L6</a> ); <br> [P12] ‚Äî <a href="">     ,   </a> (); <br> [P13] ‚Äî <a href="">     ,  </a> (). </p><br><h2 id="ssylki-na-ishodnyy-kod">  References to source code </h2><br><p> [S0] ‚Äî <a href="">   </a> ; <br> [S1] ‚Äî <a href="">      mipsfpga-plus</a> ; <br> [S2] ‚Äî <a href="">    06_timer_irq</a> ; <br> [S3] ‚Äî <a href=""> mipsfpga-plus     </a> ; <br> [S4] ‚Äî <a href="">  </a> ; <br> [S5] ‚Äî <a href="">  </a> ; <br> [S6] ‚Äî <a href="">     </a> ; <br> [S7] ‚Äî <a href="">     </a> ; <br> [S8] ‚Äî <a href="">      </a> ; <br> [S9] ‚Äî <a href="">     </a> ; <br> [S10] ‚Äî <a href="">   main  06_timer_irq</a> ; <br> [S11] ‚Äî <a href="">    </a> ; <br> [S12] ‚Äî <a href="">     </a> ; <br> [S13] ‚Äî <a href="">       </a> ; <br> [S14] ‚Äî <a href="">       </a> ; <br> [S15] ‚Äî <a href="">     mipsfpga-plus</a> ; <br> [S16] ‚Äî <a href=""> mipsfpga-plus     </a> ; <br> [S17] ‚Äî <a href="">   </a> ; <br> [S18] ‚Äî <a href="">     </a> ; <br> [S19] ‚Äî <a href="">    </a> ; <br> [S20] ‚Äî <a href="">      AHB-Lite</a> ; <br> [S21] ‚Äî <a href="">     </a> ; <br> [S22] ‚Äî <a href="">  HW63</a> ; <br> [S23] ‚Äî <a href="">      </a> ; <br> [S24] ‚Äî <a href="">      </a> ; <br> [S25] ‚Äî <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setting the vector offset increment in the external interrupt controller mode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[S26] - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interrupt handler in the external interrupt controller mode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[S27] - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ISR and EH_GENERAL macros</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[S28] - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module interrupt_sence</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[S29] - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module interrupt_channel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324900/">https://habr.com/ru/post/324900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324890/index.html">On linear regression: Bayesian approach to the ruble exchange rate</a></li>
<li><a href="../324892/index.html">PHP Digest number 105 - interesting news, materials and tools (March 13 - 26, 2017)</a></li>
<li><a href="../324894/index.html">Making your first game on the Phaser. Part 0 - Getting Started</a></li>
<li><a href="../324896/index.html">Making your first game on the Phaser. Part 1 - Introduction</a></li>
<li><a href="../324898/index.html">Tensorflow deep learning library</a></li>
<li><a href="../324902/index.html">How Discord Indexes Billions of Posts</a></li>
<li><a href="../324904/index.html">Five important principles of working with data, which we forget when preparing a project presentation</a></li>
<li><a href="../324906/index.html">The story of how I went to Google Next 17. A brief pressing on the announcements and the most important</a></li>
<li><a href="../324908/index.html">A brief history of javascript. Part 3</a></li>
<li><a href="../324910/index.html">Why do you need a manufacturer‚Äôs service for IT equipment and its cost estimate?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>