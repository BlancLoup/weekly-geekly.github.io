<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting rid of Auto Layout</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Hi, my name is Nick Snyder and I am a software engineer at LinkedIn. Today I want to tell you a story about Auto Layout: 



1. As we i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting rid of Auto Layout</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Hi, my name is Nick Snyder and I am a software engineer at LinkedIn.  Today I want to tell you a story about Auto Layout: <br><br><ol><li>  As we in LinkedIn use it. </li><li>  The problems we met. </li><li>  Why in some situations we stopped using Auto Layout. </li><li>  And what we use instead. </li></ol><br><h3>  Good news </h3><br>  I would like to start with the good news: <br><br><ol><li>  We on LinkedIn make extensive use of Auto Layout.  This is our main method of building interfaces in all of our applications. </li><li>  Auto Layout is a powerful tool that facilitates support: <br><ol><li>  Various screen sizes; </li><li>  Languages ‚Äã‚Äãwith writing from right to left. </li></ol></li></ol><br><h3>  The bad news </h3><br>  The bad news is that Auto Layout performance is not good enough: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  It does not scale for complex view hierarchies (from the subsequent presentation it will be clear that this is a non-linear increase in the calculation time with a linear increase in the number of view - approx. Transl.). </li><li>  We have seen a performance setback on some iOS releases. </li><li>  Performance may turn out to be unpredictably bad for some interface layouts (hereinafter the layout is translated as ‚Äúmarkup‚Äù - approx. Transl.). </li></ol><a name="habracut"></a><br>  (Further, where the text of the transcript and the text of the slides significantly duplicate each other, I will merge without loss of information. The text and slides were used with the permission of the author. - approx. Transl.) <br><br><h3>  Auto Layout Problems </h3><br>  Consider an example of markup from a LinkedIn application.  Let there be two labels (here and hereinafter ‚Äúlabels‚Äù are used - approx. Transl.): A multi-line label on the left, and a single-line label on the right.  We need the right label to have enough space to display all its content.  The left label contains just a certain amount of text, which should take a maximum of two lines. <br><br><img src="https://habrastorage.org/web/be1/df9/c6a/be1df9c6a9124aa188f7226be238a199.PNG" alt="Auto Layout performance drop"><br>  <i>Note.</i>  <i>Auto Layout performance drop.</i>  <i>On the left is a label containing a maximum of two lines.</i>  <i>On the right is a label that should have the following properties:</i> <i><br><br></i> <ol><li>  content reduction - i.e.  the label occupies only the minimum space sufficient to display the text it contains, </li><li>  squeezing resistance - i.e.  the label resists reducing its size to a size less than the minimum required to display the text it contains. </li></ol><br>  To implement the described markup using Auto Layout, we will set the required properties for the right label: compression of the content and resistance to compression.  It worked fine on iOS 8, and worked fine on all test data during development.  But with the release of iOS 9, this implementation has caused huge performance problems with some of our users.  And we did not know about these issues until users complained. <br><img src="https://habrastorage.org/web/04b/f8e/f7b/04bf8ef7befc4777a73f4ce2b398e2ee.PNG" alt="image"><br>  <i>Note.</i>  <i>The execution time of Auto Layout on iPhone 6. The horizontal axis is the number of view.</i>  <i>The vertical axis is the Auto Layout runtime.</i>  <i>Blue graph - UIScrollView with Auto Layout for two lines.</i>  <i>The red graph is a single-row UIScrollView with Auto Layout.</i> <br><br>  Obviously, it‚Äôs not at all cool to receive notifications from your users about performance issues.  You might think, "How bad can it be?"  For this situation, when the label on the left contains several lines, the blue line shows how much time it takes to perform the markup for a certain number of view.  As you can see, the blue line quickly goes up with the number of view.  This was the source of the problem. <br><br>  There is no such problem if the label on the left contains only one line or some other data type.  So, the problem was caused by a specific data type. <br><br><h3>  News Feed LinkedIn. </h3><br><ol><li>  For some time, due to performance issues, Auto Layout has not been used. </li><li>  Each view implements the markup code manually: <br><ol><li>  Hard to maintain </li><li>  I would like to have a reusable solution to apply on the Profile screen. </li></ol></li></ol><br>  In the case of the LinkedIn news feed, we actually knew that the performance of Auto Layout was not at all excellent.  For this reason, LinkedIn news feed has not used Auto Layout for a long time.  In the ribbon, each view or cell implements its own markup code using layoutSubviews.  This manual layout is much faster.  However, the problem is that the support of such a code is exhausting.  We have two functions.  The first one calculates the height, so we can tell the table or the UICollectionView how high the cell is.  And then the second performs the actual markup.  The reason why we divided this logic is that this way we can perform height calculations quickly - without completely performing the markup. <br><br>  We wanted something similar for the rest of the application.  But we wanted it to be suitable for solving various problems, and so that many could use it. <br><br><h2>  Markup Solutions </h2><br><h3>  Marking Solution Requirements </h3><br><ol><li>  Quick  We wanted the solution to be fast, along with hand-written code, because this is what we already had in the tape. </li><li>  An API that is natural in the Swift application.  Most of our applications on LinkedIn - including the main one - are written in Swift. </li><li>  Supported and used in serious projects.  We would not want to use beta-level software in our products. </li><li>  With open source (debugging if something goes wrong).  One of the sources of pain when working with Auto Layout is that Auto Layout is a black box.  And when something goes wrong, we have no way to dig out the cause. </li><li>  Acceptable license (from the point of view of company lawyers). </li></ol><br><h3>  Existing solutions </h3><br><ol><li>  React Native, AsyncDisplayKit, ComponentKit - Facebook has a lot of good open source libraries.  Unfortunately, because of the license, we cannot use them. </li><li>  Few is a library, but it looks like it was abandoned - the last commit more than a year ago. </li><li>  Render - creation May 2016. Now we have found another library: Render.  But she did not exist at the time of the decision. </li></ol><br>  Not one of these projects has satisfied all our requests. <br><br><h3>  Time to build something new ... </h3><br>  So, not one of the projects found in the network did not satisfy all our requirements.  And we created what we called LayoutKit. <br><br>  LayoutKit is a library for fast positioning of view on iOS, macOS, tvOS.  Next, I will explain how to apply it, and how it works. <br><br><h3>  LayoutKit "hello world" </h3><br>  At the top level, the markup is carried out in three stages: <br><br><ol><li>  The developer defines markup using immutable data structures. </li><li>  LayoutKit calculates frames for each view, and, if you wish, in the background thread. </li><li>  LayoutKit in the main thread creates the entire view and assigns them frames. </li></ol><br>  For a better understanding, consider an example, with simple, but fully implemented markup.  In this markup will be the world, and the image, and the text label. <br><br><img src="https://habrastorage.org/web/37b/24d/2a7/37b24d2a7f2044d0be4b151caa1f47c3.PNG" alt="Future markup"><br>  The first part is creating the markup for the UIImageView.  So, we need a fixed-size markup, which we call SizeLayout containing a UIImageView, and with a width and height of 50 pixels (here and later in the original pixels).  In the configuration block, we set the image for the UIImageView: <br><br><pre><code class="hljs lisp">let image = SizeLayout&lt;UIImageView&gt;( <span class="hljs-name"><span class="hljs-name">width</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, height: <span class="hljs-number"><span class="hljs-number">50</span></span>, config: { imageView in imageView.image = UIImage(<span class="hljs-name"><span class="hljs-name">named</span></span>: ‚Äúearth.jpg‚Äù) } )</code> </pre> <br>  Next we need markup for the label.  We set the text and center alignment of the available space. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">LabelLayout</span></span>( text: ‚Äú<span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-type"><span class="hljs-type">World!</span></span>‚Äù, alignment: .center )</code> </pre><br>  We want to place these views next to each other, so we will create a horizontal stack with an interval of 4 pixels. <br><br><pre> <code class="hljs lisp">StackLayout( <span class="hljs-name"><span class="hljs-name">axis</span></span>: .horizontal, spacing: <span class="hljs-number"><span class="hljs-number">4</span></span>, sublayouts: [image, label] )</code> </pre><br>  Finally, we need padding around the edges.  We create an InsetLayout that wraps the newly created StackLayout. <br><br><pre> <code class="hljs lisp">helloWorld = InsetLayout( <span class="hljs-name"><span class="hljs-name">insets</span></span>: UIEdgeInsets(<span class="hljs-name"><span class="hljs-name">top</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, left: <span class="hljs-number"><span class="hljs-number">4</span></span>, bottom: <span class="hljs-number"><span class="hljs-number">4</span></span>, right: <span class="hljs-number"><span class="hljs-number">8</span></span>), sublayout: stack )</code> </pre><br>  Our "Hello World" markup is ready, and we call the placement method.  The method recursively calculates all frames for all views and layouts.  This can be performed in a background thread. <br><br>  Since its inception, arrangement is an immutable data structure, so we can pass it back to the main thread and make makeViews. <br><br><pre> <code class="hljs bash">//     . <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> arrangement = helloWorld.arrangement() //     . arrangement.makeViews(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rootView)</code> </pre><br>  We pass the rootView parameter to the makeViews method so that the necessary views are created right in it.  If the parameter is not passed, makeViews returns a view, with which we can do whatever we want. <br><br><img src="https://habrastorage.org/web/196/4f2/2b8/1964f22b845741db8e3cc6da911ca56c.PNG" alt="First example"><br>  So we finished the markup. <br><br><h4>  One more example </h4><br>  In the example above, we called arrangement without parameters: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//   . //   . helloWorld.arrangement()</span></span></code> </pre><br>  Let's do it differently: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    . helloWorld.arrangement(width: 200)</span></span></code> </pre><br>  You can specify an explicit width, and the method will mark it on it: <br><br><img src="https://habrastorage.org/web/77a/e84/85a/77ae8485acd94fbfab5ce4ef478c3c95.PNG" alt="Second example"><br>  You can see that the indents have increased, now all the space available in width is occupied.  This width may be, for example, the width of the screen. <br><br><h4>  Another example is animation. </h4><br>  The markup can be animated.  We will do this using a simple SizeLayout.  Let's call it ‚Äúbox‚Äù.  Using the viewReuseId parameter, you can set a unique identifier for the view or markup.  Due to this, LayoutKit knows which view in the ‚Äúbefore‚Äù state corresponds to which view in the ‚Äúafter‚Äù state. <br><br>  In this example, in the ‚Äúbefore‚Äù state, our ‚Äúbox‚Äù is simply a square of 50x50 pixels, and in the state after - a square of 25x25 pixels. <br><br><pre> <code class="hljs pgsql">//     viewReuseId //  "" let <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> = SizeLayout( width: <span class="hljs-number"><span class="hljs-number">50</span></span>, height: <span class="hljs-number"><span class="hljs-number">50</span></span>, viewReuseId: ‚Äú<span class="hljs-type"><span class="hljs-type">box</span></span>‚Äù) //  "" let <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> = SizeLayout( width: <span class="hljs-number"><span class="hljs-number">25</span></span>, height: <span class="hljs-number"><span class="hljs-number">25</span></span>, viewReuseId: ‚Äú<span class="hljs-type"><span class="hljs-type">box</span></span>‚Äù)</code> </pre><br>  These are two different markup.  Create a view layout using the ‚Äúbefore‚Äù markup.  The views created from this location will be placed in some root view - the rootView.  Then, using the ‚Äúafter‚Äù markup, prepare for the animation - create a special object for the animation, which has an animate method. <br><br><pre> <code class="hljs pgsql">//   ""   <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>      rootView. <span class="hljs-keyword"><span class="hljs-keyword">before</span></span>.arrangement().makeViews(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rootView) //   . let animation = <span class="hljs-keyword"><span class="hljs-keyword">after</span></span>.arrangement() .prepareAnimation(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: rootView)</code> </pre><br>  After receiving the animation object, you can use the usual call UIView.animate, withDuration, passing it the animation.apply method, which performs the animation of changing one markup to another. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  . UIView.animate(withDuration: 5.0, animations: animation.apply)</span></span></code> </pre><br><h4>  An example of a slightly more complex animation. </h4><br><img src="https://habrastorage.org/web/b89/3ad/5ef/b893ad5efcee4e31883d50cbe03b3b87.PNG" alt="An example of more complex animation."><br>  (unfortunately, the animation is not visible even on the video in the source - approx. transl.) <br><br>  There are red and two gray squares.  The only note is that the red square at the beginning is the child view of the upper square, and then becomes the child view of the lower one.  Both squares move from left to right.  The bottom square shrinks in size, and the red one grows. <br><br>  The stage of ‚Äúpreparation for animation‚Äù is what allows you to make such complex animations with a change in the parent view.  If you skip the "preparation for animation" - then the expected result can not be obtained. <br><br><h2>  How LayoutKit Works </h2><br>  I would like to say about the benefits of Swift.  LayoutKit is written in Swift, thanks to which it was possible to provide a clean API.  We use generics, protocol extensions, and default parameters in the initializer.  In the examples above, you could already see the benefits obtained. <br><br>  How does LayoutKit work?  The Layout Protocol is located in the center of the entire LayoutKit, and it determines that there is a markup.  Anyone can implement this protocol, and LayoutKit provides a small set of pre-installed (basic) markups that implement it. <br><br><img src="https://habrastorage.org/web/d01/7d8/787/d017d8787364448a8e51d0b017b37b76.PNG" alt="LayoutKit Scheme"><br>  <i>Note.</i>  <i>On the left in the diagram is a set of markup, in the center is the Markup Protocol, on the right is the markup engine.</i> <br><br>  There is also a markup engine, which is a collection of classes.  These classes work based only on the Layout Protocol: calculating frame sizes, creating their instances (apparently talking about creating <a href="https://github.com/linkedin/LayoutKit/blob/master/Sources/LayoutArrangement.swift">allocations</a> - approx. Transl.), Executing the logic of animation. <br><br><h3>  Basic markup </h3><br>  Basic markup is just a calculation packed into the Markup Protocol: <br><br><ol><li>  LabelLayout - 124 lines of code, </li><li>  SizeLayout - 164 lines of code </li><li>  InsetLayout - 39 lines of code, </li><li>  StackLayout - 175 lines of code. </li></ol><br>  All these markup we have already seen in the examples.  They are the main blocks, and they enable the construction of a decent number of different user interfaces. <br><br><h3>  Create your own markup </h3><br>  If 4 basic layouts are not enough to describe your user interface, you can do the following: <br><br><ol><li>  Create the desired markup using the composition and the four base attachments. </li><li>  Create your own markup by implementing the Layout Protocol, which is called ‚ÄúLayout‚Äù. </li></ol><br><h3>  What makes LayoutKit fast? </h3><br>  Two main reasons: <br><br><ol><li>  LayoutKit does not use a generic solution search algorithm for system constraints like Auto Layout.  In contrast, each markup uses a specialized algorithm.  Thanks to this, you get an efficient implementation for each markup. </li><li>  The slowest thing we do around LayoutKit is sorting the child layouts by flexibility inside StackLayout.  For everything else, the algorithmic complexity is O (n). </li></ol><br>  Let's look at the actually achieved level of performance in numbers.  This is an example of execution on iPhone 6 with iOS 9. UICollectionView with UICollectionViewFlowLayout containing 20 cells was used.  Each cell as a whole resembles its counterpart from the LinkedIn news feed.  It takes up quite a lot of screen space. <br><br>  On this chart, "more" - "better."  We have designated Auto Layout as a reference point 1x.  You can see that if you apply UIStackView, then it will work slower than Auto Layout.  This is because the UIStackView is based on Auto Layout.  The extreme right shows the result of applying the markup manually.  Manual layout is 9.4 times faster than Auto Layout.  The green bar is LayoutKit, and it is 7.7 times faster than Auto Layout.  Not as fast as manual markup, but for this you get a lot of good pieces without having to write a lot of code. <br><br><img src="https://habrastorage.org/web/1ff/bbf/a46/1ffbbfa46b1c4dfaa11c4a134c9ba5a8.PNG" alt="Performance schedule 1"><br>  <i>Note.</i>  <i>Performance implementations markup.</i>  <i>More is better.</i> <br><br>  You can look at it on the other hand: how much time do you have to execute your own code in the interval between the sequential display of two frames?  The black horizontal line is 16 milliseconds.  You can see that when using UIStackView, the markup for the news item will take 46 milliseconds.  When using Auto Layout - 28 milliseconds.  What this graph tells us is that when using Auto Layout or UIStackView, one or two frames will be skipped during each layout run on the main stream. <br><br>  LayoutKit and manual layout are roughly equal.  When using LayoutKit or manual layout it only takes 6 milliseconds.  Additionally, with LayoutKit, markup can be performed in a background thread. <br><br><img src="https://habrastorage.org/web/8af/b60/00c/8afb6000cdea4c358a1c108f3a537353.PNG" alt="Performance schedule 2"><br>  <i>Note.</i>  <i>The single-cell UICollectionView markup time.</i>  <i>Less is better.</i> <br><br>  The next thing I want to say is that immutable data structures. <br><br><h3>  Unchangeable data structures </h3><br>  The markup objects and all intermediate data structures are immutable.  What gives the following results: <br><br><ol><li>  Thread safety.  The ability to transfer data back and forth between the main and background threads. </li><li>  You can easily calculate and cache markup in advance.  For example, it is possible to calculate the markup for rotating the screen in the background stream before the user actually turns the screen. </li><li>  Simple debugging.  If it is known in advance that a variable cannot change, then there is no need to worry about checking this. </li></ol><br><h3>  Other advantages of LayoutKit </h3><br><ol><li>  Automatic language support with right-to-left writing. </li><li>  Easy to read, write, build, and test declarative markup. </li><li>  Rapid sandbox prototyping. </li><li>  Support iOS, macOS, tvOS. </li></ol><br><h3>  Application </h3><br>  Is LayoutKit ready for use in the industry?  Yes, we use it in the main LinkedIn application, as well as in the application for job search. <br><br>  In our experience, it was very easy to train LayoutKit engineers.  Auto Layout training, on the other hand, was not so easy. <br><br><h2>  Conclusion </h2><br><h3>  Open source code </h3><br>  1) LayoutKit is open source.  Code can be obtained at layoutkit.org <br>  2) Apache 2.0 license, so no patent fraud. <br>  3) Release Date June 22, 2016. <br>  4) Today (I took up-to-date data for the beginning of May 2017 - approx. Transl.) On a githaba: 59 observers, 1996 stars, 136 forks. <br><br><h3>  Thanks </h3><br>  Thanks to everyone who helped with the work on LayoutKit.  Thank you, Sergei Taguer (Sergey Tager), Andy Clark (Andy Clark), Peter Livesey (Peter Livesey). <br><br><h3>  about the author </h3><br>  Nick Snyder is a software engineer on LinkedIn.  Currently, he is working on building an infrastructure for mobile applications that is scalable for all company applications.  He participated in the preparation of three company applications, including the latest version of the main application.  Favorite thing - the creation of reusable components with a clean API, which is a pleasure to work with. </div><p>Source: <a href="https://habr.com/ru/post/328242/">https://habr.com/ru/post/328242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328232/index.html">CVE-2017-5689 - Intel AMT Vulnerability in Detail</a></li>
<li><a href="../328234/index.html">Variable properties of classes in python: benefits for business and disorderly conduct</a></li>
<li><a href="../328236/index.html">No anything</a></li>
<li><a href="../328238/index.html">Multi-agent smart home</a></li>
<li><a href="../328240/index.html">What is there with JEP-303 or invent invokedynamic</a></li>
<li><a href="../328244/index.html">Magic constants in algorithms</a></li>
<li><a href="../328246/index.html">Ethereum smart contracts: we structure tokens as stocks</a></li>
<li><a href="../328248/index.html">We write a script to synchronize folders with Google Drive, plus learn to use the Google Drive API</a></li>
<li><a href="../328250/index.html">5 of the "hottest" non-fiction novelties for March-April 2017</a></li>
<li><a href="../328252/index.html">How do we save half a million rubles a month with Slack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>