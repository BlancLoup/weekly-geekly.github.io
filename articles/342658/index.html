<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What happens in Kubernetes when starting the kubectl run? Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note trans. : This material, entitled the original as ‚ÄúWhat happens when ... Kubernetes edition!‚Äù And written by Jamie Hannaford of Rackspace, is an e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What happens in Kubernetes when starting the kubectl run? Part 1</h1><div class="post__text post__text-html js-mediator-article">  <i><b>Note</b></i>  <i><b>trans.</b></i>  <i>: This material, entitled the original as ‚ÄúWhat happens when ... Kubernetes edition!‚Äù And written by Jamie Hannaford of Rackspace, is an excellent illustration of the many Kubernetes mechanisms that are often hidden from our eyes, but very useful for better understanding the device of this Open Source -systems, operation algorithm and interrelations of its components.</i>  <i>Since the whole article is quite voluminous, its translation is divided into two parts.</i>  <i>The first is about the work of kubectl, kube-apiserver, etcd and initializers.</i> <i><br><br></i>  <i>PS Some original references to the code in the master branches were replaced by commits that were last by the time they were translated, so that the line numbers to which the author refers were kept up for a long time.</i> <br><br><img src="https://habrastorage.org/web/38e/151/72f/38e15172f88348718c88b4fcc87585b6.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Imagine that I want to enclose nginx in a Kubernetes cluster.  I'll enter something like this in the terminal: <br><br><pre><code class="bash hljs">kubectl run --image=nginx --replicas=3</code> </pre> <br>  ... and press Enter.  After a few seconds, I will see 3 hearths with nginx distributed across all work nodes.  It works - as if by magic, and it's great!  But what really happens under the hood? <br><a name="habracut"></a><br>  One of the great features of Kubernetes is how this system serves the deployment of workloads to the infrastructure through user-friendly APIs.  All complexity is hidden by simple abstraction.  However, in order to fully understand the value that K8s brings, it is helpful to understand the inner kitchen.  This article will guide you through the entire life cycle of a request from the client to the kubelet, if necessary referring to the source code to illustrate what is happening. <br><br>  This is a living document.  If you find something to improve or rewrite, changes are welcome!  <i>(This, of course, about the original English-language article in <a href="https://github.com/jamiehannaford/what-happens-when-k8s">GitHub</a> - approx. Transl.)</i> <br><br><h2>  kubectl </h2><br><h3>  Validation and Generators </h3><br>  So, let's begin.  We just clicked on Enter in the terminal.  And now what? <br><br>  First, kubectl will perform validation on the client side.  He will make sure that non-working requests (for example, creating a resource that is not supported, or using an image with the <a href="">wrong name</a> ) will be quickly interrupted and not sent to kube-apiserver.  This improves system performance by reducing unnecessary load. <br><br>  After validation, kubectl starts building an HTTP request that will be sent to kube-apiserver.  All attempts to access or change the status in the Kubernetes system pass through the API server, which in turn communicates with etcd.  And kubectl is no exception.  To compose an HTTP request, kubectl uses so-called generators ( <a href="https://kubernetes.io/docs/user-guide/kubectl-conventions/">generators</a> ), an abstraction that implements serialization. <br><br>  Not entirely obvious here may seem that in the <code>kubectl run</code> specifying a set of resource types is allowed, not only Deployments.  For this to work, kubectl <a href="">calculates the</a> type of resource, unless the name of the generator has been specifically indicated through the <code>--generator</code> flag. <br><br>  For example, resources that have <code>--restart-policy=Always</code> are treated as Deployments, and resources with <code>--restart-policy=Never</code> are treated as resources.  Also, kubectl will find out what other actions need to be taken - for example, recording a command (for withdrawals or auditing) - and whether this command is a test run (by the presence of the <code>--dry-run</code> flag). <br><br>  Having understood that we want to create Deployment, kubectl will use the <code>DeploymentV1Beta1</code> generator to create a <a href="">runtime object</a> from the provided parameters.  Runtime object is a generic term for a resource. <br><br><h3>  API and version negotiation groups </h3><br>  Before we continue, it is important to note that Kubernetes uses a versioned API that is classified into API groups <i>(API groups)</i> .  The API group is designed to assign similar resources to one category in order to make it easier to interact with them.  In addition, it is a good alternative to a single monolithic API.  The Deployment API group is called <code>apps</code> and its latest version is <code>v1beta2</code> .  This is what you specify at the top of the Deployment definitions: <code>apiVersion: apps/v1beta2</code> . <br><br>  <i>( <b>Note</b> : As we told in the <a href="https://habrahabr.ru/company/flant/blog/338230/">announcement of Kubernetes 1.8</a> , the project is now working on creating a new Workload API group that will include Deployments and other APIs related to "workloads.")</i> <br><br>  In general, after kubectl has generated a runtime object, it <a href="">begins to search for the</a> corresponding API group and version, and then builds the client of the required version ‚Äî it takes into account various REST semantics for the resource.  This stage of detection is called ‚Äú <i>version negotiation</i> ‚Äù <i>(version negotiation)</i> , which includes scanning the contents <code>/apis</code> on a remote API to retrieve all possible API groups.  Since kube-apiserver produces a structured document (in OpenAPI format) along this path ( <code>/apis</code> ), it is easy for clients to perform detection. <br><br>  To improve performance, kubectl also <a href="">caches the</a> OpenAPI schema in the <code>~/.kube/schema</code> directory.  If you want to see API detection in action, try deleting this directory and running the command with the maximum value for the <code>-v</code> flag.  You will see all HTTP requests trying to find API versions.  And a lot of them! <br><br>  The final step is to <a href="">send an</a> HTTP request.  When it is made and a successful response is received, kubectl will display a successful message <a href="">considering the</a> preferred output format. <br><br><h3>  Client authentication </h3><br>  At the last step, we did not mention client authentication (it happens before sending an HTTP request) - we will consider it as well. <br><br>  To successfully send a request, kubectl must be authenticated.  User credentials are almost always stored in a <code>kubeconfig</code> file stored on disk, but it can be in different places.  To find it, kubectl does the following: <br><br><ul><li>  if the flag is <code>--kubeconfig</code> - <code>--kubeconfig</code> - uses it; </li><li>  if the <code>$KUBECONFIG</code> environment variable is <code>$KUBECONFIG</code> - uses it; </li><li>  otherwise, it checks the <a href="">expected</a> home directory like <code>~/.kube</code> and uses the first found file. </li></ul><br>  After parsing the file, the current context, the current cluster and the authentication information for the current user are determined.  If the user specified special values ‚Äã‚Äãvia flags (such as <code>--username</code> ), priority is given to them and they overwrite the values ‚Äã‚Äãspecified in <code>kubeconfig</code> .  When the information is received, kubectl sets the client configuration, making it relevant to the needs of the HTTP request: <br><br><ul><li>  x509 certificates are sent via <a href=""><code>tls.TLSConfig</code></a> (root CA is also included here); </li><li>  client tokens are <a href="">sent</a> in the HTTP <code>Authorization</code> header; </li><li>  user and password are <a href="">sent</a> via basic HTTP authentication; </li><li>  The authentication process through OpenID is pre-performed by the user manually, as a result of which a token appears, which is sent similarly to the corresponding item above. </li></ul><br><h2>  kube-apiserver </h2><br><h3>  Authentication </h3><br>  So, the request was sent, hooray!  What's next?  Kube-apiserver comes into play.  As mentioned above, kube-apiserver is the main interface used by clients and system components to save and retrieve the status of a cluster.  To perform this function, it is necessary to verify the requesting party, making sure that it corresponds to the one it claims to be.  This process is called authentication. <br><br>  How does apiserver authenticate requests?  When the server is first started, it checks all user <a href="https://kubernetes.io/docs/admin/kube-apiserver/">-</a> supplied <a href="https://kubernetes.io/docs/admin/kube-apiserver/">console flags</a> and compiles a list of suitable authenticators.  Consider an example: if passed to <code>--client-ca-file</code> , the authenticator x509 will be added;  if <code>--token-auth-file</code> is specified - tokens authenticator will be added to the list.  Each time a request is received, it is run through a chain of authenticators until one of them succeeds: <br><br><ol><li>  <a href="">x509 handler</a> verifies that the HTTP request is encrypted with the TLS key signed by the root certificate of the certification authority; </li><li>  <a href="">the token handler</a> verifies that the provided token (defined in the HTTP <code>Authorization</code> header) exists in the file on the disk indicated by the <code>--token-auth-file</code> directive; </li><li>  <a href="">The basicauth handler will</a> similarly make sure that the credentials for basic authentication in an HTTP request match the local data. </li></ol><br>  If none of the authenticators succeeds, the request <a href="">will fail</a> and return an aggregated error.  If the authentication is successful, the <code>Authorization</code> header is removed from the request and the user information is <a href="">added</a> to its context.  This gives access to the previously established user identity at subsequent stages (such as authorization and admission controllers). <br><br><h3>  Authorization </h3><br>  Okay, the request has been sent, kube-apiserver successfully verified that we are who we are.  What a relief!  However, this is not all.  We can be those who we imagine, but do we have rights to perform this operation?  Identity and access rights are not the same thing.  To continue, kube-apiserver must authorize us. <br><br>  The way in which kube-apiserver performs authorization is very similar to authentication: from the flag values ‚Äã‚Äãit collects a chain of authorizers <i>(authorizers)</i> that will be used for each incoming request.  If <b>all</b> authorizers prohibit the request, it <a href="">will end</a> with the <code>Forbidden</code> response and stop there.  If at least one authorizer approves the request, it will go further. <br><br>  Examples of authorizers that are part of the release of Kubernetes v1.8: <br><br><ul><li>  <a href="">a webhook</a> interacting with an HTTP (S) service outside of the K8s cluster; </li><li>  <a href="">ABAC</a> , which implements policies from a static file; </li><li>  <a href="">RBAC</a> , which implements RBAC <i>(Role-based access control)</i> roles added by the administrator as Kubernetes resources; </li><li>  <a href="">Node</a> , checking that the clients of cluster nodes ‚Äî for example, kubelet ‚Äî can access only resources located on themselves. </li></ul><br>  Look at the <code>Authorize</code> method of each of them to see how they work. <br><br><h3>  Access control </h3><br>  Ok, we are authenticated and authorized by kube-apiserver.  What is left?  The kube-apiserver itself trusts us and allows us to continue, but other parts of the system in Kubernetes may have their own deeply held beliefs about what is allowed and what is not.  This is where <a href="https://kubernetes.io/docs/admin/admission-controllers/">admission controllers</a> get <a href="https://kubernetes.io/docs/admin/admission-controllers/">involved</a> . <br><br>  If the authorization answers the question of whether the user is eligible, the admission controllers check the request for compliance with a wider range of expectations and rules in the cluster.  They are the last bastion of control before the object is passed to etcd, and are responsible for the remaining checks in the system, which are aimed at making sure that the action does not lead to unexpected or negative consequences. <br><br>  The principle on which these controllers operate is similar to authenticators and authorizers, but has one difference: for admission controllers, a single failure in the chain of controllers is enough to interrupt this chain and recognize the request as unsuccessful. <br><br>  The architecture of admission controllers is beautifully oriented towards promoting extensibility.  Each controller is stored as a plugin in the <code>plugin/pkg/admission</code> directory and is created to meet the needs of a small interface.  Each of them is compiled into the main binary file Kubernetes. <br><br>  Typically, admission controllers are categorized by resource management, security, default settings, and reference consistency.  Here are some examples of resource management controllers: <br><br><ul><li>  <code>InitialResources</code> sets default limits for container resources based on previous usage; </li><li>  <code>LimitRanger</code> sets default values ‚Äã‚Äãfor requests and container limits, guarantees upper bounds for certain resources (512 MB of default memory, but no more than 2 GB); </li><li>  <code>ResourceQuota</code> counts the number of objects (hearths, rc, load balancers of services) and total consumed resources (processor, memory, disk) in the namespace and prevents them from being exceeded. </li></ul><br><h2>  etcd </h2><br>  At this point, Kubernetes fully approved the incoming request and allowed to move on.  The next step kube-apiserver deserializes the HTTP request, creates runtime objects from it (something like the reverse process of what the kubectl generators do) and saves them to the data store.  Let's look at it in detail. <br><br>  How does kube-apiserver know what to do when accepting our request?  This is followed by a rather complicated sequence of steps that precede the processing of any requests.  Let's see from the very beginning - when the binary file is first run: <br><br><ol><li>  When the kube-apiserver binary is launched, it <a href="">creates</a> a server chain that makes the Kubernetes apiserver aggregation possible.  This is the basis for supporting many apiservers (which we should not worry about). </li><li>  When this happens, <a href="">a</a> generic apiserver is created, acting as the default implementation. </li><li>  The generated OpenAPI schema <a href="">fills</a> the apiserver configuration. </li><li>  Then, kube-apiserver passes sequentially through all the API groups defined in the schema, and <a href="">sets up a</a> <i>storage provider</i> for each of them, acting as a general <i>(generic)</i> abstraction of the storage.  With it, kube-apiserver interacts when it accesses the state of a resource or changes it. </li><li>  For each API group, all versions of the group are sequentially searched and REST correspondences are established for each HTTP route.  This allows kube-apiserver to match queries and delegate logic to the result found. </li><li>  In our particular case <a href="">, a</a> POST handler is <a href="">registered</a> , which is then delegated to <a href="">the resource creation handler</a> . </li></ol><br>  At this point, the kube-apiserver knows which routes exist and has an internal mapping indicating which handlers and storage providers should be called when the request matches.  Suppose we got our HTTP request: <br><br><ol><li>  If the chain of handlers can find a match between the request and the pattern (i.e., registered routes), then the required handler registered for this route <a href="">will be called</a> .  Otherwise, a <a href="">handler</a> based on paths is called (the same happens when accessing <code>/apis</code> ).  If there are no registered handlers for this path, <a href="">the not found handler</a> is called, which returns 404. </li><li>  Luckily for us, there is a registered route called <a href=""><code>createHandler</code></a> .  What is he doing?  First of all, it decodes the HTTP request and performs basic validation, such as checking the provided JSON data with the expectations for the resource from the API of the required version. </li><li>  <a href="">There is an</a> audit and final admission. </li><li>  The resource is <a href="">stored</a> in etcd by <a href="">delegating</a> to the storage provider.  Usually, the key for etcd is represented as <code>&lt;namespace&gt;/&lt;name&gt;</code> , but this is configurable. </li><li>  Any errors on creation are intercepted and, finally, the storage provider makes a <code>get</code> call, checking that the object was actually created.  Then it calls all the handlers assigned at the time after creation (post-create), and the decorators if additional finalization is required. </li><li>  <a href="">An</a> HTTP request is created and sent back. </li></ol><br>  Many steps!  It's amazing to follow apiserver like that, because you understand how much work it actually does.  So, summarizing: the Deployment resource now exists in etcd.  But it‚Äôs not enough to just put it there - you still will not see it at this stage ... <br><br><h2>  Initializers </h2><br>  When an object is stored in the data store, it is not fully visible to the apiserver and does not get into the scheduler until it has completed a set of <a href="https://kubernetes.io/docs/admin/extensible-admission-controllers/">initializers</a> <i>(intializers)</i> .  An initializer is a controller associated with a resource type and executing logic on a resource before it becomes available to the outside world.  If the resource type does not have registered initializers, this step is skipped and resources are visible instantly. <br><br>  As <a href="https://ahmet.im/blog/initializers/">written</a> in many blogs, this is a powerful feature that allows you to perform common <i>bootstrap</i> operations.  Examples might be: <br><br><ul><li>  Insert the proxy sidecar-container in the open port 80 or with a specific annotation <i>(annotation)</i> . </li><li>  Inserting a volume with test certificates in all the subs of a specific namespace. </li><li>  Prevent creation of a secret with a length of less than 20 characters (for example, for a password). </li></ul><br>  InitializerConfiguration objects allow you to determine which initializers should be run for certain types of resources.  Imagine that we want to run our initializer every time a fire is created.  Then we will do something like this: <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1alpha1 kind: InitializerConfiguration metadata: name: custom-pod-initializer initializers: - name: podimage.example.com rules: - apiGroups: - "" apiVersions: - v1 resources: - pods</code> </pre> <br>  After this config is created, a <code>custom-pod-initializer</code> will be added to each waiting field ( <code>metadata.initializers.pending</code> ).  The initializer controller will already be deployed and will begin to regularly scan the cluster for new scams.  When the initializer detects the under with its <i>(i.e. initializer)</i> name in the waiting field, it will perform its actions.  After completing the work, he will remove his name from the waiting list.  Only initializers whose names are first on the list can manage resources.  When all initializers have completed and the wait list is empty, the object will be considered initialized. <br><br>  Most observant readers may have noticed a potential problem.  How can a controller from user space handle resources if kube-apiserver has not yet made them visible?  For this, kube-apiserver has a special query parameter <code>?includeUninitialized</code> , which allows to return all objects, including those that are not initialized. <br><br><h2>  PS from translator </h2><br>  The second part of the article <s>will be published in the near future</s> <b>UPDATED: ... published on <a href="https://habrahabr.ru/company/flant/blog/342822/">this link</a></b> .  It discusses the work of the Deployments and ReplicaSets controllers, informers, scheduler, kubelet. <br><br>  Read also in our blog: <br><br><ul><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/342822/"><b>What happens in Kubernetes when starting the kubectl run?</b></a>  <a href="https://habrahabr.ru/company/flant/blog/342822/"><b>Part 2</b></a> "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> " <i>(video of the report, which includes an introduction to the technical device Kubernetes);</i> </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/335552/">How does the Kubernetes scheduler actually work?</a>  "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/341760/">Infrastructure with Kubernetes as an affordable service</a> "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/338230/">Kubernetes 1.8: a review of major innovations</a> ." </li></ul></div><p>Source: <a href="https://habr.com/ru/post/342658/">https://habr.com/ru/post/342658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342636/index.html">From Kotlin to whip: how did Mobius 2017 Moscow go</a></li>
<li><a href="../342638/index.html">How we created a new type of tariff "Turn on"</a></li>
<li><a href="../342640/index.html">Configuring Minio and Nginx for the RoR application</a></li>
<li><a href="../342644/index.html">Gorgeous assholes in the making</a></li>
<li><a href="../342654/index.html">Self-oscillations and resonance</a></li>
<li><a href="../342660/index.html">UniRx - Rx for Unity3d</a></li>
<li><a href="../342666/index.html">Facebook or Google? Where it is more profitable to advertise in 2017</a></li>
<li><a href="../342668/index.html">How to write your first Linux device driver. Part 3</a></li>
<li><a href="../342670/index.html">The experience of identifying one bug or how not to make out your code</a></li>
<li><a href="../342674/index.html">About the rotation matrix in simple words</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>