<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React 16 server rendering innovations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="React 16 released! Talking about this event, we can mention a lot of great news (like the Fibers core architecture), but personally I am most impresse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React 16 server rendering innovations</h1><div class="post__text post__text-html js-mediator-article">  React 16 released!  Talking about this event, we can mention a lot of great news (like the Fibers core architecture), but personally I am most impressed by the improvements in server rendering.  I propose to analyze all this in detail and compare it with what it was before.  I hope you will like the server rendering in React 16 as much as I liked it. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/339148/"><img src="https://habrastorage.org/webt/59/d2/2f/59d22f0309f6e578842023.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">How SSR works in React 15</font> </h2><br>  To begin, recall how server-side rendering (Server-Side Rendering, SSR) looks like in React 15. To perform SSR, a server based on a Node using Express, Hapi or Koa is usually supported and called <code>renderToString</code> to convert the root component to a string that write to the server response: <br><br><pre> <code class="hljs xml">//  Express import { renderToString } from "react-dom/server" import MyPage from "./MyPage" app.get("/", (req, res) =&gt; { res.write("<span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My Page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span>"); res.write("<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'content'</span></span></span><span class="hljs-tag">&gt;</span></span>");  res.write(renderToString(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MyPage</span></span></span><span class="hljs-tag">/&gt;</span></span>)); res.write("<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span>"); res.end(); });</code> </pre> <br>  When the client receives the answer, the client rendering subsystem, in the template code, is given the command to restore the HTML generated on the server using the <code>render()</code> method.  The same method is used in applications rendering on the client without server participation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { render } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MyPage <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./MyPage"</span></span> render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyPage</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"content"</span></span>));</code> </pre> <br>  If done correctly, the client rendering system can simply use the HTML generated on the server without updating the DOM. <br><br>  What does SSR look like in React 16? <br><br><h2>  <font color="#3AC1EF">React 16 Backward Compatibility</font> </h2><br>  The React development team showed a clear orientation towards backward compatibility.  Therefore, if your code is executed in React 15 without reports of obsolete constructs, it should simply work in React 16 without any additional effort on your part.  The code above, for example, works fine in both React 15 and React 16. <br><br>  If it happens that you run your application on React 16 and encounter errors, please <a href="https://github.com/facebook/react/issues">report</a> them!  This will help the development team. <br><br><h2>  <font color="#3AC1EF">The render () method becomes the hydrate () method.</font> </h2><br>  It should be noted that when switching from React 15 to React 16, you may encounter the following warning in the browser. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a93/1b2/955/a931b2955545f10973628dd86d2a2c0f.png"><br>  <i><font color="#999999">Another useful warning React.</font></i>  <i><font color="#999999">The render () method is now called hydrate ()</font></i> <br><br>  It turns out that in React 16 there are now two different methods for rendering on the client side.  The <code>render()</code> method for situations where rendering is performed entirely on the client, and the <code>hydrate()</code> method for cases where the rendering on the client is based on the server rendering results.  Thanks to the backward compatibility of the new version of React, <code>render()</code> will work even if you transfer to it what came from the server.  However, these calls should be replaced by calls to <code>hydrate()</code> in order for the system to stop issuing warnings, and to prepare the code for React 17. With this approach, the code shown above would change like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { hydrate } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MyPage <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./MyPage"</span></span> hydrate(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyPage</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span>, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"content"</span></span>))</code> </pre> <br><br><h2>  <font color="#3AC1EF">React 16 can work with arrays, strings and numbers</font> </h2><br>  In React 15, the component's <code>render()</code> method should always return a single React element.  However, in React 16, client-side rendering allows components to also return a string, number, or array of elements from the <code>render()</code> method.  Naturally, this also applies to SSR. <br><br>  So, now you can perform server-side rendering of components, which looks like this: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArrayComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [     &lt;div key=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;first element&lt;/div&gt;,     &lt;div key=<span class="hljs-string"><span class="hljs-string">"2"</span></span>&gt;second element&lt;/div&gt;   ]; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStringComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hey there"</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNumberComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br>  You can even pass a string, number, or array of components to the top-level API method <code>renderToString</code> : <br><br><pre> <code class="hljs axapta">res.write(renderToString([     &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> key=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;first element&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;,     &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> key=<span class="hljs-string"><span class="hljs-string">"2"</span></span>&gt;second element&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;   ])); <span class="hljs-comment"><span class="hljs-comment">//   ,   ,   ! res.write(renderToString("hey there")); res.write(renderToString(2));</span></span></code> </pre> <br>  This should allow you to get rid of any <code>div</code> and <code>span</code> that were simply added to your React component tree, which leads to a general reduction in the size of HTML documents. <br><br><h2>  <font color="#3AC1EF">React 16 generates more efficient HTML</font> </h2><br>  If we talk about reducing the size of HTML-documents, then React 16, in addition, radically reduces the excessive load created by SSR when generating HTML-code.  In React 15, each HTML element in an SSR document has a <code>data-reactid</code> , the value of which is a monotonically increasing ID, and the text nodes are sometimes surrounded by comments with <code>react-text</code> and ID.  To see this, consider the following code fragment: <br><br><pre> <code class="hljs xml">renderToString( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>   This is some <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>server-generated<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>HTML.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> );</code> </pre> <br>  In React 15, this snippet will generate HTML code that looks like the one shown below (line breaks have been added to improve the readability of the code): <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-reactroot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-reactid</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">   </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-react-checksum</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"122239856"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- react-text: 2 --&gt;</span></span>This is some <span class="hljs-comment"><span class="hljs-comment">&lt;!-- /react-text --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-reactid</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag">&gt;</span></span>server-generated<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- react-text: 4--&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- /react-text --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-reactid</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"5"</span></span></span><span class="hljs-tag">&gt;</span></span>HTML.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In React 16, however, all IDs are removed from the markup, as a result HTML, obtained from the same code fragment will be much simpler: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-reactroot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span> This is some <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>server-generated<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>HTML.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  This approach, in addition to improving the readability of the code, can significantly reduce the size of HTML documents.  This is just great! <br><br><h2>  <font color="#3AC1EF">React 16 supports arbitrary DOM attributes</font> </h2><br>  In React 15, the DOM rendering system was quite limited in terms of attributes of HTML elements.  She cleaned non-standard HTML attributes.  In React 16, however, both client and server rendering systems now omit arbitrary attributes added to HTML elements.  To learn more about this innovation, read the <a href="https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html">post of Dan Abramov</a> in the React blog. <br><br><h2>  <font color="#3AC1EF">SSR in React 16 does not support error handlers and portals</font> </h2><br>  There are two new features in the React client rendering system that, unfortunately, are not supported in SSR.  These are Error Boundaries and Portals.  Error handlers are dedicated to the <a href="https://facebook.github.io/react/blog/2017/07/26/error-handling-in-react-16.html">excellent post of Dan Abramov</a> in the React blog.  Note, however, that (at least for now) handlers do not respond to server errors.  For portals, as far as I know, there is not even an explanatory article yet, but the Portal API requires a DOM node, as a result, it cannot be used on the server. <br><br><h2>  <font color="#3AC1EF">React 16 performs less rigorous client side checking.</font> </h2><br>  When you restore the markup on the client side in React 15, the call to <code>ReactDom.render()</code> performs a character-by-character comparison with the server markup.  If for any reason a mismatch is detected, React issues a warning in design mode and replaces the entire markup tree generated on the server with HTML generated on the client. <br><br>  In React 16, however, the client rendering system uses a different algorithm to validate the markup that came from the server.  This system, in comparison with React 15, is more flexible.  For example, it does not require the markup created on the server to contain the attributes in the same order in which they would be located on the client side.  And when the client rendering system in React 16 detects discrepancies, it only tries to change a different HTML subtree instead of the entire HTML tree. <br><br>  In general, this change should not have a particularly strong effect on end users, except for one fact: React 16, when calling <code>ReactDom.render() / hydrate()</code> , does not fix the mismatched HTML attributes generated by SSR.  This performance optimization means that you will need to be more careful about fixing markup inconsistencies that lead to the warnings you see in <code>development</code> mode. <br><br><h2>  <font color="#3AC1EF">React 16 does not need to be compiled to improve performance.</font> </h2><br>  In React 15, if you use SSR in the form in which it appears immediately after installation, performance is far from optimal, even in <code>production</code> mode.  This is due to the fact that in React there are many great warnings and tips for the developer.  Each of these warnings looks like this: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">"production"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// -      //   . }</span></span></code> </pre> <br>  Unfortunately, <a href="https://github.com/facebook/react/issues/812">it turns out</a> that <code>process.env</code> is not an ordinary JavaScript object, and accessing it is a costly operation.  As a result, even if the value of <code>NODE_ENV</code> set in <code>production</code> , frequent checking of the environment variable significantly slows down server rendering. <br><br>  To solve this problem in React 15, you would need to compile the SSR code to remove references to <code>process.env</code> , using something like the <a href="https://webpack.js.org/plugins/environment-plugin/">Environment Plugin</a> in a Webpack, or the <a href="https://www.npmjs.com/package/babel-plugin-transform-inline-environment-variables">transform-inline-environment-variables</a> plugin for Babel.  I know from experience that many do not compile their server code, which, as a result, significantly degrades the performance of SSR. <br><br>  React 16 resolves this issue.  There is only one call to check the <code>process.env.NODE_ENV</code> at the very beginning of the React 16 code, as a result, it is no longer necessary to compile the SSR code to improve performance.  Immediately after installation, without additional manipulations, we get excellent performance. <br><br><h2>  <font color="#3AC1EF">React 16 features higher performance</font> </h2><br>  Continuing to talk about performance, we can say that those who used React server-side rendering in production often complained that large documents are processed slowly, even with all the recommendations for improving performance.  I would like to note here that it is recommended to always check that the <code>NODE_ENV</code> variable is set to <code>production</code> when you use SSR in production. <br><br>  I am pleased to announce that, having conducted some <a href="https://github.com/aickin/react-16-ssr-perf">preliminary tests</a> , I found a significant increase in the performance of server rendering React 16 on various versions of Node: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c94/497/11d/c9449711d4d879c571a55cc49e5e7375.png"><br>  <i><font color="#999999">Server rendering in React 16 is faster than in React 15. The lower the bar, the better the result.</font></i> <br><br>  When comparing with React 16, even taking into account the fact that in React 15, the calls to <code>process.env</code> were eliminated due to compilation, there is a performance increase of about 2.4 times in Node 4, 3 times in Node 6, and a remarkable increase of 3.8 times in Node 8.4.  If you compare React 16 and React 15 without compiling the latter, the results on the latest version of Node will be amazing. <br><br>  Why is React 16 so much faster than React 15?  So, in React 15, the server and client rendering subsystems were, in general terms, the same code.  This means the need for virtual DOM support during server rendering, even considering that this vDOM was dropped as soon as the <code>renderToString</code> call was <code>renderToString</code> .  As a result, a lot of unnecessary work was done on the server. <br><br>  In React 16, however, the development team rewrote server-side rendering from scratch, and now it is completely independent of vDOM.  This gives a significant increase in productivity. <br><br>  Here I would like to make one warning regarding the expected growth in the performance of real projects after switching to React 16. My tests were to create a huge <code>&lt;span&gt;</code> tree with one very simple recursive component React.  This means that my benchmark belongs to the category of synthetic and almost certainly does not reflect the actual use of React scenarios.  If your components have many complex <code>render</code> methods that take many CPU cycles to process, React 16 cannot do anything to speed them up.  Therefore, although I expect to see an acceleration of server rendering during the transition to React 16, I do not expect, say, a threefold increase in productivity in real applications.  According to untested data, when using React 16 in a real project, it was possible to achieve a <a href="https://github.com/facebook/react/issues/10294">productivity increase of about 1.3 times</a> .  The best way to understand how React 16 will affect the performance of your application is to try it yourself. <br><br><h2>  <font color="#3AC1EF">React 16 supports streaming</font> </h2><br>  The last of the new features of React, which I want to talk about, is no less interesting than the rest.  This is rendering directly to the Node streams. <br><br>  Stream rendering can reduce the time to receive the first byte (TTFB, Time To First Byte).  The beginning of the document enters the browser before creating a continuation of the document.  As a result, all leading browsers will quickly begin to parse and render the document. <br>  Another great thing that can get from rendering to a stream is the ability to respond to a situation where the server issues data faster than the network can receive it.  In practice, this means that if the network is overloaded and cannot receive data, the rendering system will receive the appropriate signal and suspend data processing until the load on the network drops.  The result will be that the server will use less memory and be able to respond faster to I / O events.  Both that and another is capable to help the server to work normally in difficult conditions. <br><br>  In order to organize streaming rendering, you need to call one of two new <code>react-dom/server</code> methods: <code>renderToNodeStream</code> or <code>renderToStaticNodeStream</code> , which correspond to the <code>renderToString</code> and <code>renderToStaticMarkup</code> .  Instead of returning a string, these methods return a <a href="https://nodejs.org/api/stream.html">Readable</a> object.  Such objects are used in the model for working with Node flows for entities generating data. <br><br>  When you get the <code>Readable</code> stream from the <code>renderToNodeStream</code> or <code>renderToStaticNodeStream</code> , it is in suspend mode, that is, the rendering has not yet started at this point.  Rendering will start only if <a href="https://nodejs.org/api/stream.html">read is</a> called, or, more likely, you connect the <code>Readable</code> stream using a <a href="https://nodejs.org/api/stream.html">pipe</a> to the <a href="https://nodejs.org/api/stream.html">Writable</a> stream.  Most Node web frameworks have a response object that inherits from <code>Writable</code> , so you can usually just redirect <code>Readable</code> to the response. <br><br>  Let's say the above Express example could be rewritten for streaming rendering as follows: <br><br><pre> <code class="hljs xml">//  Express import { renderToNodeStream } from "react-dom/server" import MyPage from "./MyPage" app.get("/", (req, res) =&gt; { res.write("<span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My Page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span>"); res.write("<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'content'</span></span></span><span class="hljs-tag">&gt;</span></span>"); const stream = renderToNodeStream(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MyPage</span></span></span><span class="hljs-tag">/&gt;</span></span>); stream.pipe(res, { end: false }); stream.on('end', () =&gt; {   res.write("<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span>");   res.end(); }); });</code> </pre> <br>  Note that when we redirect the stream to the response object, we need to use the optional argument <code>{ end: false }</code> to tell the stream that it should not automatically complete the response when rendering is complete.  This allows us to complete the layout of the body of the HTML document, and, as soon as the stream is fully recorded in the response, complete the answer yourself. <br><br><h2>  <font color="#3AC1EF">Pitfalls Streaming Rendering</font> </h2><br>  Stream rendering can improve many SSR scenarios, however, there are some patterns that will not benefit from streaming data. <br><br>  In general, any template in which, based on the markup created during server rendering, data is generated that needs to be added to the document prior to this markup, it will be fundamentally incompatible with streaming data.  Examples of this include frameworks that dynamically determine which CSS rules to add to the page in the previous generated markup <code>&lt;style&gt;</code> , or frameworks that add elements to the document‚Äôs <code>&lt;head&gt;</code> tag when rendering the document body.  If you are using these frameworks, you will probably have to use regular rendering. <br><br>  Another template that is not yet working in React 16 is the built-in <code>renderToNodeStream</code> calls in the component trees.  The usual thing in React 15 is to use <code>renderToStaticMarkup</code> to create a page template and embed <code>renderToString</code> calls to form dynamic content.  For example, it might look like this: <br><br><pre> <code class="hljs xml">res.write("<span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>"); res.write(renderToStaticMarkup( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>My Page<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span>       { renderToString(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MyPage</span></span></span><span class="hljs-tag">/&gt;</span></span>) }     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span>);</code> </pre> <br>  However, if you replace these calls of the rendering subsystem with their stream analogs, the code will stop working.  <code>Readable</code> streams (which are returned from <code>renderToNodeStream</code> ) are not yet possible to be embedded into components as elements.  I hope this feature will be added to React. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  So, above, we looked at the main innovations of server rendering in React 16. I hope you liked them just as much as I did.  In conclusion, I want to say a huge thank you to everyone who participated in the development of React 16. <br><br>  Continue to read?  In fact, it‚Äôs time to start tying and try to render something. <br><br>  Dear readers!  Are you here?  Looks like you already experienced server rendering in React 16.  If so, please share your impressions. </div><p>Source: <a href="https://habr.com/ru/post/339148/">https://habr.com/ru/post/339148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339138/index.html">Decompilation of RNC ProPack 5 years long</a></li>
<li><a href="../339140/index.html">ITMO University team reached the final of the World Robot Olympiad</a></li>
<li><a href="../339142/index.html">‚ÄúOne more step to blockchain‚Äù: Bitfury Group presented Exonum 0.2</a></li>
<li><a href="../339144/index.html">Donates to streamers and real money for unreal life: summed up the QIWI API Contest</a></li>
<li><a href="../339146/index.html">How to make a web application for your own Bluetooth Low Energy device?</a></li>
<li><a href="../339150/index.html">Submit the cool project: your API-client from one configuration file</a></li>
<li><a href="../339152/index.html">‚ÄúThe role of the analyst in making important product decisions‚Äù: video recordings of reports from the meeting</a></li>
<li><a href="../339154/index.html">Motivated installations from the USA (Android) - review of options, statistics, opinion</a></li>
<li><a href="../339156/index.html">Two facets of teleportation</a></li>
<li><a href="../339158/index.html">Sometimes they come back. Mobile Banker BankBot again in Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>