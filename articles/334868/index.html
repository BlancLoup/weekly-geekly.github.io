<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ubershadery in the emulator GameCube / Wii: a delightful solution to the unsolvable problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Favorite games through Dolphin on a powerful computer work quite well. The game is played at full speed, there are no graphic glitches and any control...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ubershadery in the emulator GameCube / Wii: a delightful solution to the unsolvable problem</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/46c/287/148/46c28714857371337308c90865921f3d.jpg"><br><br>  Favorite games through Dolphin on a powerful computer work quite well.  The game is played at full speed, there are no graphic glitches and any controller can be used.  However, when you hit a new area or load a new effect, there is a very small, but noticeable, ‚Äúhanging up‚Äù.  If you turn off the frame limiter for checking, you can see that the game can run much faster than at full speed.  What is going on? <br><br>  Slowing down when loading new areas, effects, models and the rest is usually called by users and developers ‚Äúhang when compiling shaders‚Äù.  This problem was present in Dolphin from the very beginning, but only recently attracted attention. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When the games barely worked, there were of course light hang-ups, but they didn‚Äôt cause big problems.  However, emulation in many games gradually improved to an almost perfect state, and the hangs remained unchanged for many years.  Since the release of Dolphin 4.0, users have started complaining even more about freezing when compiling shaders.  This was partly due to the increased requirements for the video processor due to integer mathematics, but mostly the hangup became noticeable because there were no other serious problems in the emulator. <br><a name="habracut"></a><br>  Developers were suspicious and even disliked to hang when compiling shaders.  The problem seemed intractable, in the community it caused pain and irritation.  It's ironic that we hated hanging up like no other, but the sheer complexity of the task was scared off by most developers.  Despite this, some of them continued to hold hope alone.  The solution was born as a theory that was <em>likely to</em> work.  A theory that would require hundreds, if not thousands of man-hours <i>only</i> to test the possibility of its realization. <br><br>  It was this hope that pushed us towards a difficult journey with almost no chance of success.  The journey, which took two years of work of several video processor specialists.  And all this in order to emulate the entire path of the GameCube / Wii primary programmable pipeline <strong>without</strong> this annoying hang. <br><br>  It was the dawn of the Uberschade era. <br><br><h2>  Problem </h2><br>  Modern video processors are incredibly versatile, but universality comes at a price ‚Äî they are <em>incredibly</em> complex.  To use all their power, developers use shaders ‚Äî programs that the video processor executes in the same way as the central processor executes applications.  They program the video processor to implement effects and complex rendering techniques.  The developers write the shader code in the API (for example, in OpenGL), and the shader compiler in the video driver translates the code into binary commands that the video processor can execute.  Such compilation requires computational resources and time, so in modern PC games this problem is solved by compiling at times when the frame rate is not important, for example, at boot time.  Due to the large number of different computer video processors, games for PCs cannot pre-compile shaders for a specific video processor.  Therefore, the only way to execute shaders on specific hardware is to compile them with a video driver at a certain point in the game. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35a/d6a/5b7/35ad6a5b7ac4a6c5302d2ec63d5adc75.jpg"><br>  <i>Video GameCube Flipper, the largest chip on the motherboard.</i>  <i>Source: <a href="http://www.anandtech.com/show/858/12">Anandtech</a></i> <br><br>  In consoles everything is completely different.  If you know exactly what equipment will run the game, and know that this equipment will never change, you can simply pre-compile the programs for the video processor and burn them to disk, speeding up the game loading and ensuring a constant speed of work.  This is especially important on older consoles, which do not have enough memory, and it may not even be possible to store shaders in memory.  The GameCube video processor called Flipper is just the case. <br><br>  Flipper has elements with constant functions, so it used the programmable module TEV (Texture EnVironment, texture environment), which can be configured to perform a huge variety of effects and rendering techniques - almost the same way as slicable shaders do.  In fact, the capabilities of the TEV module are very similar to the features of DirectX 8 pixel shaders on the Xbox!  It was so versatile and powerful that Flipper with some modifications was used as the Wii video processor (already called Hollywood).  Unfortunately for us, the TEV module is designed to perform TEV configurations in games directly at the moment effect is required.  There is no preloading of TEV configurations, because there is no memory for this in the TEV module. <br><br>  This instant download has become the source of all our problems.  Dolphin must be able to translate every Flipper / Hollywood configuration used by the game into a specialized shader that could be executed by a computer video processor.  Shaders need to be compiled, and this takes time.  But the TEV module does not have the ability to save configurations, so GC / Wii games customize it so that it renders the effect as soon as it is needed, without any delays and notifications.  To cope with this discrepancy, Dolphin can only postpone the video processor's stream while the video processor's stream and video driver compile, that is, in effect, suspending the operation of the emulated GC / Wii console.  Usually, compilation is performed between frames and users do not notice this, but if it lasts longer than the frame, the game is noticeably suspended until the compilation is completed.  This is the <strong>hang when compiling shaders</strong> .  Usually the hang-up lasts only a couple of frames, but in very loaded scenes with several compiled shaders, it can hang for <em>more than a second</em> . <br><br>  Until the cache of shaders is created, Metroid Prime 3 gameplay is quite painful ( <a href="https://gfycat.com/ru/gifs/detail/elderlyenchantedalpinegoat">GIF</a> ). <br><br>  Dolphin was the first emulator to emulate a system with a programmable video processor at full speed, so we had to solve this problem on our own.  We implemented caching of shaders, that is, when you turn on any configuration a second time, it no longer hangs.  But to create a reliable cache you would have to play the game for several hours, and replacing the video processor of the computer, updating the video driver, or even switching to a new version of Dolphin could lead to outdated cache and new hangs.  For several years, it seemed to us that nothing could be done with the compilation of shaders, and many wondered if this was possible at all ... <br><br><h2>  Solving an unsolvable problem </h2><br>  Of all the remaining problems of Dolphin, users complained most about hang-ups when compiling shaders.  When discussing in bug trackers, on forums, on social networks and IRC, this issue constantly popped up.  After a few years, we began to react to it differently.  At first, hanging was not even considered a bug.  What is the significance of small inhibitions if the games barely work at all?  Everything changed in January 2015, when the hangup was formally recognized as a problem in the Dolphin bug tracker and information about it began to spread. <br><br>  In recent years, users have asked a lot of questions about the hangs, demanded a solution to the problem, declared the emulator useless, and not even scolded the developers because of the lack of attention to compiling shaders.  The truth is that we hate these suspensions like no other, and we have been thinking about this issue for many years.  Many solutions were invented, some of them were even tested.  But it seemed that the task could not be solved without serious side effects. <br><br><h3>  Possible solutions </h3><br><h4>  Generate all shaders in advance! </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/289/3c7/f0f/2893c7f0f4ebc6ac796f9fd5b21ead60.jpg"><br>  <i>For reference: on Earth about 7.5 √ó 10 <sup>15</sup> grains of sand.</i> <br><br>  Dolphin can quite quickly generate the shaders it needs, but the problem lies in the compilation.  But if we could somehow generate and compile shaders for each possible configuration, this would solve the problem, right?  Unfortunately, this is simply impossible. <br><br>  There are approximately 5.64 √ó 10 <sup>511</sup> possible configurations of only one TEV module, and we would have to create a unique shader for each of the configurations.  In addition, the system uses vertex shaders to emulate a semi-programmable Hardware Transform and Lighting unit, and they further increase the number of combinations. <br><br>  Even if we could compile them, these shaders could only be used in the Dolphin version for which they were generated.  When upgrading to a new build, a new set of shaders would be required.  In other cases, for example, when replacing a video card or updating video drivers <em>,</em> recompilation would <em>also</em> be required.  And all this would be possible if the driver has a low-level cache, which not all drivers have. <br><br><h4>  Predict the shaders the game will need! </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/b4c/b32/100/b4cb321003fb46ed0ab8d3e5062c94c7.jpg"><br><br>  If we were able to generate and compile shaders only on loading screens and in other similar cases, then the suspensions would be imperceptible.  But to realize the prediction so that it solves the problem is simply impossible.  The impact on the speed and complexity of the implementation of "predictions" fast forward and prediction of input data are too expensive for situations that they could help. <br><br>  Blind predictions don't work either - the game can choose the running configurations and does not warn about it, and the previous configurations do not tell us anything about the following.  The only way to find out what shaders the game needs is to go through the game and find every configuration that it may need. <br><br>  ... Which led us to another proposed solution. <br><br><h4>  Common shaders </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/bc9/e7f/608/bc9e7f6083b05d76993c7371f95426aa.jpg"><br><br>  To describe the configuration of the emulated video processor, Dolphin uses the object ‚ÄúUnique ID‚Äù (‚ÄúUID‚Äù).  These UIDs are turned into shader code and passed to the video driver for compilation.  Since UIDs are assigned before compilation and are not customized for any particular computer video processor, they are compatible with any computer and theoretically they can be shared.  Theoretically, if users share UID files, they will be able to compile shaders in advance and they will not hang up.  Currently, the Vulkan API <em>already has this feature</em> , which is necessary to avoid problems with caching shaders for some drivers. <br><br>  So why this decision was never implemented? <br><br><ul><li>  Dolphin continues to improve.  When making graphical improvements, all these UIDs would have to be thrown away. </li><li>  Not all games can be so processed.  Popular games would have an almost complete collection of UIDs, but we couldn‚Äôt help those who played in little-known masterpieces. <ul><li>  When testing, it turned out that different games have very few common UIDs.  <em>The Legend of Zelda: The Wind Waker</em> and <em>The Legend of Zelda: Twilight Princess</em> have a small amount of common configurations (15%), but they run on the <em>same basic engine</em> .  Most games will have much less in common, so sharing information about popular games would certainly not help lesser known. </li></ul><br></li><li>  Users may not have different UIDs.  There is an almost infinite number of configurations.  Even one hundred percent passing game does not guarantee that you use them all. </li></ul><br>  The developers weighed this decision for a while, but discussing the UID exchange infrastructure and finding a good way to distribute them created more controversy than solutions.  This system could be used to <strong>improve an</strong> already working solution, but it could not be one itself. <br><br><h4>  Asynchronous Shader Compilation </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/8f3/67a/ef8/8f367aef8f230763f5523a14d7fd2e7e.jpg"><br><br>  <em>Asynchronous compilation of shaders</em> , which has gained popularity due to fork, is a non-standard solution to the dilemma of compiling shaders.  <a href="https://github.com/Tinob">Tino</a> looked at the problem in almost the same way as some modern games solve the problem of dynamic compilation of new shaders.  When a player appears in a new area, new objects sometimes just arise from nothing, that is, they load dynamically.  He wondered if he could not get a similar result in the emulator, and in his fork began to rewrite the way the shaders were processed. <br><br>  The concept of asynchronous shader compilation changed Dolphin's behavior when he did not find the cached shader for the detected Flipper / Hollywood configuration.  Instead of pausing the game and waiting for the compiler to compile the shader, he simply missed rendering the object.  This meant that there were no pauses and hangs, but some objects could be missing in the frame until their shader was <em>ready</em> . <br><br>  For some games, this method worked well.  In part of the games, the engine cut off objects when rendering in such a way that objects outside the camera's field of view or covering only a few pixels of the screen were still rendered.  In this case, the skip rendering of such objects was barely noticeable.  However, in other games this led to the ‚Äúout of nowhere‚Äù effect described above. <br><br>  When skipping the compilation of shaders, objects could appear from the air, and the graphics looked broken ( <a href="https://gfycat.com/gifs/detail/unacceptablefoolhardyirishsetter">GIF</a> ).  But the gameplay remained smooth! <br><br>  Users asked the question: why did the Tino asynchronous shaders not be included in Dolphin at least as an option to solve the problem of suspensions when compiling shaders?  It all came down to the fact that people who <em>could</em> realize this function together with other major developers were against such a decision.  They saw in him only a hack that would lead to a bunch of false positive reports in the bug tracker and the emergence of even greater problems in the future.  In some ways they were right: it became clear that some games <em>need to</em> render objects in the frame in which they are expected.  In this case, Mii avatar heads were rendered only once into the Embedded Framebuffer (EFB).  If a copy of EFB was missing due to the asynchronous compilation of shaders, then Mii heads were not displayed until the end of the game or until their regeneration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/faf/673/1a7/faf6731a742efa9a1126a76349792bc0.png"><br>  <i>Headless Mii</i> <br><br>  Despite all the flaws, users of the Tino fork believed in the asynchronous compilation of shaders.  Let asynchronous shaders cause problems, the main thing is that they <em>solved the</em> problem of <strong>hanging up</strong> when compiling shaders.  Due to obvious flaws, it could not be merged with the Dolphin master branch, but this solution definitely underlined the seriousness of the problem with the compilation of the generated shaders.  Tino's work on the asynchronous compiler of shaders clearly showed us how much this problem worries users, and even more motivated the team to find a better solution. <br><br><h2>  Decision </h2><br><h3>  Write the interpreter of the GameCube / Wii rendering pipeline inside the shaders and run it in the computer video card </h3><br>  Sometimes the best way to solve an insoluble problem is to look at it from a different angle.  Whatever we tried to do, there was no way to compile specialized shaders at the same speed as the game changes configurations. <br><br>  But what if we do not rely on specialized shaders?  We had a crazy idea - to emulate <em>the rendering pipeline itself</em> using an interpreter, which is executed directly in the video processor as a set of huge universal shaders.  If we compile these huge shaders when the game starts, then when the game changes the Flipper / Hollywood configuration for rendering effects, such ‚Äúshaders‚Äù will <strong>configure themselves</strong> and perform rendering without the need for new shaders.  Theoretically, this will solve the problem with freezing when compiling shaders due to the <em>complete</em> rejection of compilation. <br><br>  This thought seemed insane, but it was the first to have the potential to solve this insoluble problem.  The complexity of this decision lay in the absurd amount of work and knowledge to achieve at least the stage of testing its capabilities.  For you to understand: even among all Dolphin developers, only two or three people <em>at best</em> had knowledge not only about the GameCube / Wii hardware, but also about modern video processors, GPU, API <strong>and drivers</strong> needed to write and optimize shaders.  This is not to mention the fact that executing the interpreter as huge shaders is not a very simple task for the video processor.  Many feared that the results of all this work could not be performed at full speed even on modern video cards. <br><br>  To guarantee the winnings, it would take hundreds, if not thousands, of hours of numbing, monotonous, but difficult work. <br><br>  The first attempt was made in 2015, when the <a href="https://github.com/phire">phire</a> developer <a href="https://github.com/phire">was</a> so tired of hanging on his powerful new computer that he made a proposal and developed a framework for the <em>superscheider</em> .  Although he was aware of all the difficulties, but he seemed determined to prove that the uberheders were the solution to our ancient problem.  phire <strong>alone</strong> tried to re-teach dolphin rendering. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c15/fe5/a24/c15fe5a240e8e45d003fbbb2b6f146b2.png"><br>  <i>This is not a graphic filter.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db0/555/2e2/db05552e28ab0e2ad167aeeec23bba4e.png"><br>  <i>It seems there are a couple of glitches here ...</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ace/b13/17a/aceb1317ab09805a12140daac117acdb.png"><br>  <i>Due to its simplicity, the SM64 was one of the first games in which something was rendered via sinkers.</i> <br><br>  After finishing this function for a month, he managed to bring pixel uber-shaders to the stage where some games looked almost the same as their versions on fast shaders.  Surprisingly, it wasn‚Äôt that they work, but that the prototypes of Ubershaders allow you to play games at full speed.  Phire himself recalls that his first reaction was: <em>nifiga itself, they really work at full speed</em> .  He admitted that <em>video processors did not have to cope with work at playable speed, but they succeeded</em> .  Against all expectations, prototypes have proved that warders can be the solution to the problem with freezing when compiling shaders.  Therefore, with further improvements, we have improved the accuracy of the heathaders, corrected many errors and implemented the missing features. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eec/928/a9b/eec928a9bfddbf7db2868d61f0c9f0fb.png"><br>  <i>At the very beginning, ubercasders turned the games into a picture of a distorted reality.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/20b/ee9/01a/20bee901a35f59f0abca8b737d3c2670.png"><br>  <i>But the situation was quickly improving.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/c3e/01d/bd2c3e01d4d428a2c7dfb6f9975a297e.png"><br>  <i>We did not have time to blink an eye, and Wind Waker has already become rendered with just a few errors.</i> <i><br></i> <br><img src="https://habrastorage.org/getpro/habr/post_images/2fc/731/81d/2fc73181d6cd480886440cf603927a0a.png"><br>  <i>phire quickly achieved the perfect rendering of wind waker.</i>  <i>Unfortunately, other games with a wider list of features required much more work.</i> <br><br>  Having brought the project of ubersheaders to this stage, phire was completely exhausted.  Moreover, he still had a lot of work to debug other projects for the release of Dolphin 5.0.  It turned out that the delays have their price - due to burnout and worries about the limitations of the drivers and the API phire lost all its fuse.  Although approximately 90% was ready, 90% remained, including several important functions. <br><br><ul><li>  Completing Vertex Bowers </li><li>  Infrastructural / connective pixel and vertex sinkers </li><li>  Resolving OpenGL performance issues and (after rebase) with Vulkan </li><li>  Cleaning up the code, correcting errors and getting the same rendering results as on specialized shaders </li><li>  GUI Options </li><li>  <strong>Advanced</strong> - hybrid mode for embedded and weak video processors </li></ul><br>  It was painful to see that this amount of work hung in uncertainty.  But it was not possible to find developers able and willing to take on such a huge project.  Even those who decided to work on it were not ready to clean up the code, correct errors and work on the infrastructure.  For more than a year, the development of the uberschader was idle, the list of unfinished functions was constantly growing, and hope was gradually fading ... <br><br><h2>  Ubershadery 2.0 </h2><br>  Suspensions when compiling Dolphin shaders were one of the most noticeable errors, so after completing the development of the ubershaders, users did not forget about them.  The long-abandoned pool-request continued to be replenished with comments, they wrote about the problem on the forums and even stated it in various forms in a bug tracker. <br><br>  The ubercheders remained the first real hope of eliminating the suspensions, and they surfaced monthly in discussions.  The progress achieved only spurred community interest in the decision.  After a lot of requests, complaints and even <s>blackmail,</s> <a href="https://github.com/stenzek">Stenzek</a> reluctantly began to work on Ubersheaders. <br><br>  Even before Stenzek took on the packers, the team made decisions regarding support for graphics APIs.  One of the solutions, namely the rejection of the API D3D12, received mixed, if not negative reviews.  Unlike the D3D9 solution, we didn‚Äôt want to go through the process of phasing out and got rid of it right away, as it became obvious that no one wants to support this API. <br><br>  But this turned out to be a good solution, because getting rid of the API allowed us to revive the project of ubershaders when Stenzek was ready for this.  He was the backend architect of Vulkan in Dolphin, so he wanted to do extra work to get the Ubercher to work with Vulkan. <br><br>  When pixel and vertex packers were finally merged together and ready to launch, testers immediately used them in the most difficult games.  Considering that none of the previous solutions worked normally for Metroid Prime 3, this game became the first candidate. <br><br><br>  Metroid Prime 3 was one of the few games in which shader hangs lowered the rating to non-playable.  Until recently ( <a href="https://gfycat.com/gifs/detail/grotesquekeenangelfish">gif</a> )! <br><br>  The first test of Uberchers was a huge success: the suspensions completely disappeared in D3D, and in OpenGL and Vulkan only some strange inhibitions appeared at the early stages.  Continuing our work on the Ubirders, we have greatly improved their work in all APIs, with a few exceptions, which I will discuss later.  But just running the game on Uberschad was not enough: they themselves ate up a large amount of computer video card resources.  Of course, the requirements of different games are different, but usually the video card was strongly influenced by the resolution in which the game was launched.  With native resolution of 1x (480p), most video cards coped, and more powerful cards could even work with resolutions of 1080p or higher, while using only supersheders.  Unfortunately, many of our users did not have the equipment necessary to run the uberchers in the resolution they were used to.  Therefore, they had to choose between resolution and smoothness of work. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/dd5/1b8/792/dd51b8792bccfd8a45c2bf55860d81f2.svg"></a> <br>  <i>Intel's integrated video processors barely cope with specialized Dolphin shaders at high resolutions, not to mention heat sinkers.</i>  <i>(Click on the image to view statistics.)</i> <br><br>  A <strong>very large</strong> part of Dolphin users have built-in video processors in their computers.  When testing embedded video processors, <em>at best, they</em> gave in 3D-games with Ubershaders at a resolution of 1x, only about <strong>50% of the</strong> speed!  The developers realized that it would be a mistake to ignore a large part of Dolphin users and made the ubershade optional.  Work continued on a search for a more reliable solution that could solve performance problems once and for all. <br><br><h3>  Hybrid Mode Udershader </h3><br>  The hybrid mode of uberdershaders is a combination of uberdersaders and asynchronous generation of shaders in one beautiful solution, which took the best from each approach, but got rid of their shortcomings.  Since the hybrid mode greatly reduced the resource consumption of the packers, we expected it to be the most popular mode of packers. <br><br>  In the hybrid mode, when a new configuration of the pipeline appears, Dolphin uses the already compiled websheaders to instantly render the effect without hanging, while continuing to compile a specialized shader in the background.  After creating specialized shaders, Dolphin transfers the rendering of objects from the ubershader to these generated specialized shaders. <br><br>  If we assume that the drivers and API will behave in the way we need, then this will be an excellent solution.  Since heat shaders are performed only for part of the objects in the scene and not for all frames, the performance impact is almost imperceptible, and the suspensions are completely eliminated.  Unfortunately, the drivers and APIs are not perfect, which limits the effectiveness of the hybrid mode on some machines.  And that brings us to ... <br><br><h3>  Board of shame API and drivers for ubershader </h3><br>       :         ,        .        ,                  API. -           . <br><br>       . , -              /API,    , , . <br><br><h4>    </h4><br>          .            ,    ,       .          .             ,     ,     . <br><br>  ,    (,  Mesa)      ,     .            .        ,  ,     Vulkan   Mesa   . <br><br><h4>   NVIDIA  OpenGL  Vulkan </h4><br>     ,   OpenGL  Vulkan (  )      .    ,  ,      D3D,    ,     NVIDIA,     Dolphin.          . <br><br><h4>   NVIDIA  OpenGL  Vulkan  ,   D3D </h4><br>   ,           .       OpenGL, Vulkan  D3D,  ,  D3D <strong> </strong>  .  ,   GTX 760  OpenGL  Vulkan     1x,   D3D          . <br><br> NVIDIA   ,   ,  <em>   </em>    .          ,       D3D. ,   :  ,  Dolphin     NVIDIA,        . ,       .             . <br><br> <s> ,      ‚Äî      .</s> <em>:  NVIDIA  ,         Direct3D 12 (    ),    API   . ,    API   .</em> <br><br><h4> <s>  AMD  Vulkan <em>-</em>    </s> </h4><br>     ,   !  AMD  Vulkan    !       ,           .  ,            . <br><br><h4>   macOS -  </h4><br>         ,  macOS,  ,    ¬´  macOS...¬ª.  Here she is. ,   OpenGL 4.1  macOS          -  .   <strong></strong> ,       .    : macOS -         . <br><br><h2>    </h2><br>      , ,        API  .   <strong></strong>     .           .  ,        , ,      (anti-aliasing)    ,      .  ,       ,          . <br><br><ul><li> <strong>Intel</strong>  <strong>Windows</strong> <br><ul><li>   <em>Hybrid</em>  <strong>D3D</strong> .  Exclusive Mode (    ) ,    Intel   ,        ¬´¬ª  1x. </li><li>      <strong>OpenGL</strong>  . </li><li>  <strong>Vulkan</strong>     Skylake  ,              . </li></ul><br></li><li> <strong>Intel</strong>  <strong>Linux</strong> <br><ul><li>   <em>Hybrid</em>  <strong>Vulkan</strong> . Exclusive Mode ,     . </li><li>   Anv       . </li><li>  Intel i965    OpenGL  .  ,       ,    . Exclusive Mode  ,    ,   Hybrid Mode  . </li></ul></li></ul><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/95d/59c/e0a/95d59ce0abab98a47609946751337e58.png"></a> <br> <i>  ,   </i> <br><br><ul><li> <b>AMD</b>  <b>Windows</b> <ul><li>   <i>Hybrid</i>  <b>D3D</b> . </li><li>  <i>Exclusive Mode</i>  <b>D3D</b>  <b>Vulkan</b> . </li><li>    <b>OpenGL</b> AMD  . </li></ul></li><li> <b>AMD</b>  <b>Linux</b> <ul><li>   <i>Exclusive</i>  <i>Hybrid</i>  <b>Vulkan</b> . </li><li> radv     anv    . </li></ul></li></ul><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5c3/2cc/773/5c32cc773726e3b28c4905764756379d.png"></a> <br> <i>  ,   </i> <br><br><ul><li> <strong>NVIDIA</strong>  <strong>Windows</strong> <br><ul><li>   <em>Hybrid</em>  <strong>D3D</strong>  <strong>OpenGL</strong> . </li><li>   <em>Exclusive</em>  <strong>D3D</strong> , <strong>OpenGL</strong>  <strong>Vulkan</strong> .  <strong>D3D</strong>   ,   OpenGL  Vulkan,         . </li></ul></li><li> <strong>NVIDIA</strong>  <strong>Linux</strong> <br><ul><li>   <em>Hybrid</em>  <strong>OpenGL</strong> . </li><li>   <em>Exclusive</em>  <strong>OpenGL</strong>  <strong>Vulkan</strong> .     ,  API   . ,   Vulkan      ,          . </li></ul></li><li> <strong>NVIDIA</strong>  <strong>Android</strong> <br><ul><li>   <em>Hybrid</em>  <strong>OpenGL</strong> . </li><li>   <em>Exclusive</em>  <strong>OpenGL</strong>  <strong>Vulkan</strong> .   Exclusive       NVIDIA Shield TV    . </li></ul></li></ul><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/38e/95e/91e/38e95e91e5df0f792cacaf119bcd17f7.png"></a> <br> <i>  ,   </i> <br><br> <strong>PowerVR</strong>  <strong>Android</strong> <br><ul><li>  Not recommended.       -   ,       Hybrid Mode     .       . </li></ul><br> <strong>Adreno</strong>  <strong>Android</strong> <br><ul><li>  Not recommended. Hybrid Mode   ,  Exclusive Mode    .        . </li></ul><br> <strong>Mali</strong>  <strong>Android</strong> <br><ul><li>  .      ,     . </li></ul><br><h2>  Finally </h2><br>          .  ,              .    ,         .  ,    ,  Exclusive Mode   ,  .   Vulkan ,       ,  Hybrid Mode    .  ,   ,  ,    <br><br>       ,  Dolphin <em> </em>    .  ,     JIT,    .  JIT     Dolphin     ,  JIT (,   N64 VC).    ,  <em></em>     ,          .       , ,  ,     ,      ,        . <br><br> -         .  <strong></strong>        .   ,   ! </div><p>Source: <a href="https://habr.com/ru/post/334868/">https://habr.com/ru/post/334868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334856/index.html">Is the end of the CSRF close?</a></li>
<li><a href="../334858/index.html">Javascript like a holiday</a></li>
<li><a href="../334860/index.html">How to use Kanban for convenient work of not only managers, but also programmers</a></li>
<li><a href="../334864/index.html">How I downloaded the source of my own site</a></li>
<li><a href="../334866/index.html">Using FlyWay for databases on the example of Maven</a></li>
<li><a href="../334870/index.html">Dismiss, hire, improve - the culture of your company. Radish anatomy</a></li>
<li><a href="../334874/index.html">How Doom Guns were Made</a></li>
<li><a href="../334876/index.html">Graphics evolution in games</a></li>
<li><a href="../334880/index.html">Configuring Cisco AnyConnect VPN with 2FA (ActiveDirectory and Certificate) via ASDM</a></li>
<li><a href="../334882/index.html">Brand History Chupa Chups</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>