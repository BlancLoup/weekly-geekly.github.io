<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Teach computer feelings (sentiment analysis in Russian)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sentiment analysis (in Russian, tonality analysis) is the field of computational linguistics, which studies the opinions and emotions in text document...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Teach computer feelings (sentiment analysis in Russian)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/366/b70/2de/366b702de57d315c573d0db5ae6d70ac.png"><br><br>  <i>Sentiment analysis</i> (in Russian, tonality analysis) is the field of computational linguistics, which studies the opinions and emotions in text documents.  Recently, an article appeared on Habr√© about using machine learning for tonality analysis, however, it was so poorly compiled that I decided to write my own version.  So, in this article I will try to explain in an easy way what the analysis of tonality is and how to implement such a system for the Russian language. <br><a name="habracut"></a><br><br><h4>  Tonality analysis </h4><br>  The purpose of the <i>analysis of tonality</i> is to find opinions in the text and determine their properties.  Depending on the task, we may be interested in different properties, for example: <br><ol><li>  author - who owns this opinion </li><li>  topic - what is said in the opinion </li><li>  tonality - the position of the author relative to the mentioned topic (usually "positive" or "negative") </li></ol><br><pre><code class="hljs objectivec">: <span class="hljs-string"><span class="hljs-string">"        ‚Äì      ,       ¬ª, ‚Äî   "</span></span> :   : <span class="hljs-string"><span class="hljs-string">"  "</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br>  In the literature there are different ways to formalize the model of opinions.  I just gave an example of one of them.  Different terminology is also used.  In English, this area of ‚Äã‚Äãresearch is commonly referred to as <i>opinion mining and sentiment analysis</i> (literally: ‚Äúseeking opinions and analyzing feelings‚Äù).  In Russian articles, the term ‚Äútonality analysis‚Äù is usually used.  Despite the fact that tonality is only one of the characteristics of opinion, it is the task of classifying the tonality that is the most frequently studied in our day.  This can be explained by several reasons: <br><ol><li>  Identifying the author and the topic is much more difficult than classifying the tonality, so it makes sense to first solve a simpler problem and then switch to the others. </li><li>  In many cases, we only need to determine the tonality, because  other characteristics are already known to us.  For example, if we collect opinions from blogs, usually authors of opinions are authors of posts, i.e.  we do not need to identify the author.  Also, we often already know the topic: for example, if we search Twitter for the keyword "Windows 8", then we only need to determine the tone of the tweets found.  Of course, this does not work in all cases, but only in most of them.  But these assumptions make it possible to considerably simplify the already difficult task. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The analysis of tonality finds its practical application in various fields: <br><ol><li>  Sociology - collect data from the social.  networks (for example, religious beliefs) </li><li>  political science - collect data from blogs about political views of the population </li><li>  marketing - we analyze Twitter to find out which notebook model is most in demand </li><li>  medicine and psychology - we define depression in social users.  nets </li></ol><br><br><h4>  Approaches to the classification of tonality </h4><br>  Analysis of tonality is usually defined as one of the tasks of computational linguistics, i.e.  implies that we can find and classify tonality using natural language processing tools (such as teggers, parsers, etc.).  Having made a large generalization, it is possible to divide the existing approaches into the following categories: <br><br><img src="https://habrastorage.org/storage2/292/78c/da3/29278cda3b9744ac6bef7a6ceb7e3c52.png"><br><br><ol><li>  Rule based approaches </li><li>  Dictionary Based Approaches </li><li>  Machine learning with a teacher </li><li>  Machine learning without a teacher </li></ol><br>  The first type of system consists of a <b>set of rules</b> , applying which the system makes a conclusion about the tonality of the text.  For example, for the sentence "I love coffee", you can apply the following rule: <br><pre> <code class="hljs 1c"><span class="hljs-keyword"><span class="hljs-keyword"></span></span>  (<span class="hljs-string"><span class="hljs-string">""</span></span>)      (<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span> ...)    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ,     <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre><br><br>  Many commercial systems use this approach, despite the fact that it is costly, because  for a good system to work, you need to make a large number of rules.  Often, the rules are tied to a specific domain (for example, ‚Äúrestaurant theme‚Äù) and when you change the domain (‚Äúcamera review‚Äù), you must re-create the rules.  Nevertheless, this approach is the most accurate with a good rule base, but completely uninteresting to research. <br><br>  <b>Dictionary based approaches</b> use so-called tonal dictionaries (affective lexicons) to analyze text.  In its simplest form, a pitch dictionary is a list of words with a pitch value for each word.  Here is an example from the ANEW database translated into Russian: <br><table><tbody><tr><th>  <b>word</b> </th><th>  <b>valence</b> (1-9) </th></tr><tr><td>  happy </td><td>  8.21 </td></tr><tr><td>  good </td><td>  7.47 </td></tr><tr><td>  boring </td><td>  2.95 </td></tr><tr><td>  angry </td><td>  2.85 </td></tr><tr><td>  sad </td><td>  1.61 </td></tr></tbody></table><br><br>  To analyze the text, you can use the following algorithm: first, assign each word in the text to its value from the dictionary key (if it is present in the dictionary), and then calculate the overall tonality of the entire text.  You can calculate the overall tonality in different ways.  The simplest of them is the arithmetic average of all values.  More difficult is to train a classifier (for example, a neural network). <br><br>  <b>Machine learning with a teacher</b> is the most common method used in research.  Its essence is to train the machine classifier on a collection of pre-marked texts, and then use the resulting model to analyze new documents.  About this method I will tell further. <br><br>  <b>Machine learning without a teacher</b> is probably the most interesting and at the same time the least accurate method for analyzing tonality.  One example of this method may be automatic clustering of documents. <br><br><h5>  Machine learning with a teacher </h5><br>  The process of creating a tonality analysis system is very similar to the process of creating other systems using machine learning: <br><ol><li>  it is necessary to collect a collection of documents for classifier training </li><li>  Each document from the training collection must be represented as a feature vector. </li><li>  for each document you need to specify the "correct answer", i.e.  type of tonality (for example, positive or negative), the classifier will be trained according to these answers </li><li>  choice of classification algorithm and classifier training </li><li>  using the resulting model </li></ol><br><br><h6>  Number of classes </h6><br>  The number of classes into which the tonality is divided is usually given from the system specification.  For example, the customer requires the system to distinguish between three types of tonality: ‚Äúpositive‚Äù, ‚Äúneutral‚Äù, ‚Äúnegative‚Äù.  In studies, the problem of binary classification of tonality is usually considered, i.e.  There are only two classes: ‚Äúpositive‚Äù and ‚Äúnegative‚Äù.  From my experience I can say that the classification of tonality into more than two classes is a very difficult task.  Even with three classes it is very difficult to achieve good accuracy regardless of the approach used. <br><br>  If there is a task of classifying into more than two classes, then the following options are available for classifier training: <br><ul><li>  <i>Flat classification</i> - we train only one classifier for all classes. <br><br><img src="https://habrastorage.org/storage2/776/c1c/39f/776c1c39f58f3aaefb695cd2f0c6d2e9.png"></li><li>  <i>Hierarchical classification</i> - we divide classes into groups and train several classifiers to define groups.  For example, if we have 5 classes (‚Äústrongly positive‚Äù, ‚Äúmoderately positive‚Äù, ‚Äúneutral‚Äù, ‚Äúmoderately negative‚Äù, ‚Äústrongly negative‚Äù), then we can first teach a binary classifier that separates neutral texts from subjective ones;  then train a classifier that separates positive opinions from negative ones;  and as a result, a classifier that separates strongly expressed opinions from the average. <br><br><img src="https://habrastorage.org/storage2/8bc/bb0/0a9/8bcbb00a9dcfe10cd26f5fc6025cd5f5.png"><br></li><li>  <i>Regression</i> - we train the classifier to obtain a numerical value of tonality, for example, from 1 to 10, where a larger value means a more positive tonality. </li></ul><br><br>  Usually hierarchical classification gives better results than flat, because  For each classifier, you can find a set of attributes that allows you to improve the results.  However, it requires a lot of time and effort for training and testing.  Regression can show the best results if there are really many classes (from 5 and more). <br><br><h6>  Feature selection </h6><br>  The quality of the results directly depends on how we present the document for the classifier, namely, which set of characteristics we will use to compile the feature vector.  The most common way to present a document in a comp task.  linguistics and search is either in the form of a set of words (bag-of-words) or in the form of a set of N-grams.  For example, the sentence ‚ÄúI love black coffee‚Äù can be represented as a set of unigrams (I, love, black, coffee) or bigrams (I love, I love black, black coffee). <br><br>  Usually unigrams and bigrams give better results than higher-order N-grams (trigrams and higher), because  In most cases, the sample of training is not large enough to calculate higher-order N-grams.  It always makes sense to test the results using unigrams, bigrams and their combinations (I, love, black, coffee, I love, I love black, black coffee).  Depending on the type of data, unigrams may show better results than bigrams, and vice versa.  Also, sometimes a combination of unigrams and bigrams improves results. <br><img src="https://habrastorage.org/storage2/4e0/6ae/9dd/4e06ae9ddfeede18cfc709fb4da8e5bf.png"><br><br><div class="spoiler">  <b class="spoiler_title">Stemming and lemmatization</b> <div class="spoiler_text">  In some studies, when presenting a text, all words go through a stemming procedure (deletion of the ending) or lemmatization (reduction to the initial form).  The purpose of this procedure is to reduce the dimension of the problem, in other words, if the text contains the same words, but with different endings, using stemming and lemmatization, they can be reduced to the same type.  However, in practice it usually does not give any tangible results.  The reason for this is that by getting rid of the endings of words, we lose morphological information, which can be useful for analyzing the tonality.  For example, the words ‚ÄúI want‚Äù and ‚Äúwanted‚Äù have different tonality.  If in the first case the tonality is most likely positive, since  Since the author can express hope and positive emotions, then in a verb in the past tense, the tonality can be negative if the author expresses regret. <br></div></div><br><br>  Another way of presenting text is symbolic N-grams.  The text from the example can be represented as the following 4-character N-grams: ‚ÄúI love,‚Äù ‚Äúlove,‚Äù ‚Äúcelebrate,‚Äù ‚Äúblue,‚Äù etc.  Despite the fact that this method may seem too primitive, because  at first glance, the character set does not carry any semantics; nevertheless, this method sometimes gives results even better than N-grams of words.  If you take a closer look, you can see that the N-grams of characters correspond to some degree to the morphemes of words, and in particular the root of the word (‚Äúlove‚Äù) bears in itself its meaning.  Character N-grams can be useful in two cases: <br><ol><li>  in the presence of spelling errors in the text - the set of characters in the text with errors and the set of characters in the text without errors will be almost the same as in words. </li><li>  for languages ‚Äã‚Äãwith rich morphology (for example, for Russian) - the same words can be found in texts, but in different variations (different gender or number), but the root of the words does not change, and therefore the common set of characters. </li></ol><br>  Symbolic N-grams are used much less frequently than N-grams of words, but sometimes they can improve results. <br><br>  You can also use additional features such as: parts of speech, punctuation (smiles, exclamation marks in the text), negative signs in the text (‚Äúnot‚Äù, ‚Äúno‚Äù, ‚Äúnever‚Äù), interjections, etc. <br><br><h6>  Weighted Vector </h6><br>  The next step in the compilation of the feature vector is the assignment of a weight to each feature.  For some classifiers, this is optional, for example, for a Bayesian classifier, since  he himself calculates the probability for signs.  But if you use the support vector method, then weighting can significantly improve the results. <br><br>  In information retrieval, <a href="http://ru.wikipedia.org/wiki/TF-IDF">TF-IDF</a> is the most common method for assessing feature weight.  For the analysis of tonality this method does not give good results.  The reason for this is that words are not so important for the analysis of tonality, which are often repeated in the text (ie words with high TF), in contrast to the search task.  Therefore, binary weight is usually used, i.e., features (if we use unigrams, then words) are assigned a unit weight, if they are present in the text.  Otherwise, the weight is zero.  For example, ‚ÄúI love black coffee‚Äù will be represented as the following vector (we omit words with weight = 0): <br><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">""</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">""</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">""</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">""</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}</code> </pre><br><br>  However, there are methods for assessing the importance of words, which calculate the weights of words that give much better results in the classification of tonality, for example, <a href="http://ebiquity.umbc.edu/_file_directory_/papers/446.pdf">delta TF-IDF</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Delta TF-IDF</b> <div class="spoiler_text">  The idea of ‚Äã‚Äãthe delta TF-IDF method is to give more weight to words that have a non-neutral tone, because  It is these words that determine the tonality of the entire text.  The formula for calculating the weight of the word w is as follows: <br><br><img src="https://habrastorage.org/storage2/94d/cc4/851/94dcc4851c8433abf464b174707e3d32.png" alt="Vt, d = Ct, dlog (| N | Pt | P | Nt)"><br><br>  Where: <br><ul><li>  V <sub>t, d</sub> - the weight of the word t in the document d </li><li>  C <sub>t, d</sub> - the number of times the word t occurs in the document d </li><li>  | P |  - number of documents with positive tonality </li><li>  | N |  - number of documents with a negative tone </li><li>  P <sub>t</sub> - the number of positive documents, where the word t occurs </li><li>  N <sub>t</sub> - number of negative documents where the word t occurs </li></ul><br><br>  What is the result?  Let's say we work with a collection of movie reviews.  Consider three words: ‚Äúexcellent‚Äù, ‚Äútedious‚Äù, ‚Äúscript‚Äù.  The most important thing in the delta TF-IDF formula is the second factor <i>log (...)</i> .  It will be different in these three words: <br><ol><li>  The word ‚Äúexcellent‚Äù is most likely to be found in most positive (P <sub>t</sub> ) reviews and almost never occurs in negative (N <sub>t</sub> ), as a result, the weight will be a large positive number, since  the ratio P <sub>t</sub> / N <sub>t</sub> will be a number far greater than 1. </li><li>  The word ‚Äútedious‚Äù, on the contrary, occurs mainly in negative reviews, so the ratio P <sub>t</sub> / N <sub>t</sub> will be less than one and as a result the logarithm will be negative.  As a result, the weight of the word will be a negative number, but large in magnitude. </li><li>  The word ‚Äúscenario‚Äù can occur with the same probability in both positive and negative reviews, so the ratio P <sub>t</sub> / N <sub>t</sub> will be very close to one, and as a result the logarithm will be close to zero.  The weight of the word will be almost zero. </li></ol><br><br>  As a result, the weight of words with a positive tonality will be a large positive number, the weight of words with a negative tonality will be a negative number, the weight of neutral words will be close to zero.  Such a weighting of the feature vector in most cases makes it possible to improve the classification accuracy of tonality. <br></div></div><br><br><h4>  Implementation of the classifier </h4><br>  I implemented a simple classifier for the keynote of reviews on films on python.  Data was collected from <a href="http://kinopoisk.ru/">Kinopoisk</a> .  500 positive and 500 negative reviews were selected.  As a classification algorithm, I used the <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B8%25D0%25B2%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B1%25D0%25B0%25D0%25B9%25D0%25B5%25D1%2581%25D0%25BE%25D0%25B2%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BA%25D0%25BB%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580">naive Bayes classifier</a> (NB) and <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B2%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">the support vector</a> machine (SVM) <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B2%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">method</a> .  As attributes, I tested unigrams, bigrams, and their combination, and as a weighing function: a binary function for bayes and SVM, and a delta TF-IDF for SVM.  To assess the performance of the classifier, I conducted a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BA%25D1%2580%25D1%2591%25D1%2581%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D0%25BA%25D0%25B0">cross-check</a> : for each set of parameters 5 tests were run in a row, each of which used 800 reviews for training and 200 for testing.  Below are the results (percent accuracy) for all 9 sets of parameters. <br><table><tbody><tr><th>  <b>Signs of</b> </th><th>  <b>NB</b> </th><th>  <b>SVM</b> </th><th>  <b>SVM + delta</b> </th></tr><tr><td>  unigrams </td><td>  85.5 </td><td>  82.5 </td><td>  86.2 </td></tr><tr><td>  bigrams </td><td>  84.9 </td><td>  86.5 </td><td>  87.8 </td></tr><tr><td>  combination </td><td>  86.5 </td><td>  88.4 </td><td>  90.8 </td></tr></tbody></table><br><img src="https://habrastorage.org/storage2/f52/4b2/9f7/f524b29f715ef15dc1a33c6e6100a9c5.png"><br><br>  From the results it can be seen that for this collection the best results are shown by the support vector machine with the delta TF-IDF weighting function.  If we use the usual binary function, then both classifiers (NB and SVM) show approximately the same results.  The combination of unigrams and bigrams gives better results in all tests. <br><br>  Let's see why the delta TF-IDF gives such a gap (2.4 - 4.3%) in the results.  Choose N-grams with maximum modulo delta TF-IDF values: <br><table><tbody><tr><td>  awesome </td><td>  5.20 </td><td>  behave </td><td>  -5.02 </td></tr><tr><td>  depends </td><td>  5.08 </td><td>  for some reason </td><td>  -4.80 </td></tr><tr><td>  takes </td><td>  4.95 </td><td>  failed </td><td>  -4.80 </td></tr><tr><td>  create </td><td>  4.80 </td><td>  not about </td><td>  -4.71 </td></tr><tr><td>  works </td><td>  4.80 </td><td>  not impressed </td><td>  -4.71 </td></tr><tr><td>  carefully </td><td>  4.71 </td><td>  having sex </td><td>  -4.71 </td></tr><tr><td>  myself </td><td>  4.71 </td><td>  worse than </td><td>  -4.71 </td></tr><tr><td>  Kim </td><td>  4.62 </td><td>  but this </td><td>  -4.71 </td></tr><tr><td>  thrillers </td><td>  4.62 </td><td>  was filmed </td><td>  -4.62 </td></tr><tr><td>  for her </td><td>  4.51 </td><td>  do not look </td><td>  -4.62 </td></tr></tbody></table><br><br>  On the example of negative N-grams, it is especially noticeable that their weight reflects a negative tonality. <br><br><h4>  Practical use </h4><br>  As an example of the practical application of the tonality classifier, I have quickly implemented a tweet classifier, the scheme of which is as follows: <br><ol><li>  search Twitter for movie titles </li><li>  pass tweets through the tonality classifier </li><li>  we get positive and negative comments about movies from Twitter </li></ol><br><br>  An example of the analyzer: <br><br><pre> <code class="bash hljs">alexpak@dard:~/projects/pyrus$ src/sentiment/test.py <span class="hljs-string"><span class="hljs-string">""</span></span> 1. pos    !    / Sur la piste du Marsupilami (2012) DVDRip http://t.co/to5EuTHL 2. neg       !    (2012)! 3. pos     <span class="hljs-string"><span class="hljs-string">" !  "</span></span>   4. pos  !   .  :) 5. pos  !    - Sur la piste du Marsupilami (2012) HDRip http://t.co/UB1hwnHh 6. pos ,    .  ,   ) 7. pos   <span class="hljs-comment"><span class="hljs-comment"># 8. pos Went to the movies) watched the movie " !   ." http://t.co/EBlIsWMs 9. neg     ) 10. neg         ?!    11. pos  !    / Sur la piste du Marsupilami (2012) http://t.co/OoH3chso 12. pos  !    http://t.co/rb1BWurX 13. pos  !    http://t.co/rHorvtvu 14. pos  !    http://t.co/xNBHadIN 15. pos  !    http://t.co/33t35O35</span></span></code> </pre><br><br>  As you can see, the results are not particularly satisfactory.  The categorizer makes 2 types of errors: <br><ol><li>  Categorizes neutral tweets (movie description, news, spam) as positive / negative </li><li>  Incorrectly classifies the tonality of reviews </li></ol><br>  The first type of errors can be corrected by adding an additional classifier that will filter neutral tweets.  This is not an easy task, but quite feasible.  The second type of errors arises mainly due to the fact that tweets are very different from the collection of learning: there is slang, spelling errors, different manner of expression.  Here you have to either look for another collection for classifier training (take the same tweets, for example), or improve the set of features (for example, add smiles).  But in general, this example shows that it is quite possible to create a system for analyzing opinions on Twitter. <br><br><h4>  Conclusion </h4><br>  Creating a system for analyzing opinions is a difficult task, but quite feasible if there is data for training and a domain (topic) is predetermined.  When using machine learning, it is important to test different parameters in order to select those that work better on test data.        (NB, SVM),   (, ,  N-),   .        ,     ,    (,  ),        (,   .).         . <br><br>     ,   . <br>  <a href="https://github.com/irokez/Pyrus/tree/master/src/sentiment">Source</a> <br> <a href="http://vps11096.ovh.net:8080/"> </a> <br><br><h6> FAQ: </h6><br> <b>    !</b> <br> ‚Äî ,        <br><br> <b>       ,   ?</b> <br> ‚Äî        <br><br> <b>        ?</b> <br> ‚Äî     (     ?) </div><p>Source: <a href="https://habr.com/ru/post/149605/">https://habr.com/ru/post/149605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149595/index.html">Sberbank fired employee for posting on Twitter</a></li>
<li><a href="../149596/index.html">Overview of vulnerabilities on the Big Three sites</a></li>
<li><a href="../149597/index.html">IBM THINK - a new application about the history of progress</a></li>
<li><a href="../149598/index.html">Running Linux on a tablet with SoC Allwinner A10 on board</a></li>
<li><a href="../149603/index.html">Unity3D 3.x Get the current active window</a></li>
<li><a href="../149606/index.html">Bart Chalkboard Generator</a></li>
<li><a href="../149607/index.html">Java computer vision for Android. BoofCV Library Overview</a></li>
<li><a href="../149608/index.html">Work and travel - stupid, useless, humiliating?</a></li>
<li><a href="../149610/index.html">What should Android apps look like?</a></li>
<li><a href="../149612/index.html">CPython vs. IronPython: MD5 Hash Calculation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>