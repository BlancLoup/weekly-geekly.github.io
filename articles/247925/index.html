<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Herringbone, light up! Part 2: C software, work with GPIO and software PWM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Last time I wrote about how it is easy to connect our nanocomputer to something executive (Christmas tree lights, for example) and deploy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Herringbone, light up! Part 2: C software, work with GPIO and software PWM</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Last time I wrote about how it is easy to connect our nanocomputer to something executive (Christmas tree lights, for example) and deploy an environment to build C / C ++ programs for it.  Today is the second part, on how to write a C program for OpenWRT and, accordingly, Black Swift. <br><br><ol><li>  <a href="http://habrahabr.ru/company/blackswift/blog/247817/">Garland, Black Swift connection and build environment under OpenWRT in C / C ++</a> </li><li>  Control program in C and direct and fast work with GPIO </li><li>  <a href="http://habrahabr.ru/company/blackswift/blog/248037/">Web interface and application for Android</a> </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will note two points.  First, I will not talk about the role of the main function and the #include directives - as I said before, now I am writing for people who are familiar with programming, but do not know which side to approach such a thing as a computer for embedded applications.  More precisely, today's text will be more likely for those already approaching - so I will focus on a couple of interesting points, such as working with logical input-output lines (GPIO) and microsecond times. <br><br><img src="https://habrastorage.org/files/990/884/6a6/9908846a68db4df99e5e5aac50d341fd.png"><br><br>  Secondly, of course, it is not necessary to write on C.  Under OpenWRT there is Perl, Python and even Node.js - with them you don‚Äôt need, obviously, no environment for building software, just fill in @ launch. <br><br><a name="habracut"></a><h2>  Quick and easy work with GPIO </h2><br><br>  We have on hand - a Christmas tree garland, controlled by four half-bridge drivers working in pairs: one pair sets the polarity of one branch of the garland, and the polarity determines the color of the glow.  Obviously, to work with this, we need pulse-width modulation, and quite specific - asymmetric, that is, during each period each polarity can be switched on for different times (the simplest case - by giving only one polarity, we get only one color of the garland) . <br><br>  This scheme prevents the use of a ready-made PWM module (there is one in OpenWRT) - it gives a symmetrical signal, that is, the maximum that can be achieved with it is to adjust the brightness of the whole garland in all colors simultaneously, without the ability to control colors independently.  Therefore, the PWM must be done by yourself. <br><br>  PWM is, at a basic level, just a quick jerking of the processor, in the simplest case, in this cycle: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) gpioSet(GPIO_NUMBER, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">100</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == i) gpioSet(GPIO_NUMBER, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><br>  The meaning, I think, is obvious: with the value ‚Äúvalue‚Äù we set the required duty cycle, which in our case is expressed in the brightness of the LED lights of the string (changing polarity and color management until we touch). <br><br>  The standard content of the gpioSet function (int gpio, int level) in Linux is GPIO jerking through the standard sysfs interface: to set output N to one, write one to the / sys / class / gpio / gpioN / value pseudo file.  Before that, you must write the N number in / sys / class / gpio / export so that gpioN is available to the user, and also the word ‚Äúout‚Äù in / sys / class / gpioN / direction to set the mode of this GPIO to ‚Äúoutput‚Äù. <br><br>  Descriptions of this procedure - thousands, here, for example, <a href="http://falsinsoft.blogspot.ru/2012/11/access-gpio-from-linux-user-space.html">one of them</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gpioSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gpio, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"/sys/class/gpio/gpio%d/value"</span></span>, gpio); fd = open(buf, O_WRONLY); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, value); write(fd, buf, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>  The method is simple, universal (it is difficult to find a language from which it is not possible to write to the file), but it is <strong>very slow</strong> .  If using it to control our garland, then as a result, pulling four legs (two pairs of half-bridges) will take so much time that the PWM frequency on the Black Swift with its 400-MHz processor will be about 100 Hz, and at a small brightness the LEDs will be clearly and it is unpleasant to flicker - there in general will begin the pass of steps. <br><br>  Fortunately, there is a better way.  Even more fortunately, it‚Äôs not that difficult, it‚Äôs simpler.  Rectilinear. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gpioSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gpio, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">0</span></span>) *(GPIO_ADDR + <span class="hljs-number"><span class="hljs-number">4</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; gpio); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *(GPIO_ADDR + <span class="hljs-number"><span class="hljs-number">3</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; gpio); }</code> </pre><br><br>  The trick is that GPIOs in the processor are controlled through registers ‚Äî all operations with them are done through them.  And the registers are displayed in normal memory.  And the usual memory is available to us directly through the usual device / dev / mem.  Accordingly, all we need is to display the necessary small piece of / dev / mem in memory (memory in memory ... well, okay) with the help of mmap, and then tug the necessary bits in this piece. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m_mfd = open(<span class="hljs-string"><span class="hljs-string">"/dev/mem"</span></span>, O_RDWR) ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; m_base_addr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)mmap(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GPIO_BLOCK, PROT_READ|PROT_WRITE, MAP_SHARED, m_mfd, GPIO_ADDR); close(m_mfd);</code> </pre><br><br>  The mapping of registers to memory is described in the datasheet per processor, in the case of the AR9331, the addresses start with GPIO_ADDR = 0x18040000 ( <a href="http://www.black-swift.com/files/AR9331.pdf">page 65</a> ).  We are also interested in the addresses at +3 and +4 to the base address - writing the unit to the bit corresponding to the GPIO number sets the GPIO to 1 at the first address, and resets to 0 at the second address (if anything, there is also a register at +2, which maybe reset, and install GPIO - you need to write either 0 or 1 to the correct bit in it).  The GPIO direction is set by the bits at the base address - 1 for the output, 0 for the input. <br><br>  Nota bene: some GPIOs are multifunctional, this is defined by a separate register - and until, for example, you turn off the UART on GPIO 9, it will not work as a regular input / output.  In addition, GPIO from 13 to 17 can not be used as inputs. <br><br>  Speed?  The twitching of four GPIOs in dual asymmetric PWM is about 4.5 kHz.  Against about 100 Hz when working with sysfs, I remind you. <br><br><h2>  PWM period adjustment with nanosleep </h2><br><br>  Obviously, we don‚Äôt need such a speed of controlling the garland - everything that is above 100 Hz is perfect for us, especially if it doesn‚Äôt ‚Äúlose‚Äù clock cycles at small brightness (and it will not work with direct work with GPIO).  It is necessary to introduce a delay.  Standardly, short delays are entered using the nanosleep (&amp; tw, NULL) function: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tw</span></span></span><span class="hljs-class">;</span></span> tw.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  tw.tv_nsec = 10000; //  while (true) { if (value &gt; 0) gpioSet(1); for (int i=0; i&lt;100; ++i) { if (value == i) gpioSet(0); nanosleep(&amp;tw, NULL); } }</span></span></code> </pre><br><br>  Theoretically, here we should get a delay of 10 ¬µs for each PWM clock, a total of 100 clock cycles - a total of 1 ms, or a PWM frequency of 1 kHz (not taking into account the overhead of pulling the leg).  Compile, run ... and get about 140-150 Hz. <br><br>  The problem is that the minimum regularly serviced nanosleep period in OpenWRT and on such a processor is about 60 Œºs.  That is, even if you pass tw.tv_nsec = 0 to the function, it will still slow down the thread for 60 ¬µs. <br><br>  Fortunately, there is a primitive, not very accurate, but working way to deal with this: calling nanosleep (NULL, NULL) takes about 3 ¬µs. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nsleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nsecs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nsecs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { nanosleep(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ts</span></span></span><span class="hljs-class">;</span></span> ts.tv_sec=nsecs / <span class="hljs-number"><span class="hljs-number">1000000000L</span></span>; ts.tv_nsec=nsecs % <span class="hljs-number"><span class="hljs-number">1000000000L</span></span>; nanosleep(&amp;ts,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nsleep0_factor=<span class="hljs-number"><span class="hljs-number">3000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nsleep1_factor=<span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _usleep(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> usecs) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usecs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value = (usecs*<span class="hljs-number"><span class="hljs-number">1000</span></span>) / nsleep0_factor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; nsleep1_factor) { nsleep((value-nsleep1_factor) * nsleep0_factor); value = value % nsleep1_factor; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; value; ++i) nsleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  As a result, having called _usleep for less than 70 ¬µs, we will call nanosleep not in a regular way, but simply scroll through the nanosleep (NULL, NULL) many times, each call of which will take 3 ¬µs.  Roughly, but we‚Äôre more precise for our purposes and not necessary (if you need high-quality PWM, you need to do it all the same in hardware or software on a system where you guarantee real-time mode - for example, hook up a normal ATTiny to Black Swift via UART). <br><br>  Well, in general, the basic building blocks are ready - we can make quite stable software PWM with a frequency of a hundred or two hertz. <br><br>  We can also recall that with this PWM we control two pairs of half-bridges, but this is already trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)gpioValuePos/brightness)) { gpioSet(gpio[<span class="hljs-number"><span class="hljs-number">2</span></span>*j], GPIO_OFF); gpioSet(gpio[<span class="hljs-number"><span class="hljs-number">2</span></span>*j+<span class="hljs-number"><span class="hljs-number">1</span></span>], GPIO_OFF); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == (<span class="hljs-number"><span class="hljs-number">100</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)gpioValueNeg/brightness)))) { gpioSet(gpio[<span class="hljs-number"><span class="hljs-number">2</span></span>*j], GPIO_OFF); gpioSet(gpio[<span class="hljs-number"><span class="hljs-number">2</span></span>*j+<span class="hljs-number"><span class="hljs-number">1</span></span>], GPIO_ON); } } _usleep(PWM_PERIOD); }</code> </pre><br><br>  Where gpioValuePos and gpioValueNeg are the values ‚Äã‚Äãof the two polarities (with the condition that their sum should not exceed 100, of course), brightness - this is what we laid beforehand on the possibility of adjusting the brightness of the whole garland at once.  Installation on two GPIOs of the same level is equivalent to disabling the garland. <br><br><h2>  Bells and whistles </h2><br><br>  What else do we need from the app controlling the garland? <br><br>  <b>First</b> , the brightness should somehow vary in time, and it is better that there are several programs.  You can make your own scripting language, I entered easier - drove a three-dimensional array into the code, inside which 6 programs are stored, in each 4 stages, in each two pairs of numbers - the initial brightness value of one polarity and the speed of its change.  Yes, both branches of the garland work synchronously for me. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prg[PROGRAMS][<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">4</span></span>] = { { {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>} }, { {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>} }, { {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>} }, { {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} }, { {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} }, { {<span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>} } };</code> </pre><br><br>  That is, for example, the first program - the brightness of the channel "+" gradually increases, then it gradually decreases, then the brightness of the channel "-" also increases and decreases.  Simply put - one color lights up and goes out, then the second lights up as well.  And in the latter all LEDs of all colors are constantly shining. <br><br>  <b>Secondly</b> , since we have a whole Black Swift here, let's make control via Wi-Fi?  And then the smartphone application, in the end, what kind of geek are you, if you even have a Christmas tree garland without your IP address?  In general, you need to make an interface to a regular web. <br><br>  Technically, the easiest way to do management is through UNIX-socket, a pseudo-file in which commands can be pushed even from PHP, even from the command line (with the socat utility). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mode_t</span></span> mask = umask(S_IXUSR | S_IXGRP | S_IXOTH); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s, s2, len; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_un</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">local</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((s = socket(AF_UNIX, SOCK_STREAM, <span class="hljs-number"><span class="hljs-number">0</span></span>)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Socket error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags = fcntl(s, F_GETFL, <span class="hljs-number"><span class="hljs-number">0</span></span>); fcntl(s, F_SETFL, flags | O_NONBLOCK); local.sun_family = AF_UNIX; <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(local.sun_path, <span class="hljs-string"><span class="hljs-string">"/tmp/treelights.sock"</span></span>); unlink(local.sun_path); len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(local.sun_path) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local.sun_family); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bind(s, (struct sockaddr *)&amp;local, len) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Socket bind failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (listen(s, <span class="hljs-number"><span class="hljs-number">5</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Socket listen failed\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } umask(mask);</code> </pre><br><br>  Everything here is actually a template, I will only explain that operations with umask at the beginning and end are needed on systems where the web server and our application work under different users.  In OpenWRT, by default this is not the case, everything is under root.  The non-blocking work of a socket is also fundamental - otherwise the very first access to it will result in everyone getting up and waiting until something falls into the socket. <br><br>  Inside our PWM we insert the processing code that falls into the socket: <br><br><pre> <code class="cpp hljs">s2 = accept(s, (struct sockaddr *)&amp;remote, &amp;t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = recv(s2, sockinput, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); sockinput[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// null-terminated string close(s2); cmd[0] = strtok(sockinput, "- \n"); cmd[1] = strtok(NULL, "- \n"); if (strcmp (cmd[0], "brightness") == 0) // set brightness { brightness = atoi(cmd[1]); // 1 is maximum, 2 is half-brightness, etc. } }</span></span></code> </pre><br><br>  The idea, I think, is understandable.  We throw in the socket "brightness 2" - we get halving the brightness of the garland.  Processing of any other commands is added in the same way. <br><br>  What else to add?  For the convenience of manual launch when debugging - let the program respond correctly to Ctrl-C and other requests to move: <br><br><pre> <code class="cpp hljs">do_exit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">act</span></span></span><span class="hljs-class">;</span></span> sigemptyset (&amp;act.sa_mask); act.sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>; act.sa_handler = SIG_IGN; sigaction (SIGHUP, &amp;act, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); act.sa_handler = cleanup; sigaction (SIGINT, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>); act.sa_handler = cleanup; sigaction (SIGTERM, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>); act.sa_handler = cleanup; sigaction (SIGKILL, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!do_exit) { <span class="hljs-comment"><span class="hljs-comment">//  -    }</span></span></code> </pre><br><br>  And add the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig)</span></span></span><span class="hljs-function"> </span></span>{ do_exit = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  Now the signal arriving from the OS with a request to interrupt will switch the do_exit variable to 1 - and the PWM cycle will end (do_exit, of course, would be nice to declare as a global variable). <br><br>  In general, that's all.  We have ready-made bricks for building asymmetrical PWM with brightness control, several work programs and web control. <br><br>  The result is here: <a href="https://github.com/olegart/treelights">https://github.com/olegart/treelights</a> , including a Makefile for OpenWRT and for the project itself (this one is no different at all from the usual Makefiles for building software under any Linux).  Video on the applications of our readers will be in the third part (although that you, the garlands have not seen, or what?). <br><br>  Of course, everything said applies to any router and nanocomputer on OpenWRT, with one caveat: for Black Swift, we assemble a core with a 1000 Hz timer against the usual 100 Hz and with preemptive multitasking enabled.  Without this - on standard cores - PWM may be slower or less stable under any load on the system. <br><br>  However, about the assembly of its firmware for OpenWRT - another time. </div><p>Source: <a href="https://habr.com/ru/post/247925/">https://habr.com/ru/post/247925/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247907/index.html">Examples of using a real-time machine (MATLAB, Simulink, Software and hardware simulator)</a></li>
<li><a href="../247911/index.html">We construct a local cryptographic TLS proxy with an electronic signature HTTP API</a></li>
<li><a href="../247915/index.html">Student schools in education</a></li>
<li><a href="../247919/index.html">Weekly play: annual report</a></li>
<li><a href="../247923/index.html">How to sell to large companies: 16 tips. Part 2</a></li>
<li><a href="../247927/index.html">That's what happens if you install the top 10 programs from Download.com</a></li>
<li><a href="../247929/index.html">Session of white magic without revealing or how I was looking for trolls in LJ</a></li>
<li><a href="../247933/index.html">Triggerable - event-oriented logic for ActiveRecord models</a></li>
<li><a href="../247935/index.html">About input [type = range], the multiple parameter and how to make everything work</a></li>
<li><a href="../247939/index.html">Customization of workflows in YouTrack. My experience tweaking YouTrack as HelpDesk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>