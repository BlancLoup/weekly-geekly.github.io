<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does Netflix streaming work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúIf you can cache everything in a very efficient way , then you can often change the rules of the game.‚Äù 
 We, software developers, often face problem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does Netflix streaming work</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  ‚ÄúIf you can cache <b>everything in a</b> <b>very efficient way</b> , then you can often change the rules of the game.‚Äù </blockquote><br>  We, software developers, often face problems that require the distribution of a certain set of data that does not correspond to the name ‚Äúbig data‚Äù.  Examples of this type of problem are as follows: <br><br><ul><li>  Product Metadata in the Online Store </li><li>  Document Metadata in the Search Engine </li><li>  Movie and TV Show Metadata </li></ul><br>  Faced with this, we usually choose one of two ways: <br><br><ul><li>  Storing this data in a centralized repository (for example, a relational database management system, a NoSQL data warehouse, or a memcached cluster) for remote user access </li><li>  Serialization (such as json, XML, etc.) and distribution to consumers who will store a local copy </li></ul><br>  The application of each of these approaches has its own problems.  Data centralization may allow your data set to grow indefinitely, however: <br><a name="habracut"></a><br><ul><li>  There are delays and bandwidth limitations when interacting with this data. </li><li>  Remote information store can not be compared in reliability with a local copy of data </li></ul><br>  On the other hand, serialization and storing a local copy of data completely in RAM can provide shorter delay times and higher access frequency, however, this approach also brings with it problems related to scaling, which become more complex as data sets increase: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  The amount of dynamic memory occupied by the data set is growing </li><li>  Receiving a data set requires loading additional bits </li><li>  Updating a dataset may require significant CPU resources or interfere with automatic memory management. </li></ul><br>  Developers often choose a hybrid approach - they cache data locally with frequent access and use it remotely - with rare data.  This approach has its own problems: <br><br><ul><li>  Managing data structures may require a significant amount of dynamic cache. </li><li>  Objects are often stored <i>for a long time</i> so that they can be distributed, and negatively affect the operation of automatic memory management. </li></ul><br>  At Netflix, we realized that such a hybrid approach often creates only the illusion of winning.  The size of the local cache is often the result of a careful search for a compromise between the delay in remote access for many records and the storage requirement (hip) when locally storing more data.  But if you can cache <i>everything in a very efficient way</i> , then you can often change the game ‚Äî and keep the entire data set in memory using a smaller hip and loading less CPU than storing only a portion of that set.  And here comes Hollow, the latest open source project from Netflix. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/2f9/910/6df2f9910ac0f51722da1e6536c7acf3.png" alt="image"></div><br><br>  <a href="http://hollow.how/">Hollow</a> is a Java library and a comprehensive set of tools for using in-memory small and medium-sized datasets that are distributed from one manufacturer to many consumers with read-only access. <br><blockquote>  ‚ÄúHollow is <b>changing the approach</b> ... Data sets for which such an opportunity could never even be considered before can now be candidates for Hollow.‚Äù </blockquote><br><h2>  Functioning </h2><br>  Hollow focuses solely on its prescribed set of problems: storing a <i>whole</i> set of read-only data in the memory of consumers.  It overcomes the effects of updating and unloading data from a partial cache. <br><br>  Due to its performance, Hollow <i>changes the approach</i> from the position of the size of the corresponding data sets to solve using RAM.  The data sets for which such a possibility could never even be considered before can now be candidates for Hollow.  For example, Hollow may be completely acceptable for data sets, which, if presented in json or XML, would require more than 100 GB. <br><br><h2>  Quick adaptation </h2><br>  Hollow doesn‚Äôt just improve performance - this package greatly enhances the team‚Äôs quick adaptation when working with tasks related to data sets. <br><br>  Using Hollow is simple right from the first step.  Hollow automatically creates a custom API based on a specific data model, so that users can intuitively interact with the data, taking advantage of the performance of the IDE code. <br><br>  But a serious gain occurs when using Hollow on an ongoing basis.  If your data resides in Hollow, then many possibilities appear.  Imagine that you can quickly go through the entire production dataset - current or from any point in the recent past, right up to the local development workstation: load it and then <i>accurately reproduce</i> certain production scenarios. <br><br>  Choosing Hollow will give you an edge on the toolkit;  Hollow comes with many off-the-shelf utilities to ensure that your data sets are understood and handled. <br><br><h2>  Resilience </h2><br>  How many reliability nines would you like to have?  Three four five?  Nine?  Being a local in-memory data storage, Hollow is not exposed to environmental problems, including network failures, disk problems, interference from neighbors in a centralized data storage, etc.  If your data producer fails or your consumer cannot connect to the data store, then you can work with outdated data - but the data will still be present, and your service will still work. <br><br>  Hollow has been refined for more than two years of continuous tough use on Netflix.  We use it to provide the important data sets needed to perform interactions in Netflix, on servers that quickly serve real-time client requests at maximum performance or close to it.  Despite the fact that Hollow expends enormous efforts to squeeze every last bit of performance out of the server hardware, great attention to detail has become part of strengthening this critical part of our infrastructure. <br><br><h2>  A source </h2><br>  Three years ago, we <a href="http://techblog.netflix.com/2013/12/announcing-zeno-netflixs-in-memory-data.html">announced Zeno</a> , our current solution in this area.  Hollow replaces Zeno, but is in many ways his spiritual successor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5b/050/b91/b5b050b91ed355a608dbe5881f215dae.gif" alt="image"></div><br>  <font color="#999999"><i>Zeno concepts regarding producer, consumer, data state, object status copies, and state changes have gone to Hollow</i></font> <br><br>  As before, the time sequence of a changing data set can be broken down into discrete <i>data states</i> , each of which is a complete copy of the data state at a specific point in time.  Hollow automatically detects a change in state ‚Äî the effort required from the user to maintain an updated state is minimal.  Hollow automatically deduplicates data to minimize the heap size of our consumer datasets. <br><br><h2>  Development </h2><br>  Hollow takes these concepts and develops them, improving almost every aspect of the solution. <br><br>  Hollow avoids using POJOs as an in-memory representation ‚Äî instead replaces them with compact, fixed-length, strongly typed data encryption.  Such encryption is intended both to minimize the amount of dynamic memory of data sets, and to reduce the fraction of the cost associated with the CPU, while providing access to data in real time.  All encrypted entries are packed into reusable memory blocks, which are located in the JVM heap to prevent an impact on the operation of automatic memory management on working servers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/a4a/b1a/6f9a4ab1a03c2ddbf86d6686ee4f5fbc.png" alt="image"></div><br>  <font color="#999999"><i>Example of <a href="http://hollow.how/advanced-topics/">location</a> in the memory of OBJECT records</i></font> <br><br>  Hollow data sets are self-contained - for a serialized blob, in order for the blob to be used by the framework, maintenance is not required from the code specific to the use case.  Additionally, Hollow is designed <a href="http://hollow.how/data-modeling/">with backward compatibility</a> , so deployment can occur less frequently. <br><blockquote>  "The ability to build <b>powerful access systems</b> , regardless of whether they were originally intended to develop a data model." </blockquote><br>  Since Hollow is completely built on RAM, the toolkit can be implemented provided that random access across the entire width of the data set can be performed without leaving the Java heap.  A lot of <a href="http://hollow.how/tooling/">off-the-shelf tools</a> are part of Hollow, and building your own tools thanks to the basic building blocks provided by the library is simple. <br><br>  The basis for using Hollow is the concept of <a href="http://hollow.how/tooling/">indexing</a> data in <a href="http://hollow.how/data-modeling/">various ways</a> .  This provides O (1) -access to the corresponding records in the data, which makes it possible to build powerful access systems regardless of whether they were originally intended for the development of the data model. <br><br><h2>  Benefits </h2><br>  The Hollow toolkit is easy to install and has intuitive controls.  You will be able to understand in your data some aspects of which you did not even suspect. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/c14/b6c/864c14b6cb848d6f496f745e43a24c80.png" alt="image"></div><br>  <font color="#999999"><i><a href="http://hollow.how/tooling/">The change tracking tool</a> allows you to track the change of certain records in time.</i></font> <br><br>  Hollow can enhance your capabilities.  If something in a record seems to be wrong, you can find out exactly what happened and when, using a simple query in the change tracking tool.  If an accident occurs and an improper data set is accidentally released, then your data set can be <a href="http://hollow.how/producer-consumer/">rolled back</a> to the one before the error, fixing production problems on their paths.  Since the transition between states occurs quickly, this action can produce results on the entire fleet of vehicles in a few seconds. <br><blockquote>  ‚ÄúIf your data resides permanently in Hollow, then <b>many possibilities</b> appear.‚Äù </blockquote><br>  Hollow proved to be an extremely useful tool on Netflix - we saw a ubiquitous decrease in server startup times and a decrease in the amount of dynamic memory occupied with constantly increasing demand for metadata.  Thanks to targeted data modeling efforts, carried out according to the results of detailed <a href="http://hollow.how/tooling/">analysis of dynamic memory usage</a> , which became possible with the advent of Hollow, we will be able to further improve performance. <br><br>  In addition to the performance gain, we see a huge performance increase related to the distribution of our catalog data.  This is due in part to the tools that Hollow has, and in part to the architecture that would have been impossible without it. <br><br><h2>  Conclusion </h2><br>  Wherever we see a problem, we see that it can be solved with Hollow.  Today, Hollow is available for worldwide use. <br><br>  Hollow is not designed to work with data sets of any size.  If there is a lot of data, then saving the entire set of data in memory is not possible.  However, with proper structure and some data modeling, this threshold can be much higher than you think. <br><br>  Documentation is available at <a href="http://hollow.how/">http://hollow.how</a> , and the code is on <a href="https://github.com/Netflix/hollow">GitHub</a> .  We recommend that you refer to the <a href="http://hollow.how/quick-start">quick start guide</a> - it only takes a few minutes to view the demo and see the work, and it takes about an hour to become familiar with the full industrial implementation of Hollow.  After that, you can connect your data model and - go ahead. <br><br>  If you started working, you can get help directly from us or from other users via <a href="https://gitter.im/Netflix/hollow">Gitter</a> or Stack Overflow, by placing the label ‚Äúhollow‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/317640/">https://habr.com/ru/post/317640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317630/index.html">I gave up PGP</a></li>
<li><a href="../317632/index.html">A few tips to automate data center monitoring. Part 1</a></li>
<li><a href="../317634/index.html">Current strength: how mobile communications changed our attitude to energy</a></li>
<li><a href="../317636/index.html">Docker, GitLab, free SSL certificates and other modern web development buns</a></li>
<li><a href="../317638/index.html">Overcoming difficulties: Gravity Defied on sed</a></li>
<li><a href="../317642/index.html">One tool for all subscriptions - newsletters, RSS, telegram feeds, social networking pages</a></li>
<li><a href="../317644/index.html">Ransomware Trojans - security theme of the year</a></li>
<li><a href="../317648/index.html">How we solved the problem of parental committees and earned a million rubles.</a></li>
<li><a href="../317650/index.html">Overclocking Swift build project in Xcode</a></li>
<li><a href="../317652/index.html">We supplement Scrum with architectural processes. Part 1. Requirements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>