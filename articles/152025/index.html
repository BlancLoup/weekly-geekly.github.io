<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My "paradigm" of working with threads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I learned to write multi-threaded applications - I read a bunch of literature and background information on this area. But between theory and pra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My "paradigm" of working with threads</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/c24/46c/79b/c2446c79bf8422f4bd618745a3076ff1.png" align="left">  When I learned to write multi-threaded applications - I read a bunch of literature and background information on this area.  But between theory and practice - a huge abyss.  I filled a bunch of cones, and still sometimes I get on the head from my own streams.  For myself, I developed a set of some rules that I try to strictly follow, and this <u>greatly</u> helps me in writing multi-threaded code. <br><br>  Since errors associated with synchronization of threads are extremely difficult to debug, the most effective way here is to prevent these very errors.  To do this, use different programming paradigms at different levels of abstraction.  The lower level of abstraction will be considered as working with synchronization objects (critical sections, mutexes, semaphores).  Upper - such programming paradigms as Futures and promises, STM (software transactional memory), exchange of asynchronous messages, etc.  The upper level of abstraction is often always based on the lower. <br><br>  In this article I will share my style of writing code at the lower level of abstraction.  Since I am a delphist, all examples will be in Delphi, but all of the following is true for other programming languages ‚Äã‚Äã(allowing you to work with synchronization objects of course) <br><a name="habracut"></a><br><h4>  Thread safe object </h4><br>  The first rule is to work only with thread safe objects between threads.  This is the most simple, logical and understandable rule.  However, even here there are some features.  The object must be entirely thread-safe, which means that all public methods (except the constructor and destructor) must be synchronized.  Constructors and destructors, in turn, should always be synchronized outside the object.  One of the mistakes in the early stages of working with threads was that I forgot about the synchronization of constructors and destructors.  And if there is no problem with the constructor (we get the pointer to the object only when the constructor has already completed), then you need to be careful with the destructor.  Synchronization of destructors is a very slippery topic, and I cannot give any instructions on how best to implement it (I'm not a genius of multi-threaded programming, but just learning;)).  I myself try to carry out such synchronization through the TThread class destructor, but this is true only for objects that exist for the whole life of the thread. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Locks </h4><br><h5>  Description </h5><br>  Another common problem is deadlocks.  Despite the fact that this is the most common problem that occurs during synchronization - there is one not obvious rule.  If the stream at a time performs no more than one synchronization, then there will be no deadlocks.  Here, under the word synchronization - I mean both the lock of the resource, and the expectation of a resource.  Thus, stopping on a mutex, closing a mutex, entering a semaphore, entering a critical section, or sending a message (SendMessage) is all in sync.  And in fact, if flow A expects a resource, and at the same time it has not blocked any resource, then nobody in turn expects it, which means there can be no interlocking. <br><br><h5>  Examples </h5><br>  Understanding and strict implementation of this condition is the key to the absence of deadlocks.  Let's look at an example of what I'm talking about.  Suppose we have some class: <br><pre><code class="delphi hljs">TMyObj = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FCS: TCriticalSection; FA: Integer; FB: Integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> A: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetA <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetA; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> B: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetB <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetB; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-comment"><span class="hljs-comment">//...  end;</span></span></code> </pre> <br>  Following the fact that we must have a thread-safe object - I implemented properties A and B through getters and setters with a critical section: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetA</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Result := FA; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetB</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Result := FB; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> FA := Value; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> FB := Value; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Suppose the DoSomething function works for us with A and B somehow like this: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := SendMessage(SomeHandle, WM_MYMESSAGE, A <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>, B <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Hey, but we‚Äôre using one critical section for A and B, an inexperienced writer will say.  And immediately "optimizes" this piece: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> Result := SendMessage(SomeHandle, WM_MYMESSAGE, FA <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>, FB <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  And it will be a mistake.  Now, if we attempt to access field A or B in the WM_MYMESSAGE handler, we will get deadlock.  This deadlock is obvious, since the amount of code is small, the data is simple.  But it becomes not trivial, when when the code is huge, a bunch of connections and dependencies appear.  According to the rule - to work with only one synchronization at a time, the above code can be ‚Äúoptimized‚Äù as follows: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMyObj</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k, n: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCS.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> k := FA <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; n := FB <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> FCS.Leave; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := SendMessage(SomeHandle, WM_MYMESSAGE, k, n); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Therefore, always, before calling a new synchronization, you need to release other synchronization objects.  Code in the spirit of: <br><pre> <code class="delphi hljs">FCS1.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//bla bla bla FCS2.Enter; try //bla bla bla finally FCS2.Leave; end; //bla bla bla finally FCS1.Leave; end;</span></span></code> </pre><br>  In most cases, it can be considered a multi-thread bydlokodom.  I think you already imagine how to rewrite it: <br><pre> <code class="delphi hljs">FCS1.Enter; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//bla bla bla //bla bla bla //  / ,       FCS2 finally FCS1.Leave; end; FCS2.Enter; try //   / //bla bla bla finally FCS2.Leave; end;</span></span></code> </pre><br>  This approach shows that we have to copy data, which may affect performance.  However, in most cases the data volumes are not large, and we can allow them to be copied.  Think four <s>times</s> four times to apply the approach without copying. <br><br><h5>  Diagnostics </h5><br>  At the compilation level, such a diagnosis will not work.  However, you can diagnose in realtime.  To do this, we need to store the current synchronization object for each stream.  Here is an example implementation of a diagnostic tool in Delphi. <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSyncObject</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushSyncObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle: Cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushSyncObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopSyncObject</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">threadvar</span></span> syncobj: Cardinal; synccnt: Cardinal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSyncObject</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> syncobj := <span class="hljs-number"><span class="hljs-number">0</span></span>; synccnt := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushSyncObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle: Cardinal)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> handle = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EProgrammerNotFound.Create(<span class="hljs-string"><span class="hljs-string">'   '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syncobj &lt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (handle &lt;&gt; syncobj) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EProgrammerNotFound.Create(<span class="hljs-string"><span class="hljs-string">'       '</span></span>); syncobj := handle; inc(synccnt); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushSyncObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> PushSyncObject(Cardinal(obj)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopSyncObject</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syncobj = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (synccnt = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EProgrammerNotFound.Create(<span class="hljs-string"><span class="hljs-string">'   '</span></span>); Dec(synccnt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> synccnt = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> syncobj := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Call InitSyncObject when we start a new thread. <br>  Before capturing the synchronization object, we call PushThreadObject, after releasing the synchronization object, we call PopThreadObject. <br>  For ease of use of these functions, I recommend copying the code of the SyncObjs.pas module into a new one, say SyncObjsDbg.pas.  It has the base class of the synchronization object: <br><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TSynchroObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Acquire</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In Acquire add call PushSyncObject (Self), and in Release PopSyncObject.  Also, do not forget to frame the WaitFor methods of THandleObject into these functions.  In addition, if we use the TThread.Synchronize method, we save the TThread object before the call, and then retrieve it (PopSyncObject), if we use the SendMessage API or the WaitFor function API, we save the handle (PushSyncObject) before the call, then we retrieve (PopSyncObject). <br>  That's all, now when you try to capture the second synchronization object, an exception will be raised, and the modules (SyncObjs / SyncObjsDbg) can be changed through defines. <br><br><h5>  Bad code </h5><br>  As an example of bad code, let's take ... the TThreadList class from the Classes.pas module <br><pre> <code class="delphi hljs"> TThreadList = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FList: TList; FLock: TRTLCriticalSection; FDuplicates: TDuplicates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LockList</span></span></span><span class="hljs-function">:</span></span> TList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: Pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Item: Pointer; Direction: TList.TDirection)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnlockList</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Duplicates: TDuplicates <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FDuplicates <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FDuplicates; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  It would seem that a thread-safe class, with access through a critical section, what's wrong with it?  And the bad thing is that the LockList and UnlockList methods are available.  If we have synchronization between the pair of calls of LockList and UnlockList, then we break the above rule.  Therefore, making a couple of Lock / Unlock functions in public is not good, and such functions should be used extremely carefully. <br><br>  By the way, various APIs from Microsoft often return Enum interfaces, <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd389527(v%3Dvs.85).aspx">for example</a> .  Why are they doing that?  After all, it is much more convenient to get the quantity, say, through the Count function, and then in the loop, through the GetItem function, by index get the item.  But in this case, they would have to endure a couple more Lock / Unlock functions so that no one could change the list while you are in the loop.  In addition, if you suddenly call an API function between Lock / Unlock that performs internal synchronization, you can easily get deadlock.  Therefore, everything is done through Enum interfaces.  Upon receipt of such an interface, a list of objects is formed, and their reference count increases.  This means that no objects in the Enum interface will be destroyed until at least the enum interface exists, and while you are working with Enum, everyone has access to the internal list, and this list can even be changed. <br><br><h4>  Probably enough </h4><br>  I pressed the preview button, I saw the resulting volume, and I realized that for now it would be enough.  In the next article I would like to tell you about the TThread class delphi, and show the rules that I follow when creating and working with threads. </div><p>Source: <a href="https://habr.com/ru/post/152025/">https://habr.com/ru/post/152025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152016/index.html">When a project has more than one founder</a></li>
<li><a href="../152018/index.html">Yandex is 15 years old!</a></li>
<li><a href="../152022/index.html">10 Windows Phone Applications for Administrators</a></li>
<li><a href="../152023/index.html">The Japanese have developed a new type of fuel hydrogen cells</a></li>
<li><a href="../152024/index.html">Centralized logging from network equipment consoles via ssh</a></li>
<li><a href="../152028/index.html">7,100 employees work on the Google Maps project.</a></li>
<li><a href="../152030/index.html">IPhone 5 Review - Habrahabr Edition</a></li>
<li><a href="../152031/index.html">A small review of the large computer Acer Predator</a></li>
<li><a href="../152034/index.html">IR remote for PC and sockets. Part 2</a></li>
<li><a href="../152035/index.html">Programmers playing economics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>