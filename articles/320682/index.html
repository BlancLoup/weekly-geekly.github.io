<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nested logical expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. In this article I will tell you how to be very confused. How a few thoughts can seize the head for years, and even affect life. I'll tell you how...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nested logical expressions</h1><div class="post__text post__text-html js-mediator-article">  Hey.  In this article I will tell you how to be very confused.  How a few thoughts can seize the head for years, and even affect life.  I'll tell you how to add and multiply numbers, how to calculate md5, and maybe look for numbers from Euler's hypothesis. <br><a name="habracut"></a><br>  We will perform all operations in logical bits, but we will not calculate them.  We will operate only on logical variables, trembling from computational complexity and anticipating endless waiting.  In this world you feel helpless when you hardly manage to multiply a couple of ten-bit numbers. <br><br><h3>  Chapter 1. Addition </h3><br>  So let's go.  Let's start with the addition.  We represent numbers as a sequence of bits. <br><br><math> </math> $ inline $ {a0, a1, a2, a3 ...}, $ inline $ <br><math> </math> $ inline $ {b0, b1, b2, b3 ...}, $ inline $ <br><math> </math> $ inline $ {x0, x1, x2, x3 ...}, $ inline $ <br>  Where <math> </math> $ inline $ a0, b0 $ inline $   - low bits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under variable <math> </math> $ inline $ x $ inline $   I mean the result of operations. <br><br>  Let's try to add these numbers.  What will be the zero bit of the sum?  If bits <math> </math> $ inline $ a0 $ inline $   and <math> </math> $ inline $ b0 $ inline $   are equal then <math> </math> $ inline $ x0 $ inline $   will be zero, and 1 otherwise, that is <math> </math> $ inline $ x0 = a0 \ XOR \ b0 $ inline $   .  Further, the logical operators will be written easier to save precious Internet space like this: <math> </math> $ inline $ AND \ equiv $ inline $   *, <math> </math> $ inline $ OR \ equiv $ inline $   +. <br><br>  Now the first bit.  It will depend on the zero bit, if both zero bits are equal to one, then the bit will be added to the first one.  Let's call this component the carry bit.  So we have three components that affect the first bit.  it <math> </math> $ inline $ a1, b1 $ inline $   and <math> </math> $ inline $ (a0 * b0) $ inline $   . <br><br>  The first bit will be equal to one if one of these components is equal to one, or all three.  This is written like this: <br><br><math> </math> $ inline $ a1 * b1 * (a0 * b0) +! a1 * b1 * (a0 * b0) + a1 *! b1 * (a0 * b0) + a1 * b1 *! (a0 * b0) $ inline $   . <br><br>  Horror.  I'm not even sure that I recorded it right now. <br><br>  I have introduced ternary surgery for convenience. <math> </math> $ inline $ XOR3 $ inline $   - it gives a unit when an odd number of arguments equals one. <br><br>  Next, the second bit.  With him everything is the same - it depends on three components: <math> </math> $ inline $ a2, b2 $ inline $   , and carry bits from the first bit.  Now the carry bit of the first bit depends on three components: <math> </math> $ inline $ a1, b1 $ inline $   , and the previous carry bit.  If two of these three components are equal to one, then the carry bit will also be equal to one.  This ternary function is called <math> </math> $ inline $ AND3 $ inline $   : it gives one if two of the three bits are one.  The formula is simpler: <math> </math> $ inline $ AND3 (a, b, c) = (a * b) + (a * c) + (b * c). $ inline $ <br><br>  Well, the next bits will be determined in the same way as the second bit.  In a loop, it looks like this: count the carry bit <math> </math> $ inline $ p (i-1) $ inline $   and count the result bit <math> </math> $ inline $ x (i) $ inline $ <br><br><math> </math> $ inline $ p2 = AND3 (a2, b2, p1) $ inline $ <br><math> </math> $ inline $ x3 = XOR3 (a3, b3, p2) $ inline $ <br><math> </math> $ inline $ p3 = AND3 (a3, b3, p2) $ inline $ <br>  ... <br><br>  Here, we learned how to add numbers. <br><br><div class="spoiler">  <b class="spoiler_title">Here is the sum of 5-bit numbers.</b> <div class="spoiler_text">  ------------ BIT 0 ----------------- <br>  ! a0 * b0 OR <br>  a0 *! b0 <br><br>  ------------ BIT 1 ----------------- <br>  a0 * a1 * b0 * b1 OR <br>  ! a1 *! b0 * b1 OR <br>  ! a0 *! a1 * b1 OR <br>  a0 *! a1 * b0 *! b1 OR <br>  a1 *! b0 *! b1 OR <br>  ! a0 * a1 *! b1 <br><br>  ------------ BIT 2 ----------------- <br>  a0 * a2 * b0 * b1 * b2 OR <br>  ! a1 * a2 *! b0 *! b2 OR <br>  ! a0 *! a1 *! a2 * b2 OR <br>  ! a2 *! b0 *! b1 * b2 OR <br>  ! a0 *! a2 *! b1 * b2 OR <br>  ! a0 *! a1 * a2 *! b2 OR <br>  a0 * a1 * a2 * b0 * b2 OR <br>  a1 * a2 * b1 * b2 OR <br>  a2 *! b0 *! b1 *! b2 OR <br>  ! a0 * a2 *! b1 *! b2 OR <br>  a0 * a1 *! a2 * b0 *! b2 OR <br>  ! a1 *! a2 *! b1 * b2 OR <br>  ! a1 *! a2 *! b0 * b2 OR <br>  ! a1 * a2 *! b1 *! b2 OR <br>  a0 *! a2 * b0 * b1 *! b2 OR <br>  a1 *! a2 * b1 *! b2 <br><br>  ------------ BIT 3 ----------------- <br>  a2 * a3 * b2 * b3 OR <br>  a2 *! a3 * b2 *! b3 OR <br>  a3 *! b0 *! b1 *! b2 *! b3 OR <br>  ! a1 *! a2 *! a3 *! b0 * b3 OR <br>  a0 * a1 * a2 *! a3 * b0 *! b3 OR <br>  ! a3 *! b0 *! b1 *! b2 * b3 OR <br>  ! a0 *! a2 *! a3 *! b1 * b3 OR <br>  a1 * a3 * b1 * b2 * b3 OR <br>  a0 * a2 * a3 * b0 * b1 * b3 OR <br>  ! a0 *! a1 *! a3 *! b2 * b3 OR <br>  ! a0 *! a3 *! b1 *! b2 * b3 OR <br>  ! a0 *! a1 * a3 *! b2 *! b3 OR <br>  ! a2 *! a3 *! b0 *! b1 * b3 OR <br>  a0 * a1 * a3 * b0 * b2 * b3 OR <br>  a0 * a1 * a2 * a3 * b0 * b3 OR <br>  a0 * a2 *! a3 * b0 * b1 *! b3 OR <br>  ! a1 *! a3 *! b1 *! b2 * b3 OR <br>  ! a0 * a3 *! b1 *! b2 *! b3 OR <br>  ! a2 * a3 *! b0 *! b1 *! b3 OR <br>  ! a2 *! a3 *! b2 * b3 OR <br>  ! a1 * a3 *! b0 *! b2 *! b3 OR <br>  a0 *! a3 * b0 * b1 * b2 *! b3 OR <br>  ! a0 *! a1 *! a2 * a3 *! b3 OR <br>  ! a0 *! a2 * a3 *! b1 *! b3 OR <br>  ! a1 *! a2 *! a3 *! b1 * b3 OR <br>  ! a0 *! a1 *! a2 *! a3 * b3 OR <br>  ! a2 * a3 *! b2 *! b3 OR <br>  a0 * a1 *! a3 * b0 * b2 *! b3 OR <br>  a1 *! a3 * b1 * b2 *! b3 OR <br>  a1 * a2 *! a3 * b1 *! b3 OR <br>  a0 * a3 * b0 * b1 * b2 * b3 OR <br>  ! a1 *! a2 * a3 *! b0 *! b3 OR <br>  ! a1 *! a3 *! b0 *! b2 * b3 OR <br>  ! a1 * a3 *! b1 *! b2 *! b3 OR <br>  a1 * a2 * a3 * b1 * b3 OR <br>  ! a1 *! a2 * a3 *! b1 *! b3 <br><br>  ------------ BIT 4 ----------------- <br>  ! a0 *! a2 *! a3 * a4 *! b1 *! b4 OR <br>  ! a0 *! a3 * a4 *! b1 *! b2 *! b4 OR <br>  a3 *! a4 * b3 *! b4 OR <br>  a3 * a4 * b3 * b4 OR <br>  ! a0 *! a1 *! a3 * a4 *! b2 *! b4 OR <br>  a0 * a2 *! a4 * b0 * b1 * b3 *! b4 OR <br>  ! a2 *! a3 *! a4 *! b2 * b4 OR <br>  a4 *! b0 *! b1 *! b2 *! b3 *! b4 OR <br>  a0 * a1 * a2 * a3 * a4 * b0 * b4 OR <br>  ! a2 *! a4 *! b2 *! b3 * b4 OR <br>  ! a1 *! a2 *! a4 *! b1 *! b3 * b4 OR <br>  ! a1 * a4 *! b1 *! b2 *! b3 *! b4 OR <br>  ! a1 *! a3 *! a4 *! b0 *! b2 * b4 OR <br>  a0 * a1 * a2 * a3 *! a4 * b0 *! b4 OR <br>  ! a1 *! a2 *! a3 *! a4 *! b0 * b4 OR <br>  a1 * a3 * a4 * b1 * b2 * b4 OR <br>  a2 * a4 * b2 * b3 * b4 OR <br>  a0 *! a4 * b0 * b1 * b2 * b3 *! b4 OR <br>  ! a2 * a4 *! b0 *! b1 *! b3 *! b4 OR <br>  a0 * a4 * b0 * b1 * b2 * b3 * b4 OR <br>  ! a0 *! a1 *! a3 *! a4 *! b2 * b4 OR <br>  a0 * a1 * a3 *! a4 * b0 * b2 *! b4 OR <br>  a1 * a2 * a3 * a4 * b1 * b4 OR <br>  a1 * a2 *! a4 * b1 * b3 *! b4 OR <br>  a0 * a2 * a3 * a4 * b0 * b1 * b4 OR <br>  a2 *! a4 * b2 * b3 *! b4 OR <br>  a0 * a1 * a2 *! a4 * b0 * b3 *! b4 OR <br>  ! a0 *! a4 *! b1 *! b2 *! b3 * b4 OR <br>  ! a1 *! a2 *! a3 * a4 *! b0 *! b4 OR <br>  ! a0 *! a1 * a4 *! b2 *! b3 *! b4 OR <br>  ! a0 *! a1 *! a2 *! a3 * a4 *! b4 OR <br>  a0 * a1 *! a4 * b0 * b2 * b3 *! b4 OR <br>  a1 * a2 * a3 *! a4 * b1 *! b4 OR <br>  a1 * a2 * a4 * b1 * b3 * b4 OR <br>  ! a1 *! a2 *! a3 *! a4 *! b1 * b4 OR <br>  ! a4 *! b0 *! b1 *! b2 *! b3 * b4 OR <br>  a1 * a3 *! a4 * b1 * b2 *! b4 OR <br>  a0 * a1 * a3 * a4 * b0 * b2 * b4 OR <br>  ! a2 *! a3 *! a4 *! b0 *! b1 * b4 OR <br>  ! a1 *! a2 * a4 *! b0 *! b3 *! b4 OR <br>  ! a0 *! a1 *! a2 *! a4 *! b3 * b4 OR <br>  ! a0 *! a1 *! a2 * a4 *! b3 *! b4 OR <br>  a2 * a3 * a4 * b2 * b4 OR <br>  ! a1 *! a3 * a4 *! b1 *! b2 *! b4 OR <br>  ! a3 *! a4 *! b3 * b4 OR <br>  a0 * a1 * a4 * b0 * b2 * b3 * b4 OR <br>  ! a1 *! a4 *! b1 *! b2 *! b3 * b4 OR <br>  ! a0 *! a3 *! a4 *! b1 *! b2 * b4 OR <br>  ! a1 *! a3 *! a4 *! b1 *! b2 * b4 OR <br>  a2 * a3 *! a4 * b2 *! b4 OR <br>  ! a2 *! a3 * a4 *! b2 *! b4 OR <br>  a0 * a3 *! a4 * b0 * b1 * b2 *! b4 OR <br>  a1 *! a4 * b1 * b2 * b3 *! b4 OR <br>  a0 * a3 * a4 * b0 * b1 * b2 * b4 OR <br>  ! a2 *! a3 * a4 *! b0 *! b1 *! b4 OR <br>  ! a1 * a4 *! b0 *! b2 *! b3 *! b4 OR <br>  ! a1 *! a2 *! a3 * a4 *! b1 *! b4 OR <br>  ! a3 * a4 *! b0 *! b1 *! b2 *! b4 OR <br>  ! a1 *! a3 * a4 *! b0 *! b2 *! b4 OR <br>  ! a3 *! a4 *! b0 *! b1 *! b2 * b4 OR <br>  ! a0 * a4 *! b1 *! b2 *! b3 *! b4 OR <br>  a1 * a4 * b1 * b2 * b3 * b4 OR <br>  ! a0 *! a2 * a4 *! b1 *! b3 *! b4 OR <br>  ! a0 *! a1 *! a4 *! b2 *! b3 * b4 OR <br>  ! a0 *! a1 *! a2 *! a3 *! a4 * b4 OR <br>  ! a1 *! a2 *! a4 *! b0 *! b3 * b4 OR <br>  ! a2 * a4 *! b2 *! b3 *! b4 OR <br>  ! a0 *! a2 *! a4 *! b1 *! b3 * b4 OR <br>  ! a2 *! a4 *! b0 *! b1 *! b3 * b4 OR <br>  a0 * a2 * a4 * b0 * b1 * b3 * b4 OR <br>  ! a0 *! a2 *! a3 *! a4 *! b1 * b4 OR <br>  ! a3 * a4 *! b3 *! b4 OR <br>  ! a1 *! a4 *! b0 *! b2 *! b3 * b4 OR <br>  a0 * a2 * a3 *! a4 * b0 * b1 *! b4 OR <br>  ! a1 *! a2 * a4 *! b1 *! b3 *! b4 OR <br>  a0 * a1 * a2 * a4 * b0 * b3 * b4 <br><br>  ------------ BIT 5 ----------------- <br>  a0 * a1 * a4 * b0 * b2 * b3 OR <br>  a2 * a3 * b2 * b4 OR <br>  a1 * a2 * a3 * a4 * b1 OR <br>  a2 * b2 * b3 * b4 OR <br>  a0 * a1 * a3 * a4 * b0 * b2 OR <br>  a0 * a4 * b0 * b1 * b2 * b3 OR <br>  a1 * a4 * b1 * b2 * b3 OR <br>  a0 * a2 * b0 * b1 * b3 * b4 OR <br>  a1 * a3 * b1 * b2 * b4 OR <br>  a2 * a4 * b2 * b3 OR <br>  a0 * a1 * a2 * b0 * b3 * b4 OR <br>  a0 * b0 * b1 * b2 * b3 * b4 OR <br>  a0 * a1 * a3 * b0 * b2 * b4 OR <br>  a0 * a1 * b0 * b2 * b3 * b4 OR <br>  a1 * a2 * a3 * b1 * b4 OR <br>  a4 * b4 OR <br>  a2 * a3 * a4 * b2 OR <br>  a0 * a1 * a2 * a3 * b0 * b4 OR <br>  a1 * a2 * b1 * b3 * b4 OR <br>  a1 * a2 * a4 * b1 * b3 OR <br>  a3 * a4 * b3 OR <br>  a0 * a1 * a2 * a3 * a4 * b0 OR <br>  a1 * b1 * b2 * b3 * b4 OR <br>  a1 * a3 * a4 * b1 * b2 OR <br>  a0 * a3 * a4 * b0 * b1 * b2 OR <br>  a0 * a2 * a3 * b0 * b1 * b4 OR <br>  a0 * a3 * b0 * b1 * b2 * b4 OR <br>  a0 * a2 * a3 * a4 * b0 * b1 OR <br>  a0 * a1 * a2 * a4 * b0 * b3 OR <br>  a3 * b3 * b4 OR <br>  a0 * a2 * a4 * b0 * b1 * b3 <br></div></div><br>  Yes, now this number has one bit more: the sum of the numbers can give one new bit. <br><br><div class="spoiler">  <b class="spoiler_title">But so many members in each bit of the amount</b> <div class="spoiler_text">  In the bit 0: 2 <br>  In bit 1: 6 <br>  In bit 2: 16 <br>  In bit 3: 36 <br>  In bit 4: 76 <br>  At bit 5: 156 <br>  At bit 6: 316 <br>  At bit 7: 636 <br>  At bit 8: 1276 <br>  At bit 9: 2556 <br>  At bit 10: 1023 </div></div><br>  As a member, I mean the term after casting the expression into a disjunctive normal form (we used the same terms), to put it simply, after reducing it to the form as the sum of five bits is written above. <br><br><h3>  Chapter 2. Multiplication </h3><br>  Chapter Two, multiplication.  We learned how to fold, so we can multiply!  Yes, a column, as taught in school, only on binary numbers.  In the loop, it will look like this: to the first operand we add the second operand shifted bitwise by <math> </math> $ inline $ i $ inline $   bit, and multiplied in each bit by <math> </math> $ inline $ i $ inline $   bit of the first operand.  Apparently the pseudocode will look clearer: <br><br><pre><code class="hljs pgsql">var big, small //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; small.bits.size(); i++ ) { var big_tmp = big; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; big.bits.size(); j++) { big_tmp.bits[j] = big.bits[j] * small.bits[i]; } result = (result + big_tmp.operator_SHIFT_LEFT(i)); }</code> </pre> <br>  When multiplying numbers of length m and n bits, you get a number of length m + n bits. <br><br>  Simplifying the result of multiplication takes a lot of resources, and looks very polynomial, here is the product of three-bit numbers: <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text">  ------------ BIT 0 ----------------- <br>  a0 * b0 <br><br>  ------------ BIT 1 ----------------- <br>  a1 * b0 *! b1 OR <br>  ! a0 * a1 * b0 OR <br>  a0 *! b0 * b1 OR <br>  a0 *! a1 * b1 <br><br>  ------------ BIT 2 ----------------- <br>  ! a0 *! a1 * a2 * b0 OR <br>  a0 *! b0 *! b1 * b2 OR <br>  a0 *! a1 *! b0 * b2 OR <br>  a0 * a1 * a2 * b0 * b1 *! b2 OR <br>  a0 *! a2 *! b1 * b2 OR <br>  ! a0 * a1 *! a2 * b1 OR <br>  a0 *! a2 * b0 * b2 OR <br>  a0 *! a1 *! a2 * b2 OR <br>  a2 * b0 *! b1 *! b2 OR <br>  a1 *! b0 * b1 *! b2 OR <br>  ! a1 * a2 * b0 *! b2 OR <br>  ! a0 * a2 * b0 *! b1 OR <br>  ! a0 * a1 *! b0 * b1 <br><br>  ------------ BIT 3 ----------------- <br>  ! a0 * a1 * b0 * b2 OR <br>  a0 * a1 * a2 *! b0 * b1 * b2 OR <br>  ! a1 * a2 * b1 *! b2 OR <br>  a2 *! b0 * b1 *! b2 OR <br>  a0 *! a1 * a2 * b0 *! b1 * b2 OR <br>  ! a0 * a1 *! a2 * b2 OR <br>  a1 *! b0 *! b1 * b2 OR <br>  ! a0 *! a1 * a2 * b1 OR <br>  a1 *! a2 *! b1 * b2 OR <br>  a0 * a1 *! a2 * b0 * b1 *! b2 OR <br>  ! a1 * a2 *! b0 * b1 OR <br>  ! a0 * a1 *! b1 * b2 <br><br>  ------------ BIT 4 ----------------- <br>  ! a0 *! a1 * a2 * b2 OR <br>  ! a1 * a2 *! b1 * b2 OR <br>  a0 * a1 * a2 * b0 * b1 * b2 OR <br>  a2 *! b0 *! b1 * b2 OR <br>  ! a1 * a2 *! b0 * b2 OR <br>  a0 * a1 *! a2 *! b0 * b1 * b2 OR <br>  ! a0 * a2 *! b1 * b2 OR <br>  a1 * a2 * b0 * b1 *! b2 OR <br>  a0 * a1 *! a2 * b0 * b1 * b2 <br><br>  ------------ BIT 5 ----------------- <br>  a0 * a1 * a2 * b0 *! b1 * b2 OR <br>  a1 * a2 *! b0 * b1 * b2 OR <br>  a1 * a2 * b0 * b1 * b2 OR <br>  a0 *! a1 * a2 * b0 * b1 * b2 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">But how many members in 6x6 work bits</b> <div class="spoiler_text">  In the bit 0: 1 <br>  In bit 1: 4 <br>  In bit 2: 13 <br>  At bit 3: 41 <br>  In bit 4: 168 <br>  At bit 5: 656 <br>  At bit 6: 791 <br>  At bit 7: 778 <br>  At bit 8: 606 <br>  At bit 9: 402 <br>  At bit 10: 240 <br>  At bit 11: 135 <br></div></div><br>  But this is only one of the options for simplifying the cumbersome multi-storey expression from multiplication.  You may have other values ‚Äã‚Äãfor the higher bits, it all depends how much you can simplify the logical expression. <br><br>  So, we can add and multiply.  We can without special computational costs get a recursive formula, according to which the sum, or product, or some other compound operation on numbers is considered.  But, as it turned out, we cannot in a reasonable time simplify this expression for numbers even more than 10 bits.  I hardly managed to simplify the expression for the 8x8 product. <br><br>  At this stage, I ran into one of the first problems.  Is it possible, looking at the simplified works of small orders, to find some kind of dependence, and learn how to build such a formula? <br><br>  As a result, both addition and multiplication should have symmetry with respect to a and b, it can be seen with the naked eye on the lower bits, and in order to see it on the upper bits you need to arm it. <br><br>  So, is it possible to build a formula for the higher bits of addition / multiplication, looking at the lower bits?  I did not succeed, maybe you will? <br><br>  But there is a downside: the simplified expression will definitely take up a lot of space, so it simply does not make sense to simplify the product of two 1024-bit numbers.  But everyone is interested in multiplying 1024-bit (especially simple) numbers, isn't it?  We'll have to learn how to work with nested logical expressions. <br><br>  It was not difficult to write a little code that operates with logical expressions given in a disjunctive normal form, including nested ones.  Well, I had to quit drinking, learn how to program, quit my job, in general, little things. <br><br><h3>  Chapter Three, the most interesting </h3><br>  Take for example md5.  64 boring roughly identical rounds.  In the calculations, only the usual logical operators and the sum described above are used.  Only bits older than 32 are discarded.  Well, ready, we can calculate md5 using nested bit formulas. <br><br>  It looks like this. <br><br>  At the input of md5, we give for example 128 logical variables.  Nested variables I call the variable t, and begin to number the numbers after the main ones.  In this case, the main variables (those that are input to the md5 function) from <math> </math> $ inline $ x0 $ inline $   before <math> </math> $ inline $ x127 $ inline $   , and nested ones start from <math> </math> $ inline $ t128 $ inline $   .  Then the first bit of the result will be approximately the same (it all depends on which moments of the algorithm you will convolve into t-variable). <br><br><div class="spoiler">  <b class="spoiler_title">Like this</b> <div class="spoiler_text">  md5 [0] = <br>  t67168 * t70255 OR <br>  t67167 * t70255 OR <br>  t67163 * t67169 * t70255 OR <br>  ! t65928 *! t65929 *! t65930 * t65936 * t67155 * t67169 * t70255 OR <br>  t65929 * t65937 * t67155 * t67169 * t70255 OR <br>  ! t65928 *! t65929 *! t65930 * t65938 * t67155 * t67169 * t70255 OR <br>  t65928 * t65937 * t67155 * t67169 * t70255 OR <br>  t65929 * t65939 * t67155 * t67169 * t70255 OR <br>  t65928 * t65939 * t67155 * t67169 * t70255 OR <br>  t67162 * t67169 * t70255 OR <br>  t67166 * t70255 OR <br>  t65937 * t65930 * t67155 * t67169 * t70255 OR <br>  t65930 * t65939 * t67155 * t67169 * t70255 <br></div></div><br>  where each t-variable is a different expression. <br><br><div class="spoiler">  <b class="spoiler_title">And at the end of the chain something like this</b> <div class="spoiler_text">  t219 = <br>  ! x6 * t139 * t217 OR <br>  ! x6 * t140 * t217 OR <br>  t211 *! t135 * t217 OR <br>  ! x6 * t211 * t217 OR <br>  ! x10 * t139 * t217 OR <br>  ! x10 * t211 * t217 OR <br>  ! x8 * t211 * t217 OR <br>  ! x8 * t139 * t217 OR <br>  ! x9 * t140 * t217 OR <br>  ! x8 * t140 * t217 OR <br>  ! x9 * t139 * t217 OR <br>  ! x10 * t140 * t217 OR <br>  ! t135 * t140 * t217 OR <br>  ! x9 * t211 * t217 OR <br>  ! t135 * t139 * t217 <br>  ... <br>  t128 = <br>  x0 OR <br>  x5 OR <br>  x6 OR <br>  x4 OR <br>  x8 OR <br>  x7 OR <br>  x9 OR <br>  x3 OR <br>  x10 OR <br>  x2 OR <br>  x1 <br></div></div><br>  As you understand, the complexity of the md5 function from 128 bits is approximately 70000. That is, as a result, we get ~ 70000 t-variables.  As it turned out, if we apply 15, 256, 347, or 512 variables to the input, then the nesting (that is, the number of t-variables) will be about the same.  Here it is necessary to make an important reservation.  The operation of creating a t-variable during the evaluation of logical expressions is applied after logical operators <math> </math> $ inline $ AND $ inline $   and <math> </math> $ inline $ AND3 $ inline $   after <math> </math> $ inline $ OR $ inline $   and <math> </math> $ inline $ XOR3 $ inline $   simplification is performed, I have it like this, therefore, such a result. <br><br>  So, the nested complexity of md5 is 70K.  For each bit, we will call the resulting formula in t-variables a logical representation variable. <br><br>  And now.  Now we do the following.  Take any hash, and present it in the form of bits.  Where the hash bit is 0, we take the corresponding logical representation variable, where 1 is inverted (operator <math> </math> $ inline $ NOT $ inline $   ).  And we add them to the operator <math> </math> $ inline $ OR $ inline $   .  As a result, we get a new nested logical expression, and equate it to <math> </math> $ inline $ FALSE $ inline $   . <br><br>  What does this expression mean?  And it describes all possible solutions for a given hash.  And if to simplify, substituting t-variables, then the solutions will be in full view.  That's just to simplify it will not work.  At this stage, I had to buy a quality grip rolling machine. <br><br>  Well, okay, we can‚Äôt simplify, but maybe at least a corner of the eye can look at at least one possible solution ... Indeed, why should we all, we should have at least one ... And here the most interesting part begins.  We have a logical formula that is <math> </math> $ inline $ FALSE $ inline $   .  This means that if at some simplification stage a member becomes simpler in <math> </math> $ inline $ TRUE $ inline $   , the hash has no solutions.  Starting to simplify the expression, you can see how many members self-destruct, turning into <math> </math> $ inline $ FALSE $ inline $   .  That is, after substituting a t-variable, you get something like <math> </math> $ inline $ t67234 \ * \! t67234 * ... $ inline $   That is, if we knew in advance which member is identically equal <math> </math> $ inline $ FALSE $ inline $   , we would be able to avoid computationally hell on the substitution of t-variables in such terms. <br><br>  So solemnly declare.  The task of solving a nested logical expression in terms of computational hell is reduced to the definition of terms that are identically equal <math> </math> $ inline $ FALSE $ inline $   .  That's all.  If you do this, you can guess what will happen.  Some cryptographic algorithms will turn into a pumpkin.  The nested complexity of multiplying two 256-bit numbers is about 500K, 512-bit numbers are 2M, 1024 is 8M, and so on.  Yes, the multiplication of numbers turns into the same nested construction, only the complexity is more. <br><br>  At this stage, I pretty much patted my jerking machine.  I tried out a few ideas, but ... all to no avail.  There are no signs yet that can somehow identify false members.  Maybe I tried a little.  And think for it, it was already somewhere nearby, but I did not find it, did not reach it, that would be a shame ... But perhaps this is my karma - to go half the way.  Something like that. <br><br><h4>  PS </h4><br>  A small afterword about what it is and what is the point.  I will honestly say, I have no idea whether all of the above has any scientific meaning, or practical use, or something else.  I de facto do not have a classical education, and I do all this based on my considerations, influx, and attitude. <br><br>  Mazai Banzayev. </div><p>Source: <a href="https://habr.com/ru/post/320682/">https://habr.com/ru/post/320682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320670/index.html">PHP 7.1.1 FPM vs Node.js 7.4.0 as a web backend server</a></li>
<li><a href="../320672/index.html">Intellectual system ELIS</a></li>
<li><a href="../320674/index.html">Automatic visualization of the python code. Part Two: Implementation</a></li>
<li><a href="../320676/index.html">Dagger 2. Part Three. New facets of the possible</a></li>
<li><a href="../320678/index.html">Correct problem detection with Zabbix</a></li>
<li><a href="../320684/index.html">A little about Swift runtime or where NSObject disappeared</a></li>
<li><a href="../320686/index.html">The practice of metaprogramming in C ++: binary search tree at compile time</a></li>
<li><a href="../320690/index.html">Notify at any cost about the fall of the site. Practical advice</a></li>
<li><a href="../320692/index.html">Three product lines and version control</a></li>
<li><a href="../320694/index.html">Hack.me: Another platform for honing skills in the field of information security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>