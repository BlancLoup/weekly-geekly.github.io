<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A study of simple crackme's (part 3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habraludi. 
 I present to you the third part of my series of articles on the study of kryakmis. In this topic we will talk with you about manua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A study of simple crackme's (part 3)</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habraludi. <br>  I present to you the third part of my series of articles on the study of kryakmis.  In this topic we will talk with you about manual unpacking of some packers and about overcoming not complicated anti-debugging methods. <br><a name="habracut"></a><br><br><h4>  1. Manual unpacking </h4><br>  From the tools I needed: <br><ul><li>  1. OllyDbg </li><li>  2. Olly Dump Plugin </li><li>  3. ImpREC </li><li>  4. PE tools </li><li>  5. PEid </li></ul><br><h5>  Theory </h5><br>  The packed program works as follows: <br>  First, the unpacker code is launched, which begins to decrypt the packed program code.  After the decryption is completed, a jump is made to the OEP program and then the already unpacked program code starts to be executed. <br><br>  The unpacking algorithm will be as follows: <br>  1. Find the RVA OEP. <br>  2. Dump the program. <br>  3. Restore the import table. <br>  4. Change the entry point to the original. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the OEP address we need is calculated by the formula: <br>  <code>RVA OEP = VA OEP - ImageBase</code> , where: <br>  <b>Image Base</b> is the address in memory from which the program is loaded into memory. <br>  <b>OEP (Original Entry Point)</b> is the address from which the program would start if it were not packed. <br>  <b>Virtual Address (VA)</b> - virtual address of the element in memory <br>  <b>Relative Virtual Adress (RVA)</b> is a relative virtual address.  Address relative to imagebase. <br>  Well, for example, we found OEP equal to 00301000, and ImageBase is equal to 00300000, then RVA OEP will be equal to 1000. The ImageBase value can be found by looking in any PE headers editor. <br>  After we find the RVA OEP we need to remove the dump program.  Dump means - area (part) of memory or a file saved to disk from memory.  To remove a dump means to save the required area of ‚Äã‚Äãmemory (usually occupied by the program) to the hard disk.  As a result, we get the unpacked program. <br>  Next we need to restore the import table.  The import table stores information about the functions used by the program during its operation.  Initially, the import table stores the addresses at which the file contains the names of imported functions, i.e.  functions used when running the program.  When the program is started, these addresses (this is all in memory) are overwritten by the direct addresses of the functions being imported.  It is necessary to restore it because those cells in which the addresses of the names of functions used to obtain direct addresses of functions in any version of the operating system are already filled with the addresses of these functions in the system in which the program was dumped.  In this case, the information on the addresses of the names of the functions can no longer be recovered and when starting such a program, the direct addresses of the functions already recorded will be used.  And this leads to the inoperability of the program on other versions of the OS. <br>  Finally, restore the OEP.  This can be done using any PE editor headers. <br>  That's the whole theory. <br><br><h5>  Practice </h5><br>  In this article we will look at two packers.  This is UPX and ASPack.  Unpacking other packers will not be much different from unpacking these two. <br><br><h6>  UPX </h6><br>  Download the latest version.  We pack something.  Run it under the debugger. <br>  During the decryption of the packed code, the packer uses the stack to its fullest.  Naturally, in order for the packed program to work correctly, the packer needs to save the initial value of the stack and then, after the decompression is completed, restore it.  In almost all packers, when they restore the stack before switching to OEP, the value in the stack is read to the address esp-4. <br>  Thus, in Olly we set the breakpoint with the hr esp-4 command.  Then we run the program and see that the breakpoint worked here: <br><br> <code>00472176 . 8D4424 80 LEA EAX,DWORD PTR SS:[ESP-80] // <br> 0047217A &gt; 6A 00 PUSH 0 // <br> 0047217C . 39C4 CMP ESP,EAX // <br> 0047217E .^75 FA JNZ SHORT 111.0047217A //. <br> 00472180 . 83EC 80 SUB ESP,-80 <br> 00472183 .^E9 386EFEFF JMP 111.00458FC0 //  OEP</code> <br> <br>  Next, we trace the program to OEP (roughly speaking, we become OEP).  With the help of the Olly Dump plugin, dump the program. <br>  Now it remains only to restore the import. We run our packed program and ImpREC.  In the list of processes ImpREC'a find our program.  In the RVA field, enter RVA OEP (described above as how to find it).  Click AutoSearch.  After the message that most likely something is found appears, click Get Imports and, if functions appear in the list, then click Fix Dump and select our dump.  That's all the program unpacked. <br><br><h6>  Aspack </h6><br>  It's all the same, except for some point.  After installing the breakpoint we get here: <br><br> <code>0046F416 75 08 JNZ SHORT Test_Com.0046F420 <br> 0046F418 B8 01000000 MOV EAX,1 <br> 0046F41D C2 0C00 RETN 0C <br> 0046F420 68 C08F4500 PUSH Test_Com.00458FC0 //   OEP <br> 0046F425 C3 RETN //    OEP</code> <br> <br>  The rest of the procedure is the same. <br><br><h5>  Kryakmis on unpacking </h5><br>  <a href="http://www.crackmes.de/users/znycuk/crackme2_find_my_passw0rd/download">Here is</a> this kryakmis. <br>  Unpack as described above.  Everything is perfectly unpacked. (For reference, OEP = 00401000).  After this, save the breakpoints on the call to the GetDlgItemTextA function, run, enter the fake pass, press the button and get here: <br><br> <code>00401206 . E8 1B060000 CALL &lt;JMP.&amp;user32.GetDlgItemTextA&gt; //   <br> 0040120B . 8B35 00604000 MOV ESI,DWORD PTR DS:[406000] <br> 00401211 . 81C6 7F010300 ADD ESI,3017F <br> 00401217 . 81EE 66060000 SUB ESI,666 <br> 0040121D . 81F6 ADDE0000 XOR ESI,0DEAD <br> 00401223 . BB 33604000 MOV EBX,dddddddd.00406033 <br> 00401228 . C0E0 03 SHL AL,3 // ! <br> 0040122B . 83F8 78 CMP EAX,78 // ! <br> 0040122E . 0F85 9A050000 JNZ dddddddd.004017CE //   "" </code> <br> <br>  At EAX, we have the length of the password entered.  With the SHL al, 3 command, we perform a logical shift of the AL value to the left by 3 and ideally we should get 78. We carry out the inverse shl procedure.  This shr 78.3 = 0F = 15 is the length of a valid password.  Then I traced for a very long time up to a certain point and on the way I came across several anti-debugging tricks: <br><br> <code>004012B0 0F31 RDTSC // <br> 004012B2 8BC8 MOV ECX,EAX <br> 004012B4 0F31 RDTSC // <br> 004012B6 2BC8 SUB ECX,EAX <br> 004012B8 F7D1 NOT ECX <br> 004012BA 81F9 00500000 CMP ECX,5000 <br> 004012C0 -7F FE JG SHORT crackme2.004012C0 //  </code> <br> <br>  The RDTSC instruction returns to EAX the number of clock cycles since the last processor reset.  In the code above, we see two calls to this instruction and then a comparison of the difference between their conclusions and a certain reference value.  The fact is that when a program is executed without a debugger, the time difference will be small, and when it is under the debugger, the difference will be large.  You will meet a lot of similar moments, just patch them or change flags.  When you prior to trace to the next point: <br><br> <code>0040126A 0F31 RDTSC <br> 0040126C 8BC8 MOV ECX,EAX <br> 0040126E 0F31 RDTSC <br> 00401270 2BC8 SUB ECX,EAX <br> 00401272 F7D1 NOT ECX <br> 00401274 81F9 00500000 CMP ECX,5000 <br> 0040127A 7C 05 JL SHORT crackme2.00401281 <br> 0040127C -E9 139C04EC JMP EC44AE94 <br> 00401281 EB 0D JMP SHORT crackme2.00401290</code> <br> <br>  Pay attention to 0040127C.  There is a jump to a non-existent address, so feel free to patch the transition to 00401281. There will be several such moments.  Trace to this code: <br><br> <code>004014F1 0FB613 MOVZX EDX,BYTE PTR DS:[EBX] ;         EBX,          EDX <br> 004014F4 B9 08000000 MOV ECX,8 <br> 004014F9 AC LODS BYTE PTR DS:[ESI] ;   EAX -  <br> 004014FA 24 01 AND AL,1 ; and 1    <br> 004014FC 74 04 JE SHORT crackme2.00401502 <br> 004014FE D0E2 SHL DL,1 <br> 00401500 72 08 JB SHORT crackme2.0040150A <br> 00401502 D0E2 SHL DL,1 <br> 00401504 0F82 BF020000 JB crackme2.004017C9 ;      <br> 0040150A ^E2 ED LOOPD SHORT crackme2.004014F9 <br> 0040150C 43 INC EBX <br> 0040150D 58 POP EAX <br> 0040150E 48 DEC EAX <br> 0040150F 0F84 9A020000 JE crackme2.004017AF <br> 00401515 50 PUSH EAX <br> 00401516 ^EB D9 JMP SHORT crackme2.004014F1</code> <br> <br>  Over this moment I thought for a very long time.  It turned out that this is a password generation procedure.  That is, the password is stored in the program is not in the clear.  AL throughout the generation takes the values ‚Äã‚Äã1 or 0. So, having traced the whole procedure of generating a password and writing out all the values, I got a huge string of binary values ‚Äã‚Äã(for convenience, I transferred it to the decimal system): <br><br> <code>119 101 108 108 100 111 110 101 85 102 105 110 100 109 101</code> <br> <br>  Considering that each eight characters (in a double string, and I translated into decimal, so here is every character framed by a space), generated after we put a certain character of our entered password in EDX, we can say that the string is higher and there is valid password.  Having recoded it it turned out "welldoneUfindme". <br><br><h4>  2. Some anti-debug methods </h4><br>  There are a lot of anti-debugging methods, starting with this article we will analyze them in turn, from simple to complex. <br>  So, on crackmes.de there is just a special quackery called <a href="http://www.crackmes.de/users/sashx41/antiolly_1/download">AntiOlly</a> .  Download it, launch it and see the following window: <br><br><img src="https://habrastorage.org/storage/habraeffect/80/31/8031a6be9cebf76d58a4c50f7dd54565.png" alt="image"><br><br>  Here we are told that nothing was found and we managed.  Now we have an idea of ‚Äã‚Äãwhat a ‚Äúgood‚Äù message looks like.  Load the mall into Olly and see the following: <br><br><img src="https://habrastorage.org/storage/habraeffect/65/60/656021c88534c5a75378a653488df335.png" alt="image"><br><br>  The error is caused by the fact that Olly, having analyzed the title of our mall, found errors in it (the header).  But it is fixable.  We load our cracks in PE edior and go to the Optional header tab.  My attention was attracted by the ‚Äútoo large‚Äù value of the parameters NumberOfRVAandSize, Base of Code and Base of Data.  Usually NumberOfRVAandSize = 0x00000010, Base of Code = 00001000, Base of Data = 00002000. We change these parameters to ‚Äúnormal‚Äù and run the cracks under the debugger.  Now the abusive message is not visible (that is, it remains, but does not affect the analysis) and we can safely analyze the mall.  So this was the first anti-debugging trick. <br>  Having started kryakmis under debugging, we see a ‚Äúbad‚Äù message: <br><br><img src="https://habrastorage.org/storage/habraeffect/3b/52/3b5214225b9ff14d64ca86df89bf12ed.png" alt="image"><br><br>  After analyzing the program, we find the anti-debug code section: <br><br> <code>00401010 |. FFD7 CALL EDI //   GetTickCount <br> 00401012 |. 6A 00 PUSH 0 <br> 00401014 |. 68 34214000 PUSH AntiOlly.00402134 <br> 00401019 |. 8BF0 MOV ESI,EAX <br> 0040101B |. FF15 DC204000 CALL DWORD PTR DS:[4020DC] //FindWindowA <br> 00401021 |. 85C0 TEST EAX,EAX <br> 00401023 |. 75 04 JNZ SHORT AntiOlly.00401029 <br> 00401025 |. 884424 0F MOV BYTE PTR SS:[ESP+F],AL <br> 00401029 |&gt; FF15 04204000 CALL DWORD PTR DS:[402004] //IsDebuggerPresent</code> <br> <br>  So, the first is the GetTickCount function.  This function returns the time that has passed since the start of the system in milliseconds.  The fact is that there is another call to this function.  Further, in the following code, the difference between the values ‚Äã‚Äãobtained as a result of these functions is measured.  This was the second anti-debugging trick. <br>  This is followed by a call to FindWindowA, which searches for a window with an OllyDbg header.  Finally, the call IsDebuggerPresent, which simply checks whether the program is being debugged or not.  If so, then in Eax 1, if not, then 0. <br>  Here are the checks that conducts mall: <br><br> <code>0040102F |. 85C0 TEST EAX,EAX //     IsDebuggerPresent <br> 00401031 |. 75 02 JNZ SHORT AntiOlly.00401035 //       00401035 <br> 00401033 |. 32DB XOR BL,BL //    BL <br> 00401035 |&gt; FFD7 CALL EDI //    GetTickCount <br> 00401037 |. 2BF0 SUB ESI,EAX <br> 00401039 |. 83FE 64 CMP ESI,64 //   <br> 0040103C |. 76 0D JBE SHORT AntiOlly.0040104B //  ok    0040104B <br> 0040103E |. A1 44204000 MOV EAX,DWORD PTR DS:[402044] <br> 00401043 |. 50 PUSH EAX <br> 00401044 |. 68 3C214000 PUSH AntiOlly.0040213C <br> 00401049 |. EB 3F JMP SHORT AntiOlly.0040108A //   ok      <br> 0040104B |&gt; 84DB TEST BL,BL <br> 0040104D |. 74 14 JE SHORT AntiOlly.00401063 //    IsDebuggerPresent <br> 0040104F |. 8B15 44204000 MOV EDX,DWORD PTR DS:[402044] <br> 00401055 |. A1 60204000 MOV EAX,DWORD PTR DS:[402060] <br> 0040105A |. 52 PUSH EDX <br> 0040105B |. 68 3C214000 PUSH AntiOlly.0040213C <br> 00401060 |. 50 PUSH EAX <br> 00401061 |. EB 2E JMP SHORT AntiOlly.00401091 <br> 00401063 |&gt; 807C24 0F 00 CMP BYTE PTR SS:[ESP+F],0 //       FindWindow <br> 00401068 |. 74 15 JE SHORT AntiOlly.0040107F</code> <br> <br>  I think now it is clear where to patch or edit registers. <br>  Thank you very much for your attention. </div><p>Source: <a href="https://habr.com/ru/post/102126/">https://habr.com/ru/post/102126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102119/index.html">Geoip</a></li>
<li><a href="../102121/index.html">R. Feynman "The nature of physical laws" (second lecture)</a></li>
<li><a href="../102122/index.html">Features of using GD-lib on PHP hosting with limited resources</a></li>
<li><a href="../102124/index.html">Your Web-PDF printer in 10 minutes</a></li>
<li><a href="../102125/index.html">Sports Tracker Service Overview</a></li>
<li><a href="../102128/index.html">Removal of extra costs for customers for online stores with courier delivery</a></li>
<li><a href="../102129/index.html">Packard Bell Laptop Power Recovery</a></li>
<li><a href="../102132/index.html">How we conducted the examination. findings</a></li>
<li><a href="../102134/index.html">When is THEM cheaper?</a></li>
<li><a href="../102141/index.html">Re: Ways to evaluate employee performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>