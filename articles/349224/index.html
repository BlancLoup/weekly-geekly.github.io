<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL indexes - 10</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles, we looked at PostgreSQL's indexing mechanism and interface access methods , as well as hash indices , B-trees , GiST , SP-GiST ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL indexes - 10</h1><div class="post__text post__text-html js-mediator-article"><br>  In previous articles, we looked at <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">PostgreSQL's indexing mechanism</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">interface access methods</a> , as well as <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash indices</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-trees</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">SP-GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">GIN</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/343488/">RUM,</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/346460/">BRIN</a> .  It remains for us to look at the Bloom indices. <br><br><h1>  Bloom </h1><br><h2>  General idea </h2><br>  The classic Bloom filter is a data structure that allows you to quickly verify that an element belongs to a set.  The filter is very compact, but it allows false positives: it has the right to make a mistake and consider the element as belonging to the set (false positive), but it has no right to say that the element is not in the set if it is actually present (false negative). <br><br>  The filter is a bitmap (also called a <em>signature</em> ) of length <em>m</em> bits, initially filled with zeros.  <em>K</em> different hash functions are selected that map any element of the set to <em>k</em> bits of the signature.  To add an element to a set, you need to set each of these bits to one in the signature.  Therefore, if all the bits corresponding to the element are set to one, the element may be present in the set;  if at least one bit is zero, the element is definitely missing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the case of a DBMS index, we actually have <em>N</em> separate filters built for each index line.  As a rule, several fields are included in the index;  the values ‚Äã‚Äãof these fields constitute the set of elements for each of the rows. <br><br>  Thanks to the choice of the size of the signature <em>m,</em> one can find a compromise between the volume of the index and the probability of false positives.  The Bloom Index's scope is large, fairly ‚Äúwide‚Äù tables, queries to which can use filtering by any of the fields.  This access method, like BRIN, can be considered as a sequential scanning accelerator: all the matches found by the index need to be rechecked on the table, but there is a chance not to consider a significant part of the lines at all. <br><a name="habracut"></a><br><h2>  Device </h2><br>  We already talked about signature trees in the context of the <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> access method.  Unlike these trees, the Bloom Index is a flat structure.  It consists of a metastpage, followed by ordinary pages with index lines.  Each index line contains a signature and a link to a table row (TID), as shown schematically in the figure. <br><br><img src="https://habrastorage.org/webt/tl/v3/xp/tlv3xpdlc4iw25iuma6yurx8wto.png"><br><br><h3>  Creating and selecting parameter values </h3><br>  When creating a bloom index, the storage parameters indicate the <em>total</em> size of the signature (length) and the number of bits to be set <em>separately for each field</em> included in the index (col1 ‚Äî col32): <br><br> <code>create index on ... using bloom(...) with (length=..., col1=..., col2=..., ...); <br></code> <br>  The way of specifying the number of bits looks strange: these numbers should be a parameter not of an index, but of a class of operators.  Just now, classes of operators cannot be parameterized, although work is underway on this. <br><br>  How to choose suitable values?  <a href="https://en.wikipedia.org/wiki/Bloom_filter">The theory</a> says that if we set the probability <em>p of a</em> false filter response, then the optimal number of bits of the signature can be estimated as <br>  <em>m = ‚àín log <sub>2</sub> (p) / ln (2),</em> where <em>n</em> is the number of fields in the index, and the number of bits to be set is <em>k = ‚àílog <sub>2</sub> (p).</em> <br><br>  Inside the index, the signature is stored as an array of two-byte integers, so that the value of <em>m</em> can be safely rounded to the top to 16. <br><br>  Choosing the probability <em>p, you</em> should consider the size of the index, which will be approximately equal to <br>  <em>(m / 8 + 6) N,</em> where <em>N</em> is the number of rows in the table, and 6 is the size of the TID pointer in bytes. <br><br>  A few points: <br><ul><li>  The probability of false positives <em>p</em> refers to one filter;  when scanning the table, we expect to get <em>Np</em> false positives (for a query that returns few rows, of course).  For example, for a table with a million rows and a probability of 0.01, on average we can expect in terms of the query ‚ÄúRows Removed by Index Recheck: 10,000‚Äù. <br></li><li>  Bloom filter - probabilistic structure.  It makes sense to talk about concrete numbers, only averaging quite a lot of values, and in each specific case, you can get anything you want. <br></li><li>  The above estimates are based on an idealized mathematical model and a number of assumptions.  In practice, the result is likely to turn out worse.  So the formulas should be treated calmly: this is just a way to choose initial values ‚Äã‚Äãfor further experiments. <br></li><li>  The access method allows you to select the number of bits to be set separately for each field.  There is a reasonable assumption that in fact the optimal number depends on the distribution of values ‚Äã‚Äãin the column.  If you want to be confused, you can see, for example, <a href="http://blog.coelho.net/database/2016/12/11/postgresql-bloom-index.html">this article</a> (I will be grateful for links to other studies).  But first reread the previous paragraph. <br></li></ul><br><h3>  Update </h3><br>  When a new row is inserted into the table, a signature is formed: for the values ‚Äã‚Äãof all indexed fields, all the corresponding bits are set to one.  According to the classics, it is necessary to have <em>k</em> different hash functions;  in practice, it is managed with a pseudo-random number generator, the generating element (seed) for which is selected each time using a single hash function. <br><br>  A normal Bloom filter does not support deletion of elements, but this is not required for a Bloom index: deleting a row from the table removes the entire signature along with the index row. <br><br>  The change, as usual, consists of deleting the old version of the string and inserting a new one (in this case, the signature is re-evaluated). <br><br><h3>  Scanning </h3><br>  Since the only thing that Bloom's filter can do is to check whether an element belongs to a set, the only operation supported by Bloom-index is the equality test (as in the hash index). <br><br>  As we said, the Bloom Index is flat, so with index access it is always read in succession and in its entirety.  In the process of reading a bitmap is built, which is then used to access the table. <br><br>  With traditional index access, it is assumed that you will need to read a few index pages, which, moreover, may soon be needed again;  therefore, they are placed in the buffer cache.  Reading a bloom index is actually a sequential scan.  In order to prevent the caching of useful information from the cache, reading occurs through a small <em>buffer ring,</em> just as with sequential scanning of tables. <br><br>  It should be noted that the larger the bloom index size, the less attractive it will seem to the planner - this dependence is linear, unlike tree-like indices. <br><br><h2>  Example </h2><br><h3>  Table </h3><br>  Let's look at the Bloom Index on the example of a large table flights_bi from the <a href="https://habrahabr.ru/company/postgrespro/blog/346460/">previous article</a> .  Let me remind you that the size of this table is 4 GB with approximately 30 million rows.  Table Definition: <br><br> <code>demo=# \d flights_bi <br> Table "bookings.flights_bi" <br> Column      |          Type          | Collation | Nullable | Default <br> --------------------+--------------------------+-----------+----------+--------- <br> airport_code      | character(3)            |          |          | <br> airport_coord      | point                    |          |          | <br> airport_utc_offset | interval                |          |          | <br> flight_no          | character(6)            |          |          | <br> flight_type        | text                    |          |          | <br> scheduled_time    | timestamp with time zone |          |          | <br> actual_time        | timestamp with time zone |          |          | <br> aircraft_code      | character(3)            |          |          | <br> seat_no            | character varying(4)    |          |          | <br> fare_conditions    | character varying(10)    |          |          | <br> passenger_id      | character varying(20)    |          |          | <br> passenger_name    | text                    |          |          | <br></code> <br>  Start by creating an extension - Bloom Index is included in the standard distribution starting from version 9.6, but is not available by default. <br><br> <code>demo=# create extension bloom; <br> CREATE EXTENSION <br></code> <br>  Using BRIN last time we managed to index three fields (scheduled_time, actual_time, airport_utc_offset).  The bloom indices do not depend on the physical location of the data, so we will try to include in the index almost all fields of the table.  However, we exclude the time (scheduled_time and actual_time) - the method supports only comparison for equality, but the request for the exact time is hardly interesting to someone (one could build an index by expression, rounding up the time to a day, but we will not do that).  We also have to exclude airport coordinates (airport_coord) - looking ahead, the point type is not supported. <br><br>  To select the values ‚Äã‚Äãof the parameters, we take the probability of a false positive of 0.01 (understanding that it will actually turn out more).  The above formulas for <em>n = 9</em> and <em>N = 30,000,000</em> give a signature size of 96 bits and suggest setting 7 bits per element.  The estimated index size is 515 MB (approximately the eighth part of the table). <br><br>  (With a minimum signature size of 16 bits, the formulas promise a two-fold smaller index, but they can only hope for a probability of 0.5, which is quite bad.) <br><br><h3>  Operator Classes </h3><br>  So, we try to create an index. <br><br> <code>demo=# create index flights_bi_bloom on flights_bi <br> using bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <br> with (length=96, col1=7, col2=7, col3=7, col4=7, col5=7, col6=7, col7=7, col8=7, col9=7); <br> ERROR: data type character has no default operator class for access method "bloom" <br> HINT: You must specify an operator class for the index or define a default operator class for the data type. <br></code> <br>  Sadness: in the extension, we are given only two classes of operators: <br><br> <code>demo=# select opcname, opcintype::regtype <br> from pg_opclass <br> where opcmethod = (select oid from pg_am where amname = 'bloom') <br> order by opcintype::regtype::text; <br> opcname  | opcintype <br> ----------+----------- <br> int4_ops | integer <br> text_ops | text <br> (2 rows) <br></code> <br>  Fortunately, it is not difficult to create similar classes for other data types.  The operator class for the bloom method must include exactly one operator ‚Äî equality ‚Äî and exactly one auxiliary function ‚Äî hashing.  The easiest way to find the necessary operators and functions for an arbitrary type is to look into the system catalog for the classes of operators of the hash method: <br><br> <code>demo=# select distinct <br> opc.opcintype::regtype::text, <br> amop.amopopr::regoperator, <br> ampr.amproc <br> from pg_am am, pg_opclass opc, pg_amop amop, pg_amproc ampr <br> where am.amname = 'hash' <br> and opc.opcmethod = am.oid <br> and amop.amopfamily = opc.opcfamily <br> and amop.amoplefttype = opc.opcintype <br> and amop.amoprighttype = opc.opcintype <br> and ampr.amprocfamily = opc.opcfamily <br> and ampr.amproclefttype = opc.opcintype <br> order by opc.opcintype::regtype::text; <br> opcintype |      amopopr        |    amproc <br> -----------+----------------------+-------------- <br> abstime  | =(abstime,abstime)  | hashint4 <br> aclitem  | =(aclitem,aclitem)  | hash_aclitem <br> anyarray  | =(anyarray,anyarray) | hash_array <br> anyenum  | =(anyenum,anyenum)  | hashenum <br> anyrange  | =(anyrange,anyrange) | hash_range <br> ... <br></code> <br>  With this information, create two missing classes: <br><br> <code>demo=# CREATE OPERATOR CLASS character_ops <br> DEFAULT FOR TYPE character USING bloom AS <br> OPERATOR  1  =(character,character), <br> FUNCTION  1  hashbpchar; <br> CREATE OPERATOR CLASS <br> <br> demo=# CREATE OPERATOR CLASS interval_ops <br> DEFAULT FOR TYPE interval USING bloom AS <br> OPERATOR  1  =(interval,interval), <br> FUNCTION  1  interval_hash; <br> CREATE OPERATOR CLASS <br></code> <br>  For points (point type) the hash function is not defined;  it is for this reason that we will not be able to build a bloom index on such a field (just as we will not be able to perform a hash join using fields of this type). <br><br>  We try again: <br><br> <code>demo=# create index flights_bi_bloom on flights_bi <br> using bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <br> with (length=96, col1=7, col2=7, col3=7, col4=7, col5=7, col6=7, col7=7, col8=7, col9=7); <br> CREATE INDEX <br></code> <br>  The size of the index is 526 MB, which is somewhat larger than the calculated one, due to the fact that in the formula we do not take into account the overhead expenses for the service information in each block. <br><br> <code>demo=# select pg_size_pretty(pg_total_relation_size('flights_bi_bloom')); <br> pg_size_pretty <br> ---------------- <br> 526 MB <br> (1 row) <br></code> <br><h3>  Requests </h3><br>  Now we can perform a search on a variety of criteria, and it will be supported by the index. <br><br>  As we said, the Bloom filter is a probabilistic structure, so the effectiveness in each particular case can be different.  For example, look at the records related to two passengers, Miroslav Sidorov: <br><br> <code>demo=# explain(costs off,analyze) <br> select * from flights_bi where passenger_name='MIROSLAV SIDOROV'; <br> QUERY PLAN <br> -------------------------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=2639.010..3010.692 rows=2 loops=1) <br> Recheck Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) <br> Rows Removed by Index Recheck: <strong>38562</strong> <br> Heap Blocks: exact=21726 <br> -&gt;  Bitmap Index Scan on flights_bi_bloom (actual time=1065.191..1065.191 rows=38564 loops=1) <br> Index Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) <br> Planning time: 0.109 ms <br> Execution time: 3010.736 ms <br></code> <br>  and Marfa Solovyova: <br><br> <code>demo=# explain(costs off,analyze) <br> select * from flights_bi where passenger_name='MARFA SOLOVEVA'; <br> QUERY PLAN <br> --------------------------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=9980.884..10142.684 rows=2 loops=1) <br> Recheck Cond: (passenger_name = 'MARFA SOLOVEVA'::text) <br> Rows Removed by Index Recheck: <strong>3950168</strong> <br> Heap Blocks: exact=45757 lossy=67332 <br> -&gt;  Bitmap Index Scan on flights_bi_bloom (actual time=1037.588..1037.588 rows=212972 loops=1) <br> Index Cond: (passenger_name = 'MARFA SOLOVEVA'::text) <br> Planning time: 0.157 ms <br> Execution time: 10142.730 ms <br></code> <br>  In one case, the filter allowed only 40 thousand false positives, in the other - as many as 4 million.  Correspondingly, the execution time of requests is different <br><br>  But the results for the search for the same lines, using not the name, but the document number.  Miroslav: <br><br> <code>demo=# explain(costs off,analyze) <br> demo-# select * from flights_bi where passenger_id='5864 006033'; <br> QUERY PLAN <br> ------------------------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=13747.305..16907.387 rows=2 loops=1) <br> Recheck Cond: ((passenger_id)::text = '5864 006033'::text) <br> Rows Removed by Index Recheck: <strong>9620258</strong> <br> Heap Blocks: exact=50510 lossy=165722 <br> -&gt;  Bitmap Index Scan on flights_bi_bloom (actual time=937.202..937.202 rows=426474 loops=1) <br> Index Cond: ((passenger_id)::text = '5864 006033'::text) <br> Planning time: 0.110 ms <br> Execution time: 16907.423 ms <br></code> <br>  And Martha: <br><br> <code>demo=# explain(costs off,analyze) <br> select * from flights_bi where passenger_id='2461 559238'; <br> QUERY PLAN <br> -------------------------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=3881.615..3934.481 rows=2 loops=1) <br> Recheck Cond: ((passenger_id)::text = '2461 559238'::text) <br> Rows Removed by Index Recheck: 30669 <br> Heap Blocks: exact= <strong>27513</strong> <br> -&gt;  Bitmap Index Scan on flights_bi_bloom (actual time=1084.391..1084.391 rows=30671 loops=1) <br> Index Cond: ((passenger_id)::text = '2461 559238'::text) <br> Planning time: 0.120 ms <br> Execution time: 3934.517 ms <br></code> <br>  Efficiency is again very different, this time it was more lucky for Martha. <br><br>  Note that the search simultaneously for two fields will be performed much more efficiently, since the probability of a false positive <em>p</em> turns into <em>p <sup>2</sup> :</em> <br><br> <code>demo=# explain(costs off,analyze) <br> select * from flights_bi <br> where passenger_name='MIROSLAV SIDOROV' <br> and passenger_id='5864 006033'; <br> QUERY PLAN <br> -------------------------------------------------------------------------------------------------------------------- <br> Bitmap Heap Scan on flights_bi (actual time=872.593..877.915 rows=2 loops=1) <br> Recheck Cond: (((passenger_id)::text = '5864 006033'::text) <br> AND (passenger_name = 'MIROSLAV SIDOROV'::text)) <br> Rows Removed by Index Recheck: <strong>357</strong> <br> Heap Blocks: exact=356 <br> -&gt;  Bitmap Index Scan on flights_bi_bloom (actual time=832.041..832.041 rows=359 loops=1) <br> Index Cond: (((passenger_id)::text = '5864 006033'::text) <br> AND (passenger_name = 'MIROSLAV SIDOROV'::text)) <br> Planning time: 0.524 ms <br> Execution time: 877.967 ms <br></code> <br>  But the condition with a logical "or" is not supported at all - this is a restriction not on this access method, but on the scheduler.  It remains, of course, the option to read the index twice, build two bitmaps and merge them, but it‚Äôs probably too expensive for such a plan to be chosen. <br><br><h2>  Comparison with BRIN and Hash </h2><br>  The areas of use of Bloom indices and BRIN indices obviously overlap.  These are large tables for which it is desirable to provide a search in different fields, and the accuracy of the search is sacrificed for compactness. <br><br>  BRIN indices are smaller (say, up to tens of megabytes in our example) and can support a range search, but have a very strong limitation associated with the physical location of the data in the file.  Bloom indices are larger (hundreds of megabytes), but they have no limitations, except for the presence of a suitable hash function. <br><br>  Like Bloom's indices, hash indices support a single equality test.  The hash index provides search accuracy that is unattainable for Bloom, but its size is significantly larger (in our example, only one gigabyte field, and no hash index over several fields). <br><br><h2>  Properties </h2><br>  Traditionally, we will look at the properties (requests <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were cited earlier</a> ). <br><br>  Method properties: <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> bloom  | can_order    | f <br> bloom  | can_unique    | f <br> bloom  | can_multi_col | t <br> bloom  | can_exclude  | f <br></code> <br>  Obviously, the access method allows building indexes on several columns - the Bloom index on one column is hardly meaningful. <br><br>  Index properties: <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | f <br> index_scan    | f <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br>  The only possible way to scan - on the bitmap.  Since the index is always scanned entirely, it makes no sense to implement the usual index access, in which the TIDs are returned one by one. <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | f <br> desc              | f <br> nulls_first        | f <br> nulls_last        | f <br> orderable          | f <br> distance_orderable | f <br> returnable        | f <br> search_array      | f <br> search_nulls      | f <br></code> <br>  Here, all the ‚Äúdashes‚Äù, and even with uncertain values, this access method does not know how to work. <br><br><h2>  And finally </h2><br>  I do not exclude that this series of articles will continue in the future with the advent of new interesting types of indices, but now it is time to stop. <br><br>  I want to express my gratitude to my colleagues from Postgres Professional (some of whom are the authors of many of the access methods considered) for reading drafts and comments.  And, of course, I appreciate <em>your</em> patience and valuable comments.  Your attention has given me the strength to reach this point.  Thank! </div><p>Source: <a href="https://habr.com/ru/post/349224/">https://habr.com/ru/post/349224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349214/index.html">Smart contract trap in the network Ethereum</a></li>
<li><a href="../349216/index.html">Registration is now open for Raiffeisen Data_Cup</a></li>
<li><a href="../349218/index.html">YouTube fell? Or one percent problem</a></li>
<li><a href="../349220/index.html">As we did "narrative" - ‚Äã‚Äãa new format of publications in Yandex. Dzen</a></li>
<li><a href="../349222/index.html">Hakintosh: upgrading from macOS Sierra 10.12 to High Sierra 10.13</a></li>
<li><a href="../349226/index.html">The blockchain program committee or how to fight off the ICO</a></li>
<li><a href="../349228/index.html">Unit tests when using Corutin in Android application</a></li>
<li><a href="../349230/index.html">How to make your code 80 times faster</a></li>
<li><a href="../349232/index.html">Let's talk about usernames</a></li>
<li><a href="../349234/index.html">Security Week 4: Bots for GTA fans, malicious addons for Chrome with Yandex technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>