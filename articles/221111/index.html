<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Proper use of promise in angular.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of using angular.js, it is difficult to do without the $ q object (it is promise / deferred), because it is the basis of the whole fram...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Proper use of promise in angular.js</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3b4/885/554/3b48855549271fca37b6a5ead123662e.png" alt="image" align="right">  In the process of using angular.js, it is difficult to do without the $ q object (it is promise / deferred), because it is the basis of the whole framework.  Deferred mechanism is a very simple and powerful tool that allows you to write concise code.  But in order to truly use this power, you need to know about all the possibilities of this tool. <br>  Here are a few things you probably didn't know about. <br><a name="habracut"></a><br><hr><br><br><h4>  1. then always returns a new promise. </h4><br>  Take a look at an example: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deferred = $q.defer(); doSomethingAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ res = asyncManipulate(res); deferred.resolve(res); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ deferred.reject(err); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred.promise; }</code> </pre> <br>  Here a new promise <code>$q.defer()</code> is meaningless.  The author of the code clearly did not know that then so would return the promise.  To improve the code, simply return the result to then: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncManipulate(res); }); }</code> </pre><br><br><h4>  2. The promise "not lost" result </h4><br>  Again an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncManipulate(res); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $q.reject(err); }); }</code> </pre><br>  Any result of executing the <code>doSomethingAsync</code> function, either resolve or reject, will ‚Äúpop up‚Äù until it finds its handler (if the handler exists at all).  This means that if there is no need to process the result, then you can simply omit the corresponding handler, because the result will not disappear anywhere, it will simply pass on.  In this example, the second handler can be safely removed (reject processing), since no manipulations are performed: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncManipulate(res); }); }</code> </pre><br>  You can also omit the resolve processing if you only need to handle the reject case: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().then(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorHandler(err); }); }</code> </pre><br>  By the way, for such a case there is syntactic sugar: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorHandler(err); }); }</code> </pre><br><br><h4>  3. You can get into the reject handler only by returning $ q.reject () </h4><br>  Code: <br><br><pre> <code class="javascript hljs">asyncFunction().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code return res; }, function (res) { // some code }).then(function (res) { console.log('in resolve'); }, function (res) { console.log('in reject'); });</span></span></code> </pre><br>  In this example, no matter how the <code>asyncFunction</code> function <code>asyncFunction</code> , we will see 'in resolve' in the console.  This is because there is only one way to be in the reject handler - to return $ q.reject ().  In any other cases, the resolve handler will be called.  We will rewrite the code so that we can see in the <code>asyncFunction</code> console in the console if <code>asyncFunction</code> returns a reject: <br><br><pre> <code class="javascript hljs">asyncFunction().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code return res; }, function (res) { // some code return $q.reject(res); }).then(function (res) { console.log('in resolve'); }, function (res) { console.log('in reject'); });</span></span></code> </pre><br><br><h4>  4. finally does not change promise result </h4><br><br><pre> <code class="javascript hljs">asyncFunction().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ importantFunction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ importantFunction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $q.reject(err); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some resolve code }, function (err) { // some reject code })</span></span></code> </pre><br>  If you need to execute code regardless of the promise result, use a finally handler that is always called.  The finally block does not affect further processing, since it does not change the type of promise of the result.  Improving: <br><br><pre> <code class="javascript hljs">asyncFunction().finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ importantFunction(); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some resolve code }, function (err) { // some reject code })</span></span></code> </pre><br>  If the finally handler returns $ q.reject (), then the reject handler will be called next.  There is no way to call the resolve handler. <br><br><h4>  5. $ q.all performs functions in parallel </h4><br>  Consider nested call chains: <br><br><pre> <code class="javascript hljs">loadSomeInfo().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">something</span></span></span><span class="hljs-function">) </span></span>{ loadAnotherInfo().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">another</span></span></span><span class="hljs-function">) </span></span>{ doSomethingOnThem(something, another); }); });</code> </pre><br>  The <code>doSomethingOnThem</code> functions require the result of executing both <code>loadSomeInfo</code> and <code>loadAnotherInfo</code> .  And it does not matter in what order they will be called, it is only important that the <code>doSomethingOnThem</code> function be called after the result from both functions is obtained.  This means that these functions can be called in parallel.  But the author of this code clearly did not know about the $ q.all method.  Rewrite: <br><br><pre> <code class="javascript hljs">$q.all([loadSomeInfo(), loadAnotherInfo()]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results</span></span></span><span class="hljs-function">) </span></span>{ doSomethingOnThem(results[<span class="hljs-number"><span class="hljs-number">0</span></span>], results[<span class="hljs-number"><span class="hljs-number">1</span></span>]); });</code> </pre><br>  $ q.all accepts an array of functions that will be run in parallel.  The promise returned by $ q.all will be called when all functions in the array have completed.  The result will be available in the form of an array of <code>results</code> , in which are the results of all functions respectively. <br>  Thus, the $ q.all method should be used in cases when it is necessary to synchronize the execution of asynchronous functions. <br><br><h4>  6. $ q.when turns everything into promise </h4><br>  There are situations where the code may depend on an asynchronous function, and may depend on synchronous.  And then you create a wrapper over the synchronous function to keep order in the code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAsync){ promise = asyncFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localPromise = $q.defer(); promise = localPromise.promise; localPromise.resolve(<span class="hljs-number"><span class="hljs-number">42</span></span>); } promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code });</span></span></code> </pre><br>  There is nothing wrong with this code.  But there is a way to make it cleaner: <br><br><pre> <code class="javascript hljs">$q.when(isAsync? asyncFunction(): <span class="hljs-number"><span class="hljs-number">42</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code });</span></span></code> </pre><br>  $ q.when a kind of proxy function that accepts either a promise or a normal value, and always returns a promise. <br><br><h4>  7. Proper error handling in promise </h4><br>  Let's look at an example of error handling in an asynchronous function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $timeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meAsynk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'error in meAsynk'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ asyncFunction(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(err){ errorHandler(err); }</code> </pre><br>  Do you see a problem here?  The try / catch block will only catch errors that occur when executing the <code>asyncFunction</code> function.  But, after <code>$timeout</code> launches its callback function <code>meAsynk</code> , any errors that occur there will fall into the application's uncaught exception handler.  Accordingly, our catch handler will not know anything. <br>  Therefore wrapping asynchronous functions in try / catch is useless.  But what to do in such situations?  To do this, asynchronous functions must have a special callback for error handling.  In $ q, such a handler is the reject handler. <br>  Rewrite the code so that the error is in the handler (use the <code>catch</code> sugar described above): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $timeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meAsynk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'error in meAsynk'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1</span></span>); } asyncFunction().catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ errorHandler(err); });</code> </pre><br>  Consider another example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise = doSomethingAsync(); promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> somethingAsyncAgain(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre><br>  This code has one problem: if the function <code>somethingAsyncAgain</code> returns a reject (and as we already know, the reject is also called in cases where errors are falling), the code that caused our function will never know about it.  Promises must be consistent, each following should depend on the previous one.  But in this example, the promise is broken.  To fix the rewrite so: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomethingAsync().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> somethingAsyncAgain(); }); }</code> </pre><br>  Now the code that calls our function completely depends on the result of the execution of the function <code>somethingAsyncAgain</code> , and all errors can be handled by the parent code. <br><br>  Let's look at this example: <br><br><pre> <code class="javascript hljs">asyncFunction().then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> somethingElseAsync(); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ errorHandler(err); });</code> </pre><br>  It would seem that this time everything is correct.  But if the error falls in the <code>somethingElseAsync</code> function, it will not be handled by anyone.  Let's rewrite the code so that the reject handler is detached: <br><br><pre> <code class="javascript hljs">asyncFunction().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> somethingElseAsync(); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ errorHandler(err); });</code> </pre><br>  Now, any error that occurs will be processed. <br><br><h4>  <b>PS</b> </h4><br>  The $ q service is an implementation of the <a href="http://promises-aplus.github.io/promises-spec/">Promises / A +</a> standard.  For a deeper understanding, I recommend reading this standard. <br>  It is also worth noting that the promise implementation in jQuery differs from the Promises / A + standard.  Those who are interested in these differences can read <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">this article</a> . </div><p>Source: <a href="https://habr.com/ru/post/221111/">https://habr.com/ru/post/221111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221091/index.html">We realize video calls in an iOS application (by the example of a children's monitor and without WebRTC)</a></li>
<li><a href="../221095/index.html">J-sort</a></li>
<li><a href="../221097/index.html">Samsung Galaxy Tab Pro 10.1: tested in humans</a></li>
<li><a href="../221105/index.html">About cutting corners</a></li>
<li><a href="../221107/index.html">‚ÄúCars instead of people!‚Äù</a></li>
<li><a href="../221113/index.html">Free Webinar "Preparation for the exam 70412: Configuring additional services Windows Server 2012"</a></li>
<li><a href="../221115/index.html">IBM introduced new servers based on Power8 processors</a></li>
<li><a href="../221117/index.html">Clash of Clans - mechanisms for monetizing game time</a></li>
<li><a href="../221119/index.html">Home Connect - one app for all brands</a></li>
<li><a href="../221121/index.html">Trends in online education</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>