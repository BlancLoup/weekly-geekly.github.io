<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices on Go with the Go kit: Introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will describe the use of the Go kit, a set of tools and libraries for creating microservices on Go. This article is an introduction ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservices on Go with the Go kit: Introduction</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article I will describe the use of the Go kit, a set of tools and libraries for creating microservices on Go.  This article is an introduction to the Go kit.  The first part in my blog, the source code of the examples is available <a href="https://github.com/shijuvar/gokit-examples">here</a> . </p><a name="habracut"></a><br><p>  Go is increasingly being chosen to develop modern distributed systems.  When you develop a cloud-based distributed system, you may need support for various specific functionalities in your services, such as: various transport protocols ( <em>eg. HTTP lane, gRPC, etc.</em> ) and message encoding formats for them, RPC reliability, logging , tracing, metrics and profiling, interrupting queries, limiting the number of queries, integrating into the infrastructure, and even describing the architecture.  Go is a popular language due to its simplicity and "no magic" approaches, so Go packages, for example, the standard library, are already suitable for developing distributed systems more than using a full-fledged framework with a lot of "magic under the hood".  Personally, I  <em>per.</em>  <em>Shiju Varghese</em> ] do not support the use of full frameworks, I prefer to use libraries that give more freedom to the developer.  Go kit filled the gap in the Go ecosystem, making it possible to use a set of libraries and packages when creating microservices, which in turn allow the use of good principles for designing individual services in distributed systems. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="image"></p><br><h3 id="vvedenie-v-go-kit">  Introduction to go kit </h3><br><p>  <a href="https://gokit.io/">Go kit</a> is a set of Go packages that facilitate the creation of reliable and supported microservices.  Go kit provides libraries for the implementation of various components of a transparent and reliable application architecture, using such layers as: logging, metrics, tracing, restriction and interruption of requests that are necessary to run microservices on the sale.  Go kit is good because it is well implemented tools for interacting with different infrastructures, message encoding formats and different transport levels. </p><br><p>  In addition to a set of libraries for the development of mircoservices, it provides and encourages the use of good design principles for the architecture of your services.  The go kit helps to adhere to the principles of SOLID, the subject-oriented approach (DDD) and the <a href="https://habr.com/post/267125/">hexagonal architecture</a> proposed by <em>Alistair Cockburn</em> or any other approaches from architectural principles known as the <a href="https://habr.com/post/233747/">onion architecture</a> by <em>Jeffrey Palermo</em> and the <a href="https://habr.com/post/269589/">pure architecture</a> by <em>Robert C. Martin</em> .  Although the Go kit was designed as a set of packages for developing microservices, it is also suitable for developing elegant monoliths. </p><br><h3 id="arhitektura-go-kit">  Go kit architecture </h3><br><p>  Three main levels in the architecture of the application developed using the Go kit are: </p><br><ul><li>  transport level </li><li>  endpoint level </li><li>  service level </li></ul><br><h4 id="transportnyy-uroven">  Transport level </h4><br><p>  When you write microservices for distributed systems, the services in them often have to communicate with each other using different transport protocols, such as: HTTP or gRPC, or use pub / sub systems, such as NATS.  The transport level in the Go kit is bound to a specific transport protocol (hereinafter the transport).  Go kit supports various transport for your service, such as: HTTP, gRPC, NATS, AMQP and Thirft ( <em>you can also develop your own transport protocol for your protocol</em> ).  Therefore, services written using the Go kit often focus on the implementation of a specific business logic, which knows nothing about the transport used, you are free to use different transports for the same service.  As an example, one service written on the Go kit can simultaneously provide access to it via HTTP and gRPC. </p><br><h4 id="endpointy">  Endpoints </h4><br><p>  The endpoint or endpoint is a fundamental building block for services and customers.  In the go kit, the main communication pattern is RPC.  Endpoint is presented as a separate RPC method.  Each service method in the Go kit is converted to an endpoint, allowing communication between the server and the client in the RCP style.  Each endpoint exposes the service method using the Transport layer, which in turn uses various transport protocols, such as HTTP or gRPC.  A separate endpoint can be placed outside the service simultaneously with the help of several transports ( <em>approx. HTTP and gRPC at different ports</em> ). </p><br><h4 id="servisy">  Services </h4><br><p>  Business logic is implemented in the service layer.  Services written with the Go kit are designed as interfaces.  The business logic in the service layer contains the main business logic core, which does not need to know anything about the endpoints used or a particular transport protocol, like HTTP or gRPC, or about encoding or decoding requests and responses of various types of messages.  This will allow you to stick to pure architecture in services written with the Go kit.  Each service method is converted to endpoint using an adapter and exposed to the outside using a specific transport.  Thanks to the use of pure architecture, a separate method can be set up with the help of several transports simultaneously. </p><br><h3 id="primery">  Examples </h3><br><p>  And now let's look at the layers described above on the example of a simple application. </p><br><h4 id="biznes-logika-v-servise">  Business logic in the service </h4><br><p>  Business logic in the service is designed using interfaces.  We consider the example of an order in e-commerce: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  The Order service interface works with the order domain entity: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Here we implement the Order service interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  RPC Endpoint Queries and Answers </h4><br><p>  Service methods are exposed as RPC endpoints.  So we need to determine the types of messages ( <em>note. DTO - data transfer object</em> ) that will be used to send and receive messages through RPC endpoints.  Let's now define the structures for the types of requests and responses for RPC endpoints in the Order service: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Endpoint Go kit for service methods like RPC endpoint </h4><br><p>  The core of our business logic is separated from the rest of the code and rendered into the service layer, which is exposed using RPC endpoints, which use the Go kit abstraction called <code>Endpoint</code> . </p><br><p>  This is how the endpoint from the go kit looks like: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  As we said above, endpoint represents a separate RPC method.  Each service method is converted to <code>endpoint.Endpoint</code> using adapters.  Let's make the Go kit endpoints for the Order service methods: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  The endpoint adapter accepts an interface as a parameter for input and converts it into a go kit abstraction <code>endpoint.Enpoint</code> making each individual service method an endpoint.  This function adapter makes a comparison and type conversion for requests, calls the service method and returns a response message. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Setting the service out using HTTP </h4><br><p>  We created our service and described RPC endpoints for exposing our service methods.  Now we need to publish our service outwards so that other services can call RCP endpoints.  In order to place our service outside, we need to decide on the transport protocol for our service, according to which it will receive requests.  The go kit supports various transports, for example HTTP, gRPC, NATS, AMQP and Thrift out of the box. </p><br><p>  For example, we use HTTP transport for our service.  Go kit package <a href="http">github.com/go-kit/kit/transport/http</a> provides the ability to serve HTTP requests.  And the <code>NewServer</code> function from the <code>transport/http</code> package will create a new http server that will implement <code>http.Handler</code> and wrap the provided endpoints. </p><br><p>  Below is the code that converts the Go kit endpoints to an HTTP transport that serves HTTP requests: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  We create <code>http.Handler</code> with the help of the <code>NewServer</code> function from the <code>transport/http</code> package, which provides us with endpoints and query decoding functions (returns <code>type DecodeRequestFunc func</code> ) and response encoding (for example, <code>type EncodeReponseFunc func</code> ). </p><br><p>  The following are examples of <code>DecodeRequestFunc</code> and <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  Start HTTP server </h4><br><p>  Finally, we can run our HTTP server to process requests.  The <code>NewService</code> function described above implements the <code>http.Handler</code> interface <code>http.Handler</code> which allows us to run it as an HTTP server: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Now our service is running and uses the HTTP protocol at the transport level.  The same service can be launched using another transport. For example, the service can be exposed to the outside using gRPC or Apache Thrift. </p><br><p>  For the introductory article, we have already sufficiently used the Go kit primitives, but it also provides more functionality for creating systems of transparent, reliable patterns, service discovery, load balancing, etc.  We will discuss these and other things in the Go kit in the following articles. </p><br><h3 id="ishodnyy-kod">  Source </h3><br><p>  The entire source code of the examples can be viewed on GitHub <a href="https://github.com/shijuvar/gokit-examples">here.</a> </p><br><h3 id="middlewares-v-go-kit">  Middlewares in go kit </h3><br><p>  Go kit predisposes to the use of good principles of system design, such as separation into layers.  Isolating service components and endpoints is possible by using Middlewares ( <em>approx. Lane pattern mediator</em> ).  Middlewares in the Go kit provide a powerful mechanism by which you can wrap services and endpoints and add functionality (isolated components), such as logging, interrupting requests, limiting the number of requests, load balancing, or distributed tracing. </p><br><p>  Below is a picture from the <a href="https://gokit.io/">Go kit</a> website, which is depicted as a typical "onion architecture" using Middlewares in the Go kit: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="image"></p><br><h3 id="osteregaytes-sindroma-spring-boot-mikroservices">  Beware of Spring Boot Mikroservices Syndrome </h3><br><p>  Like Go kit, Spring Boot is a toolkit for creating microservices in the Java world.  But, unlike the Go kit, Spring Boot is a quite mature framework.  Also, many Java developers use Spring Boot to create mirkoservices using Java stack with positive feedback from use, some of them believe that microservices are only about using Spring Boot.  I see a lot of development teams who misinterpret the use of microservices, that they can be developed only with the help of Spring Boot and OSS Netflix and do not perceive microservices as a template in the development of distributed systems. </p><br><p>  So keep in mind that using a toolkit, such as a go kit or some kind of framework, you direct your development towards micro-sevris as a design pattern.  Although microservices solve many problems with scaling and commands and systems, but it also creates many problems, because data in systems based on microservices are scattered across various databases, which sometimes create many problems when creating transactional or data queries.  It all depends on the problem of the domain and the context of your system.  The cool thing is that the Go kit, designed as a tool for creating microservices, was also suitable for creating elegant monoliths that are created with a good design of the architecture of your systems. </p><br><p>  And some Go kit functionality, such as interruption and restriction of requests, are also available in service mesh platforms, for example, Istio.  So if you use something like Istio to launch your microsecure, you may not need some things from the Go kit, but not everyone will have enough channel width to use the service mesh to create inter-service communication as it adds one level and extra complexity. </p><br><h2 id="ps">  PS </h2><br><p>  The author of the translation may not share the opinion of the author of the <a href="https://medium.com/%40shijuvar/go-microservices-with-go-kit-introduction-43a757398183">original text</a> , this article is translated for informational purposes only for the Russian language community Go. </p><br><p>  <strong>UPD</strong> <br>  This is also the first article in the translation section and I would appreciate any feedback on the translation. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430300/">https://habr.com/ru/post/430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430286/index.html">Details of the promiscuous and dark side of pirated games for the Nintendo Switch</a></li>
<li><a href="../430290/index.html">Attempt to predict the fourth iteration of the SpaceX BFR project</a></li>
<li><a href="../430292/index.html">Electronic Frontier Foundation: network performance of police car license scanners in the US - 0.5%</a></li>
<li><a href="../430294/index.html">10 unobvious benefits of using Rust</a></li>
<li><a href="../430296/index.html">Make your ideas come app. Serverless application - step by step instructions</a></li>
<li><a href="../430302/index.html">Introduction to ptrace or code injection in sshd for fun</a></li>
<li><a href="../430304/index.html">Wonderful outpost in orbit</a></li>
<li><a href="../430306/index.html">Drilled the first tunnel Boring Company Ilona Mask</a></li>
<li><a href="../430308/index.html">Python internals. Easter eggs</a></li>
<li><a href="../430312/index.html">Validation of complex forms React. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>