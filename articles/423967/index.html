<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 10. Scheduler: additional features and context preservation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we looked at the different types of scheduling supported by the RTOS and the corresponding features in Nucleus SE. This artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 10. Scheduler: additional features and context preservation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/m-/ag/9y/m-ag9yjhbtfwdjmljyermwi6duu.jpeg"><br><br>  In the <a href="https://habr.com/post/422615/">previous article,</a> we looked at the different types of scheduling supported by the RTOS and the corresponding features in Nucleus SE.  This article will look at the additional scheduling options in Nucleus SE and the process of saving and restoring context. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Optional Functions </h2><br>  When developing the Nucleus SE, I made the maximum number of functions optional, which saves on memory and / or time. <br><br><h3>  Suspending Tasks </h3><br>  As mentioned earlier in the <a href="https://habr.com/post/422615/">‚ÄúScheduler: Implementation‚Äù article</a> , the Nucleus SE supports various options for suspending tasks, but this feature is optional and is enabled with the <b>NUSE_SUSPEND_ENABLE</b> symbol in <b>nuse_config.h</b> .  If set to <b>TRUE</b> , the data structure is defined as <b>NUSE_Task_Status []</b> .  This type of suspension applies to all tasks.  The array is of type <b>U8</b> , where 2 nibbles are used separately.  The lower 4 bits contain the status of the task: <br>  <b>NUSE_READY, NUSE_PURE_SUSPEND</b> , <b>NUSE_SLEEP_SUSPEND</b> , <b>NUSE_MAILBOX_SUSPEND</b> , etc.  If a task is suspended by an API call (for example, <b>NUSE_MAILBOX_SUSPEND</b> ), the upper 4 bits contain the index of the object on which the task is suspended.  This information is used when the resource becomes available and to call the API you need to find out which of the suspended tasks you need to resume. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To perform the suspension of tasks, a pair of scheduler functions is used: <b>NUSE_Suspend_Task ()</b> and <b>NUSE_Wake_Task ()</b> . <br><br>  The <b>NUSE_Suspend_Task ()</b> code is as follows: <br><br><img src="https://habrastorage.org/webt/ep/1j/gi/ep1jgiocsfdclopsjghruszeggq.png"><br><br>  The function saves the new task state (all 8 bits), received as the suspend_code parameter.  When locking is enabled (see ‚ÄúAPI blocking calls‚Äù below), the return code <b>NUSE_SUCCESS</b> is <b>preserved</b> .  Next, <b>NUSE_Reschedule ()</b> is called to transfer control to the next task. <br><br>  The <b>NUSE_Wake_Task ()</b> code is quite simple: <br><br><img src="https://habrastorage.org/webt/br/of/0p/brof0ptcaza3ovc4ykffacmkphy.png"><br><br>  The task status is set to <b>NUSE_READY</b> .  If the Priority Scheduler is not used, the current task continues to occupy the processor until it is time to release the resource.  If the Priority Scheduler is used, <b>NUSE_Reschedule ()</b> is called with the task index as the execution indication, since the task may have a higher priority and must be immediately put to execution. <br><br><h3>  API blocking calls </h3><br>  Nucleus RTOS supports a variety of API calls, with which the developer can pause (block) a task if resources are unavailable.  The task will resume when resources are available again.  This mechanism is implemented in Nucleus SE and applies to a number of kernel objects: a task can be locked in a memory section, in an event group, in a mailbox, a queue, a channel, or a semaphore.  But, like most tools in the Nucleus SE, it is optional and is defined by the symbol <b>NUSE_BLOCKING_ENABLE</b> in <b>nuse_config.h</b> .  If set to <b>TRUE</b> , then the array <b>NUSE_Task_Blocking_Return []</b> is defined, which contains the return code for each task;  this can be <b>NUSE_SUCCESS</b> or the <b>NUSE_MAILBOX_WAS_RESET</b> code indicating that the object was reset when the task was blocked.  When locking is enabled, the corresponding code is included in the API functions using conditional compilation. <br><br><h3>  Scheduler Counter </h3><br>  Nucleus RTOS calculates how many times a task has been scheduled since it was created and last reset.  This feature is also implemented in the Nucleus SE, but is optional and is defined by the symbol <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> in <b>nuse_config.h</b> .  If set to <b>TRUE</b> , an array of <b>NUSE_Task_Schedule_Count [] of</b> type <b>U16 is created</b> , which stores the counter of each task in the application. <br><br><h3>  Initial state of the task </h3><br>  When a task is created in the RTOS Nucleus, you can select its status: ready or suspended.  In Nucleus SE, by default, all tasks are ready at startup.  The option selected using the symbol <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> in <b>nuse_config.h</b> allows you to select the launch state.  The <b>NUSE_Task_Initial_State []</b> array is defined in <b>nuse_config.c</b> and requires the initialization of <b>NUSE_READY</b> or <b>NUSE_PURE_SUSPEND</b> for each task in the application. <br><br><h2>  Saving context </h2><br>  The idea of ‚Äã‚Äãsaving the task context with any type of scheduler other than RTC (Run to Completion) was presented in article # 3 ‚ÄúTasks and Planning‚Äù.  As already mentioned, there are several ways to keep context.  Given that the Nucleus SE is not intended for 32-bit processors, I chose to use tables rather than a stack to save the context. <br><br>  A two-dimensional array of the type <b>ADDR NUSE_Task_Context [] [] is</b> used to save the context for all tasks in the application.  The rows are <b>NUSE_TASK_NUMBER</b> (the number of tasks in the application), the columns are <b>NUSE_REGISTERS</b> (the number of registers to be saved; depends on the processor and is set to <b>nuse_types.h)</b> . <br><br>  Of course, saving the context and restoring the code depends on the processor.  And this is the only Nucleus SE code associated with a specific device (and development environment).  I will give an example of a save / restore code for a ColdFire processor.  Although this choice may seem strange due to an outdated processor, its assembler is easier to read than the assemblers of most modern processors.  The code is fairly simple to use as the basis for creating a context switch for other processors: <br><br><img src="https://habrastorage.org/webt/kw/gw/ct/kwgwctpm3q_igjvz2qfhmbi0awm.png"><br><br>  When a context switch is required, this code is called in NUSE_Context_Swap.  Two variables are used: <b>NUSE_Task_Active</b> , the index of the current task, the context of which must be saved;  <b>NUSE_Task_Next</b> , the index of the task, the context of which must be downloaded (see section ‚ÄúGlobal data‚Äù). <br><br>  The context preservation process works as follows: <br><br><ul><li>  Registers <b>A0</b> and <b>D0 are</b> temporarily stored on the stack; </li><li>  <b>A0 is</b> configured to point to an array of context blocks <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 is</b> loaded using <b>NUSE_Task_Active</b> and multiplied by 72 (ColdFire has 18 registers requiring 72 bytes to store); </li><li>  then <b>D0 is</b> added to <b>A0</b> , which now points to the context block for the current task; </li><li>  further registers are saved in the context block;  first <b>A0</b> and <b>D0</b> (from the stack), then <b>D1-D7</b> and <b>A1-A6</b> , then <b>SR</b> and <b>PC</b> (from the stack, we will look at a quickly triggered context switch), and the stack pointer is saved at the end. </li></ul><br>  The process of loading the context is the same sequence of actions in the reverse order: <br><br><ul><li>  <b>A0 is</b> configured to point to an array of context blocks <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0 is</b> loaded using <b>NUSE_Task_Active</b> , incremented and multiplied by 72; </li><li>  then <b>D0 is</b> added to <b>A0</b> , which now points to the context block for the new task (since the context must be loaded in the reverse process of saving the sequence, the stack pointer is required first); </li><li>  further registers are restored from the context block;  first the stack pointer, then <b>PC</b> and <b>SR</b> are <b>pushed</b> onto the stack, then <b>D1-D7</b> and <b>A1-A6</b> are loaded, and at the end <b>D0</b> and <b>A0</b> . </li></ul><br>  The difficulty in implementing context switching is difficult access to the state register for many processors (for ColdFire, this is <b>SR</b> ).  A common solution is to interrupt, i.e., a program interrupt or interrupt by conditional transition, which results in the <b>SR being</b> loaded onto the stack along with the <b>PC</b> .  This is how Nucleus SE works on ColdFire.  The macro <b>NUSE_CONTEXT_SWAP ()</b> is defined in <b>nuse_types.h</b> , which expands to: <br>  <b>asm ("trap # 0");</b> <br><br>  Below is the initialization code ( <b>NUSE_Init_Task ()</b> in <b>nuse_init.c</b> ) for context blocks: <br><br><img src="https://habrastorage.org/webt/h7/8n/td/h78ntdz05whdi70d0pkfx-ffnok.png"><br><br>  This initializes the stack pointer, <b>PC</b> and <b>SR</b> .  The first two have the values ‚Äã‚Äãset by the user in <b>nuse_config.c</b> .  The <b>SR</b> value is defined as the <b>NUSE_STATUS_REGISTER</b> character in <b>nuse_types.h</b> .  For ColdFire, this value is <b>0x40002000</b> . <br><br><h2>  Global data </h2><br>  The Nucleus SE scheduler requires very little memory to store data, but, of course, uses the data structures associated with the tasks, which will be discussed in detail in future articles. <br><br><h3>  RAM data </h3><br>  The scheduler does not use the data located in the ROM, and the RAM contains from 2 to 5 global variables (all set in <b>nuse_globals.c</b> ), depending on which scheduler is used: <br><br><ul><li>  <b>NUSE_Task_Active</b> - a variable of type <b>U8</b> , containing the index of the current task; </li><li>  <b>NUSE_Task_State</b> - a variable of type <b>U8</b> , containing a value indicating the status of the currently running code, which can be a task, an interrupt handler, or a launch code;  possible values: <b>NUSE_TASK_CONTEXT</b> , <b>NUSE_STARTUP_CONTEXT</b> , <b>NUSE_NISR_CONTEXT</b> and <b>NUSE_MISR_CONTEXT</b> ; </li><li>  <b>NUSE_Task_Saved_State</b> is a <b>U8</b> variable used to protect the <b>NUSE_Task_State</b> value in a controlled interrupt; </li><li>  <b>NUSE_Task_Next</b> is a variable of type <b>U8</b> , containing the index of the next task to be scheduled for all schedulers except RTC; </li><li>  <b>NUSE_Time_Slice_Ticks</b> is a variable of type <b>U16</b> containing a count of time <b>slices</b> ;  Used only with TS Scheduler. </li></ul><br><h3>  Data Footprint Data Scheduler </h3><br>  The Nucleus SE Scheduler does not use ROM data.  The exact amount of RAM data varies depending on the scheduler used: <br><br><ul><li>  for RTC - 2 bytes ( <b>NUSE_Task_Active</b> and <b>NUSE_Task_State</b> ); </li><li>  for RR and Priority - 4 bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> and <b>NUSE_Task_Next</b> ); </li><li>  for TS - 6 bytes ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> , <b>NUSE_Task_Next</b> and <b>NUSE_Time_Slice_Ticks</b> ). </li></ul><br><h2>  Implementation of other planning mechanisms </h2><br>  Although Nucleus SE offers a choice of 4 schedulers, covering most cases, the open architecture allows you to realize the possibilities for other cases. <br><br><h3>  Time slicing with background task </h3><br>  As discussed in <a href="https://habr.com/post/415329/">article # 3, ‚ÄúTasks and Planning,‚Äù a</a> simple time slice scheduler has limitations, because it limits the maximum time that a task can occupy a processor.  A more difficult option would be to add support for the background task.  Such a task could be scheduled on any slot allocated for suspended tasks, and run when the slot was partially released.  This approach allows you to schedule tasks at regular intervals and the predicted amount of time the processor core to perform. <br><br><h3>  Priority and Round Robin (RR) </h3><br>  In most real-time kernels, the priority scheduler supports several tasks at each priority level, unlike Nucleus SE, where each task has a unique level.  I prefer the latter because it greatly simplifies the data structures and, therefore, the scheduler code.  To support more complex architectures, numerous ROM and RAM tables would be required. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. <br><br>  <b>On translation:</b> this cycle of articles seemed interesting because, in spite of the outdated described approaches, the author introduces a little-prepared reader with real-time OS features in a very clear language.  I myself belong to the team of creators of the <a href="https://www.astrosoft.ru/products/development/rtos-macs/">Russian RTOS</a> , which we <a href="https://habr.com/post/423689/">intend to make free</a> , and I hope that the cycle will be useful for novice developers. </div><p>Source: <a href="https://habr.com/ru/post/423967/">https://habr.com/ru/post/423967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423957/index.html">Traffic generation in user space</a></li>
<li><a href="../423959/index.html">Underwater affairs - for robots</a></li>
<li><a href="../423961/index.html">Do not lose yourself: a new method of diagnosing dementia</a></li>
<li><a href="../423963/index.html">Prologue of Kelvin Point</a></li>
<li><a href="../423965/index.html">You bought the SIEM and are sure that the SOC is in your pocket, isn't it?</a></li>
<li><a href="../423971/index.html">Friday webinars from Skillbox: developers from developers</a></li>
<li><a href="../423973/index.html">Mirai botnet creators are now fighting crime on the side of the FBI</a></li>
<li><a href="../423977/index.html">Meeting with DevOps Deflope at the DevOpsConf 2018 conference</a></li>
<li><a href="../423979/index.html">British Biomarker Panel Healthy Aging</a></li>
<li><a href="../423981/index.html">DDIA book (book with hog) - make level up in understanding databases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>