<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Realistic Realm. 1 year experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Realm has long been known among mobile (and not only) developers. Unfortunately, there are almost no articles on this database in Runet. Let's fix thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Realistic Realm. 1 year experience</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/9d7/2bd/ab4/9d72bdab4e5a4c64ba82c1ffac8cbe36.png"></div><br>  Realm has long been known among mobile (and not only) developers.  Unfortunately, there are almost no articles on this database in Runet.  Let's fix this situation. <br><br>  A year ago, a line appeared in the build.gradle of our project: <br><br><pre><code class="java hljs">classpath <span class="hljs-string"><span class="hljs-string">"io.realm:realm-gradle-plugin:0.87.5"</span></span></code> </pre> <br>  During this year, the Realm code has grown to version 3.3, acquired many features and fixed a bunch of bugs, implemented a new functionality and got a cloud backend.  Let's talk more about Realm in the realities of Andoroid development and discuss the subtle points that arise when using it. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/328418/">About Us</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Realm as a startup</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Realm as a database</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Hello world</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Comparison with other databases</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Live Objects - Synchronous Reading</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Live Objects - Asynchronous Reading</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Main features of Realm objects</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Transactions</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Synchronous transactions</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Asynchronous transactions</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Open / close realm</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Notifications, RxJava</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Multithreading and asynchrony</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Testing</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">One Realm is good, but three is better.</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Inheritance and polymorphism</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Kotlin</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Realm mobile platform</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Debugging</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Architecture</a> </li><li>  <a href="https://habrahabr.ru/post/328418/">useful links</a> <a href="https://habrahabr.ru/post/328418/"><br></a> </li><li>  <a href="https://habrahabr.ru/post/328418/">Conclusion</a> </li></ul></div></div><br><a name="1"></a><br><h3>  About Us </h3><br>  We are developing an application for communication within the team, something between a telegram and slack.  The Android application is written in Kotlin, from the very beginning the offline-first approach was used, i.e.  when all the data displayed on the screen is taken from the cache.  Having tried several different databases, we stopped at Realm and actively used it throughout the year.  This article has grown from an internal document on the use of Realm.  The article is not a translation of the documentation and does not pretend to be complete, it is rather a collection of recipes and analysis of subtle points.  For full understanding we strongly recommend reading the <a href="https://realm.io/docs/java/latest/">official documentation</a> .  We will tell you about our experience and what bumps stuffed this year.  All the code for the article is written in Kotlin, you can find it on <a href="https://github.com/andrey7mel/realm_example">Github</a> . <br><a name="2"></a><br><h3>  Realm as a startup </h3><br>  If we talk about <a href="https://www.crunchbase.com/organization/realm-2">Realm as a company</a> , then this is a Danish startup founded in 2011.  Previously, the project was called tight.db.  During its existence, attracted 29M $ investment.  The company plans to earn on the basis of the <a href="https://realm.io/pricing/">Realm Mobile Platform</a> , the database itself is free and open source.  Realm for Android appeared in 2014 and has been constantly evolving since then.  Some updates break backward compatibility, but fixes can be done quite easily and quickly. <br><a name="3"></a><br><h3>  Realm as a database </h3><br>  Realm is a database for multiple platforms.  About themselves they write: <br><blockquote>  The Realm Mobile Platform is a next-generation data layer for applications.  Realm is reactive, concurrent, lightweight, and native objects. </blockquote><br>  In short, this is a native no-sql database for Android (Java, Kotlin), iOS (Objective-C, Swift), Xamarin (C #) and JavaScript (React Native, Node.js). <br>  There is also a backend that allows you to synchronize data from all sources. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Key features include <a href="https://ru.wikipedia.org/wiki/Zero-copy">zero copy</a> , <a href="https://ru.wikipedia.org/wiki/MVCC">MVCC</a> and <a href="https://ru.wikipedia.org/wiki/ACID">ACID</a> .  There is no built-in mechanism for aging and data cleaning. <br><br>  Realm has <a href="https://realm.io/docs/java/latest/">very good documentation</a> and lots of <a href="https://github.com/realm/realm-java/tree/master/examples">examples on github</a> . <br>  Realm employees periodically <a href="https://stackoverflow.com/questions/tagged/realm">monitor StackOverflow</a> , you can also get an <a href="https://github.com/realm/realm-java/issues">issue on github</a> . <br><a name="4"></a><br><h3>  Hello world </h3><br>  Hello world for Android looks like this: <br><br>  Add to build.gradle <br><br><pre> <code class="java hljs">build.gradle (Project level) classpath <span class="hljs-string"><span class="hljs-string">"io.realm:realm-gradle-plugin:3.3.0"</span></span> build.gradle (App level) apply plugin: <span class="hljs-string"><span class="hljs-string">'realm-android'</span></span></code> </pre> <br>  In Application we will configure Realm Configuration <br><br><pre> <code class="hljs kotlin">Realm.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> config = RealmConfiguration.Builder() .build() Realm.setDefaultConfiguration(config)</code> </pre><br>  And you can start working with the database: <br><br><pre> <code class="hljs pgsql">val realm = Realm.getDefaultInstance() realm.executeTransaction { realm -&gt; val dataObject = realm.createObject(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java) dataObject.name = "A" dataObject.id = <span class="hljs-number"><span class="hljs-number">1</span></span> } val dataObject = realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java).equalTo("id", <span class="hljs-number"><span class="hljs-number">1</span></span>).findFirst() dataObject.name // =&gt; A realm.executeTransaction { realm -&gt; val dataObjectTransaction = realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java).equalTo("id", <span class="hljs-number"><span class="hljs-number">1</span></span>).findFirst() dataObjectTransaction.name = "B" } dataObject.name // =&gt; B</code> </pre><a name="5"></a><br><h3>  Comparison with other databases </h3><br>  On Habr√© there is <a href="https://habrahabr.ru/post/281226/">an article from April 8, 2016, where 9 ORMs are compared for Android</a> , including Realm.  Realm is in the lead, here are the graphics: <br><br><div class="spoiler">  <b class="spoiler_title">Comparison with other ORM</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/833/363/e12/833363e1268a4f82ac34f50552a44804.png" alt="image"><br><br><img src="https://habrastorage.org/files/cfb/8cb/877/cfb8cb87704e446db5c5425701d3eda0.png" alt="image"><br><br></div></div><br>  On its website Realm provides the <a href="https://realm.io/news/realm-for-android/">following statistics</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Charts from the site Realm</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/9d7/ca5/2c9/9d7ca52c98914c818739da155446b527.png"><br><img src="https://habrastorage.org/web/b3a/279/f75/b3a279f7513341a6ae08832f4e8c70b6.png"><br></div></div><br>  There are three main features to consider: <br>  Live Objects - All objects obtained from Realm are, in fact, a proxy to the database.  Due to this, zero copy is achieved (objects are not copied from the database) <br>  Transactions - All changes to the associated data objects must be made inside the transaction. <br>  Open \ Close - The need to open / close the database instance <br><a name="6"></a><br><h3>  Live objects </h3><br>  All objects from Realm can be received synchronously or asynchronously. <br><br><h4>  Synchronous read </h4><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(realm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Realm</span></span></span></span><span class="hljs-function"><span class="hljs-params">, id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DataObject? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">equalTo</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, id).findFirst() }</code> </pre> <br>  Call the Realm method and block the stream until we get an object or null.  You cannot use objects received in other threads, therefore, for use in the main thread, you need to block ui or use asynchronous requests.  Fortunately, Realm provides us with a proxy, and not the object itself, so everything happens fairly quickly.  You can work with the object immediately upon receipt. <br><a name="7"></a><br><h4>  Asynchronous read </h4><br>  Very unobvious case.  What do you think will happen in this code: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstObject = realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findFirstAsync</span></span></span></span>() log(firstObject.id)</code> </pre> <br>  The correct answer is: get the error java.lang.IllegalStateException <br>  In asynchronous reading, although we get the object right away, we cannot work with it until it loads.  You need to check this with the isLoaded () function or call the load () blocking function.  It looks quite uncomfortable, so it‚Äôs better to use rx here.  Convert to observable and get the loaded object in OnNext.  Asynchronous operations are available only in streams with Looper. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObjectObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(realm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Realm</span></span></span></span><span class="hljs-function"><span class="hljs-params">, id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;DataObject&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findFirstAsync</span></span></span></span>().asObservable() }</code> </pre><a name="8"></a><br><h4>  Main features of Realm objects </h4><br><ul><li>  Obtaining objects from the database is very fast, there is no deserialization as such, reading from disk occurs only when accessing a specific field. </li><li>  For this purpose, there is a requirement to make all fields private and contact via getters. </li><li>  The copyFromRealm () method allows you to get untied, fully assembled objects, just like a normal ORM.  True and all Realm chips become unavailable.  The input is the depth of deserialization, the default is MAX_INT </li><li>  In the debugger all fields will be null.  To get any value we need to contact via getter </li><li>  All objects are Live, i.e. live.  Changes are distributed instantly within a single thread.  For more complex cases, see below (multithreading). </li><li>  Objects are filtered by fields, and you specify the field names with your hands as a string.  For example: .equalTo ("id", 1).  This complicates refactoring and leads to errors in the naming of fields for filtering.  Unfortunately, Realm does not generate variables with field names, so it is better to hide all samples inside the function: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFirstDataObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">, realm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Realm</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : DataObject = realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">equalTo</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, id).findFirst()</code> </pre> <br>  or <a href="https://github.com/cmelchior/realmfieldnameshelper">use the cmelchior field name generator</a> <br></li><li>  This item has changed right at the time of writing (a vivid example of how the project is developing) <br>  It was: It is impossible to use DiffUtil when changing an object, it is impossible to understand what fields the object has changed.  Those.  if you received a notification about the change of the object, it is impossible to understand what has changed.  This is due to the fact that both objects (old and new) are live objects and refer to the same data, they will always be equal. <br>  It became: <a href="https://news.realm.io/news/realm-java-3-1/">You can use RealmObjectChangeListener</a> to understand what has changed: <br><div class="spoiler">  <b class="spoiler_title">RealmObjectChangeListener</b> <div class="spoiler_text"><pre> <code class="java hljs">Person p = realm.where(Person.class).findFirst(); p.addChangeListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RealmObjectChangeListener&lt;Person&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person, ObjectChangeSet changeSet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changeSet.isDeleted()) { hide(); <span class="hljs-comment"><span class="hljs-comment">// Object was deleted } else { // Use information about which fields changed to only update part of the UI if (changeSet.isFieldChanged("name")) { updateName(person.getName()); } } } });</span></span></code> </pre><br></div></div></li><li>  Any object is available only as long as the instance realm-a is open from which we received it.  You can check isValid methods.  When accessing an invalid object, we get an exception </li><li>  Objects are available only in the stream in which they were created.  You cannot call from another thread, we get an exception </li></ul><br>  Similarly, lists (RealmResult) of objects (query results) are proxied to Realm, this leads to the following: <br><br><ul><li>  Getting lists is very fast, in fact we only get count.  All requests lazy, we can get a large list of complex objects very quickly </li><li>  Lists are read-only; any modification methods result in an exception. <br></li><li>  Since  we can quickly and cheaply receive all the elements, you can forget about the problem of pagination.  We always give a complete list of items, when scrolling, we turn to objects, and they quickly come out of the database.  If we need to load the data, we start the download, get the data, save it to Realm, again get the full list with the loaded elements and display it <br></li><li>  Until recently (prior to version 3.0) there was a problem with redrawing all the elements of the list.  If we use the list for the adapter, then changing one element causes a complete redrawing of the entire list.  Using DiffUtils and comparing which objects have changed will not work, because  These are live objects.  In Realm 3.0, OrderedCollectionChangeSet appeared, which tells us DeletionRanges, InsertionRange, ChangeRanges.  It has finally become possible to understand what objects have changed and how. <br><br><div class="spoiler">  <b class="spoiler_title">CollectionChangeListener Example</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> OrderedRealmCollectionChangeListener&lt;RealmResults&lt;Person&gt;&gt; changeListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedRealmCollectionChangeListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RealmResults&lt;Person&gt; collection, OrderedCollectionChangeSet changeSet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// `null` means the async query returns the first time. if (changeSet == null) { notifyDataSetChanged(); return; } // For deletions, the adapter has to be notified in reverse order. OrderedCollectionChangeSet.Range[] deletions = changeSet.getDeletionRanges(); for (int i = deletions.length - 1; i &gt;= 0; i--) { OrderedCollectionChangeSet.Range range = deletions[i]; notifyItemRangeRemoved(range.startIndex, range.length); } OrderedCollectionChangeSet.Range[] insertions = changeSet.getInsertionRanges(); for (OrderedCollectionChangeSet.Range range : insertions) { notifyItemRangeInserted(range.startIndex, range.length); } OrderedCollectionChangeSet.Range[] modifications = changeSet.getChangeRanges(); for (OrderedCollectionChangeSet.Range range : modifications) { notifyItemRangeChanged(range.startIndex, range.length); } } };</span></span></code> </pre><br></div></div><br></li></ul><a name="9"></a><h3>  Transactions </h3><br>  Modifying objects bound to Realm is possible only inside a transaction, when changing outside of a transaction, we get an error.  On the one hand, it is not very convenient, on the other hand - it disciplines and does not allow to change objects in any part of the code, only in a certain layer (database).  You also need to remember that transactions within another transaction are prohibited. <br><br>  How not to do: <br><br><pre> <code class="hljs pgsql">val <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) button.setOnClickListener { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name = "Test" }</code> </pre> <br>  How can you: <br><br><pre> <code class="hljs pgsql">val <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.getUser(<span class="hljs-number"><span class="hljs-number">1</span></span>) button.setOnClickListener { <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.setUserName(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, "Test") }</code> </pre> <br>  Transactions can be made synchronously and asynchronously.  Let's take a closer look at each of the options: <br><a name="10"></a><br><h4>  Synchronous transactions: </h4><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syncTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Realm.getDefaultInstance().use { it.executeTransaction { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataObject = DataObject() it.insertOrUpdate(dataObject) } } }</code> </pre> <br>  You can also perform transactions between beginTransaction and commitTransaction, however, it is recommended that you use executeTransaction. <br><br>  Unfortunately, synchronous transactions do not support onError callback, so error handling is on your conscience.  <a href="https://github.com/realm/realm-java/issues/3048">There is an issue</a> to add onError callback since June 2016. <br><a name="11"></a><br><h4>  Asynchronous transactions </h4><br>  Asynchronous transactions are triggered by the asyncTransaction method.  We give the transaction and callback onSuccess and onError to the input, we get the RealmAsyncTask object at the output, with which we can check the status or cancel the transaction.  Asynchronous transactions run only in threads with Looper.  An example of an asynchronous transaction: <br><br><pre> <code class="hljs pgsql">Realm.getDefaultInstance().use { it.executeTransactionAsync({ it.insertOrUpdate(DataObject(<span class="hljs-number"><span class="hljs-number">0</span></span>)) }, { log("OnSuccess") }, { log("onError") it.printStackTrace() }) }</code> </pre> <br>  A couple of important nuances: <br><br>  You cannot assign an object not bound to Realm via a setter.  You must first put the object in the database, and then attach the linked copy.  Example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> realm = Realm.getDefaultInstance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parent = realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(Parent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">findFirst</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> children = Children() <span class="hljs-comment"><span class="hljs-comment">// parent.setChildren(children) &lt;-- Error val childrenRealm = realm.copyToRealmOrUpdate(children) parent.setChildren(childrenRealm) /// Ok</span></span></code> </pre> <br>  Many transactions are best merged into one.  In Realm there is an internal queue for transactions (100 in size) and if you exceed it, an exception will fall. <br><br>  All asynchronous transactions run on the same executor. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Thread pool for all async operations (Query &amp; transaction) static final RealmThreadPoolExecutor asyncTaskExecutor = RealmThreadPoolExecutor.newDefaultExecutor();</span></span></code> </pre> <br>  If you have many asynchronous operations in a short time, you will get a RejectedExecutionException error.  The way out of this situation would be to use a separate stream and start synchronous transactions in it or merge several transactions into one. <br><a name="12"></a><br><h3>  Open / close realm </h3><br>  We receive all objects from the database using a specific instance of Realm-a, and we can work with them while this instance is open.  As soon as we call realm.close (), any attempt to read an object will result in an exception for us.  If we do not close Realm in time, it will lead to memory leaks, since  the garbage collector does not know how to work correctly with the resources used by Realm. <br><br>  The <a href="https://realm.io/docs/java/latest/">official documentation is</a> recommended to open / close Realm: <br><br><ul><li>  for Activity: onCreate / onDestroy </li><li>  for Fragment: onCreateView / onDestroyView </li></ul><br>  However, if you want to make the logic of working with Realm from Activity \ Fragments into presenters, you will have to use (prokidyd) life-cycle methods. <br><br>  If you need to somehow change the data or add new ones, the easiest way is to get a new instance, write the data and then close it.  In Kotlin, you can use .use () <br><br><pre> <code class="hljs php">Realm.getDefaultInstance().<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> { <span class="hljs-comment"><span class="hljs-comment">// it = realm instance}</span></span></code> </pre> <br>  For reading objects using Rx, you can use ‚Äúisolated‚Äù instances and close them in doOnUnsubscribe (or use Observable.using) <br><br><pre> <code class="hljs pgsql">// Use doOnUnsubscribe val realm = Realm.getDefaultInstance() realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java).findAllSorted("id").asObservable().doOnUnsubscribe { realm.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>() } // Use Observable.<span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(Realm.getDefaultInstance(), realm -&gt; realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java).equalTo("id", id) .findFirstAsync() .asObservable() .<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(realmObject -&gt; realmObject.isLoaded()) .cast(DataObject::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.java), Realm::<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>);</code> </pre> <br>  There is also a feature associated with closing Realm in onDestroy \ onDestroyView.  Sometimes after closing Realm, FragmentManagerImpl.moveToState ‚Üí ViewGroup.removeView ‚Üí ... ‚Üí RecyclerViewAdapter.getItemCount () is called and the list.size () method is called from an invalid collection.  So here you need to check isValid () or untie the adapter from recyclerView <br><br>  If you are using <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">Kotlin Android Extensions</a> , then you can work with view (from kotlinx.android.synthetic. *) From Fragment only from the onViewCreated () method, it is better to configure all listeners in this method in order not to get NPE. <br><br>  After analyzing the three most important features, let's go over the less important ones: <br><a name="13"></a><br><h3>  Notifications, RxJava </h3><br>  Realm supports notifications about changes in data, both for the object itself and for embedded objects (all linked objects).  This is implemented using RealmChangeListener (the object itself comes to us), RealmObjectChangeListener (a modified object comes in and ObjectChangeSet for it, you can understand which fields have changed) or using RxJava (you get an object in onNext, in the case of an asynchronous request you need to check isLoaded (), only in streams with Looper). <br><br>  RxJava2 hasn‚Äôt been delivered yet, the <a href="https://github.com/realm/realm-java/issues/3497">issue has been hanging since September 2016</a> , when they are implementing it is unknown, use <a href="https://github.com/akarnokd/RxJava2Interop">Interop</a> . <br><br>  Similarly, you can listen to changes in collections or the entire instance Realm.  Listening to changes inside transactions is prohibited. <br><br>  Rx example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObjectObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(realm: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Realm</span></span></span></span><span class="hljs-function"><span class="hljs-params">, id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;DataObject?&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> realm.<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(DataObject::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">equalTo</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, id).findFirstAsync() .asObservable&lt;DataObject?&gt;().filter({ it?.isLoaded }).filter { it?.isValid } }</code> </pre> <a name="14"></a><br><h3>  Multithreading and asynchrony </h3><br>  Realm is an MVCC database.  <a href="https://ru.wikipedia.org/wiki/MVCC">Wikipedia says about MVCC</a> : <br><blockquote>  ‚ÄúManagement of parallel access using multi-version (MVCC - MultiVersion Concurrency Control) is one of the mechanisms for providing parallel access to the database, which is to provide each user with a so-called‚Äú snapshot ‚Äùof the database, which has the property that changes made by the user to the database are invisible to others users until the transaction is committed.  This method of control allows you to ensure that writing transactions do not block readers, and reading transactions do not block writers. ‚Äù </blockquote><br>  In practice, it looks like this: we can listen to changes to an object or use RxJava to receive changed objects in onNext.  If changes occur in stream A, and we work with an object in stream B, then stream B will know about the changes after the Realm instance is closed in stream A. Changes are transmitted through the Looper.  If there is no Looper in stream B, then the changes will not come (you can check with isAutoRefresh ()).  The way out of this situation is to use the waitForChange () method. <br><br>  As for asynchronous calls and transactions, it is better not to use them at all.  It is more convenient to translate actions to a separate stream and perform synchronous operations there.  <a href="https://medium.com/%40ffvanderlaan/realm-auto-updated-objects-what-you-need-to-know-b2d769d12d76">There are several reasons</a> : <br><br><ul><li>  You can not mix asynchronous transactions and synchronous, if mixed, all transactions will become synchronous </li><li>  Asynchronous calls cannot be used in streams without Looper </li><li>  For long-term transactions, you need to open a separate instance realm, otherwise the realm can be closed during the transaction and you will get an exception </li><li>  All actions in an asynchronous transaction occur on a separate internal executor, as a result you cannot use external realm objects, an executor may overflow, changes to the realm object are not propagated between threads and other inconveniences </li></ul><br><a name="15"></a><h3>  Testing </h3><br>  Previously, Realm.java was final and for testing you needed powerMock or other similar tools.  At the moment, Realm.java has ceased to be final and you can safely use the usual mockito.  Examples of tests in the <a href="https://github.com/andrey7mel/realm_example">demo project</a> or on the <a href="https://github.com/realm/realm-java/tree/master/examples/unitTestExample">official repository</a> <a href="https://github.com/realm/realm-java/tree/master/examples/unitTestExample"><br></a> <a name="16"></a><br><h3>  One Realm is good, but three is better. </h3><br>  Working with Realm, we always mean the standard realm, but there are also In-Memory Realm and Dynamic Realm. <br><br>  Standard Realm - can be obtained using Realm.getDefaultInstance () methods or using a specific Realm.getInstance (config) configuration, there can be an unlimited number of configurations, these are essentially separate databases. <br><br>  In-Memory Realm is a Realm that stores all recorded data in memory without writing it to disk.  As soon as we close this instance, all data will be lost.  Suitable for short-term data storage. <br><br>  Dynamic Realm - used mainly during migration, allows working with realm objects without using the generated RealmObject classes, access is carried out by field names. <br><a name="17"></a><br><h3>  Inheritance and polymorphism </h3><br>  Realm does not support inheritance.  Any realm object must either inherit from RealmObject or implement an interface with a RealmModel marker and be marked with the @RealmClass annotation.  It is impossible to inherit from existing Realm objects.  It is recommended to use composition instead of inheritance.  A very serious problem, the <a href="https://github.com/realm/realm-java/issues/761">issue has been hanging since January 2015</a> , but it's still there. <br><a name="18"></a><br><h3>  Kotlin </h3><br>  Realm out of the box <a href="https://realm.io/docs/java/latest/">works with Kotlin</a> . <br>  Data classes do not work, you need to use the usual open class. <br>  Also worth noting is <a href="https://github.com/vicpinm/Kotlin-Realm-Extensions">Kotlin-Realm-Extensions</a> , convenient extensions for working with RealmObject. <br><a name="19"></a><br><h3>  Realm mobile platform </h3><br>  At first, Realm was presented only to databases for different platforms, now they have rolled out the server for synchronization between all devices.  Now the platform consists of: <br><ul><li>  Realm Mobile Database - a database for data storage <br></li><li>  Realm Object Server - server that is responsible for automatic synchronization and event handling. </li><li>  Realm Data Integration API - to connect and synchronize data with existing databases (Oracle, MongoDB, Hadoop, SAP HANA, Postgres and Redis) </li></ul><br><div class="spoiler">  <b class="spoiler_title">Illustration of the mobile platform</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/6ad/c91/ff0/6adc91ff09be4c938a051d396a5e9f9e.jpg"><br></div></div><a name="20"></a><br><h3>  Debugging </h3><br>  We have several tools for debugging: <br><br><ul><li>  <a href="https://realm.io/docs/java/latest/api/io/realm/log/RealmLog.html">RealmLog</a> - displays the log, there are different levels of logging <br></li><li>  <a href="https://github.com/realm/realm-browser-osx">Realm browser</a> - you need to view the database from a computer.  It works only on Mac.  To view the database on Windows, you can use <a href="https://github.com/uPhyca/stetho-realm">Stetho Realm</a> <br>  There are also several Android libraries for easy <a href="https://github.com/jonasrottmann/realm-browser">viewing of data on the device</a> . <br></li><li> <a href="https://realm.io/docs/java/latest/api/io/realm/Realm.html">WriteCopyTo()</a> ‚Äî          . </li><li> <a href="https://realm.io/docs/java/latest/">NDK Debugging</a> ‚Äî         Crashlytics NDK Crash Reporting <br></li></ul><a name="21"></a><br><h3>  Architecture </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm is great for MV * architectures when the entire implementation hides behind the database interface. All calls and selections occur in the database module (repository), the Observable with automatically closing realm is sent to the top when unsubscribe. Or we take as input the instance realm and perform all the actions with it. When recording objects, we open the realm, write data and close it, only the object to be saved is input. See both examples on </font></font><a href="https://github.com/andrey7mel/realm_example"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alas, the use of Realm (without copyFromRealm) imposes serious restrictions on the use of </font></font><a href="https://github.com/android10/Android-CleanArchitecture"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean architecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It‚Äôs impossible to use different data models for different layers, the whole meaning of live objects and proxy lists disappears. Also, difficulties will arise when creating independent layers and opening / closing Realm, since this operation is tied to the Activity \ Fragment life cycle. A good option would be an isolated layer of receiving data, converting objects and storing them in a database. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm is very useful when building offline-first applications, when we receive all the data for display from the database.</font></font><br><a name="22"></a><br><h3>  useful links </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To continue exploring and debriefing, we recommend the following articles: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three articles from </font></font><a href="https://medium.com/%40Zhuinden/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@Zhuinden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br> <a href="https://medium.com/%40Zhuinden/basics-of-realm-a-guide-to-using-realm-1-2-0-634471c0fe8f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basics of Realm: A guide to using Realm 1.2.0 </font></font></a> <br> <a href="https://medium.com/%40Zhuinden/how-to-use-realm-for-android-like-a-champ-and-how-to-tell-if-youre-doing-it-wrong-ac4f66b7f149"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to use it wrong </font></font></a> <br> <a href="https://medium.com/%40Zhuinden/realm-1-2-0-android-data-binding-1dc06822287f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm 1.2.0 + Android Data Binding</font></font><br></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two articles about Realm integration from </font></font><a href="https://medium.com/%40Viraj.Tank/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@Viraj.Tank </font></font></a> <br> <a href="https://medium.com/%40Viraj.Tank/realm-integration-in-android-best-practices-449919d25f2f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Safe-Integration of Realm in Android production code </font></font><br></a> <a href="https://medium.com/%40Viraj.Tank/deep-integration-of-realm-in-android-production-code-part-2-with-mvp-4cf44ab6289d"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, with MVP</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multithreading, detailed analysis: </font></font><br> <a href="https://realm.io/news/threading-deep-dive/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designing a Database: Realm Threading Deep Dive </font></font><br></a> <a href="https://realm.io/docs/java/latest/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docs - Auto-Refresh </font></font></a> <br> <a href="https://realm.io/docs/java/latest/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docs - Threading</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A recent article on FairBear:</font></font><br> <a href="https://habrahabr.ru/company/fairbear/blog/326152/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to make friends with Realm </font></font><br></a> <a name="23"></a><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realm harder than it seems at first glance. </font><font style="vertical-align: inherit;">However, all the disadvantages are more than covered by its power and convenience. </font><font style="vertical-align: inherit;">Live objects, notifications and Rx, convenient API and many other things make it easy to create applications. </font><font style="vertical-align: inherit;">From competitors, you can select the requery, ObjectBox and GreenDao. </font><font style="vertical-align: inherit;">Realm fully reveals itself when building offline-first applications, when we get all the data from the cache and we need complex samples, as well as constant data updates. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can </font><a href="https://github.com/andrey7mel/realm_example"><font style="vertical-align: inherit;">find</font></a><font style="vertical-align: inherit;"> all the above code </font></font><a href="https://github.com/andrey7mel/realm_example"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on Github.</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/328418/">https://habr.com/ru/post/328418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328406/index.html">The tragedy of one hundred percent code coverage</a></li>
<li><a href="../328408/index.html">Essentialism and decision theory</a></li>
<li><a href="../328410/index.html">‚ÄúThey didn‚Äôt come up with anything, improvise‚Äù or Agile in information security</a></li>
<li><a href="../328412/index.html">Your idea is nonsense.</a></li>
<li><a href="../328416/index.html">Do not you send spam?</a></li>
<li><a href="../328422/index.html">Introduction to OpenCV in relation to the recognition of road marking lines</a></li>
<li><a href="../328424/index.html">Deep Learning against cancer. Intel Contest</a></li>
<li><a href="../328426/index.html">How to become a web developer in 2017 - an action plan</a></li>
<li><a href="../328428/index.html">Welcome to MOSDROID May Meetup May 20</a></li>
<li><a href="../328430/index.html">New tools for organizing effective teamwork</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>