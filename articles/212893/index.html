<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From bubble sorting to genetic algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a brief overview of what genetic algorithms are. Being a novice in bioinformatics, I will start with things that are close to and unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From bubble sorting to genetic algorithms</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/d3c/0b1/0cf/d3c0b10cf4ae3341b3ed33e49ffa20b8.jpg">  This article is a brief overview of what genetic algorithms are.  Being a novice in bioinformatics, I will start with things that are close to and understandable to people of technical specialties: sorting algorithms, then I will go on to describe one of the tasks of genetic programming and what biologists understand algorithms. <br><a name="habracut"></a><br><h4>  Sorting </h4><br>  I think that every programmer implicitly believes that he knows on this subject if not all, then almost everything.  Perhaps, at the moment it is so, and the reader of these lines has studied the third volume of the Art of Programming by Donald Knut.  But let's do an experiment: take your favorite algorithm and try to implement it with a pencil on a piece of paper.  If there is no favorite algorithm, then I suggest sorting by bubble.  Happened?  I have repeatedly offered this task at interviews, but few of the proposed options turned out to be workers, and only a few turned out to be a ‚Äúbubble‚Äù.  Recently, I happened to see the lecture notes on Python, where the teacher gives the following code under the guise of bubble sorting: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bubble_sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(numbers)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(numbers)<span class="hljs-number"><span class="hljs-number">-1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> second <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(first+<span class="hljs-number"><span class="hljs-number">1</span></span>, len(numbers)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> numbers[first] &gt; numbers[second]: numbers[first], numbers[second] = numbers[second], numbers[first]</code> </pre> <br>  The algorithm is working, it will be sorted, but only this is clearly not a ‚Äúbubble‚Äù.  With some stretch, it can be called sorting by sampling, but even here there is an annoying oversight: the advantage of sorting by sampling is to minimize the number of substitutions, that is, the number of times when we swap the elements should be limited to O (n), which is not observed in the above code. <br><br>  In a conversation on the topic of algorithms, it is interesting to reverse the question of quick sorting.  As a rule, people easily answer the question of how good it is: this is both a good algorithmic complexity on average, and no need for additional memory (the stack is usually forgotten).  But then it is interesting to ask, why is it bad, since, apart from her, there are many other algorithms?  Answers to this question are much more scarce and monotonous.  And what are the disadvantages of Quick Sort you can call? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To my satisfaction, sometimes it is possible to meet aesthetes who demonstrate knowledge of exotic methods, for example, gnome sort. <br>  Conclusion: <br>  1. If you want to pass for an interview with an esthete, study a couple of little-known sorting methods; <br>  2. If you yourself accept interviews, learn to distinguish different methods from each other, and then the candidate following paragraph 1 is not enough ... <br><br><h4>  Pancake sorting </h4><br>  Following the tips above, we consider a problem that has no practical meaning, but is interesting from a theoretical point of view: pancake sorting.  Its impracticality lies in the fact that this algorithm does not take into account the number of comparisons of elements at all (it is believed that these operations are very cheap and fast), and the only operation that has a price is to turn the top of a stack of sorted pancakes.  Of course, initially they are arranged in a random order, and the desired result is a kind of tower of Hanoi, when pancakes of a larger diameter lie at the bottom and smaller ones are located at the top. <br><br>  Regarding this task, I would like to note two interesting facts.  First, the method of finding a fairly effective (although not optimal) solution was at one time proposed by the notorious Bill Gates while he was still a student.  This algorithm, proposed in 1979, remained the most effective until 2008, when the result was surpassed.  Secondly, as it was proved later, the problem of finding the optimal solution belongs to the class NP-complete.  Also, Gates and his leader, Christ Papadimitriou, proposed a complicated version of the problem, known as the problem of burnt pancakes. <br><br><h4>  Burnt pancake problem </h4><br>  In this form of the task, each element, in addition to its size, also has a binary attribute ‚Äúdirection‚Äù, that is, each ‚Äúpancake‚Äù has one side burnt and the other is rosy;  the result of solving the problem is a stack, ordered by size, but, in addition to this, all the "pancakes" are burnt side down.  Without going into details, let us say that this problem is also NP-complete, and that, in the general case, its sufficiently effective, but non-optimal solutions are known.  However, there are restrictions on the data, under which the task becomes polynomial.  For the problem in question, such data are <i>simple permutations</i> .  To understand what it is, consider the permutation of numbers from 1 to 7: 2 <b>6475</b> 13. Note that the bold sequence is itself a permutation of numbers from 4 to 7 (called a <i>block</i> ).  Simple permutations are those where there are no non-trivial blocks (blocks of length 1 and n). <br><br>  Behind the figurative formulation of the problem, when the elements are represented by burnt pancakes, it is difficult to discern the fact that it has a biological significance.  However, a common mutation is a revolution in the DNA molecule, and if you count the minimum number of revolutions necessary to convert one molecule to another (without considering smaller point mutations), you can roughly estimate the relationship of organisms.  For example, the human and mouse genomes are only separated by about 120 global mutations;  I confess, I used to believe that between these types of difference much more ... <br><br><h4>  Genetic algorithm for solving the problem of burnt pancakes </h4><br>  In comparative genomics, the algorithm is used for analytically finding the number of mutations that separate organisms, but look at the problem in another projection.  Now we will declare the solution of the analytical task to be the goal, and the living organisms and the processes proceeding in them will be made an instrument for its solution. <br><br>  Bacteria are known to be able to divide, ensuring an exponential growth of the population if they are provided with the necessary conditions;  Of course, after a while the colonies of bacteria will no longer be enough nutrient medium, other factors will also appear that affect the growth of the colony, but this takes time.  Experimentally, we can find out the average time it takes for the bacteria of a given species to develop a global mutation associated with the upheaval of a part of the DNA. <br><br>  Now we set the task for the bacteria.  We genetically modify one of them (biologists like to use E. coli in such experiments), where the antibiotic resistance gene will be broken down into several parts and mixed together, changing not only the order but also the direction of some pieces.  Thus, each inverted and rearranged piece of a gene in our case will be a ‚Äúburnt pancake‚Äù. <br><br>  The task of the bacteria is set, you can start the experiment.  We place it in a nutrient medium and wait for the allotted time, during which one mutation-coup of DNA is expected.  I draw attention to the fact that we consider one mutation: it is unique not for the whole colony (there will be many of these mutations in the colony);  this is just the expected number of coups in each of the living bacteria compared to their progenitor. <br><br>  Is one pancake coupling enough to solve the problem?  We can easily verify this by placing part of the colony in a dangerous environment for it.  The bacteria placed in the antibiotic did not survive, and we continue to monitor the remaining ones.  It will take another two or three periods, and, finally, the group of bacteria placed in the antibiotic will remain alive.  "Collective Intelligence" coped with the task! <br><br><h4>  Results </h4><br>  Of course, the usefulness of the solved problem is unlikely to impress us: in actual experiments performed, the number of sorted ‚Äúpancakes‚Äù does not exceed four, and the number of mutations occurring in the allotted time can be estimated only as probabilistic.  And yet I personally was struck by the fantasy of those biologists who were able to set up the experiment;  Those who could solve the traveling salesman problem by a biological method had no less fantasy (I will leave the details of this experiment beyond the scope of this article).  In many respects, the complexity of the problems solved by genetic algorithms is comparable to quantum computing, and I want to believe that both directions of non-classical calculations will be able to produce results that are not yet achievable in modern conditions. </div><p>Source: <a href="https://habr.com/ru/post/212893/">https://habr.com/ru/post/212893/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212883/index.html">Declarative event binding / handling</a></li>
<li><a href="../212885/index.html">Problem 10 million connections</a></li>
<li><a href="../212887/index.html">Keep the roots (to the 80th anniversary of Nicklaus Wirth)</a></li>
<li><a href="../212889/index.html">Javascript: autocorrection timers</a></li>
<li><a href="../212891/index.html">Ubiquiti AirGrid M5 HP 27dBi - Expansion of a network bridge. Personal experience</a></li>
<li><a href="../212895/index.html">Analysis of application performance as a separate direction in IT</a></li>
<li><a href="../212897/index.html">Helper combining scripts and styles in one file for the old man ZF1</a></li>
<li><a href="../212899/index.html">Brief instruction on how to work with a web-designer (designer's view)</a></li>
<li><a href="../212901/index.html">Job Search Java Middle Developer (observations and impressions)</a></li>
<li><a href="../212907/index.html">PayPal: Adaptive Payments API System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>