<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing: how and why to use PureComponent in React</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="React 15.3 was released on July 29, and the first item in release-notes was adding support for React.PureComponent, which replaces its predecessor pur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing: how and why to use PureComponent in React</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/702/de5/473/702de5473cf84371818c73c2894321d7.png"><br>  React 15.3 was released on July 29, and the first item in release-notes was adding support for React.PureComponent, which replaces its predecessor pure-render-mixin.  This article will discuss why this component is so important and where to use it. <br><a name="habracut"></a><br>  This is one of the most significant ways to optimize react-applications, which can be implemented quite easily and quickly.  Using pure-render-mixin gives a tangible increase in performance, as the number of renders in the application is reduced, and therefore react, in turn, produces much less operations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f7/1a0/470/2f71a04703d2952eb29936a48f317c9b.gif" alt="image"><br><br>  PureComponent changes the lifecycle method shouldComponentUpdate, automatically checking if the component needs to be redrawn.  At the same time, PureComponent will only render if it detects changes in the state or props of the component, which means that in many components you can change the state without having to constantly write 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.someVal !== computedVal) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">someVal</span></span>: computedVal}) }</code> </pre> <br>  In the React source code, provided that the component is ‚ÄúPure‚Äù, and this check is carried out: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState); }</code> </pre><br>  The use of shallowEqual indicates that a shallow params and state check occurs, so the comparison will not occur across deeply nested objects, arrays. <br><br>  Deep comparison is a very expensive operation.  If PureComponent caused it every time, it would do more harm than good.  No one bothers to use proven shouldComponentUpdate to manually determine the need for a new render.  The simplest option is direct comparison of parameters. <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextProps.user.id === props.user.id; }</code> </pre> <br>  You can also use immutable data.  The comparison in this case becomes very simple, since the existing variables do not change, but new ones are always created.  Libraries like Immutable.js are our sure ally. <br><br><h2>  Application features </h2><br>  PureComponent saves us time and allows us not to write extra code, but it is not a panacea.  It is important to know the features of its use, otherwise the utility is lost.  Since the PureComponent implies a shallow check, its props and state changes may remain ignored.  For example, in the parent component there is a render and click handler: <br><br><pre> <code class="javascript hljs"> handleClick() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.items; items.push(<span class="hljs-string"><span class="hljs-string">'new-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">items</span></span>: items}); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; &lt;button onClick={this.handleClick} /&gt; &lt;ItemList items={this.state.items} /&gt; &lt;/div&gt; ); }</code> </pre><br>  If the ItemList component is made PureComponent, then when items are changed after pressing a button, nothing will happen.  This happens because this.state.items when comparing will be equal to the old version of this.state.items, although its contents have changed.  However, this is easy to fix by removing mutations, for example, like this: <br><br><pre> <code class="javascript hljs">handleClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prevState</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">words</span></span>: prevState.items.concat([<span class="hljs-string"><span class="hljs-string">'new-item'</span></span>]) })); }</code> </pre><br>  PureComponent will always re-render components if it receives links to different objects.  This means that if we do not want to lose the benefits of PureComponent, such constructions should be avoided: <br><br><pre> <code class="javascript hljs">&lt;Entity values={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.values || []}/&gt;</code> </pre><br>  A new array, even though it is empty, will always force the component to be redrawn. <br>  To avoid this is very simple, for example, using DefaultProps, in which you can set an initially empty state of the variable being transferred.  Also very often you can see the following components: <br><br>  &lt;CustomInput onChange = {e =&gt; this.props.update (e.target.value)} /&gt;; <br>  When creating them, a new function will always be created, which means that PureComponent will see new data every time.  This is treated, for example, by bind the desired function in the component's constructor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } update(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.update(e.target.value); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyInput</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.update}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">; }</span></span></code> </pre><br>  Also, any component that contains child elements created in JSX will always return false on shallowequal checks. <br><br>  It is important to remember that PureComonent skips drawing not only the component itself, but all its ‚Äúchildren‚Äù, so it is safest to use it in the presentational components, without ‚Äúchildren‚Äù and without dependence on the global state of the application. <br><br><h2>  What is the result </h2><br>  In fact, the transition to PureComponent is quite simple, if you know a number of features related to JS rather than React.  In many components I replaced: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{‚Ä¶}</code> </pre><br>  on: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{‚Ä¶}</code> </pre><br>  ... and they continued to work quietly, and with increased productivity. <br><br>  So try and use, the component is very useful. <br><br>  EDIT <br>  Thanks <a href="https://habrahabr.ru/users/raveclassic/" class="user_link">raveclassic</a> for a useful note.  In case the pure component has children, all child components dependent on the context change will not react to changes if the contextTypes is not declared in the parent pure component. </div><p>Source: <a href="https://habr.com/ru/post/318222/">https://habr.com/ru/post/318222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318212/index.html">Secrets of a successful update: interface, backend, application structure</a></li>
<li><a href="../318214/index.html">5 really free non-linear video editors for Windows</a></li>
<li><a href="../318216/index.html">DevOps - speed? Yes speed</a></li>
<li><a href="../318218/index.html">From Intranet to Digital Workplace</a></li>
<li><a href="../318220/index.html">SetGoroutineName</a></li>
<li><a href="../318224/index.html">.NET wrappers for native C ++ / CLI libraries</a></li>
<li><a href="../318226/index.html">NetApp SnapLock ‚Ñ¢ - Licensed Data Protection Feature (WORM)</a></li>
<li><a href="../318228/index.html">Hacking on board the aircraft</a></li>
<li><a href="../318230/index.html">Information hygiene in a country with non-free Internet</a></li>
<li><a href="../318232/index.html">What is enterprise architecture, and why was Zachman wrong?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>