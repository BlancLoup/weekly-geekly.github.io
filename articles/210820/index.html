<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About using $ .Deferred to work with asynchronous tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all! 

 In this article, I would like to share with you thoughts on how, in practice, you can use the asynchronous process mechanism provided...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About using $ .Deferred to work with asynchronous tasks</h1><div class="post__text post__text-html js-mediator-article">  Hello to all! <br><br>  In this article, I would like to share with you thoughts on how, in practice, you can use the asynchronous process mechanism provided by the jQuery library from version 1.5 called deferred, ‚Äúdeferred‚Äù, as well as with related objects and methods . <br><br>  Of course, more than a dozen articles have already been written on the topic of working with a <a href="http://habrahabr.ru/search/%3Fq%3Ddeferred">deferred / promise</a> pair.  I set myself my goal to provide such a set of knowledge that would give a beginner, firstly, the opportunity to forget about their fears of incomprehensible and complex and, secondly, to take another step towards writing clear and well-structured code that works with asynchronous processes .  I would like to focus my and your attention on the problems that are easily resolved using deferred, on the assumptions and typical patterns of using this object. <br><a name="habracut"></a><br><h1>  Asynchronous processes </h1><br>  So, an asynchronous process assumes that it can be executed in parallel with other code, and the result of its execution is not immediately available to the calling program.  This, of course, is <a href="http://ilyabirman.ru/meanwhile/2011/09/14/1/">strange</a> : are not <em>synchronous</em> actions, those that are performed in parallel with each other, and not sequentially, one after the other?  To justify established terminology: saying that the process is ‚Äúsynchronous,‚Äù we proceed from the fact that the moment when its result appears, i.e.  The end of one process, coincides with the moment of the beginning of the execution of some next, and their end and the beginning are <em>synchronized</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = readValueBy(key); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(result);</code> </pre> <br>  And the ‚Äúasynchronous‚Äù property says that the result of the process will come, but the exact place in the program where this happens cannot be specified.  To describe the logic of processing the results of an asynchronous process, programmers resort to callback functions, or callback functions, transferring the results of work to them in the form of its actual input parameters. <br><br><h2>  An example of an asynchronous process </h2><br>  We are used to the fact that an asynchronous process can be an ajax request.  And when we are faced with the task of writing a call to the server using the convenience of jQuery, we will write about the following, without a second thought: <br><br><pre> <code class="javascript hljs">$.post(<span class="hljs-string"><span class="hljs-string">"ajax/test.html"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> data </span></span></span><span class="hljs-function">) </span></span>{ $( <span class="hljs-string"><span class="hljs-string">".result"</span></span> ).html( data ); });</code> </pre><br>  Moreover, this is an example from the official jQuery documentation for the <code>$.post()</code> method ( <a href="http://api.jquery.com/jQuery.post/">see</a> ). <br>  Note that the second parameter in the method is a callback function, which takes the result as the first argument - the server response. <br><br>  Here is an alternative version of such a request: <br><br><pre> <code class="javascript hljs">$.ajax({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"ajax/test.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: data, <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> data </span></span></span><span class="hljs-function">) </span></span>{ $( <span class="hljs-string"><span class="hljs-string">".result"</span></span> ).html( data ); }, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span>: dataType });</code> </pre><br>  In this example, the successful completion handler is passed as a property of the object along with other parameters. <br><br>  But, starting with jQuery 1.5, ajax methods ($ .get, $ .post, $ .ajax) can be called without passing them handlers, since  these methods return not just an XMLHTTPRequest object, but this object, overloaded with methods that <em>implement the Promise interface</em> .  From a practical point of view, this means that by initiating an asynchronous process (= request to the server), we can not hurry to indicate callbacks to successful execution, to handle an error situation, etc., and not to limit ourselves to one when we need to specify them .  We can save the server request in a variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.post(<span class="hljs-string"><span class="hljs-string">'ajax/'</span></span> + key, data); } <span class="hljs-comment"><span class="hljs-comment">// .. var requestData = { id: '79001' }, storeDataRequest = api('get_store_by_id', requestData); //   </span></span></code> </pre><br>  ... and subsequently "hang" all the callbacks we need: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addStandardHandlers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, requestData, model</span></span></span><span class="hljs-function">) </span></span>{ request.done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,        //        model.received(requestData, data &amp;&amp; data.payload); }).fail(function(){ //      //   ,        model.received(requestData, null); }); } function addUIHandlers(request, $messageHolder) { //   .. request.done(function(data){ // ..   "", $messageHolder.text('Success'); }).fail(function(){ //    - // ",  " $messageHolder.text('Error, please retry.'); }).always(function(){ //   ,   ,   , //        window.setTimeout(function(){ $messageHolder.fadeOut(); }, 3000); }); } //  ,    addStandardHandlers(storeDataRequest, requestData, context.getModel()); //  ,   UI addUIHandlers(storeDataRequest, $('.main_page-message_holder'));</span></span></code> </pre><br>  If there is a hundred and one place in our program where we need to contact the server, and the response structure everywhere requires the same type of processing, it is logical not to produce the same code as the handlers in the server call sites, but to ‚Äúhang‚Äù for each instance of the request depending on the need, using knowing that ajax requests are now promises.  See the promises below. <br><br><h2>  Other asynchronous processes </h2><br>  Let's step back and list some other asynchronous processes that we have to deal with: <br><br><ul><li>  loading of one or several pictures (with the subsequent establishment, what sizes at it, and acceptance of some decision when pictures were loaded or gave failure) </li><li>  document ready state ( <em>dom ready</em> event) </li><li>  time out onset </li><li>  completion of long-term calculations implemented on the iterator and zero timeout </li><li>  the completion of the animation on the elements of the page </li><li>  the result of the dialog box (‚ÄúOK / Cancel‚Äù) (for example, the dialog box can be closed with the Cancel button, with a cross on top, and even clicking into the background around the window, but it can still be interpreted as a failure to achieve the operation suggested in the dialog). </li><li>  simultaneous occurrence of heterogeneous events (for example, compliance with all conditions in the input form; loading of all pictures from the list; and downloading a file with a template) or the occurrence of at least one of the expected events (the ‚Äúreload‚Äù button with a timeout of 10 seconds). </li></ul><br><br><h1>  What problems does Deferred solve? </h1><br>  Let us think about situations when we need something more than passing a callback as a parameter to a function or an object property (as we saw in simple examples of using ajax above): <br><br><ol><li>  How to assign more than one callback for the same process completion event? </li><li>  How to recognize the onset of the expected event after its completion? </li><li>  How to group all callback handlers according to the types of the processed situation around a single process? </li></ol><br><br>  I remember how long ago we solved the problem of the <em>first item</em> for multiple onload event handlers: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oldHandler</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldHandler) oldHandler(); <span class="hljs-comment"><span class="hljs-comment">// new code here.. }; })(window.onload);</span></span></code> </pre><br>  Well, that is already a problem of bygone days.  Today, no one does (hopefully) and it‚Äôs enough to remember about $ .on (..) (working with jQuery) if we are talking about document events.  And about $ .Deferred () - when we talk about everything else.  (Sorry for deliberately exaggerating, it serves the purpose of the story.) Well, ‚Äúwhat to do with multiple handlers?‚Äù Is another question.  Suppose one, for example, you can parse the data, and the other - hide the busy indicator or change the status text, as suggested in the example above.  Previously, we had to shove everything, and work with the model, and with the display, in one handler, now we have the freedom to share. <br><br>  Also, several years ago, the <em>second item</em> was solved by some sort of clumping around the flag variable, to which the body of the handler was closed.  I clearly remember how we thought, how to tell our widget that <em>dom ready</em> had already taken place by the time it was uploaded.  But there was <code>$(function(){ ... })</code> , which is now implemented in jQuery using deferred.  And this means that the callback in this construction will work even when the code is executed after the occurrence of the <em>dom ready</em> event itself.  The scheme of use is simple.  "Hang" handler.  If the process is already terminated, the handler is executed immediately.  If not, the handler (all handlers of this type) will be executed at the time of its occurrence in the future. <br><br>  Let's look towards deferred to solve the <em>third problem</em> .  With deferred, we have a group of handlers to <em>successfully</em> complete the process, there is - for <em>an unsuccessful</em> (erroneous or unforeseen) completion, there is a group that will be called <em>at any ending</em> (‚Äúlove‚Äù).  There is also a group in which handlers can track the <em>progress of</em> the operation. <br><br>  So, we looked at three problems solved using $ .Deferred (). <br><br><h1>  Prerequisites for using Deferred </h1><br>  Let's mark the conditions when we need to think about using deferred in our program. <br><br>  <em>We will think about using Deferred then ..</em> <br><br><ol><li>  when we need to wait for the onset of a state and save the indicator of its occurrence and / or related data.  Waiting for a <strong>condition to occur</strong> is the first condition. </li><li>  The second condition is when we think about the <strong>relative position of the</strong> code of a lengthy process and the code of processing its change / completion.  Deferred allows you to "untie" at the place of determining the method of obtaining data / results from determining the method of their reception and subsequent processing. </li></ol><br><br>  Notice that the distinguishing feature of the first condition is the <em>onset of the state</em> , and not just the moment at which it happened.  This distinguishes Deferred from jQuery's regular <em>event</em> handling mechanisms.  The event occurred, caused handlers, and is forgotten.  The state of the process defined by Deferred, having arrived, is preserved as long as we store Deferred. <br><br>  The second premise.  Let's take a look at the code: <br><br><pre> <code class="javascript hljs">$.post(<span class="hljs-string"><span class="hljs-string">"ajax/cart"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> data1 </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  1. //   data1 // if (data1 &amp;&amp; data.success) .... //  2. //      var processedData1 = data1.payload; //  3. //      : $.post("ajax/shipping", processedData1, function( data2 ) { //  1. //  2. var processedData2 = data2.payload; //  3. $.post("ajax/payment", data2, function( data3 ) { //  1. //  2. var processedData3 = data3.payload; //  3.    $( ".result" ).html( processedData3 ); }); }); });</span></span></code> </pre><br>  The first request receives data on the basis of which the second request is made, and on the basis of its result, subsequent ones, etc.  There are only three requests and the logic is only indicated, but we already have the famous anti-pattern ‚ÄúPyramid of Evil Rock‚Äù (pyramid of doom). <br><br>  In one of the projects in which I had the opportunity to participate, the task of ‚Äúwrapping up‚Äù a hidden payment system site (which was written in CGI and was unsupported, was solved, so there was no talk of styling, modifying and embedding it in our site) on WordPress, which is ‚Äúin the shadow,‚Äù using asynchronous get- and post-requests, emulated user actions (entering the cart page, recalculating goods, sending a form, receiving a confirmation page, sending an address, sending a second form, entering payment data ..)  I know I know.  This is bad.  I am ashamed to recall the details.  At one time I was afraid to go there and refactor, because  "It worked."  But the most terrible thing is that the method containing the payment logic had either six, or seven levels of nesting and stretched screens by ten in height.  What can we say, with this solution, the choice between supporting only this method and mastering CGI from scratch became not obvious, with a slight advantage in favor of CGI.  What would I do with a similar decision now (let's pretend that imitating the sequence of making a purchase is ‚Äúokay‚Äù)? <br><br>  First, I would break the logic of the method into steps.  Let me demonstrate, based on the example above: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseStep01_CartDataRequestFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.post(<span class="hljs-string"><span class="hljs-string">"ajax/cart"</span></span>, input); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseStep02_UpdateShippingInfoRequestFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.post(<span class="hljs-string"><span class="hljs-string">"ajax/shipping"</span></span>, input); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseStep03_SubmitPaymentDetailsRequestFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.post(<span class="hljs-string"><span class="hljs-string">"ajax/payment"</span></span>, input); }</code> </pre><br>  Secondly, the request is not enough to send, it is necessary to provide as a general functionality for the analysis of answers: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   : // -  -  -  //   /   function handleResponseData(request, specificLogic) { //    -promise,    fail //   ,  AJAX  ,   //        success==true // (          ) //      ,      return $.Deferred(function(def){ request .fail(def.reject) .done(function(data){ if (!data || !data.success) return def.reject(); if (!specificLogic) return def.resolve(data); try { def.resolve(specificLogic(data)); } catch (e) { def.reject(e); } }); }).promise(); }</span></span></code> </pre><br>  ... and the logic for processing the result of each request separately.  This logic is compatible with the above: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.   .  . var step01_CartDataPromise = handleResponseData( purchaseStep01_CartDataRequestFor(data), function (data){ //       . //    -  ,    fail. if (!data.cart) throw new Error('Cart info is missing'); //  -  ,     cartInfo  . return data.cart; }), // &lt;- , ..         . //  2.       1. //       : // step02_ShipInfoPromise = step01_CartDataPromise.then().done(function(cartInfo){... // then()   ,      // .      jQuery step02_ShipInfoPromise = step01_CartDataPromise.then(function(cartInfo){ return handleResponseData( purchaseStep02_UpdateShippingInfoRequestFor({ id: cartInfo.id}), function (data){ if (!data.shipping) throw new Error('Shipping info is missing'); return { cart: cartInfo, shipping: data.shipping }; }); }), //  3.     2. step03_PaymentResultPromise = step02_ShipInfoPromise.then(function(prePurchaseInfo){ return handleResponseData( purchaseStep03_SubmitPaymentDetailsRequestFor(prePurchaseInfo), function (data){ if (!data.payment) throw new Error('Payment gone wrong'); return data.payment; }); }); // &lt;-    //          ,  //       //     done()  then()  function(paymentInfo)..  //    function(prePurchaseInfo)..   . // .    2. step03_PaymentResultPromise.then(function(paymentInfo){ $('.result').html( paymentInfo.message ); });</span></span></code> </pre><br><br>  Cons of such a decision: <br><br><ul><li>  the code is written in more lines because of the logic framing functions </li><li>  you need to remember how the <code>$.Deferred(..)</code> constructor works, as well as the method of linking two promises in a one-to-one sequence - <code>.then(..)</code> - and remember that inside you must not forget to give promises, those.  do not forget to put <code>return</code> before calling the function <code>handleResponseData</code> , which returns the promise. </li></ul><br><br>  Pros: <br><br><ul><li>  Separation of the data sending logic and the processing logic of the response received </li><li>  The location of the logic of making decisions about the success of the operation in one place and the inability to influence this decision from outside.  A bunch of <code>$.Deferred(..).promise()</code> in the <code>handleResponseData()</code> method. </li><li>  The location of the logic of making a decision about the success of the same operation at its different stages.  Notice the <code>def.reject(..)</code> calls inside <code>handleResponseData()</code> .  The operation is considered unsuccessful not only if the server refused to work, but also if it worked correctly, but did not return enough data.  And also, if the data has not been validated after processing (branch <code>catch(e){ .. }</code> ).  Now think about how we would implement it without using $ .Deferred. </li><li>  Better structuring of logic, lowering its nesting, increasing maintainability. </li></ul><br><br>  Few would argue that the advantages outweigh both the number and quality. <br><br>  It seems I have demonstrated the background.  Let's go further.  Before proceeding with the examples, I promise a few words about promises. <br><br><h1>  Promise </h1><br>  Having a reference to the deferred object, the program has the ability to control the result of the process flow (not the process itself, although sometimes it) and ‚Äúinform‚Äù all listeners how it ended.  But the promise object, or ‚Äúpromise‚Äù, associated with this deferred object, gives the program a set of methods exclusively for ‚Äúhearing‚Äù.  (It is interesting to note that in a Wikipedia article on this topic such a readonly object is called futures (future), and the promise is what $. Deferred in jQuery. Try not to get confused.) In fact, this separation of powers warns a number of awkward situations when the code wants to do what he is ‚Äúnot supposed to do.‚Äù <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> def = $.Deferred(); <span class="hljs-comment"><span class="hljs-comment">//   , //  "" def.resolve()  def.reject() // //  readonly- promise, //   def //  ""  var promise = def.promise()</span></span></code> </pre><br>  Most often, the most convenient and secure way to use the reference to deferred is to define its logic within the function passed by the parameter when creating it: <br><br><pre> <code class="javascript hljs">$.Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       , //  resolve()  reject() //    . });</span></span></code> </pre><br>  Such use can immediately be ‚Äúgiven away‚Äù (return), not forgetting to close access to this object by calling <code>.promise()</code> . <br><br>  A simple example.  The onset of the timeout determines the successful completion of the process. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doneTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timeout</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(def.resolve, timeout); }).promise(); }</code> </pre><br>  It seems that I have fulfilled my promise to tell about the promises.  Examples <br><br><h1>  Examples </h1><br>  I will say that some time ago I absolutely could not think of deferred / promise concepts and drew inspiration from the examples <a href="http://learn.jquery.com/code-organization/deferreds/examples/">on the official website</a> . <br><br><h2>  Loading pictures </h2><br>  In particular, there I became acquainted with the procedure for controlling the loading of images.  But then it occurred to me to add it so that it would be possible to recognize not only whether the picture is loaded or not, but also its dimensions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loadImage = createCache(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">defer, url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ image.onload = image.onerror = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } defer.then( cleanUp, cleanUp ); image.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ defer.resolve( url, { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: image.width, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: image.height }); }; image.onerror = defer.reject; image.src = url; });</code> </pre><br><br><h2>  Determining the occurrence of a document readiness </h2><br>  We already talked about <code>$(function(){.. })</code> above.  Let me just give a way to get the object-promise of the availability of the document in its pure form: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> domReadyPromise = $.ready.promise();</code> </pre><br><br><h2>  Onset of timeout state </h2><br>  We have already considered an example with a timeout, the occurrence of which entails the successful completion of the process, <code>doneTimeout()</code> .  But now we also need an option, in which the timeout will be considered that the process is completed with an error.  Here he is: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timeout</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(def.reject, timeout); }).promise(); }</code> </pre><br>  We can implement the logic of the button, which does not care whether you press it or not, because after 10 seconds it will click.  Does it happen?  Who can this come to mind? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeToSubmit = $.Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ doneTimeout(<span class="hljs-number"><span class="hljs-number">10000</span></span>).done(def.resolve); $(<span class="hljs-string"><span class="hljs-string">'.submissionButton'</span></span>).one(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ def.resolve(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }); }).promise(); timeToSubmit.done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    });</span></span></code> </pre><br><br><h2>  Completion of the animation on the page elements </h2><br>  Sometimes I need to consider the process completed not at the moment when the data from the server arrives, but when we accurately show it with a pop-up message and then this message is extinguished.  We can, of course, make a binding like this (this is a revised example with one of the links at the end of the note): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animationPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.Deferred(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ $element.fadeIn( <span class="hljs-number"><span class="hljs-number">10000</span></span> , def.resolve ); }).promise(); }</code> </pre><br>  however, it is completely unnecessary.  Each jQuery element supports a promise () call, returning a promise to end the animation on it: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animationPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $element.fadeIn( <span class="hljs-number"><span class="hljs-number">10000</span></span> ).promise(); }</code> </pre><br>  "Listen" to the end of the animation can be as follows: <br><br><pre> <code class="javascript hljs">animationPromise($(<span class="hljs-string"><span class="hljs-string">'#foo'</span></span>)).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Animation is finished'</span></span>); });</code> </pre><br>  or simply: <br><br><pre> <code class="javascript hljs">$element.fadeIn( <span class="hljs-number"><span class="hljs-number">10000</span></span> ).promise().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Animation is finished'</span></span>); });</code> </pre><br>  Do not forget that in this way you should not ‚Äústring‚Äù one animation onto another.  To do this, there are more concise regular ways: <br><br><pre> <code class="javascript hljs">$element.fadeIn( <span class="hljs-number"><span class="hljs-number">10000</span></span> ).fadeOut( <span class="hljs-number"><span class="hljs-number">10000</span></span> );</code> </pre><br><br><h2>  Maintenance of the modal dialogue </h2><br>  There are many examples of libraries that improve user interaction with the interface of the page, which, however, sometimes forget about programmers. <br><br>  An example is the implementation of a modal window operation in Twitter Bootstrap ( <a href="http://getbootstrap.com/javascript/">see here</a> ).  There are methods - ‚Äúshow‚Äù and ‚Äúhide‚Äù, there are events ‚Äúwindow open‚Äù, ‚Äúwindow hidden‚Äù.  But how can we, programmers, find out what choice the user made in this window?  Those.       ,    <em></em>  ?             ? ,       Cancel,   ,       ,      ,   ,   . <br><br>            Twitter Bootstrap,  , ,   .       . <br><br><h2>     </h2><br>        .           : -    .    ,          ,       . <br><br>  jQuery    <code>$.when()</code> ,   <em></em> ,    <em></em> ,          ,   ‚Äî     .  ‚Äî    .    (=)  ,     ,    ‚Äî  (=). <br><br>  ,   ,   .  Those.  ,  ,          ,         .       . <br><br>       : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// fail if and only if all fail: function failIifAllFail(_promise_array){ var promises = [].slice.apply(arguments), count = promises.length; return $.Deferred(function(def){ //      var done = 0, fail = 0; //             //   check() ,       //     $.each(promises, function wrap(key, p){ p.done(function(){ done++; check(); }).fail(function(){ fail++; check(); }); }); function check(){ if ((done + fail) &lt; count) return; if (fail === count) def.resolve(); else def.reject(); } }).promise(); }</span></span></code> </pre><br><br><h2>     </h2><br>   ‚Äî ,  , , ‚Äî   . ,     ,   ,     , ,  -,     - ,   ‚Äî     .      .  ‚Äî   . <br><br>       ,    ,     . <br><br>  Thanks for attention! <br><br><h1>  Related links </h1><br><ul><li> <a href="http://en.wikipedia.org/wiki/Futures_and_promises">Futures and promises ‚Äî    </a> </li><li> : <a href="http://habrahabr.ru/post/112960/"> Deferred   jQuery 1.5 ‚Äî   1.02.2011</a> </li><li> : <a href="http://habrahabr.ru/post/204456/">     $.Deferred  ‚Äî  2.12.2013</a> </li><li> : <a href="http://habrahabr.ru/post/193598/">   Deferred/Promise ‚Äî   27.09.2013</a> </li><li> <a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You're Missing the Point of Promises ‚Äî     14.10.2012</a> </li><li> : <a href="http://www.slideshare.net/cbas/promise-pattern-13575574">Promise pattern, Jul 08, 2012</a> </li><li> : <a href="http://www.slideshare.net/Aaronius/patterns-andprinciples-20437005">JavaScript Patterns and Principles, May 03, 2013</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/210820/">https://habr.com/ru/post/210820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210808/index.html">We are not building our analogue Google Calendar in 30 lines</a></li>
<li><a href="../210812/index.html">Method of comparing algorithms and for what it may still be useful</a></li>
<li><a href="../210814/index.html">We do automatic watering of a room flower on Arduino in 15 minutes</a></li>
<li><a href="../210816/index.html">Creating and using Matlab clusters</a></li>
<li><a href="../210818/index.html">Resurrection Sharepoint or how not to burn at the stake of the Inquisition</a></li>
<li><a href="../210822/index.html">Better to lose a day, and then teleport wherever you want and how much you want</a></li>
<li><a href="../210824/index.html">Splitting web pages into semantic blocks</a></li>
<li><a href="../210826/index.html">About comparing and optimizing keyboard layouts</a></li>
<li><a href="../210828/index.html">Nanex: A Nightmare on Elm Street for High-Speed ‚Äã‚ÄãTrading, Part 4</a></li>
<li><a href="../210830/index.html">The controller is a central home, all-powerful KCD-V-2-12</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>