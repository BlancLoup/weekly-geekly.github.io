<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Async / await in C #: pitfalls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to discuss the pitfalls that are most often encountered when working with async / await features in C #, and also to write about how to g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Async / await in C #: pitfalls</h1><div class="post__text post__text-html js-mediator-article">  I would like to discuss the pitfalls that are most often encountered when working with async / await features in C #, and also to write about how to get around them. <br><a name="habracut"></a><br><h2>  How async / await works </h2><br>  The async / await insides are well described by Alex Davies in <a href="http://www.amazon.com/Async-C-5-0-Alex-Davies/dp/1449337163">his book</a> , so I’ll only briefly describe them here.  Consider the following sample code: <br><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFirstBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream fs1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(filePath1, FileMode.Open)) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream fs2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(filePath2, FileMode.Open)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fs1.ReadAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 await fs2.ReadAsync(new byte[1], 0, 1); // 2 } }</span></span></code> </pre> <br><br>  This function reads one byte of the two files, the paths to which are passed through parameters.  What happens in the lines “1” and “2”?  Will they be executed in parallel?  Not.  This function will be “split” by the “await” keyword into three parts: the part preceding “1”, the part between “1” and “2”, and the part following “2”. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The function will start the new <a href="http://enterprisecraftsmanship.com/2014/12/13/io-threads-explained/">I / O bound thread</a> in the “1” line, transfer the second part of itself (the part between “1” and “2”) as a callback and return control.  After the I / O thread has completed its work, a callback will be called and the method will continue execution.  The method will create another I / O stream in row “2”, pass it a third part of itself as a callback, and return control again.  After the second I / O thread completes execution, the rest of the method will run. <br><br>  The magic here is due to the compiler, which converts methods marked with the keyword "async" into a finite state machine, in the same way as it converts <a href="https://msdn.microsoft.com/en-us/library/dscyy5s0.aspx">iterator methods</a> . <br><br><h2>  When to use async / await? </h2><br>  There are two main scenarios in which the use of async / await is preferred. <br><br>  First of all, this feature can be used in thick clients to provide users with a better user experience.  When a user presses a button, starting a heavy computational operation, the best way out is to perform this operation asynchronously, without blocking the flow UI.  Before .NET 4.5, this logic required much more effort.  Now it can be programmed like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnRead_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(“File path”, FileMode.Open)) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (StreamReader sr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(fs)) { Content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sr.ReadToEndAsync(); } btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  Please note that the Enabled flag in both cases is set by the UI thread.  This approach eliminates the need to write such ugly code: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (btnRead.InvokeRequired) { btnRead.Invoke(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><br>  In other words, the entire “light” code is executed by the calling thread, while the “heavy” parts are delegated to a separate thread (I / O or CPU-bound).  This approach can significantly reduce the amount of effort required to synchronize access to UI elements, since  they are only managed from the UI stream. <br><br>  Secondly, async / await can be used in web applications for better thread utilization.  The ASP.NET MVC team has made asynchronous controllers very easy to implement.  You can simply write an action method like the example below and ASP.NET does the rest of the work: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(“File path”, FileMode.Open)) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (StreamReader sr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(fs)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sr.ReadToEndAsync(); <span class="hljs-comment"><span class="hljs-comment">// 1 } } }</span></span></code> </pre><br><br>  In this example, the workflow executing the method starts a new I / O stream on line “1” and returns to the thread pool.  After the I / O thread finishes, the CLR selects a new thread from the pool and continues the method execution.  Thus, CPU-bound threads from the thread pool are used much more economically. <br><br><h2>  Async / await in C #: pitfalls </h2><br>  <b>If you are developing a third-party library, it is very important to always configure await so that the rest of the method is executed by an arbitrary thread from the pool.</b>  In other words, in the code of third-party libraries you should always add ConfigureAwait (false). <br><br>  First of all, third-party libraries usually do not work with UI controls (unless of course this is not a UI library), so there is no need to bind a UI thread.  You can increase performance slightly by allowing the CLR to execute your code with any thread from the pool.  Secondly, using the default implementation (or explicitly stamping ConfigureAwait (true)), you leave a potential hole for deadlocks.  Consider the following example: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button1_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = DoSomeWorkAsync().Result; <span class="hljs-comment"><span class="hljs-comment">// 1 } private async Task&lt;int&gt; DoSomeWorkAsync() { await Task.Delay(100).ConfigureAwait(true); //2 return 1; }</span></span></code> </pre><br><br>  Clicking on the button here leads to deadlock.  The UI thread starts a new I / O thread on line “2” and goes into sleep mode on line “1”, waiting for the completion of work.  After the I / O thread finishes execution, the rest of the DoSomeWorkAsync method is passed to the calling (UI) thread for execution.  But he is at this time in sleep mode, waiting for the completion of the method.  Dedlock. <br><br>  ASP.NET behaves the same way.  Despite the fact that in ASP.NET there is no dedicated UI thread, the code in the controller's action-ah can not be executed by more than one workflow at the same time. <br><br>  Of course, we can use await instead of accessing the Result property to avoid deadlock: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button1_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> DoSomeWorkAsync(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomeWorkAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  But in .NET there is still at least one case in which you can’t get around the deadlock.  You cannot use asynchronous methods inside ASP.NET MVC child action, because  they are not supported.  Thus, you will have to access the Result property directly and if the asynchronous method that is called by your controller is not configured correctly, you will get deadlock.  For example, if you try to write the following code and SomeAction accesses the Result property of an asynchronous method that was not configured via ConfigureAwait (false), you will again get a deadlock: <br><br><pre> <code class="hljs css">@<span class="hljs-keyword"><span class="hljs-keyword">Html</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Action</span></span>(“<span class="hljs-keyword"><span class="hljs-keyword">SomeAction</span></span>“, “SomeController“)</code> </pre><br><br>  <b>Users of your libraries usually do not have direct access to the code of these libraries, so always put ConfigureAwait (false) in advance in your asynchronous methods.</b> <br><br><h2>  How not to use PLINQ and async / await </h2><br>  Consider an example: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button1_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ReadFileAsync(); btnRead.Enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFileAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Run(() =&gt; <span class="hljs-comment"><span class="hljs-comment">// 1 { using (FileStream fs = new FileStream(“File path”, FileMode.Open)) using (StreamReader sr = new StreamReader(fs)) { return sr.ReadToEnd(); // 2 } }); }</span></span></code> </pre><br><br>  Is this code executed asynchronously?  Yes.  Is this code a valid example of writing asynchronous code?  Not.  The UI thread here starts a new CPU-bound thread on line “1” and returns control.  This thread then starts a new I / O thread on line “2” and goes into sleep mode, waiting for execution. <br><br>  What is going on here?  Instead of creating a single I / O stream, we create both a CPU stream on the “1” line and an I / O stream on the “2” line.  This is a waste of threads.  To fix the situation, we need to use the asynchronous version of the Read method: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFileAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(“File path”, FileMode.Open)) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (StreamReader sr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(fs)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sr.ReadToEndAsync(); } }</code> </pre><br><br>  One more example: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequests</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _urls.AsParallel().ForAll(url =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); httpClient.PostAsync(url, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(“Some data”)); }); }</code> </pre><br><br>  It looks like we're sending requests in parallel, isn't it?  Yes, it is, but here we have the same problem as in the previous example: instead of creating a single I / O stream, we create both I / O and CPU-bound stream for each request.  You can fix the situation using the Task.WaitAll method: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendRequests</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { IEnumerable&lt;Task&gt; tasks = _urls.Select(url =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> httpClient.PostAsync(url, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringContent(“Some data”)); }); Task.WaitAll(tasks.ToArray()); }</code> </pre><br><br><h2>  Is it always necessary to perform I / O operations without binding CPU-bound threads? </h2><br>  Depends on the situation.  In some cases this is not possible, in some cases it introduces too much complexity to the code.  For example, in NHibernate there are no possibilities for asynchronous loading of data from the database.  EntityFramework, on the other hand, does have it, but using it does not always make sense. <br><br>  Also, thick clients (for example, WPF or WinForms applications) usually do not have large loads, so for such an optimization for the most part is not necessary.  But in any case, you need to know what is happening “under the hood” of this feature in order to be able to make a conscious decision in each specific case. <br><br>  Link to original article: <a href="http://enterprisecraftsmanship.com/2014/12/20/pitfalls-of-async-await/">Async / await in C #: pitfalls</a> </div><p>Source: <a href="https://habr.com/ru/post/257221/">https://habr.com/ru/post/257221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257211/index.html">Creating a Landing Page Design</a></li>
<li><a href="../257213/index.html">Connecting D-link IP phones to 3CX Phone System via integrated L2TP VPN tunnel</a></li>
<li><a href="../257215/index.html">EPAM, get me a genome</a></li>
<li><a href="../257217/index.html">Conceptual modeling: How Many? How Much?</a></li>
<li><a href="../257219/index.html">Event video surveillance over the Internet for apartment and private homes. Virtual concierge</a></li>
<li><a href="../257223/index.html">Spring Boot: from start to production</a></li>
<li><a href="../257225/index.html">vCloud Director for the smallest (part 2): creating virtual machines</a></li>
<li><a href="../257227/index.html">Remote work or freelancing in the outback. Aspects of communication. Part 1</a></li>
<li><a href="../257229/index.html">The digest of interesting materials for the mobile developer # 101 (April 27-May 4)</a></li>
<li><a href="../257231/index.html">Can we talk about the applicability of the law of Moore in the field of IaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>