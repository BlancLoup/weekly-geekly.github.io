<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a plugin for GStreamer on MS Visual Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have always been interested in real-time video processing applications. On Habr√©, I read a series of articles on the GStreamer multimedia framework:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a plugin for GStreamer on MS Visual Studio</h1><div class="post__text post__text-html js-mediator-article">  I have always been interested in real-time video processing applications.  On Habr√©, I read a series of articles on the GStreamer multimedia framework: <br><ul><li>  <a href="http://habrahabr.ru/post/178813/">Introducing GStreamer: Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/179167/">Introducing GStreamer: Data Sources</a> </li><li>  <a href="http://habrahabr.ru/post/204014/">Meet GStreamer: Output Devices</a> </li><li>  <a href="http://habrahabr.ru/post/127023/">GStreamer: Linux-flavored codecs</a> </li></ul><br>  I really wanted to do something with its use.  But, as usual, the current tasks completely exhausted the resource of free time. <br><a name="habracut"></a><br>  And once, in the course of working on a project, I needed to organize a video surveillance system at the facility and integrate it into the accounting system.  This task was successfully solved by our specialists and is not worthy of the attention of the general public.  The accounting system works on Microsoft .NET, all cameras issue H264 RTSP stream.  Video capture uses the MediaSuite commercial library from Streamcoders. <br><br>  As a bonus, I allowed myself to conduct a series of experiments with GStreamer for capturing and processing video. <br>  To begin with, I decided to try to capture a stream from one of the cameras aimed at the scales for weighing vehicles, transfer the frame to the license plate recognition subsystem and impose the recognition result on the video.  In the above example, I will not call the LPR functional, just grab the frame and draw a rectangle on it. <br><br>  So, given: <br><ul><li>  RTSP H264 source </li><li>  Windows 7 32-bit system </li><li>  MS Visual Studio 2010 </li><li>  C ++ language </li><li>  GStreamer 1.0 </li></ul><br>  It is necessary to obtain: <br><ul><li>  video stream containing processing results </li></ul><br>  Solution: <br><ul><li>  Develop plugin for GStreamer 1.0 </li></ul><br>  GStreamer provides the developer with its own <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-libs/html/gstreamer-hierarchy.html">class hierarchy</a> .  For our purposes, we can inherit our plugin from the <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstElement.html">GstElement</a> class.  GstElement is the base abstract class required to develop an element that can be used in the processing of GStreamer threads. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Install GStreamer </h5><br>  Download and install GStreamer gstreamer-1.0-xxx-1.2.4.msi.  It can be taken <a href="http://gstreamer.freedesktop.org/data/pkg/windows/1.2.4/">here</a> . <br>  For development, we also need the distribution gstreamer-1.0-devel-xxx.msi for example, gstreamer-1.0-devel-x86-1.2.4.msi. During the installation process, select the necessary options: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc1/037/cd5/bc1037cd53ef87660c465dc70276908d.png"><br><br>  Looking ahead, I will say it would be better to install the <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fdisplaylang%3Den%26id%3D11800">Windows Device Driver Kit 7.1.0</a> .  By default, it is installed in C: \ WinDDK \ 7600.16385.1 and this is where Visual Studio will look for it when building the project.  If you already have the DDK installed on a different path, this can be corrected later, directly in the project settings. <br><br>  On the GStreamer project site, among other documentation, there is a <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html">guide for plugin developers</a> .  You can read the manual to write all the code yourself, but you can download the template for the plugin project from the <a href="http://cgit.freedesktop.org/gstreamer/gst-template">repository</a> . <br><br>  The template contains c ++ source files and a script for generating the plugin code.  According to the instructions, after deploying the template from the repository, you need to go to the gst-template / gst-plugin / src directory and run the utility ../tools/make_element.  The make_element utility has two parameters: the name of the plug-in (dummy), the name of the source file that will be used (gstplugin by default). <br><br>  As a result of the execution, we get two files: gstdummy.c and gstdummy.h.  Inside there will be a skeleton of the dummy plug-in, which is still stupid and does nothing, but can already be built into the system of plug-ins of the framework. <br><br>  A small remark: everything said above is true for Linux, Unix machines, and how to be mournful owners of Windows?  Cmd.exe will not execute make_element.  If you look inside make_element, it becomes clear that it doesn‚Äôt do anything complicated, and using the stream editor, sed generates target sources based on the parameters it provides.  This can be done by yourself.  Just in case, I created a repository where I will place my test project in the course of development: <a href="https://github.com/nostrum-service/gst">github.com/nostrum-service/gst</a> . <br><br>  After we did the preliminary work, it was time for the project to be formed directly in MS Visual Studio 2010. Fortunately, the GStreamer developers took care of the Visual Studio users and put everything they needed into the distribution to create the project.  It is only necessary to correctly place the files in the directories of Visual Studio. <br>  Everything you need is in the directory gstreamer \ 1.0 \ x86 \ share \ vs \ 2010. <br>  We carry out: <br><pre><code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">xcopy</span></span> c:\gstreamer\<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\x86\share\vs\<span class="hljs-number"><span class="hljs-number">2010</span></span>\gst-template\*.* "C:\Program Files\Microsoft Visual Studio <span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\VC\VCWizards\gst-template\*.*" /s /e /c <span class="hljs-built_in"><span class="hljs-built_in">xcopy</span></span> C:\gstreamer\<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\x86\share\vs\<span class="hljs-number"><span class="hljs-number">2010</span></span>\wizard\*.* "C:\Program Files\Microsoft Visual Studio <span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\VC\vcprojects\"</code> </pre> <br>  We start Visual Studio (or restart it to see the new settings), create a new project, and select Visual C ++ \ gst-dk-template from the installed templates. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d91/255/27e/d9125527e0b53f969dcaef1f9b44aab1.png"><br><br>  If everything went well, an empty project with the necessary settings will be created.  Because we want to create a plugin, go to the project settings and change the Project Details Configuration Type from Application (.exe) to Dynamic Library (.dll). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fc/e0a/bdb/0fce0abdb55733611b8f737fc53f873b.png"><br><br>  In the Property Manager, we observe the following picture (you can turn on Property Manager- View-&gt; Other Windows-&gt; Property Manager): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32f/6fc/4f8/32f6fc4f8b59a6cbc541c401dc40b257.png"><br><br>  The newly created project should include files that were previously created using the make_element utility. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/cbd/b73/32acbdb73940d51071a8be884f1b26fe.png"><br><br>  If we compile everything correctly, we get a ready-made DLL that needs to be copied to the GStreamer plugins directory (I have C: \ gstreamer \ 1.0 \ x86 \ lib \ gstreamer-1.0 \). <br>  Just in case, check: gst-inspect-1.0 dummy.  Here we will see that GStreamer has learned about our plugin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f7/123/897/7f7123897e889f8f643c187169d60302.png"><br><br><h5>  The minimum feature set of the plugin </h5><br>  In order to embed a plug-in chain, we need to implement the following life cycle: <br><ul><li>  tell the framework data about yourself (initialize the class) </li><li>  initialize the plugin instance </li><li>  handle the thread connection process </li><li>  do something with the input data and pass it to the output </li><li>  on completion, clear occupied resources </li></ul><br><h5>  Metadata </h5><br>  For providing metadata about the plugin, we have the function <br>  static void gst_dummy_class_init (GstdummyClass * klass) <br><br>  In our example, the dummy element has a Silent property of type Boolean, which is responsible for displaying text during stream processing. <br><br><pre> <code class="cpp hljs"> gobject_class-&gt;set_property = gst_dummy_set_property; gobject_class-&gt;get_property = gst_dummy_get_property; g_object_class_install_property (gobject_class, PROP_SILENT, g_param_spec_boolean (<span class="hljs-string"><span class="hljs-string">"silent"</span></span>, <span class="hljs-string"><span class="hljs-string">"Silent"</span></span>, <span class="hljs-string"><span class="hljs-string">"Produce verbose output ?"</span></span>, FALSE, (GParamFlags)G_PARAM_READWRITE));</code> </pre><br>  This code tells the GStreamer environment that the plugin has the Silent property, it has the Boolean type, the delegate is responsible for installing it gst_dummy_set_property, reading is gst_dummy_get_property, it is accessible by reading and writing, the default value is FALSE.  Next, we register the connection points to the plugin - pads. <br><br><pre> <code class="cpp hljs"> gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&amp;src_factory)); gst_element_class_add_pad_template (gstelement_class, gst_static_pad_template_get (&amp;sink_factory));</code> </pre><br>  We define the input pad sink, which is always available - GST_PAD_ALWAYS and accepts any format GST_STATIC_CAPS ("ANY"). <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE (<span class="hljs-string"><span class="hljs-string">"sink"</span></span>, GST_PAD_SINK, GST_PAD_ALWAYS, GST_STATIC_CAPS (<span class="hljs-string"><span class="hljs-string">"ANY"</span></span>) );</code> </pre><br>  We define the output src pad, which is always available - GST_PAD_ALWAYS and outputs any format GST_STATIC_CAPS ("ANY"). <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE (<span class="hljs-string"><span class="hljs-string">"src"</span></span>, GST_PAD_SRC, GST_PAD_ALWAYS, GST_STATIC_CAPS (<span class="hljs-string"><span class="hljs-string">"ANY"</span></span>) );</code> </pre><br><h5>  Instance initialization </h5><br>  In the process of building the pipeline, the GStreamer environment calls the plugin instance initialization function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gst_dummy_init</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Gstdummy * filter)</span></span></span></span></code> </pre><br>  At the entrance of which is fed the structure, which must be filled: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gstdummy</span></span></span><span class="hljs-class"> {</span></span> GstElement element; GstPad *sinkpad, *srcpad; gboolean silent; };</code> </pre><br>  In order to handle events occurring at the input of the plugin, you must specify the appropriate delegate: <br><pre> <code class="cpp hljs">gst_pad_set_event_function (filter-&gt;sinkpad, GST_DEBUG_FUNCPTR(gst_dummy_sink_event));</code> </pre><br><h5>  Connection to stream </h5><br>  When events occur at the input of the plugin, in our case the function will be called: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gst_dummy_sink_event</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GstPad * pad, GstObject * parent, GstEvent * event)</span></span></span></span></code> </pre><br>  which doesn't do anything yet. <br><br><h5>  Trial run </h5><br>  Now you can try to run - gst-launch-1.0 videotestsrc!  dummy!  autovideosink ‚Äìv.  This command sends a test video stream generated by videotestsrc to our plugin, which passes it on to the autovideosink video player without any changes.  The v key allows you to see how the entire chain is processed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34e/5a7/a63/34e5a7a632433395968fa55cfffba19d.png"><br><br>  If we saw a test image, it means our plugin has successfully transmitted data from its input to the output. <br>  For our case, the output of the processing will contain the following: <br><pre> <code class="dos hljs">/GstPipeline:pipeline0/GstVideoTestSrc:videotestsrc0.GstPad:src: caps = video/x-raw, <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>=(string)I420, width=(int)<span class="hljs-number"><span class="hljs-number">320</span></span>, height=(int)<span class="hljs-number"><span class="hljs-number">240</span></span>, framerate=(fraction)<span class="hljs-number"><span class="hljs-number">30</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>, pixel-aspect-ratio=(fraction)<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>, interlace-<span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=(string)progressive</code> </pre><br>  From this it follows that an instance of the GstVideoTestSrc class named videotestsrc0 provided a pad src, issuing a video / x-raw stream in I420 format with frame sizes of 320 by 240, and so on. <br>  Since our plugin can accept any format, its input is associated with the output of videotestsrc0: <br><pre> <code class="dos hljs">/GstPipeline:pipeline0/Gstdummy:dummy0.GstPad:sink: caps = video/x-raw, <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>=(string)I420, width=(int)<span class="hljs-number"><span class="hljs-number">320</span></span>, height=(int)<span class="hljs-number"><span class="hljs-number">240</span></span>, framerate=(fraction)<span class="hljs-number"><span class="hljs-number">30</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>, pixel-aspect-ratio=(fraction)<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>, interlace-<span class="hljs-built_in"><span class="hljs-built_in">mode</span></span>=(string)progressive</code> </pre><br><h5>  Further immersion </h5><br>  Having found out that the mechanics works, we will try to take several steps towards our goal.  To illustrate the evolution of the solution, I added another painter plug-in to the project that will draw a rectangle over the image. <br>  You can draw a rectangle without using any libraries, but I wanted to continue experimenting using OpenCV. <br><br>  When adding a new plug-in there is a problem of its registration, since  the registrar should be one per project.  In this regard, the GstTestLib.cpp file was entered, which contains the registration code for both plugins. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gchar *name; GType (*type) (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements_entry</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class">[] = {</span></span> {<span class="hljs-string"><span class="hljs-string">"dummy"</span></span>, gst_dummy_get_type}, {<span class="hljs-string"><span class="hljs-string">"painter"</span></span>, gst_painter_get_type}, {<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plugin_init</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GstPlugin * plugin)</span></span></span><span class="hljs-function"> </span></span>{ gint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_elements[i].name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gst_element_register (plugin, _elements[i].name, GST_RANK_NONE, (_elements[i].type) ())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre><br>  For painter, I created tougher restrictions on the input stream format.  Now it looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE (<span class="hljs-string"><span class="hljs-string">"sink"</span></span>, GST_PAD_SINK, GST_PAD_ALWAYS, GST_STATIC_CAPS ( GST_VIDEO_CAPS_MAKE (<span class="hljs-string"><span class="hljs-string">"{ BGRx }"</span></span>) ) );</code> </pre><br>  This means that BGRx streaming video at any resolution and frame rate can be input.  OpenCV uses the BGR scheme by default.  About color schemes and transformations can be read <a href="https://software.intel.com/sites/products/documentation/hpc/ipp/ippi/ippi_ch6/ch6_color_models.html">here</a> . <br>  Since the camera that interests me produces the RTSP H264 stream, we need to decode it and send it to the input of the videoconvert converter.  Our test example will look like this: <br><pre> <code class="dos hljs">gst-launch-<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> -v rtspsrc location=rtsp://<span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">15</span></span> ! rtph264depay ! avdec_h264 ! videoconvert ! painter ! videoconvert ! autovideosink</code> </pre><br>  (10.10.0.15 - my internal address, taken as an example). <br>  Now the input buffer will be in BGRx format.  If you do not know how to build the pipeline, you can use the universal decodebin container.  He will try to pick and connect the appropriate plugins: <br><pre> <code class="dos hljs">gst-launch-<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> -v rtspsrc location=rtsp://<span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">15</span></span> ! decodebin ! autovideosink</code> </pre><br>  The ‚Äìv key is required for diagnostic output, where it will be seen how the pipeline is formed. <br><br>  Let's return to our plugin.  All our processing will consist in forming a new image based on the input and drawing a rectangle on top of it.  The working function is: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> GstBuffer * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gst_painter_process_data</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Gstpainter * filter, GstBuffer * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          GstMapInfo srcmapinfo; gst_buffer_map (buf, &amp;srcmapinfo, GST_MAP_READ); //    GstBuffer * outbuf = gst_buffer_new (); //      IplImage * dst = cvCreateImageHeader (cvSize (filter-&gt;width, filter-&gt;height), IPL_DEPTH_8U, 4); //      GstMemory * memory = gst_allocator_alloc (NULL, dst-&gt;imageSize, NULL); GstMapInfo dstmapinfo; if (gst_memory_map(memory, &amp;dstmapinfo, GST_MAP_WRITE)) { //        memcpy (dstmapinfo.data, srcmapinfo.data, srcmapinfo.size); dst-&gt;imageData = (char*)dstmapinfo.data; //   cvRectangle (dst, cvPoint(10,10), cvPoint(100, 100), CV_RGB(0, 255, 0), 1, 0); //         gst_buffer_insert_memory (outbuf, -1, memory); gst_memory_unmap(memory, &amp;dstmapinfo); } cvReleaseImageHeader(&amp;dst); gst_buffer_unmap(buf, &amp;srcmapinfo); return outbuf; }</span></span></code> </pre><br><br>  In the event handler from the sink pad, we can find out information about the input stream. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gst_painter_sink_event</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GstPad * pad, GstObject * parent, GstEvent * event)</span></span></span><span class="hljs-function"> </span></span>{ gboolean ret; Gstpainter *filter; filter = GST_PAINTER (parent); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GST_EVENT_TYPE (event)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GST_EVENT_CAPS: { GstCaps * caps; gst_event_parse_caps (event, &amp;caps); <span class="hljs-comment"><span class="hljs-comment">//  GstStructure *structure = gst_caps_get_structure (caps, 0); //  gst_structure_get_int (structure, "width", &amp;filter-&gt;width); gst_structure_get_int (structure, "height", &amp;filter-&gt;height); filter-&gt;format = gst_structure_get_string (structure, "format"); ret = gst_pad_event_default (pad, parent, event); break; } default: ret = gst_pad_event_default (pad, parent, event); break; } return ret; }</span></span></code> </pre><br>  The problem is solved in the forehead.  The experiment was a success.  As GStreamer becomes available, new opportunities open up, which I will continue to talk about as I move forward and have an interest in the topic. <br><br><h5>  Sources </h5><br>  <a href="http://gstreamer.freedesktop.org/">GStreamer</a> <br>  <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer-libs/html/gstreamer-hierarchy.html">GStreamer object hierarchy</a> <br>  <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html">GStreamer plugin development guide</a> <br>  <a href="http://opencv.org/">Opencv</a> <br>  <a href="http://cgit.freedesktop.org/gstreamer/gst-template">plugin template repository</a> <br>  <a href="https://github.com/nostrum-service/gst">my sources</a> </div><p>Source: <a href="https://habr.com/ru/post/221483/">https://habr.com/ru/post/221483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221471/index.html">What requirements today can be put forward and voiced by IT people?</a></li>
<li><a href="../221473/index.html">How to configure access to Microsoft Azure through a corporate account (Organizational Account) and enable multifactor authentication</a></li>
<li><a href="../221475/index.html">.Net Framework Interior Workshop</a></li>
<li><a href="../221477/index.html">Using Yandex MapKit with Pivot and Panorama controls</a></li>
<li><a href="../221479/index.html">Happy Star Wars Day! May the force be with you</a></li>
<li><a href="../221485/index.html">Breaking Vigenera cipher using frequency cryptanalysis</a></li>
<li><a href="../221487/index.html">Stephen Wolfram: ‚ÄúImplementing calculations everywhere‚Äù</a></li>
<li><a href="../221489/index.html">Can Apple read your iMessage?</a></li>
<li><a href="../221495/index.html">Comparative overview of BPM systems</a></li>
<li><a href="../221497/index.html">Control through wine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>