<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Real-time anti-aliasing algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aliasing is perhaps the most fundamental and most widely discussed 3D rendering artifact of all time. However, in the gaming community it is often mis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Real-time anti-aliasing algorithms</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/af6/f59/6a1af6f592d3da8f87bf0aefb7e37fd7.png" alt="image"></div><br>  Aliasing is perhaps the most fundamental and most widely discussed 3D rendering artifact of all time.  However, in the gaming community it is often misunderstood.  In this article I will talk in detail about the topic of anti-aliasing (anti-aliasing, anti-aliasing, AA) in real time, especially as far as games are concerned, and at the same time I will express everything in fairly simple language. <br><br>  The various types of aliasing and anti-aliasing discussed in the article will mainly be illustrated using screenshots from an OpenGL program designed to demonstrate variations of aliasing artifacts. <br><br>  This program can be downloaded <a href="http://blog.metaclassofnil.com/%3Fp%3D444">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before I begin, let me say a few words about performance: since it is the most important aspect of real-time graphics, we mainly focus on <i>why</i> and <i>how</i> anti-aliasing is implemented today.  I will mention the performance characteristics, but a strict evaluation of all the anti-aliasing methods presented in this article in various real-use cases will be too broad a topic for a post. <br><a name="habracut"></a><br><h1>  Nature of aliasing </h1><br><blockquote>  "If you know yourself and know the enemy, you will not be in danger in a hundred battles" </blockquote><br>  As Sun Tzu teaches us to defeat the enemy, we must first understand him.  The enemy ‚Äî forgive me for being too dramatic ‚Äî the smoothing methods are aliasing artifacts.  Therefore, we first need to understand how and where aliasing comes from. <br><br>  The term <i>aliasing</i> was first introduced in the field of signal processing, in which he originally described the effect that occurs when various continuous signals become indistinguishable (or begin to <i>distort</i> each other) during discretization.  In 3D rendering, this term usually has a more specific meaning: it refers to the many unwanted artifacts that can occur when a 3D scene is rendered for display on a screen consisting of a fixed grid of pixels. <br><br>  In this case, the 3D scene is a continuous signal, and the process of generating color values ‚Äã‚Äãfor each pixel <i>samples</i> this signal to create rendering output.  The goal of anti-aliasing methods is to make the output as closely as possible like a scene on a given grid of pixels, while minimizing visually distorting artifacts. <br><br>  Figure 1 shows aliasing in a simple scene consisting of a single white triangle on a black background.  At the rasterization stage of standard rendering, the <i>central</i> position of each pixel is sampled: if it is in a triangle, the pixel will be <i>painted in</i> white, otherwise it is <i>painted in</i> black.  The result is a well-marked <i>‚Äúladder‚Äù effect</i> , one of the most recognizable aliasing artifacts. <br><br>  With perfect smoothing for each pixel, it is determined which part of its area is covered by a triangle.  If the pixel is closed at 50%, then it must be filled with color at 50% between white and black (medium gray).  If it is closed less, then it should be proportionally darker, if it is more, then it is proportionally lighter.  Fully enclosed pixel is white, completely unclosed - black.  The result of this process is shown in the fourth figure.  However, performing this calculation in real time is generally an impossible task. <br><br>  <i><b>Figure 1</b> .</i>  <i>The simplest aliasing.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/1cd/b04/c051cdb047d2d640a7e5db680c7484af.png"></div><br>  <i>1-1.</i>  <i>Grid 8x8 with marked centers</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f86/712/f0e/f86712f0ebc85847914737055d75acb2.png"></div><br>  <i>1-2.</i>  <i>Grid 8x8 with a triangle</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/da6/f70/c3ada6f7028c7b666a0590e122b096fc.png"></div><br>  <i>1-3.</i>  <i>8x8 grid with rasterized triangle</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9a/8df/d25/b9a8dfd25902e1325bc5c399d1c0c2fc.png"></div><br>  <i>1-4.</i>  <i>8x8 grid with perfectly smooth output</i> <br><br><div class="spoiler">  <b class="spoiler_title">Same as gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/se/la/zz/selazzbunkvf50-t-rb0vvk6ztg.gif"></div></div></div><br><h1>  Types of aliasing </h1><br>  Although all aliasing artifacts can be reduced to the problem of discretization of the representation of a continuous signal on a fixed grid consisting of a limited number of pixels, the specific reasons for their occurrence are very important for choosing an effective smoothing method that eliminates them.  As will be seen later, some anti-aliasing methods can perfectly cope with the simple geometric aliasing shown in Figure 1, but fail to correct the aliasing created by other rendering processes. <br><br>  Therefore, in order to fully discuss the relative strengths and weaknesses of the anti-aliasing techniques, we grouped the aliasing artifacts arising from 3D rendering into five separate categories.  This grouping depends on the exact conditions of generating artifacts.  Figure 2 shows these types of aliasing with a real example, rendered using OpenGL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89d/46f/10c/89d46f10c194dc9dc0b0744517d91515.png"></div><br>  <i><b>Figure 2</b> : Different types of aliasing.</i>  <i>From left to right, top to bottom:</i> <i><br></i>  <i>‚Ä¢ The only rectangle aligned with the screen with a partially transparent texture.</i> <i><br></i>  <i>‚Ä¢ ‚ÄúMill‚Äù, consisting of alternating white and black triangles aligned with the screen.</i> <i><br></i>  <i>‚Ä¢ Several black lines of various widths, starting from 1 pixel on top to 0.4 pixels from the bottom, and a white line 0.5 in thickness, representing a sine wave.</i> <i><br></i>  <i>‚Ä¢ Cube consisting of six flat filled rectangles</i> <i><br></i>  <i>‚Ä¢ Inclined plane textured by high-frequency grass texture.</i> <i><br></i>  <i>‚Ä¢ A rectangle aligned with the screen with a pixel shader defining the color of each pixel based on the sine function.</i> <br><br>  The most common type of aliasing, which we have already mentioned, is <b>geometric aliasing</b> .  This artifact occurs when a primitive of a scene (usually a triangle) partially overlaps with a pixel, but this partial overlap is not taken into account in the rendering process. <br><br>  <b>Transparent aliasing</b> occurs in textured primitives with partial transparency.  The top left image in Figure 2 is rendered using a single rectangle filled with a partially transparent mesh fence.  Since the texture itself is just a fixed grid of pixels, it needs to be sampled at the points on which each pixel of the rendered image is superimposed, and for each such point a decision should be made whether transparency is necessary in it.  As a result, the same problem of sampling arises, which we have already met on solid geometry. <br><br>  Although it is actually a type of geometric aliasing, <b>sub-pixel aliasing</b> requires special consideration, as it sets unique problems for analytical smoothing methods that have recently gained great popularity in the rendering of games.  We will look at them in detail in the article.  Sub-pixel aliasing occurs when a rasterized structure is superimposed on less than one pixel in the frame buffer grid.  This most often happens in the case of narrow objects - spiers, telephone or electric lines, or even swords, when they are far enough away from the camera. <br><br>  <i><b>Figure 3.</b> Illustration of subpixel aliasing.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c05/1cd/b04/c051cdb047d2d640a7e5db680c7484af.png"></div><br>  <i>3-1.</i>  <i>Grid 8x8 with marked centers</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/bdd/6ff/3e5bdd6ffce77c0e68757b1777a5dcd8.png"></div><br>  <i>3-2.</i>  <i>8x8 grid with two straight line segments</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/492/6e9/dc84926e9fcd6002bdffabd57cc5bd10.png"></div><br>  <i>3-3.</i>  <i>Grid 8x8 with rasterized segments, without AA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/437/863/6c6/4378636c6cdb5e394740a2dc9d4d2cb3.png"></div><br>  <i>3-4.</i>  <i>8x8 grid with perfectly smooth triangle</i> <br><br><div class="spoiler">  <b class="spoiler_title">Same as gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ht/e0/ad/hte0adi92wqnrj3l2juol-j8nmy.gif"></div></div></div><br>  Figure 3 shows subpixel aliasing in a simple scene consisting of two straight line segments.  The upper one is one pixel wide, and although during rasterization it demonstrates the familiar artifact ‚Äúladder‚Äù of geometric aliasing, the result still generally corresponds to the input data.  The bottom segment is half a pixel wide.  During rasterization, part of the pixel columns it intersects does not have a single pixel center within the segment.  As a result, it is divided into several unrelated fragments.  The same can be seen on straight lines and sinusoid curve in Figure 2. <br><br>  <b>Texture aliasing</b> occurs when texture sampling is insufficient, especially in cases of anisotropic sampling (these are cases where the surface is strongly inclined relative to the screen).  Usually, artifacts created by this type of aliasing are not obvious on fixed screenshots, but appear in motion as flickering and pixel instability.  Figure 4 shows this in several frames of the sample program in animation mode. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 4: Animated high-frequency texture with twinkling artifacts</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/a55/051/69ea55051ddfeed81d23c5f974beac8c.gif"></div></div></div><br>  Texture aliasing can usually be prevented by using mipmaking and filtering high-quality textures, but it still sometimes remains a problem, especially with some driver versions of popular video processors that downsamper high-anisotropic textures.  It is also influenced by various anti-aliasing methods, so it is also included in the demonstration program. <br><br>  And finally, <b>shader aliasing</b> occurs when a pixel shader program that runs for each pixel and determines its color generates a result with aliasing.  This often happens in games with shaders that create contrast lighting, for example, mirror highlights based on the normal map, or with contrast lighting techniques like cel shading or back lighting.  In the demonstration program, this is approximated by one shader, which calculates the sine function for the texture coordinates and paints all negative results with black, and all positive results with white. <br><br><h1>  Sampling-based smoothing techniques </h1><br>  Armed with an understanding of aliasing artifacts and all types of aliasing that may occur when rendering a 3D scene, we can start researching anti-aliasing techniques.  These techniques can be divided into two categories: techniques trying to reduce aliasing by increasing the number of samples generated during rendering and techniques trying to mitigate the aliasing artifacts by analyzing and post-processing the generated images.  The category of <i>smoothing techniques based on sampling</i> is simpler, so you should start with it. <br><br>  Let's look again at our first example with a triangle in a 8 √ó 8 grid.  The problem with standard rendering is that we only sample the center of each pixel, which leads to the generation of an ugly ‚Äúladder‚Äù on the edges that are not completely horizontal or vertical.  On the other hand, the calculation of the coverage of each pixel is impossible in real time. <br><br>  An intuitive solution would be to simply <i>increase the number of samples taken per pixel</i> .  This concept is shown in Figure 5. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/c85/57c/2d4c8557cd54ae5d4775ca36ada95221.png"></div><br>  <em><b>Figure 5</b> : A triangle rasterized with four ordered samples per pixel.</em> <br><br>  The centers of the pixels are again marked with red dots.  However, in each pixel there are actually four separate places sampled (they are marked with turquoise dots).  If the triangle does not close any of these samples, then the pixel is considered black, and if it covers them all, then white.  Here the situation is interesting when only part of the pixels are closed: if one of the four is closed, then the pixel will be 25% white and 75% black.  In the case of two of the four 50/50 ratio, and with three samples closed, the result will be a lighter shade of 75% white. <br><br>  This simple idea is the foundation of all sample-based antialiasing methods.  In this context, it is also worth noting that when the number of samples per pixel tends to infinity, the result of this process will tend to the ‚Äúideal‚Äù smooth example shown earlier.  Obviously, the quality of the result strongly depends on the number of samples used - but also the performance.  Usually in games 2 or 4 samples are used per pixel, and 8 or more are usually used only in powerful PCs. <br><br>  There are other important parameters, the change of which may affect the quality of the results obtained by anti-aliasing methods based on sampling.  Basically this <i>is the location of the samples</i> , the <i>type of samples</i> and the <i>grouping of samples</i> . <br><br><h2>  <font color="DarkGreen">The location of the samples</font> </h2><br>  The location of the samples inside the pixel greatly influences the final result, especially in the case of a small number of samples (2 or 4), which is most often used in real-time graphics.  In the previous example, the samples are arranged as if they are the centers of the rendered image four times the original (16 √ó 16 pixels).  This is intuitive and easy to achieve by simply rendering a large image size.  This method is known as anti-aliasing on an ordered grid (ordered grid anti-aliasing, OGAA), also sometimes referred to as downsampling.  In particular, it is implemented by a forced increase in the rendering resolution compared to the monitor resolution. <br><br>  However, an ordered grid is often suboptimal, especially for almost vertical and almost horizontal lines, in which aliasing artifacts are most obvious.  Figure 6 shows why this happens and how a rotated or <i>sparse</i> sampling grid provides much better results: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d6/2a2/aa33d62a222161e03bb26cc46f7635b7.png"></div><br>  <i>6-1.</i>  <i>Scene with almost vertical line</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/056/7f8/1cb0567f8ee3631c37896f557a9a8ba1.png"></div><br>  <i>6-2.</i>  <i>Perfectly smooth rasterization</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/cea/e8b/9e7ceae8b94e54428914c65aee13815c.png"></div><br>  <i>6-3.</i>  <i>Rasterization with four ordered samples</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/353/d7e/021/353d7e021118c09e88bf91f01528ca96.png"></div><br>  <i>6-4.</i>  <i>Smoothing with four sparse samples</i> <br><br>  In this almost vertical case, the ideal result with four samples should have five different shades of gray: black with completely unclosed samples, 25% white with one closed sample, 50% with two and so on.  However, rasterization with an ordered grid gives us only three shades: black, white and 50/50.  This happens because the ordered samples are arranged in two columns, and therefore, when one of them closes with a nearly vertical primitive, the other is also likely to be closed. <br><br>  As shown in the image with a sparse sampling, this problem can be circumvented by changing the position of the samples inside each pixel.  The ideal arrangement of samples for smoothing is <i>sparse</i> .  This means that with N samples, no two samples have one common column, row or diagonal in the NxN grid.  Such patterns correspond to the solutions <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D0%25B2%25D0%25BE%25D1%2581%25D1%258C%25D0%25BC%25D0%25B8_%25D1%2584%25D0%25B5%25D1%2580%25D0%25B7%25D1%258F%25D1%2585">of the N Queens problem</a> .  Antialiasing methods that use such grids are called <i>anti-aliasing on sparse grids (sparse grid anti-aliasing, SGAA)</i> . <br><br><h2>  <font color="DarkGreen">Types of samples</font> </h2><br>  The simplest approach to image anti-aliasing based on sampling is that all calculations are performed on the ‚Äúreal‚Äù pixel of each sample.  Although this approach is highly efficient for removing all types of aliasing artifacts, it is also very computationally expensive, because with N samples it increases the cost of shading, rasterization, bandwidth and memory by N times.  Techniques in which all calculations are performed for each individual sample are called <b>super-sampling anti-aliasing (SSAA)</b> . <br><br>  Around the beginning of this century, support for <b>antialiasing by multisampling (MSAA)</b> , which is an optimization of supersampling, was built into the graphics hardware.  Unlike the SSAA case, in MSAA, each pixel is shaded only once.  However, for each sample, the depth and stencil values ‚Äã‚Äãare calculated, which ensures the same smoothing quality on the geometry edges as in SSAA, with a much smaller decrease in performance.  In addition, further performance improvements are possible, especially for busy bandwidth, if Z-buffer and color buffer compression is supported.  They are supported in all modern video processor architectures.  Because of the way MSAA optimizes sampling, with aliasing transparency, textures and shaders this way cannot be done directly. <br><br>  The third type of sampling was introduced by NVIDIA in 2006 in <b>anti-aliasing</b> technology <b>coverage (sampling anti-aliasing, CSAA)</b> .  MSAA separates shading from pixel-by-pixel depth and stencil calculations, while CSAA adds <i>coverage</i> samples that do not contain color, depth, or stencil values ‚Äã‚Äã‚Äî they only store the binary value of the coverage.  Such binary samples are used to assist in mixing the finished MSAA samples.  That is, CSAA modes add coverage samples to MSAA modes, but it does not make sense to perform coverage sampling without creating multiple MSAA samples.  Modern NVIDIA hardware uses three CSAA modes: 8xCSAA (4xMSAA / 8 coverage samples), 16xCSAA (4x / 16), 16xQCSAA (8x / 16) and 32xCSAA (8x / 32).  AMD has a similar implementation with 4x EQAA (2x / 4), 8xEQAA (4x / 8) and 16xEQAA (8x / 16).  Additional coverage samples are usually only marginally affected by performance. <br><br><h2>  <font color="DarkGreen">Sample grouping</font> </h2><br>  The final ingredient of AA based sampling methods is how samples are grouped, that is, how the individual samples generated during rendering are collected into the final color of each pixel.  As shown in Figure 7, various grouping filters are used for this purpose.  The figure shows 3 √ó 3 pixels ‚Äî the cyan dots represent the positions of the samples, and the yellow hue indicates the sample grouping filter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbc/568/d1b/fbc568d1bac2ef76beaad7a54f38bb26.png"></div><br>  <i>7-1.</i>  <i>Filter Box</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2b/b30/0f4/a2bb300f4e2f7317955de81581e30042.png"></div><br>  <i>7-2.</i>  <i>Quincunx Filter</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/941/2f6/5d8/9412f65d8d186e53564ed03ce04ef869.png"></div><br>  <i>7-3.</i>  <i>Filter tent</i> <br><br>  The obvious and most common grouping method simply accumulates each sample in a square region representing a pixel with equal weights.  This is called the ‚Äúbox‚Äù filter, and is used in all normal MSAA modes. <br><br>  One of the first approaches attempting to improve the smoothing effect with a small number of samples is anti-aliasing ‚Äúquincunx‚Äù.  In it, only two samples are calculated per pixel: one in the center, and one shifted up and left by half a pixel.  However, instead of these two samples, the five samples that make up the pattern shown in Figure 7 accumulate. This leads to a significant reduction in aliasing, but at the same time blurs the entire image, because the color values ‚Äã‚Äãof the surrounding pixels are grouped into each pixel. <br><br>  A more flexible approach was introduced in 2007 by AMD in the HD 2900 series of video processors. They use programmable grouping of samples, which allows for the implementation of the ‚Äúnarrow tent‚Äù and ‚Äúwide tent‚Äù grouping modes.  As shown above, each sample does not have the same weight.  Instead, the weighting function is used, depending on the distance to the center of the pixel.  Narrow (narrow) and wide (wide) options use a different size of the filter core.  These grouping methods can be combined with different number of samples, and some of the results obtained are shown in a general comparison.  As for quincunx AA, these methods represent a trade-off between image sharpness and aliasing reduction. <br><br><h2>  AA Sampling Comparison </h2><br>  Figure 8 shows a comparison of all the AA methods we considered based on sampling with a different number of samples.  The image of "ground truth" shows the closest to the "real", the perfect representation of the scene.  It is created by combining 8xSGSSAA and 4 √ó 4 OGSSAA. <br><br>  It is worth noting the similar quality of SGMSAA and SGSSAA with the same number of samples with geometric aliasing, and the lack of anti-aliasing of transparency, textures and shaders in the case of MSAA.  Disadvantages of ordered sampling patterns, especially for almost horizontal and almost vertical lines, are immediately noticeable when comparing 4x SGSSAA and 2 √ó 2 OGSSAA.  With only two samples per pixel, OGSSAA is limited only to the horizontal (2 √ó 1) or only vertical (1 √ó 2) AA, and the sparse pattern to some extent can cover both types of edges. <br><br>  AA methods with sample grouping filters, which are different from the usual box filter, usually provide a better reduction in aliasing per sample, but suffer from the blur effect of the entire image. <br><br>  It is necessary to note one more important point - especially in the light of the subsequent discussion of AA analytical methods - all these methods based on sampling apply equally well to sub-pixel aliasing and ordinary geometric aliasing. <br><br>  <em><b>Figure 8</b> : Handling of various types of aliasing using different AA methods based on sampling.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/b5a/8e5/104b5a8e54cc7bc41bc672613de22118.png"></div><br>  <i>"True" image</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89d/46f/10c/89d46f10c194dc9dc0b0744517d91515.png"></div><br>  <i>Without AA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/2b7/553/7ef2b75538e6e1a27071d21b5e3555ed.png"></div><br>  <i>2x MSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/405/58a/f8440558a2cc732733e956381dea4ec7.png"></div><br>  <i>2x SGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/dc0/76e/524dc076e91cd2d1f95b9fa480abd404.png"></div><br>  <i>4x MSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/947/167/d649471679cefd4535413248b9d9b6d3.png"></div><br>  <i>4x SGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b6/6eb/4f8/9b66eb4f8f34b6d85337339359efae67.png"></div><br>  <i>8x MSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/586/d2f/724/586d2f724280c8a7d843e95a62d63fa4.png"></div><br>  <i>8x SGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/af6/f59/6a1af6f592d3da8f87bf0aefb7e37fd7.png"></div><br>  <i>8x MSAA + alpha-to-coverage</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/475/8dd/f61/4758ddf61587d5d2b493bf874170d188.png"></div><br>  <i>2x1 OGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/5ba/0f6/1d15ba0f63260df3aae1a2c8f11779de.png"></div><br>  <i>1x2 OGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/55b/d91/56f55bd915919ecc7e1301d2835d7496.png"></div><br>  <i>2x2 OGSSAA</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66d/a88/238/66da88238562bdde29deffade27fa08e.png"></div><br>  <i>4x Narrow Tent</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b7/5cf/dc6/8b75cfdc60375038cf0e0313e519b4d5.png"></div><br>  <i>6x Narrow Tent</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/256/f83/12e/256f8312eb24bbac771430f24389a38e.png"></div><br>  <i>6x Wide Tent</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/67b/4fd/3ff67b4fd7e2bdf62277cfaca0e1e78d.png"></div><br>  <i>8x Wide Tent</i> <br><br><div class="spoiler">  <b class="spoiler_title">Same as gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/2h/ne/cf2hnes3ifgqqmu59lr2xlb-ihc.gif"></div></div></div><br><h1>  Analytical antialiasing techniques </h1><br>  Sampling-based techniques are intuitive and work quite well with a fairly large number of samples, but at the same time they are expensive in terms of computation.  This problem is exacerbated when rendering methods are used (for example, deferred shading), which can complicate the use of effective types of hardware accelerated sampling.  Therefore, other ways to reduce the visual artifacts created by aliasing during 3D rendering are being explored.  Such methods render a regular image with one sample per pixel, and then try to identify and eliminate aliasing by analyzing the <i>image</i> . <br><br><h2>  <font color="DarkGreen">Brief introduction and introduction</font> </h2><br>  Although the idea of ‚Äã‚Äãsmoothing computer-generated images has been popularized thanks to Reshetov's article on <b>morphological anti-aliasing of</b> 2009 (often called <b>MLAA</b> ) [1], it is by no means new.  Jules Blumenthal gave a concise description of this technique in his 1983 article for SIGGRAPH "Edge Inference with Applications to Antialiasing", which is actively used in modern methods [2]: <br><br><blockquote>  ‚ÄúThe edge, sampled by points for display on the raster device, and not parallel to the display axis, looks like a ladder.        ,     .       ,       ,   ,       ,   .       . <br><br>         ,   ,     .         ,     ¬ª. </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In 1999, Ishiki and Kunieda presented the first version of this technique, intended for use in real time, which was performed by scanning pairs of rows and columns of an image, and could be implemented in hardware [3]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, all purely analytical antialiasing methods are performed in three stages:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recognition of gaps in the image. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recreation of geometric edges from the pattern of gaps. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smoothing pixels crossing these edges by blending the colors of each side. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Separate implementations of analytical anti-aliasing differ in how these steps are implemented. </font></font><br><br><h2> <font color="DarkGreen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gap Recognition</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest and most common way to recognize gaps is to simply study the final rendered color buffer. If the color difference between two neighboring pixels (their </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is greater than a certain threshold value, then there is a gap, otherwise it is not. These distance measures are often calculated in a color space that simulates human vision better than RGB, for example, in </font></font><a href="http://en.wikipedia.org/wiki/HSL_and_HSV"><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HSL</font></font></u></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 9 shows an example of a rendered image, as well as horizontal and vertical gaps calculated from them.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/0dd/383/6720dd383530b7241694ed35d359aeec.png"></div><br> <i><em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 9:</font></font></b></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recognizing breaks in a color buffer. Left: image without AA. In the center: horizontal gaps. Right: vertical breaks.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To speed up the process of recognizing gaps or reduce the number of false-positive recognitions (for example, in a texture, or around the text in Figure 9), you can use other buffers generated during the rendering process. Usually, a Z-buffer (depth buffer) is available for the forward and reverse renderer. It stores the depth value for each pixel, and can be used to recognize edges. However, it only works to recognize</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edge silhouettes.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, the outer edges of the 3D object. </font><font style="vertical-align: inherit;">To view the edges inside the object, you need to use another buffer instead of or in addition to the Z-buffer. </font><font style="vertical-align: inherit;">For deferred renderers, a buffer is often generated that stores the direction of the normals surfaces of each pixel. </font><font style="vertical-align: inherit;">In this case, the angle between adjacent normals will be a suitable metric for edge recognition.</font></font><br><br><h2> <font color="DarkGreen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge Recreation and Blending</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method of reconstructing geometric edges from discontinuities varies slightly in different analytical AA methods, but they all perform similar actions by comparing patterns on horizontal and vertical discontinuities to recognize the typical ‚Äúladder‚Äù pattern of aliasing artifacts. </font><font style="vertical-align: inherit;">Figure 10 shows the patterns used according to Reshetov‚Äôs description in MLAA and the method for recreating edges. </font></font><br><br> <em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 10:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MLAA patterns and their recreated edges</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/014/07a/567/01407a567ed9c209bc4f722888a3aa8a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recognized patterns</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/e8e/dfa/035e8edfa29c00eff08a8fde8ada5fa1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The discontinuity patterns used in MLAA.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After reconstructing the geometric edges, it is simple to calculate how much the top / bottom or right / left pixel along the edge should contribute to the mixed color of the pixel in order to generate a smooth appearance.</font></font><br><br><h2> <font color="DarkGreen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Advantages and disadvantages of analytical smoothing</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compared to sample-based antialiasing methods, analytical solutions have several important advantages. With proper operation (on properly recognized geometric edges), they can provide quality equal to the quality of sampling methods with a very high number of samples, while spending less computational resources. Moreover, they are easily applicable in many cases in which AA based on sampling is more difficult to implement, for example, in the case of deferred shading. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, analytical AA is not a panacea. An integral problem of purely analytical methods based on a single sample is that they cannot cope with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sub-pixel aliasing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you transfer the pixel structure shown in the upper right corner of Figure 2 to the analytical smoothing algorithm, it will not be able to understand that the separated groups of pixels actually make up the line. At this stage, there are two equally unpleasant ways to solve this problem: either blurring the pixels, reducing visible aliasing, but also destroying the details, or conservative processing of only well-defined ‚Äúladder‚Äù artifacts that are definitely caused by aliasing; however, subpixel aliasing will be preserved and distorted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another problem with analytical methods is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false positives.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When part of an image is recognized as an edge with aliasing, but in fact it is not, it will be distorted by mixing. This is especially obvious on the text, and also requires compromises: more conservative edge recognition will lead to fewer false positives, but it will also miss some edges that actually have aliasing. On the other hand, when the edge recognition threshold is expanded, these edges will also be included, but this will lead to false positives. Since anatilistic antialiasing basically tries to extrapolate more information from a rasterized image than it actually is, it is impossible to get rid of these problems completely.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the interpretation of the edges by these methods can vary greatly depending on the difference in a single pixel. </font><font style="vertical-align: inherit;">Therefore, when using single-pixel analytical anti-aliasing methods, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flickering and temporal instability of the image</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> may increase or even be added </font><font style="vertical-align: inherit;">: a single changed pixel in the original image may turn into smooth output data into a whole flickering line. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 11 shows some of the successful and unsuccessful results of using AA analytical methods using the example of standard algorithms FXAA and SMAA1x. </font><font style="vertical-align: inherit;">The latter is usually considered the best purely analytical single-pixel algorithm that can be used in real time. </font></font><br><br> <em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 11:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AA analytical methods</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/b60/263/df8b60263804c554b328716b47f55d4b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without AA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/e4d/fc8/07ee4dfc8721cf8cccd4b185b716069a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e18/203/a5b/e18203a5b1b8ede4b73b95d2cceff546.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1x SMAA</font></font></i> <br><br><h2> <font color="DarkGreen"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison of analytical antialiasing methods</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12 shows a comparison between the results of FXAA, SMAA1x and the ‚Äúperfect‚Äù image, and non-AA images, with 4xMSAA and 4xSGSAAA from the previous comparison. </font></font><br><br> <em><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing of various types of aliasing using different AA analytical and sampling methods</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/b5a/8e5/104b5a8e54cc7bc41bc672613de22118.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Perfect" image</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89d/46f/10c/89d46f10c194dc9dc0b0744517d91515.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without AA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/dc0/76e/524dc076e91cd2d1f95b9fa480abd404.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4x MSAA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/947/167/d649471679cefd4535413248b9d9b6d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4x SGSSAA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/4b7/930/1114b7930e7d26eec9ff17a57fd8f3ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b7/ae9/4a5/4b7ae94a5b698dfb9256f79931061f67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SMAA</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Same as gif</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zp/nc/gl/zpncgljpcmc2eyh9r1jjujwwhj0.gif"></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that unlike MSAA, these analytical methods are not interested in whether geometry, transparency, or even shader calculation were the causes of aliasing artifacts. All edges are processed equally. Unfortunately, the same applies to the edges of the screen text, although the distortion with SMAA1x and less than with FXAA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both methods do not cope with anti-aliasing in the case of sub-pixel aliasing, however, they handle this failure differently: SMAA1x simply decides not to affect individual white pixels of the sinusoid at all, and FXAA mixes them with their surroundings. More desirable processing depends on context and personal preference.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More objectively, SMAA1x processes some angles of lines in the 2D geometry test and curves in the shader aliasing example is definitely better than FXAA, providing a smoother result that is more aesthetically pleasing and closer to the ‚Äúperfect‚Äù image. </font><font style="vertical-align: inherit;">This happened due to a more complicated stage of rib reconstruction and mixing, the details of which are explained in the 2012 SMAA article by Jimenez et alia [4].</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future antialiasing </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/4aa/45d/d814aa45d625115439347500cff1c7cf.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We got a good understanding of the many anti-aliasing methods (analytical and based on sampling), which are now actively used in games. It is time to speculate a little. What anti-aliasing techniques can be seen on a new generation of consoles raising the bar for technology? How can the weaknesses of the existing methods be mitigated, and how will the new equipment be allowed to use new algorithms? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the future is already partly here: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combined methods based on sampling and analytical anti-aliasing</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. These algorithms create several scene samples ‚Äî by means of traditional multi- or supersampling, or by temporal accumulation between frames ‚Äî and combine them with analysis, generating the final image with anti-aliasing. This allows them to reduce the problems of sub-pixel aliasing and temporal instability of single-sample purely analytical methods, but still gives much better results on geometric edges than pure sampling methods with similar performance characteristics. A very simple combination of additional sampling and analytical AA can be obtained by combining single-sample analytical techniques like FXAA with subsampling from a higher resolution buffer. More sophisticated examples of such methods are SMAA T2x, SMAA S2x and SMAA 4x, as well as TXAA.The SMAA methods are explained in detail and compared in</font></font><a href="http://www.iryoku.com/smaa/downloads/SMAA-Enhanced-Subpixel-Morphological-Antialiasing.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , while NVIDIA implemented its own approach to TXAA </font></font><a href="http://www.geforce.com/hardware/technology/txaa"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is highly probable that such combined methods will be more widely used in the future. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another option, which has not yet received wide distribution, but which has great potential for the future, is to encode additional geometric information in the rendering process, which will later be used at the stage of analytical anti-aliasing. Examples of this approach are anti-aliasing with geometric post-processing (Geometric Post-process Anti-Aliasing, GPAA) and anti-aliasing using Geometry Buffer Anti-Aliasing (GBAA), the demo of which is posted </font></font><a href="http://www.humus.name/%3Fpage%3D3D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, a common pool of CPU and video processor memory of new console platforms and future PC architectures may allow the use of technology designed to exploit such shared resources. In a recent article, ‚ÄúAsynchronous Adaptive Anti-aliasing Using Shared Memory,‚Äù Barringer and Moeller describe a technique that performs traditional single-sample rendering, while recognizing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">important</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixels (for example, on the edge) and rasterizing additional sparse samples for them in the CPU [5] . Although this requires a serious restructuring of the rendering process, the results look promising.</font></font><br><br><h2>  Reference materials </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] A. Reshetov, ‚ÄúMorphological antialiasing,‚Äù in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proceedings of the Conference on High Performance Graphics 2009 HPG '09</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , New York, NY, USA, 2009, pp. 109‚Äì116. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] J. Bloomenthal, 'Edge Inference with Applications to Antialiasing', ACM SIGGRAPH Comput. Graph., Vol. 17, no. 3, pp. 157-162, Jul. 1983. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] T. Isshiki and H. Kunieda, 'Efficient anti-aliasing algorithm for computer generated images', in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proceedings of the 1999 IEEE International Symposium on Circuits and Systems ISCAS '99</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Orlando, FL, 1999, vol. 4, pp. 532‚Äì535. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] J. Jimenez, JI Echevarria, T. Sousa, and D. Gutierrez, 'SMAA: Enhanced Subpixel Morphological Antialiasing', </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comput. Graph. Forum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vol. 31, no. 2pt1, pp. 355‚Äì364, May 2012.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] R. Barringer and T. Akenine-M√∂ller, 'A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : asynchronous adaptive anti-aliasing using shared memory', </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACM Trans. </font><font style="vertical-align: inherit;">Graph. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vol. </font><font style="vertical-align: inherit;">32, no. </font><font style="vertical-align: inherit;">4, pp. </font><font style="vertical-align: inherit;">100: 1‚Äì100: 10, Jul. </font><font style="vertical-align: inherit;">2013</font></font></div><p>Source: <a href="https://habr.com/ru/post/343876/">https://habr.com/ru/post/343876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343864/index.html">F # on Linux as a cure for the soul</a></li>
<li><a href="../343866/index.html">Electricity in the data center</a></li>
<li><a href="../343870/index.html">Most Popular Books on Reddit Programming</a></li>
<li><a href="../343872/index.html">GraphQL - a new look at the API. Part 1</a></li>
<li><a href="../343874/index.html">Installing Solaris 10 on a SunFire V240 over a network using a Debian Stretch-based boot server</a></li>
<li><a href="../343878/index.html">Good bot for Slack</a></li>
<li><a href="../343880/index.html">How we made an application under Windows 10 with Fluent Design (UWP / C #)</a></li>
<li><a href="../343882/index.html">Undefined behavior! = Insecure programming</a></li>
<li><a href="../343884/index.html">Automation of development processes: how we in Positive Technologies implemented DevOps ideas</a></li>
<li><a href="../343888/index.html">Performance analysis of React 16 applications using Chrome developer tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>