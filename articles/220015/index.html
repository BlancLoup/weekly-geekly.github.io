<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Organizing web-based interaction with the Spring application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will say right away that the standard implementation of such an interaction exists . 

 However, since this article is a continuation of the topic ‚Äú...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Organizing web-based interaction with the Spring application</h1><div class="post__text post__text-html js-mediator-article">  I will say right away that the standard implementation of such an interaction <a href="http://habrahabr.ru/post/187822/">exists</a> . <br><br>  However, since this article is a continuation of the topic <a href="http://habrahabr.ru/post/211937/">‚ÄúSimple Calling of Remote Service Methods in One-Page Applications‚Äù</a> , here will be an alternative interaction scheme needed to replace ajax with web-based strategies in the context of the approach (jrspc) described in the above topic. <br><br>  In the first article, the mechanism for invoking service methods was described using ajax. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article describes how you can implement this mechanism, with the replacement of ajax by web sockets, without changing the code of the business logic of the application. <br><br>  Such a replacement gives a faster connection (tests at the end), saving server memory, and adds the ability to call client methods from the server. <br><br>  For the demonstration, a small <a href="http://94.127.68.13/jrspc-ws/demo-chat/">chat application</a> is written, with source code <a href="https://github.com/janson13/demo-jrspc-ws">on a githaba</a> . <br>  for example, which analysis, I will try to explain how the client and server parts of this interaction are implemented. <br>  The application runs on a tomcat 7.042 server. <br>  It supports https and wss (certificate unconfirmed), and does not keep logs on the server. <br><a name="habracut"></a><br><h4>  Server part </h4><br>  The main question that arose when organizing a web-based interaction with the Spring application was the question of how to call Spring components, from its visibility areas that are bound to the http session, from a StreamInbound object returned by the createWebSocketInbound method of the <a href="http://www.tomcatexpert.com/blog/2012/05/01/how-apache-tomcat-implemented-websocket">WebSocketServlet</a> class, which is not bound to the session? <br><br>  To provide the required functionality for invoking the server component methods, we need to somehow access the worker ApplicationContext from the StreamInbound descendant. <br><br>  If we try to install ApplicationContext in order to use it to get the components we need, in the successor of WebSocketServlet or StreamInbound - we will be disappointed, because it does not initialize, which is absolutely legal. <br><br>  In order to get access to components from Spring contexts that are related to the http session from the web socket handler, we need to create an object that would be a session spring bean, and which would be stored in a static object of the storage class, which could be accessed would be StreamInbound heir. <br><br>  This session object (let's call it ClientManager) is created during the installation of the http connection. <br><br>  Accordingly, the client, before starting to interact with the server via the web socket, must make one http handshake request, as a result of which, he must receive his ClientManager ID. <br><br>  The result of this query can be sent to the client code in two ways - to insert clientManagerId into the generated generated page, or via ajax request, from a static page (here - the option is implemented via ajax). <br><br>  This request is processed in the session controller's initializeClientManager method: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-meta"><span class="hljs-meta">@Scope</span></span>(<span class="hljs-string"><span class="hljs-string">"session"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientManagerController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ClientManager clientManager; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/init"</span></span>, method = RequestMethod.POST) <span class="hljs-meta"><span class="hljs-meta">@ResponseBody</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeClientManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSession session)</span></span></span><span class="hljs-function"> </span></span>{ JSONObject result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONObject(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> loged = ClientManagersStorage.checkClientManager(clientManager, session) ; result.put(<span class="hljs-string"><span class="hljs-string">"loged"</span></span>, loged); result.put(<span class="hljs-string"><span class="hljs-string">"clientManagerId"</span></span>, clientManager.getId()); }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Throwable th){ result.put(<span class="hljs-string"><span class="hljs-string">"error"</span></span>, th.toString()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.toString(); }</code> </pre> <br><br>  ClientManagersStorage is a repository of our session managers of clients, which has methods for checking the manager for null, creating a new one, adding it to the repository, searching for and deleting. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientManagersStorage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, ClientManager&gt; clientManagers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap &lt;String, ClientManager&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkClientManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClientManager clientManager, HttpSession session)</span></span></span><span class="hljs-function"> </span></span>{ ClientManager registeredClientManager = clientManagers.get(clientManager.getId()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (registeredClientManager == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { clientManager.setSession(session); addClientManager(clientManager); registeredClientManager = clientManager; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> registeredClientManager.getUser() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } ... }</code> </pre><br><br>  (the question of managing the life cycle of the session will be discussed a little below) <br><br>  As you can see, managers are stored in a static map, by the key that is its hashCode, and when the user reloads the page, the same manager is assigned to it. <br><br>  The ID of this manager is passed to the client in the clientManagerId variable of the response. <br><br>  After the client has received his manager's ID, he can open a web socket connection by passing his clientManagerId in a single parameter of the request to establish a connection. <br><br>  The request to open this connection is handled in the createWebSocketInbound method of the WebSocketConnectorServlet class, an implementation of the abstract WebSocketServlet. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> StreamInbound </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWebSocketInbound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String paramString, HttpServletRequest request)</span></span></span><span class="hljs-function"> </span></span>{ String clientManagerId = request.getParameter(<span class="hljs-string"><span class="hljs-string">"clientManagerId"</span></span>); ClientManager clientManager = ClientManagersStorage.findClientManager(clientManagerId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clientManager == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocketConnection(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } log.debug(<span class="hljs-string"><span class="hljs-string">"new connection"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocketConnection(clientManager); }</code> </pre><br>  in it, the clientManagerId is taken from the request, the ClientManager is located on it, and the WebSocketConnection object (which is StreamInbound) is created, to which the ClientManager is bound. <br><br>  Since the ClientManager is session, and was created in a ‚Äúnormal‚Äù http request, all of the spring bins will be available from it, via the ApllicationContext that is automatically signed into it, which, here, will be initialized correctly). <br><br>  When opening a new connection with the client, the container invokes the onOpen method of the WebSocketConnection class, in which its associated ClientManager adds this WebSocketConnection to its connection map, according to the object's (hashcode). <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WsOutbound outbound)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clientManager != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ clientManager.addConnection(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre><br><br>  (Support for multiple connections is necessary so that the user can open the application in several windows, each of which will create its own web-based connection.) <br><br>  By opening a connection, the client can send requests for server-side calls that will be processed in the overridden onTextMessage method of the WebSocketConnection class. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTextMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharBuffer message)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String connectionId = String.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hashCode()); String request = message.toString(); clientManager.handleClientRequest(request, connectionId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable th) { log.error(<span class="hljs-string"><span class="hljs-string">"in onTextMessage: "</span></span> + th); } }</code> </pre><br><br>  The ClientCanent class handleClientRequest method ‚Äî processes the request and writes the result to the connection: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RequestHandler requestHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleClientRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String request, String connectionId)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"handleClientRequest request="</span></span> + request); log.debug(<span class="hljs-string"><span class="hljs-string">"handleClientRequest user="</span></span> + getUser()); <span class="hljs-comment"><span class="hljs-comment">/** handleRequest - never throws exceptions ! */</span></span> JSONObject response = requestHandler.handleRequest(request, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); String responseJson = response.toString(); CharBuffer buffer = CharBuffer.wrap(responseJson); WebSocketConnection connection = connections.get(connectionId); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connection.getWsOutbound().writeTextMessage(buffer); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ioe) { log.error(<span class="hljs-string"><span class="hljs-string">"in handleClientRequest: in writeTextMessage: "</span></span> + ioe); } }</code> </pre><br><br>  requestHandler - avtovaerenny component responsible for processing requests. <br>  The ApllicationContext is built into it, with which it finds service objects. <br><br>  Its handleRequest method, searches for a service component, and calls on it the methods the client needs, just like the processAjaxRequest method from the CommonServiceController class from the previous article. <br><br><br>  This is the general pattern of interaction. <br><br>  Now let's take a closer look at the moment of initialization of the ClientManager http session. <br><br>  Session has the property to fall off on timeout, which by default is 30 minutes. <br>  To avoid this, set its value to maximum, and invalidate the session when we need it - namely, in two cases: the first case is when someone made the request not from the application, and the second when the client closed the application page. <br><br>  The first case is handled directly in the initialization method: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientManager</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpSession session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** session will be invalidated at connection removing */</span></span> session.setMaxInactiveInterval(Integer.MAX_VALUE);<span class="hljs-comment"><span class="hljs-comment">//69.04204112011317 years this.session = session; new Thread(new Runnable() { @Override public void run() { /** Giving time to client, for establish websocket connection. */ try {Thread.sleep(60000);} catch (InterruptedException ignored) {} /** if client not connected via websocket until this time - it is bot */ if (connections.size() == 0) {removeMe();} } }).start(); } private void removeMe() {ClientManagersStorage.removeClientManager(this);} ... }</span></span></code> </pre><br><br>  and the second is in the onClose method of the WebSocketConnection class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebSocketConnection</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> status)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clientManager != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ clientManager.removeConnection(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientManager</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WebSocketConnection webSocketConnection)</span></span></span><span class="hljs-function"> </span></span>{ String connectionId = getObjectHash(webSocketConnection); connections.remove(connectionId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { log.debug(<span class="hljs-string"><span class="hljs-string">"removeConnection before wait: connections.size()="</span></span> + connections.size()); <span class="hljs-comment"><span class="hljs-comment">/** may be client just reload page? */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {Thread.sleep(waitForReloadTime);} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable ignored) {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/** no, client leave us (page closed in browser)*/</span></span> ClientManagersStorage.removeClientManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); log.debug(<span class="hljs-string"><span class="hljs-string">"client "</span></span> + getId() + <span class="hljs-string"><span class="hljs-string">" disconnected"</span></span>); } } } ... }</code> </pre><br><br>  The session is invalidated in the removeClientManager method of the ClientManagersStorage class: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeClientManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClientManager clientManager)</span></span></span><span class="hljs-function"> </span></span>{ ClientManager removed = clientManagers.remove(clientManager.getId()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(removed == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;} User user = removed.getUser(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(user != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ Broadcaster.broadcastCommand(<span class="hljs-string"><span class="hljs-string">"userPanel.setLogedCount"</span></span>, UserService.logedCount.decrementAndGet()); } Broadcaster.broadcastCommand(<span class="hljs-string"><span class="hljs-string">"userPanel.setOnlineCount"</span></span>, ClientManagersStorage.getClientManagersCount()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { clientManager.getSession().invalidate(); clientManager.setSession(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable th) { log.error(<span class="hljs-string"><span class="hljs-string">"at removeClientManager: "</span></span> + th); } }</code> </pre><br>  The same method is used to notify users that the number of visitors to the page has changed (the processing of these notifications on the client is described below). <br><br>  To notify users about events on the server ‚Äî the Broadcaster class is used, which has two methods: broadcastCommand and sendCommandToUser: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Broadcaster</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">broadcastCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String method, Object params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ClientManager clientManager : ClientManagersStorage.getClientManagers().values()) { clientManager.sendCommandToClient(method, params); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommandToUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId, String method, Object params)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;ClientManager&gt; userClientManagers = ClientManagersStorage.findUserClientManagers(userId); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ClientManager clientManager: userClientManagers){ clientManager.sendCommandToClient(method, params); } } }</code> </pre><br><br>  The sendCommandToClient method of the ClientManager class works like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommandToClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String method, Object params)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(WebSocketConnection connection: connections.values()){ sendCommandToClientConnection(connection, method, params); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommandToClientConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WebSocketConnection connection, String method, Object params)</span></span></span><span class="hljs-function"> </span></span>{ JSONObject commandBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONObject(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(params == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONObject();} commandBody.put(<span class="hljs-string"><span class="hljs-string">"method"</span></span>, method); commandBody.put(<span class="hljs-string"><span class="hljs-string">"params"</span></span>, params); CharBuffer buffer = CharBuffer.wrap(commandBody.toString()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connection.getWsOutbound().writeTextMessage(buffer); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ioe) { log.error(<span class="hljs-string"><span class="hljs-string">"in sendCommandToClient: in writeTextMessage: "</span></span> + ioe); } }</code> </pre><br><br>  On this, with the server part we finish, and move on to the client. <br><br><h4>  Client part </h4><br>  The client part must implement three functionalities: <br><br>  the first is a handshake on ajax, to initialize the session client manager, the second is a web-based transport, to send jsrpc requests and receive answers to them, and the third is to call functions on the client, from the server. <br><br>  The first part is the simplest: <br><br>  Since we are using Angulyar, for initializing the http session of the ajax request, $ http is used: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appName = <span class="hljs-string"><span class="hljs-string">"jrspc-ws"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secured = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.protocol == <span class="hljs-string"><span class="hljs-string">"https:"</span></span> ? <span class="hljs-string"><span class="hljs-string">"s"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> HttpSessionInitializer = {<span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"http"</span></span>+secured+<span class="hljs-string"><span class="hljs-string">"://"</span></span>+ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.host +<span class="hljs-string"><span class="hljs-string">"/"</span></span>+appName+<span class="hljs-string"><span class="hljs-string">"/init"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/** called from root-controller.js after its initialization */</span></span> HttpSessionInitializer.init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$http</span></span></span><span class="hljs-function">) </span></span>{ $http.post(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.url, <span class="hljs-string"><span class="hljs-string">""</span></span>).success(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { error(response.error); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loged = response.loged; Server.initialize(<span class="hljs-string"><span class="hljs-string">"ws"</span></span>+secured+<span class="hljs-string"><span class="hljs-string">"://"</span></span>+ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.location.host +<span class="hljs-string"><span class="hljs-string">"/"</span></span>+appName+<span class="hljs-string"><span class="hljs-string">"/ws?clientManagerId="</span></span>+response.clientManagerId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(loged){Listeners.notify(<span class="hljs-string"><span class="hljs-string">"onLogin"</span></span>);} } }).error(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{error(<span class="hljs-string"><span class="hljs-string">"network error!"</span></span>);}); }</code> </pre><br><br>  On the server, this request is processed in the initializeClientManager method of the ClientManagerController class, the code of which is given above, in the description of the server part. <br><br>  Initialization of the socket connection occurs in the Server.initialize function: <br><br><pre> <code class="javascript hljs"> connector.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ connector.url = url; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { connector.connect(url); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { p(<span class="hljs-string"><span class="hljs-string">"in connector.initialize: "</span></span> + ex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre><br><br>  connector is an internal Server object that is responsible for the web socket connection (its full code is in the <a href="">ws-connector.js</a> file) <br><br>  The code from ws-connector.js that is responsible for generating the jrspc request: <br><br><pre> <code class="javascript hljs"> Server.socketRequests = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestId = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendSocket</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">service, method, params, successCallback, errorCallback, control</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!checkSocket()) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;} requestId++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!params){params = [];} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isArray(params)){params = [params];} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">service</span></span> : service, <span class="hljs-attr"><span class="hljs-attr">method</span></span> : method, <span class="hljs-attr"><span class="hljs-attr">params</span></span> : params, <span class="hljs-attr"><span class="hljs-attr">requestId</span></span> : requestId }; Server.socketRequests[<span class="hljs-string"><span class="hljs-string">"request_"</span></span> + requestId] = { <span class="hljs-attr"><span class="hljs-attr">successCallback</span></span> : successCallback, <span class="hljs-attr"><span class="hljs-attr">errorCallback</span></span> : errorCallback, <span class="hljs-attr"><span class="hljs-attr">control</span></span> : control }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (control) {control.disabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(data); log(<span class="hljs-string"><span class="hljs-string">"sendSocket: "</span></span>+message); connector.socket.send(message); } ... Server.call = sendSocket;</code> </pre><br><br><br>  Code from ws-connector.js, which is responsible for processing responses to requests, and processing server commands: <br><br><pre> <code class="javascript hljs"> connector.socket.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = message.data; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(data); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestId = response.requestId; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (requestId) {<span class="hljs-comment"><span class="hljs-comment">/** server return response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> control = Server.socketRequests[<span class="hljs-string"><span class="hljs-string">"request_"</span></span> + requestId].control; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (control) {control.disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorCallback = Server.socketRequests[<span class="hljs-string"><span class="hljs-string">"request_"</span></span> + requestId].errorCallback; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorCallback) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { errorCallback(response.error); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { error(<span class="hljs-string"><span class="hljs-string">"in connector.socket.onmessage errorCallback: "</span></span> + ex + <span class="hljs-string"><span class="hljs-string">", data="</span></span> + data); } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ error(response.error); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> successCallback = Server.socketRequests[<span class="hljs-string"><span class="hljs-string">"request_"</span></span> + requestId].successCallback; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (successCallback) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { successCallback(response.result); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { error(<span class="hljs-string"><span class="hljs-string">"in connector.socket.onmessage successCallback: "</span></span> + ex + <span class="hljs-string"><span class="hljs-string">", data="</span></span> + data); } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Server.socketRequests[<span class="hljs-string"><span class="hljs-string">"request_"</span></span> + requestId]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** server call client or broadcast */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(response.method); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> params = response.params; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { method(params); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { error(<span class="hljs-string"><span class="hljs-string">"in connector.socket.onmessage call method: "</span></span> + ex + <span class="hljs-string"><span class="hljs-string">", data="</span></span> + data); } } };</code> </pre><br><br>  The application of the framework described above allows you to implement all the business logic responsible for the chat functionality - in two functions on the client ( <a href="">chat-controller.js</a> ): <br><br><pre> <code class="javascript hljs"> self.sendMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = {<span class="hljs-attr"><span class="hljs-attr">to</span></span>: (self.sendPrivate ? self.privateTo : <span class="hljs-string"><span class="hljs-string">"all"</span></span>), <span class="hljs-attr"><span class="hljs-attr">from</span></span>: userPanel.user.login, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: self.newMessage, <span class="hljs-attr"><span class="hljs-attr">clientTime</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getTime()}; Server.call(<span class="hljs-string"><span class="hljs-string">"chatService"</span></span>, <span class="hljs-string"><span class="hljs-string">"dispatchMessage"</span></span>, message, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ self.newMessage = <span class="hljs-string"><span class="hljs-string">""</span></span>; self.$digest(); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">)</span></span>{self.onError(error);}, command); } <span class="hljs-comment"><span class="hljs-comment">/** called from server */</span></span> self.onChatMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">)</span></span>{ message.isPrivate = (message.to != <span class="hljs-string"><span class="hljs-string">"all"</span></span>); self.messages.push(message); self.$digest(); chatConsole.scrollTop = chatConsole.clientHeight + chatConsole.scrollHeight; }</code> </pre><br><br>  and one server method: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractService</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UserManager userManager; <span class="hljs-meta"><span class="hljs-meta">@Secured</span></span>(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Remote</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatchMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChatMessage message)</span></span></span></span>{ message.setServerTime(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date().getTime()); String to = message.getTo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"ALL"</span></span>.equalsIgnoreCase(to)){ Broadcaster.broadcastCommand(<span class="hljs-string"><span class="hljs-string">"chatPanel.onChatMessage"</span></span>, message); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ User fromUser = getUser(); message.setFrom(fromUser.getLogin()); User toUser = userManager.findByLogin(to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(toUser == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"User "</span></span>+to+<span class="hljs-string"><span class="hljs-string">" not found!"</span></span>);} Broadcaster.sendCommandToUser(toUser.getId(), <span class="hljs-string"><span class="hljs-string">"chatPanel.onChatMessage"</span></span>, message); Broadcaster.sendCommandToUser(fromUser.getId(), <span class="hljs-string"><span class="hljs-string">"chatPanel.onChatMessage"</span></span>, message); } } }</code> </pre><br>  Speed ‚Äã‚Äãtests, with serial and parallel sending of 1000 requests, for ajax and websockets: <br><br>  consistently: ajax (3474, 3380, 3377) ws (1299, 1113, 1054) <br>  in parallel: ajax (1502, 1515, 1469) ws (616, 637, 632) <br><br><div class="spoiler">  <b class="spoiler_title">test code</b> <div class="spoiler_text"><br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = $scope; self.maxIterations = <span class="hljs-number"><span class="hljs-number">1000</span></span>; self.testIterations = self.maxIterations; self.testStart = <span class="hljs-number"><span class="hljs-number">0</span></span>; self.testEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; self.testForSpeedSerial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(self.testStart == <span class="hljs-number"><span class="hljs-number">0</span></span>){self.testStart = now();} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(--self.testIterations &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> duration = now() - self.testStart; alert(<span class="hljs-string"><span class="hljs-string">"testForSpeedSerial duration="</span></span>+duration); self.testStart = <span class="hljs-number"><span class="hljs-number">0</span></span>; self.testIterations = self.maxIterations; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Server.call(<span class="hljs-string"><span class="hljs-string">"userService"</span></span>, <span class="hljs-string"><span class="hljs-string">"testForSpeed"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ self.testForSpeedSerial(command); }, error, command); } self.testForSpeedParallelResponses = <span class="hljs-number"><span class="hljs-number">0</span></span>; self.testForSpeedParallel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">command</span></span></span><span class="hljs-function">)</span></span>{ self.testStart = now(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; self.testIterations; i++){ Server.call(<span class="hljs-string"><span class="hljs-string">"userService"</span></span>, <span class="hljs-string"><span class="hljs-string">"testForSpeed"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ self.testForSpeedParallelResponses++ ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(self.testForSpeedParallelResponses &gt;= self.maxIterations){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> duration = now() - self.testStart; alert(<span class="hljs-string"><span class="hljs-string">"testForSpeedParallel duration="</span></span>+duration); self.testForSpeedParallelResponses = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }, error, command); } } }</code> </pre><br>  server testForSpeed ‚Äã‚Äãmethod: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Remote</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testForSpeed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre><br></div></div><br><br>  All critical comments and indications of errors will be greatly appreciated. </div><p>Source: <a href="https://habr.com/ru/post/220015/">https://habr.com/ru/post/220015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220005/index.html">Some interesting and useful things for web developer # 16</a></li>
<li><a href="../220007/index.html">Zalman ZM-VE400 Review</a></li>
<li><a href="../220009/index.html">Warm lamp light</a></li>
<li><a href="../220011/index.html">Making a spherical panorama by Google</a></li>
<li><a href="../220013/index.html">Neutralizing the effects of Heartbleed in Drupal 7</a></li>
<li><a href="../220017/index.html">Hope Microelectronics 24-bit I2C Pressure Sensors HP203B and HP206C</a></li>
<li><a href="../220019/index.html">HD FPV on Raspberry Pi</a></li>
<li><a href="../220021/index.html">From the IT preacher to the designer of medical robots: future professions in IT and robotics</a></li>
<li><a href="../220023/index.html">Use of encryption in Russian companies</a></li>
<li><a href="../220025/index.html">Secure payment card do it yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>