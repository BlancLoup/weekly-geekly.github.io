<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebGLU: simplify working with WebGL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once 3D in the browser was a big problem. They didn‚Äôt resort to creating dynamic 3D graphics in the browser: using pseudo-3D in SVG, building on canva...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebGLU: simplify working with WebGL</h1><div class="post__text post__text-html js-mediator-article">  Once 3D in the browser was a big problem.  They didn‚Äôt resort to creating dynamic 3D graphics in the browser: using pseudo-3D in SVG, building on canvas, using flash ... However, progress does not stand still: finally, all modern browsers began to support the lightweight version of OpenGL (OpenGL ES 2.0) - WebGL.  This is a rather young technology, it is only a little more than a year old.  However, it is already possible to estimate its power by all sorts of browser games and examples. <br><br>  Due to the comparative youth of this technology, there are not so many manuals for working with it.  You can read something about working with her <a href="http://learningwebgl.com/blog/%3Fpage_id%3D1217">here</a> ( <a href="http://russian-webgl.blogspot.com/2010/07/0_03.html">here</a> - translation into Russian).  <a href="http://habrahabr.ru/post/112430/">Here</a> you can learn something about the basics of WebGL. <br><br>  To facilitate the work with WebGL, a number of libraries have been developed (although most of them are still quite raw).  The application of one of them - <a href="http://sourceforge.net/projects/webglu/">webGLU</a> - for the formation of a simple scene, illuminated by one source-lantern, and this article is devoted.  <a href="http://eddyem.narod.ru/WGL/">Here</a> you can see an example, and <a href="">from here</a> download the full archive to run it on your machine. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  First, let me remind you a little about the difference between OpenGL and WebGL.  Since WebGL is based on GLES, this technology is significantly inferior to OpenGL: it does not have many convenient extensions (ARB, etc.), there is no built-in support for lighting, and even GL_QUADS is not supported in it ... However, what can you do: no more technologies, Allowing to embody 3D on the web without third-party plug-ins is not. <br><br>  Shaders are used to calculate the position of the vertices and their colors in the final image.  In the simplest construction of three-dimensional scenes, shaders are called for each vertex with which they are associated.  But more complex scenes cannot be described in this way.  In this case, they resort to writing shaders that form the texture, which forms the final scene (an example can be seen <a href="http://www.rhythm.com/~beason/webgl/WebGL%2520Path%2520Tracing.html">here</a> . Perhaps in the next article I will touch on this way of describing three-dimensional scenes. <br><br>  The WebGLU library contains scant documentation and a few examples.  This is not enough to complete the work with the library, so you have to read its source code.  In addition, the library is quite raw, so sometimes you have to dig deeper into its code. <br><br>  So, in order to get started with WebGLU, we need to enable the webglu.js script and initialize it: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"./src/webglu.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶ $W.initialize();</code> </pre> <br>  $ W is the primary object of the WebGLU namespace.  We will do most of the work with him.  In addition to this object, there is an $ G object (GameGLU namespace), which simplifies working with scene control using the mouse and keyboard.  There are some experimental functions in WebGLU (for example, CrazyGLU is for working with the pseudo-buffer of choice and some physics).  All source files are loaded by WebGLU when running the corresponding functions (for example, the <code>useControlProfiles();</code> function <code>useControlProfiles();</code> loads ControlProfiles.js), so you do not need to load scripts manually besides webglu.js. <br><br>  After initializing the WebGLU, we can proceed to the creation of scene objects.  To create an object, WebGLU provides the <code>$W.Object(type, flags)</code> interface, where type is the type of the object (as in OpenGL): <br><br><ul><li>  $ W.GL.POINTS - each vertex is represented by a point, </li><li>  $ W.GL.LINES - each pair of vertices 2n-1 and 2n is connected by a line, </li><li>  $ W.GL.LINE_LOOP - all vertices are connected in order in segments with a closure to the first vertex, </li><li>  $ W.GL.LINE_STRIP - all vertices are connected by segments without closure, </li><li>  $ W.GL.TRIANGLES - each triple of vertices (in order) forms a triangle, </li><li>  $ W.GL.TRIANGLE_STRIP ‚Äî vertices are connected in order by triangles, </li><li>  $ W.GL.TRIANGLE_FAN - vertices are connected by triangles around a common - first - vertices; </li></ul><br>  flags - optional flags: by default they are equal to <code>$W.RENDERABLE | $W.PICKABLE</code>  <code>$W.RENDERABLE | $W.PICKABLE</code> , however, if we draw an object that is a child, then <code>$W.PICKABLE</code> should be specified explicitly.  In the simplest case, for each vertex of the object, you must specify a color, however, we are free to write a custom shader (which we will do later), which allows you to specify a common color for the entire object. <br><br>  So, for example, to create color coordinate axes, we will do this: <br><br><pre> <code class="html hljs xml">var originLines = new $W.Object($W.GL.LINES); originLines.vertexCount = 6; originLines.fillArray("vertex", [[0,0,0], [3,0,0], [0,0,0], [0,3,0], [0,0,0], [0,0,3]]); with ($W.constants.colors){ originLines.fillArray("color", [ RED, RED, GREEN, GREEN, BLUE, BLUE]); }</code> </pre><br>  The default shader uses the following arrays to characterize each object vertex: <br><ul><li>  "Vertex" - the coordinates of the vertices, </li><li>  "Color" - colors of tops, </li><li>  "Normal" - normals to the vertices, </li><li>  "TexCoord" - coordinates of the texture at this vertex, </li><li>  ‚ÄúWglu_elements‚Äù - indices of vertex coordinates (for complex objects). </li></ul><br>  The corresponding variables in the shaders are named accordingly (except for the indices) (recall that the variables characterizing a particular vertex in the shader have an <code>attribute</code> ). <br><br>  The connection of shaders in WebGL is implemented using the <code>Material</code> method.  The only argument to this method is the path to the shader description JSON file.  For example, our shaders that implement lighting are connected as follows: <br><br><pre> <code class="html hljs xml">var lights = new $W.Material({path:$W.paths.materials + "light.json"});</code> </pre><br>  The light.json file itself looks like this: <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">name</span></span>: <span class="hljs-string"><span class="hljs-string">"light"</span></span>, program: { name: <span class="hljs-string"><span class="hljs-string">"light"</span></span>, shaders: [ {name:<span class="hljs-string"><span class="hljs-string">"light_vs"</span></span>, path:$W.paths.shaders+<span class="hljs-string"><span class="hljs-string">"light.vert"</span></span>}, {<span class="hljs-attribute"><span class="hljs-attribute">name</span></span>:<span class="hljs-string"><span class="hljs-string">"light_fs"</span></span>, path:$W.paths.shaders+<span class="hljs-string"><span class="hljs-string">"light.frag"</span></span>} ] } }</code> </pre><br>  Here name is the common name of the ‚Äúmaterial‚Äù;  program ‚Üí name - it seems to characterize the name of the program (perhaps the creator of WebGL assumed that several programs could be used for one material, but this parameter does not play a special role);  shaders - used shaders with the path to them. <br><br>  Variables that are common to each object or the entire system (with the <code>uniform</code> attribute) are associated with the corresponding JavaScript variables using the <code>setUniformAction(n, f)</code> method of the <code>setUniformAction(n, f)</code> object.  The arguments of this method have the following value: n - the name of the variable in the shader (in the method it is specified as a string);  f is a function of type <code>function(u, o, m)</code> , where u is an object uniform (), o is an object itself, m is a material.  For example, binding the ‚Äúcolor‚Äù parameter to the color of an object is performed as <br><br><pre> <code class="hljs scala">lights.setUniformAction(<span class="hljs-symbol"><span class="hljs-symbol">'colo</span></span>r', function(uniform, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">material</span></span></span><span class="hljs-class">)</span></span>{ $<span class="hljs-type"><span class="hljs-type">W</span></span>.<span class="hljs-type"><span class="hljs-type">GL</span></span>.uniform4fv(uniform.location, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color</span></span></span><span class="hljs-class">)</span></span>; });</code> </pre><br><br>  To set a non-standard material to an object, use the object property <code>setMaterial(mat)</code> , where mat is the material we need.  Since JavaScript allows you to add properties to already defined objects on the fly, we can easily make changes to objects to coordinate them with our shaders. <br><br>  Let's create this scene with WebGLU: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ba/293/339/4ba2933397b679213f03cac566a613a4.png"><br><br>  Here inheritance of objects is used: the main vertical cylinder inherits the second cylinder and the upper circle.  That, in turn, inherits the lower circle and a set of multi-colored spheres of different sizes, placed randomly in a plane between two circles.  The entire scene is illuminated by a single directional light source (orange ‚Äúflashlight‚Äù), indicated by a small orange sphere. <br><br>  To use the lighting, we definitely need to correctly calculate the normals to all the vertices that will be processed by our ‚Äúlighter‚Äù shaders.  We can draw the sphere using the <code>genSphere(n1,n2,rad)</code> function of the <code>genSphere(n1,n2,rad)</code> library, but we will have to draw the cylinders ourselves.  The easiest way to do this is to fill the side surface of the cylinder with connected triangles: <br><br><pre> <code class="html hljs xml">function drawCylinder(R, H, n, flags){ var v = [], norm = []; var C = new $W.Object($W.GL.TRIANGLE_STRIP, flags); C.vertexCount = n * 2+2; for(var i = -1; i <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++){ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">_2PI/n*i;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cc</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">Math.cos(a),</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ss</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">Math.sin(a);</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">v.concat([R*cc,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span><span class="hljs-tag">*</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ss</span></span></span><span class="hljs-tag">,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.</span></span></span><span class="hljs-tag">]); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">v.concat([R*cc,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span><span class="hljs-tag">*</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ss</span></span></span><span class="hljs-tag">,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">H</span></span></span><span class="hljs-tag">]); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">norm</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">norm.concat([-cc,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-ss</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.</span></span></span><span class="hljs-tag">]); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">norm</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">norm.concat([-cc,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-ss</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.</span></span></span><span class="hljs-tag">]); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.fillArray</span></span></span><span class="hljs-tag">("</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">vertex</span></span></span><span class="hljs-tag">", </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.fillArray</span></span></span><span class="hljs-tag">("</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">normal</span></span></span><span class="hljs-tag">", </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">norm</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span><span class="hljs-tag">; }</span></span></code> </pre><br>  This method, as you will see later, is rather primitive: due to the fact that we don‚Äôt place vertices on the surface of the cylinder between its ends, the illumination for it is calculated incorrectly: if the ‚Äúlantern‚Äù illuminates only the middle of the cylinder surface, without capturing its ends displayed unlit.  To draw the cylinder correctly, you need to add additional intermediate vertices and fill the array of indices to correctly display the triangles.  Another option is to draw a composite object (with children) from several rectangles, each of which consists of a set of triangles. <br><br>  We will draw circles using the function <br><br><pre> <code class="html hljs xml">function drawCircle(R, n, w, flags){ var v = []; var C = new $W.Object($W.GL.LINE_LOOP, flags); C.vertexCount = n; for(var i = 0; i <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++){ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">_2PI/n*i;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">v.concat([R*Math.cos(a),</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">R</span></span></span><span class="hljs-tag">*</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Math.sin</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span><span class="hljs-tag">),</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.</span></span></span><span class="hljs-tag">]); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.fillArray</span></span></span><span class="hljs-tag">("</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">vertex</span></span></span><span class="hljs-tag">", </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typeof</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">w</span></span></span><span class="hljs-tag">) != </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"undefined"</span></span></span><span class="hljs-tag">) </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.WD</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">w;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.WD</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">1.;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C.draw</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">function(){</span></span></span><span class="hljs-tag"> //       </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">oldw</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">$W.GL.getParameter($W.GL.LINE_WIDTH);</span></span></span><span class="hljs-tag"> $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.lineWidth</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">this.WD</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">this.drawAt</span></span></span><span class="hljs-tag">( </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">this.animatedPosition</span></span></span><span class="hljs-tag">()</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.elements</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">this.animatedRotation</span></span></span><span class="hljs-tag">()</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.matrix</span></span></span><span class="hljs-tag">(), </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">this.animatedScale</span></span></span><span class="hljs-tag">()</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.elements</span></span></span><span class="hljs-tag"> ); $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.lineWidth</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">oldw</span></span></span><span class="hljs-tag">); }; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">C</span></span></span><span class="hljs-tag">; }</span></span></code> </pre><br>  To be able to change the thickness of the lines that draw circles, we will need to override the <code>draw()</code> function of this object (because the <code>$W.GL.lineWidth(w)</code> function sets the thickness of the w line globally - until the next call to this function).  If you change the <code>$W.GL.LINE_LOOP</code> of this object to <code>$W.GL.POINTS</code> , the circles will be drawn with dots.  The size of the points will depend on the property of the <code>WD</code> object due to the fact that we use for it the ‚Äúmaterial‚Äù points, which indicates <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">gl_PointSize</span></span> = WD;</code> </pre>  <a href="">Here</a> you can see the fragment shader code for displaying points of different sizes, and <a href="">here</a> - the vertex shader. <br><br>  So, the objects we created.  It was the turn to create shaders to calculate the lighting.  In any OpenGL reference for calculating the final color of a vertex when illuminated by several sources, you can find the following formula: <br><br><pre> <code class="hljs lisp"> result_Color = mat_emission + lmodel_ambient * mat_ambient Sum_i(<span class="hljs-name"><span class="hljs-name">D</span></span> * S * [l_ambient * mat_ambient + max{dot(L,n),0}*l_diffuse*mat_diffuse + max{dot(<span class="hljs-name"><span class="hljs-name">s</span></span>,n),<span class="hljs-number"><span class="hljs-number">0</span></span>}^mat_shininess * l_specular * mat_specular )</code> </pre><br>  Here <br><ul><li>  result_Color - the final color of the vertex, </li><li>  mat_X - material properties </li><li>  l_X - properties of the i-th light source </li><li>  X: <ul><li>  emission - emitted light (i.e. material is a source of light), </li><li>  lmodel_ambient - the general diffused light of the lighting model (does not depend on the sources, i.e. it is background light) </li><li>  ambient - background light (the color of the material outside the light sources, the diffuse light component of the i-th light source) </li></ul></li><li>  D is the light attenuation coefficient, D = 1 / (kc + kl * d + kq * d ^ 2), <ul><li>  d is the distance from the source to the top, </li><li>  kc is the constant attenuation coefficient (‚Äúgray filter‚Äù), </li><li>  kl is the linear attenuation coefficient, </li><li>  kq is the quadratic attenuation coefficient, </li></ul></li><li>  S is the searchlight effect, calculated as follows: <br>  = 1 if the light source is not a searchlight (infinitely remote parallel beam), <br>  = 0 if the source is a searchlight, but the top is outside the radiation cone, <br>  = max {dot (v, dd), 0} ^ GL_SPOT_EXPONENT in other cases, here v is the normalized vector from the searchlight (GL_POSITION) to the top, dd (GL_SPOT_DIRECTION) is the orientation of the searchlight </li><li>  L = -v (normalized vector from the vertex to the source), </li><li>  n is the normal to the vertex </li><li>  diffuse - diffused light, does not depend on the angle of incidence / reflection, </li><li>  s is the normalized vector equal to the sum of L and the vector from the top to the eye, </li><li>  shininess - the degree of gloss (from 0 to 128, the more, the more brilliant the surface is), </li><li>  specular - the color of the mirror component. </li></ul><br>  We can simplify this formula if we take into account that the usually diffuse and background color of the material coincide, the background color of the spotlight coincides with the diffuse color of the general background illumination, and the constant and linear attenuation coefficients can be omitted.  As a result, we get <a href="">such a</a> fragment shader.  <a href="">In</a> addition to calculating the vertex display coordinates, the vertex <a href="">shader</a> should recalculate, based on the model-specific matrix of the object, the vertex position in space and its normal orientation (this must be done, since we can move, scale, and rotate each object). <br><br>  Now it remains for us to determine the properties of our ‚Äúlantern‚Äù: <br><br><pre> <code class="hljs dos"> light = { position: [<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">2</span></span>.,<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>], target: [<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">0</span></span>.,-<span class="hljs-number"><span class="hljs-number">2</span></span>.], <span class="hljs-built_in"><span class="hljs-built_in">color</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>.,.<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>.,<span class="hljs-number"><span class="hljs-number">1</span></span>.], fieldAngle: <span class="hljs-number"><span class="hljs-number">60</span></span>., exponent: <span class="hljs-number"><span class="hljs-number">5</span></span>., distanceFalloffRatio: .<span class="hljs-number"><span class="hljs-number">02</span></span> };</code> </pre><br>  using <code>setUniformAction(‚Ä¶)</code> to connect the properties of the ‚Äúflashlight‚Äù and the properties of objects with variable shaders and set individual properties for each object using this ‚Äúmaterial‚Äù. <br><br>  After we do all this, we animate the scene using the <code>$W.start(T);</code> function <code>$W.start(T);</code>  where T is the minimum interval between scene rendering.  If our scene is too complex, we will have to draw it after each change manually using the <code>$W.util.defaultUpdate();</code> functions <code>$W.util.defaultUpdate();</code>  and <code>$W.util.defaultDraw();</code>  .  These functions do not affect the compilation of shaders (which should be performed only when making drastic changes to the shaders themselves), so our scene will ‚Äúfreeze‚Äù only at the time of initial loading (during initialization), and also slow down a little when the window is resized. <br><br>  Finally, I will say that the function of rotating the scene (more precisely, moving the camera around the scene) from WebGLU is not very convenient, so it‚Äôs worth defining your movement function.  <a href="http://dl.dropbox.com/u/78717568/WGL/index.html">Here</a> (and also at the address of the example specified at the very beginning) you can see what the final html file looks like. <br><br><br><br>  The article turned out to be quite large, despite the fact that I did not mention working with the selection buffer (if we need to realize the identification of objects by a mouse click), the display of objects when mixing (and this is necessary for using the transparency component in the color of the object), clipping the ‚Äúback‚Äù surfaces of figures and much more.  I hope this article about WebGL is not the last (or maybe someone else will continue my initiative). <br><br><br><br><br><br>  UPD: I tried to use the getObjectIDAt and usePicking functions from the crazyglu.js file to provide a choice, however, these attempts were not successful: the library is damp.  Therefore, the function was written independently. <br><br>  So, what is needed to implement the selection buffer. <br><br>  First, we cannot use the <code>$W.start(p)</code> function, otherwise we run the risk of ‚Äúrunning into‚Äù updating the image with a timer when we write to the selection buffer.  Therefore, we need to take care of drawing the scene after each change in it. <br><br>  Second, we need to create a ‚Äúglobal material‚Äù ( <code>MatPick</code> ) for the selection buffer and initialize it, as well as initialize the buffer itself: <br><br><pre> <code class="html hljs xml"> //  ""    MatPick = new $W.Material({path:$W.paths.materials + "pick.json"}); MatPick.setUniformAction('pickColor', function(uniform, object, material){ var colr = [0.,0.,0.,0.]; var id = object.id; for(var i = 0; i <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++){ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">colr</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">] = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">(id</span></span></span><span class="hljs-tag"> &amp; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0xff</span></span></span><span class="hljs-tag">)/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">256.</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag"> &gt;</span></span>&gt;= 8; } $W.GL.uniform4fv(uniform.location, colr); } ); //    try{ $W.pickBuffer = new $W.Framebuffer(); $W.pickBuffer.attachTexture($W.GL.RGBA, $W.canvas.width, $W.canvas.height, $W.GL.COLOR_ATTACHMENT0); $W.pickBuffer.attachRenderbuffer($W.GL.DEPTH_COMPONENT16, $W.canvas.width, $W.canvas.height, $W.GL.DEPTH_ATTACHMENT); }catch (e) { console.error(e); }</code> </pre><br><br>  Making the choice is done according to the standard scheme: the object identifier (a 32-bit integer, preferably positive, it is possible and negative, but not equal to -1) is divided into bytes, which are converted into a floating-point number - an object color component.  The float guarantees that rounding errors will not give the possibility of a random error (when the identifier a is converted to a ¬± 1).  The shaders for displaying the selection buffer are so simple that I won't even bring them here. <br><br>  Thirdly, you need to slightly change the code of the Objects.js file (to initialize identifiers by default), as well as Util.js (to save the contents of the drawing buffer after displaying its contents on the screen, otherwise the choice will not work). <br><br>  Finally, we need to write a selection function that will draw objects into the selection buffer and get the color value under the cursor.  To do this, after displaying all the objects, we save their ‚Äúmaterials‚Äù into the <code>oldmat</code> array, and when drawing the selection buffer, temporarily change all the ‚Äúmaterials‚Äù to our <code>MatPick</code> , fill the buffer and get the color value at the desired point.  And already by the color value we define the object identifier (or its absence, if id == - 1): <br><br><pre> <code class="html hljs xml">function pick(X,Y){ //  var ccolr = $W.GL.getParameter($W.GL.COLOR_CLEAR_VALUE); var blend = $W.GL.getParameter($W.GL.BLEND); if(blend) $W.GL.disable($W.GL.BLEND); $W.GL.clearColor(1., 1., 1., 1.); //    "-1" $W.pickBuffer.bind(); //  ""  $W.util.defaultUpdate(); $W.util.clear(); $W.util.setupMatrices(); for (var i = 0; i <span class="hljs-tag"><span class="hljs-tag">&lt; $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.objects.length</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++) { $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.objects</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.material</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">MatPick;</span></span></span><span class="hljs-tag"> //  "" } $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.util.defaultDraw</span></span></span><span class="hljs-tag">(); //   </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag"> &lt; $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.objects.length</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">++) { $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.objects</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.material</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">oldmat[i];</span></span></span><span class="hljs-tag"> //  "" } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pix</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">new</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Uint8Array</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span><span class="hljs-tag">); $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.readPixels</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">X</span></span></span><span class="hljs-tag">,$</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.canvas.height-Y</span></span></span><span class="hljs-tag">,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">,</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">,$</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.RGBA</span></span></span><span class="hljs-tag">, $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.UNSIGNED_BYTE</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pix</span></span></span><span class="hljs-tag">); $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.pickBuffer.unbind</span></span></span><span class="hljs-tag">(); //   </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">blend</span></span></span><span class="hljs-tag">) $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.enable</span></span></span><span class="hljs-tag">($</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.BLEND</span></span></span><span class="hljs-tag">); $</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">W.GL.clearColor</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ccolr</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">],</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ccolr</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">],</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ccolr</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">],</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ccolr</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag">]); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">pix[0]+(pix[1]</span></span></span><span class="hljs-tag">&lt;&lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">8</span></span></span><span class="hljs-tag">)+(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pix</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">]&lt;&lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">16</span></span></span><span class="hljs-tag">)+(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pix</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag">]&lt;&lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">24</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">delete</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pix</span></span></span><span class="hljs-tag">; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">str</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"X="</span></span></span><span class="hljs-tag"> + </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">X</span></span></span><span class="hljs-tag"> + ", </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Y</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" + Y+ "</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ID</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+id; alert(str); } &lt;/code&gt; &lt;br&gt;&lt;br&gt;   :           . &lt;br&gt;&lt;br&gt; :  google-chrome     (     ).</span></span></span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/143680/">https://habr.com/ru/post/143680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143674/index.html">Character modeling and graphic design for a mobile game</a></li>
<li><a href="../143675/index.html">The digest of interesting news and materials from the world of ayti for the last week No. 5 (May 5 - 11, 2012)</a></li>
<li><a href="../143676/index.html">15 years ago the computer Deep Blue beat a man in chess</a></li>
<li><a href="../143678/index.html">First, but detailed look at the Samsung Galaxy S III [Video]</a></li>
<li><a href="../143679/index.html">RetroBSD on Maximite</a></li>
<li><a href="../143682/index.html">Tesla Cannon</a></li>
<li><a href="../143683/index.html">LinkedIn is considering buying a portal Monster.com</a></li>
<li><a href="../143684/index.html">Skype for Linux. It's too early to bury me</a></li>
<li><a href="../143685/index.html">Weekly Digest # 3: Simple-Science - Simple Experiments</a></li>
<li><a href="../143687/index.html">User experience design: how to build a website for customers, not for yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>