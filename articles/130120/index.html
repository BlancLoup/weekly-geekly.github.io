<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Characteristic features of the Dart language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dart was designed to look familiar to programmers in languages ‚Äã‚Äãsuch as Java and JavaScript. If you try, you can write on Dart almost the same as on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Characteristic features of the Dart language</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/c4f3bd3b/eb19412d/52d647e7/30c76279.png" align="left">  Dart was designed to look familiar to programmers in languages ‚Äã‚Äãsuch as Java and JavaScript.  If you try, you can write on Dart almost the same as on one of them.  If you <i>really</i> try - you can even turn it into FORTRAN, but at the same time you will miss many of the unique and cool features of Dart. <br><br>  This article will help you learn how to write code in the style of Dart.  Since the language is still actively developing, many idioms can also change in the future.  In some places we have not yet decided what is the best practice (maybe you can help us?) However, here are a few points that you should pay attention to to switch your brains from Java or JavaScript mode to Dart mode. <br><a name="habracut"></a><br><h4>  Constructors </h4><br>  We will begin this article in the same way that objects start their lives - with constructors.  Each object will have to be created in the constructor, and its definition is an important point in creating a quality class.  Dart has some interesting features. <br><br><h5>  Automatic field initialization </h5><br>  To get started, get rid of boring reps.  Constructors often take arguments and simply assign their values ‚Äã‚Äãto the fields of the class: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ num x, y; Point(num x, num y) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } }</code> </pre> <br>  We had to type <code>x</code> four times just to initialize the field.  Sucks!  Better to do this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ num x, y; Point(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y); }</code> </pre><br>  If in the constructor argument list before the argument name goes <code>this.</code>  , the field with this name will be automatically initialized with the argument value.  In our example, another small trick is used - if the body of the constructor is empty, you can use it <code>;</code>  instead of <code>{}</code> . <br><br><h5>  Named Constructors </h5><br>  Like most dynamic languages, Dart does not support overloading.  In the case of methods, this is not so scary, because we can just think of another name.  Constructors are less fortunate.  To ease their plight, Dart allows you to use named constructors: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">Point</span></span> { num x, y; <span class="hljs-type"><span class="hljs-type">Point</span></span>(this.x, this.y); <span class="hljs-type"><span class="hljs-type">Point</span></span>.zero() : x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">Point</span></span>.polar(num theta, num radius) { x = Math.cos(theta) * radius; y = Math.sin(theta) * radius; } }</code> </pre><br>  The class <code>Point</code> has three constructors ‚Äî a regular one and two named.  Here's how to use them: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point.zero(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point.polar(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">4.0</span></span>);</code> </pre><br>  Note that we use <code>new</code> with named constructors, these are not ordinary static methods. <br><br><h5>  Factory Designers </h5><br>  Sometimes it is useful to use the ‚Äúfactory‚Äù design pattern.  For example, you need to create an instance of a class, but some flexibility is needed, just to hard-code a constructor call is not enough.  Perhaps you want to return the cached instance, if any, or an object of another type. <br><br>  Dart allows you to do this without changing the code in the place where the object is created.  You can create a factory constructor that is invoked just like a normal one.  For example: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Symbol</span></span></span><span class="hljs-class"> </span></span>{ final <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>&gt; _cache; factory <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cache == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _cache = {}; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cache.containsKey(name)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _cache[name]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { final symbol = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>._internal(name); _cache[name] = symbol; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> symbol; } } <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>._internal(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name); }</code> </pre><br>  We defined the <code>Symbol</code> class.  A character is about the same as a string, but we want to ensure that at any given time there is only one character with the given name.  This makes it possible to safely test symbols for equality, simply by making sure that they point to the same object. <br><br>  Before defining a default constructor (nameless) there is a keyword <code>factory</code> .  When it is called, a new object is not created ( <code>this</code> missing from the factory constructor).  Instead, we need to explicitly create and return an object.  In this example, we first check if there is a character with the same name in the cache, and return it if there is one. <br><br>  It's cool that all this is transparent to the calling code: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'something'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'something'</span></span>);</code> </pre><br>  The second call does not actually create a new character, but returns an existing one.  This is convenient, because if at first we didn‚Äôt need a factory constructor, and then it turned out that we did, we wouldn‚Äôt have to change <code>new</code> somewhere in the code to call a static factory method. <br><br><h4>  Functions </h4><br>  As in most modern languages, Dart functions are first-class objects, with closures and a lightweight version of the syntax.  Any function is an object, and you can do anything with it.  We make extensive use of functions for event handlers. <br><br>  There are three ways to create functions in Dart.  The first is named functions: <br><br><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayGreeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String salutation, String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> greeting = <span class="hljs-string"><span class="hljs-string">'$salutation $name'</span></span>; print(greeting); }</code> </pre><br>  It looks like a regular function declaration in C or a method in Java or JavaScript.  Unlike C and C ++, function declarations can be nested.  The second method is anonymous functions: <br><br><pre> <code class="hljs cs">window.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>.click.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>) { print(<span class="hljs-string"><span class="hljs-string">'You clicked the window.'</span></span>); })</code> </pre><br>  In this example, we pass an anonymous function to the <code>add()</code> method as an event handler.  Finally, for small functions consisting of a single expression, there is a simplified syntax: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> odd = items.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>((i) =&gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(odd); <span class="hljs-comment"><span class="hljs-comment">// [1, 3, 5]</span></span></code> </pre><br>  The argument in brackets, followed by the arrow ( <code>=&gt;</code> ) and the expression, create a function that takes this argument and returns the result of evaluating the expression. <br><br>  In practice, we prefer to use the switch notation wherever possible, because of its brevity (not to the detriment of expressiveness).  We often use anonymous functions for event handlers and callbacks.  Named functions are rarely used. <br><br>  There is another trick in Dart (this is one of my favorite language chips) - you can use <code>=&gt;</code> to define class members.  Of course, you can do it like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Rectangle</span></span> { num width, height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num x, num y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; width) &amp;&amp; (y &lt; height); } <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; } }</code> </pre><br>  But why, if it is possible so: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> </span></span>{ num width, height; bool contains(num x, num y) =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x &lt; width</span></span></span><span class="hljs-function">) &amp;&amp; (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y &lt; height</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> width * height; }</code> </pre><br>  We find a great arrow notation for defining simple getters / setters and other one-line functions. <br><br><h4>  Fields, getters and setters </h4><br>  To work with properties Dart uses the standard syntax of the form <code>object.someProperty</code> .  In Dart, you can define methods that will look like a call to a class field, but still execute arbitrary code.  As in other languages, such methods are called getters and setters: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Rectangle</span></span> { num left, top, width, height; <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; left + width; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; left = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - width; <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; top + height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; top = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - height; Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.top, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height); }</code> </pre><br><br>  We have a <code>Rectangle</code> class with four ‚Äúreal‚Äù properties ‚Äî <code>left</code> , <code>top</code> , <code>width</code> , and <code>height</code> and two logical properties in the form of getters and setters ‚Äî <code>right</code> and <code>bottom</code> .  When using the class, there is no visible difference between natural fields and getters and setters: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rect = new <span class="hljs-type"><span class="hljs-type">Rectangle</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(rect.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(rect.bottom); rect.top = <span class="hljs-number"><span class="hljs-number">6</span></span>; rect.<span class="hljs-keyword"><span class="hljs-keyword">right</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre><br>  Erasing the border between fields and getters / setters is one of the fundamental properties of a language.  It is best to think of the fields as a set of ‚Äúmagic‚Äù getters and setters.  From this it follows that you can completely override the inherited getter with a natural field and vice versa.  If the interface requires a getter, in the implementation you can simply specify a field with the same name and type.  If the field is mutable (not <code>final</code> ), you can write the setter required by the interface. <br><br>  In practice, this means that there is no need to carefully isolate class fields with a bunch of getters and setters, as in Java or C #.  Feel free to announce public properties.  If you want to prevent them from being modified, use the <code>final</code> keyword. <br><br>  Later, if it becomes necessary to do a validation or something else like this, you can always replace this field with a getter and a setter.  For example, we want our <code>Rectangle</code> class to always have a non-negative size: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Rectangle</span></span> { num left, top; num _width, _height; <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">width</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; _width; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">width</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">'Width cannot be negative.'</span></span>; _width = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; _height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">'Height cannot be negative.'</span></span>; _height = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; left + width; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; left = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - width; <span class="hljs-function"><span class="hljs-function">num </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; top + height; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bottom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; top = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - height; Rectangle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.top, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._width, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._height); }</code> </pre><br>  We added validation to the class without having to change the code in any other place. <br><br><h4>  Top level definitions </h4><br>  Dart is a pure object-oriented language.  All that can be placed in a variable is an object (no mutable ‚Äúprimitives‚Äù), and each object is an instance of a class.  However, this is not a ‚Äúdogmatic‚Äù OOP ‚Äî it is not necessary to put everything inside the classes.  Instead, you can define variables, functions, and even getters and setters at the top level. <br><br><pre> <code class="hljs pgsql">num abs(num <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; final TWO_PI = Math.PI * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> today() { final <span class="hljs-type"><span class="hljs-type">date</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DateTime.now(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">date</span></span>.day; }</code> </pre><br>  Even in languages ‚Äã‚Äãthat do not require to place all certain classes or objects, such as JavaScript, it is customary to do so in order to avoid name conflicts: global definitions in different places may collide.  To cope with this, Dart has a library system that allows you to import definitions from other files, adding prefixes to them to avoid ambiguity.  So there is no need to hide definitions inside classes. <br><br>  We are still exploring how this feature can affect the way libraries are written.  Most of our code places definitions inside classes, such as <code>Math</code> .  It is difficult to say that this is an ingrained habit from other languages, or a programming practice that is also useful for Dart.  In this area, we really need feedback from other developers. <br><br>  We have several examples of using top-level definitions.  First of all - this is <code>main()</code> .  When working with the DOM, the ‚Äúvariables‚Äù <code>document</code> and <code>window</code> are getters defined at the top level. <br><br><h4>  Strings and interpolation </h4><br>  Dart has several kinds of string literals.  You can use double and single quotes, as well as triple quotes for multi-line literals: <br><br><pre> <code class="hljs python"><span class="hljs-string"><span class="hljs-string">'I am a "string"'</span></span> <span class="hljs-string"><span class="hljs-string">"I'm one too"</span></span> <span class="hljs-string"><span class="hljs-string">'''I'm on multiple lines '''</span></span> <span class="hljs-string"><span class="hljs-string">""" As am I """</span></span></code> </pre><br>  To combine multiple lines into one, you can use concatenation: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> salutation = <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeting = salutation + <span class="hljs-string"><span class="hljs-string">', '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>;</code> </pre><br>  But interpolation will be cleaner and faster: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">var</span></span> name = <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">var</span></span> salutation = <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">var</span></span> greeting = <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$salutation</span></span></span><span class="hljs-string">, </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">'</span></span>;</code> </pre><br>  In place of the dollar sign ( <code>$</code> ), followed by the variable name, the value of the variable will be substituted (if it is not a string, the <code>toString()</code> method will be called).  Expressions can be placed inside curly brackets: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>('<span class="hljs-type"><span class="hljs-type">The</span></span> area of a circle with radius $r <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ${<span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-type"><span class="hljs-type">PI</span></span> * r * r}');</code> </pre><br><h4>  Operators </h4><br>  Dart uses the same operators, with the same priorities as C, Java, and other similar languages.  They will behave as you expect.  However, the internal implementation has its own characteristics.  In Dart, an expression with a <code>1 + 2</code> operator is just a syntactic sugar for calling a method.  From the point of view of language, this example looks like <code>1.+(2)</code> . <br><br>  This means that you can overload most operators by creating your own types.  For example, the <code>Vector</code> class: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector</span></span></span><span class="hljs-class"> </span></span>{ num x, y; Vector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y); <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(Vector other) =&gt; new Vector(x + other.x, y + other.y); }</code> </pre><br><br>  Now we can add vectors using familiar syntax: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> velocity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newPosition = position + velocity;</code> </pre><br><br>  However, you should not abuse this opportunity.  We give you car keys in the hope that you will not ram the pillars. <br><br>  In practice, if the types you define are used by operators in the real world, this is a good indication that it is worth redefining standard operators for them: complex numbers, vectors, matrices, etc.  In all other cases, operators should not be overloaded.  Types with overloaded operators usually must be immutable. <br><br>  It is worth noting that since operators are calls to methods, asymmetry is inherent in them.  The method search is always done for the left argument.  So when you write <code>a + b</code> , the meaning of the operation depends on the type <code>a</code> . <br><br><h4>  Equality </h4><br>  This set of operators should be given special attention.  Dart has two pairs of equality operators: <code>==</code> and <code>!=</code> And <code>===</code> and <code>!==</code> .  It looks familiar to JavaScript programmers, but here they work a little differently. <br><br>  <code>==</code> and <code>!=</code> serve to check for equivalence.  99% of the time you will use them.  Unlike JavaScript, they do not make any implicit conversions, so they will behave more predictably.  Do not be afraid to use them!  Unlike Java, they work with any types for which an equivalence relation is defined.  No more <code>someString.equals("something")</code> . <br><br>  You can overload <code>==</code> for your types, if that makes sense.  There is no need to overload <code>!=</code> , Dart will automatically output it from <code>==</code> . <br><br>  The second pair of operators, <code>===</code> and <code>!==</code> , is used to check for identity.  <code>a === b</code> returns <code>true</code> only if <code>a</code> and <code>b</code> are the same object in memory.  You rarely have to use them in practice.  By default, <code>==</code> relies on <code>===</code> if the type does not define an equivalence relation, so <code>===</code> will be needed in a single case ‚Äî to bypass the user-defined <code>==</code> . </div><p>Source: <a href="https://habr.com/ru/post/130120/">https://habr.com/ru/post/130120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130113/index.html">Disruptor - a new paradigm for multi-threaded programming</a></li>
<li><a href="../130114/index.html">Lisp music programming</a></li>
<li><a href="../130115/index.html">Golden T Game Engine (GTGE) - first acquaintance</a></li>
<li><a href="../130117/index.html">Secondary account authentication on the site</a></li>
<li><a href="../130118/index.html">Video review of Android applications and games - kedDroid</a></li>
<li><a href="../130122/index.html">Google Developer Day 2011: sections visited</a></li>
<li><a href="../130123/index.html">mutex, spinlock, buslock. Overhead</a></li>
<li><a href="../130124/index.html">RU-CENTER resents</a></li>
<li><a href="../130125/index.html">TP-LINK Wireless Router Vulnerability</a></li>
<li><a href="../130127/index.html">Facebook has released an application for iPad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>