<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AsyncIO for practicing python developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I remember that moment when I thought, ‚ÄúHow slowly does everything work, what if I parallelize calls?‚Äù, And after 3 days, looking at the code, I could...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AsyncIO for practicing python developer</h1><div class="post__text post__text-html js-mediator-article">  I remember that moment when I thought, ‚ÄúHow slowly does everything work, what if I parallelize calls?‚Äù, And after 3 days, looking at the code, I couldn‚Äôt understand anything in the terrible mess of streams, synchronizers and callback functions. <br><br>  Then I met with <a href="https://docs.python.org/dev/library/asyncio.html">asyncio</a> , and everything changed. <br><a name="habracut"></a><br>  If anyone does not know, asyncio is a new module for organizing competitive programming, which appeared in Python 3.4.  It is designed to simplify the use of corutin and futur in asynchronous code - so that the code looks like synchronous, without callbacks. <br><br>  I remember at that time there were several similar tools, and one of them stood out - this is the <a href="http://www.gevent.org/">gevent</a> library.  I advise everyone to read the excellent <a href="http://sdiehl.github.io/gevent-tutorial/">gevent guide for a practicing python developer</a> , which describes not only <a href="http://sdiehl.github.io/gevent-tutorial/">how to</a> work with it, but what competition is in the general sense.  I liked the article so much that I decided to use it as a template for writing an introduction to asyncio. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A small disclaimer is an article not gevent vs asyncio.  Nathan Road has already done it for me in his <a href="http://www.getoffmalawn.com/blog/playing-with-asyncio">article</a> .  All examples you can find on <a href="https://github.com/yeraydiazdiaz/asyncio-ftwpd">github</a> . <br><br>  I know you‚Äôre not anxious to write code, but first I would like to consider several concepts that will be useful to us in the future. <br><br><h2>  Threads, event loops, cortices and futures </h2><br>  Threads are the most common tool.  I think you have heard of it before, but asyncio operates with slightly different concepts: event loops, cortutina and futures. <br><br><ul><li>  the <a href="https://docs.python.org/dev/library/asyncio-eventloop.html">event loop</a> for the most part just controls the execution of various tasks: it registers the arrival and starts at the right moment </li><li>  <a href="https://docs.python.org/3.5/library/asyncio-task.html">Korutinas</a> are special functions, similar to python generators, that are expected ( <b>await</b> ) to give control back to the event loop.  It is necessary that they be launched exactly through the event loop. </li><li>  <a href="https://docs.python.org/3.5/library/asyncio-task.html">futures</a> are objects in which the current result of a task is stored.  This may be information that the task has not yet been processed or the result already obtained;  or maybe an exception </li></ul><br>  Pretty simple?  Go! <br><br><h2>  Synchronous and asynchronous execution </h2><br>  In the video " <a href="https://vimeo.com/49718712">Competition is not concurrency, it is better.</a> " Rob Pike draws your attention to the key thing.  The division of tasks into competitive subtasks is possible only with such parallelism, when it also controls these subtasks. <br><br>  Asyncio does the same thing - you can break your code into procedures that you define as Korutin, which makes it possible to manage them as you wish, including simultaneous execution.  The korutinas contain the yield statements, with the help of which we determine the places where you can switch to other pending tasks. <br><br>  The context switch in asyncio is answered by yield, which transfers control back to the event loop, and that in turn is transferred to another corortina.  Consider a basic example: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Running in foo'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Explicit context switch to foo again'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Explicit context to bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Implicit context switch back to bar'</span></span>) ioloop = asyncio.get_event_loop() tasks = [ioloop.create_task(foo()), ioloop.create_task(bar())] wait_tasks = asyncio.wait(tasks) ioloop.run_until_complete(wait_tasks) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 1-sync-async-execution-asyncio-await.py Running <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo Explicit context to bar Explicit context switch to foo again Implicit context switch back to bar</code> </pre> <br>  * First, we announced a couple of simplest corutin, which pretend to be non-blocking, using <b>sleep</b> from asyncio <br>  * Korutiny can only be run from another korutiny, or wrapped in a task using <b>create_task</b> <br>  * After we have 2 tasks, combine them using <b>wait</b> <br>  * And finally, we will send for execution to the event loop via <b>run_until_complete</b> <br><br>  Using <b>await</b> in any corintine, we thus declare that the coroutine can give control back to the event loop, which, in turn, will launch some of the following tasks: bar.  In bar, the same thing happens: on <b>await asyncio.sleep, the</b> control will be transferred back to the event loop, which will return to the execution of foo at the right time. <br><br>  Imagine 2 blocking tasks: gr1 and gr2, as if they are accessing some third-party services, and while they are waiting for a response, the third function can work asynchronously. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'at %1.1f seconds'</span></span> % (time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gr1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Busy waits for a second, but we don't want to stick around... print('gr1 started work: {}'.format(tic())) await asyncio.sleep(2) print('gr1 ended work: {}'.format(tic())) async def gr2(): # Busy waits for a second, but we don't want to stick around... print('gr2 started work: {}'.format(tic())) await asyncio.sleep(2) print('gr2 Ended work: {}'.format(tic())) async def gr3(): print("Let's do some stuff while the coroutines are blocked, {}".format(tic())) await asyncio.sleep(1) print("Done!") ioloop = asyncio.get_event_loop() tasks = [ ioloop.create_task(gr1()), ioloop.create_task(gr2()), ioloop.create_task(gr3()) ] ioloop.run_until_complete(asyncio.wait(tasks)) ioloop.close()</span></span></code> </pre> <br><pre> <code class="bash hljs">$ python3 1b-cooperatively-scheduled-asyncio-await.py gr1 started work: at 0.0 seconds gr2 started work: at 0.0 seconds Lets <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> some stuff <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> the coroutines are blocked, at 0.0 seconds Done! gr1 ended work: at 2.0 seconds gr2 Ended work: at 2.0 seconds</code> </pre> <br>  Notice how I work with I / O and scheduling, allowing it all to fit in one thread.  While two tasks are blocked by waiting for I / O, the third function may take up all the CPU time. <br><br><h2>  Execution order </h2><br>  In the synchronous world, we think consistently.  If we have a list of tasks that take different time to complete, they will end in the same order in which they were processed.  However, in the case of competition one cannot be sure of it. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sleep <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pid)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Synchronous non-deterministic task. """</span></span> sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">0.001</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Task %s done'</span></span> % pid) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_coro</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pid)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Coroutine non-deterministic task """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">0.001</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Task %s done'</span></span> % pid) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): task(i) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> tasks = [asyncio.ensure_future(task_coro(i)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait(tasks) print(<span class="hljs-string"><span class="hljs-string">'Synchronous:'</span></span>) synchronous() ioloop = asyncio.get_event_loop() print(<span class="hljs-string"><span class="hljs-string">'Asynchronous:'</span></span>) ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 1c-determinism-sync-async-asyncio-await.py Synchronous: Task 1 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 2 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 3 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 4 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 5 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 6 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 7 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 8 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 9 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Asynchronous: Task 2 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 5 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 6 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 8 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 9 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 1 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 4 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 3 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Task 7 <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Of course, your result will be different, because each task will fall asleep for a random time, but notice that the result is completely different, although we always set tasks in the same order. <br><br>  Also pay attention to quorutine for our rather simple task.  It is important to understand that there is no magic in asyncio when implementing non-blocking tasks.  During implementation, asyncio stood alone in the standard library, since  the remaining modules provided only blocking functionality.  You can use the <a href="https://docs.python.org/3/library/concurrent.futures.html">concurrent.futures</a> module to wrap blocking tasks into threads or processes and get futures for use in asyncio.  Several such examples <a href="https://github.com/yeraydiazdiaz/asyncio-ftwpd">are available on GitHub</a> . <br>  This is probably the main drawback now when using asyncio, however there are already several libraries that can help solve this problem. <br><br>  The most popular blocking task is retrieving data via an HTTP request.  Consider working with the magnificent <a href="http://tp.readthedocs.org/">aiohttp</a> library on the example of getting information about public events on GitHub. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urllib.request <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp URL = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/events'</span></span> MAX_CLIENTS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_sync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pid)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Fetch sync process {} started'</span></span>.format(pid)) start = time.time() response = urllib.request.urlopen(URL) datetime = response.getheader(<span class="hljs-string"><span class="hljs-string">'Date'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Process {}: {}, took: {:.2f} seconds'</span></span>.format( pid, datetime, time.time() - start)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pid)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'Fetch async process {} started'</span></span>.format(pid)) start = time.time() response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, URL) datetime = response.headers.get(<span class="hljs-string"><span class="hljs-string">'Date'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Process {}: {}, took: {:.2f} seconds'</span></span>.format( pid, datetime, time.time() - start)) response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> datetime <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> start = time.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, MAX_CLIENTS + <span class="hljs-number"><span class="hljs-number">1</span></span>): fetch_sync(i) print(<span class="hljs-string"><span class="hljs-string">"Process took: {:.2f} seconds"</span></span>.format(time.time() - start)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> start = time.time() tasks = [asyncio.ensure_future( fetch_async(i)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, MAX_CLIENTS + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait(tasks) print(<span class="hljs-string"><span class="hljs-string">"Process took: {:.2f} seconds"</span></span>.format(time.time() - start)) print(<span class="hljs-string"><span class="hljs-string">'Synchronous:'</span></span>) synchronous() print(<span class="hljs-string"><span class="hljs-string">'Asynchronous:'</span></span>) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 1d-async-fetch-from-server-asyncio-await.py Synchronous: Fetch sync process 1 started Process 1: Wed, 17 Feb 2016 13:10:11 GMT, took: 0.54 seconds Fetch sync process 2 started Process 2: Wed, 17 Feb 2016 13:10:11 GMT, took: 0.50 seconds Fetch sync process 3 started Process 3: Wed, 17 Feb 2016 13:10:12 GMT, took: 0.48 seconds Process took: 1.54 seconds Asynchronous: Fetch async process 1 started Fetch async process 2 started Fetch async process 3 started Process 3: Wed, 17 Feb 2016 13:10:12 GMT, took: 0.50 seconds Process 2: Wed, 17 Feb 2016 13:10:12 GMT, took: 0.52 seconds Process 1: Wed, 17 Feb 2016 13:10:12 GMT, took: 0.54 seconds Process took: 0.54 seconds</code> </pre> <br>  Here you should pay attention to a couple of points. <br><br>  First, the difference in time - when using asynchronous calls, we run requests at the same time.  As mentioned earlier, each of them passed control to the next and returned the result on completion.  That is, the execution speed directly depends on the running time of the slowest query, which took just 0.54 seconds.  Cool, right? <br><br>  Secondly, how much code is similar to synchronous.  This is essentially the same thing!  The main differences are associated with the implementation of the library to execute queries, creating and waiting for completion of tasks. <br><br><h2>  Creating competitiveness </h2><br>  So far, we have used the only method to create and retrieve results from coruntine, create a set of tasks, and wait for them to complete.  However, quicksies can be scheduled to run and get results in several ways.  Imagine a situation where we need to process the results of GET requests as they are received;  in fact, the implementation is very similar to the previous one: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp URL = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/events'</span></span> MAX_CLIENTS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pid)</span></span></span><span class="hljs-function">:</span></span> start = time.time() sleepy_time = random.randint(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Fetch async process {} started, sleeping for {} seconds'</span></span>.format( pid, sleepy_time)) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(sleepy_time) response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, URL) datetime = response.headers.get(<span class="hljs-string"><span class="hljs-string">'Date'</span></span>) response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Process {}: {}, took: {:.2f} seconds'</span></span>.format( pid, datetime, time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> start = time.time() futures = [fetch_async(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, MAX_CLIENTS + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(asyncio.as_completed(futures)): result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> future print(<span class="hljs-string"><span class="hljs-string">'{} {}'</span></span>.format(<span class="hljs-string"><span class="hljs-string">"&gt;&gt;"</span></span> * (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), result)) print(<span class="hljs-string"><span class="hljs-string">"Process took: {:.2f} seconds"</span></span>.format(time.time() - start)) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 2a-async-fetch-from-server-as-completed-asyncio-await.py Fetch async process 1 started, sleeping <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 4 seconds Fetch async process 3 started, sleeping <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 5 seconds Fetch async process 2 started, sleeping <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 3 seconds &gt;&gt; Process 2: Wed, 17 Feb 2016 13:55:19 GMT, took: 3.53 seconds &gt;&gt;&gt;&gt; Process 1: Wed, 17 Feb 2016 13:55:20 GMT, took: 4.49 seconds &gt;&gt;&gt;&gt;&gt;&gt; Process 3: Wed, 17 Feb 2016 13:55:21 GMT, took: 5.48 seconds Process took: 5.48 seconds</code> </pre> <br>  Look at the indents and timings - we run all the tasks at the same time, but they are processed in order of completion.  The code in this case is slightly different: we pack the korutiny, each of which is already prepared for execution, in the list.  The <b><a href="https://docs.python.org/dev/library/asyncio-task.html">as_completed</a></b> function returns an iterator that returns the results of quorutine as they are executed.  Cool, right ?!  By the way, both <b>as_completed</b> and <b>wait</b> are functions from the <b><a href="https://docs.python.org/dev/library/concurrent.futures.html">concurrent.futures</a></b> package. <br><br>  Another example is that if you want to know your IP address.  There are a lot of services for this, but you do not know which of them will be available at the time of the program.  Instead of sequentially polling each of the list, you can run all queries concurrently and select the first successful one. <br><br>  Well, for this, in our favorite <b><a href="https://docs.python.org/dev/library/asyncio-task.html">wait</a></b> function, there is a special parameter <b>return_when</b> .  Until now, we have ignored what the <b>wait</b> returns, because  only parallelized tasks.  But now we need to get the result from the coroutine, so we will use the set of done and pending futures. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FIRST_COMPLETED <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'query'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] done, pending = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait( futures, return_when=FIRST_COMPLETED) print(done.pop().result()) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 2c-fetch-first-ip-address-response-await.py Fetching IP from ip-api Fetching IP from ipify ip-api finished with result: 82.34.76.170, took: 0.09 seconds Unclosed client session client_session: &lt;aiohttp.client.ClientSession object at 0x10f95c6d8&gt; Task was destroyed but it is pending! task: &lt;Task pending coro=&lt;fetch_ip() running at 2c-fetch-first-ip-address-response.py:20&gt; wait_for=&lt;Future pending cb=[BaseSelectorEventLoop._sock_connect_done(10)(), Task._wakeup()]&gt;&gt;</code> </pre> <br>  What happened?  The first service responded successfully, but there is some warning in the logs! <br><br>  In fact, we started the execution of two tasks, but left the cycle after the first result, while the second quorum was still being executed.  Asyncio thought it was a bug and warned us.  Probably worth tidying up for themselves and obviously kill unnecessary tasks.  How?  Glad you asked. <br><br><h2>  Futur states </h2><br><ul><li>  pending </li><li>  execution (running) </li><li>  done </li><li>  canceled </li></ul><br>  Everything is so simple.  When the futur is in the done state, you can get the result of the execution.  In the pending and running states, such an operation will result in an <b>InvalidStateError</b> exception, and in the case of canelled it will be canceledError, and finally, if the exception occurred in the corortine itself, it will be generated again (as was done when the <b>exception was</b> called).  <a href="https://docs.python.org/dev/library/asyncio-task.html">But don't take my word for it</a> . <br><br>  You can find out the status of the futures using the <b>done</b> , <b>canceled</b> or <b>running</b> methods, but do not forget that in the case of <b>done,</b> the <b>result</b> call can return both the expected result and the exception that occurred during the work.  There is a <b>cancel</b> method for canceling the futures.  This is suitable for correcting our example. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FIRST_COMPLETED <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'query'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] done, pending = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait( futures, return_when=FIRST_COMPLETED) print(done.pop().result()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pending: future.cancel() ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 2c-fetch-first-ip-address-response-no-warning-await.py Fetching IP from ipify Fetching IP from ip-api ip-api finished with result: 82.34.76.170, took: 0.08 seconds</code> </pre> <br>  Simple and accurate conclusion - just what I love! <br><br>  If you need some additional logic for processing futures, then you can connect callbacks that will be called upon going to the done state.  This can be useful for tests when some results need to be redefined with some values ‚Äã‚Äãof their own. <br><br><h2>  Exception Handling </h2><br>  asyncio is all about writing a managed and readable competitive code, which is clearly visible when handling exceptions.  Let's go back to the example to demonstrate. <br>  Suppose we want to make sure that all requests for services by definition IP returned the same result.  However, one of them may be offline and not respond to us.  Just use try ... except as usual: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'query'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'borken'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://no-way-this-is-going-to-work.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} is unresponsive'</span></span>.format(service.name) json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] done, _ = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait(futures) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> done: print(future.result()) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 3a-fetch-ip-addresses-fail-await.py Fetching IP from ip-api Fetching IP from borken Fetching IP from ipify ip-api finished with result: 85.133.69.250, took: 0.75 seconds ipify finished with result: 85.133.69.250, took: 1.37 seconds borken is unresponsive</code> </pre> <br>  We can also handle the exception that occurred during the execution of the cortina: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> traceback Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'this-is-not-an-attr'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'borken'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://no-way-this-is-going-to-work.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} is unresponsive'</span></span>.format(service.name) json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] done, _ = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait(futures) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> done: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: print(future.result()) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Unexpected error: {}"</span></span>.format(traceback.format_exc())) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</code> </pre> <br><pre> <code class="bash hljs">$ python3 3b-fetch-ip-addresses-future-exceptions-await.py Fetching IP from ipify Fetching IP from borken Fetching IP from ip-api ipify finished with result: 85.133.69.250, took: 0.91 seconds borken is unresponsive Unexpected error: Traceback (most recent call last): File ‚Äú3b-fetch-ip-addresses-future-exceptions.py‚Äù, line 39, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> asynchronous <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(future.result()) File ‚Äú3b-fetch-ip-addresses-future-exceptions.py‚Äù, line 26, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fetch_ip ip = json_response[service.ip_attr] KeyError: <span class="hljs-string"><span class="hljs-string">'this-is-not-an-attr'</span></span></code> </pre> <br>  Just like launching a task without waiting for its completion is an error, so getting unknown exceptions leaves its traces in the output: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'this-is-not-an-attr'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'borken'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://no-way-this-is-going-to-work.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: print(<span class="hljs-string"><span class="hljs-string">'{} is unresponsive'</span></span>.format(service.name)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() print(<span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait(futures) <span class="hljs-comment"><span class="hljs-comment"># intentionally ignore results ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous()) ioloop.close()</span></span></code> </pre> <br><pre> <code class="bash hljs">$ python3 3c-fetch-ip-addresses-ignore-exceptions-await.py Fetching IP from ipify Fetching IP from borken Fetching IP from ip-api borken is unresponsive ipify finished with result: 85.133.69.250, took: 0.78 seconds Task exception was never retrieved future: &lt;Task finished coro=&lt;fetch_ip() <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>, defined at 3c-fetch-ip-addresses-ignore-exceptions.py:15&gt; exception=KeyError(<span class="hljs-string"><span class="hljs-string">'this-is-not-an-attr'</span></span>,)&gt; Traceback (most recent call last): File ‚Äú3c-fetch-ip-addresses-ignore-exceptions.py‚Äù, line 25, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fetch_ip ip = json_response[service.ip_attr] KeyError: <span class="hljs-string"><span class="hljs-string">'this-is-not-an-attr'</span></span></code> </pre> <br>  The output looks the same as in the previous example with the exception of the reproachful message from asyncio. <br><br><h2>  Timeouts </h2><br>  But what if the information about our IP is not so important?  This can be a good addition to some composite answer, in which this part will be optional.  In this case, we will not keep the user waiting.  Ideally, we would set a timeout for calculating the IP, after which, in any case, give the answer to the user, even without this information. <br><br>  Again <b>wait</b> has a suitable argument: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FIRST_COMPLETED Service = namedtuple(<span class="hljs-string"><span class="hljs-string">'Service'</span></span>, (<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip_attr'</span></span>)) SERVICES = ( Service(<span class="hljs-string"><span class="hljs-string">'ipify'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://api.ipify.org?format=json'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>), Service(<span class="hljs-string"><span class="hljs-string">'ip-api'</span></span>, <span class="hljs-string"><span class="hljs-string">'http://ip-api.com/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'query'</span></span>), ) DEFAULT_TIMEOUT = <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">:</span></span> start = time.time() print(<span class="hljs-string"><span class="hljs-string">'Fetching IP from {}'</span></span>.format(service.name)) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> aiohttp.request(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, service.url) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{} is unresponsive'</span></span>.format(service.name) json_response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() ip = json_response[service.ip_attr] response.close() print(<span class="hljs-string"><span class="hljs-string">'{} finished with result: {}, took: {:.2f} seconds'</span></span>.format( service.name, ip, time.time() - start)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asynchronous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeout)</span></span></span><span class="hljs-function">:</span></span> response = { <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Result from asynchronous."</span></span>, <span class="hljs-string"><span class="hljs-string">"ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"not available"</span></span> } futures = [fetch_ip(service) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SERVICES] done, pending = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait( futures, timeout=timeout, return_when=FIRST_COMPLETED) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pending: future.cancel() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> future <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> done: response[<span class="hljs-string"><span class="hljs-string">"ip"</span></span>] = future.result() print(response) parser = argparse.ArgumentParser() parser.add_argument( <span class="hljs-string"><span class="hljs-string">'-t'</span></span>, <span class="hljs-string"><span class="hljs-string">'--timeout'</span></span>, help=<span class="hljs-string"><span class="hljs-string">'Timeout to use, defaults to {}'</span></span>.format(DEFAULT_TIMEOUT), default=DEFAULT_TIMEOUT, type=float) args = parser.parse_args() print(<span class="hljs-string"><span class="hljs-string">"Using a {} timeout"</span></span>.format(args.timeout)) ioloop = asyncio.get_event_loop() ioloop.run_until_complete(asynchronous(args.timeout)) ioloop.close()</code> </pre> <br><br>  I also added the timeout argument to the script startup line to check what happens if the requests have time to be processed.  I also added random delays to prevent the script from ending too quickly, and it was time to figure out exactly how it works. <br><br><pre> <code class="bash hljs">$ python 4a-timeout-with-wait-kwarg-await.py Using a 0.01 timeout Fetching IP from ipify Fetching IP from ip-api {<span class="hljs-string"><span class="hljs-string">'message'</span></span>: <span class="hljs-string"><span class="hljs-string">'Result from asynchronous.'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>: <span class="hljs-string"><span class="hljs-string">'not available'</span></span>}</code> </pre> <br><pre> <code class="bash hljs">$ python 4a-timeout-with-wait-kwarg-await.py -t 5 Using a 5.0 timeout Fetching IP from ip-api Fetching IP from ipify ipify finished with result: 82.34.76.170, took: 1.24 seconds {<span class="hljs-string"><span class="hljs-string">'ip'</span></span>: <span class="hljs-string"><span class="hljs-string">'82.34.76.170'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>: <span class="hljs-string"><span class="hljs-string">'Result from asynchronous.'</span></span>}</code> </pre> <br><h2>  Conclusion </h2><br>  Asyncio has strengthened my already great love for python.  To be honest, I fell in love with coroutines, even when I met them in Tornado, but asyncio managed to take all the best from him and other libraries in the implementation of competitiveness.  And so much so that special efforts were made so that they could use the main I / O cycle.  So if you use <a href="http://tornadoweb.org/">Tornado</a> or <a href="https://www.twistedmatrix.com/">Twisted</a> , you can connect the code intended for asyncio! <br><br>  As I already mentioned, the main problem is that standard libraries do not yet support non-blocking behavior.  Many popular libraries also work so far only in a synchronous style, and those that use competition are still young and experimental.  <a href="http://asyncio.org/">However, their number is growing</a> . <br><br>  I hope in this tutorial I showed how pleasant it is to work with asyncio, and this technology will encourage you to switch to python 3 if you are stuck on python 2.7 for some reason.  One thing is for sure - the future of Python has completely changed. <br><br><div class="spoiler">  <b class="spoiler_title">From the translator:</b> <div class="spoiler_text">  The original article was published on February 20, 2016, during which time a lot has happened.  Python 3.6 was released, in which, in addition to optimizations, asyncio work was improved, the API was transferred to a stable state.  Libraries for working with Postgres, Redis, Elasticsearch, etc. were released in non-blocking mode.  Even the new framework is Sanic, which resembles Flask, but works asynchronously.  In the end, even the event loop was optimized and rewritten in Cython, which happened 2 times faster.  So I see no reason to ignore this technology! <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/337420/">https://habr.com/ru/post/337420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337402/index.html">New course "Design of high-loaded systems" in Technopolis</a></li>
<li><a href="../337410/index.html">Satoshi Bomb</a></li>
<li><a href="../337412/index.html">Do you need SMS marketing?</a></li>
<li><a href="../337416/index.html">The economics of tokens: why are ICOs so popular?</a></li>
<li><a href="../337418/index.html">Machine learning in RapidMiner</a></li>
<li><a href="../337424/index.html">VK by design</a></li>
<li><a href="../337426/index.html">We go to the Internet outside the Russian Federation: (MikroTik <-> Ubuntu) * GRE / IPsec</a></li>
<li><a href="../337428/index.html">"Siege affairs": How companies build a solid fortress to protect the clouds</a></li>
<li><a href="../337430/index.html">Multitasking Arduin: pain-free timers</a></li>
<li><a href="../337436/index.html">Bitcoin farm and android miner app</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>