<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How and why static analyzers deal with false positives</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my previous article, I wrote that I didn‚Äôt like the approach in which static code analyzers are evaluated using synthetic tests. The article cited ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How and why static analyzers deal with false positives</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/868/88f/ec7/86888fec755babf7003ce362008fddcd.png" alt="why static analyzers are struggling with false positives"></div><br>  In my previous article, I wrote that I didn‚Äôt like the approach in which static code analyzers are evaluated using synthetic tests.  The article cited an example, perceived by the analyzer as a special case for which a warning is not consciously issued.  To be honest, I did not expect such a surge of comments on the topic that the analyzer may very rarely, but did not issue an error warning due to the false-tripping mechanisms implemented in it.  The fight against false positives is such a large component of any static analyzer that somehow it is not even clear what is there to actually discuss.  This must be done and everything.  Such mechanisms exist not only in our analyzer, but also in other analyzers / compilers.  However, since this moment caused such a heated discussion, I think it is worth paying attention to it, therefore I wrote this explanatory article. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  It all started with the publication " <a href="https://habrahabr.ru/company/pvs-studio/blog/321242/">Why I do not like synthetic tests</a> ."  We can say that this article was written in reserve.  Sometimes in discussions I need to explain why I do not like certain synthetic tests.  It‚Äôs hard to write long answers each time, so I‚Äôve been planning to prepare an article for a long time, which I can link to.  And when I looked at the <a href="https://github.com/regehr/itc-benchmarks">itc-benchmarks</a> , I realized that it was a good time to write the text, while my impressions were fresh and you could choose a couple of tests that I can include in the article. <br><br>  I did not expect such rejection of this article by the community of programmers and comments at various sites and in the mail.  The reason for this, probably, is that I have been developing static analyzers for <a href="http://www.viva64.com/ru/b/0465/">10 years now</a> and some questions seem so obvious to me that I consider them too brief and categorical.  I will try to eliminate misunderstandings and tell how and why the fight against false positives is conducted. <br><br>  The text of the article can relate to any tool, PVS-Studio itself has nothing to do with it.  A similar article could be written by someone from the GCC, Coverity or Cppcheck developers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Hand work with false positives </h2><br>  Before proceeding to the main topic, I want to clarify the markup of false messages.  I got the impression that many people began to write negative comments without understanding what was being said.  I met comments in the spirit of: <br><br>  <i>You went the wrong way.</i>  <i>Instead of providing mechanisms for suppressing false positives, you try to fix them yourself as much as possible and are most likely mistaken.</i> <br><br>  I will give explanations to no longer return to the discussion of this topic.  PVS-Studio provides several mechanisms for eliminating false positives, which are inevitable in any case: <br><br><ul><li>  Suppress warnings on a specific line using comments. </li><li>  Mass suppression of warnings that occur because of the macro.  This is also done with special comments. </li><li>  Similarly for lines of code containing a specific sequence of characters. </li><li>  Complete shutdown of diagnostics irrelevant for this project using settings or special comments. </li><li>  Exclusion from the analysis of a part of the code using #ifndef PVS_STUDIO. </li><li>  Change the settings of some diagnostics using special comments.  They are described in the description of specific diagnostics (see <a href="http://www.viva64.com/ru/w/V719/">V719</a> : V719_COUNT_NAME as an example). </li></ul><br>  All of these features are described in detail in the ‚Äú <a href="http://www.viva64.com/ru/m/0017/">Suppressing False Warnings</a> ‚Äù documentation.  You can also turn off warnings or suppress warnings in macros by using configuration files (see pvsconfig). <br><br>  Separately, it is necessary to single out the <a href="http://www.viva64.com/ru/m/0032/">system of mass marking of warnings</a> using a special database.  This allows you to quickly integrate the analyzer into the process of developing large projects.  The ideology of this process is described in the article " <a href="http://www.viva64.com/ru/b/0364/">Practice of using the PVS-Studio analyzer</a> ". <br><br>  All this refers to an explicit indication that it is not considered an error.  However, this does not remove the task of minimizing warnings with the help of special exceptions.  The value of the analyzer is not that he swears at everything, but how much he knows the situations when he does not have to swear. <br><br><h2>  Theoretical background </h2><br>  Now a little theory.  Each diagnostic analyzer message is evaluated by two characteristics: <br><br><ul><li>  Criticality of the error (how fatal it is for the program). </li><li>  The reliability of the error (what is the probability that a real defect was found, and not just a code that the analyzer did not understand). </li></ul><br>  These two criteria for each diagnosis can be combined in any proportions.  Therefore, it is ideal to describe the types of diagnostics, placing them on a two-dimensional graph: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/f95/34c/8e9f9534c34dc9c7e726f128b2cabccc.png" alt="Figure 1. Diagnostics can be assessed by severity and reliability."></div><p></p><br>  <font color="#999999"><i>Figure 1. Diagnostics can be assessed by severity and reliability.</i></font> <br><br>  I will give a couple of explanatory examples.  Diagnostics <b>A</b> , which determines that there is no header from comments in the * .cpp file, will be located in the lower right corner.  A forgotten comment will not cause the program to crash, although it is an error in terms of the coding standard adopted by the team.  In this case, you can very accurately determine whether there is a comment or not.  Therefore, the accuracy of the error is high. <br><br>  Diagnostics <b>B</b> , which says that some of the class members are not initialized in the constructor, will be placed in the middle of the upper part.  The reliability of this error is not very high, since the analyzer could simply not understand how and where this member is initialized ( <a href="http://www.viva64.com/ru/b/0354/">this is difficult</a> ).  The programmer can perform initialization after the constructor has completed its work.  Thus, an uninitialized member in the constructor is not necessarily an error.  But this diagnosis is at the top of the graph, since if it is really a mistake, then it will critically affect the performance of the program.  Using an uninitialized variable is a serious defect. <br><br>  I hope the idea is clear.  However, I think the reader will agree that such a distribution of errors on a chart is difficult to understand.  Therefore, some analyzers simplify this graph to a table of nine or four cells: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/023/b0d/fb1/023b0dfb18eb34e99ff6e5bf62e378e1.png" alt="Figure 2. Simplified version of the classification.  4 cells are used."></div><p></p><br>  <font color="#999999"><i>Figure 2. Simplified version of the classification.</i></font>  <font color="#999999"><i>4 cells are used.</i></font> <br><br>  So, for example, the authors of the Goanna analyzer did until they were bought by Coverity, which Synopsys later bought.  They just classified the warnings issued by the analyzer, referring them to one of 9 cells: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/80b/326/11280b3260224b64937ff02700c30487.png" alt="Figure 3. Fragment from Goanna reference guide (Version 3.3).  Used 9 cells."></div><p></p><br>  <font color="#999999"><i>Figure 3. Fragment from Goanna reference guide (Version 3.3).</i></font>  <font color="#999999"><i>Used 9 cells.</i></font> <br><br>  However, this method is also unusual and inconvenient for use.  Programmers want warnings to be located on a one-dimensional chart: it doesn‚Äôt matter -&gt; important.  This is customary, especially since compiler warnings are built on the same principle, divided into different levels. <br><br>  To reduce the two-dimensional classification to one-dimensional is not easy.  This is how we arrived at the PVS-Studio analyzer.  We simply do not have the bottom of a two-dimensional graph: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/cc0/b2d/895cc0b2d2f860e6e4f31ca4062383a3.png" alt="Figure 4. We project high-level warnings onto the line. Errors begin to be classified by authenticity."></div><p></p><br>  <font color="#999999"><i>Figure 4. We project high-level warnings onto the line.</i></font>  <font color="#999999"><i>Errors begin to be classified by authenticity.</i></font> <br><br>  We identify only those errors that may lead to a program malfunction.  A forgotten comment at the beginning of the file can not lead to the fall of the program and is not interesting to us.  But we are looking for an uninitialized member of the class, as this is a critical error. <br><br>  Thus, we need to classify errors according to their level of reliability.  This level of confidence is nothing other than the distribution of analyzer messages into three groups (High, Medium, Low). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/e71/4c0/cdfe714c0dbdaf3c0710f1ead586063a.png" alt="Figure 5. Fragment of the PVS-Studio interface window. Enabled to view the general purpose diagnostics level High and Medium."></div><p></p><br>  <font color="#999999"><i>Figure 5. Fragment of the PVS-Studio interface window.</i></font>  <font color="#999999"><i>Enabled to view the general purpose diagnostics level High and Medium.</i></font> <br><br>  And the same warning can get at different levels, depending on how much the analyzer is sure that he found the error, and did not give a false positive. <br><br>  In this case, I repeat that all warnings are looking for errors that may be critical for the program.  Just sometimes the analyzer is sure more, and sometimes less, that I found an error. <br><br>  <b>Note.</b>  Of course, there is a certain relativity.  For example, in PVS-Studio there is a warning, the V553 which the analyzer issues when it encounters a function with a length of more than 2000 lines of code.  Such a function need not contain an error.  But in practice, the probability is extremely high that this function is a source of errors.  This feature cannot be tested by unit tests.  You can consider the presence of such a function in the code as a defect.  However, there are only a few such diagnostics and the main task of the analyzer is to search for exits beyond the array, unspecified behavior and other fatal errors (see <a href="http://www.viva64.com/ru/w/">table</a> ). <br><br><h2>  False alarms and confidence levels </h2><br>  PVS-Studio warnings reveal code points, about which it can be said that they, to a greater or lesser degree, lead to serious program malfunctions.  Therefore, the warning levels in PVS-Studio are not the criticality of errors, but their accuracy.  However, sometimes criticality can also be taken into account for leveling, but we will not go into such small details, since the overall picture is important to us. <br><br>  Briefly: <b>Levels - this is the reliability of the identified error</b> . <br><br>  The criticism that was expressed in the previous article was that, fighting false warnings, we could lose useful warnings.  In fact, warnings usually do not go anywhere, but only move according to confidence levels.  And those rare variants of errors for which readers were experiencing, as a rule, simply accumulate at the Low level, which we do not recommend for viewing.  Only completely meaningless warnings completely disappear, from viewing of which there will be no sense. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/7f6/d54/4d97f6d54ce564f97bc0cb1708f87bcc.png" alt="Figure 6. Leaving something in reserve is good. But at some point you need to be able to stop."></div><p></p><br>  <font color="#999999"><i>Figure 6. Leaving something in reserve is good.</i></font>  <font color="#999999"><i>But at some point you need to be able to stop.</i></font> <br><br>  Readers apparently alerted my words that useful messages could disappear.  I see no reason to deny it.  Such a probability exists, but it is so insignificant that you should not worry about it.  I will show with examples that there is no sense in taking these cases into account.  But let's start with the topic of posting messages at different levels. <br><br>  In some cases, it is immediately clear to what level of confidence a warning should be placed.  As an example, consider a simple <a href="http://www.viva64.com/ru/w/V518/">V518</a> diagnostic that identifies the following error pattern: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Most likely, incorrectly put a bracket.  They wanted to add 1 so that it was where to place the terminal zero.  But they were mistaken and, as a result, the memory is allocated 2 bytes less than it should. <br><br>  Theoretically, you can imagine that the programmer wanted to write just such code, but the probability of this is extremely small.  Therefore, the accuracy of this warning is very high, and it is always placed in messages of the High level. <br><br>  By the way, this diagnostic does not even have a single exception.  If you find such a pattern, it means an error. <br><br>  In other cases, it is immediately clear that the accuracy of the error is low and the message is always sent to the Low level.  We have very few such diagnostics, since this means that the diagnosis was unsuccessful.  One such stupid diagnostic is <a href="http://www.viva64.com/ru/w/V608/">V608</a> , which identifies repetitive sequences consisting of operators of explicit type conversions.  Look for expressions like: <br><br><pre> <code class="cpp hljs">y = (A)(B)(A)(B)x;</code> </pre> <br>  I do not remember why we did this diagnosis.  While I have never seen that this diagnosis revealed a real error.  She found redundant code (usually in complex macros), but not errors. <br><br>  The majority of diagnostics ‚Äúfloats‚Äù through the levels, depending on the confidence of the analyzer that a real bug has been found. <br><br>  We interpret the levels like this: <br><br>  <b>High (first level).</b>  Most likely, this is a mistake.  Be sure to read this code!  If this is not even an error, then most likely the code is poorly written and should be corrected anyway, so that it does not confuse the analyzers and other members of the development team.  Let me explain with an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) A = <span class="hljs-number"><span class="hljs-number">1</span></span>; B = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Perhaps there is no error and braces are not needed.  There is a tiny chance that the programmer always wanted to assign the variable <i>B the</i> value 2. However, I think everyone will agree that such code should be rewritten, even if there is no error: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) A = <span class="hljs-number"><span class="hljs-number">1</span></span>; B = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  <b>Medium (second level)</b> .  This code seems to contain an error, but the analyzer is not sure.  If you have corrected all the warnings of the High level, it will be useful to work with the warnings of the Medium level. <br><br>  <b>Low (third level)</b> .  Low confidence warnings that we generally do not recommend for study.  Please note that when we write articles about <a href="http://www.viva64.com/ru/inspections/">checking projects</a> , we consider only the High and Medium levels and do not associate with the Low level. <br><br>  We did the same when we <a href="http://www.viva64.com/ru/b/0330/">worked</a> on the Unreal Engine project.  Our goal was to destroy all the warnings of the first and second levels of general purpose.  We did not look at the third level. <br><br>  As I said, most diagnostics can be assigned a different level, depending on the set of symptoms.  Some signs may reduce, while others increase the reliability.  They are selected empirically based on the diagnostics run on more than a hundred open source projects. <br><br>  Consider how diagnostics can move through different levels.  For example, take the <a href="http://www.viva64.com/ru/w/V572/">V572</a> diagnostic, which warns about a suspicious explicit type conversion.  Using the <i>new</i> operator, a class object is created, a pointer to which is then cast to another type: <br><br><pre> <code class="cpp hljs">T *p = (T *)(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A);</code> </pre> <br>  This is a strange construction.  If class <i>A is</i> inherited from <i>T</i> , then the type conversion is superfluous and you can simply remove it.  If not inherited, then this is most likely an error.  However, the analyzer is not completely sure that this is a mistake, and to begin with, it assigns the Medium confidence level.  No matter how strange this construction may be, it sometimes corresponds to a correctly working code.  I can‚Äôt give an example, because I don‚Äôt remember what those situations are. <br><br>  If an array of elements is created, and then it is given to a pointer to the base class, this is much more dangerous: <br><br><pre> <code class="cpp hljs">Base *p = (Base *)(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived[<span class="hljs-number"><span class="hljs-number">10</span></span>]);</code> </pre> <br>  Here the analyzer will issue a high warning.  The size of the base class may be less than the heir, and then, when accessing the <i>p</i> element <i>[1],</i> we ‚Äúdo not understand where‚Äù and will work with incorrect data.  Even if as long as the size of the base class and the successor are the same, this code should be corrected anyway.  While the programmer can carry, but it is very easy to break everything by adding a new member of the class to the heir class. <br><br>  There is also a reverse situation when the casting to the same type occurs: <br><br><pre> <code class="cpp hljs">T *p = (T *)(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T);</code> </pre> <br>  Such code can appear when someone has been working with C for too long and has forgotten that, unlike calling the <i>malloc</i> function, a mandatory type cast is not necessary.  Or as a result of refactoring the old code, in which the C program turns into a C ++ program. <br><br>  There is no error here and the message can not be issued at all.  Just in case, it remains, but moves to the Low level.  Watch this message and edit the code is not necessary, but if someone wants to bring beauty in the code, then we do not mind. <br><br>  In the comments to the previous article, people were worried that warnings could accidentally disappear, which, although with a low probability, could indicate an error.  As a rule, such messages do not disappear, but move to the Low level.  We have just considered one such example: ‚ÄúT * p = (T *) (new T);‚Äù.  There is no error here, but suddenly something is wrong ... Those who wish can learn the code. <br><br>  Let's look at another example.  Diagnostics <a href="http://www.viva64.com/ru/w/V531/">V531</a> : suspiciously multiply one <i>sizeof</i> by another <i>sizeof</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>);</code> </pre> <br>  This is a meaningless expression and, most likely, there is some kind of mistake, for example, a typo.  The analyzer will issue a High warning on this code. <br><br>  However, there is a situation where the warning level is replaced with Low.  This happens when <i>sizeof (char) is</i> one of the factors. <br><br>  All the ‚Äúsizeof (T) * sizeof (char)‚Äù expressions that we observed on more than a hundred projects were not errors.  Almost always, these were some macros where such multiplication was obtained due to the substitution of one macro into another. <br><br>  You can not look at these warnings, so they are hidden from the eyes of users in the section Low-warnings.  However, those who wish can still study them. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/b51/e5b/c85b51e5b79672fee930640f7409c57d.png" alt="Figure 7. Now the reader knows that he can always sail on the endless expanses of Low level warnings."></div><p></p><br>  <font color="#999999"><i>Figure 7. Now the reader knows that he can always sail on the endless expanses of Low level warnings.</i></font> <br><br><h2>  Exceptions in diagnostics </h2><br>  Exceptions can be made both for individual diagnostics and for diagnostic groups.  Let's start with "mass destruction exceptions."  Programs have code that is never executed.  In fact, it is possible not to look for errors at all.  Once the code is not executed, the error does not manifest itself.  Therefore, many diagnostics do not apply to non-executable code.  Let me explain this with an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) { *p = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  When dereferencing a pointer, its only possible value is NULL.  There is no other value here that could be stored in the 'p' variable.  However, the exception is triggered that dereferencing is in code that is never executed.  And if it is not executed, then there is no error.  Dereferencing will be performed only when a value other than <i>NULL is</i> placed in the variable <i>p</i> . <br><br>  Someone might say that a warning might be useful, as it will tell you that the condition is always false.  But this is a concern of other diagnostics, for example, V547. <br><br>  Would it be useful to someone if the analyzer starts warning that in the above code the null pointer is dereferenced?  Not. <br><br>  We now turn to the special exceptions in diagnostics.  Let's return to the V572 diagnostics we have already reviewed: <br><br><pre> <code class="cpp hljs">T *p = (T *)(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A);</code> </pre> <br>  There are exceptions when this message will not be issued.  One such case is the cast to <i>(void)</i> .  Example: <br><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A();</code> </pre> <br>  The object is created and consciously left to live until the end of the program.  This design could not appear by chance due to a typo.  This is a conscious action to suppress warnings of compilers and analyzers on a record of the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A();</code> </pre> <br>  Many tools will swear at this design.  The compiler / analyzer suspects that the person forgot to write a pointer that the new operator returns.  Therefore, the person <b>consciously</b> used the suppression of warnings, adding a cast to the <i>void</i> type. <br><br>  Yes, this code is strange.  But once a person asks to leave this code alone, this is the way to do it.  The task of the analyzer is to look for errors, rather than forcing a person to write even more sophisticated constructions to confuse the compiler / analyzer and get rid of warnings. <br><br>  Would it be useful for someone to issue a warning anyway?  Not.  The one who wrote this code, thanks will not tell. <br><br>  Now, back to the V531 diagnostic: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(A) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(B)</code> </pre> <br>  Are there any cases when you should not issue any messages at all, even at Low level?  Yes there is. <br><br>  Typical task: it is necessary to calculate the size of the buffer, the size of which is a multiple of the size of another buffer.  Let's say there is an array of 125 elements of type <i>int</i> , and we need to create an array of 125 elements of type <i>double</i> .  To do this, the number of elements in the array must be multiplied by the size of the object.  That's just when counting the number of elements is easy to make a mistake.  Therefore, programmers use special macros to safely calculate the number of elements.  For more details, why and how to do this, I repeatedly wrote in my various articles (see <a href="http://www.viva64.com/ru/a/0074/">the</a> mention of the <i>arraysize</i> macro <i>here</i> ). <br><br>  After the macro is opened, the following constructs are obtained: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (*RtlpNumberOf( __unaligned T (&amp;)[N] ))[N]; .... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*RtlpNumberOf(liA-&gt;Text)) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>);</code> </pre> <br>  The first <i>sizeof is</i> used to calculate the number of items.  The second <i>sizeof</i> calculates the size of the object.  As a result, everything is fine, and we correctly calculate the size of the array in bytes.  Perhaps the reader does not understand what is actually being discussed.  I apologize, but I do not want to deviate from the essence of the story and go into clarification. <br><br>  In general, there is some magic when multiplying two <i>sizeof</i> operators is perfectly normal and expected.  The analyzer is able to recognize such a buffer size calculation pattern and does not issue a warning. <br><br>  Would it be useful for someone to issue a warning anyway?  Not.  This is perfectly correct and well-written code.  So it is necessary to write. <br><br>  Go ahead.  The analyzer will issue a warning <a href="http://www.viva64.com/ru/w/V559/">V559</a> on the construction of the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br>  To suppress a warning on similar code, the expression must be placed in double brackets: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a = <span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre> <br>  This is a hint to the analyzers and the compiler that there is no error, and the person consciously wants to assign a value inside the condition.  I do not know who and when came up with this method of hints, but it is generally accepted and supported by many compilers and analyzers. <br><br>  Naturally, the PVS-Studio analyzer will also keep silent about such code. <br><br>  Perhaps, it was worthwhile to move the warning to the Low level, and not completely suppress it?  Not. <br><br>  Is it possible that a person accidentally puts extra parentheses around the wrong expression?  Yes, there is, but extremely small.  Do you often put extra brackets?  I do not think.  Rather, it happens 1 time for 1000 <i>if statements</i> .  Or even less.  Accordingly, the probability that due to the extra brackets an error is missed, less than 1/1000. <br><br>  Perhaps it is better to issue a warning anyway?  Not.  Thus, we deprive a person of the ‚Äúlegal possibility‚Äù to avoid a warning on his code, but at the same time the probability of finding an additional error is extremely small. <br><br>  I have already given similar arguments in the comments to the previous article, but they did not convince everyone.  Therefore, I will try to approach this topic from another side. <br><br>  I have a question for those who claim to want to see all warnings.  Have you covered unit tests with 100% of the code?  Not?  How so, because there may be mistakes? <br><br>  I will answer for my opponent.  Covering 100% of the code with tests is extremely difficult and expensive.  The price that will be paid for 100% coverage will not pay for the investment of time and effort. <br><br>  That's the same with static analysis.  There is a line at the intersection of which the time for analyzing warnings of the analyzer will exceed any reasonable limits.  Therefore, there is no practical sense to issue as many warnings as possible. <br><br>  Let's consider another case where the V559 warning is not issued: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>))</code> </pre> <br>  This is a classic pattern of memory allocation and simultaneous verification that memory has been allocated.  It is clear that there is no error here.  The man clearly did not want to write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>))</code> </pre> <br>  Such an expression has no practical meaning and, in addition, leads to a memory leak.  So assignment inside a condition is exactly what the programmer wanted to do. <br><br>  Would it be good if the analyzer would issue warnings for such constructions?  Not. <br><br>  Let's finish the chapter with one more example of the exception, which will be harder for me to justify, but I will try to convey to the reader our philosophy. <br><br>  Diagnostics <a href="http://www.viva64.com/ru/w/V501/">V501</a> - one of the leaders in the number of exceptions.  However, these exceptions do not interfere with the diagnosis to work efficiently ( <a href="http://www.viva64.com/ru/examples/v501/">proof</a> ). <br><br>  Diagnostics gives out warnings for expressions like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X = Q - Q;</code> </pre> <br>  If the left and right operands are identical, then this is suspicious. <br><br>  One of the exceptions is that you should not issue a warning if the operation '/' or '-' applies to numeric constants.  Examples: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> w = <span class="hljs-number"><span class="hljs-number">1.</span></span>/<span class="hljs-number"><span class="hljs-number">1.</span></span>; R[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span> - <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  The fact is that programmers often specifically write such expressions without simplifying them.  This makes it easier to understand the meaning of the program.  Most often, such situations are found in applications that perform many calculations. <br><br>  An example of real code with similar expressions: <br><br><pre> <code class="cpp hljs">h261e_Clip(mRCqa, <span class="hljs-number"><span class="hljs-number">1.</span></span>/<span class="hljs-number"><span class="hljs-number">31.</span></span> , <span class="hljs-number"><span class="hljs-number">1.</span></span>/<span class="hljs-number"><span class="hljs-number">1.</span></span>);</code> </pre> <br>  Can we miss any mistake due to such an exception?  Yes we can.  However, the benefits of reducing the number of false positives greatly exceed the potential benefits of losing useful warnings. <br><br>  Such a division or subtraction is a standard common practice in programming.  The risk of losing a trigger is justified. <br><br>  Perhaps they wanted to write another expression there?  Yes, it is not excluded.  However, such reasoning is the path to nowhere.  The phrase "suddenly wanted to write something else," can be applied to 1./31.  And here we come to the idea of ‚Äã‚Äãan ideal analyzer, which simply swears at all the lines in the program.  Even on the empty.  Suddenly it is wrong that it is empty.  Suddenly there it was necessary to call the function <i>foo ()</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/034/f50/370034f50c1270e7c0b23de6f9887ad5.png" alt="Figure 8. You need to be able to stop. Otherwise, a useful walk on diagnostics will turn into some kind of garbage."></div><p></p><br>  <font color="#999999"><i>Figure 8. You need to be able to stop.</i></font>  <font color="#999999"><i>Otherwise, a useful walk on diagnostics will turn into some kind of garbage.</i></font> <br><br>  It is better to lose 1 useful message than to show another 1,000 useless for the company.  There is nothing terrible about it.  The completeness of error detection is not the only criterion of the utility of the analyzer.  Equally important is the balance between useful and useless messages.  Attentiveness is quickly lost.  Looking through a report with a large number of false positives, a person begins to be very inattentive to warnings and misses many errors, marking them out as not errors. <br><br><h2>  Once again briefly about exceptions </h2><br>  It seems to me that I explained everything in detail, but I foresee that I can once again hear a comment of this type: <br><br>  <i>I don‚Äôt understand why you should complain about misunderstanding instead of just making a function and the on / off button for it.</i>  <i>You want - you use, you do not want, it is not necessary - do not use.</i>  <i>Yes, this is work.</i>  <i>But yes, this is your job.</i> <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e0/fd8/079/1e0fd80790237755a33f2aa2c62e1514.png" alt="Figure 9. The unicorn reaction to a wish to make a setting that disables all warning filtering."></div><p></p><br>  <font color="#999999"><i>Figure 9. The unicorn reaction to a wish to make a setting that disables all warning filtering.</i></font> <br><br>  It is proposed to make a button that will show all warnings without restrictions with exceptions turned off. <br><br>  <b>There is such a button already in the analyzer!</b>  <b>There is!</b>  <b>It is called ‚ÄúLow‚Äù and displays warnings with a minimum level of confidence.</b> <br><br>  Apparently, many simply misunderstand the term "exceptions."  In the form of exceptions, a number of absolutely necessary conditions for adequate diagnostics of problems are drawn up. <br><br>  Let me explain this, based on the diagnosis of <a href="http://www.viva64.com/ru/w/V519/">V519</a> .  She warns that the same object is assigned values ‚Äã‚Äãtwice in a row.  Example: <br><br><pre> <code class="cpp hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  But only in this form, the diagnosis is not applicable.  Therefore, refinements begin, such as: <br><br>  Exception N1.  The object participates in the second expression as part of the right operand of the operation =. <br><br>  If this exception is removed, the analyzer will start swearing at a completely normal code: <br><br><pre> <code class="cpp hljs">x = A(); x = x + B();</code> </pre> <br>  Does anyone want to devote their time and energy to view this type of code?  Not.  And convince us of the opposite will not work. <br><br><h2>  the main idea </h2><br>  I don‚Äôt have a goal in this article to prove or justify anything to anyone.  Its purpose is to direct the thoughts of readers in the right direction.  I try to explain that trying to get as many warnings from analyzers as possible is counterproductive.  This does not help to make the developed project more reliable, but it takes time that could be spent on alternative methods of improving the quality of the program. <br><br>  Static code analyzer is not able to detect all errors.  And any other tool is also not capable.  There is no silver bullet.  The quality and reliability of the software is achieved by a reasonable combination of various tools, and not by trying to squeeze everything possible and impossible from any one tool. <br><br>  I will give an analogy.  They try to achieve safety at a construction site using a combination of various elements: training in safety measures, wearing a helmet, prohibition to start work while intoxicated, and so on.  It is inefficient to choose only one component and hope that it will solve all the problems.  You can make a wonderful armored helmet, and better a helmet, with a built-in Geiger counter and water supply for the day.  But all this will not save from falling when performing high-altitude work.  Here you need another device - a safety cable.  You can start to think in the direction of the parachute built into the helmet.  This, of course, is an interesting engineering problem, but such an approach is impractical.  Very soon, the weight and size of the helmet will exceed reasonable limits.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The helmet will begin to interfere with the builders, anger them, slow down the pace of work. It is likely that builders will begin to secretly remove the helmet and work without it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the user has won all the warnings of the analyzer, it is unreasonable to seek to see as many warnings as possible at an ever lower level of confidence. It will be more useful to do unit tests and bring the code coverage, say up to 80%. I do not call for striving for 100% coverage, since the time it takes to implement 100% coverage and maintain it will outweigh the benefits of this action. Then you can add one of the dynamic code analyzers to the testing process. Some types of defects found by dynamic analyzers cannot find static analyzers.</font></font> And vice versa.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, dynamic and static analysis perfectly complement each other. You can develop UI tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such an integrated approach will have a much better effect on the quality and reliability of programs. Using several technologies, it is possible to achieve better quality than, say, 100% covering all code with tests. At the same time, 100% code coverage will be spent much more. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, I think that everyone who writes that he wants more unfiltered messages from static code analyzers have never used these code analyzers. Or tried them on toy projects in which </font></font><a href="http://www.viva64.com/ru/b/0158/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">low density of errors</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In any real project there is always a problem, how to deal with the existing false positives. </font><font style="vertical-align: inherit;">This is a big complex task, on which both the developers of the analyzers and their users have to work. </font><font style="vertical-align: inherit;">Where even more warnings ?! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We regularly receive letters from customers asking them to eliminate this or that false positive. </font><font style="vertical-align: inherit;">But "give more messages" we have never heard.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From this article we learned: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The PVS-Studio analyzer tries to look for not ‚Äúsmells‚Äù, but real errors that can lead to program malfunction. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diagnostic messages are divided into three confidence levels (High, Medium, Low). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We recommend to study only the levels of High and Medium. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those who are worried that exceptions can remove a useful error: this is unlikely. </font><font style="vertical-align: inherit;">Most likely, such an unreliable warning has been moved to the Low level. </font><font style="vertical-align: inherit;">You can open the Low tab and examine such warnings.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exceptions in diagnostics are inevitable, otherwise the tool will begin to interfere more than help. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to everyone who took the time to read this great article. </font><font style="vertical-align: inherit;">I myself did not expect it to turn out so long. </font><font style="vertical-align: inherit;">This shows that the topic is more complicated than it seems at first glance.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a6/de9/1ac/1a6de91ac035782135b83d73e6251ab3.png" alt="Picture 11"></div><p></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The unicorn will continue to guard the quality of the program code. </font><font style="vertical-align: inherit;">I wish everyone good luck and invite you to additionally get acquainted with the presentation of " </font></font><a href="http://www.slideshare.net/Andrey_Karpov/pvsstudio-windowslinux-ccc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ".</font></font><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0488/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov. <a href="http://www.viva64.com/en/b/0488/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The way static analyzers fight against false positives</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read the article and have a question?</font></font></b> <div class="spoiler_text">          .      : <a href="http://www.viva64.com/ru/a/0085/">      PVS-Studio,  2015</a> . ,   . </div></div></div><p>Source: <a href="https://habr.com/ru/post/324372/">https://habr.com/ru/post/324372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324362/index.html">IBM offers a new way to superdense information: 1 bit to 1 atom</a></li>
<li><a href="../324364/index.html">The best reports of HolyJS 2016 Moscow: Access open</a></li>
<li><a href="../324366/index.html">Tracking js errors with Metrics</a></li>
<li><a href="../324368/index.html">How to choose NGFW or what manufacturers keep back?</a></li>
<li><a href="../324370/index.html">Set method</a></li>
<li><a href="../324374/index.html">CEPH for pumping</a></li>
<li><a href="../324376/index.html">Exceptions in Windows x64. How it works. Part 3</a></li>
<li><a href="../324378/index.html">We bring business to the international market in 5 minutes</a></li>
<li><a href="../324380/index.html">Hard Prioritization</a></li>
<li><a href="../324382/index.html">Fine Rust state machines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>