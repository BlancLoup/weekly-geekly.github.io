<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with radio modules SI4432</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes the functional features of the radio module on the ISM chip (industrial, scientific and medical radio bands) of the SI4432 trans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with radio modules SI4432</h1><div class="post__text post__text-html js-mediator-article">  The article describes the functional features of the radio module on the ISM chip (industrial, scientific and medical radio bands) of the SI4432 transceiver.  It also provides the simplest examples of software initialization of the module and describes some possible configuration variations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/33d/b97/c58/33db97c58b8a4681ac8f43c802c23289.jpg"></div><br><a name="habracut"></a><br><h3>  Description of the chip SI4432 </h3><br>  Receiver sensitivity -121 <a href="https://en.wikipedia.org/wiki/DBm">dBm</a> .  Transmitter power up to +20 dBm (software tuning is possible in 3 dBm increments).  There is a built-in function of <a href="http://celnet.ru/diversity.php">separated reception (Antenna Diversity)</a> .  The microcircuit is capable of operating at frequencies from 240 to 960 MHz in increments of 156 (240-480 MHz) or 312 Hz (480-960 MHz).  Also, the chip has such features as: automatic wake-up timer, low battery charge detector, 64-byte receive / transmit buffer, automatic packet handler, temperature sensor, 8-bit ADC, reference voltage source, three GPIO outputs, various types of signal modulation (OOK, FSK, GFSK) and others. <br><br>  The microcircuit runs from 1.8 to 3.6 V of the supply voltage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Features of the radio module </h3><br>  There are no voltage regulators on the module, so you need the appropriate power supply and the appropriate level at the logic inputs.  On the module, one more small six-lead chip with G4C marking is visible.  This is the uPG2179TB chip, which performs the function of switching the antenna between the TX and RX terminals, thus ensuring that the module can operate in both receive mode and transmit mode.  The switch chip is controlled by the SI4432 itself through the ports GPIO0 and GPIO1, which, when initialized, must be programmed accordingly, to change / set the receive / transmit mode.  At the same time, this circuit configuration does not allow using the diversity reception function, and the operation of the GPIO0 and GPIO1 pins should be assigned only to control the uPG2179TB switch. <br><br>  The values ‚Äã‚Äãof the capacitors and inductances installed in the piping of the antenna inputs of the SI4432 should be selected based on the operating frequency range, antenna characteristics and supply voltage range.  What particular values ‚Äã‚Äãhave these elements is unknown. <br><br>  The scheme of the module, namely the one shown in the figure I did not find, but according to the information from the datasheet, you can install the pinout of the module: <br><br><img src="https://habrastorage.org/files/f3a/9bf/021/f3a9bf0216b34cd39fceb0d0495b0542.jpg" alt="image"><br><br>  <b>NSEL, SCLK, SDI, SDO</b> - SPI interface (working with SI4432 comes down to writing and reading SI4432 registers via SPI interface); <br><br>  <b>NIRQ</b> - output interrupts (if a receive / transmit event occurs, etc., then the level at this output drops to 0, which events will lead to interrupts depending on the values ‚Äã‚Äãof the bits in the corresponding registers); <br><br>  <b>SDN</b> - output control mode of the SI4432, if you set a high level to SDN, then the SI4432 switches to Shutdown mode, in which the chip goes to power saving mode with a current consumption of 15 nA, while all the contents of the registers return to their original state and SPI data transmission is impossible ; <br><br>  <b>VDD</b> - module power supply from 1.8 to 3.6 V; <br><br>  <b>GND</b> - the "land"; <br><br>  <b>GPIO0, GPIO1, GPIO2</b> - programmable input / output ports (if you do not rewire the module, then only GPIO2 can be programmed for your goals, since GPIO0 GPIO1 is already occupied to switch the transmit / receive mode). <br><br><h3>  Module setup </h3><br>  All register settings described below are taken from the <a href="http%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FTechnicalDocs%252FAN415.pdf%26usg%3DAFQjCNHsdot0TwHOKowi01kIuXUDwUMQWg%26sig2%3DBTbNiZKIAn4_7Zp18PUCJQ%26bvm%3Dbv.128617741,bs.2,d.bGg">AN415 Programming guide</a> .  This file covers the use of the SI4432 as a transmitter, receiver, transceiver, and also deals with the transmission of packets with a length of more than 64 KB. <br><br>  SI4432 chips come in different revisions: A, V, B. It is determined by the first letter in the cipher, in my case BPS10P, which means revision B. For different revisions there are some features in the initialization. <br><br><h4>  Connection to the controller </h4><br>  The module connection is made in accordance with the pinout above.  For simple reception or transmission of data, GPIO pins can be turned off at the inputs of the microcontroller and leave them hanging in the air.  The SPI pins are connected to the corresponding pins of the microcontroller, the NIRQ can be hung on any free pins of the microcontroller (probably better at such a pin where you can get an external interrupt on the front).  SDN can be brought to the "ground" or to the output of the MK, but do not forget to set it to 0. <br><br><h4>  SPI Read and Write </h4><br>  Manufacturer SI4432 offers to use the following functions for reading and writing registers for SPI. <br><br>  Record: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpiWriteRegister</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U8 reg, U8 value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     //    NSEL  0 NSS = 0; //     SPI  //           ( 127 ) SPI1DAT = (reg|0x80); //   while( SPIF1 == 0); SPIF1 = 0; //    SI4432   SPI  SPI1DAT = value; //   while( SPIF1 == 0); SPIF1 = 0; //  NSS = 1; }</span></span></code> </pre> <br>  Reading: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">U8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpiReadRegister</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U8 reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    NSEL  0 NSS = 0; //     SPI  (   - 0) SPI1DAT = reg; //   while( SPIF1 == 0); SPIF1 = 0; //     SPI  //         SI4432 SPI1DAT = 0xFF; //   while( SPIF1 == 0); SPIF1 = 0; //  NSS = 1; //         SI4432 return SPI1DAT; }</span></span></code> </pre> <br><h4>  Initialization.  Beginning of work </h4><br>  It is recommended to make the following manipulations. <br><br>  1) Set the SDN pin to 0. <br>  2) Wait 15 ms before sending commands via SPI. <br>  3) Read the status of the interrupt registers. <br>  4) Perform a soft reset. <br><br><pre> <code class="cpp hljs">SDN = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// SDN  0 delay_ms(15); //  ItStatus1 = SpiReadRegister(0x03); ItStatus2 = SpiReadRegister(0x04); //   SpiWriteRegister(0x07, 0x80); // 0x80   Operating &amp; Function Control1 //   while ( NIRQ == 1); //  ItStatus1 = SpiReadRegister(0x03); //read the Interrupt Status1 register ItStatus2 = SpiReadRegister(0x04); //read the Interrupt Status2 register</span></span></code> </pre> <br>  Reading statuses clears the interrupt flags and resets the NIRQ output to 1 (when an interrupt occurs, the NIRQ is reset to 0 and remains in this state until the corresponding status register is read). <br><br><h4>  Setting the frequency parameters </h4><br>  Since the microcircuit supports operation in a rather wide frequency range, configuring the registers responsible for the frequency is rather difficult.  The manufacturer suggests using a calculator ( <a href="https%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FSoftware%252FSi443x%252520Register%252520Settings_RevA0-v4.xls%26usg%3DAFQjCNHPChYO7ogigz6oWBTynFm-kCmuBg%26sig2%3D3NpeO5b81W4w4EnhmcJs2A%26bvm%3Dbv.128153897,d.bGg">EZRadioPRO Register Calculator</a> ) to calculate the values ‚Äã‚Äãof frequency registers.  The calculator is a Microsoft Excell file: <br><br><img src="https://habrastorage.org/files/362/445/ecc/362445ecc9fe421ebb0ca311893fcb50.PNG"><br><br>  This file already has the appropriate default values.  Values ‚Äã‚Äãcan only be changed in gray cells.  It is advisable to change the value of the cells responsible for the transmission rate (J9) and the carrier frequency (B17) in this file.  Usually, the slower the transmission rate, the lower the probability of an error occurring during data transfer.  You can select the type of signal modulation: FSK, GFSK, OOK. <br><br>  OOK modulation encodes the data by turning the signal amplifier on or off.  When there is no data to transmit, the amplifier is disabled, when transmitting a logical 0, the amplifier is turned off for the duration of one bit, while transmitting a logical 1, the amplifier is turned on for the duration of one bit. <br><br>  FSK is based on changing the frequency of a signal for transmitting digital data.  For transmission of logical 0, the frequency of the carrier signal is reduced by the frequency of the deviation, and for logical 1, it increases.  The difference between GFSK and FSK is that GFSK applies a Gaussian filter to the data bits. <br><br>  The manufacturer recommends using the GFSK type, since this type of modulation provides the best performance and a cleaner signal spectrum compared to other types of modulations available, as can be seen from the figure (comparing FSK and GFSK): <br><br><img src="https://habrastorage.org/files/683/4b5/11a/6834b511a38c499289ee91a6b82df908.PNG"><br><br>  Configuring the registers responsible for the frequency: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   915  SpiWriteRegister(0x75, 0x75); SpiWriteRegister(0x76, 0xBB); SpiWriteRegister(0x77, 0x80); //   (9.6 kbps) SpiWriteRegister(0x6E, 0x4E); SpiWriteRegister(0x6F, 0xA5); SpiWriteRegister(0x70, 0x2C); //   (+-45 ) (   GFSK ) SpiWriteRegister(0x72, 0x48);</span></span></code> </pre> <br><h4>  Sending a data packet using a packet handler </h4><br>  The packet handler is used in receive mode and in transmit mode.  You can transfer data without a packet handler, in which case you need to describe the structure of the packet in the registers yourself.  Usually the structure of the package is as follows: <br><br><img src="https://habrastorage.org/files/b01/e52/a02/b01e52a027ec482ebf91e7fb5defc9fb.PNG"><br><br>  Preamble - sequence 0101 ... used to synchronize the receiver and transmitter.  The SI4432 has an integrated preamble detector.  When setting the SI4432 in registers, the value of the preamble length and the threshold value of the preamble detection are set.  If the length of the preamble or the detection threshold of the preamble is less than a certain value, then the probability of loss of data packets will increase.  The preamble detector searches for the preamble according to the detection threshold.  If the corresponding preamble is found, then the synchronization word detection mechanism (Sync Word) is launched. <br><br>  A transmitted packet always starts with a preamble (010101 ... bit pattern), which allows the receiver to prepare to receive transmitted data.  The preamble dina, as well as the threshold, depend on the radio settings: modulation type, automatic frequency control (AFC).  The SI4432 has a built-in preamble detector that automatically compares the bits received from the ether with the preamble bit pattern, if the preamble detector detects a predetermined length of the preamble bit sequence in the received signal, then SI4432 reports the reception of a valid preamble in the status register or the output of the GPIO if the corresponding GPIO setting. <br><br>  Preamble detection threshold - programmable value.  Depending on the modulation type (FSK, GFSK, OOK), enabling automatic frequency tuning (AFC) and diversity reception (antenna diversity), the manufacturer recommends choosing the preamble length and preamble detection threshold in accordance with the table: <br><br><img src="https://habrastorage.org/files/328/78d/b8b/32878db8bb5c47f7b0c63aea7063ffef.PNG"><br><br><div class="spoiler">  <b class="spoiler_title">About AFC</b> <div class="spoiler_text">  When using the AFC automatic frequency trim, the values ‚Äã‚Äãof the shift between the tuned receiver and transmitter frequencies are written to the Frequency offset 1 and 2 registers.  These values ‚Äã‚Äãcan be used to fine tune the frequency while turning off the automatic frequency control and reducing the preamble length and, accordingly, the detection threshold. </div></div><br>  After successfully detecting the preamble, the radio waits for a word of synchronization.  On his arrival compares the received bits.  After a successful comparison, the SI4432 begins to fill in the FIFO with the transmitted data.  The synchronization word, known for the receiver and transmitter of the bit sequence, makes it possible to identify the transmitted data. <br><br>  If the transmitted data has an arbitrary length (you can make a fixed one), then a byte with information about the length of the transmitted data is added to the packet. <br><br>  A CRC checksum is also added to the packet. <br><br>  Using the packet handler, the microcontroller configures the format of the transmitted packet once during initial setup of the SI4432, then, in order to transfer the data, the microcontroller must simply write it to the corresponding FIFO register SI4432. <br><br>  Disabling the header, setting a variable number of bytes of the transmitted data (the number of transmitted bytes is recorded automatically in the transmitted data packet) and 2 bytes for the synchronization word: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x33</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">About headlines</b> <div class="spoiler_text">  If a header is used, the receiver's packet handler filters the header, thereby identifying from which transmitter the message came. </div></div><br>  Direct installation of sync word 0x2DD4: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x36</span></span>, <span class="hljs-number"><span class="hljs-number">0x2D</span></span>); SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x37</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>);</code> </pre> <br>  Enable transmitter and CRC packet handler: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x0D</span></span>);</code> </pre> <br>  Selecting the FIFO modulation source and installing GFSK modulation: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x71</span></span>, <span class="hljs-number"><span class="hljs-number">0x63</span></span>);</code> </pre> <br>  The modulation source is the data that needs to be modulated to be broadcast.  In this case, the FIFO is set by the source.  But there is a direct mode when the data bits, with a certain timing, are fed to any output of the SI4432 (GPIOn, SDI, NIRQ). <br><br>  As described earlier, the module has one output for the antenna and a mode switch for receiving transmission on the uPG2179TB chip, the outputs of which are connected to GPIO0 and GPIO1.  Thus, it is possible to program the GPIO to automatically switch: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x0B</span></span>, <span class="hljs-number"><span class="hljs-number">0x12</span></span>);<span class="hljs-comment"><span class="hljs-comment">//  GPIO0     TX SpiWriteRegister(0x0C, 0x15);// GPIO1     RX</span></span></code> </pre> <br>  The accuracy of the center frequency setting is determined by the accuracy of the quartz resonator, its load capacity, as well as the various parasitic capacitances in the resonator circuit.  To reduce the influence of these factors on the accuracy of the center frequency setting is possible in the following ways: <br><br>  1) Use a higher deviation frequency for the transmitter and a wider range for the receiver. <br><br>  2) Use AFC (Auto-frequency calibration), for this you need to increase the length of the preamble. <br><br>  3) Adjust the register responsible for the load capacity of the quartz resonator: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0xD7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 0xD7      </span></span></code> </pre> <br><h4>  Send package </h4><br>  We will send the package once a second. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  while(1) { delay_ms(1000); /*  */ //    - 8  SpiWriteRegister(0x3E, 8); // 8      // FIFO   SpiWriteRegister(0x7F, 0x42); SpiWriteRegister(0x7F, 0x55); SpiWriteRegister(0x7F, 0x54); SpiWriteRegister(0x7F, 0x54); SpiWriteRegister(0x7F, 0x4F); SpiWriteRegister(0x7F, 0x4E); SpiWriteRegister(0x7F, 0x31); SpiWriteRegister(0x7F, 0x0D); //        //         SpiWriteRegister(0x05, 0x04); SpiWriteRegister(0x06, 0x00); //   ,       NIRQ  . 1 ItStatus1 = SpiReadRegister(0x03); ItStatus2 = SpiReadRegister(0x04); /* */ //         SpiWriteRegister(0x07, 0x09); //    while(NIRQ == 1); //       ItStatus1 = SpiReadRegister(0x03); ItStatus2 = SpiReadRegister(0x04); }</span></span></code> </pre> <br><h3>  Receive a data packet with a packet handler </h3><br><h4>  Radio initialization </h4><br>  Initialization of the receiver is similar to transmitter initialization.  You must reset and read the status registers. <br><br><h4>  Frequency setting </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   915  SpiWriteRegister(0x75, 0x75); SpiWriteRegister(0x76, 0xBB); SpiWriteRegister(0x77, 0x80);</span></span></code> </pre> <br>  Radio parameters: 9.6 kbps, GFSK modulation, 45 kHz frequency deviation, 112.1 kHz receiving range.  In accordance with the frequency calculator, the following registers are filled: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x1C</span></span>, <span class="hljs-number"><span class="hljs-number">0x05</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 0x05  IF Filter Bandwidth  SpiWriteRegister(0x20, 0xA1); // 0xA1  Clock Recovery Oversampling Ratio  SpiWriteRegister(0x21, 0x20); // 0x20  Clock Recovery Offset 2  SpiWriteRegister(0x22, 0x4E); // 0x4E  Clock Recovery Offset 1  SpiWriteRegister(0x23, 0xA5); // 0xA5  Clock Recovery Offset 0  SpiWriteRegister(0x24, 0x00); // 0x00  Clock Recovery Timing Loop Gain 1  SpiWriteRegister(0x25, 0x13); // 0x13  Clock Recovery Timing Loop Gain 0  SpiWriteRegister(0x1D, 0x40); // 0x40  AFC Loop Gearshift Override  SpiWriteRegister(0x72, 0x48); // 0x48  Frequency Deviation  SpiWriteRegister(0x2A, 0x20); // 0x20  AFC Limiter </span></span></code> </pre> <br><h4>  Install Package Structure </h4><br>  Similar to the transmitter: disabling the header, setting a variable number of bytes of the transmitted data (the number of transmitted bytes is recorded automatically in the transmitted data packet) and 2 bytes for the synchronization word: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x33</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>);</code> </pre> <br>  Turn off header filtering: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x32</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> );</code> </pre> <br>  Direct installation of sync word 0x2DD4: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x36</span></span>, <span class="hljs-number"><span class="hljs-number">0x2D</span></span>); SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x37</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>);</code> </pre> <br>  Enable receiver receiver and CRC handler: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x85</span></span>);</code> </pre> <br>  Enabling FIFO and GFSK modulation: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x71</span></span>, <span class="hljs-number"><span class="hljs-number">0x63</span></span>);</code> </pre> <br>  Setting the preamble detection threshold of 20 bits: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x35</span></span>, <span class="hljs-number"><span class="hljs-number">0x28</span></span>);</code> </pre> <br>  Setting the GPIO to automatically switch the antenna: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x0B</span></span>, <span class="hljs-number"><span class="hljs-number">0x12</span></span>);<span class="hljs-comment"><span class="hljs-comment">//  GPIO0     TX SpiWriteRegister(0x0C, 0x15);// GPIO1     RX</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">About fixed packet length</b> <div class="spoiler_text">  With a fixed packet length, the length data is not included in the packet, but stored in the Transmit Packet Length register of both the receiver and the transmitter, and the fixpklen bit in the Header Control 2 register must be set (see <a href="http%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FTechnicalDocs%252FAN440.pdf%26usg%3DAFQjCNH6Mu1TtfrFpwvmyvTtEZ2SlPwIoA%26sig2%3DWe71_IwXy0ofdBMzGvsWuw%26bvm%3Dbv.128617741,d.bGs%26cad%3Drjt">the register map</a> ) </div></div><br>  If the diversity reception is not used, the SGI bit in the AGC register must be set for the analog gain control to work correctly: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x69</span></span>, <span class="hljs-number"><span class="hljs-number">0x60</span></span>);</code> </pre> <br>  Setting the register responsible for the load capacity of the quartz resonator: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0xD7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 0xD7      </span></span></code> </pre> <br><h4>  Reception package </h4><br>  Receiver activation: <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x07</span></span>, <span class="hljs-number"><span class="hljs-number">0x05</span></span>);<span class="hljs-comment"><span class="hljs-comment">// 0x05  Operating Function Control 1 </span></span></code> </pre> <br>  We enable two interrupts: <br><br>  1) interrupt on receiving a valid packet; <br>  2) CRC error interrupt. <br><br><pre> <code class="cpp hljs">SpiWriteRegister(<span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x03</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 0x03  Interrupt Enable 1  SpiWriteRegister(0x06, 0x00); // 0x00  Interrupt Enable 2 </span></span></code> </pre> <br>  Reading status registers to reset interrupts: <br><br><pre> <code class="cpp hljs">ItStatus1 = SpiReadRegister(<span class="hljs-number"><span class="hljs-number">0x03</span></span>); ItStatus2 = SpiReadRegister(<span class="hljs-number"><span class="hljs-number">0x04</span></span>);</code> </pre> <br>  Main loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  if(NIRQ == 0) { //   ItStatus1 = SpiReadRegister(0x03); ItStatus2 = SpiReadRegister(0x04); if( (ItStatus1 &amp; 0x01) == 0x01 )//  CRC { //  SpiWriteRegister(0x07, 0x01);// 0x01  Operating Function Control 1  // RX FIFO SpiWriteRegister(0x08, 0x02);// 0x02  Operating Function Control 2  SpiWriteRegister(0x08, 0x00);// 0x00  Operating Function Control 2  //  SpiWriteRegister(0x07, 0x05); } if( (ItStatus1 &amp; 0x02) == 0x02 )//   { //  SpiWriteRegister(0x07, 0x01);// 0x01  Operating Function Control 1  //    length = SpiReadRegister(0x4B);//  Received Packet Length //    RX FIFO for(temp8=0;temp8 &lt; length;temp8++) { payload[temp8] = SpiReadRegister(0x7F);// FIFO Access  } //     { //... } // RX FIFO SpiWriteRegister(0x08, 0x02);// 0x02  Operating Function Control 2  SpiWriteRegister(0x08, 0x00);// 0x00  Operating Function Control 2  //  SpiWriteRegister(0x07, 0x05); } } }</span></span></code> </pre> <br><h3>  Conclusion </h3><br>  All information on programming modules is taken from the <a href="http%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FTechnicalDocs%252FAN415.pdf%26usg%3DAFQjCNHsdot0TwHOKowi01kIuXUDwUMQWg%26sig2%3DizPZwdl9MayeZw_1CQAWOQ%26bvm%3Dbv.128617741,d.bGs">Application Note 415 Programming guide</a> . <br><br>  The <a href="https%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FTechnicalDocs%252FSi4430-31-32.pdf%26usg%3DAFQjCNGvsDdvX_g8fiIhEvfVTN1OknrQ_A%26sig2%3D5iaMqxS7ld1l2OlSwUjvBw%26bvm%3Dbv.128617741,d.bGs">datasheet on the SI4432</a> has a list of all Application Note, representing something like the peace reports related to the work of the SI4432.  In addition to the datasheet and the specified Programming guide, there is one more useful document among Application Note - <a href="http%253A%252F%252Fwww.silabs.com%252FSupport%252520Documents%252FTechnicalDocs%252FAN440.pdf%26usg%3DAFQjCNH6Mu1TtfrFpwvmyvTtEZ2SlPwIoA%26sig2%3DWe71_IwXy0ofdBMzGvsWuw%26bvm%3Dbv.128617741,d.bGs%26cad%3Drjt">the register map</a> .  The programming guide also describes how to configure the transmitter for two-way communication.  The register map provides a detailed description of all registers, modes of operation, and settings. </div><p>Source: <a href="https://habr.com/ru/post/307836/">https://habr.com/ru/post/307836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307826/index.html">20+ My favorite AngularJS helpers</a></li>
<li><a href="../307828/index.html">Discovered a new hacking mechanism for cloud virtual machines</a></li>
<li><a href="../307830/index.html">Tales of Ransomwhere: how often spam campaigns are used</a></li>
<li><a href="../307832/index.html">Nagios - monitoring system and some homemade plugins</a></li>
<li><a href="../307834/index.html">About Sailfish OS Summer School 2016</a></li>
<li><a href="../307838/index.html">The book "Simple Python. Modern programming style "</a></li>
<li><a href="../307840/index.html">Using gpio-generic and irq_chip_generic for gpio driver</a></li>
<li><a href="../307842/index.html">The art of forecasting in the SAP F & R system for inventory management</a></li>
<li><a href="../307844/index.html">Requirements collection methods or ‚ÄúHow to understand what the customer wants?‚Äù</a></li>
<li><a href="../307848/index.html">Python dependency management: it looks like you can already use it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>