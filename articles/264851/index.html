<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to fix the error in Node.js and inadvertently raise performance by 2 times</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with the fact that I optimized the return of the HTTP 408 Request Timeout error in the Impress application server running on Node.js. A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to fix the error in Node.js and inadvertently raise performance by 2 times</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/de6/b42/5e6/de6b425e629a43219c4f8bb5375ed8c2.png">  It all started with the fact that I optimized the return of the <a href="http://tools.ietf.org/html/rfc2068">HTTP 408 Request Timeout</a> error in the <a href="https://www.npmjs.com/package/impress">Impress</a> application server running on <a href="http://nodejs.org/">Node.js.</a>  As you know, the node. <a href="&amp;xid=17259,15700019,15700186,15700191,15700248,15700253&amp;usg=ALkJrhilBrl965_mQ8c_BZfXYwUfKGh4OA#http_class_">http.Server</a> has a timeout event that must be <a href="&amp;xid=17259,15700019,15700186,15700191,15700248,15700253&amp;usg=ALkJrhilBrl965_mQ8c_BZfXYwUfKGh4OA#http_class_">raised</a> for each open socket if it has not closed during the specified time.  I want to clarify that not for every request.  not for each request event, whose function has two arguments (req, res), namely for each socket.  Through a single socket can consistently receive many requests in the mode of <a href="http://tools.ietf.org/html/rfc7230">keep-alive</a> .  If we set this event, via server.setTimeout (2 * 60 * 1000, function (socket) {...}), we must destroy socket.destroy () by ourselves.  But if you do not install your handler, then http.Server has a built-in that will destroy the socket after 2 minutes automatically.  At this very timeout, you can give an error 408 and consider the incident settled.  If it were not for one thing ... I was surprised that I found out that the timeout event is also triggered for those sockets that have hung up for those that have already received an answer and for those that are closed by the client side, in general, for all who are in the keep-alive mode.  This strange behavior turned out to be quite complicated, and I will tell about it below.  It would be possible to insert one check into the timeout event, but with my idealism I could not resist and it was useful to correct the bug a level deeper.  It turned out that the keep-alive mode was not implemented in http.Server not by RFC, but frankly not added.  Instead of a separate timeout for the connection and a separate keep-alive timeout, everything is on one timeout, which is implemented on fast pseudo-timers (enroll / unenroll), but is set to 2 minutes by default.  It would not be so bad if browsers worked well with keep-alive and reused it effectively or closed unused connections. <a name="habracut"></a><br><br><h4>  First results </h4><br>  After 12 lines of changes, the timeout event started to fire only when the server did not respond to the client and the client waits for it.  The connection timeout remained with the default value of 2 minutes, but http.Server.keepAliveTimeout appeared with a default value of 5 seconds (like in Apache).  Repository with corrections: <a href="https://github.com/tshemsedinov/node">tshemsedinov / node</a> (for node.js 0.12) and <a href="">tshemsedinov / io.js</a> (for io.js).  Soon I will send pull requests, respectively, to <a href="https://github.com/joyent/node">joyent / node</a> and <a href="https://github.com/nodejs/node">nodejs / node</a> (the former io.js, and now there are already glued projects in it). <br><br>  <b>The essence of the correction</b> is that the connection timeout should work if the connection is stalled, leaving the request unanswered, and if the socket is open, but all requests are answered, then you need to wait much less, giving you the opportunity to send another request in keep-alive mode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is already possible to guess about the side effect, a lot of memory and socket descriptors have been freed, which immediately caused in my current high-load projects an increase in the overall performance of more than 2 times.  And here I will show a small test with a code, the results of which can be seen on the graphs below and giving an idea of ‚Äã‚Äãwhat is happening. <img src="https://habrastorage.org/files/f3d/37f/71c/f3d37f71c30a4fa5ab9b3789babae7f7.png"><br>  The essence of the test: create 15 thousand HTTP / 1.1 connections (which are considered keep-alive by default, even without special headers) and check the intensity of creating and closing sockets and memory costs.  The test was performed for 200 seconds, data was recorded every 10 seconds.  The charts on the left are Node.js 0.2.7 without fixes, and on the right are the patched and reassembled Node.js.  Blue line - the number of open sockets, and red - closed sockets.  For this, I of course had to write all the sockets into an array, which did not allow completely freeing the memory.  Therefore, there are two variants of the client part of the test, with an array of sockets, and without it, to check the memory.  As expected, the sockets are released 2 times faster, which means that they do not occupy descriptors and do not load the TCP / IP stack of the operating system, which in addition to the node holds data structures and buffers for each descriptor. <img src="https://habrastorage.org/files/9de/600/6ba/9de6006ba5654c639fd8870933fc9e59.png"><br>  Blue line - RSS (resident set size) - how long the whole process takes, red - heap total - allocated memory for the application, green - heap used - used memory.  Naturally, all freed up memory can be reused for other sockets, even faster than at the first allocation. <br><br>  Test code: <div class="spoiler">  <b class="spoiler_title">Client part of the test</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> net = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'net'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; keepAliveConnect(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keepAliveConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = net.connect({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">allowHalfOpen</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ c.write(<span class="hljs-string"><span class="hljs-string">'GET / HTTP/1.1\r\nHost: localhost\r\n\r\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count++ <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">15000</span></span></span></span><span class="xml"><span class="hljs-tag">) </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">keepAliveConnect</span></span></span></span><span class="xml"><span class="hljs-tag">(); }); }</span></span></span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Server side with socket counters</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pad = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) pad += <span class="hljs-string"><span class="hljs-string">'- - - - - - - - - - - - - - - - - '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sockets = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = req.socket; sockets.push(socket); res.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>}); res.end(pad + <span class="hljs-string"><span class="hljs-string">'Hello World\n'</span></span>); }); setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> destroyedSockets = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sockets.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sockets[i].destroyed) destroyedSockets++; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = process.memoryUsage(), a = [m.rss, m.heapTotal, m.heapUsed, sockets.length, destroyedSockets]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.join(<span class="hljs-string"><span class="hljs-string">','</span></span>)); }, <span class="hljs-number"><span class="hljs-number">10000</span></span>); server.listen(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>);</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">Server side without socket counters</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pad = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) pad += <span class="hljs-string"><span class="hljs-string">'- - - - - - - - - - - - - - - - - '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>}); res.end(pad + <span class="hljs-string"><span class="hljs-string">'Hello World\n'</span></span>); }); setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = process.memoryUsage(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([m.rss, m.heapTotal, m.heapUsed].join(<span class="hljs-string"><span class="hljs-string">','</span></span>)); }, <span class="hljs-number"><span class="hljs-number">10000</span></span>); server.listen(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>);</code> </pre></div></div><br><h4>  Details of the problem </h4><br>  If the client side does not request keep-alive, Node.js closes the socket immediately upon a call to res.end () and no resource leaks occur.  Therefore, all the tests in which we do massively http.get ('/'). On ('error', function () {}) or curl http://domain.com/ or via ab (apache benchmark) show that all OK.  And browsers always want to keep-alive, with which they work badly, like a node.  The problem of keep-alive is that through it you can send several requests only sequentially, there is no batch mechanism in it that would mark which of the competitive requests each answer answers.  Granted, this is wildly uncomfortable.  There is no such problem in <a href="httpbis-spdy-00">SPDY</a> and <a href="https://tools.ietf.org/html/rfc7540">HTTP / 2</a> .  When browsers load a page with many resources, they sometimes use keep-alive, but more often they send the correct headers, telling the server to keep open connections, while they themselves use it very little or even ignore it, guided by some incomprehensible logic.  Here Firebug and DevTools show that requests are completed, and sockets hang.  Even if the page has already been fully loaded, several sockets were created, they are not closed, and we need to make one unfortunate request to the API, my observations show that browsers always create a new connection, and sockets keep them until the server will close.  Such suspended sockets are not considered to be parallel requests, so they do not affect browser restrictions (I understand that they are marked as half-open, not used and excluded from the counter).  This can be checked, if you close the browser, then on the node server immediately closes a whole bundle of sockets that did not have time to wait for their 2 minutes of timeout. <br><br>  From the side of the node, the timeout is set to 2 minutes, regardless of whether the response is sent to the client side or not.  Lowering this timeout, for example, to 5 seconds is not an option, as a result, connections that objectively take longer than 5 seconds will fail.  We need a separate timeout for keep-alive, the counting of which does not begin immediately, but after the last activity in the socket, i.e.  This is the real time waiting for the next request from the client. <br><br>  In general, for the full implementation of keep-alive, you need to do much more, take the desired timeout from the HTTP headers sent by the client, send the client the actual set timeout time in the response headers, process the max and Keep-Alive Extensions parameter.  But modern browsers do not use all these things, in any case, from the experiments I conducted, they ignored these HTTP headers.  Therefore, I calmed down minor edits that gave great results. <br><br><h4>  Node.js fixes </h4><br>  First, I decided to patch the problem with unnecessary timeouts in a simple way, preventing emit events: <a href="https://github.com/tshemsedinov/node/commit/ae9a1a5d5b49d4e38d3d0adfc9acbdf11e42f028">ae9a1a5</a> .  But for this, I had to familiarize myself with the code and I did not like the way it was written.  In some places there are comments that it is impossible to write like that, you need to decompose large closures, get rid of the nesting of functions, but nobody touches these libraries, because then you can‚Äôt collect tests and you can ruin a lot of people with all dependent code.  Okay, everything will not work out, but the leakage of sockets did not give me rest.  And I decided to solve the problem by destroying the socket after ServerResponse.prototype.detachSocket, when one res.end () was already sent, but it broke a lot of useful behavior related to keep-alive: <a href="https://github.com/tshemsedinov/node/commit/9d9484b6b7808624d39e2b3bec3135647a5fa96a">9d9484b</a> .  After experimenting, reading RFCs and documentation on other servers, it became obvious that you need to implement a keep-alive timeout, and that it differs from just the connection timeout. <br><br>  Corrections: <ol><li>  Added server.keepAliveTimeout parameter, which can be set manually <a href="https://github.com/tshemsedinov/node/blob/ce4e14f7630f489f8f22e1f4532049c4076c4f13/lib/_">/lib/_http_server.js#L259</a> </li><li>  Renamed the prefinish event function to use it elsewhere <a href="https://github.com/tshemsedinov/node/blob/ce4e14f7630f489f8f22e1f4532049c4076c4f13/lib/_">/lib/_http_server.js#L455,L456</a> </li><li>  I hung the finish event to catch the moment when everything was answered.  No, I‚Äôll delete event handlers from the EventEmitter, which were hanged on the timeout event of the socket, and broadcast the event that destroys the socket </li><li>  For the https server we add the keepAliveTimeout parameter, because it inherits everything else from the prototype <a href="https://github.com/tshemsedinov/node/blob/ce4e14f7630f489f8f22e1f4532049c4076c4f13/lib/">/lib/https.js#L51</a> </li></ol><br>  For <a href="https://npmjs.org/package/impress">Impress Application Server,</a> all these changes are implemented inside, in the form of a beautiful patch and the effect is available even without a patch on Node.js, in its source codes you can see how simple it is done.  In addition, on recent projects we have achieved other, impressive results, for example, 10 million permanent connections on 4 servers, clustered (2.5 million per server), based on the SSE protocol (Server-Sent Events), and now we are preparing to make the same for websockets.  They implemented application balancing for the Impress cluster, tied the cluster nodes with their TCP-based protocol, instead of the previously used <a href="http://zeromq.org/">ZMQ,</a> from which they received significant acceleration.  I am also going to partially publish the results of this work in the following articles.  Many people tell me that nobody needs this optimization and performance, everyone doesn‚Äôt care.  But, at least on four live, highly loaded examples, for my customers from the PRC and for the interactive TV format ‚ÄúThe Seventh Sense‚Äù, I observe a general increase in productivity from 2-3 times to 1 order, and this is already significant.  To do this, I had to give up the principle of middleware, and rewrite interprocess communication, and implement applied balancing (hardware balancers do not cope), etc.  This will be a separate article about the horrors of performance when using middleware: "What the node gave, the middleware took away."  For which I have already prepared enough facts, statistics and examples, and I have something to offer in return. <br><br><h4>  Do you want everything at once, right now? </h4><br>  Then you need to test just such a patch and not on the basis of your build, but to show its impact on the official version of Node.js 0.12.7.  Now we‚Äôll check what happens if we add an additional 7 lines of code to the request event.  Sockets will be closed as needed and even the error with the extra timeout event also disappears, this is understandable.  But with memory, the situation is certainly much better, but not as much as when reassembling Node.js. <br><pre> <code class="javascript hljs">http.createServer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = req.socket; res.on(<span class="hljs-string"><span class="hljs-string">'finish'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ socket.removeAllListeners(<span class="hljs-string"><span class="hljs-string">'timeout'</span></span>); socket.setTimeout(<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ socket.destroy(); }); }); res.writeHead(<span class="hljs-number"><span class="hljs-number">200</span></span>, {<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>}); res.end(<span class="hljs-string"><span class="hljs-string">'Hello World\n'</span></span>); });</code> </pre><br>  Let's compare the results on the graphs: on the left - the initial state of Node.js 0.12.7, in the middle - adding 7 lines to the request and running on the official 0.12.7, on the right - the patched Node.js from my repository.  The reasons for this are clear, I did not slope 0.12.7, but a slightly newer version, and repelled from it.  Of course, all the tests except the last were carried out on my repository, with the patch and without the patch.  And I compared the last test with the official version 0.12.7, to make it clear how this will affect your code now. <img src="https://habrastorage.org/files/889/32b/806/88932b8062a54bb3b1f2bbf33a6aebbc.png"><br>  The version of V8 in my repository is the same as in 0.12.7, but it is obvious that optimization has happened in the node.  If you wait quite a bit, then you will be able to use either the patch mentioned above or the corrections get into the node.  The results of these two options are almost the same.  In general, I am going to continue to engage in experiments and optimization in this direction, and if you have ideas, please do not hesitate to offer and connect to bring the code of the most critical embedded libraries of the node into a decent look.  Believe me, there is a lot of work for a specialist of any level.  In addition, the study of the source code is the best known method for me to master the platform. <br><br>  <b>Update</b> : found another problem there with _last, no one figured it out.  Now merged with neighboring edits, tested and laid out a pull-request and <a href="https://github.com/nodejs/node/pull/2534">https://github.com/nodejs/node/pull/2534</a> </div><p>Source: <a href="https://habr.com/ru/post/264851/">https://habr.com/ru/post/264851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264839/index.html">15 Important Developer Career Tips</a></li>
<li><a href="../264841/index.html">How to write software for the whole world</a></li>
<li><a href="../264843/index.html">Exploring OpenWRT: what is the difference between the uImage and sysupgrade images</a></li>
<li><a href="../264845/index.html">The digest of interesting materials for the mobile # 116 developer (on August 10-16)</a></li>
<li><a href="../264849/index.html">Megaphone - anyone can manage your account</a></li>
<li><a href="../264853/index.html">mhddfs - Mounting multiple partitions in one directory</a></li>
<li><a href="../264855/index.html">How we created the new VoxImplant logo</a></li>
<li><a href="../264859/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ172 (August 9 - 16, 2015)</a></li>
<li><a href="../264861/index.html">How to replace jQuery with D3 in a project</a></li>
<li><a href="../264863/index.html">Exception catching and handling in Yii2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>