<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tic Tac Toe "Without Borders"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... they all played, I'm sure. The game is attractive in its simplicity, especially when you pull a watch somewhere in a lesson, a pair, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tic Tac Toe "Without Borders"</h1><div class="post__text post__text-html js-mediator-article">  Tic-tac-toe ... they all played, I'm sure.  The game is attractive in its simplicity, especially when you pull a watch somewhere in a lesson, a pair, and there is nothing at hand except a notebook sheet and a simple pencil.  I don‚Äôt know who the first one ever thought to draw crosses and circles in 9 squares, but since then the game has not lost in demand at all, especially since the people came up with a great many of its variations. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  This article is about the process of developing AI on javascript for playing one of these variations of daggers: there was a lot of material, but I diluted it with animation and pictures.  In any case, at least it is worth trying to play it. <br>  The differences of this version of the game from the original are as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <b>The field</b> can be arbitrarily <b>large</b> (How long is enough notebook) </li><li>  The one who puts <b>5 pieces</b> (if you can call them that) in a row wins. </li></ol><br>  Everything is simple ... and at the same time difficult: the outcome of the game cannot be calculated in advance, as in the classic version.  This "little project" took me a lot of time and nerves.  I hope you will be interested. <a name="habracut"></a><br><br><h3>  Before we begin </h3><br>  I am forced to apologize in advance for the volume of the article and in some places not quite an intelligible statement of thought, but I did not manage to squeeze the flock without a loss in content and quality. <br>  I recommend first to get acquainted with the <a href="http://alexpelmen.github.io/">result</a> .  <a href="https://github.com/AlexPelmen/tic-tac-bot">Code</a> <br><br>  Hotkeys and commands: <br><br><ul><li>  <b>D</b> - AI will make a move for you </li><li>  <b>T</b> - view cell weight </li><li>  Write in the console <b>SHOW_WEIGHTS = true</b> to view the weights of all the analyzed cells. </li></ul><br><h3>  Let's start </h3><br>  You need to start with the implementation of the game itself, i.e.  write an application for two players, as long as no bot.  For my own purposes, I decided to use javascript + jquery + bootstrap4, although it is practically not used there, but it is better to leave it - or the table will float.  There is nothing special to tell, the material on js, jquery and bootstrap on Habr√© is full.  Let me just say that I used MVC.  And in general, I will not explain absolutely all the code - there was already a lot of material. <br><br>  So, the playing field was ready.  You can set the figures in the cells.  But the victory of any of the players was not fixed. <br><br><h3>  Scan the "end of the game" </h3><br>  The game ends when one of the players puts <b>5 pieces</b> in a row.  ‚ÄúIt's simple!‚Äù I thought.  And he began to scan absolutely all the cells of the field: first all the horizontals, then the verticals and, finally, the diagonals. <br><br>  It's a dumb way, but it worked.  However, it could be significantly improved, which I did: Most of the cells will remain empty throughout the game - the playing field is too large to fill it up completely.  Since it was necessary to scan it every move, and in one move only one figure is put - then you can focus only on this figure (cell): scan only one horizontal, vertical and two diagonals of the cell that owns that cell. <br><br>  Plus, you do not need to scan all the cells of the lines.  Since the end of the game is 5 figures in a row, we are not interested in figures located 6 cells apart from each other.  It is enough to scan five cells in each side.  Unclear?  See the animation below. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Let's get to the bot itself </h3><br>  So, we have already written a page with tic-tac-toe.  We proceed to the main task - AI. <br>  You can not just take and write code, if you do not know how: you need to think about the logic of the bot. <br><br>  The bottom line is to analyze the playing field, at least part of it, and miscalculate the <b>price (weight) of</b> each cell on the field.  The cage with the greatest weight - the most promising - is where the bot comes and puts the figure.  The main difficulty is in the calculation of the weight of one cell. <br><br><h3>  Terminology </h3><br>  <b>Noughts and crosses</b> are figures. <br>  <b>Attack</b> we will call several identical figures standing side by side on the same line.  In fact, this set.  The number of pieces in the attack - its <b>power</b> .  One separate figure is also an attack (power 1). <br><br>  On the adjacent attack cells (at the ends) there may be empty cells or enemy pieces.  It is logical to think that the attack with two empty cells at the "ends", we can develop in two directions, which makes it more promising.  The number of empty cells at the ‚Äúends‚Äù of the attack will be called its <b>potential</b> .  The potential can be 0, 1 or 2. <br>  Attacks are denoted as follows: <b>[attack power, potential]</b> .  For example, <b>attack [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figure 1. Attack [4: 1]</i> <br><br>  During the analysis, we will evaluate all the cells that are in a specific area.  Each cell will calculate its <b>weight</b> .  It is calculated based on the weights of all attacks that are affected by a given cell. <br><br><h3>  The essence of the analysis </h3><br>  Imagine that on the playing field there are already several attacks of one and second player.  Someone from the players makes a move (let the crosses).  Naturally, he makes a move to an empty cell - and thus he can: <br><br><ol><li>  Develop your attack, and maybe not just one, by increasing its power.  Can start a new attack, etc. </li><li>  Prevent the development of an enemy attack or block it altogether. </li></ol><br>  That is, our protagonist can attack and defend.  And maybe all at once in one move.  For him it is important, both the first and second. <br><br>  The essence of the analysis is as follows: <br><br><ol><li>  The bot inserts figures into the checked cell: first a cross, then a zero. </li><li>  Next, he searches for all the attacks that were received by such moves and summarizes their weights. </li><li>  The amount received is the weight of the cell. </li><li>  A similar algorithm is performed for all cells of the playing field. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  In fact, with this algorithm we check what will happen if we go like this ... and what will happen if the opponent goes like that.  We look one step ahead and choose the most suitable cell - with the greatest weight. <br><br>  If a cell has more weight than another, it means that it creates more dangerous attacks, or blocks strong enemy attacks.  Everything is logical ... it seems to me. <br>  If you go to the page and write in the console SHOW_WEIGHTS = true, you can visually feel the work of the algorithm (Cell weights will be shown). <br><br><h3>  Attack weights </h3><br>  I lost my mind and brought this correspondence of attacks and scales: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Selected empirically - perhaps this is not the best option. <br><br>  I added an attack with a power of 5 with an extremely high weight.  This can be explained by the fact that the bot analyzes the game, looking at a step forward (substituting the figure into a cell).  Skipping such an attack is nothing but a defeat.  Well, or a victory ... looking for someone. <br><br>  Attacks with great potential are valued higher. <br><br>  The attack [4: 2] in most cases decides the outcome of the game.  If the player managed to create such an attack, then the opponent will not be able to block it.  However, this is not a victory.  The enemy can finish the game faster, even if we have an attack on the field [4: 2], so its weight is lower than that of attacks with a power of 5. See the example below. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figure 2. Attack [4: 2]</i> <br><br><h3>  Ripped Attacks </h3><br>  In this paragraph, the code is not presented.  Here we introduce the concept of the attack divider and explain the essence of the <b>‚Äúragged attacks‚Äù</b> . <br><br>  Consider the following situation: when replacing a shape at a distance of several empty cells, but not more than 5, another one is located. <br><br>  And like, two identical figures, on the same line ... visually it looks like an attack, but in fact not.  Do not order, as such "ragged" attacks also carry a potential threat. <br><br>  Especially for such cases, for each attack we will calculate the divisor.  Initially, its value is 1. <br><br><ol><li>  We present the ‚Äútorn‚Äù attack as a few ordinary </li><li>  We count the number of empty cells between the central attack and the side </li><li>  For each empty cell, the divisor is increased by 1 </li><li>  The weight of the central attack is calculated as usual, the weight of the secondary is divided by the divisor. </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Figure 3. Analysis of the "torn attack".</i>  <i>Scanned cell with a yellow cross.</i> <br><br>  Thus, "torn" attacks will also be taken into account by the AI.  In fact, these will be ordinary attacks, but the farther they are from the scanned cell, the less influence it has and, accordingly, they have less weight (thanks to the divider). <br><br><h3>  Attack search algorithm </h3><br>  First, create <b>an</b> attack <b>class</b> .  The attack will have 3 attributes, which I wrote about earlier: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  And one <b>method</b> that will return the weight of this attack: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Further.  Search for all attacks for a single cell will be divided into: <br><br><ol><li>  Horizontal search </li><li>  Vertical search </li><li>  45 degree diagonal search </li><li>  Search on 135 degrees diagonal </li></ol><br>  All these are <b>lines</b> , and the algorithm for searching for attacks on these lines can be summarized: the <b>class checkLine</b> . <br><br>  However, we do not need to check the entire line.  The maximum attack power that interests us is 5. Certainly, creating an attack with a power of, say, 6 is possible.  But for the AI, who analyzes the game situation of the next move, it‚Äôs like 6, that 5. The prospect of getting one of these attacks speaks of the end of the game on the next move.  Accordingly, the weight of the analyzed cell will be the same in both cases. <br><br>  Class Attributes: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "√ó"; //     .    ¬´0¬ª - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  It is necessary to stop here, as the question may arise: why check the 6th cell, if the maximum attack power is 5. The answer is to determine the potential remote from the center of attack. <br><br>  Here is an example: the attack with a power of 1 in the picture is on the border of the scanned area.  To find out the potential of this attack, you need to "look abroad." <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Scan 6th cells.</i>  <i>If you do not scan the 6th cell, you can incorrectly determine the attack potential.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  To complete some attacks may simply not enough space.  Considering the attackplace, we can understand in advance which of the attacks are unpromising. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Place to attack</i> <br><br>  The algorithm is as follows: <br><br>  1) Let's start with the central cell.  It should be empty (we're going to make a move in it, aren't we? However, we do not forget that our AI should substitute figures in this cell for analyzing the next move. The figure we substitute ‚Äî <b>this.subfig</b> ‚Äî is a cross by default. Since the central cell will initially contain some shape after the substitution, it will belong to some kind of attack <b>this.curAttack</b> : <br><br><ul><li>  its power will be at least 1 (figure in the central cell) </li><li>  the divisor is 1, since  it is a central attack (it owns the scanned cell); </li><li>  potential is not yet known - default is 0; </li></ul><br><br>  All of these items we have displayed in the values ‚Äã‚Äãof the default constructor - see the code above. <br><br>  2) Next, reducing the iterator, sort through 5 cells on one side of the scan.  The <b>getAttacks</b> function <b>(cellX, cellY, subFig, dx, dy)</b> is responsible for this, where: <br><br>  <b>cellX, cellY</b> - coordinates of the checked cell <br>  <b>subFig</b> - the shape that we substitute in the checked cell <br>  <b>dx, dy</b> - changes of x and y coordinates in cycles - this is how we set the search direction: <br><br><ul><li>  Horizontal (dx = 1, dy = 0) </li><li>  Vertical (dx = 0, dy = 1) </li><li>  Diagonal 45 (dx = 1, dy = -1) </li><li>  135 diagonal (dx = 1, dy = 1) </li></ul><br>  In a sense, this is a vector parallel to the search line.  Thus, one function will be able to search in 4 directions and we will not violate the DRY principle once again. <br><br>  Function code: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Please note that if checkCell () returns something, then the loop is terminated. <br><br>  3) Check the shape of these cells. <br>  The <b>checkCell (x, y)</b> function is responsible for this: <br><br>  First, let's write the figure in the variable <b>fig</b> : <br>  <b>Model.Field</b> is our playing field. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> can be 'x', 'o', 'b' (border), 0 (empty cell). <br><br><ul><li>  If such a figure coincides with the central cell ( <b>this.subFig</b> ), then we continue the algorithm - then we continue to scan the attack, everything is fine, we continue in the same spirit.  The extra figure in the attack - plus its power ( <b>this.curAttack.capability</b> ) and place ( <b>this.attackplace</b> ). <br><br>  (See the code in the next paragraph) </li><li>  If this is a different figure, then the attack that we scanned before (this.curAttack) is blocked from this side.  We change nothing in the attack parameters, write it into the array of attacks and fall out of the loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  If there is no such cell, it means that it fell outside the field, which means that the attack is blocked.  We write it into an array of all attacks and exit the loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  If you catch an empty cage - then the current attack is over, or we are dealing with a "torn attack."  Plus, the potential and the place to attack (because the attack is not blocked).  However, we are not leaving the loop - perhaps this is a ‚Äútorn attack‚Äù - we simply write this.curAttack into the array of all attacks of the this.Attacks [] line.  We create a new ‚Äúcurrent‚Äù attack and increase its divisor by 1 (this is already a side attack). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) If the figure on the 5th square coincides with the central cell, then the attack ‚Äúrested‚Äù on the border and in order to determine the attack potential it is necessary to ‚Äúcheck the border‚Äù ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  The <b>checkCell</b> function is ready.  However, we continue to work on the class <b>checkLine</b> . <br><br>  5) After the first cycle, you need to "turn around."  We translate the iterator to the center and the central attack, with the index 0, remove from the array of attacks and set as the current one. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Next, go to the other side of the current cell, increasing the iterator. <br>  Absolutely the same check of figures.  (The code has already been written - <b>getAttacks</b> function) <br><br>  7) Everything, we collected all the attacks that were on the line in one array. <br>  On this with the class <b>checkLine</b> all ... finished. <br><br>  Well, then everything is simple - create a <b>checkLine</b> object for each of the lines (2 diagonals, horizontal and vertical) and call the <b>getAttacks</b> function.  That is, for each line - its own <b>checkLine</b> object and, accordingly, its own set of attacks. <br><br>  Let the <b>getAllAttacks ()</b> function be responsible for all this - already separately from the classes described above; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '√ó', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '√ó', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '‚óã', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  At the exit we have an object with all the attacks for the checked cell. <br><br>  However, you may have noticed some kind of filter function.  Its task is to screen out "unpromising" attacks: <br><br><ul><li>  With zero power (you never know will get into the array) </li><li>  Attacks that lack space (attackplace &lt;5) </li><li>  With zero potential. </li></ul><br>  However, if the attack has a power greater than 5, then the filter will miss it.  Such a bot should see attacks, their screening will lead to jambs at the end of the game. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Breakpoints </h3><br>  Yes ... the term is again, sorry!  So we will call the situation in the game when one wrong move decides the outcome of the game. <br><br>  For example, the attack [3: 2] is a breakpoint.  If the opponent does not block it by placing a piece next to it, then with the next move, we already have an attack on the playing field [4: 2] - well, the outcome of the game is decided, no matter how cool (In the overwhelming majority of cases). <br><br>  Or attack [4: 1].  One yawn - and the game can be easily completed. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figure 5. Breakpoint</i> <br><br>  Everything is clear and understandable here, and the algorithm about which it was written above is already able to take into account breakpoint and timely block them.  Bot looks at the course ahead.  He will see that on the next move, the opponent is able to create an attack [5: 1], for example, whose weight is 200 - it means that the cunning bootyar goes here. <br><br>  However, imagine a situation where one of the players manages to get 2 breakpoint on the field.  And this, obviously, leaves no chance to the opponent, since  in one move we can block only one breakpoint.  How to teach our AI to block such attacks? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figure 6. 2 Breakpoint</i> <br><br>  Everything is simple, when analyzing a cell, when substituting a figure into it, we will count the number of breakpoints we will receive on the next turn (the bot looks at the course ahead, do not forget).  Having counted 2 breakpoints, we increase the cell weight by 100. <br><br>  And now, the bot will not only prevent such game situations, but also be able to create them, which makes it now a more formidable opponent. <br><br><h3>  How to understand that the attack - breakpoint </h3><br>  Let's start with the obvious: any attack, with a capacity of 4 - breakpoint.  Just one missed move gives us the opportunity to complete the game, i.e.  put 5 pieces in a row. <br><br>  Further, if the attack potential is 2, then we will spend 1 more stroke to block such an attack, which means there is a breakpoint with a power of 3. But such a breakpoint is only one - this is an attack [3: 2]. <br><br>  And then harder - <b>"ragged attacks</b> . <b>"</b> <br>  We will consider only attacks with one empty cell in the middle - no more.  This is explained by the fact that to complete the attack with two empty cells in the middle, you need to spend at least 2 turns - this is clearly not a breakpoint. <br><br>  As we remember, we consider ragged attacks as somewhat normal: one central attack and side attacks.  The central attack belongs to the scanned cell, the secondary divisor has more than 1 - this was written above. <br><br>  Algorithm for finding breakpoint (it can be easier - read below): <br><br><ol><li>  We introduce the <b>score</b> variable </li><li>  We take the central attack, we consider the power </li><li>  Take one of the side, if its divider is not more than 2x. </li><li>  <b>Score</b> - the sum of the powers of the central and side attacks </li><li>  If the potentials of the central and side attacks are equal to 2, then to block such an attack, you need to spend one more move.  Therefore, score increase by 1 </li><li>  If <b>score</b> &gt; = 4, then this is breakpoint <br>  In fact, breakpoint could simply be enumerated, there are not so many of them, but I did not understand this immediately. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Yes, finally we put it all together </h3><br>  So, the main hell behind is described above.  It is time to blind from it something working.  The <b>countWeight (x, y)</b> function takes the cell coordinates as input, and returns its weight.  What does she have under the hood? <br><br>  First, we get an array of all the attacks that the cell belongs to.  ( <b>getAllAttacks (x, y)</b> ).  Going through all the lines, we count the number of breakpoints.  If 2 breakpoint - remember that this situation can decide the outcome of the game, and increase the weight of the cell by 100. <br>  However, all breakpoints should belong to the same player, so I had to implement a check in 2 steps: first crosses, then zeros. <br><br>  Since in the array of attack weights ( <b>ATTACK_WEIGHTS []</b> ) I did not consider attacks with a power of 6 or more, I had to replace them with attacks of power 5. No difference ‚Äî they all lead to the end of the game. <br><br>  Well, we summarize the weights of the attacks - and that was all. <br><br>  Another small point: in order for the bot not to fail at the end of the game, when it has already built an attack with a power of 4 and is thinking about the current move, it is necessary to significantly increase the weight of the cell to complete such an attack.  Without this, the AI, simply simply, can begin to defend against the "dangerous" attacks of the opponent, although the game seemed to be won.  The last move is important. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Now, when calling this function for a specific cell, we will get its weight.  We carry out this operation for all cells and choose the best (with the greatest weight).  Go and go) <br><br>  You can find the rest of the code on <a href="https://github.com/AlexPelmen/tic-tac-bot">github</a> .  There is already enough material, and his presentation, as I did not try, leaves much to be desired.  But if you could read this far, dear reader, then I am grateful to you. <br><br><h3>  My opinion about the result </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will do! Yes, you can beat him, but to make it a little problematic for me personally. Maybe I'm just not attentive enough. Try your strength too. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know that it can be easier, but I do not know how. I would like to listen to people who know or look at other implementations of such a bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know what can be better. Yes ... you can use well-known algorithms, like a minimax, but for this you need to have some knowledge base in the field of game theory, which, unfortunately, I cannot boast. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the future, I plan to add an analysis of breakpoits a few steps ahead, which will make the bot an even more serious rival. However, now I do not have a clear idea about the implementation of this; I only have the upcoming session and the unfinished diploma - which saddens me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks if you read to the end.</font></font></div><p>Source: <a href="https://habr.com/ru/post/430708/">https://habr.com/ru/post/430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430694/index.html">A brief guide to learning C ++: what, when and what to create</a></li>
<li><a href="../430700/index.html">A unified online movie viewing system will start working in Russia</a></li>
<li><a href="../430702/index.html">Very strange training</a></li>
<li><a href="../430704/index.html">How artificial intelligence technologies help Aviasales grow: seven examples</a></li>
<li><a href="../430706/index.html">New theory of evolution</a></li>
<li><a href="../430710/index.html">What to do if Black Friday is tomorrow, and your servers are not ready</a></li>
<li><a href="../430712/index.html">NeurIPS: how to conquer the best ML conference</a></li>
<li><a href="../430714/index.html">VMware buys Heptio - what does this mean for Kubernetes</a></li>
<li><a href="../430718/index.html">What objects should use cloud video surveillance?</a></li>
<li><a href="../430720/index.html">Intel RealSense D435i: a small update and a small historical excursion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>