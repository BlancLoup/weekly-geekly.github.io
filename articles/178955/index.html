<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Non-cryptographic hash functions and DoS attack on them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Non-cryptographic hash functions are used where speed is important and the possibility of attacking the characteristics of a function is not so import...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Non-cryptographic hash functions and DoS attack on them</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Non-cryptographic hash functions are used where speed is important and the possibility of attacking the characteristics of a function is not so important.  Recently, an attack on the algorithmic complexity of hash tables by creating multiple collisions of a hash function that can lead to DoS has been actively discussed.  We will consider modern non-cryptographic hash functions, conditions for their use, possible methods of protection against attacks on hash tables, and why it turned out that this is not so easy to fix. </blockquote><img align="right" title="Avalanche effect hash function One-at-a-Time" src="https://habrastorage.org/storage2/cd4/76a/053/cd476a053b8199071b720e3fe96fb006.png"><br><h4>  Non-cryptographic hash functions </h4><br>  If everyone has a lot of cryptographic hash functions, then little is known about non-cryptographic (general-purpose hash functions).  Non-cryptographic functions are used where data is not affected by third parties (the attacker).  For example, such functions can be used to build hash tables. <br><br>  Criteria that are important for non-cryptographic hash functions: <a name="habracut"></a><br><br><ul><li>  Output values ‚Äã‚Äãshould have a <b>uniform distribution</b> (uniform distribution).  This criterion is important for building hash tables so that the search speed is optimal. </li><li>  Each input bit must, in 50% of cases, affect each output bit (avalanche is an <b>avalanche criterion</b> ).  This criterion is important for using a hash as a unique document identifier.  Also, sometimes the hash can have a uniform distribution, but fail the avalanche criterion - in this case there will be keys for which the hash will not give a uniform distribution. </li><li>  There must be no <b>correlation</b> between the pairs of bits at the output.  This will not be considered, because  usually there is no problem with this criterion. </li><li>  <b>Speed</b>  All of the listed hashes are much faster than cryptographic ones. </li></ul><br><img align="right" title="CRC32 collisions" src="https://habrastorage.org/storage2/6f2/b61/097/6f2b61097809127a75fdc481892e1ba4.png">  Since usually the input value space is larger than the output value space, collisions are inevitable.  In an ideal function, the output values ‚Äã‚Äãhave a uniform distribution, so the probability of collisions is minimal.  This can be checked chi-square test (œá¬≤). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  FNV-1a </h5><br>  2003  Speed: 4.5 cycles per byte. <br>  Very simple function [1] (RFC [5]). <br>  1. Uniform distribution: poor, up to 14 bits can be used for a hash table (up to 2 <sup>14</sup> hash table slots).  Slightly better in the FNV-1a variation, which is recommended by default. <br>  2. Avalanche test: bad.  Also bad in FNV-1a. <br>  Both criteria are significantly improved in modified FNV-1a [2], where at the end mixing is added to FNV-1a. <br><br><h5>  Bob Jenkins' Hash (lookup3) </h5><br>  2006, length 32 and 64 bits, 32-bit instructions, speed: 2.62 cycles per byte (for messages 16 bytes long). <br>  1. Uniform distribution: excellent for all bits. <br>  2. Avalanche test: good.  There is a small problem with the upper bits. <br>  The first version of the function was called One-at-a-Time. <br><br><h5>  CRC32 </h5><br>  1975, length: 32, 64 and 128 bits, speed: 1.2‚Äì0.13 cycles per byte (for messages shorter than 64 bits, depending on the CPU). <br>  1. Uniform distribution: poor distribution of lower bits.  Use the upper bits for the hash table, then all tested bits can be used - up to 16 upper bits (up to 2 <sup>16</sup> hash table slots). <br>  2. Avalanche test: very bad.  Avalanche effect is absent.  The purpose of the hash is affected: its output bits are designed to detect errors in the data transmission channel.  Also, the CRC has an important property: you can split the message into parts, count the hash for each part, then merge the message, and count the hash of the entire message from the hashes of its parts. <br><br><h5>  MurmurHash 2 </h5><br>  2008, length 32 and 64 bits, 32 and 64-bit instructions. <br>  There is a problem with the uniform distribution of some keys [3]. <br><br><h5>  MurmurHash 3 </h5><br>  2011, length 32 and 128 bits, 32 and 64-bit instructions, speed: 1.87 cycles per byte (for messages 16 bytes long). <br>  1. Uniform distribution: good (in one case out of three ‚Äúalmost suspicious‚Äù). <br>  2. Avalanche test: excellent. <br><br><img title="The dependence of the hash rate on the length of the hash key" src="https://habrastorage.org/storage2/b0f/7b2/e47/b0f7b2e47d4aca88c74cbdf881528639.png"><br><br><h5>  CityHash </h5><br>  2011, length 32, 64, 128 and 256 bits, 64-bit instructions.  Rather difficult function. <br>  For the fastest option, you need a CRC32 processor instruction (SSE 4.2 - Intel Nehalem). <br>  1. Uniform distribution: good (in one case out of three ‚Äúalmost suspicious‚Äù). <br>  2. Avalanche test: good.  There is a small problem with the lower bits. <br><br><h5>  Spookyhash </h5><br>  2011, length 32, 64 and 128 bits, speed: 0.33 cycles per byte.  By Bob Jenkins <br>  1. Uniform distribution: average (in one case out of three ‚Äúsuspicious‚Äù). <br>  2. Avalanche test: excellent. <br><br>  Statistical analysis of hash functions can be done using the tools [17], using the results of the analysis [2], [4], [18]. <br><br>  CityHash is more complex and has more bandwidth (speed on long messages) than MurmurHash.  MurmurHash is simpler, has a low latency for short messages (&lt;20 bytes). <br><br>  CityHash uses CRC instructions for new processors, providing up to 0.17 cycles per byte, which is faster than all other hashes;  for comparison, SHA-1 - 4.6 cycles per byte (Ivy Bridge).  Without the support of these instructions, CityHash is two times slower than SpookyHash (according to the author of the latter). <br><br>  For the 32-bit platform, MurmurHash 3 can be faster than SpookyHash and CityHash. <br><br><h5>  Perfect hash function </h5><br>  If the array of messages is known in advance, then an ideal hash function can be used: no collisions and a search in one comparison operation.  Example: gperf. <br><br>  If the hash function has a normal distribution, then the probability of a collision is as follows: <br><br><ul><li>  for 32 bits: with a probability of 1 in 10 000 there will be a collision among 927 hashes, with a probability of 1 in 100 there will be a collision among 9 292 hashes, </li><li>  for 64 bits: with a probability of 1 in 10 000 there will be a collision among 60.7 million hashes, with a probability of 1 in 100 there will be a collision among 609 million hashes. </li></ul><br><img title="Dependence of collision probability on the number of messages" src="https://habrastorage.org/storage2/d34/f49/d12/d34f49d124ad9597505b113951a03496.png"><br><br>  How real are the collisions?  For 32-bit hashes, they are met regularly.  For example, CRC32 coincides with ‚Äúcodding‚Äù and ‚Äúgnu‚Äù, ‚Äúexhibitors‚Äù and ‚Äúschlager‚Äù, ‚Äúcurl‚Äù and ‚Äúnatural‚Äù, etc.  This is not the fault of the statistical features of the hash function, but a consequence of the limited size of the hash - only 4 bytes. <br><br>  All listed functions, except for CRC32 and FNV-1, have good statistics.  For a 32-bit system, MurmurHash may be the fastest.  If the system cannot do unaligned memory read, for example, ARM or SPARC, then MurmurHash may also work faster than anyone.  CityHash speed is highly dependent on the compiler, since a lot of complex code is used, it can be either more or less than the rest. <br><br><h5>  Recommendations </h5><br>  You can use MurmurHash 3, CityHash, SpookyHash V2, gperf as a general-purpose hash function. <br><br><img align="left" title="Normal Hash Table" src="https://habrastorage.org/storage2/4f2/bc3/aa8/4f2bc3aa8580030bb465c5bedf2593ff.png"><h4>  DoS attack hash table </h4><br>  You can imagine a DoS attack, when an attacker feeds data into a hash table so that they all fall into one slot, and you get the worst speed for finding one element - O (n), inserting each new collision - O (n¬≤), the memory size increases ( hash-flooding).  To launch an attack, you need to be able to place arbitrary data in a hash table, and find hash function collisions. <br><img align="left" title="Hash table with collisions" src="https://habrastorage.org/storage2/e95/07f/7da/e9507f7da981ae5bdfc7c15de8190295.png">  The attack is also called hash DoS or, more generally, an attack on algorithmic complexity attack. <br><br>  Collisions can be created in several ways: <br><br><ul><li>  if the hash function is known in advance and the hash length is small, then use the search method: compute and search in memory meet-in-the-middle. <br></li><li>  if the hash function is not resistant to collisions, then the collisions can be calculated mathematically.  Non-cryptographic functions are fairly simple, and it is often enough to search for collisions in the reverse order ([6], oCERT [7]). <br></li></ul><br>  We list the <b>properties of cryptographic hash functions</b> (not applicable to general-purpose hash functions): <br><br><ul><li>  resistance to restoration of the <b>pre-image</b> (given <i>m</i> , it is impossible to find <i>X</i> so that H ( <i>X</i> ) = <i>m</i> ), <br></li><li>  resistance to the restoration of the <b>second pre-image</b> (given <i>m <sub>1</sub></i> , it is impossible to find <i>m <sub>2</sub></i> so that H ( <i>m <sub>1</sub></i> ) = H ( <i>m <sub>2</sub></i> )), <br></li><li>  resistance to the search for <b>collisions</b> (it is impossible to find <i>m <sub>1</sub></i> and <i>m <sub>2</sub></i> so that H ( <i>m <sub>1</sub></i> ) = H ( <i>m <sub>2</sub></i> )). <br></li></ul><br>  Sometimes the last two criteria are called resistance to collisions of the first and second kind, respectively.  We will call the collision only the case when neither the message nor the hash was originally specified. <br><br>  Usually the ‚Äúeasiest‚Äù attack is the search for collisions.  Due to the ‚Äúbirthdays‚Äù paradox, the complexity of this attack is at least two times less than the length of the hash.  This attack exists for SHA-1: with a theoretical collision complexity O (2 <sup>80</sup> ), the attack reduces the difficulty to O (2 <sup>61</sup> ).  There is no recovery attack of the first or second preimage for SHA-1. <br><br>  To increase collision resistance, you can: <br><br><ul><li>  use a cryptographic hash function to compute a hash of sufficient length.  It will be resistant to collisions, but if collisions are once calculated, they can be used to attack any system. <br></li><li>  use HMAC (MAC based cryptographic hash function). <br></li><li>  use MAC based on PRF or universal one-way hash function. <br></li></ul><br>  <b>A MAC</b> based on a cryptographic function has the following properties: <br><br><ul><li>  you cannot find the key, having the ability to get a hash for any message, <br></li><li>  You can not find the correct hash for the message without knowing the key. <br></li><li>  Greater resistance to collisions, since the family of hash functions is not known in advance to the attacker. <br></li></ul><br>  If we decide to use a cryptographic hash function (for example, SHA-3) or a MAC based on it, we will encounter the following disadvantages: <br><br><ul><li>  too slow for hash tables: the algorithm is designed for long messages, and it works slowly for short messages, <br></li><li>  although the full length of the hash is collision-resistant, but if we take only the first <i>n</i> bits, it will simplify the search for collisions, <br></li><li>  in the case of HMAC, cryptographic hash functions are used that do extra work to ensure collision resistance, although this is not necessary because the secret key is used. <br></li></ul><br>  <b>A universal hash function</b> besides a message also receives a key, using which selects a hash function from a finite family of functions.  With a key known to the attacker, the function must be resistant to the restoration of the second prototype, but there is no requirement for collision resistance.  If the key is unknown to the attacker, then the function will be resistant to collisions.  Considering our speed requirements, it is advisable to do without cryptographic functions. <br><br>  To complicate the search for collisions, they sometimes try to build a MAC based on general-purpose hash functions, using seed as the key.  But the resulting ‚ÄúMAC‚Äù will not have the required properties, since it is not built on the basis of a cryptographic function.  The following attacks are possible: <br><br><ul><li>  create collisions without knowledge of the seed, using mathematical analysis of the hash function, <br></li><li>  to figure out the seed, having access to the result of the hash function (for example, the program gives the data, ordered by hash by default, this provides data leakage about the hash value), <br></li><li>  get data via timing attack. <br></li></ul><br>  Therefore, although this approach may make life more difficult for the casual attacker, it often does not withstand the simplest cryptanalysis (oCERT [8]).  It has been shown that most general-purpose hash functions are not resistant to cryptographic attacks: <br><br><ul><li>  xxHash is not resistant to restoring the second prototype even without knowing the key, knowing the hash [12]. <br></li><li>  MurmurHash 2, MurmurHash 3, CityHash 1.0.3 not resistant to collisions without knowing the key and hash: a way was found to quickly find collisions that do not depend on the choice of the seed (‚Äúuniversal‚Äù multicollisions) [13]. <br></li><li>  Python hash is not resistant to key recovery, knowing the result of the hash function, after which you can attack against the 64-bit state using meet-in-the-middle [13]. <br></li><li>  Python hash is not resistant to collisions without knowing the key and hash [14]. <br></li></ul><br>  Until 2008-2010, most languages ‚Äã‚Äãand frameworks used fairly simple hash functions: <br><br><ul><li>  PHP 4, ASP.NET and JavaScript: DJBX33X, <br></li><li>  PHP 5, Ruby 1.8 and Java: DJBX33A, <br></li><li>  Rust: DJB (till 2012), <br></li><li>  Python: modified FNV, <br></li><li>  JRuby: MurmurHash2, <br></li><li>  Haskell: FNV-1, <br></li><li>  Redis: djbhash, later MurmurHash 2. <br></li></ul><br>  Exception: Perl 4, used One-at-a-Time with a random seed since 2003 (this year they discussed this attack at the conference), later (5.17.6) used MurmurHash 3. <br><br>  To reduce the number of collisions and complicate the DoS attack, many languages ‚Äã‚Äãover the last year switched to modern hash functions with a random seed.  And when it turned out that this does not solve the problem with the attack, many have changed the hash and the second time. <br><br>  An example of a <b>collision-resistant MAC</b> : <br><br><ul><li>  VMAC, UMAC, Poly1305-AES - use AES-128, optimal for long messages. <br></li><li>  SipHash - is a PRF, does not use cryptographic algorithms, is optimal for short messages. <br></li><li>  ‚ÄúStrongly universal string hashing is fast‚Äù [10]. <br></li></ul><br><h5>  Siphash </h5><br>  2012, length 64 bits, key 128 bits. <br>  Speed: 15.50 cycles per byte for 8 bytes of a message, 3.66 cycles per byte for 64 bytes of a message, up to 1.96 cycles per byte for long messages.  For comparison, the fastest finalist SHA-3 BLAKE-512: 134 cycles per byte for 8 bytes, 20 cycles per byte for 64 bytes. <br>  You can use any number of compression and finalization rounds.  For example, SipHash-2-4 - 2 and 4 rounds, respectively. <br><br>  It was developed as a collision-resistant hash function based on a cryptographic pseudo-random function (PRF), fast for short messages.  Since it is intended to be used with a random key, there is no requirement for collision resistance.  It differs from non-cryptographic hash functions in that it works correctly and safely with the key, providing both the MAC properties and the properties of the universal hash function. <br><br><img title="The dependence of the spent cycles on the length of the message" src="https://habrastorage.org/storage2/734/ccf/5a4/734ccf5a406111c04184bced07a1d5a3.png"><br><br>  The situation by language currently looks like this: <br><br><ul><li>  Rust: SipHash 2-4, <br></li><li>  Rails: SipHash 2-4, <br></li><li>  Perl (5.8.1): SipHash 2-4 (64 bits) and One-at-a-time (32 bits), <br></li><li>  Ruby (1.9.3-p327), JRuby: SipHash 2-4, <br></li><li>  Python (2.7.3, 3.2.3): own hash function, with the inclusion of -R a random seed is added [11], <br></li><li>  Haskell (1.2): SipHash (for strings), <br></li><li>  Go: aeshash (supported by AES-NI) or a simple eigenfunction (variation FNV-1), <br></li><li>  PHP (5): DJBX33A, there is a limit on the number of GET / POST elements (max_input_vars), <br></li><li>  Java SE (7u6 and 8): when jdk.map.althashing.threshold is turned on, MurmurHash is used with a random seed (alternative string hashing), <br></li><li>  Scala: Byteswap32 and MurmurHash 3 or hash from Java, <br></li><li>  .NET (4.5): when enabled, UseRandomizedStringHashAlgorithm uses its own development Marvin32 [9]. <br></li></ul><br>  Open tasks: <br><br><ul><li>  Java: there is no response to MurmurHash cryptanalysis [16], <br></li><li>  Python: recognized that the key "-R" is useless, and ponder how best to fix the attack on the hash table [14] <br></li><li>  Go: implemented aeshash, but there is no cryptanalysis yet [15]. <br></li></ul><br><h5>  Other methods of protection </h5><br>  It is believed that the fight against this attack is not the task that the hash function should perform.  You can instead: <br><br><ul><li>  use data structures with less complexity at worst.  For example, a balanced tree - AVL-tree or red-black tree - guarantees in any case O (log <i>n</i> ).  Here it is important to take into account new attacks, for example, cascade rebalance of a tree with specially formed data, but even in this case we will get a better result - O ( <i>n</i> log <i>n</i> ), <br></li><li>  limit the number of processed items (for example, POST / GET), <br></li><li>  raise an exception if the number of collisions is greater than the limit (or just discard data, if possible), <br></li><li>  raise an exception if the CPU is busy above the normal for search operations (timeout). <br></li></ul><br><h5>  Recommendations </h5><br>  For data structures that use untrusted data, apply algorithms with complexity O (log <i>n</i> ), for example, a balanced tree.  If it is not possible, then use a hash function randomly selected from the family of functions (MAC), for example, VMAC or SipHash. <br><br><div class="spoiler">  <b class="spoiler_title">Sources</b> <div class="spoiler_text">  [1] <a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">www.isthe.com/chongo/tech/comp/fnv/index.html</a> <br>  [2] <a href="http://home.comcast.net/~bretm/hash/">Pluto Scarab - Hash Functions</a> <br>  [3] <a href="http://code.google.com/p/smhasher/wiki/MurmurHash2Flaw">code.google.com/p/smhasher/wiki/MurmurHash2Flaw</a> <br>  [4] "Choosing a Good Hash Function, Part 3 - AK Tech Blog" - <a href="http://blog.aggregateknowledge.com/2012/02/02/choosing-a-good-hash-function-part-3/">blog.aggregateknowledge.com/2012/02/02/choosing-a-good-hash-function-part-3</a> <br>  [5] <a href="http://tools.ietf.org/html/draft-eastlake-fnv-05">tools.ietf.org/html/draft-eastlake-fnv-05</a> <br>  [6] <a href="http://www.ocert.org/advisories/ocert-2011-003.html">www.ocert.org/advisories/ocert-2011-003.html</a> <br>  [7] <a href="http://www.nruns.com/_downloads/advisory28122011.pdf">www.nruns.com/_downloads/advisory28122011.pdf</a> <br>  [8] <a href="http://www.ocert.org/advisories/ocert-2012-001.html">www.ocert.org/advisories/ocert-2012-001.html</a> <br>  [9] <a href="">github.com/floodyberry/Marvin32/blob/master/Marvin32.c</a> <br>  [10] "Strongly universal string hashing is fast" - <a href="">arxiv.org/abs/1202.4961</a> <br>  [11] ‚ÄúIssue 13703: Hash collision security issue‚Äù - <a href="http://bugs.python.org/issue13703">bugs.python.org/issue13703</a> <br>  [12] <a href="http://crypto.stackexchange.com/questions/6408/from-hash-to-cryptographic-hash">crypto.stackexchange.com/questions/6408/from-hash-to-cryptographic-hash</a> <br>  [13] <a href="https://131002.net/siphash/">131002.net/siphash/#at</a> <br>  [14] "Issue 14621: Hash function is not randomized properly" - <a href="http://bugs.python.org/issue14621">bugs.python.org/issue14621</a> <br>  [15] "Issue 4604 - go - runtime: switch to fast, collision-resistant hash function" - <a href="http://code.google.com/p/go/issues/detail%3Fid%3D4604">code.google.com/p/go/issues/detail?id=4604</a> <br>  [16] ‚ÄúBug 880705 - CVE-2012-5373 java: Murmur hash function collisions (oCERT-2012-001)‚Äù - <a href="https://bugzilla.redhat.com/show_bug.cgi%3Fid%3D880705">bugzilla.redhat.com/show_bug.cgi?id=880705</a> <br>  [17] <a href="http://code.google.com/p/smhasher/wiki/SMHasher">code.google.com/p/smhasher/wiki/SMHasher</a> <br>  [18] <a href="http://floodyberry.com/noncryptohashzoo/">floodyberry.com/noncryptohashzoo</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/178955/">https://habr.com/ru/post/178955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178943/index.html">Adobe has announced its own devices: "cloud" stylus and "electronic line"</a></li>
<li><a href="../178945/index.html">Drone adapted to bring beer - video</a></li>
<li><a href="../178949/index.html">How to change Citrix Web interface</a></li>
<li><a href="../178951/index.html">Honest lot</a></li>
<li><a href="../178953/index.html">Sphinx meeting (Moscow, May 8)</a></li>
<li><a href="../178959/index.html">Time travel and programming 2: paradoxes</a></li>
<li><a href="../178961/index.html">About the past in the present tense</a></li>
<li><a href="../178969/index.html">How we made a DVD-RW drive laser</a></li>
<li><a href="../178971/index.html">Adobe finally moves to the cloud and closes the development of Fireworks.</a></li>
<li><a href="../178973/index.html">ISO 15926 vs Semantics: a comparative analysis of semantic models</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>