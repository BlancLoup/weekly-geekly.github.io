<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do postgreSQL security_barrier views work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You may have noticed that support for security_barrier views has been added to PostgreSQL 9.2. I looked into this code with an eye on adding support f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How do postgreSQL security_barrier views work</h1><div class="post__text post__text-html js-mediator-article">  You may have noticed that support for security_barrier views has been added to PostgreSQL 9.2.  I looked into this code with an eye on adding support for automatic updates for them, as part of the developing line level security work for <a href="http://axleproject.eu/">the AXLE project</a> , and I thought that I would try to explain how they work. <br><br>  Robert has already <a href="http://rhaas.blogspot.com.au/2012/03/security-barrier-views.html">explained</a> what the benefits of such views are and what they protect against (besides, this was discussed in " <a href="">What's new in PostgreSQL 9.2</a> ").  Now I would like to go into <i>how</i> they work and discuss how security_barrier views interact with automatically updated views. <br><a name="habracut"></a><br><h4>  <b>Ordinary views</b> </h4><br>  A simple, regular representation is expanded in macro as a subquery, which is usually later optimized by putting out its predicate and adding it to the conditions of the contained query.  This can be made clearer with an example.  Given table: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> n, <span class="hljs-string"><span class="hljs-string">'secret'</span></span>||n <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> secret <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>) n;</code> </pre> <br>  and presentation: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> n, secret <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  query type: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  will be converted inside the request handler to the following form: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  which the optimizer will then turn into a query executed at once, putting the subquery and the WHERE conditions into an external query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (n % <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  You cannot see instant requests directly and they never exist as real SQL, but you can see this process by including <i>debug_print_parse = on</i> , <i>debug_print_rewritten = on</i> and <i>debug_print_plan = on</i> in postgresql.conf.  I will not reproduce the parsing and planning trees here, as they are rather cumbersome and easy to generate, based on the examples above. <br><br><h4>  <b>The problem with using views for security</b> </h4><br>  You might think that giving someone access to the view, without giving access to the table itself, would not allow them to see the even rows.  Actually it looks like the truth: <br><br><pre> <code class="sql hljs">regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; n | secret <span class="hljs-comment"><span class="hljs-comment">---+--------- 1 | secret1 3 | secret3 (2 rows)</span></span></code> </pre><br>  but when you look at the plan, you can see a potential problem: <br><br><pre> <code class="sql hljs">regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------- Seq Scan on t (cost=0.00..31.53 rows=2 width=36) Filter: ((n &lt; 4) AND ((n % 2) = 1)) (2 rows)</span></span></code> </pre><br>  The subquery of the view was optimized and its determinants were made to the external query. <br><br>  In SQL, AND and OR are not ordered.  The optimizer / executor has complete freedom in choosing which branch to launch, which they consider to be faster in terms of issuing an answer and possibly allowing them to avoid launching other branches.  Those.  if the scheduler thinks <b><i>n &lt;4 is</i></b> much faster than <b><i>n% 2</i></b> , it will start it first.  It looks harmless, right?  Try: <br><br><pre> <code class="sql hljs">regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> f_leak(<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RAISE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span> <span class="hljs-string"><span class="hljs-string">'Secret is: %'</span></span>,$<span class="hljs-number"><span class="hljs-number">1</span></span>; RETURN true; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ COST 1 LANGUAGE plpgsql; regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> f_leak(secret) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; NOTICE: Secret is: secret1 NOTICE: Secret is: secret2 NOTICE: Secret is: secret3 NOTICE: Secret is: secret4 NOTICE: Secret is: secret5 NOTICE: Secret is: secret6 NOTICE: Secret is: secret7 NOTICE: Secret is: secret8 NOTICE: Secret is: secret9 NOTICE: Secret is: secret10 NOTICE: Secret is: secret11 NOTICE: Secret is: secret12 NOTICE: Secret is: secret13 NOTICE: Secret is: secret14 NOTICE: Secret is: secret15 NOTICE: Secret is: secret16 NOTICE: Secret is: secret17 NOTICE: Secret is: secret18 NOTICE: Secret is: secret19 NOTICE: Secret is: secret20 n | secret <span class="hljs-comment"><span class="hljs-comment">---+--------- 1 | secret1 3 | secret3 (2 rows) regress=&gt; EXPLAIN SELECT * FROM t_odd WHERE f_leak(secret) AND n &lt; 4; QUERY PLAN ---------------------------------------------------------- Seq Scan on t (cost=0.00..34.60 rows=1 width=36) Filter: (f_leak(secret) AND (n &lt; 4) AND ((n % 2) = 1)) (2 rows)</span></span></code> </pre><br>  Oops!  As you can see, the function with the predicate put by the user was considered cheaper to run than other tests, so it skipped all the lines before the presentation predicate ruled out the wrong ones.  A malicious function can use the same trick to copy strings. <br><br><h4>  <b>Views security_barrier</b> </h4><br>  The security_barrier views fix this by forcing the view conditions to be executed first, before any conditions created by the user are applied.  Instead of extending the view and putting any conditions of the view into an external query, they replace the reference to the view with a subquery.  This subquery has a security_barrier flag affixed to the entire range of its entry in the table, which tells the optimizer that it should not touch the subquery, or take conditions out of it, as it would have done in the usual case. <br><br>  Thus, the presentation with a protective barrier: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> t_odd_sb <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (security_barrier) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> n, secret <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  we'll get: <br><br><pre> <code class="sql hljs">regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t_odd_sb <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> f_leak(secret) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; NOTICE: Secret is: secret1 NOTICE: Secret is: secret3 n | secret <span class="hljs-comment"><span class="hljs-comment">---+--------- 1 | secret1 3 | secret3 (2 rows) regress=&gt; EXPLAIN SELECT * FROM t_odd_sb WHERE f_leak(secret) AND n &lt; 4; QUERY PLAN --------------------------------------------------------------- Subquery Scan on t_odd_sb (cost=0.00..31.55 rows=1 width=36) Filter: f_leak(t_odd_sb.secret) -&gt; Seq Scan on t (cost=0.00..31.53 rows=2 width=36) Filter: ((n &lt; 4) AND ((n % 2) = 1)) (4 rows)</span></span></code> </pre><br>  The query execution plan should tell you what is going on, although it does not show the protective barrier attribute in the explanation output.  A nested subquery forces <i><b>t</b></i> to scan with the conditions of the subquery representation, after which the conditions of the function written by the user are satisfied on the received data. <br><br>  But.  Wait a second.  Why does the user predicate <i><b>n &lt;4</b></i> also appear in the subquery?  Isn't that a potential security hole?  If <i><b>n &lt;4 is</b></i> omitted, then why not <i><b>f_leak (secret)</b></i> ? <br><br><h4>  <b>LEAKPROOF operators and functions</b> </h4><br>  The explanation for this is that the <i><b>&lt;</b></i> operator is labeled <i><b>LEAKPROOF</b></i> .  This attribute signals that the given operator or function will not allow information leakage; therefore, it can be safely applied to <i><b>security_barrier</b></i> views.  For obvious reasons, you cannot set the <i><b>LEAKPROOF</b></i> attribute as a regular user: <br><br><pre> <code class="sql hljs">regress=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> f_leak(<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) LEAKPROOF; ERROR: only superuser can define a leakproof function</code> </pre><br>  Superuser can do whatever they want and they do not need to resort to tricks with information leakage functions in order to pass the protective barrier of ideas. <br><br><h4>  <b>Why can't you update the view security_barrier</b> </h4><br>  Normal views in PostgreSQL 9.3 are <a href="http://www.postgresql.org/docs/current/static/sql-createview.html">automatically updated</a> , but security_barrier views do not imply ‚Äúsimplicity‚Äù.  This is due to the fact that the update of the view relies on the ability to remove the view subquery, turning the update into a regular table update.  The whole point of security_barrier views is to prevent this view condition exception.  UPDATE cannot currently work directly with a subquery, so PostgreSQL will reject any attempts to update the security_barrier view: <br><br><pre> <code class="sql hljs">regress = &gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t_odd <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> secret = <span class="hljs-string"><span class="hljs-string">'secret_haha'</span></span> || n; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> regress = &gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t_odd_sb <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> secret = <span class="hljs-string"><span class="hljs-string">'secret_haha'</span></span> || n; ERROR: cannot <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> <span class="hljs-string"><span class="hljs-string">"t_odd_sb"</span></span> DETAIL: <span class="hljs-keyword"><span class="hljs-keyword">SECURITY</span></span> - barrier views <span class="hljs-keyword"><span class="hljs-keyword">ARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> automatically updatable. HINT: <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENABLE</span></span> updating the <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span>, provide an INSTEAD <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> an unconditional <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> INSTEAD RULE.</code> </pre><br>  This is exactly the same restriction that I am interested in canceling as part of the work on the development of row level security for <a href="http://axleproject.eu/">the AXLE project</a> .  Kohei KaiGai has done a tremendous amount of work with row-level security, and such things as security_barrier and LEAKPROOF have largely sprung from his work in the direction of adding row-level security in PostgreSQL.  The next challenge is how to deal with updating the security barrier safely and in such a way that it can be serviced in the future. <br><br><h4>  <b>Why subqueries?</b> </h4><br>  You may wonder why we use subqueries for this.  I was thinking.  The short version is we don‚Äôt have to, but if we don‚Äôt use subqueries, we‚Äôll instead have to create new, sorting sensitive AND and OR operators and teach the optimizer that it cannot pass conditions through them.  Since views are already expanded by subqueries, it is much easier to mark subqueries as fences that do not allow to extract / add data to them. <br><br>  PostgreSQL already has a simplified, ordered operation - <b><i>CASE</i></b> .  The problem with using <b><i>CASE</i></b> is that no operation can cross <b><i>CASE</i></b> boundaries, even <b><i>LEAKPROOF</i></b> .  As well as the optimizer and can not make decisions about the use of indices?  based on expressions inside a CASE block.  So, if we used CASE as I asked about this here, we would never have been able to use the index to satisfy the user-provided condition. <br><br><h4>  <b>In code</b> </h4><br>  Security_barrier support was added at <a href="https://github.com/postgres/postgres/commit/0e4611c0234d89e288a53351f775c59522baed7c">0e4611c0234d89e288a53351f775c59522baed7c</a> and enhanced with LEAKPROOF support in <a href="https://github.com/postgres/postgres/commit/cd30728fb2ed7c367d545fc14ab850b5fa2a4850">cd30728fb2ed7c367d545fc14ab850b5fa2a4850</a> .  Words of thanks go to commit notes.  Thanks to everyone who participated. <br><br>  <b>Ps.</b>  The article is relatively old, but important as an introduction to the translation of the next article. </div><p>Source: <a href="https://habr.com/ru/post/273167/">https://habr.com/ru/post/273167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273157/index.html">Creative Commons licenses have published over 1 billion papers.</a></li>
<li><a href="../273159/index.html">Non-local image smoothing algorithm</a></li>
<li><a href="../273161/index.html">Xamarin and Xamarin.Forms - cactus in chocolate. Part 2</a></li>
<li><a href="../273163/index.html">Conference for developers Top & Featured in Moscow on December 17</a></li>
<li><a href="../273165/index.html">Winter internship for developers at Redmadrobot</a></li>
<li><a href="../273169/index.html">Pebble: Timeline - Inside View</a></li>
<li><a href="../273171/index.html">Results of 2015: web development</a></li>
<li><a href="../273173/index.html">Server "second-hand" as an anti-crisis solution</a></li>
<li><a href="../273175/index.html">Usability of trading terminals: UX-trends of mobile and desktop applications for trading on the stock exchange</a></li>
<li><a href="../273177/index.html">How to work with timestamps in PostgreSQL?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>