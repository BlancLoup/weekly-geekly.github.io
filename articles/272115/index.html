<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell "terrible" abstractions without mathematics and without code (almost). Part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- What are monads for? 
 - To separate clean calculations from side effects. 
 (from online discussions about Haskell) 
 Sherlock Holmes and Dr. Watso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell "terrible" abstractions without mathematics and without code (almost). Part I</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  - What are monads for? <br>  - To separate clean calculations from side effects. <br>  <i>(from online discussions about Haskell)</i> </blockquote><br><blockquote>  Sherlock Holmes and Dr. Watson are flying in a balloon.  Fall into thick fog and lose orientation.  There is a small gap - and they see a person on earth. <br>  - Dear, would you tell me where we are? <br>  - In the balloon basket, sir. <br>  Then they are carried further and again they see nothing. <br>  ‚ÄúIt was a mathematician,‚Äù says Holmes. <br>  - But why? <br>  - His answer is completely accurate, but absolutely useless. <br>  <i>(joke)</i> </blockquote><br><a name="numbers"></a>  When the ancient Egyptians wanted to write that they counted 5 fish, they drew 5 fish figures.  When they wanted to write that they counted 70 people, they painted 70 figures of people.  When they wanted to write that they counted 300 sheep in a herd, they ... - well, in general, you understood.  So the ancient Egyptians suffered, until the cleverest and lazy of them saw something in common in all these records, and separated the concept of the <b>quantity</b> of what we count from the <b>properties</b> of what we count.  And then another smart lazy Egyptian replaced a lot of sticks, which people used to designate a quantity, with a significantly smaller number of signs, a short combination of which could replace a huge amount of sticks. <br><br>  What these clever lazy Egyptians have done is called abstraction.  They noticed something in common, which is characteristic of all records about the amount of something, and separated this general from the particular properties of the counted objects.  If you understand the meaning of this abstraction, which we call numbers today, and how much it has made life easier for people, then it will not be difficult for you to understand the Haskell abstractions - all these seemingly incomprehensible functors, monoids, applicative functors and monads.  Despite their frightening names, which came to us from the mathematical theory of categories, it is no more difficult to understand them than the abstraction called ‚Äúnumbers‚Äù.  To understand them, it is absolutely not necessary to know either the theory of categories, or even mathematics in the volume of high school (arithmetic is quite enough).  And they can also be explained without resorting to frightening many mathematical concepts.  And the meaning of Haskell language abstractions is exactly the same as that of numbers - they make life much easier for programmers (and you can‚Äôt even imagine how much!). <br><a name="habracut"></a><br>  <a href="https://habr.com/ru/post/272115/">Differences of functional and imperative programs</a> <br>  <a href="https://habr.com/ru/post/272115/">Discover the benefits of pure features.</a> <br>  <a href="https://habr.com/ru/post/272115/">Calculations and ‚Äúsomething else‚Äù</a> <br>  <a href="https://habr.com/ru/post/272115/">Something else encapsulation</a> <br>  <a href="https://habr.com/ru/post/272115/">The functor is not easy, but very simple!</a> <br>  <a href="https://habr.com/ru/post/272115/">Applicative functors are also very simple!</a> <br>  <a href="https://habr.com/ru/post/272115/">You will laugh, but monads are also simple!</a> <br>  <a href="https://habr.com/ru/post/272115/">And let's define a couple more monads</a> <br>  We use monads <br>  We define the Writer monad and get acquainted with monoids. <br>  Monoids and laws of functors, applicative functors and monads <br>  Classes of types: dozens of functions for free! <br>  Input-output: IO monad <br><br>  In order to understand (and accept) abstractions, people usually need to look at them from several sides: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  First, they need to understand that the introduction of an additional level of complexity in the form of the proposed abstraction eliminates a much greater level of complexity with which they constantly encounter.  Therefore, I will describe the huge number of problems that programmers will no longer face using pure functions (do not worry, I will explain below what it is) and the described abstractions. </blockquote><br><blockquote>  Secondly, people need to understand how the proposed abstraction was implemented, and how this implementation allows it to be used not in a particular case, but in a huge variety of different situations.  Therefore, I will describe to you the logic behind the implementation of Haskell language abstractions, and show that they are not only applicable, but also provide significant advantages in an incredible number of situations. </blockquote><br><blockquote>  And, thirdly, people need to understand not only how abstractions are implemented, but how to apply them in their daily lives.  Therefore, I will describe in the article and this.  Moreover, it is not easy, but very simple - even easier than to understand how these abstractions are implemented (and you yourself will see that it is quite easy to understand the implementation of the described abstractions). </blockquote><br>  However, the introduction was somewhat delayed, so, perhaps, let's start.  I‚Äôll just add that there‚Äôs very little code in the article, so you don‚Äôt have to be familiar with the Haskell syntax to understand and appreciate the beauty and power of its abstractions. <br><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text">  I am not an experienced Haskell programmer.  I really like this language, and at the moment I am still in the process of learning it (this is not the fastest process, because it requires not only mastery of knowledge, but also a restructuring of thinking).  Recently, I have several times had to talk about functional programming and about Haskell programmers who are familiar only with imperative programming languages.  In the process, I realized that I should work on a clearer and more structured explanation of the basic abstractions of Haskell, which usually cause awe of those who are not familiar with them.  This material is just an attempt at such structuring.  I will be glad if you, the readers, point out to me both the possible inaccuracies of my presentation, and those moments that you did not understand well enough. </div></div><br><a name="functional_vs_imperative"></a><h3>  <font color="#cc0000">Differences of functional and imperative programs</font> </h3><br>  If you look at programs written in functional and imperative languages, from a bird's-eye view, they are no different.  And those and other programs are some kind of black box, which takes the original data and outputs other data converted from the original.  The differences we will see when we want to look inside the black boxes, to understand exactly how the data conversion takes place in them. <br><br>  Looking into the imperative black box, we see that the data included in it is assigned to variables, and then these variables are repeatedly sequentially changed, until we get the data we need, which we issue from the black box. <br><br>  In a functional black box, this transformation of incoming data into outgoing data occurs by applying to them a certain formula in which the final result is expressed in terms of dependence on the incoming data.  Remember from the school curriculum, what determines the average speed of movement?  That's right: from the distance traveled and the time for which it is covered.  Knowing the original data (path <i>S</i> and time <i>t</i> ), as well as the formula for calculating the average speed ( <i>S / t</i> ), we can calculate the final result - the average motion speed.  By the same principle of dependence of the final result on the initial data, the final result of the program written in the functional style is also calculated.  At the same time, in contrast to imperative programming, in the process of computing we do not have any change in the variables, either local or global. <br><br>  In fact, in the previous paragraph, it would be more correct to use the word <i>function</i> instead of the word <i>formula</i> .  I did not do this due to the fact that the word <i>function</i> in imperative programming languages ‚Äã‚Äãis most often called not at all what is meant by this term in mathematics, physics, and functional programming languages.  In imperative languages, a function is often referred to as what is more correctly called a <i>procedure</i> ‚Äî that is, a named part of a program (subroutine), which is used to avoid repeating repeated pieces of code.  A little later you will understand how functions in functional programming languages ‚Äã‚Äã(so-called <i>pure functions</i> , or <i>pure functions</i> ) differ from what is called functions in imperative programming languages. <br><br>  <i>Note: The division of programming languages ‚Äã‚Äãinto imperative and functional is rather arbitrary.</i>  <i>You can program in a functional style in languages ‚Äã‚Äãthat are considered imperative, and in an imperative style in languages ‚Äã‚Äãthat are considered functional ( <a href="http://augustss.blogspot.ru/2007/08/programming-in-c-ummm-haskell-heres.html">here is an example of a factorial calculating program, in an imperative style in Haskell and comparing it with the same C program</a> ) - it will just be inconvenient .</i>  <i>Therefore, let us consider imperative languages ‚Äã‚Äãas those that encourage programming in an imperative style, and functional languages ‚Äã‚Äãas those that encourage programming in a functional style.</i> <br><br><a name="pure_functions"></a><h3>  <font color="#cc0000">Discover the benefits of pure features.</font> </h3><br>  Most of the time, a Haskell programmer has to deal with the so-called <i>pure functions</i> (everything, of course, depends on the programmer, but we are talking about how it should be).  In fact, these functions are called ‚Äúpure‚Äù in order not to be confused with what they mean by the term ‚Äúfunction‚Äù in imperative programming.  In fact, these are the most common functions in the mathematical understanding of this term.  Here is the simplest example of such a function that adds three numbers: <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addThreeNumbers</span></span> xyz = x + y + z</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Explanation for those not familiar with Haskell syntax</b> <div class="spoiler_text">  In the part of the function that is to the left of the <b>=</b> sign, the name of the function always comes first, and then, separated by spaces, the arguments of this function.  In this case, the function name is <b>addThreeNumbers</b> , and <b>x</b> , <b>y,</b> and <b>z</b> are its arguments. <br><br>  The right of the <b>=</b> sign indicates how the result of the function is calculated in terms of its arguments. </div></div><br>  Notice the <b>=</b> ( <i>equals</i> ) sign.  Unlike imperative programming, it does not mean an assignment operation.  The <i>equal</i> sign means that what is to the left of it is <b><i>the same as the</i></b> expression to the right of it.  Just like in mathematics: <i>6 + 4</i> is <i>the same as</i> <i>10</i> , so we write <i>6 + 4 = 10</i> .  In any calculation, we can substitute the expression <i>(6 + 4)</i> instead of the ten, and we get the same result as if we had substituted the ten.  The same is true in Haskell: instead of <code>addThreeNumbers xyz</code> we can substitute the expression <code>x + y + z</code> , and we get the same result.  The compiler, by the way, does just that - when it encounters a function name, it substitutes an expression defined in its body instead. <br><br>  What is the "purity" of this function? <br><br><blockquote>  The result of a function depends only on its arguments.  No matter how many times we call this function with the same arguments, it will always return the same result to us, because the function does not refer to any external state.  She is completely isolated from the outside world and takes into account only what we explicitly passed on to her as her arguments.  Unlike such a science as history, the result of mathematical calculations does not depend on whether the Communists are in power, the Democrats or Putin.  Our function comes from mathematics - it depends only on the arguments passed to it and nothing more. <br><br>  You can check it yourself: no matter how many times you pass this function 1, 2 or 4 as arguments, you will always get 7 as a result. You can even "(2 +1)" instead of "3", and instead "4" - "(2 * 2)".  There is no other way to get other results with these arguments. </blockquote><br><blockquote>  The <code>addThreeNumbers</code> function is <code>addThreeNumbers</code> called pure because it is not only independent of the external state, but also not capable of changing it.  It cannot even change the local variables passed to it as arguments.  All she can (and should) do is calculate the result based on the values ‚Äã‚Äãof the arguments passed to her.  In other words, this feature has no side effects. </blockquote><br>  What does this give us?  Why do haskellists cling to this ‚Äúpurity‚Äù of their functions so much, contemptuously kryvat, looking at the traditional functions of imperative programming languages, built on mutations of local and global variables? <br><br><blockquote>  Since the result of calculating pure functions does not depend on the external state and does not change the external state, we can calculate such functions in parallel, without worrying about <i>data race</i> , which compete with each other for common resources.  Side effects are the destruction of parallel computing, and since our pure functions do not have them, we have nothing to worry about.  We simply write pure functions, not caring about the order in which the functions are calculated, or how to parallelize the calculations.  Paralleling we get out of the box, simply because we write in Haskell. </blockquote><br><blockquote>  In addition, since calling a pure function several times with the same arguments, we are always guaranteed to get the same result, Haskell remembers the result that was calculated once, and doesn‚Äôt calculate it again when calling a function with the same arguments, but instead substitutes the previously calculated .  This is called <i>memoization</i> .  It is a very powerful optimization tool.  Why count again if we know that the result will always be the same? </blockquote><br><a name="essence"></a>  If the essence of imperative programming is in the mutation (change) of variables in a strictly defined sequence, then the essence of functional programming is in the immunity of data and in the composition of functions. <br><br>  If we have a function <code>g :: a -&gt; b</code> (read as ‚Äúa function g that takes an argument of type a and returns values ‚Äã‚Äãof type b‚Äù) and a function <code>f :: b -&gt; c</code> , then we can compose it to get a function <code>h :: a -&gt; c</code> .  Applying the value of type a to the input of the function g, we obtain the value of the type b at the output - and the values ‚Äã‚Äãof this type are taken by the function f.  Therefore, we can immediately transfer the result of calculating the function g to the function f, the result of which will be a value of type c.  This is written like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">h</span></span> :: a -&gt; c h = f . g</code> </pre><br><img src="https://habrastorage.org/files/409/1c1/cdf/4091c1cdf9d04609924df3e820f11ab5.png"><br><br>  The point between the functions f and g is the composition operator, which has the following type: <br><br><pre> <code class="haskell hljs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code> </pre><br>  The composition operator here is taken in parentheses because it is in this way (in parentheses) that it is used in the prefix style as a normal function.  When we use it in infix style - between its two arguments - it is used without brackets. <br><br>  We see that the composition operator takes the function <code>b -&gt; c</code> as the first argument (the arrow also indicates the type - the type of the function), which corresponds to our function f.  With the second argument, it also accepts a function - but already with the type <code>a -&gt; b</code> , which corresponds to our function g.  And it returns the composition operator a new function ‚Äî with the type <code>a -&gt; c</code> , which corresponds to our function <code>h :: a -&gt; c</code> .  Since the functional arrow has the right associativity, we can omit the last parentheses: <br><br><pre> <code class="haskell hljs">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code> </pre><br>  Now we see that the composition operator needs to pass two functions - with types <code>b -&gt; c</code> and <code>a -&gt; b</code> , as well as an argument of type a, which is passed to the input of the second function, and at the output we get a value of type <code>c</code> , which the first one returns function. <br><div class="spoiler">  <b class="spoiler_title">Why is the composition operator denoted by a dot</b> <div class="spoiler_text">  In mathematics, <code>f ‚àò g</code> used to denote a composition of functions, which means ‚Äúf after g‚Äù.  The point is similar to this symbol, and therefore it was chosen as the composition operator. </div></div><br>  Composition of functions <code>f . g</code>  <code>f . g</code> means the same as <code>f (gx)</code> - i.e.  the function <code>f</code> applied to the result of applying the function <code>g</code> to the argument <code>x</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Wait a minute</b>  <b class="spoiler_title">And where is the argument of type a in the definition of the function h = f lost.</b>  <b class="spoiler_title">g?</b>  <b class="spoiler_title">I see two functions as arguments of the composition operator, and I don‚Äôt see the value passed to the input of the g function!</b> <div class="spoiler_text">  When the last argument in the definition of the function to the left and right of the "=" sign is the same argument, and this argument is not used anywhere else, it can be omitted (but necessarily from both sides!).  In mathematics, the argument is called the ‚Äúpoint of use of the function‚Äù, so this writing style is called ‚Äúpointless‚Äù (although usually with such recording of points as the composition operators, there are quite a few :)). </div></div><br>  Why is the composition of functions the essence of functional programming languages?  Yes, because any program written in a functional language is nothing but a composition of functions!  Functions are the building blocks of our program.  Compositing them, we get other functions that, in our own, we compose to obtain new functions - etc.  The data flows from one function to another, transforming, and the only condition for the composition of functions is that the data returned by one function have the same type that the next function accepts. <br><br>  Since the functions in Haskell are clean and depend only on the arguments clearly passed to them, we can easily ‚Äúpull‚Äù a ‚Äúbrick‚Äù out of the function composition chain in order to refactor or even completely replace it.  All we need to take care of is that our new brick function accepts input values ‚Äã‚Äãand outputs values ‚Äã‚Äãof the same type as the old brick function.  And that's it!  Pure functions do not depend on the external state, so we can test functions without looking at it.  Instead of testing the entire program, we test individual functions.  The situation described in this very vital story, in our case, becomes simply impossible: <br><br><blockquote>  A marketer asks a programmer: <br>  - What is the difficulty of supporting a large project? <br>  - Well, imagine that you are a writer, and support the project "War and Peace", - the programmer answers.  - You have TK - write a chapter about how Natasha Rostova walked in the rain in the park.  You write ‚Äúit was raining‚Äù, you remain - and the error message flies to you: ‚ÄúNatasha Rostova died, the continuation is impossible.‚Äù  How did she die, why did she die?  You start to understand.  It turns out that Pierre Bezukhov has slippery shoes, he fell, his gun hit the ground, and the bullet from the post ricocheted into Natasha.  What to do?  To charge the gun with idle?  Change shoes?  We decided to remove the post.  Removed, save and get the message: "Lieutenant Rzhevsky died."  Again you sit down, understand, and it turns out that in the next chapter he leans on a pole that is no longer there ... </blockquote><br>  I hope you now understand why haskellists appreciate pure functions.  First, they allow them to write parallelized code without any effort, without worrying about the data race.  Secondly, it allows the compiler to effectively optimize the calculations.  And, thirdly, the absence of side effects and the independence of the work of pure functions from the external state allows the programmer to easily maintain, test and refactor even very large projects. <br><br><a name="problems"></a>  In other words, the creators of Haskell invented for themselves (and for us) such worlds, such a spherical horse in a vacuum, in which all functions are clean, completely stateless, there is no state, everything is optimized to the impossibility and everything is parallelized with us parties.  Not a language, but a dream!  It remains only to understand what to do with the "mere trifles", which, <a href="http://core.ac.uk/download/pdf/21173011.pdf">in their scientific work on the concept of monads</a> , listed Eugenio Moggi: <br><br><blockquote>  How in this very spherical horse in vacuum to get the initial data for our programs, which come just from the outside world, from which we isolated?  You can, of course, use the result of user input as an argument to our clean function (for example, the <code>getChar</code> function that accepts character input from the keyboard), but, first, in this way we will let in our cozy clean world a ‚Äúdirty‚Äù function that we it will break there, and, secondly, such a function will always have the same argument (the <code>getChar</code> function), but the calculated value will always be different, because the user (this is an ambush!) will always press different keys. </blockquote><br><blockquote>  How to produce the result in the external world isolated by us from our cozy purely functional world, the result of the program?  After all, a function in the mathematical sense of this word must always return a result, and functions that send some data to the outside world do not return anything to us, and therefore they are not functions! </blockquote><br><blockquote>  What to do with the so-called partially defined functions - that is, with functions that are not defined for all arguments?  For example, the well-known division function is not defined for division by zero.  Such functions are also not full-fledged functions in the mathematical sense of the term.  You can, of course, throw an exception for such arguments, but ... </blockquote><br><blockquote>  ... but what do we do with the exceptions?  Exceptions are not the result that we expect from pure functions! </blockquote><br><blockquote>  And what to do with non-deterministic calculations?  That is, with those where the correct result of the calculations is not one, but many of them.  For example, we want to get a translation of a word, and the program gives us several of its meanings at once, each of which is the correct result.  A pure function should always produce only one result. </blockquote><br><blockquote>  And what to do with the continuations?  Continuation is when we make some calculations, and then, without waiting for them to finish, we save the current state and switch to perform some other task, so that after its execution we return to the incomplete calculations and continue from where we left off.  What state are we talking about in our purely functional world, where there is no state and cannot be? </blockquote><br><blockquote>  And what, finally, should we do when we need not only to somehow consider the external state, but also to somehow change it? </blockquote><br>  Let's think together how we can keep our calculations clean and solve the problems that have been voiced.  And see if you can find a common solution for all these problems. <br><br><a name="types"></a><h3>  <font color="#cc0000">Calculations and ‚Äúsomething else‚Äù</font> </h3><br>  So, we got acquainted with pure functions and realized that their cleanliness allows us to get rid of the most difficult problems that programmers face.  But we also described a number of problems that we have to solve in order to retain the ability to enjoy the benefits of pure functions.  I will bring them again (excluding the problems related to input-output, which we will discuss a little later), slightly reformulating them so that we can see in them a common pattern: <br><br><blockquote>  Sometimes we have functions that are not defined for all arguments.  When we pass this function the arguments on which the function is defined, we want it to calculate the result.  But when passing its arguments on which it is not defined, we want the function to return <b>something else to us</b> (exception, error message, or an analogue of imperative <code>null</code> ). </blockquote><br><blockquote>  Sometimes functions can give us not one result, but <b>something else</b> (for example, a whole list of results, or no result at all (an empty list of results)). </blockquote><br><blockquote>  Sometimes, to calculate the value of a function, we want to receive not only arguments, but also <b>something else</b> (for example, some data from an external environment, or some settings from a configuration file). </blockquote><br><blockquote>  Sometimes we want not only to get the result of the calculation to pass the next function, but also to apply it as an argument <b>to something else</b> (getting some state to which we can then return to continue the calculation, which is the meaning of continuations). </blockquote><br><blockquote>  Sometimes we want not only to make calculations, but also to do <b>something else</b> (for example, write something to the log). </blockquote><br><blockquote>  Sometimes, by compositing functions, we want to transfer to the next function not only the result of our calculation, but also <b>something else</b> (for example, some state that we first considered from somewhere, and then somehow changed in a controlled manner). </blockquote><br>  Noticed the general pattern?  On pseudocode, it can be written like this: <br><br><pre> <code class="javascript hljs"> ( /  - ) { <span class="hljs-comment"><span class="hljs-comment">//    / //  -  return (   / - ) }</span></span></code> </pre><br><br>  You can, of course, pass this ‚Äúsomething else‚Äù as an additional argument to our functions (this approach is used in imperative programming, and is called ‚Äústate threading‚Äù), but you can mix pure calculations with ‚Äúsomething else‚Äù in one pile - not the best idea.  In addition, it will not allow us to get a single solution for all the situations described. <br><br>  Let us recall the ancient Egyptians, who were discussed at the beginning, and who invented numbers.  Instead of drawing a number of sheep figures, they <b>separated the calculation from its context</b> .  In modern terms, they encapsulated calculations and their context.  And if before them the concept of calculating the quantity was inextricably linked to what we believe, then their innovation divided it into two parallel ‚Äúexecution threads‚Äù - into the flow associated directly with the calculations, and into the flow in which <b>something</b> is stored or processed. <b>something else</b> - namely, the context of the calculation (because during the calculation the context can not only be stored, but also be changed, if we, for example, calculate how many kebabs come from the sheep in the herd). <br><br><img src="https://habrastorage.org/files/a81/2bc/f46/a812bcf467de4e10a42b3522055efccd.png"><br><br>  When we want to express ‚Äúsomething else‚Äù in Haskell and at the same time get the most generalized solution, we express this ‚Äúsomething else‚Äù as an additional type.  But not of a simple type, but of a type function, which takes other types as an argument.  Sounds difficult and incomprehensible?  Do not worry, it is very simple, and after a few minutes you will see for yourself. <br><br><a name="types_more"></a><h3>  <font color="#cc0000">Something else encapsulation</font> </h3><br>  On December 11, 1998, the Mars Climate Orbiter spacecraft was launched to explore Mars.  After the unit reached Mars, it was lost.  After the investigation, it became clear that in the control program some distances were counted in inches, and others - in meters.  Both in one and in the other case these values ‚Äã‚Äãwere represented by the type <code>Double</code> .  As a result of the function that counts in inches, the arguments expressed in meters were passed, which naturally led to an error in the calculations. <br><br>  If we want to avoid such errors, then we need the values ‚Äã‚Äãexpressed in meters to be different from the values ‚Äã‚Äãexpressed in inches, and so that when we try to pass a value to a function that is not expressed in those units, the compiler will tell us about the error.  In Haskell this is very easy to do.  Let's announce two new types: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DistanceInMeters</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Meter</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DistanceInInches</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Inch</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span></span></code> </pre><br><br>  <code>DistanceInMeters</code> and <code>DistanceInInches</code> are called type constructors, and <code>Meter</code> and <code>Inch</code> are data constructors (type constructors and data constructors inhabit different scopes, so they could be made the same). <br><br>  Take a closer look at these type declarations.  Do you think that data constructors behave like functions, taking as a argument a value of type <code>Double</code> and returning a result of calculating a value of type <code>DistanceInMeters</code> or <code>DistanceInInches</code> ?  So it is - the data constructors are also functions!  And if earlier we could accidentally pass to a function that takes a <code>Double</code> , any value that has a <code>Double</code> , then now in this function we can specify that its argument should contain not only the value of the <code>Double</code> type, but also <b>something else</b> , namely  ¬´¬ª <code>Meter</code>  <code>Inch</code> . <br><br>          .     -_ <code>Meter</code>  <code>Inch</code>      <code>Double</code> .      ,       ‚Äî     ¬´- ¬ª ‚Äî  ,   ¬´¬ª,   ¬´- ¬ª,        .         Haskell.       Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">  ,   ,   </b> <div class="spoiler_text">  ,    <code>Maybe</code>    ,     <code>a</code> .    ¬´ ¬ª  ,         ‚Äî  <code>Double</code> ,  <code>Bool</code> ,   <code>DistanceInMeters</code> ,    .   ,    <code>Maybe a</code>  2   ‚Äî <code>Nothing</code>  <code>Just</code> (        <code>a</code> ).       ¬´¬ª:      <code>Nothing</code> ,      <code>Just</code>   -  (, <code>Just True</code> ) ‚Äî         <code>Maybe a</code> (    <code>Just</code>   <code>True</code> ,      <code>Maybe Bool</code> ). </div></div><br> ,     <code>Maybe</code> ,      .      -  (    <code>Just</code> ),     (    <code>Nothing</code> ).  ,  ,   -    <code>Maybe</code> ,     .     :  ,    ,      ‚Äî         . <br><br>  <code>Maybe</code>   Haskell       ‚Äî     ,       . ,     <code>lookup</code> ,         (, ),     ,    .            ,    .       <code>Nothing</code> ,    ‚Äî    ,   <code>Just</code> .  Those.     ,    ,     (  <code>Just</code> ),    ,      ‚Äî   ¬´- ¬ª ( <code>Nothing</code> ). <br><br><a name="either"></a>  ,       <code>Nothing</code> ,     ,     ¬´- ¬ª   ?     :  ,     ,     ,    ‚Äî    ,           . ,    : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> b</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We see that the type constructor </font></font><code>Either</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes 2 type variables - </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(which can be different types, but can be of the same type - as we like). If the result of the calculations was successful, we get them in a wrapper </font></font><code>Right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(the result of the calculations will be of type </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and if the calculations failed, then we get an error message of type a in the wrapper of the data designer </font></font><code>Left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, what about working with the external environment? What if the value of our calculation depends on some external environment, which we must read and pass as an argument to the function that calculates the value we need? As stated, we write:</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> ea = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  (Environment),      ,    <code>e</code> (,          ),        <code>a</code> .       <code>e -&gt; a</code> , ..        . <br><br>       ,        -  (    ):      ,    ¬´- ¬ª.       ‚Äî    <code>[a]</code> (    : <code>[] a</code> ,  <code>[]</code>   ¬´- ¬ª,    <code>a</code> ‚Äî     ). <br><br>      ¬´- ¬ª ‚Äî   ,          ,  ,        .    ¬´- ¬ª  ,    ¬´¬ª   ,    ¬´- ¬ª       ,       <b></b> . <br><br> <b>    ,      :</b> <br><br><blockquote>         ,     ,      ,       . </blockquote><br><blockquote>       , ,   ,         ¬´- ¬ª.    ,   , ¬´- ¬ª,          ¬´- ¬ª. </blockquote><br><blockquote>     ¬´- ¬ª,     .       ¬´- ¬ª   . </blockquote><br><blockquote>    ¬´- ¬ª  ¬´¬ª ,    ¬´¬ª   . </blockquote><br><blockquote>         : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span> -&gt; mb</code> </pre> <br>  <code>m</code> ‚Äî   ¬´ ¬ª,       <code>b</code> . </blockquote><br> <b>,     .       ,  -        :</b> <br><br><blockquote>        <code>a -&gt; b</code> , ..    .        <code>ma</code> .        <code>ma -&gt; mb</code> ,    ,  ¬´¬ª    <code>a -&gt; b</code>   <code>m</code> ,   <code>a -&gt; b</code>   ,      <code>mb</code> . </blockquote><br><blockquote>    ,   ,      first class citizens.  Those.        ,     ‚Äî     ,         ..  ,   ,   ,     ¬´¬ª  <code>m</code> .       <code>f</code> ,    <code>a</code> ,      ,     <code>mf</code>      <code>ma</code> ,     ¬´   ¬ª: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mf</span></span> ` ` ma =&gt; m (f ` ` a).</code> </pre> </blockquote><br><blockquote> , ,   ,     ,   ,   ,    .      <code>f :: b -&gt; c</code>  <code>g :: a -&gt; b</code> ,         <code>f . g</code> ,     <code>g</code>     ,    <code>f</code> .      <code>f :: b -&gt; mc</code>  <code>g :: a -&gt; mb</code> ?  <code>mb</code>  <code>b</code> ‚Äî   ,   ,   <code>b</code> ¬´¬ª   <code>m</code> . <br><br>       ¬´¬ª  <code>b</code>   <code>m</code> ,        .        ¬´¬ª    ¬´- ¬ª,           .  ,   ,      <code>a -&gt; mb</code>  <code>b -&gt; mc</code> ,         <code>a -&gt; mc</code> ,            ,   ¬´- ¬ª.   ,  , ,  ,    . </blockquote><br><br><a name="functor"></a><h3> <font color="#cc0000"> ‚Äî   ,   !</font> </h3><br> ,     : <br><br><blockquote> ,         ,    ,   . </blockquote><br><blockquote> ,     <b></b> ,    ,   . </blockquote><br><blockquote> ,     ,        ‚Äî ,         ,   ,     ¬´- ¬ª,    . </blockquote><br>  ,       ,   <s> </s>          .     <code>isChar :: a -&gt; Bool</code> , ,        <code>Char</code> ,     ,        . ,    <code>Maybe a</code>  2   ‚Äî <code>Just</code>  <code>Nothing</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybeIsChar</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> maybeIsChar (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (isChar x) maybeIsChar <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so we can, without bothering (although this is how to look), determine the analogue of each pure function for working with wrapped data. And we will need to write the corresponding analog not only for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function, but also for each wrapper! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it can be done differently. You can define a new function that takes as its first argument a pure function that we already have and applies it to the value contained within the wrapper, returning us the new value wrapped in the same wrapper. Let's call this function </font></font><code>fmap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; ma -&gt; mb</code> </pre><br> ,  ,            ,            <code>fmap</code> .    <code>fmap</code>    <code>Maybe a</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> f (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fx) fmap _ <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">            fmap   ?</b> <div class="spoiler_text">    <code>fmap</code>    <code>a -&gt; b</code> . ,   ,          ,   ,       .     - ,        .      ,       . </div></div><br>         <code>Maybe a</code>    <code>a -&gt; b</code> . ,      <code>fmap</code>      .       -:     <code>Maybe a</code> ,      . <br><br> -!     ,        <code>fmap</code> ,    ¬´¬ª ,    ,  .   ,   ‚Äî   !  , ..           ,     . <br><br><a name="applicative"></a><h3> <font color="#cc0000">  ‚Äî    !</font> </h3><br>  ,    ,    ,   .  ,       ?       ? <br><br> ,   .    ,        ,      ‚Äî  ,         ,      .    <code>&lt;*&gt;</code> ( apply; ,        ,    ,    ,        ;        ,   ,        ): <br><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: m (a -&gt; b) -&gt; ma -&gt; mb</code> </pre><br>       <code>Maybe a</code> .    ,     2 ,  ,      ,   ,    ( <code>Just   </code> ),   <code>Nothing</code> : <br><br><pre> <code class="haskell hljs">(<span class="hljs-type"><span class="hljs-type">Just</span></span> f) &lt;*&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &lt;*&gt; _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> f) &lt;*&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fx)</code> </pre><br> ,       ,        ,    ‚Äî  ,      <code>Maybe</code> .               ,  ,    ‚Äî        <code>(&lt;*&gt;)</code> .  ,       ,       ,     <code>(&lt;*&gt;)</code>  <code>pure</code> . <br><br>     <code>pure</code> ? ,   ,     !  <code>pure</code>         .   : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pure</span></span> :: a -&gt; ma</code> </pre><br>    <code>pure</code>    <code>Maybe</code> ,      : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pure</span></span> x = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br>   , ? (   ¬´!¬ª) <br><br> ,     ,    ,     ,      (           ).  , ,    <code>Just 2</code>  <code>Just 3</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">pure</span></span> (+) &lt;*&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;*&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> &gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">    ?</b> <div class="spoiler_text">    pure     <code>Maybe</code>  <code>(+)</code> ,      .      2           <code>(&lt;*&gt;)</code> . </div></div><br><div class="spoiler"> <b class="spoiler_title">   ?   !</b> <div class="spoiler_text"> , ,       .        <code>liftAN</code> ,   A  Applicative (functor),   N  ,   ,   .       (+),   : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">liftA2</span></span> (+) (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>       ,     : <code>( | a + b | )</code> <br><br><pre> <code class="haskell hljs">( | (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) + (<span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) | ) &gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br></div></div><br><br><a name="monad"></a><h3> <font color="#cc0000">  ,    !</font> </h3><br> ,  ,      ( )   .         <code>fmap</code> .    ,         ,      ,    ,    . <br><br>   ,        .          ‚Äî <code>pure</code>  <code>&lt;*&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- and this also allowed us to apply ordinary functions to the wrapped values, taking any number of arguments. And as soon as we defined these functions for the wrapper type, he immediately earned the right to be called an applicative functor. By the way, in order to make a wrapper type an applicative functor, you must first make it an ordinary functor (and it‚Äôs not possible to cheat - the compiler will follow this). This is a logical (and, as usual, simple) explanation, which I will leave to you for self-study, because the article has already become swollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains for us to understand how we can compose a composition of two functions </font></font><code>a -&gt; mb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>b -&gt; mc</code>  ,            ,    ¬´- ¬ª,    .   , , ,              .     ,   ,      ,   . <br><br>     ‚Äî  <code>return</code> .    <code>return</code> ,      .   <code>return</code>   ,      : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> :: a -&gt; ma</code> </pre><br>    <code>pure</code>  ,        ?    ,        .    ,     ,     ,      (   ‚Äî  ),  ,         pure,   <code>return</code>     : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> = pure</code> </pre><br>  ,       ,    ,  <code>(&gt;&gt;=)</code> ( bind).    : <br><br><pre> <code class="haskell hljs">(&gt;&gt;=) :: mb -&gt; (b -&gt; mc) -&gt; mc</code> </pre><br> ‚Ä¶ -      .  :  <code>(&gt;&gt;=)</code>        <code>a -&gt; mb</code> ,    ,           ,   -,     ¬´- ¬ª (    ¬´- ¬ª,       ),    .  Those.        <code>a -&gt; mb</code> ,        <code>mb</code> , ,      - . ,      ,     <code>(&gt;&gt;=)</code> .    . <br><br>   <code>(&gt;&gt;=)</code>    <code>Maybe</code> .    2  ,     2 .    ,   <code>b -&gt; mc</code>  <code>k</code> ,   ¬´ <b></b> ¬ª ( ,   ,    ,  ¬´ ¬ª,      <code>return</code>   ¬´ ¬ª): <br><br><pre> <code class="haskell hljs">‚Äî       <span class="hljs-type"><span class="hljs-type">Nothing</span></span>,   <span class="hljs-type"><span class="hljs-type">Nothing</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> &gt;&gt;= _ = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ‚Äî       ,    <span class="hljs-string"><span class="hljs-string">""</span></span>    k (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) &gt;&gt;= k = kx</code> </pre><br>  That's all.     <code>Maybe</code> ‚Äî ! ,       ‚Äî     <code>return</code>  <code>(&gt;&gt;=)</code> . <br><br>      (  ,     ,    )?       ,       .          ,    <code>Maybe</code>     <code>Just</code> ,  <code>Nothing</code> . ,   -       <code>Nothing</code> ,        .     ?         <code>if then else</code> ,      <code>Nothing</code> ? <br><br>    ,       <code>if then else</code> .     <code>(&gt;&gt;=)</code> ,       .  :  -    <code>Nothing</code> ,   <code>(&gt;&gt;=)</code>  ¬´¬ª    ,      . ,            <s>null</s> <code>Nothing</code> .           ,               . <br><br><a name="more_monads"></a><h3> <font color="#cc0000">     </font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's maybe define another monad? Take the wrapper type </font></font><code>Either ab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allows us to more clearly work with errors and exceptions than the type </font></font><code>Maybe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Let's recall the definition of this type:</font></font><br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Left</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> b</span></span></code> </pre><br>    2 ,    ‚Äî <code>Left</code> ‚Äî    <code>a</code> ‚Äî   ,        ,        ¬´- ¬ª,   ‚Äî <code>Right</code> ‚Äî    <code>b</code> ‚Äî    ¬´¬ª .  ¬´¬ª      ,           ,      <code>Right</code> .      ‚Äî       ,      <code>Left</code> . <br><br>     <code>return</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">return</span></span> x = <span class="hljs-type"><span class="hljs-type">Right</span></span> x</code> </pre><br>   .     <code>return</code>    ,  -   <code>b</code> ,       -_ <code>Right</code>     <code>Either ab</code> . <br><br>    <code>(&gt;&gt;=)</code> .    ,     <code>Maybe</code> :       ,       <code>Either ab</code> ,    ,    -_ <code>Left</code> ‚Äî            .       (..       ,    -_ <code>Right</code> ),         : <br><br><pre> <code class="haskell hljs">(<span class="hljs-type"><span class="hljs-type">Left</span></span> x) &gt;&gt;= _ = <span class="hljs-type"><span class="hljs-type">Left</span></span> x (<span class="hljs-type"><span class="hljs-type">Right</span></span> x) &gt;&gt;= k = kx</code> </pre><br>  <code>Maybe</code>  <code>Either</code> .   2  ,        (, ,       ,  ¬´¬ª     ).           ,         . <br><br>    ,       ‚Äî  .        <code>a -&gt; [b]</code> .    <code>(&gt;&gt;=)</code>     <code>ma</code> ‚Äî   ,  <code>[a]</code> (   <code>a</code> ).        ,         <code>a</code> . <br><br>  ,   ,       ?   ,         .        ‚Äî       ,        .          ,   <code>fmap</code> (     ,   ,      ‚Äî ?).      <code>fmap</code> ,        <code>m</code>      : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> </pre><br>     ,   <code>fmap</code> ,     : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; [b]) -&gt; [a] -&gt; [[b]]</code> </pre><br>  ,        <code>fmap</code>       <code>mb</code> ,   <code>mmb</code> , ..     .      <code>(&gt;&gt;=)</code> ,       ¬´¬ª.       <code>concat</code> ,   ,   ,     .      <code>(&gt;&gt;=)</code>   : <br><br><pre> <code class="haskell hljs">[] &gt;&gt;= _ = [] xs &gt;&gt;= k = (concat . fmap k) xs</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You see that the logic of defining an operator </font></font><code>(&gt;&gt;=)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the same in all cases. In each wrapped value, we have the result of calculations and ‚Äúsomething else‚Äù, and we think that we need to do it with calculations and with this ‚Äúsomething else‚Äù when transferring to another function. ‚ÄúSomething else‚Äù can be a marker of successful or unsuccessful calculations, it can be a marker of successful calculations or an error message, it can be a marker that our calculations can return from zero to infinity of results. ‚ÄúSomething else‚Äù can be a log entry, a state that we read and pass as an argument for our ‚Äúbasic‚Äù calculations. Or the state that we read, change and transfer to another function, where it changes again - in parallel with our ‚Äúbasic‚Äù calculations.</font></font><br><br> ,       (   ,    ).  ‚Äî    ,      ‚Äî <code>return</code>  <code>(&gt;&gt;=)</code> . <br><br> ,  <code>(&gt;&gt;=)</code>  ,   ,  .      ,           Haskell,  ,      .     . -,      Haskell     ,  <a href="https://www.quora.com/What-is-considered-the-best-practice-in-Haskell-to-define-your-own-monadic-type-to-solve-specific-problem-or-to-use-predefined-monads-as-the-generalized-solution/answer/Tikhon-Jelvis">   ,      </a> . -, <b></b>  (      )  ,   ,      . <br><br>         :    ¬´¬ª    ¬´- ¬ª,   .        ¬´¬ª ¬´ ¬ª,   <code>(&gt;&gt;=)</code> . ,     -     <code>(&gt;&gt;=)</code> ,     ,        ,   ,      . <br><br> ,   ,   <code>(&gt;&gt;=)</code> ‚Äî      ,        .      Haskell,    <code>(&gt;=&gt;)</code> ,   ¬´¬ª (¬´fish operator¬ª): <br><br><pre> <code class="haskell hljs">(&gt;=&gt;) :: (a -&gt; mb) -&gt; (b -&gt; mc) -&gt; a -&gt; mc (f &gt;=&gt; g) x = fx &gt;&gt;= g</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we have is type </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is Kleisley's arrows. Applying the Klaisley arrow </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the value </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we get the wrapped value. And how to transfer the wrapped value to the next Klaisley arrow, as you remember, the operator knows </font></font><code>(&gt;&gt;=)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next part we will see how to work with the monads defined in Haskell (and others are not required by the overwhelming majority of programmers), we will implement another standard monad called</font></font><code>Writer</code> (¬´- ¬ª       ),        ,        .           Haskell   ¬´ ¬ª,     ,  ,   ,    ,     ,     ,      .               -,      (,    ,       ,    ). </div><p>Source: <a href="https://habr.com/ru/post/272115/">https://habr.com/ru/post/272115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272095/index.html">Corporate use of Android 5.0: security recommendations</a></li>
<li><a href="../272099/index.html">PHP 7.0.0</a></li>
<li><a href="../272101/index.html">SQLi is still in service</a></li>
<li><a href="../272105/index.html">What we should parse site. Webdriver API Basics</a></li>
<li><a href="../272107/index.html">Server administration Resource Management with PowerShell</a></li>
<li><a href="../272117/index.html">PyNSK # 5 - the fifth meeting of the Novosibirsk Python community</a></li>
<li><a href="../272119/index.html">Few nice mancalas</a></li>
<li><a href="../272121/index.html">3CX Phone System 14 Service Pack 2 with a new console for the Secretary and WallBoard</a></li>
<li><a href="../272123/index.html">Unity in action. Multiplatform C # Development</a></li>
<li><a href="../272125/index.html">Angular Light for jQuery / JS developers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>