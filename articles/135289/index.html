<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt Creator Extension System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Hello. I admit right away that I started writing this post for quite a long time, but I don‚Äôt have enough time to fully complete its writin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt Creator Extension System</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  Hello.  I admit right away that I started writing this post for quite a long time, but I don‚Äôt have enough time to fully complete its writing.  Therefore, now I am publishing it in the current state, and I will still postpone the description of the three incomplete sections and will try to publish it in a separate post. <br><br><h4>  Introduction </h4><br>  This is a note in which I would like to briefly describe the architecture and system extensions of the Qt Creator development environment.  Initially, I assumed only to translate the <a href="http://www.google.kz/search%3Fix%3Dsea%26sourceid%3Dchrome%26ie%3DUTF-8%26q%3DWriting-Qt-Cretor-plugins.pdf">Writing-Qt-Cretor-plugins.pdf</a> document, but it just so happened that the development of Qt Creator does not stand still and firstly, this document is not so relevant (it‚Äôs outdated, the API has changed, pieces of code are not full and often do not work), and secondly, since the time it was written, additional features of Qt Creator extension have appeared that I would like to describe. <br><br>  However, without this document, there would not have been a given note: I took a lot out of it, right down to the structure of the post, while trying somewhere to throw out / replace / add something to make the post relevant for the latter at the moment Qt Creator 2.4.0 time release. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Who can be useful for this document?  First of all, these are of course Qt-programmers who have chosen this IDE as their main development environment. <br><br>  In addition, thanks to the well-thought-out system of Qt Creator extensions, this material will be useful to those who are going to create their own development tools, but do not want to start writing them from scratch: a person can turn off all Qt Creator extensions that are unnecessary for him and write their own ready-made examples in the source code Qt Creator. <br><br>  So, what awaits us under the cut (finished sections are marked in bold): <br><br><ol><li>  <b>Qt Creator build</b> </li><li>  <b>First expansion</b> </li><li>  <b>Adding new menus and menu items</b> </li><li>  <b>Qt Creator Architecture</b> </li><li>  <b>Adding a new editor (Editor)</b> </li><li>  <b>Adding a side navigation bar</b> </li><li>  Adding a page to the settings dialog </li><li>  Adding a filter to the search dialog </li><li>  Adding a new project type </li></ol><br>  Let me remind you that Qt Creator is a cross-platform free IDE for working with the Qt framework developed by Trolltech (Nokia).  What does not prevent to make from it a simple text editor with syntax highlighting, simply disabling all extensions.  <i>Attention, hundreds of pictures!</i> <br><a name="habracut"></a><br><h4>  1. Build Qt Creator </h4><br>  Building an entire IDE is fairly straightforward.  First of all, we need to download the source code of the latest version of Qt Creator.  at the moment it is version 2.4.  Download the file from <a href="http://qt.nokia.com/">qt.nokia.com</a> from <a href="http://qt.nokia.com/downloads/downloads">Downloads / Qt-Creator</a> : <br><img src="https://habrastorage.org/getpro/habr/post_images/550/4e0/cb3/5504e0cb317aa2f9080e6ad89354ec55.jpg" alt="image"><br>  Next, unpack the resulting archive, create a build subdirectory in the source directory, go to it, run qmake and then make: <br><pre><code class="hljs ruby">$ tar -xvf qt-creator-<span class="hljs-number"><span class="hljs-number">2.4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>-src.tar.gz $ mkdir qt-creator-<span class="hljs-number"><span class="hljs-number">2.4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>-src/build $ cd qt-creator-<span class="hljs-number"><span class="hljs-number">2.4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>-src/build/ $ qmake ../qtcreator.pro ‚Äìrecursive $ make</code> </pre> <br>  For Windows users, this code may differ only in the last line - instead of make, you will need to call mingw32-make or nmake, depending on the user's preferences. <br><br>  That's all.  You can run Qt Creator from the build / bin directory. <br><img src="https://habrastorage.org/getpro/habr/post_images/968/9d0/d50/9689d0d50e44e4d7ff05ff7cec5cd6c0.jpg" alt="image"><br>  <i>It should be noted that this is a very important step, because if you do not build Qt Creator from source, you will not be able to go further and compile and test extensions for it.</i> <br><br><h4>  2. First expansion </h4><br>  As in many cases, exploring the Qt Creator extension system should start by creating a very simple extension.  Now we will try to make an extension that does nothing, but using the example of our DoNothing extension, we will learn about Qt Creator base classes related to writing extensions and see the ‚ÄúDoNothing‚Äù line in the list of available extensions. <br><img src="https://habrastorage.org/getpro/habr/post_images/a0f/25f/b74/a0f25fb7407b43150960443720cb74f7.jpg" alt="image"><br><img src="https://habrastorage.org/getpro/habr/post_images/ce3/cdd/b94/ce3cddb94e2af4d9c763b51645bfa3b3.jpg" alt="image"><br><br><h5>  2.1 Creating a Qt Creator Extension Project </h5><br>  Previously, it seems down to version 2.0, to perform this step, you had to manually create the following files: <br><ul><li>  DoNothingPlugin.pro </li><li>  DoNothingPlugin.h </li><li>  DoNothingPlugin.cpp </li><li>  DoNothingPlugin.pluginspec </li></ul><br>  Also, then it was necessary either to add the extension project to the $$ QT_CREATOR_ROOT / src / plugins directory, or placing it elsewhere, you need to specify the source and build directories of Qt Creator in the .pro file.  In modern versions of Qt Creator, project files can be placed anywhere, since a new type of master, the Qt Creator Module, has appeared to create it.  The process of creating a new extension is currently as follows / <br>  At the very beginning, everything is as usual - choose the type of project being created, <br><img src="https://habrastorage.org/getpro/habr/post_images/72e/869/a01/72e869a01c7697419778193d5bbab196.jpg" alt="image"><br>  after we enter the name and the path to its directory <br><img src="https://habrastorage.org/getpro/habr/post_images/b57/92c/686/b5792c6865f8fc013ee7bd7c0f4adcc3.jpg" alt="image"><br>  as well as the purpose of the assembly, of course it's Desktop. <br><img src="https://habrastorage.org/getpro/habr/post_images/46d/506/259/46d50625912509f91f9987984830206c.jpg" alt="image"><br>  But after that, a little bit of magic begins - we need to fill in the module-specific information: <br><img src="https://habrastorage.org/getpro/habr/post_images/5ac/5e8/9f2/5ac5e89f279c29c7d6b11b55ee5c6eb3.jpg" alt="image"><br>  Here, in general, everything is more than clear from the picture.  The only vital fields here are the path to the Qt Creator source / build directories.  Finishing the wizard: <br><img src="https://habrastorage.org/getpro/habr/post_images/27d/109/3b9/27d1093b964ebdaf2dd9e8e579a94c70.jpg" alt="image"><br>  And we look at the resulting project structure: <br><img src="https://habrastorage.org/getpro/habr/post_images/32e/845/32c/32e84532c002b5537ba2da350f7ba41f.jpg" alt="image"><br><br><h5>  2.2 Service Files </h5><br>  At first glance there are a lot of files and directories, but in fact there is nothing to worry about.  Let's look at what we saw above and start with the project file: <br><pre> <code class="hljs pgsql">TARGET = DoNothing TEMPLATE = lib DEFINES += DONOTHING_LIBRARY # DoNothing files SOURCES += donothingplugin.cpp HEADERS += donothingplugin.h\ donothing_global.h\ donothingconstants.h OTHER_FILES = DoNothing.pluginspec # Qt Creator linking ## <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> the QTC_SOURCE environment variable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> override the setting here QTCREATOR_SOURCES = $$<span class="ruby"><span class="ruby">(QTC_SOURCE) isEmpty(QTCREATOR_SOURCES)</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:QTCREATOR_SOURCES=/home/kafeg/devel/Qt/qt-creator-</span></span></span><span class="hljs-number"><span class="ruby"><span class="hljs-number">2.4</span></span></span><span class="ruby">.</span><span class="hljs-number"><span class="ruby"><span class="hljs-number">0</span></span></span><span class="ruby">-src </span><span class="hljs-comment"><span class="ruby"><span class="hljs-comment">## set the QTC_BUILD environment variable to override the setting here IDE_BUILD_TREE = $$</span></span></span></span>(QTC_BUILD) isEmpty(IDE_BUILD_TREE):IDE_BUILD_TREE=/home/kafeg/devel/Qt/qt-creator<span class="hljs-number"><span class="hljs-number">-2.4</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-src/build ## uncomment <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> build plugin <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> config directory ## &lt;localappdata&gt;/plugins/&lt;ideversion&gt; ## <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> &lt;localappdata&gt; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> eg ## "%LOCALAPPDATA%\Nokia\qtcreator" <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Windows Vista <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> later ## "$XDG_DATA_HOME/Nokia/qtcreator" <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> "~/.local/share/Nokia/qtcreator" <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Linux ## "~/Library/Application Support/Nokia/Qt Creator" <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Mac # USE_USER_DESTDIR = yes PROVIDER = DoNothingCompany <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>($$<span class="pgsql"><span class="pgsql">QTCREATOR_SOURCES/src/qtcreatorplugin.pri) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">include</span></span></span><span class="pgsql">($$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>QTCREATOR_SOURCES/src/plugins/coreplugin/coreplugin.pri) LIBS += -L$$<span class="undefined"><span class="undefined">IDE_PLUGIN_PATH/Nokia</span></span></code> </pre><br>  As you can see, in this generated file, the name (DoNothing) and the type (library) of the project are described, three header files and one source code file are specified, pluginspec is mentioned.  The location of Qt Creator source codes is indicated, commented instructions allow installing the assembled library not into the Qt Creator directory, but into the local user directory, the provider is described, on which the final location of the library files depends.  And finally, the qtcreatorplugin.pri and coreplugin.pri files, which are basic for all extensions, are included, which are already responsible for properly linking our extension with all the necessary libraries. <br><br>  The following files are <b>donothing_global.h</b> : <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#ifndef DONOTHING_GLOBAL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DONOTHING_GLOBAL_H #include &lt;QtCore/QtGlobal&gt; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(DONOTHING_LIBRARY) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DONOTHINGSHARED_EXPORT Q_DECL_EXPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DONOTHINGSHARED_EXPORT Q_DECL_IMPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // DONOTHING_GLOBAL_H</span></span></code> </pre><br>  and <b>donothingconstants.h</b> : <br><pre> <code class="hljs rust">#ifndef DONOTHINGCONSTANTS_H #define DONOTHINGCONSTANTS_H namespace DoNothing { namespace Constants { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ACTION_ID = <span class="hljs-string"><span class="hljs-string">"DoNothing.Action"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MENU_ID = <span class="hljs-string"><span class="hljs-string">"DoNothing.Menu"</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// namespace DoNothing } // namespace Constants #endif // DONOTHINGCONSTANTS_H</span></span></code> </pre><br>  Here I think everything is clear without additional explanations.  And what is not clear - it will become clear when we will need this code in the future.  The list of service files can be completed with the DoNothing.pluginspec.in file: <br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">\</span></span></span><span class="hljs-tag">"</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DoNothing</span></span></span><span class="hljs-tag">\" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">\</span></span></span><span class="hljs-tag">"</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.0.1</span></span></span><span class="hljs-tag">\" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">compatVersion</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">\</span></span></span><span class="hljs-tag">"</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0.0.1</span></span></span><span class="hljs-tag">\"&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vendor</span></span></span><span class="hljs-tag">&gt;</span></span>DoNothingCompany<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vendor</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">copyright</span></span></span><span class="hljs-tag">&gt;</span></span>(C) DoNothing Company<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">copyright</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">license</span></span></span><span class="hljs-tag">&gt;</span></span>DoNothing Company license text here<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">license</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>DoNothing Company short description of plugin here<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>http://www.donothing.com<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencyList</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">\</span></span></span><span class="hljs-tag">"</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Core</span></span></span><span class="hljs-tag">\" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">\</span></span></span><span class="hljs-tag">"$$</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">QTCREATOR_VERSION</span></span></span><span class="hljs-tag">\"/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencyList</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  This file will eventually come with a binary library file and is a simple description of our extension.  And this is what he describes: <br><ol><li>  The name of the extension that will be used in the name of the library that implements it.  (In our case, DoNothing.dll in Windows and libDoNothing.so in Unix) </li><li>  Extension version </li><li>  Qt Creator Extension Required Version </li><li>  Vendor Name </li><li>  Copyright </li><li>  License text </li><li>  Description </li><li>  Vendor URL </li><li>  List of extensions on which this extension depends. </li></ol><br><h5>  2.3 Implementation of the extension </h5><br>  To successfully compile an empty project, two basic implementation files of our extension are needed.  What are they like?  The main requirement is that the main extension class should inherit from the base class IPlugin and override some of its methods. <br>  <b>donothingplugin.h</b> <br><pre> <code class="hljs kotlin">#ifndef DONOTHING_H #define DONOTHING_H #include <span class="hljs-string"><span class="hljs-string">"donothing_global.h"</span></span> #include &lt;extensionsystem/iplugin.h&gt; namespace DoNothing { namespace Internal { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoNothingPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public ExtensionSystem::IPlugin { Q_OBJECT public: DoNothingPlugin</span></span></span></span>(); ~DoNothingPlugin(); bool initialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;arguments, QString *errorString); void extensionsInitialized(); ShutdownFlag aboutToShutdown(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: void triggerAction(); }; } <span class="hljs-comment"><span class="hljs-comment">// namespace Internal } // namespace DoNothing #endif // DONOTHING_H</span></span></code> </pre><br>  Consider the file implementation of this code in more detail: <br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"donothingplugin.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"donothingconstants.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/icore.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/icontext.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/actionmanager/actionmanager.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/actionmanager/command.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/actionmanager/actioncontainer.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/coreconstants.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtGui</span></span>/<span class="hljs-type"><span class="hljs-type">QAction</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtGui</span></span>/<span class="hljs-type"><span class="hljs-type">QMessageBox</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtGui</span></span>/<span class="hljs-type"><span class="hljs-type">QMainWindow</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtGui</span></span>/<span class="hljs-type"><span class="hljs-type">QMenu</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QtCore</span></span>/<span class="hljs-type"><span class="hljs-type">QtPlugin</span></span>&gt; using namespace <span class="hljs-type"><span class="hljs-type">DoNothing</span></span>::<span class="hljs-type"><span class="hljs-type">Internal</span></span>; <span class="hljs-type"><span class="hljs-type">DoNothingPlugin</span></span>::<span class="hljs-type"><span class="hljs-type">DoNothingPlugin</span></span>() { // <span class="hljs-type"><span class="hljs-type">Create</span></span> your members } <span class="hljs-type"><span class="hljs-type">DoNothingPlugin</span></span>::~<span class="hljs-type"><span class="hljs-type">DoNothingPlugin</span></span>() { // <span class="hljs-type"><span class="hljs-type">Unregister</span></span> objects from the plugin manager<span class="hljs-string"><span class="hljs-string">'s object pool // Delete members }</span></span></code> </pre><br>  The constructor and destructor are used only to initialize base variables that are not widgets and / or actions (Action). <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">bool</span></span> <span class="hljs-type"><span class="hljs-type">DoNothingPlugin</span></span>::initialize(const <span class="hljs-type"><span class="hljs-type">QStringList</span></span> &amp;arguments, <span class="hljs-type"><span class="hljs-type">QString</span></span> *errorString) { // <span class="hljs-type"><span class="hljs-type">Register</span></span> objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the plugin manager's object pool // <span class="hljs-type"><span class="hljs-type">Load</span></span> settings // <span class="hljs-type"><span class="hljs-type">Add</span></span> actions to menus // connect to other plugins' signals // <span class="hljs-string"><span class="hljs-string">"In the initialize method, a plugin can be sure that the plugins it // depends on have initialized their members."</span></span> <span class="hljs-type"><span class="hljs-type">Q_UNUSED</span></span>(arguments) <span class="hljs-type"><span class="hljs-type">Q_UNUSED</span></span>(errorString) <span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">ActionManager</span></span> *am = <span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">ICore</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>()-&gt;actionManager(); <span class="hljs-type"><span class="hljs-type">QAction</span></span> *action = new <span class="hljs-type"><span class="hljs-type">QAction</span></span>(tr(<span class="hljs-string"><span class="hljs-string">"DoNothing action"</span></span>), this); <span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">Command</span></span> *cmd = am-&gt;registerAction(action, <span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">ACTION_ID</span></span>, <span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">Context</span></span>(<span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">C_GLOBAL</span></span>)); cmd-&gt;setDefaultKeySequence(<span class="hljs-type"><span class="hljs-type">QKeySequence</span></span>(tr(<span class="hljs-string"><span class="hljs-string">"Ctrl+Alt+Meta+A"</span></span>))); connect(action, <span class="hljs-type"><span class="hljs-type">SIGNAL</span></span>(triggered()), this, <span class="hljs-type"><span class="hljs-type">SLOT</span></span>(triggerAction())); <span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">ActionContainer</span></span> *menu = am-&gt;createMenu(<span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">MENU_ID</span></span>); menu-&gt;menu()-&gt;setTitle(tr(<span class="hljs-string"><span class="hljs-string">"DoNothing"</span></span>)); menu-&gt;addAction(cmd); am-&gt;actionContainer(<span class="hljs-type"><span class="hljs-type">Core</span></span>::<span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">M_TOOLS</span></span>)-&gt;addMenu(menu); return true; }</code> </pre><br>  The <b>initialize ()</b> function is called when Qt Creator decides it's time to initialize the extension.  This function is intended to initialize the initial state and register all actions and objects related to the extension in Qt Creator itself. <br><br>  The function will be called only after all extensions depend on the extension already loaded into memory.  In the default code, as can be seen from the example above, the addition of a new menu item has already been described, but we will stop there a bit later. <br><br>  All we need to know now is that if the initialization is successfully completed, this function should return true, if unsuccessful, return false and write an error message to the errorString variable in human language. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DoNothingPlugin::extensionsInitialized() { <span class="hljs-comment"><span class="hljs-comment">// Retrieve objects from the plugin manager's object pool // "In the extensionsInitialized method, a plugin can be sure that all // plugins that depend on it are completely initialized." }</span></span></code> </pre><br>  The <b>extensionsInitialized ()</b> method is called after the end of initialization.  Serves mainly as an assistant to those extensions that depend on the current one. <br><pre> <code class="hljs pgsql">ExtensionSystem::IPlugin::ShutdownFlag DoNothingPlugin::aboutToShutdown() { // Save settings // Disconnect <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> signals that are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> needed during shutdown // Hide UI (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> UI that <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the main <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> directly) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SynchronousShutdown; }</code> </pre><br>  The <b>aboutToShutdown ()</b> method is called before the extension is unloaded from memory. <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DoNothingPlugin</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::triggerAction()</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">QMessageBox</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">information</span></span>(Core::ICore::instance()<span class="hljs-built_in"><span class="hljs-built_in">-</span></span>&gt;<span class="hljs-built_in"><span class="hljs-built_in">mainWindow</span></span>(), <span class="hljs-built_in"><span class="hljs-built_in">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"Action triggered"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"This is an action from DoNothing."</span></span>)); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Q_EXPORT_PLUGIN2</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">DoNothing</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DoNothingPlugin</span></span>)</code> </pre><br><h5>  2.4 Build and test extensions </h5><br>  To build our extension, just press the key combination Ctrl + R, after which the extension will be assembled and installed in the Qt Ceator extension directory, but not launched, since Qt Creator does not know how to launch this library.  You can fix this situation on the application launch settings page (Projects -&gt; Start -&gt; Startup Configuration -&gt; Program): <br><img src="https://habrastorage.org/getpro/habr/post_images/3b1/670/659/3b16706597304dd36a0147d4b64a21ed.jpg" alt="image"><br>  The result will be Qt Creator launched, in the list of extensions of which you can see a new line: <br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/024/736/4d6024736645dfd8f422936354993ca1.jpg" alt="image"><br>  And in the directory of all extensions a new directory with a couple of files appeared: <br><pre> <code class="hljs ruby">kafeg@kafeg-<span class="hljs-symbol"><span class="hljs-symbol">desktop:</span></span>~<span class="hljs-regexp"><span class="hljs-regexp">/devel/</span></span>Qt/qt-creator-<span class="hljs-number"><span class="hljs-number">2.4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>-src/build/lib/qtcreator/plugins/DoNothingCompany$ ls DoNothing.pluginspec libDoNothing.so</code> </pre><br>  This is how we can add the most elementary Qt Creator extension.  Go ahead. <br><br><h4>  3 Adding new menus and menu items </h4><br>  In this part, we will learn how to add new menu menus to existing menus, and also understand how to create our own menus.  But first, look at the contents of the Qt Creator panel menu: <br><img src="https://habrastorage.org/getpro/habr/post_images/f43/819/867/f438198672c9be8e6af86cdb1f201a75.jpg" alt="image"><br>  The panel contains the following default elements: <br><ul><li>  File <br>  -Create <br>  -Open <br>  - recent files <br></li><li>  Edit <br>  -Additionally <br></li><li>  Instruments </li><li>  Window <br>  -Outboard <br></li><li>  reference </li></ul><br>  <i>All other menu items, for example, Debug, Build and Analysis are implemented in separate extensions and are not part of the default menu set.</i> <br><br>  Qt developers know that the menus of the menus themselves are implemented by a combination of the QMenu and QAction classes, and their display in the form of a panel is handled by the QMenuBar class. <br><br><h5>  3.1 Core :: ActionManager </h5><br>  The basic part of Qt Creator is essentially just an empty window that can load extensions.  All the functionality provided by Qt Creator is implemented through its extensions.  The main extension of Qt Creator is referred to as "core".  Without this extension, Qt Creator is nothing at all. <br><br>  One of the main components of the core extension is ActionManager.  ActionManager is an object responsible for registering all menus, menu items, and keyboard shortcuts.  Actually, if we want to add a new menu item, we must use the ActionManager object.  Just below, we'll figure out how ... <br>  To access the ActionManager object, our code must contain the following: <br><pre> <code class="hljs rust">#include &lt;coreplugin/actionmanager/actionmanager.h&gt; #include &lt;coreplugin/icore.h&gt; ... Core::ActionManager* am = Core::ICore::instance()-&gt;actionManager();</code> </pre><br><h5>  3.2 Core :: ActionContainer </h5><br>  ActionContianer provides menus and menu bars in Qt Creator.  Instances of this class are never created directly, they are accessed through the methods ActionManager :: createMenu (), ActionManager :: createMenuBar () and others. <br><br>  There are instances of ActionContainer associated with all the default menus.  To get an instance of ActionContainer, you need to use code like this: <br><pre> <code class="hljs rust">#include &lt;coreplugin/coreconstants.h&gt; #include &lt;coreplugin/actionmanager/actionmanager.h&gt; #include &lt;coreplugin/icore.h&gt; Core::ActionManager* am = Core::ICore::instance()-&gt;actionManager(); Core::ActionContainer* ac = am-&gt;actionContainer( ID );</code> </pre><br>  Below is a table of the default IDs that allow you to get ActionContainer instances.  IDs are variables of type const char * static in Core visibility. <br><table><tbody><tr><th>  Menu </th><th>  ID </th></tr><tr><td>  File </td><td>  Core :: Constants :: M_FILE </td></tr><tr><td>  File -&gt; New </td><td>  Core :: Constants :: M_FILE_NEW </td></tr><tr><td>  File -&gt; Open </td><td>  Core :: Constants :: M_FILE_OPEN </td></tr><tr><td>  File -&gt; Recent Files </td><td>  Core :: Constants :: M_FILE_RECENTFILES </td></tr><tr><td>  Edit </td><td>  Core :: Constants :: M_EDIT </td></tr><tr><td>  Edit -&gt; Advanced </td><td>  Core :: Constants :: M_EDIT_ADVANCED </td></tr><tr><td>  Tools </td><td>  Core :: Constants :: M_TOOLS </td></tr><tr><td>  Window </td><td>  Core :: Constants :: M_WINDOW </td></tr><tr><td>  Window panes </td><td>  Core :: Constants :: M_WINDOW_PANES </td></tr><tr><td>  Help </td><td>  Core :: Constants :: M_HELP </td></tr></tbody></table><br>  For example, if we want to get a pointer to the ‚ÄúHelp‚Äù menu, then we should use the following code: <br><pre> <code class="hljs rust">#include &lt;coreplugin/coreconstants.h&gt; #include &lt;coreplugin/actionmanager/actionmanager.h&gt; #include &lt;coreplugin/icore.h&gt; ... Core::ActionManager* am = Core::ICore::instance()-&gt;actionManager(); Core::ActionContainer* ac = am-&gt;actionContainer( Core::Constants::M_HELP );</code> </pre><br><h5>  3.3 Adding Menus and Menu Items </h5><br>  Let's see how we can add new menu items.  To do this, let's return to our existing initialize () function and take a closer look at its implementation. <br><pre> <code class="hljs php">bool DoNothingPlugin::initialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;arguments, QString *errorString) { Q_UNUSED(arguments) Q_UNUSED(errorString) Core::ActionManager *am = Core::ICore::instance()-&gt;actionManager(); QAction *action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QAction(tr(<span class="hljs-string"><span class="hljs-string">"DoNothing action"</span></span>), this); Core::Command *cmd = am-&gt;registerAction(action, Constants::ACTION_ID, Core::Context(Core::Constants::C_GLOBAL)); cmd-&gt;setDefaultKeySequence(QKeySequence(tr(<span class="hljs-string"><span class="hljs-string">"Ctrl+Alt+Meta+A"</span></span>))); connect(action, SIGNAL(triggered()), this, SLOT(triggerAction())); Core::ActionContainer *menu = am-&gt;createMenu(Constants::MENU_ID); menu-&gt;menu()-&gt;setTitle(tr(<span class="hljs-string"><span class="hljs-string">"DoNothing"</span></span>)); menu-&gt;addAction(cmd); am-&gt;actionContainer(Core::Constants::M_TOOLS)-&gt;addMenu(menu); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  The code shown here is now becoming much more understandable.  So, we get a pointer to ActionManager, then create a new menu item and assign it a shortcut.  After that we create our own menu and add the item we just created to it.  It is also worth noting that now ACTION_ID and MENU_ID are useful to us. <br><br>  Next we get a pointer to the ActionContainer menu of tools (M_TOOLS) and add our menu to it. <br>  In addition, our keyboard shortcut was entered in the registry of all keyboard shortcuts of the application and is available to change in its settings: <br><img src="https://habrastorage.org/getpro/habr/post_images/aba/fea/2bd/abafea2bdbf472f510fc6985daeecd2b.jpg" alt="image"><br>  It should also be noted that you can add your menus anywhere.  For example, if we would need to add our menu to the main menu bar, then instead of the constant M_TOOLS we would use the constant MENU_BAR.  And in order to position our menu inside another menu, we would have to pass an additional parameter to the function addMenu () <br><pre> <code class="hljs lisp">am-&gt;actionContainer(<span class="hljs-name"><span class="hljs-name">Core</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:Constants</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:MENU_BAR</span></span>)-&gt;addMenu(<span class="hljs-name"><span class="hljs-name">am-&gt;actionContainer</span></span>(<span class="hljs-name"><span class="hljs-name">Core</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:Constants</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:M_HELP</span></span>), menu)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><h5>  3.3 Responding to menu item events </h5><br>  Since menu items are instances of the QAction class, we can use the signals sent by these objects, such as triggered (bool) or toggled (bool), and respond to them by creating slots.  An example again can be taken from our code above: <br><pre> <code class="hljs css">... <span class="hljs-selector-tag"><span class="hljs-selector-tag">connect</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">action</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SIGNAL</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">triggered</span></span>()), <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLOT</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">triggerAction</span></span>())); ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DoNothingPlugin</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::triggerAction()</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">QMessageBox</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">information</span></span>(Core::ICore::instance()<span class="hljs-built_in"><span class="hljs-built_in">-</span></span>&gt;<span class="hljs-built_in"><span class="hljs-built_in">mainWindow</span></span>(), <span class="hljs-built_in"><span class="hljs-built_in">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"Action triggered"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">tr</span></span>(<span class="hljs-string"><span class="hljs-string">"This is an action from DoNothing."</span></span>)); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/6fc/3ce/862/6fc3ce86215e77acf61b781c7feab091.jpg" alt="image"><br><br><h4>  4 Qt Creator Architecture </h4><br>  As a rule, each large enough system has its own architecture, having understood that, we will be able to move on much faster.  Qt Creator is simple and in this part we will try to understand its basic architecture, after which we will continue to deal with writing extensions. <br><br><h5>  4.1 Qt Creator Core </h5><br>  The Qt Creator core is just an extension manager.  All functionality is provided through them. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/ba8/420/b19ba8420180495aa80e272cfc490b8f.jpg" alt="image"></div><br><br>  The basic functionality of Qt Creator is implemented in the Core extension (Core :: ICore).  We have already touched on this expansion in the previous part.  In the following, we will refer to this base extension as Core.  Extension Manager (ExtensionSystem :: PluginManager) provides simple features for the interaction of extensions, through hooks, which some extensions can provide to others. <br><br><h5>  4.2 What is an extension? </h5><br>  At the system level, an extension is a shared library (DLL on Windows, SO on Linux, DYLIB on Mac).  From the developer‚Äôs point of view, an extension is a module that: <br><ol><li>  Inherits and implements the ExtensionSystem :: IPlugin interface.  Further in the text we will call a similar class ‚ÄúPlugin Class‚Äù. </li><li>  Exports the Plugin Class using the Q_EXPORT_PLUGIN macro. </li><li>  Provides a file (Plugin Name) .pluginspec containing metadata about the extension. </li><li>  Provides one or more objects that other extensions may be interested in using. </li><li>  Checks the availability of one or more objects provided by other extensions. </li></ol><br>  We have already met the first three points, but nowhere have we stopped at the last two. <br><br><h6>  4.2.1 How to get a list of available objects? </h6><br>  Available objects are stored in the object pool inside the PluginManager.  The allObjects () method from the PluginManager returns the entire pool of objects as a list of pointers to a QObject.  Below is the code with which we could print a list of available objects for printing: <br><pre> <code class="hljs rust">#include &lt;extensionsystem/pluginmanager.h&gt; ExtensionSystem::PluginManager *pm = ExtensionSystem::PluginManager::instance(); QList&lt;QObject*&gt; objects = pm-&gt;allObjects(); QListWidget* listWidget = new QListWidget; Q_FOREACH(QObject* obj, objects) { QString objInfo = QString(<span class="hljs-string"><span class="hljs-string">"%1 (%2)"</span></span>) .arg(obj-&gt;objectName()) .arg(obj-&gt;metaObject()-&gt;className()); listWidget-&gt;addItem(objInfo); } listWidget-&gt;show();</code> </pre><br>  Thus, after executing this part of the code, we will see a long list of available objects: <br><img src="https://habrastorage.org/getpro/habr/post_images/6f8/b15/6f0/6f8b156f009852493f7c3786956a3993.jpg" alt="image"><br><br>  From the names in the list it can be concluded that the objects are provided by various extensions.  I think now we can give a more precise definition of the term "object provided": <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A supplied (exported) object is an instance of a QObject class (or its descendants) provided by one extension and available to other extensions through a pool of objects.</font></font></i> <br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2.2 How to export your object to the list of available? </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For this purpose there are three ways: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPlugin :: addAutoReleasedObject (QObject *) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPlugin :: addObject (QObject *) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PluginManager :: addObject (QObject *) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The methods IPlugin :: addObject () and IPlugin :: addAutoReleasedObject () essentially call the PluginManager :: addObject () method. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPlugin methods are created just for convenience. </font><font style="vertical-align: inherit;">Extensions are recommended to use them to add objects. </font><font style="vertical-align: inherit;">The differences between the addAutoReleasedObject () and addObject () methods are that the objects added through the first method will be automatically destroyed and removed from the pool of available objects (in the reverse order) when the extension is destroyed. </font><font style="vertical-align: inherit;">In addition, you can call the IPlugin :: removeObject (QObject *) method at any time to manually remove an object from the pool of available ones.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2.3 Which objects to export? </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extensions can provide (export) any objects, but usually exported objects are structured according to a functional feature. </font><font style="vertical-align: inherit;">Other Qt Creator functionality is provided via exported interfaces.</font></font> Here are some of them: <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: INavigationWidgetFactory </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IEditor </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IOptionsPage </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IOutputPane </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IWizard </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ developers are accustomed to the fact that interfaces are usually called classes, all methods of which are purely virtual and public. </font><font style="vertical-align: inherit;">In Qt Creator, interfaces are descendants of a QObject that have one or more purely virtual methods. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the extension has objects that implement an interface, then such an object should be exported. </font><font style="vertical-align: inherit;">For example, if an extension exports an implementation of the INavigationWidgetFactory interface, Core will automatically pick up the widget created in this implementation to display it on the navigation bar. </font><font style="vertical-align: inherit;">As an example, consider adding a simple QTableWidget to the navigation bar through the implementation of the Core :: INavigationWidgetFactory interface.</font></font><br><pre> <code class="hljs kotlin">#include &lt;coreplugin/inavigationwidgetfactory.h&gt; #include &lt;QTableWidget&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavWidgetFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public Core::INavigationWidgetFactory { public: NavWidgetFactory</span></span></span></span>() { } ~NavWidgetFactory() { } Core::NavigationView createWidget() { Core::NavigationView view; view.widget = new QTableWidget(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view; } QString displayName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Spreadsheet"</span></span>; } int priority() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } QString id() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Spreadsheet"</span></span>; } }; bool DoNothingPlugin::initialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;arguments, QString *errorString) { ... <span class="hljs-comment"><span class="hljs-comment">// Provide a navigation widget factory. // Qt Creator's navigation widget will automatically // hook to our INavigationWidgetFactory implementation, which // is the NavWidgetFactory class, and show the QTableWidget // created by it in the navigation panel. addAutoReleasedObject(new NavWidgetFactory); return true; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And here is the result: </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/8b7/bbd/044/8b7bbd0443c36254609c362569683491.jpg" alt="image"><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2.4 Notifications about newly exported objects. </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the PluginManager :: addObject () method is called, the PluginManager sends an objectAdded signal (QObject *). </font><font style="vertical-align: inherit;">This signal can be used to track which objects were newly added during Qt Creator operation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is obvious that an extension can process this signal only after connecting it to any of its slots, and therefore, it will receive notifications only about objects added after its full initialization has been completed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, the slot connected to this signal monitors one or several interfaces. </font><font style="vertical-align: inherit;">For example, this might be the code that follows the appearance of a new object that implements the INavigationWidgetFactory interface.</font></font><br><pre> <code class="hljs ruby">void Plugin::slotObjectAdded(QObject * obj) { INavigationWidgetFactory *factory = Aggregation::query&lt;INavigationWidgetFactory&gt;(obj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(factory) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> use it here... } }</code> </pre><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2.4 Object Search </font></font></h6><br>        ,   .         : <br><ul><li>  PluginManager::allObjects(),     . </li><li>    PluginManager::objectAdded(),        . </li></ul><br>   ,     .      ?      PluginManager::getObjects().  ,       ,   INavigationWidgetFactory,      : <br><pre> <code class="hljs php">ExtensionSystem::PluginManager* pm = ExtensionSystem::PluginManager::instance(); QList&lt;Core::INavigationWidgetFactory*&gt; objects = pm-&gt;getObjects&lt;Core::INavigationWidgetFactory&gt;();</code> </pre><br><h6> 4.3   </h6><br>         QObject   . ,  Qt Creator        <br><pre> <code class="hljs vbscript">#include &lt;aggregation/aggregate.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Interface1 : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Interface1() { } ~Interface1() { } }; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Interface2 : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Interface2() { } ~Interface2() { } }; Aggregation::Aggregate bundle; bundle.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Interface1); bundle.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Interface2);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the bundle object contains pointers to two objects. </font><font style="vertical-align: inherit;">To access the interfaces, we can use the following code:</font></font><br><pre> <code class="hljs xml">Interface1* iface1Ptr = Aggregation::query<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Interface1</span></span></span><span class="hljs-tag">&gt;</span></span>( &amp;bundle ); Interface2* iface2Ptr = Aggregation::query<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Interface2</span></span></span><span class="hljs-tag">&gt;</span></span>( &amp;bundle );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can include multiple interfaces in one bundle: </font></font><br><pre> <code class="hljs pgsql">Aggregation::<span class="hljs-keyword"><span class="hljs-keyword">Aggregate</span></span> bundle; bundle.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface1); bundle.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface2); bundle.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface1); bundle.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface1); QList&lt;Interface1*&gt; iface1Ptrs = Aggregation::query_all&lt;Interface1&gt;( &amp;bundle );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And also delete both the added interfaces and the bundle itself: </font></font><br><pre> <code class="hljs pgsql">Aggregation::<span class="hljs-keyword"><span class="hljs-keyword">Aggregate</span></span>* bundle = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Aggregation::<span class="hljs-keyword"><span class="hljs-keyword">Aggregate</span></span>; bundle-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface1); bundle-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Interface2); Interface1* iface1Ptr = Aggregation::query&lt;Interface1&gt;(bundle); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> iface1Ptr; // deletes the bundle <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> objects <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> it // same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bundle</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now it may not be clear why there is a need to mention Aggregation :: Aggregate objects here, but in the following parts it will also be useful to us to simplify the implementation and structuring of the described examples. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 Adding a new editor (Editor) </font></font></h4><br>    (  Core Plugin), Qt Creator ‚Äî      . ,    ,    :         ,      C++    .     UI (Qt Designer), JS/QML,   QRC,   (PRO/PRI),         EXE/DLL/SO. <br><br>     ,           HTML.     ,   HTML-      . <br><br><h5> 5.1     </h5><br>     ,  : <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement the Core :: IPlugin class, which exports the Core :: IEditorFactory interface implementation. </font><font style="vertical-align: inherit;">We learned this earlier.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement the Core :: IEditorFactory interface. </font><font style="vertical-align: inherit;">This interface will allow you to create the necessary editor, depending on the mime type passed to it.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement the file editor itself, through the implementation of the Core :: IEditor interface. </font><font style="vertical-align: inherit;">This implementation will provide a widget that allows you to edit files depending on their type (for example: HTML, ODF and others). </font><font style="vertical-align: inherit;">The editor must have access to the file that is currently being edited / displayed.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the Core :: IFile interface, which will help in the work on loading / saving files on the hard disk. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we will consider each of these interfaces. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.1.1 Interface Core :: IFile. </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This interface is an abstract layer between working with files and the user interface. </font><font style="vertical-align: inherit;">It provides purely virtual methods for loading / saving files, specifying the file name, also helps the application determine the mime type of the file and get the values ‚Äã‚Äãof certain flags (for example, ‚Äúmodified‚Äù and ‚Äúread-only‚Äù). </font><font style="vertical-align: inherit;">This interface is declared in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / plugins / coreplugin / ifile.h file</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question arises - why do I need an IFile if a QFile already exists? </font><font style="vertical-align: inherit;">Here is the answer:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IFile loads data straight into Core :: IEditor, unlike QFile, which loads a file into QByteArray </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFile can send the modified () signal when the user starts editing the file in the editor, but the content remains the same. </font><font style="vertical-align: inherit;">QFile sends bytesWritten () only after the contents of the disk have been changed.</font></font></li><li> IFile   ,             ‚Äî   . QFile     . </li></ul><br><h6> 5.1.2  Core::IEditor. </h6><br>         .    <b>src/plugins/coreplugin/editormanager/ieditor.h</b> <br><br> Core::IEditor       : <br><ul><li>   ( Core::IEditor::widget()),  Qt Creator      . </li><li>  Core::IEditor::file(),    Core::IFile,  Qt Creator      . </li><li>   ,  Qt Creator      . </li><li>      (Core::IEditor::currentLine()  Core::IEditor::currentColumn()). </li><li> ,      , </li></ul><br>    ,   . <br><img src="https://habrastorage.org/getpro/habr/post_images/b0d/8e3/cff/b0d8e3cffbf99810ea4074c86ed102df.jpg" alt="image"><br><br><h6> 5.1.3  Core::IEditorFactory </h6><br>          Core::IEditor   mime-.   src/plugins/coreplugin/editormanager/ieditorfactory.h. <br><br>  IEditorFactory::mimeType()  mime-  .  IEditorFactory::createEditor()   . <br><br><h6> 5.1.4  Core::MimeDatabase </h6><br>  Core::MimeDatabase     Qt Creator mime-.     mime-  .  Example: <br><pre> <code class="hljs rust">#include &lt;coreplugin/mimedatabase.h&gt; Core::ICore* core = Core::ICore::instance(); Core::MimeDatabase* mdb = core-&gt;mimeDatabase(); Core::MimeType type1 = mdb-&gt;findByFile( QFileInfo(<span class="hljs-string"><span class="hljs-string">"C:/Temp/sample.html"</span></span>) ); qDebug(<span class="hljs-string"><span class="hljs-string">"File Type for sample.html = %s"</span></span>, qPrintable(type1.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>())); Core::MimeType type2 = mdb-&gt;findByFile( QFileInfo(<span class="hljs-string"><span class="hljs-string">"C:/Temp/TextEdit/Main.cpp"</span></span>) ); qDebug(<span class="hljs-string"><span class="hljs-string">"File Type for Main.cpp = %s"</span></span>, qPrintable(type2.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>())); Core::MimeType type3 = mdb-&gt;findByFile( QFileInfo(<span class="hljs-string"><span class="hljs-string">"C:/Temp/TextEdit/TextEdit.pro"</span></span>) ); qDebug(<span class="hljs-string"><span class="hljs-string">"File Type for TextEdit.pro = %s"</span></span>, qPrintable(type3.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>()));</code> </pre><br>  : <br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">File</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sample.html = <span class="hljs-literal"><span class="hljs-literal">text</span></span>/plain <span class="hljs-keyword"><span class="hljs-keyword">File</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Main.cpp = <span class="hljs-literal"><span class="hljs-literal">text</span></span>/x-c++src <span class="hljs-keyword"><span class="hljs-keyword">File</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TextEdit.pro = <span class="hljs-literal"><span class="hljs-literal">text</span></span>/plain</code> </pre><br>   Core::MimeDatabase   ,     ,  -  mime- .        mime-  : <br><ol><li>    ( -&gt; ). </li><li> Qt Creator  Core::MimeDatabase   mime-type  . </li><li> Qt Creator   Core::IEditorFactory        mime-. </li><li> Qt Creator   Core::IEditorFactory   Core::IEditor. </li><li> ,  Core::IEditor::widget()    . </li><li>   Core::IEditor::open()   ,    . </li></ol><br><h6> 5.1.5   mime- </h6><br>       ,    mime-,      Core::MimeDatabase.     ,     ,   XML-.  ,    text/html mime-      *.html.   XML       <b>text-html-mimetype.xml</b> : <br><pre> <code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mime-info</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'http://www.freedesktop.org/standards/shared-mime-info'</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mime-type</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/html"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sub-class-of</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/plain"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">comment</span></span></span><span class="hljs-tag">&gt;</span></span>HTML File<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">comment</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">glob</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pattern</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.html"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mime-type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">mime-info</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>      mime-   Core::MimeDatabase::addMimeTypes(): <br><pre> <code class="hljs rust">Core::ICore* core = Core::ICore::instance(); Core::MimeDatabase* mdb = core-&gt;mimeDatabase(); QString errMsg; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> success = mdb-&gt;addMimeTypes(<span class="hljs-string"><span class="hljs-string">"text-html-mimetype.xml"</span></span>, errMsg);</code> </pre><br>      ‚Äî Qt Creator      *.html   mime- text/html. <br><br><h5> 5.2  Qt Creator  HTML. </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, having stopped a little on the theory, we can start creating an editor that supports viewing / editing HTML files. </font><font style="vertical-align: inherit;">To implement our plans, we need to create several classes:</font></font><br><table><tbody><tr><td>  Class </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> base class </font></font></td><td>  Description </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HtmlEditorWidget </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> QTabWidget </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This will be a widget with two tabs, the first one will show the final result, and the second will show the source of the document. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Htmlfile </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IFile </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implementing the IFile interface for HtmlEditorWidget. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Htmleditor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IEditor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implements IEditor to control HtmlEditorWidget and its interaction with HtmlFile. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HtmlEditorFactory </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IEditorFactory </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implements IEditorFactory to create IEditor instances based on the text / html mime type. </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HtmlEditorPlugin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core :: IPlugin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implements IPlugin to associate all of the above with Qt Creator. </font></font></td></tr></tbody></table><br> ,     Qt Creator,     HTMLEditor   . <br><br><h6> 5.2.1  HTML Editor Widget </h6><br>  , Qt Creator       HTML-.    - ,       ,    ‚Äî  . <br><pre> <code class="hljs kotlin">#ifndef HTMLEDITORWIDGET_H #define HTMLEDITORWIDGET_H #include &lt;QTabWidget&gt; #include &lt;QWebView&gt; #include &lt;QPlainTextEdit&gt; struct HtmlEditorWidgetData { QWebView *webView; QPlainTextEdit *textEdit; bool modified; QString path; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HtmlEditorWidget</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public QTabWidget { Q_OBJECT public: HtmlEditorWidget</span></span></span></span>(QWidget* parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); ~HtmlEditorWidget(); void setContent(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; ba, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; path=QString()); QByteArray content() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString title() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> slots: void slotCurrentTabChanged(int tab); void slotContentModified(); signals: void contentModified(); void titleChanged(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp;); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HtmlEditorWidgetData* d; }; #endif <span class="hljs-comment"><span class="hljs-comment">// HTMLEDITORWIDGET_H</span></span></code> </pre><br>      QWebView  QPlainTextEdit,             : <br><ol><li>        ,  QWeBView    </li><li>    ,     </li><li>        QWebView. </li></ol><br><pre> <code class="hljs erlang-repl">#include <span class="hljs-string"><span class="hljs-string">"htmleditorwidget.h"</span></span> HtmlEditorWidget::HtmlEditorWidget(QWidget* parent) :QTabWidget(parent) { d = new HtmlEditorWidgetData; d-&gt;webView = new QWebView; d-&gt;textEdit = new QPlainTextEdit; addTab(d-&gt;webView, <span class="hljs-string"><span class="hljs-string">"Preview"</span></span>); addTab(d-&gt;textEdit, <span class="hljs-string"><span class="hljs-string">"Source"</span></span>); //setTabPosition(QTabWidget::South); setTabShape(QTabWidget::Triangular); d-&gt;textEdit-&gt;setFont( QFont(<span class="hljs-string"><span class="hljs-string">"Courier"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) ); connect(this, SIGNAL(currentChanged(int)), this, SLOT(slotCurrentTabChanged(int))); connect(d-&gt;textEdit, SIGNAL(textChanged()), this, SLOT(slotContentModified())); connect(d-&gt;webView, SIGNAL(titleChanged(QString)), this, SIGNAL(titleChanged(QString))); d-&gt;modified = false; }</code> </pre><br>     : <br><pre> <code class="hljs cpp">HtmlEditorWidget::~HtmlEditorWidget() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> d; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The setContent () method sets the contents of webView and textEdit. </font><font style="vertical-align: inherit;">And the content () method returns the content accordingly. </font><font style="vertical-align: inherit;">The title () method returns a string that will be displayed in the list of open files. </font><font style="vertical-align: inherit;">Well, the last two methods handle the connections with signals created in the constructor.</font></font><br><pre> <code class="hljs php">void HtmlEditorWidget::setContent(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; ba, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; path) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(path.isEmpty()) d-&gt;webView-&gt;setHtml(ba); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> d-&gt;webView-&gt;setHtml(<span class="hljs-string"><span class="hljs-string">"file:///"</span></span> + path); d-&gt;textEdit-&gt;setPlainText(ba); d-&gt;modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; d-&gt;path = path; } QByteArray HtmlEditorWidget::content() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QString htmlText = d-&gt;textEdit-&gt;toPlainText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> htmlText.toAscii(); } QString HtmlEditorWidget::title() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;webView-&gt;title(); } void HtmlEditorWidget::slotCurrentTabChanged(int tab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tab == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; d-&gt;modified) setContent( content(), d-&gt;path ); } void HtmlEditorWidget::slotContentModified() { d-&gt;modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; emit contentModified(); }</code> </pre><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.2.2 Core :: IFile Implementation </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement this interface in the HtmlFile class. </font><font style="vertical-align: inherit;">This class will implement several virtual methods from Core :: IFile and will be able to set the modified flag to reflect the status of the document being edited.</font></font><br><pre> <code class="hljs go">#ifndef HTMLFILE_H #define HTMLFILE_H #include &lt;coreplugin/ifile.h&gt; #include <span class="hljs-string"><span class="hljs-string">"htmleditorconstants.h"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HtmlFileData; class HtmlEditor; class HtmlEditorWidget; class HtmlFile : public Core::IFile { Q_OBJECT public: HtmlFile(HtmlEditor* editor, HtmlEditorWidget* editorWidget); ~HtmlFile(); void setModified(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> val=<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isModified() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString mimeType() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> save(QString *errorString, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> autoSave); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reload(QString *errorString, ReloadFlag flag, ChangeType <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>); void rename(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;newName); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName); void setFilename(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; filename); QString fileName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString defaultPath() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString suggestedFileName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString fileFilter() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString fileExtension() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isReadOnly() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSaveAsAllowed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; void modified(ReloadBehavior* behavior); protected slots: void modified() { setModified(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } private: HtmlFileData* d; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HtmlFileData { HtmlFileData() : mimeType(HTMLEditor::Constants::C_HTMLEDITOR_MIMETYPE), editorWidget(<span class="hljs-number"><span class="hljs-number">0</span></span>), editor(<span class="hljs-number"><span class="hljs-number">0</span></span>), modified(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString mimeType; HtmlEditorWidget* editorWidget; HtmlEditor* editor; QString fileName; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> modified; }; #endif <span class="hljs-comment"><span class="hljs-comment">// HTMLFILE_H</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the constructor, we simply set up the associations we need. </font><font style="vertical-align: inherit;">In the destructor we delete the private object.</font></font><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"htmlfile.h"</span></span> #include &lt;QFile&gt; #include &lt;QFileInfo&gt; #include <span class="hljs-string"><span class="hljs-string">"htmleditor.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"htmleditorwidget.h"</span></span> HtmlFile::HtmlFile(HtmlEditor* <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>, HtmlEditorWidget* editorWidget) : Core::IFile(<span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>) { d = new HtmlFileData; d-&gt;<span class="hljs-keyword"><span class="hljs-keyword">editor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">editor</span></span>; d-&gt;editorWidget = editorWidget; } HtmlFile::~HtmlFile() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> d; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The setModified () method sets the modified flag and sends the changed () signal. </font></font><br><pre> <code class="hljs rust">void HtmlFile::setModified(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d-&gt;modified == val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;modified = val; emit changed(); } <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> HtmlFile::isModified() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;modified; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From here we return the mime-type of this class. </font></font><br><pre> <code class="hljs php">QString HtmlFile::mimeType() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;mimeType; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The save () method is called when you select the menu item File -&gt; Save or by using the keyboard shortcut Ctrl + S. </font><font style="vertical-align: inherit;">It saves the contents of the HtmlEditorWidget (from textEdit) in the current associated file. </font><font style="vertical-align: inherit;">then the modified flag is set to false.</font></font><br><pre> <code class="hljs rust"><span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> HtmlFile::save(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName) { QFile file(fileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.open(QFile::WriteOnly)) { d-&gt;fileName = fileName; QByteArray content = d-&gt;editorWidget-&gt;content(); file.write(content); setModified(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The open () method is called when you select File -&gt; Open. </font><font style="vertical-align: inherit;">or Ctrl + O. </font><font style="vertical-align: inherit;">Loads the file and passes it to the setContent () function of our editing widget.</font></font><br><pre> <code class="hljs php">bool HtmlFile::open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName) { QFile file(fileName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.open(QFile::ReadOnly)) { d-&gt;fileName = fileName; QString path = QFileInfo(fileName).absolutePath(); d-&gt;editorWidget-&gt;setContent(file.readAll(), path); d-&gt;editor-&gt;setDisplayName(d-&gt;editorWidget-&gt;title()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } bool HtmlFile::reload(QString *errorString, ReloadFlag flag, ChangeType type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> open(d-&gt;fileName); } void HtmlFile::rename(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;newName) { QFile file(d-&gt;fileName); file.rename(newName); setFilename(newName); } void HtmlFile::setFilename(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; filename) { d-&gt;fileName = filename; } QString HtmlFile::fileName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;fileName; } QString HtmlFile::defaultPath() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); } QString HtmlFile::suggestedFileName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); } QString HtmlFile::fileFilter() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); } QString HtmlFile::fileExtension() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); } bool HtmlFile::isReadOnly() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } bool HtmlFile::isSaveAsAllowed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } void HtmlFile::modified(ReloadBehavior* behavior) { Q_UNUSED(behavior); }</code> </pre><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.2.3 Core :: IEditor Implementation </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We implement IEditor to allow Qt Creator to use our html widget and associate it with HtmlFile. </font></font><br><pre> <code class="hljs rust">#ifndef HTMLEDITOR_H #define HTMLEDITOR_H #include &lt;coreplugin/editormanager/ieditor.h&gt; #include &lt;QToolBar&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HtmlEditorData</span></span></span></span>; class HtmlFile; class HtmlEditorWidget; class HtmlEditor : public Core::IEditor { Q_OBJECT public: HtmlEditor(HtmlEditorWidget* editorWidget); ~HtmlEditor(); <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> createNew(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; <span class="hljs-comment"><span class="hljs-comment">/*contents*/</span></span> = QString()); QString displayName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; IEditor* duplicate(QWidget* <span class="hljs-comment"><span class="hljs-comment">/*parent*/</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> duplicateSupported() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Core::IFile* file(); <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> isTemporary() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* kind() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; fileName = QString()) ; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> restoreState(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; <span class="hljs-comment"><span class="hljs-comment">/*state*/</span></span>); QByteArray saveState() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; void setDisplayName(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;title); QToolBar* toolBar(); <span class="hljs-comment"><span class="hljs-comment">// From Core::IContext QWidget* widget(); Core::Context context() const; QString id() const; protected slots: void slotTitleChanged(const QString&amp; title) { setDisplayName(title); } private: HtmlEditorData* d; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The HtmlEditorData object stores pointers to HtmlEditorWidget and HtmlFile objects, the displayName variable is used to store the name of the editor displayed to the user. </font></font><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HtmlEditorData</span></span></span><span class="hljs-class"> {</span></span> HtmlEditorData() : editorWidget(<span class="hljs-number"><span class="hljs-number">0</span></span>), file(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } HtmlEditorWidget* editorWidget; QString displayName; HtmlFile* file; Core::Context context; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// HTMLEDITOR_H</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The constructor initializes itself, creates an instance of HtmlFile, and associates between all three objects. </font><font style="vertical-align: inherit;">destructor by tradition only removes the private object.</font></font><br><pre> <code class="hljs erlang-repl">#include <span class="hljs-string"><span class="hljs-string">"htmleditor.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"htmlfile.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"htmleditorwidget.h"</span></span> HtmlEditor::HtmlEditor(HtmlEditorWidget* editorWidget) : Core::IEditor(editorWidget) { d = new HtmlEditorData; d-&gt;editorWidget = editorWidget; d-&gt;file = new HtmlFile(this, editorWidget); //Core::UniqueIDManager* uidm = Core::UniqueIDManager::instance(); d-&gt;context = *(new Core::Context(HTMLEditor::Constants::C_HTMLEDITOR)); //&lt;&lt; uidm-&gt;uniqueIdentifier(HTMLEditor::Constants::C_HTMLEDITOR); connect(d-&gt;editorWidget, SIGNAL(contentModified()), d-&gt;file, SLOT(modified())); connect(d-&gt;editorWidget, SIGNAL(titleChanged(QString)), this, SLOT(slotTitleChanged(QString))); connect(d-&gt;editorWidget, SIGNAL(contentModified()), this, SIGNAL(changed())); } HtmlEditor::~HtmlEditor() { delete d; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Three simple functions for mapping. </font></font><br><pre> <code class="hljs php">QWidget* HtmlEditor::widget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;editorWidget; } Core::Context HtmlEditor::context() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;context; } Core::IFile* HtmlEditor::file() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;file; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The createNew () method resets the contents of HtmlEditorWidget and HtmlFile. </font></font><br><pre> <code class="hljs rust"><span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> HtmlEditor::createNew(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; contents) { Q_UNUSED(contents); d-&gt;editorWidget-&gt;setContent(QByteArray()); d-&gt;file-&gt;setFilename(QString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The open () method passes the name of the file to open to HtmlFile. </font></font><br><pre> <code class="hljs rust"><span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> HtmlEditor::open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;file-&gt;open(fileName); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Returns the type of editor. </font></font><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* HtmlEditor::kind() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTMLEditor::Constants::C_HTMLEDITOR; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> displayName is used to display the file name in the ComboBox. </font></font><br><pre> <code class="hljs php">QString HtmlEditor::displayName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;displayName; } void HtmlEditor::setDisplayName(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; title) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d-&gt;displayName == title) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;displayName = title; emit changed(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The remaining methods are not so important. </font></font><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HtmlEditor::duplicateSupported() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Core::IEditor* HtmlEditor::duplicate(QWidget* parent) { Q_UNUSED(parent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } QByteArray HtmlEditor::saveState() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QByteArray(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HtmlEditor::restoreState(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray&amp; state) { Q_UNUSED(state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } QToolBar* HtmlEditor::toolBar() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HtmlEditor::isTemporary() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } QString HtmlEditor::id() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); }</code> </pre><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.2.4 Implementing Core :: IEditorFactory </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The HtmlEditorFactory class will implement the Core :: IEditorFactory interface. </font></font><br><pre> <code class="hljs rust">#ifndef HTMLEDITORFACTORY_H #define HTMLEDITORFACTORY_H #include &lt;coreplugin/editormanager/ieditorfactory.h&gt; #include &lt;QStringList&gt; #include <span class="hljs-string"><span class="hljs-string">"htmleditorplugin.h"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HtmlEditorFactoryData</span></span></span></span>; class HtmlEditorFactory : public Core::IEditorFactory { Q_OBJECT public: HtmlEditorFactory(HTMLEditor::Internal::HTMLEditorPlugin* owner); ~HtmlEditorFactory(); QStringList mimeTypes() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; QString kind() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Core::IEditor* createEditor(QWidget* parent); Core::IFile* open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;fileName); private: HtmlEditorFactoryData* d; }; #endif <span class="hljs-comment"><span class="hljs-comment">// HTMLEDITORFACTORY_H</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The HtmlEditorFactoryData structure contains the private data of the HtmlEditorFactory class. </font><font style="vertical-align: inherit;">The constructor of this structure initializes it with the mime type contained in the HTMLEditor :: Constants :: C_HTMLEDITOR_MIMETYPE. </font><font style="vertical-align: inherit;">It also initializes the editor type with the value HTMLEditor :: Constants :: C_HTMLEDITOR. </font><font style="vertical-align: inherit;">All constants are declared in the htmleditorconstants.h file.</font></font><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"htmleditorfactory.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"htmleditorconstants.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/editormanager/editormanager.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"htmleditorwidget.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">QStringList</span></span>&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;coreplugin/editormanager/ieditor.h&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"htmleditor.h"</span></span> struct <span class="hljs-type"><span class="hljs-type">HtmlEditorFactoryData</span></span> { <span class="hljs-type"><span class="hljs-type">HtmlEditorFactoryData</span></span>() : kind(<span class="hljs-type"><span class="hljs-type">HTMLEditor</span></span>::<span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">C_HTMLEDITOR</span></span>) { mimeTypes &lt;&lt; <span class="hljs-type"><span class="hljs-type">QString</span></span>(<span class="hljs-type"><span class="hljs-type">HTMLEditor</span></span>::<span class="hljs-type"><span class="hljs-type">Constants</span></span>::<span class="hljs-type"><span class="hljs-type">C_HTMLEDITOR_MIMETYPE</span></span>); } <span class="hljs-type"><span class="hljs-type">QString</span></span> kind; <span class="hljs-type"><span class="hljs-type">QStringList</span></span> mimeTypes; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, a drop of simple familiar methods. </font></font><br><pre> <code class="hljs php">HtmlEditorFactory::HtmlEditorFactory(HTMLEditor::Internal::HTMLEditorPlugin* owner) :Core::IEditorFactory(owner) { d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlEditorFactoryData; } HtmlEditorFactory::~HtmlEditorFactory() { delete d; } QStringList HtmlEditorFactory::mimeTypes() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;mimeTypes; } QString HtmlEditorFactory::kind() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;kind; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The open () method transfers the file name to the editors' manager, which in turn either creates and opens a new editor, or opens one of the existing ones. </font></font><br><pre> <code class="hljs php">Core::IFile* HtmlEditorFactory::open(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString&amp; fileName) { Core::EditorManager* em = Core::EditorManager::instance(); Core::IEditor* iface = em-&gt;openEditor(fileName, d-&gt;kind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iface ? iface-&gt;file() : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This method returns an instance of the HtmlEditor class. </font></font><br><pre> <code class="hljs php">Core::IEditor* HtmlEditorFactory::createEditor(QWidget* <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) { HtmlEditorWidget* editorWidget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlEditorWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlEditor(editorWidget); }</code> </pre><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.2.5 Main extension class </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement the HtmlEditorPlugin class using the knowledge that we gained in the second part. </font><font style="vertical-align: inherit;">True, we‚Äôll change the initialize () method a bit.</font></font><br><pre> <code class="hljs php">bool HTMLEditorPlugin::initialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;arguments, QString *errorString) { Q_UNUSED(arguments) Q_UNUSED(errorString) Core::ICore* core = Core::ICore::instance(); Core::MimeDatabase* mdb = core-&gt;mimeDatabase(); QString *errMsg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mdb-&gt;addMimeTypes(<span class="hljs-string"><span class="hljs-string">":/text-html-mimetype.xml"</span></span>, errMsg)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; addAutoReleasedObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlEditorFactory(this)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 Adding Sidebar </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The navigation bar in Qt Creator is an area that may contain components such as: </font></font><br><ul><li>  Projects </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Open documents </font></font></li><li>  Bookmarks </li><li>  File system </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Class overview </font></font></li><li>  Overview </li><li>  Type hierarchy </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> other... </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we can simultaneously use not one, but several navigation bars. </font></font><br><img src="http://cs11465.vkontakte.ru/u13577027/139138529/x_a4bd41d0.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember, we have already tried to add a nameplate in one of the previous sections to the navigation bar? </font><font style="vertical-align: inherit;">Now we will do almost the same thing, but we will complicate the task a little.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.1 Interface Core :: INavigationWidgetFactory </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, as far as we remember, to add a new navigation bar, we need to create our own implementation of the Core :: INavigationWidgetFactory interface, located in the plugins / corelib / inavigationwidgetfactory.h file. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.2 Preparing the widget for the panel </font></font></h5><br>     Qt Creator.     FTPBrowser. ,  ,       .      <a href="http://blog.vcreatelogic.com/2009/07/ftpdirmodel-a-qabstractitemmodel-implementation-for-browsing-ftp-directories/"></a> ,    FtpDirModel. <br><br>              : <br><img src="http://cs11465.vkontakte.ru/u13577027/139138529/y_5652a62f.jpg" alt="image"><br>      FTP-   FTP Path   Go,    FTP     QTreeView   .       FTPBrowserForm.     ,         .     . <br><pre> <code class="hljs kotlin">#include &lt;coreplugin/inavigationwidgetfactory.h&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FtpViewNavigationWidgetFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public Core::INavigationWidgetFactory { public: FtpViewNavigationWidgetFactory</span></span></span></span>() { } ~FtpViewNavigationWidgetFactory() { } Core::NavigationView createWidget(); QString displayName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FTP View"</span></span>; } int priority() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } QString id() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Spreadsheet"</span></span>; } };</code> </pre><br>  createWidget()         .  displayName()     . <br><pre> <code class="hljs pgsql">Core::NavigationView FtpViewNavigationWidgetFactory::createWidget() { Core::NavigationView <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.widget = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FTPBrowserForm; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>; }</code> </pre><br>  Here's what we got: <br><img src="http://cs11465.vkontakte.ru/u13577027/139138529/y_06cc24cc.jpg" alt="image"><br><br><h5> 6.3      </h5><br>    /     Qt Creator.   ,   INavigationWidgetFactory     : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, QWidget *widget</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, QWidget *widget</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>    ,        .       : <br><pre> <code class="hljs php">void FtpViewNavigationWidgetFactory::saveSettings(int position, QWidget *widget) { FTPBrowserForm* ftpExp = qobject_cast&lt;FTPBrowserForm*&gt;(widget); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ftpExp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; QSettings *settings = Core::ICore::instance()-&gt;settings(); settings-&gt;setValue(<span class="hljs-string"><span class="hljs-string">"FtpView.URL"</span></span>, ftpExp-&gt;url().toString()); } void FtpViewNavigationWidgetFactory::restoreSettings(int position, QWidget *widget) { FTPBrowserForm* ftpExp = qobject_cast&lt;FTPBrowserForm*&gt;(widget); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ftpExp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; QSettings *settings = Core::ICore::instance()-&gt;settings(); QString urlStr = settings-&gt;value(<span class="hljs-string"><span class="hljs-string">"FtpView.URL"</span></span>).toString(); ftpExp-&gt;setUrl( QUrl(urlStr) ); }</code> </pre><br>   ,   ‚Äî      . <br><br> ‚Ä¶    ‚Ä¶     ‚Ä¶      =) </div><p>Source: <a href="https://habr.com/ru/post/135289/">https://habr.com/ru/post/135289/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135283/index.html">Wpbb3: wordpress integration and phpbb3 forum using curl</a></li>
<li><a href="../135284/index.html">ActionScript as a language for developing JS applications with jQuery and debager</a></li>
<li><a href="../135286/index.html">Microsoft Lync goes to mobile platforms, client review, server setup</a></li>
<li><a href="../135287/index.html">Algorithm winner AI Challenge 2011 (Ants)</a></li>
<li><a href="../135288/index.html">ICQ office</a></li>
<li><a href="../135290/index.html">Handling errors and crashes proprietary programs</a></li>
<li><a href="../135291/index.html">Centralized backup of Windows and * nix servers using Bacula</a></li>
<li><a href="../135292/index.html">How to develop a personal business automation system for 1 day</a></li>
<li><a href="../135293/index.html">Students from the University of Amsterdam (VU) play Tetris with an optical tweaser</a></li>
<li><a href="../135295/index.html">Member of the project Kickstarter is going to release triangular tablets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>