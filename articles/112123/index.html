<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Branching. What can be done with them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My last post caused a huge resonance. There were not many comments, but I received a lot of letters, and some readers even made open statements (thoug...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Branching. What can be done with them</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a05/c62/f28/a05c62f28ea237ae3b66943998c86d40.jpg" align="right">  My <a href="http://habrahabr.ru/blogs/cpp/110850/">last post</a> caused a huge resonance.  There were not many comments, but I received a lot of letters, and some readers even made <a href="http://cd-riper.livejournal.com/319899.html">open statements</a> (though, attacks on me personally and on Habr as a whole prevail, but there are also thoughts on the essence of the question).  Therefore, I decided to continue to write in the genre "my thoughts about the questions of a <a href="http://ya.ru/">well-known company</a> ."  With this post I will try to solve two problems: (i) answer the questions and objections of the readers of the previous post and (ii) push in a certain sense the philosophical thought about non-FIC programming.  There are quite a few letters, but those who are interested only in one of the posts may miss half. <br><br>  <b>And another</b> thing <b>:</b> this topic (like the last one) is not hitting anyone.  Just interesting to speculate about interesting issues.  There is no subtext, hint, challenge.  Paranoids and supporters of conspiracy theories will ask to relax. <br><br>  This time I would like to look at question <a href="">4</a> . <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is his code.  A little combed so that he was going to <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;stdexcept&gt; #include &lt;iostream&gt; class CodeGenerator { public: enum Lang {JAVA, C_PLUS_PLUS, PHP}; CodeGenerator(Lang language) { _language=language; } std::string generateCode() { switch(_language) { case JAVA: return std::string("Java: System.out.println(\"Hello world!\");"); case C_PLUS_PLUS: return std::string("C++: std::cout &lt;&lt; \"Hello world!\";"); } throw new std::logic_error("Bad language"); } std::string someCodeRelatedThing() // used in generateCode() { switch(_language) { case JAVA: return std::string("http://www.java.com/"); case C_PLUS_PLUS: return std::string("http://www.cplusplus.com/doc/tutorial/"); } throw new std::logic_error("Bad language"); } private: Lang _language; }; int main() { CodeGenerator cg(CodeGenerator::JAVA); std::cout &lt;&lt; cg.generateCode() &lt;&lt; "\tMore info: " &lt;&lt; cg.someCodeRelatedThing() &lt;&lt; std::endl; CodeGenerator ec(CodeGenerator::PHP); try { ec.generateCode(); } catch (std::logic_error * e) { std::cout &lt;&lt; "ERROR: " &lt;&lt; e-&gt;what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre> <br>  Let's outline what I want to get rid of here: <br><ul><li>  I would like <b>not to put all the languages ‚Äã‚Äãin one pile</b> .  If they are smashed, they will become easier to maintain, to survey with the eye, to test. </li><li>  It would <b>be</b> desirable to <b>get rid of multiple switch</b> .  They clutter up the code and all of them must be followed when adding new languages.  It is troublesome.  In addition, these switches are executed every time and the user of the class cannot do anything about it. </li><li>  I want to <b>get rid of the time bomb</b> in the face of _language.  This wonderful variable is set in one place, and is used (and causes exceptions!) In another (or rather, in others).  This certainly does not make it easier to debug and search for the causes of failures. </li><li>  I want <b>to separate the interface from the implementation</b> so that these two things do not hinder the development of each other. </li><li>  I would like to come to this design, which will <b>encourage the programmer to implement the early diagnosis of errors</b> , a single ‚Äúdecryption‚Äù of the _language value.  In general, act wisely.  The existing solution encourages exactly the opposite behavior. </li></ul>  Let's move consistently.  Letters turned out a lot, but they are all simple and, I hope, will not require excessive brain effort.  Pour yourself your favorite drink and proceed. <br><br><h1>  We divide and conquer </h1><br>  To begin with, we will spread everything that concerns individual languages ‚Äã‚Äãinto separate classes.  We did nothing new, but it became a little bit easier to develop and test. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;stdexcept&gt; #include &lt;iostream&gt; class CodeGeneratorJavaProcessor { public: std::string code() { return std::string("Java: System.out.println(\"Hello world!\");"); } std::string thing() { return std::string("http://www.java.com/"); } }; class CodeGeneratorCppProcessor { public: std::string code() { return std::string("C++: std::cout &lt;&lt; \"Hello world!\";"); } std::string thing() { return std::string("http://www.cplusplus.com/doc/tutorial/"); } }; class CodeGenerator { public: enum Lang {JAVA, C_PLUS_PLUS, PHP}; CodeGenerator(Lang language) { _language=language; } std::string generateCode() { switch(_language) { case JAVA: return CodeGeneratorJavaProcessor().code(); case C_PLUS_PLUS: return CodeGeneratorCppProcessor().code(); } throw new std::logic_error("Bad language"); } std::string someCodeRelatedThing() { switch(_language) { case JAVA: return CodeGeneratorJavaProcessor().thing(); case C_PLUS_PLUS: return CodeGeneratorCppProcessor().thing(); } throw new std::logic_error("Bad language"); } private: Lang _language; }; int main() { CodeGenerator cg(CodeGenerator::JAVA); std::cout &lt;&lt; cg.generateCode() &lt;&lt; "\tMore info: " &lt;&lt; cg.someCodeRelatedThing() &lt;&lt; std::endl; CodeGenerator ec(CodeGenerator::PHP); try { ec.generateCode(); } catch (std::logic_error * e) { std::cout &lt;&lt; "ERROR: " &lt;&lt; e-&gt;what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br>  We will not linger long on the discussion of this purely mechanical improvement. <br><br><h1>  Single interface and multiple switch failure </h1><br>  Let's create a single interface for all languages.  Now we can store in CodeGenerator not a language code, but a pointer to the generator class of this language.  The conversion of a language code to a class occurs once. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;stdexcept&gt; #include &lt;iostream&gt; class CodeGeneratorAbstractProcessor { public: virtual std::string code() = 0; virtual std::string thing() = 0; virtual ~CodeGeneratorAbstractProcessor() {} }; class CodeGeneratorJavaProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { return std::string("Java: System.out.println(\"Hello world!\");"); } std::string thing() { return std::string("http://www.java.com/"); } }; class CodeGeneratorCppProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { return std::string("C++: std::cout &lt;&lt; \"Hello world!\";"); } std::string thing() { return std::string("http://www.cplusplus.com/doc/tutorial/"); } }; class CodeGeneratorBadProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { throw new std::logic_error("Bad language"); return std::string(); } std::string thing() { throw new std::logic_error("Bad language"); return std::string(); } }; class CodeGenerator { public: enum Lang {JAVA, C_PLUS_PLUS, PHP}; CodeGenerator(Lang language) : processor(0) { switch(language) { case JAVA: processor = new CodeGeneratorJavaProcessor(); break; case C_PLUS_PLUS: processor = new CodeGeneratorCppProcessor(); break; case PHP: processor = new CodeGeneratorBadProcessor(); break; } } ~CodeGenerator() { delete processor; } std::string generateCode() { return processor-&gt;code(); } std::string someCodeRelatedThing() { return processor-&gt;thing(); } private: CodeGeneratorAbstractProcessor * processor; }; int main() { CodeGenerator cg(CodeGenerator::JAVA); std::cout &lt;&lt; cg.generateCode() &lt;&lt; "\tMore info: " &lt;&lt; cg.someCodeRelatedThing() &lt;&lt; std::endl; CodeGenerator ec(CodeGenerator::PHP); try { ec.generateCode(); } catch (std::logic_error * e) { std::cout &lt;&lt; "ERROR: " &lt;&lt; e-&gt;what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br>  I understand that it was about this design that was mentioned in the <a href="http://cd-riper.livejournal.com/319899.html">reply</a> to my previous note.  The author doubted that there could be anything else to improve.  Well, let's see. <br><br><h1>  And if we do not change the view of things? </h1><br>  Let's take a look at what CodeGenerator is doing now.  Just two things: <br><ul><li>  Converts an enum to an object in the constructor. </li><li>  Provides a wrapper for an object that does all the work. </li></ul>  Do we even need such a class?  Let's leave this question open for now and see how this class is supposed to be used.  Obviously, something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i_like_to_convert_enum_to_lang</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeGenerator::Lang lang_code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">CodeGenerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lang_code)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; cg.generateCode() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\tMore info: "</span></span> &lt;&lt; cg.someCodeRelatedThing() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  That is, it is assumed that we are dragging the enum through life, and we will transform it into an algorithm where we suddenly need it.  With all the overhead: creating / deleting objects, checking the correctness of our enum-a, handling exceptions ... Would it be wiser to once convert the enum into an object and continue to live with it?  This would solve many problems and provide many benefits.  Say, a single end-to-end object could collect statistics about its work, cache something ... How do you like this solution: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i_like_to_use_generators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeGeneratorAbstractProcessor * cg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; cg-&gt;code() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\tMore info: "</span></span> &lt;&lt; cg-&gt;thing() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Here we really abandoned CodeGenerator. <br><br>  Of course, such a decisive step did not go without changing the interface, but for how many advantages we received! <br><br>  By the way (going back to the discussion of the previous note), pay attention, as soon as we abandoned the _language bomb and the processor that was not like its bomb, the operation of creating and deleting a generator came so close to each other that the need to remove polymorphic objects disappeared. <br><br>  And now is the time to screw up the lyrical digression. <br><br>  <b>&lt;Lyrical digression&gt;</b> <br><br>  Among programmers who are prone to every kind of haskel, there are curious movements of fighters against if and other branches. <br><br>  The problem with ifs is that they multiply as an infection.  I will give an example that can often be found in real life.  Suppose you are writing a program with the ability to enable debugging. <br><br>  Often this is done like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { //   ( ) bool debug(false); int r; while ((r = getopt(argc, argv, "d")) != -1) { switch ( r ){ case 'd': debug = true; break; } } //      , //     // ( ) if (debug) { std::cout &lt;&lt; "Some debugging" &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br>  Examples of such code can be found in the sources cdrtools, Python, git, cmake, m4 (debug variable), firefox (debug_mode), mpalyer / mencoder (debug, b_debug fields in various structures), x11vnc (debug / crash_debug / debug_pointer) ... look at the source code of your favorite program and you will find additional illustrations. <br><br>  The problem is that the first if converts one logical value to another.  And then, in the main code, this second logical value is interpreted each time. <br><br>  This of course does not lead to a decrease in performance (even on the contrary! This is a very good approach in terms of performance), but it clutters up the code and makes its support very complex.  It‚Äôs easy to make a mistake in this whole bunch of code.  This bunch of code is hard to change. <br><br>  But, fortunately, there is another solution.  Type of such: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;unistd.h&gt; class noout : public std::ostream {}; noout&amp; operator&lt;&lt; (noout&amp; out, const char* s) { return out; } int main(int argc, char *argv[]) { //       //    noout e; std::ostream *debug(&amp;e); int r; while ((r = getopt(argc, argv, "d")) != -1) { switch ( r ){ case 'd': debug = &amp;std::cout; break; } } //     *debug &lt;&lt; "Some debugging" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Here, the conversion is performed immediately to the object, which determines what to do with debugging messages. <br><br>  In the main body of the program, branching is no longer needed. <br><br>  Moreover, it is now very easy to develop this code.  For example, we can add a new stream to direct debug information. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;unistd.h&gt; class noout : public std::ostream {}; noout&amp; operator&lt;&lt; (noout&amp; out, const char* s) { return out; } int main(int argc, char *argv[]) { //     //      noout e; std::ostream *debug(&amp;e); int r; while ((r = getopt(argc, argv, "de")) != -1) { switch ( r ){ case 'd': debug = &amp;std::cout; break; case 'e': debug = &amp;std::cerr; break; } } //        //  ,     *debug &lt;&lt; "Some debugging" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  Of course, this implementation only illustrates the approach.  Of course I forgot to add <br><br><pre> <code class="cpp hljs">noout&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt; (noout&amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s); noout&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt; (noout&amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s); ...</code> </pre><br>  and many, many things.  Of course, it would be more appropriate to use a complete logging tool.  This is all clear.  But I hope that the idea itself, I illustrated. <br><br>  And, pay attention, and here the objects live a polymorphic life, but here we still do not need polymorphic deletion (this again going back to the previous article). <br><br>  <b>&lt;/ Lyrical digression&gt;</b> <br><br><h1>  Separate the interface from the implementation </h1><br>  Let's rewrite the CodeGeneratorAbstractProcessor class a bit by demonstrating the concept of NVI.  See how nicely the implementation is separated from the interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;stdexcept&gt; #include &lt;iostream&gt; class CodeGeneratorAbstractProcessor { public: std::string generateCode() { return code(); } std::string someCodeRelatedThing() { return thing(); } protected: ~CodeGeneratorAbstractProcessor() {} private: virtual std::string code() = 0; virtual std::string thing() = 0; }; class CodeGeneratorJavaProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { return std::string("Java: System.out.println(\"Hello world!\");"); } std::string thing() { return std::string("http://www.java.com/"); } }; class CodeGeneratorCppProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { return std::string("C++: std::cout &lt;&lt; \"Hello world!\";"); } std::string thing() { return std::string("http://www.cplusplus.com/doc/tutorial/"); } }; class CodeGeneratorBadProcessor : public CodeGeneratorAbstractProcessor { public: std::string code() { throw new std::logic_error("Bad language"); return std::string(); } std::string thing() { throw new std::logic_error("Bad language"); return std::string(); } }; void i_like_to_use_generators(CodeGeneratorAbstractProcessor * cg) { std::cout &lt;&lt; cg-&gt;generateCode() &lt;&lt; "\tMore info: " &lt;&lt; cg-&gt;someCodeRelatedThing() &lt;&lt; std::endl; } int main() { CodeGeneratorJavaProcessor java; i_like_to_use_generators(&amp;java); return 0; }</span></span></span></span></code> </pre><br>  Open methods implement the interface.  Private and virtual methods are used to customize the behavior of a class.  These two things can now be juggled with ease and ease.  Doing both the best.  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;stdexcept&gt; #include &lt;iostream&gt; class CodeGeneratorAbstractProcessor { public: std::string generateCode() { return lang() + ": " + code(); } std::string someCodeRelatedThing() { return thing(); } protected: ~CodeGeneratorAbstractProcessor() {} private: virtual std::string lang() = 0; virtual std::string code() = 0; virtual std::string thing() = 0; }; class CodeGeneratorJavaProcessor : public CodeGeneratorAbstractProcessor { public: std::string lang() { return std::string("Java"); } std::string code() { return std::string("System.out.println(\"Hello world!\");"); } std::string thing() { return std::string("http://www.java.com/"); } }; class CodeGeneratorCppProcessor : public CodeGeneratorAbstractProcessor { public: std::string lang() { return std::string("C++"); } std::string code() { return std::string("std::cout &lt;&lt; \"Hello world!\";"); } std::string thing() { return std::string("http://www.cplusplus.com/doc/tutorial/"); } }; class CodeGeneratorBadProcessor : public CodeGeneratorAbstractProcessor { public: std::string lang() { throw new std::logic_error("Bad language"); return std::string("???"); } std::string code() { throw new std::logic_error("Bad language"); return std::string(); } std::string thing() { throw new std::logic_error("Bad language"); return std::string(); } }; void i_like_to_use_generators(CodeGeneratorAbstractProcessor * cg) { std::cout &lt;&lt; cg-&gt;generateCode() &lt;&lt; "\tMore info: " &lt;&lt; cg-&gt;someCodeRelatedThing() &lt;&lt; std::endl; } int main() { CodeGeneratorJavaProcessor java; i_like_to_use_generators(&amp;java); return 0; }</span></span></span></span></code> </pre><br>  And the user interface and the ‚Äúinterface‚Äù for the developer can now be made compact, not inconsistent, convenient, logical.  And the class itself now dictates to everyone a certain discipline and structure. <br><br>  Thus, we have fulfilled all the wishes stated at the beginning of the article.  It is time to stop.  I take off my hat to all who read to the end.  Thank. <br><br>  And the picture shows a dolmen, which has nothing to do with the article.  It was just they who wanted to issue an article on this topic. </div><p>Source: <a href="https://habr.com/ru/post/112123/">https://habr.com/ru/post/112123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112113/index.html">Advertising startups teaming up against Google and Microsoft</a></li>
<li><a href="../112116/index.html">How to create and sell a board game</a></li>
<li><a href="../112118/index.html">Board games: what is played in IT offices?</a></li>
<li><a href="../112121/index.html">Appcelerator buys Aptana</a></li>
<li><a href="../112122/index.html">Lists, Lists everywhere!</a></li>
<li><a href="../112125/index.html">Apple (AAPL): First Quarter 2011 - New Records for Jobs' Hospital</a></li>
<li><a href="../112126/index.html">Are you already in HTML5?</a></li>
<li><a href="../112127/index.html">Windows Phone 7 Marketplace Statistics</a></li>
<li><a href="../112129/index.html">Video from the Perl Workshop "Saint Perl - 2" (St. Petersburg), December 18</a></li>
<li><a href="../112131/index.html">Microsoft is testing a new version of its site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>