<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I created the maps of the continents for my game.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. SVG and coordinate systems 
 Until recently, the size of the maps in my game Dragons Abound was fixed and somewhat non-deterministic. I consid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I created the maps of the continents for my game.</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/2a8/d08/3272a8d0885e3e2f041a6f2bdb7400c9.png" alt="image"></div><br><h2>  Part 1. SVG and coordinate systems </h2><br>  Until recently, the size of the maps in my game <i>Dragons Abound</i> was fixed and somewhat non-deterministic.  I considered them "regional" - not maps of the whole world, but its large parts, such as, for example, the west coast of the United States or part of Europe.  I was quite happy with this scale, but I wanted to experiment a bit with the game to see if I could generate maps of the whole world (or at least a larger one).  But before I start this, let's talk a little bit about the fantasy worlds cards. <br><br>  The world is a big space.  Most of the fantasy "worlds" cards don't even come close to their true size.  Take, for example, Middle-earth, in which the ‚ÄúLord of the Rings‚Äù action takes place: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/bc8/9f3/90fbc89f36ab284a974be18c66909558.jpg"></div><br>  Although it seems that a huge world is captured on it, in fact, Middle-earth was created on the basis of Europe. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/e6d/d95/7a0e6dd9576841e7ecf87babf2a66b93.webp"></div><br>  That is, the real map of the ‚Äúworld‚Äù for Tolkien‚Äôs world will be approximately 50 times larger than the map of Middle-earth (!).  In fact, most of the maps of fantasy worlds that I have seen display a territory about the size of a continent: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/17a/90e/c9517a90ef51440cda257b2300ba591e.png"></div><br>  It seems that this is the largest area that is well visualized in the style of fantasy cards. <br><br>  That is, the task of generating real "world maps" is probably too ambitious.  It is better to aim at creating a map of the continent (or part of the continent).  (However, it is still more convenient to consider a map having the size of a ‚Äúworld.‚Äù) So, how big should the map be?  If the current <i>Dragons Abound cards</i> have a ‚Äúsubcontinental‚Äù size, then we can assume that you need to generate cards 8-10 times larger. <br><br>  Before I proceed to the task of generating large maps, I need to better understand the various coordinate systems that are used in my game.  I borrowed a lot of coordinate systems from Martin O'Leary's source code, and their interactions can be confusing, even when you work with them for two years.  Usually I managed to do without experimenting with them, but it is obvious that in order to generate large maps this will have to be done. <br><br>  To begin with, the ‚Äúworld‚Äù of the regional map is currently generated within a single square.  Each regional map has coordinates from (-0.5, -0.5) to (0.5, 0.5), and the origin (0,0) is in the middle of the region. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/c65/c30/201c65c30244efe1e6cd4bd47e07b901.png"></div><br>  One of the oddities here is that the Y-axis is reversed compared to what we studied in school geometry.  -0.5 is at the top of the map, and 0.5 - at the bottom.  In computer graphics, the Y axis is often inverted.  I heard that this is explained by the way the first monitors (televisions) were scanned from top to bottom, that is, the first scan line was at the top, the next immediately below it, and so on, that is, the Y index of the scan lines was changed from zero at the top to some positive number down below.  Anyway, the SVG (Scalable Vector Graphics) format uses the same coordinate system, so <i>Dragons Abound</i> too. <br><br>  This coordinate system is independent of how the map will be displayed.  This is just a dimensionless system for the creation of the world - the city is located at (0.12875, -0.223), the border runs from (0.337, 0.010) to (0.333, 0.017), and so on.  And although my current regional maps are limited to a range from 0.5 to -0.5, this is not the limit of the coordinate system.  I can create a world beyond these borders. <br><br>  The next coordinate system is what the SVG is called the viewbox.  It sets the true coordinates that will be used to draw the graphics.  For example, <i>Dragons Abound</i> at the beginning sets the viewbox to the coordinates (-500, -500) and it has a width of 1000 and a height of 1000: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4f4/e4f/5094f4e4f04889dcc9f389fba59d2b24.png"></div><br>  (There is a typo in the picture, at the top of the Y axis should be -500, sorry.) <br><br>  It can be noted that in this case the transformation between the first and second coordinate systems consists only in multiplying by only 1000. That is.  to draw something, the game finds the coordinates of this object, multiplies them by 1000, and draws in these coordinates SVG. <br><br>  That is, I can use the viewbox coordinates to allow us to draw a line from (0, 0) to (250, 250).  But actually I don‚Äôt want to draw a line from (0, 0) to (250, 250) on the computer screen.  This would mean that if I want to display a map at a different point on the screen, then I will have to change the coordinates of all map objects and redraw them.  It would be a lot of work. <br><br>  To control the coordinates of displaying graphics on the screen, there is a third coordinate system in SVG, called viewport.  Viewport is the part of the page in which the graphics should be drawn (on a web page this is the &lt;svg&gt; element).  It has a width, height and location.  The location is the coordinates of the upper left corner of the viewport.  That is, if I displayed the map in the viewport with coordinates (30, 100), which has a height and width of 800, then the coordinate system of the viewport would look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/746/73e/f51/74673ef51f001d21b7871382c5dc0638.png"></div><br>  In SVG, the coordinate systems viewbox and viewport are connected to each other, and the transition between them is handled by the SVG itself.  We simply draw in the viewbox coordinate system, and everything drawn is displayed in the corresponding viewport location.  (There are some problems when creating the viewbox and viewport with different aspect ratios. Then the objects are either clipped or stretched, depending on the value of the <code>preserveAspectRatio</code> attribute. I recommend not to do this at all.) <br><br>  To summarize: a city located in the coordinates of the world (0.10, 0.33) is drawn in the coordinates (100, 330) and is shown on the screen in (110, 764). <br><br>  Now you can understand why this can be confusing! <br><br>  What happens if I change each of these coordinate systems?  Suppose that in the first coordinate system I will generate a world that ranges from -0.25 to 0.25 along each axis.  Then the resulting world will be four times smaller than the ordinary world and will fill only the middle part of the viewport: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/11c/6c2/89411c6c2b1975f8512548a487191648.png"></div><br>  (You can also notice artifacts around the edges, which are usually hidden.) Similarly, if I double the size of the first coordinate system (CS), then we will not see most of the map, because it will be outside the edges of the viewport. <br><br>  What happens if I double the viewbox size?  Well, if I also double the ratio between the first SC and the viewbox (from 1000 to 2000), then nothing will change much.  If the ratio remains equal to 1000, the map will again be halved. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/f79/dfe/859f79dfe453741087cedce2d6918e16.png"></div><br>  However, this time the map has an initial area of ‚Äã‚Äã1x1.  We can again notice artifacts along edges that are usually hidden (for example, bulging parts of forests).  You can also see that the ocean pattern is incorrect - I must have rigidly set some assumptions about the size of the viewbox.  In addition, it seems that the compass is not located on the corner of the map, but on the corner of the viewbox. <br><br>  And vice versa, if I reduce the size of the viewbox by half, this will create the effect of a zoom map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/f0e/f8e/26ef0ef8e0a2db5298de4720d12193fe.png"></div><br>  Here we see only the middle quarter of the map.  This is not a very convenient way to zoom, because when displaying only half of the map, some problems are created - for example, the marker of the city ‚ÄúSouth Owenson‚Äù has gone off the screen.  In addition, it doubles the size of fonts and other things that I do not need. <br><br>  A more useful aspect of the viewbox is changing the origin point.  While the viewbox has been centered on the map, this is not necessary.  For example, I can shift the map to the right by centering the viewbox on a point on the left side of the map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/bbf/662/970bbf662eb73852a4140af450c48fb8.png"></div><br>  We can again notice the effects on borders and some other problems, but in fact the map has shifted to the right.  The usefulness of this may not be obvious, but imagine that I will generate a map that is twice the width of an ordinary map.  By default, it looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/fee/3ad/327fee3add9790b0a73a32d7e1ee04cf.png"></div><br>  It looks like any other map, but in fact it is only the central part of a larger map.  That is, now I can change the viewbox to transfer other parts of the map to the overview window: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/2a8/d08/3272a8d0885e3e2f041a6f2bdb7400c9.png"></div><br>  Here I have shifted the viewpoint to the left, so we see a part of the world east of the original view.  Some names on the map have changed, because <i>Dragons Abound</i> performs some functions (for example, gives names to objects) based on whether they are visible.  I will need to change this so that when I move the viewbox, the map remains constant.  However, later I can move the viewbox on a large map and generate regional maps of any desired area.  That is, I can generate and display large maps the size of a continent, but I can also generate regional maps of areas within a large map. <br><br>  To summarize: the game uses three coordinate systems.  The first is an abstract SC for objects of the world.  The second is the viewbox, it defines the visible region of the world.  The third is the viewport, it controls where the map will be drawn on the screen.  To draw a larger world, I need to expand the first SC.  To display more on the screen, you need to expand the viewbox.  I can also move the viewbox to display different parts of the big world. <br><br><h2>  Part 2. Making cards permanent </h2><br>  In the previous part, I explored the coordinate systems and learned how to move the SVG viewport to display only parts of the larger world.  However, this approach has some problems, because earlier I assumed that everything invisible to us does not matter.  In this part, I will eliminate these assumptions so that you can generate and view different parts of the unchanged large maps. <br><br>  The problem with the placement of names, which I described in the previous part, is clearly visible on these two types of a single card: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/fee/3ad/327fee3add9790b0a73a32d7e1ee04cf.png"></div><br>  Here is the same world, only the view is shifted to the left: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/2a8/d08/3272a8d0885e3e2f041a6f2bdb7400c9.png"></div><br>  You may notice that the geography is the same, but many names have changed.  Since in two forms different objects are visible, and the process of creating names is controlled by random numbers, different names are obtained. <br><br>  Looking at the code, I found that almost all objects are given names depending on their visibility.  But there is only one exception that makes it difficult to give names to all subsequent objects.  In our case, the exception is that <i>Dragons Abound</i> only generates visible coastlines.  The reasons for this are very confusing.  In fact, there is a ‚Äúcoastline‚Äù all along the edge of the world, but the creation of this line destroys part of the logic of the program, because it encloses the whole world.  To avoid this, I simply generated only the visible coastline.  Now that the map can expand far beyond the viewport, this solution does not look good.  Instead, I need to stop generating shorelines as I approach the real edge of the map.  (Which I still leave off-screen to hide problems at the edges.) <br><br>  After this problem is fixed, the names on the two maps remain constant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/908/a83/39b908a83146f3161397cda6fbcba045.png"></div><br>  and: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/322/ad4/6af322ad4cb57591a51748243a8ac02e.png"></div><br>  Another note for the future: if I use the <a href="https://heredragonsabound.blogspot.com/2018/08/the-naming-of-places-part-12-map.html">possibility of interactivity</a> to change the names of map objects, this change will not be recreated in its current form, and probably will not even be reproducible.  It is worth thinking about. <br><br>  If you look closely at the previous map, you can see that the area of ‚Äã‚Äãthe ocean near the lower central part of the map has a hanging label ‚ÄúMeb Island‚Äù.  This happened because <i>Dragons Abound</i> actually believes that the area of ‚Äã‚Äãthe ocean is an island.  I will not go into technical details, but it is surprisingly difficult to distinguish islands from lakes when they go beyond the map.  The algorithm is confusing the change I made to the generation of invisible coastlines, and in order to avoid such problems, this needs to be fixed. <br><br>  Now let's quadruple the size of the map and show only a quarter of it in the map window: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/81f/8d4/f4081f8d4d2ac9dd3d7d35077ba23450.png"></div><br>  In general, everything looks good (there is an interesting system of rivers on the map, a large lake, but you can see that cities are very rare. It happened because <i>Dragons Abound</i> generates 10-20 cities. This interval is well suited for the world of normal size, but it‚Äôs bad, when the size is four times larger. Therefore, the interval should be changed in accordance with the relative size of the world. Probably, it should be done in several places. <br><br>  Here is the same map after fixing the problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/821/113/b40/821113b400ab683c8fdfad87bccf3213.png"></div><br>  Now there is a more logical number of cities and towns on the map, but this shows us another problem.  You can see a lot of extra names around the edges of the map, for example, Nanmrummombrook, Marwynnley and Noyewood in the lower left corner.  This happens because the placement code of the method tries to put them where they are visible.  Previously, this procedure never had to worry about marks off the screen, because in the maps of regional size the whole world is usually visible.  But now there may be cities and other objects located off-screen.  Therefore, I need to add logic to the label placement procedure that does not attempt to create labels for invisible map objects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9d/022/b5a/b9d022b5a3c22d9f7e1f4c5e7c24771e.png"></div><br>  Now the picture is more logical.  On the right, Cumden is barely displayed on the map, but the label is still located where it is visible. <br><br>  There is one aspect that is not immediately noticeable on large maps: the number of locations in the world has not changed.  Although the map (in a sense) has become 4 times larger, its total area is still limited by the same number of locations.  The initial stage of map generation was to cover the world with a Voronoi diagram with a constant number of locations.  That is, when the map becomes larger, the Voronoi cells also become larger. <br><br>  It would be logical to scale the number of locations according to the size of the map, but unfortunately, the dependence of the speed of <i>Dragons Abound</i> on the number of locations is much worse than linear, that is, the generation of a map with a large number of locations can take a long time.  Here is an example of a map with a quad resolution (number of locations): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/faa/7a6/4bcfaa7a64abf56cb1cf4aab84651215.png"></div><br>  The added locations change the generation process, so the terrain is different from the maps shown above, but you can see added details on the coasts on it. <br><br>  Fortunately, when profiling the performance of generating large cards, I noticed that obvious problems take up most of the CPU time.  Having completed the debugging, I eliminated the most interfering of them, which allowed me to create more cards.  Here is the entire 4x map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/6f4/600/1496f4600dc18c1ffa955580e07d7161.png"></div><br>  Completed zoom at 25% size.  It looks like about the maximum map size Chrome can display.  The world generation procedure can process maps of a larger size, but when trying to display them, the browser crashes.  It seems that in this sense, Firefox is more functional;  It can display maps 9 times larger than its original size.  Here is a part of such a map - I left it in full size, so you can open it in a separate window in order to better understand the size and detail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/1a2/c98/15f1a2c98b85e749101f0a379e7b9937.png"></div><br>  Firefox is able to generate maps of this size, but I can only take screenshots at the maximum size of the browser window.  I have the function to save the map as a PNG file, but it can only save the displayed part of the map.  I think you can scroll the map, capture individual screens and connect them together, but it will be time consuming. <br><br>  The best solution is to save the SVG itself so that it can be opened in a program like Inkscape. <br><br>  Previously, I could cut and paste SVG maps in Inkscape, but the SVG for world maps is so great that when I try to cut the browser crashes!  Fortunately, I found <a href="">FileSaver.js</a> and can use it to save the SVG directly to a file and then open it in Inkscape, thus creating a very large image. <br><br>  At least theoretically.  When I try to open these maps in Inkscape, I run into a couple of problems. <br><br>  The first problem is that Inkscape assumptions are different from Chrome and Firefox assumptions in how to open SVG.  In particular, if the fill color is not specified in the contour, then browsers assume that there is no fill;  Inkscape assumes that the outline is filled with black.  So when I open a saved SVG in Inkscape, it is almost completely black, because the topmost layer of the map does not contain a fill color.  This can be corrected by specifying ‚Äúfill: none‚Äù in the required places so that the contours are displayed equally in both the browser and Inkscape. <br><br>  The second problem - Inkscape has errors in the processing of masks.  It seems that Inkscape creates masks with only one element, and badly handles masks with several elements.  <i>Dragons Abound</i> creates many masks with multiple elements.  One can get around this problem by grouping all the elements of each game mask into one (optional) ‚Äúgroup‚Äù element. <br><br>  The third problem is related to images and other downloadable resources.  In the original SVG links to them are indicated in a relative form, for example, "images / background0.png".  My sources are organized in such a way that the <a href="https://github.com/cesanta/mongoose">individual web server I use</a> can find these resources in the specified places.  When I take the same SVG and open it in Inkscape, these relative paths are treated as the URL "file:" and Inkscape searches for resources relative to the folder into which the SVG was saved.  This problem can be easily circumvented by saving the SVG to a folder that already has resources in the right places;  it can be the same root folder as that used by the web server, or another place where there are copies of resources along the same (relative) paths. <br><br>  The fourth issue is fonts.  <i>Dragons Abound</i> uses both web fonts and locally stored fonts;  those and others in the WOFF2 format.  In the browser, they are applied to the text using the font-family CSS style, and before generating a map, all possible fonts are uploaded to a web page to be ready for use.  When the same file is opened in the game, it searches for fonts in the system font directory, and it looks like you can‚Äôt specify a different font directory in any way.  A simple solution (at least on the machine where I develop) is to install the fonts used by the game into the system font directory.  However, this is not as easy as it seems, because the font names must match, and in Windows there are no simple ways to change the font name.  But, of course, such a scheme will not work on computers that do not have all the necessary fonts installed.  A more portable solution is to <a href="https://github.com/BTBurke/svg-embed-font">embed SVG fonts in maps</a> .  This will be on my todo list. <br><br>  In the end, I came to this map generation interface: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/e69/c3b/88ee69c3b069b7c369cbf3921b6a3eba.png"></div><br>  The Extent input fields specify the total size of the world, where 1x1 is the size of the source maps.  The size of the vbx (viewbox) determines the size of a fragment of the world displayed on the map;  in the screenshot, it also has a value of 1x1, that is, the map will display the whole world.  The vbx center fields specify the location of the map center in the world;  0, 0 is the center of the world.  Finally, the SVG parameters set the number of screen pixels per 1 viewbox size unit;  If the value is 775, the 1x1 map will be displayed on the screen in the size of 775x775 pixels.  This is convenient when I create a very large map.  By setting the parameter to a low value (for example, 150 pixels), I can fit a large map on the screen entirely. <br><br>  By changing these six parameters, I can control the size of the world and the proportion of the world that is displayed on the map.  The Generate button works exactly as you might guess;  the Display button simply displays a part of the world, that is, I can generate the world and then display its individual parts by changing the parameters of the viewbox without the need to re-generate the world.  (A better programmer would implement this as scaling and scrolling.) The Save PNG button saves the visible map as a PNG file;  The Save SVG button saves the entire map SVG file.  The Test It button is used to launch a test code that changes during the development of various functions. <br><br>  Now that I can generate and reflect all parts of the big world, we can move on to adapting the shape of sushi to larger maps. <br><br><h2>  Part 3. Forms of sushi </h2><br>  Having made various changes in the previous part, now I can generate worlds that are much larger than the previous ones (up to 8 times more) and save them as large graphic images: <br><br><div style="text-align:center;"> <a href="https://www.flickr.com/photos/151153712%40N05/44364141012/sizes/o/"><img src="https://habrastorage.org/getpro/habr/post_images/963/31e/c94/96331ec940b59a6f349603f0024f5cc7.png"></a> </div><br>  (Open the image in a separate window to see the map in full resolution 4800x2400 on Flickr.) <br><br>  I generate these maps using the same procedural generation that created the regional maps.  The map shown above has a fairly regular continental shape and several interesting outer islands.  However, it mostly depends on luck.  Here is another map: <br><br><div style="text-align:center;"> <a href="https://www.flickr.com/photos/151153712%40N05/44414268951/sizes/l"><img src="https://habrastorage.org/getpro/habr/post_images/b03/406/fd1/b03406fd17f93c9e33cd8dd488b404c3.png"></a> </div><br>  This map is just chaos from the islands and Swiss sushi cheese. <br><br>  Here is another example, something intermediate between the two previous maps.  He is not completely realistic, but may be interesting for a fantasy entourage: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7c3/c79/e98/7c3c79e98246dde23f7104428e9cf9b2.jpg"></a> </div><br>  This is a huge continental mass of land, but there are quite a few strange forms of land, and the whole world does not look quite "real."  (Although to someone such a world will seem quite suitable for fantasy.) So what forms should the "world" card have? <br><br>  Most of the maps of fantasy worlds that I have seen display a large island continent (with small islands around), for example, such as this map of <a href="https://twitter.com/DanielDydek/status/1046927857195393024">Andelen</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/3f4/fb8/9263f4fb80cf2899f48693c31aa2566a.png"></div><br>  Or the peninsula of the continent, as on this map of <a href="https://www.artstation.com/artwork/2G30J">Angoruna</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/ef4/bc1/75cef4bc1d0e698c2a76ee77bfc74bd0.png"></div><br>  From time to time it turns out a map consisting entirely of land or several island continents, but they are rather exceptions to the rule. <br><br>  First, let's deal with the generation of "island" continents.  As it turns out in my game, there was already a function that generates a large central island on the map, taking into account the size of the map, so it should be suitable for generating the main form of the continent.  The rest will be taken care of by noise and additional islands. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a7/86e/0b5/0a786e0b59241b451f3c225c23328a47.png"></div><br>  I did not expect a large central sea on this map, but it is a pleasant surprise.  Here is another example: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f58/a14/788/f58a14788a7dbcd6fbaa25c9fb45457e.png"></div><br>  The problem of the function of the central island is that it starts with a circle, which is suitable for the square maps shown by me, but not very good for rectangular ones.  (Below are examples with a small amount of distortion so that the basic forms are more clearly visible.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/b43/073/30bb430737122e671fb2f2067fafea08.png"></div><br>  This is easily corrected by masking sushi instead of a circle with an ellipse (distorted) taken according to the size of the map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/7a9/2ea/3937a92ea08cd752739550bf59a89971.png"></div><br>  These central islands are scaled to fill the map, but in many cases for continental maps we need to leave a ‚Äúborder‚Äù around the continent.  Two parameters control the value of filling the map with the island along the X and Y axes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad4/b00/94e/ad4b0094e542930350a964377888a640.png"></div><br>  Here is the same border management system with more logical distortions: <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/357/9e1/121/3579e11217c879a587f11b30380e94b9.png"></a> </div><br>  It can be seen that the eastern and western parts of the map remain the ocean.  (You can open the map in a separate window to study it more carefully.) This means that the map displays the whole world (and its right and left edges can be joined) or a part of the world that can be attached to another map that also has an ocean from the corresponding edge. <br><br>  An attentive reader who has studied the previous map may have noticed that the patterns of ocean and sushi stop in the middle of the map.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, I had maps of only 1x1 in size, so the size of ocean and land patterns fit into these maps. On larger maps, I need to manually mask the patterns on the map, so I added this feature. (In SVG, there is a way to perform a tiling pattern, but in Chrome it contains a bug, so I cannot use it.) This is a good function, because now I can use smaller land and ocean patterns that will be hidden automatically. I do not know why I did not implement it before! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, now the island continents are working normally, and we will proceed to the implementation of the ‚Äúpeninsular‚Äù continents - maps, in which the continent appears on the map from its edge.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/d75/914/d9ed75914bd6b4deaae08fb687b828e2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the continent cannot fold at three edges. </font><font style="vertical-align: inherit;">But the main feature of such maps is that there is a significant land connection on them between the continent displayed on the map and the land outside the map. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to provide such a connection outside the map is to set the low sea level when generating. </font><font style="vertical-align: inherit;">So we will increase the area of ‚Äã‚Äãthe land displayed on the map, which increases the likelihood of large masses of land and the emergence of land (and not the sea) along the edges of the map.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/adb/522/24dadb52258988326f096336470d97c3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, this does not guarantee that the land mass will be very interesting, and indeed it will be the same: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/c22/335/c0bc223356225dea02bfbd773495f36e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A similarity of a single continent can be created using the same generation of the island continent, but at the same time shifting the island to the edge of the map. </font><font style="vertical-align: inherit;">You get something like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/209/981/20e/20998120e01c4c48f53419855cf6f703.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be seen that the continent (mostly) is the central island, shifted up and to the right. </font><font style="vertical-align: inherit;">Since this is a continent and it is not obliged to maintain a strict island form, you can add more distortion to the form.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/000/523/e5f00052339289e504ffcd82b7481545.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, there are many other approaches to the generation of relief, but these two, at least, give me the opportunity to generate the most common land forms on a continental scale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The attentive reader may have noticed the strange forms of forest in the form of stripes on many maps of the continents. </font><font style="vertical-align: inherit;">Next time I will start to deal with the problems of wind and biome models that cause these oddities.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 4. Wind model </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As he said, the size of the continents on the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> maps </font><font style="vertical-align: inherit;">began to show unrealistic patterns of weather and biomes. In this example, it is clear that the forest is lining up along the prevailing wind direction:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/209/981/20e/20998120e01c4c48f53419855cf6f703.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason is not in broken code; rather, the weather and biome models are too simple, and on a large scale this becomes obvious. To cope with these problems, I began by revising the wind model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would like my wind model to better reflect the dynamics of the Earth‚Äôs wind: </font></font><a href="https://en.wikipedia.org/wiki/Hadley_cell"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hadley cells</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://en.wikipedia.org/wiki/Trade_winds"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trade winds,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the like. Such dynamics can help get rid of the strange patterns of weather on continental maps. However, when they were added, the excruciating dissatisfaction with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wind model </font><font style="vertical-align: inherit;">, which was slow and too complicated, </font><i><font style="vertical-align: inherit;">came to light</font></i><font style="vertical-align: inherit;"> again </font><font style="vertical-align: inherit;">. (Read about the original implementation of the wind model </font></font><a href="https://heredragonsabound.blogspot.com/2016/10/is-it-windy-in-here.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.) After thinking about this for several days, I decided that most of the problems boil down to the fact that the game map is represented as a </font></font><a href="https://en.wikipedia.org/wiki/Voronoi_diagram"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voronoi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagram </font><font style="vertical-align: inherit;">. (Or rather, the </font></font><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delaunay triangle of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the Voronoi diagrams.) It has many advantages in generating relief ‚Äî in combination with noise, it can create natural-looking land masses. That is why it is so often used to generate relief. But since the individual triangles have different sizes and orientations, any calculations, including wind models that use the acting neighboring cells, become quite complex. It will be much easier to model the wind through a grid of evenly spaced identical areas. In addition, the wind model most likely does not have to be as detailed as land.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But I do not want to completely abandon the Voronoi diagram, which underlies the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (At a minimum, this will require rewriting almost the entire program!) Instead, I want to experiment with binding the map to a uniform grid, run the wind model in it, and then perform a reverse binding. If the losses in copying back and forth are not too great, then this can make the wind model faster and easier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What kind of mesh should I use? Ideally, the grid should consist of equal areas equidistant from their neighbors. And this description is like a grid of hexagons.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/948/12a/72094812ad2adea8d6d71fa795146c44.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, the grid of hexagons is the </font></font><a href="https://www.revolvy.com/page/Honeycomb-conjecture%3F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">best way to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> divide a flat surface into equal areas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to determine how to represent the grid of hexagons in my program. I searched the web for a bit of clues, and each link brought me back to the </font></font><a href="https://www.redblobgames.com/grids/hexagons/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">page on the grids of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Amit Patel‚Äôs </font><a href="https://www.redblobgames.com/grids/hexagons/"><font style="vertical-align: inherit;">hexagons</font></a><font style="vertical-align: inherit;"> ( </font></font><a href="https://habr.com/post/319644/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Habr√©). Probably, with her and need to start; it is also a good idea to first explore the </font></font><a href="https://www.redblobgames.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red Blob Games website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you are looking for information on the implementation of game mechanics. Amit explains better than me, so if something is unclear, then read his page.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first choice to be made is a way to store a grid of hexagons. </font><font style="vertical-align: inherit;">The easiest way to store it as a two-dimensional array, I need the ability to bind the grid cells to an array. </font><font style="vertical-align: inherit;">There are many options (read </font></font><a href="https://www.redblobgames.com/grids/hexagons/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Amita page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), but I will use what he calls odd-r:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9c/a08/6bb/e9ca086bb2e5957db58d021c302c27f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The numbers in each cell are indices of the location of a cell in a two-dimensional array. </font><font style="vertical-align: inherit;">(The image is stolen from the </font></font><a href="https://www.redblobgames.com/grids/hexagons/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">page of Amit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . On its page they are interactive, so I advise you to experiment with them.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having made my choice, I must now learn how to tie the indexes to the grid of hexagons. </font><font style="vertical-align: inherit;">For example, if I search for a hexagonal cell (3, 3), what will be its neighbors? </font><font style="vertical-align: inherit;">If each cell has a width of 5 pixels, then what will be the coordinates of the center of the cell (3, 3)?</font></font> And so on.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dealing with this can be difficult, so I'm glad that Amit did it for me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assuming that we can steal everything Amit needs, I first need to figure out how to place the hexagons on the map. At this stage, I still do not need an array, I can pretend that it is and see where the hexagons will be. If I know the location of the hexagons, then I simply divide the width of the map by the horizontal distance between them to get the number of columns, and do the same vertically to get the number of rows, after which I draw a hexagon in each place:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ba/0e2/d39/7ba0e2d39d51e3ea0584734fbb584f19.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These hexagons are much larger than those that I will use to model the wind, but they show me that everything is placed correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I opened the edges of the map and painted only the central hexagon and on the borders to check if I really would close the entire map:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f99/733/2a0/f997332a08696203af9e4cf044cf07cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top and bottom are outside the map, but it‚Äôs not a matter of having several cells abroad, unless I miss a part of the map. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to create an array for the grid of hexagons and bind all Delone triangles to the corresponding hexagons. Since Javascript does not support </font></font><a href="https://stackoverflow.com/questions/20916442/negative-indices-in-array"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negative array indices</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I need to shift the cell (0, 0) from the center of the map to the upper right corner. Having done this, I go around all Delone triangles and add them to the corresponding cells of the grid of hexagons. I can see this by coloring the hexagons containing land:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f2e/1b7/848f2e1b78edb9dbfb91abdbff1bcf56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To determine whether a cell is land, I average the height of all locations that fall in this cell. </font><font style="vertical-align: inherit;">You can see that for some coastal hexagons, the average is below zero even when there is land. </font><font style="vertical-align: inherit;">You can also use the maximum height of all locations in the hexagon:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/041/254/66b0412544abda9d618ab32784bd9ec8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When this happens, the search in the other direction occurs - the hexagon is marked as dry if there is any dry in it. </font><font style="vertical-align: inherit;">What is better depends on what you need. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any case, I can improve the accuracy by reducing the size of the hexagons:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3b/0e7/1ec/c3b0e71ecf56429e04ea02a771b3a044.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the coast has become much better, but a new problem has arisen - a lot of internal hexagons, which are not considered land. This happens because when the hexagons become quite small, inside some of them there are no Delone triangles at all. Therefore, they have no "height". (This also demonstrates the non-uniformity of the Delaunay triangles.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use this solution ‚Äî take the height of the missing triangles as an average of their neighbors, or as a maximum of their neighbors.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d51/ad8/30f/d51ad830fd84fa509f8f47c40b730f07.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, when the binding between hexagons and locations is not one to one, then corrections are needed to fill in the missing information. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that I have laid a grid of hexagons on the map, we can begin to implement the wind model. The main idea of ‚Äã‚Äãthe wind model is to simulate some winds (trade winds) and spread them all over the map until they reach a state of immobility. At the level of hexagons (or the level of locations, if I do it on Delone triangles), this includes two steps: (1) summarize all the winds in the current hexagon, and (2) determine how the summed wind leaves the hexagon.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first stage is quite simple. </font><font style="vertical-align: inherit;">Each hexagon has six neighbors, and each of these hexagons contributes. </font><font style="vertical-align: inherit;">If we consider each of the winds entering the hexagon as a vector, then the total wind in the cell will be the sum of these vectors, i.e. </font><font style="vertical-align: inherit;">two strictly opposite winds of the same strength nullify each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second stage (determining how the total wind leaves the hexagon) requires thinking. </font><font style="vertical-align: inherit;">The simplest case is the wind blowing through the hexagon directly:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8a/982/d5a/e8a982d5af635e1fbee1e82f20c1990d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, we expect that the wind will move to the next cell without any changes. </font><font style="vertical-align: inherit;">(Here the vector of the original wind is shown in red, and the vector of the propagated wind is shown in blue.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what if the wind does not blow directly onto the neighboring cell?</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/396/196/3cd3961960c15fa86e60cd421336e23d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, it seems logical that the part of the wind bore the hexagon directly above it, the other part into the cell located counterclockwise from this one, and the proportions should depend on the direction in which the arrow points. </font><font style="vertical-align: inherit;">In our case, the main part of the wind will move to the upper cell, and less - to the neighboring cell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also necessary to decide on the direction of the spread wind. </font><font style="vertical-align: inherit;">One option is to maintain the direction of the original wind:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e31/e3f/6ef/e31e3f6ef05e18991e2e48462e47a05b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that this is the most realistic option, but there is another one - to change the direction of the wind in accordance with the edge of the hexagon, which it intersects: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96b/caa/11d/96bcaa11d738b2468eccd1ea758b9e8d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach is less accurate, but it has an advantage: incoming winds will always be in one of the six directions, which can simplify calculations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another difficulty arises when considering relief. </font><font style="vertical-align: inherit;">What should happen when a mountain gets in the way of the wind?</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c03/492/a95c0349265fe5581df74ebb33bbd4f5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case, part of the wind passes over the mountain (possibly creating precipitation), but part of the wind turns to the sides. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f4/e8b/fe3/5f4e8bfe34c0e0a8fd7a9bb784487ad9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, how the wind leaves the hexagon depends on its direction, as well as the relief in the neighboring cells. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's talk about how to represent vectors. </font><font style="vertical-align: inherit;">There are two main options. </font><font style="vertical-align: inherit;">First, the vector can be represented as X and Y values, like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/4da/c67/2534dac673d43b8bf4d93f70254e540a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we draw a vector starting at (0, 0), then (X, Y) are the coordinates of the end points. </font><font style="vertical-align: inherit;">Such a record makes it very easy to summarize the vectors. </font><font style="vertical-align: inherit;">We simply sum all the values ‚Äã‚Äã(X, Y) and get a new vector:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fd/b4c/427/9fdb4c427518523698ec72c34b854059.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Another option is to use the angle and length of the vector: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c43/421/9c9/c434219c9ba69e9a29b5d73b665d5e96.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this form, it is easy to perform operations such as rotating vectors or changing its length. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For most of the operations needed in a wind model, the first option is better, but in some cases the second is better, so it would be convenient to switch between them if necessary. </font><font style="vertical-align: inherit;">In order not to reinvent the wheel, I searched the vector Javascript library and </font></font><a href="http://victorjs.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Victor.js was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quite suitable </font><font style="vertical-align: inherit;">, so I used it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'll start by adding a wind vector to each hexagon and see if I can visualize it:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/1a2/b49/d9e1a2b49e115bbc4436a8e518164adb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looks good for now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to check if I can properly divide the wind vector and spread it to the next cell. First, you need to calculate the angles leading to other cells. I found the answer again on </font></font><a href="https://www.redblobgames.com/grids/hexagons/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Amit page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f2/f9d/4a9/9f2f9d4a9c349dbb47ff2dc32ede0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, a vector at 0 degrees points to a hexagon to the right, at 60 degrees to a hexagon to the bottom right, and so on. A vector pointing between these two directions is proportionally divided between two cells - that is, a vector at an angle of 30 degrees will be evenly divided between the cell to the right and the cell from the bottom to the right. Each vector lies somewhere between the angles of the faces of two neighboring cells, so it‚Äôs enough to look at the angle of the wind vector, find out that it falls between the central angles of the two hexagons, and then proportionally divide it between these two hexagons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, if the wind vector has an angle of 22 degrees:</font></font><br><br><div style="text-align:center;"><img height="320" src="https://habrastorage.org/getpro/habr/post_images/147/fc8/add/147fc8add812755fa9abab8c5eb928aa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then 38/60 values ‚Äã‚Äãare distributed to the cell to the right, and 22/60 values ‚Äã‚Äãof the vector are distributed to the cell to the bottom right. If the vectors are represented as a pair of X and Y values, then they can be expanded by multiplying each value of the original vector by a fraction (for example, by 22/60), and then adding it to the wind vector in the new hexagon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To test this, I can position the winds in different directions and position them at the top and side of the map and see if they can spread properly across the map. When the winds collide, they must be combined and choose the middle direction with increased speed:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/482/4ac/0394824ac970c0887bb100c515ea300e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we see that the winds meet along the diagonal and combine to blow towards the lower corner. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next stage is to take into account the influence of land on the wind. </font><font style="vertical-align: inherit;">Of course, real wind models are very complex, but I‚Äôm mainly interested in how the surface winds are affected by the land geography. </font><font style="vertical-align: inherit;">At the simplest level, this is the influence of the heights and lowlands of land on the direction and speed of the wind. </font><font style="vertical-align: inherit;">I experimented with many different approaches, but as a result I stopped at </font></font><a href="https://heredragonsabound.blogspot.com/2016/10/is-it-windy-in-here.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two simple rules</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The wind turns away from obstacles. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The wind slows when it rises, and accelerates, dropping down. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An obstacle occurs when the wind blows into a cell with a greater height, for example, a cell with a mountain. </font><font style="vertical-align: inherit;">When this happens, I look at the two cells into which the wind blows, and I change the angle of the wind so that it points more to the lower of the two hexagons. </font><font style="vertical-align: inherit;">The magnitude of the angle changes depends on the height difference between the two cells, so when the wind blows into two adjacent cells with mountains, its direction changes little, but if it blows into a cell with a mountain and a cell with a plain, then it will turn more towards the empty cell:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/4cd/b90/e6f4cdb90eb194445cf21b3c5679e3ca.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wind power can be customized. </font><font style="vertical-align: inherit;">On the map shown above, it is too strong, leading to the appearance of many unrealistic biomes. </font><font style="vertical-align: inherit;">Here is a more logical meaning:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e70/676/6f8/e706766f8d1abfc1ad18b928b72d9c7e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is still a large proportion of wind movement caused by reliefs, but there are fewer large gaps and valleys of strong wind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another feature that enhances realism is wind scattering. For example, on the map shown above, you can see that the wind blows to the west just above the city of Breeches. Although it blows far enough away, it never disperses as we would expect. When the blowing wind meets another air, it usually pulls the wind behind it. To simulate this, I can take a small part of the wind blowing in each hexagon and redistribute it to all the neighboring cells. This is how the map shown above will look like with a small scatter value:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98d/53c/6d1/98d53c6d1659c068a8d36c58d692bd02.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, now the wind over Breeches began to dissipate a little. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This operation determines the bulk of the wind directions. The second part is the deceleration of the wind as it rises upwards and the acceleration as it descends. I can do this by looking at the relative height of the cell from which the wind flows, and the height of the cell into which the wind blows, and speeding up / slowing it down if necessary. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is how it all looks:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/2c0/d8b/6332c0d8b042591426238cceafaea5a8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we see that part of the wind blowing through the high mountains in the central part of the island was cut off. And vice versa - several new winds appeared in the western part of the island, where the air moves from relatively high land to the sea. (This is a </font></font><a href="https://en.wikipedia.org/wiki/Sea_breeze"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coastal breeze</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Although, in fact, not quite: the mechanism is different there.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I can substitute the new wind into the already existing precipitation algorithm. Here is a comparison of them (old winds on the left, new ones on the right):</font></font><br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1e2/c41/3b4/1e2c413b436456e0964c50b794a402db.png"></a> </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Click on the picture to view a larger version.) Obviously, there are differences between the wind models. On both maps the wind blows from the east. The mountains near the center of the map turn the wind to the south, cause heavy precipitation and create a swamp and forests south of the mountains. In the lower part of the wind blows without interference, and forests are formed along the eastern half of the island. In the original wind model, a sufficient amount of wind passed over the central mountains and marshes to create a forest in the western part of the island. In the new model, most of the wind is cut off and grassy biomes form on the far side of the mountains.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The old model has a variability of random parameters (within a given interval), and it is likely that some combination of these parameters would give a picture that looks more like a new map. But in reality, we do not need to reproduce the exact behavior of the old model, a model that creates convincing-looking results is enough.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The point of all this is to accelerate and simplify the generation of wind, so that you can add new wind behaviors to continental maps. </font><font style="vertical-align: inherit;">Did I succeed? </font><font style="vertical-align: inherit;">I have profiled the original wind model and the new hexagon-based model. </font><font style="vertical-align: inherit;">It turned out that the new model is 15-20 times faster than the original (!). </font><font style="vertical-align: inherit;">This is a very significant acceleration, little impact on the card. </font><font style="vertical-align: inherit;">Experiments make it clear that the model is not particularly sensitive to the size of the hexagons, so if necessary, I can speed up the algorithm even further by increasing the cell size. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next time, we will work on using the new wind model to implement continental-scale wind patterns, and then connect them to the precipitation model and biomes.</font></font></div><p>Source: <a href="https://habr.com/ru/post/429620/">https://habr.com/ru/post/429620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429606/index.html">Damn dozen for PM: book list for project managers</a></li>
<li><a href="../429610/index.html">The story of how to run the Android emulator or save on intel processor</a></li>
<li><a href="../429612/index.html">Fullsteks are eternal midies. Do not go on this path if you do not want to suffer</a></li>
<li><a href="../429616/index.html">Digital Workspace, Part 1: Citrix</a></li>
<li><a href="../429618/index.html">XO electronic game</a></li>
<li><a href="../429622/index.html">Robots replaced Amazon 20,000 workers</a></li>
<li><a href="../429624/index.html">How NASA will use robots to create rocket fuel from Martian soil</a></li>
<li><a href="../429626/index.html">Hackers of the genome have demonstrated that no DNA will be anonymous</a></li>
<li><a href="../429628/index.html">How to create a chat bot for VKontakte using Python, Django and webhook</a></li>
<li><a href="../429630/index.html">"Monsters in games or make fear diverse"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>