<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Droidutils - a set of solutions that accelerate the development of applications for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing applications, I noticed that every time I had to deal with the solution of similar tasks (implement working with http, json, multithre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Droidutils - a set of solutions that accelerate the development of applications for Android</h1><div class="post__text post__text-html js-mediator-article">  When developing applications, I noticed that every time I had to deal with the solution of similar tasks (implement working with http, json, multithreading, etc.), I had to do the same thing for the robot, and it took a lot of time.  At first it was not critical, but in large projects it took too much time.  To save his and your time, I decided to write a universal solution for these tasks, which I want to share with the community. <br><a name="habracut"></a><br><h3>  Let's start with parsing JSON </h3><br>  Droidutils provides a convenient class for working with JSON, which allows you to convert data into JSON and back into an object of a class that implements the structure of a specific JSON.  Let's look at an example. <br><br>  We have JSON: <br><br><pre><code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"example"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"test"</span></span>:<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> }, <span class="hljs-string"><span class="hljs-string">"company_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Google"</span></span>, <span class="hljs-string"><span class="hljs-string">"staff"</span></span>:[ { <span class="hljs-string"><span class="hljs-string">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"David"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"Name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Mike"</span></span> } ], }</code> </pre> <br>  Now we need a class in which we write the data.  Each field in which we want to write certain data must be annotated and indicate the key for which the data is stored in JSON. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Company</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      JSONObject @JsonKey("test") private String mTest; @JsonKey("company_name") private String mCompanyName; @JsonKey("staff") private LinkedList&lt;Employee&gt; mStaff; public class Employee { @JsonKey("Name") private String mName; } }</span></span></code> </pre><br>  Everything is ready, now we can parse JSON. <br><br><pre> <code class="java hljs"> JsonConverter converter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonConverter(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         JSON Company company = converter.readJson(exampleJson, Company.class); } catch (Exception e) { e.printStackTrace(); }</span></span></code> </pre><br>  Perhaps the opposite effect.  To do this, create an instance of the class and fill it with data (fields must also be marked with annotations) and transferred to the parser, as a result we get a JSON string: <br><br><pre> <code class="java hljs"> String json = converter.convertToJsonString(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Company());</code> </pre><br>  It's simple.  But now you will say that there are a lot of different and powerful frameworks that already know how to do it all (for example, <a href="https://github.com/FasterXML/jackson">jackson</a> ).  I agree with you, <b>but</b> in most cases we do not use all the capacities of these frameworks.  In such cases, why do we need extra ballast, if we can do with one class? <br><br><h5>  Small retreat </h5><br>  When developing applications, try to avoid multiple dependencies.  Do not rush to connect a bunch of libraries to the project just because you are too lazy to write with your own pens.  Or because the developer of this library is screaming with might and main that its development solves this problem.  I'm not saying that dependencies are bad, just before you embed something in your project, you better think a few times if you need it. <br><br>  The main reasons why many addictions are bad: <br><br>  - the project becomes very bulky; <br>  - performance deteriorates; <br>  - in the later stages of development, the project becomes very dependent on third-party libraries, which, if necessary, are difficult to cut out from the project; <br><br>  This says a person who has already stepped on this rake and who then had to redo a lot of things.  This, as we know, is the loss of precious time and money. <br><br><h3>  Work with Http </h3><br>  In order to work with Http in Android, we can use one of two standard solutions: ApacheHttpClient or HttpURLConnection.  I chose HttpURLConnection, as the guys from Google use it themselves and recommend it to us. <br><br>  Now about the advantages and disadvantages: <br>  - HttpURLConnection is slightly faster, but less convenient (as for me, it is only at first glance); <br>  - ApacheHttpClient is much more convenient in relation to the previous one, but slower, and there are a couple of bugs in it; <br><br>  Let's imagine that we are developing an application that communicates closely with the server.  We have a bunch of different requests that need to be sent to the server.  Some of them themselves periodically go to the server for updates, while others we ourselves send.  And we also need to cache some data.  Take for example the news feed.  Imagine that we have a request with which we receive new information, call it ‚Äúupdate_news_request‚Äù. <br><br><h5>  Let's start creating a request </h5><br>  To build the Url there is a convenient builder: <br><br><pre> <code class="java hljs"> String url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Url.Builder(<span class="hljs-string"><span class="hljs-string">"http://base_url?"</span></span>) .addParameter(<span class="hljs-string"><span class="hljs-string">"key1"</span></span>, <span class="hljs-string"><span class="hljs-string">"value1"</span></span>) .addParameter(<span class="hljs-string"><span class="hljs-string">"key2"</span></span>, <span class="hljs-string"><span class="hljs-string">"value2"</span></span>) .build(); <span class="hljs-comment"><span class="hljs-comment">//    http://base_url?key1=value1&amp;key2=value2</span></span></code> </pre><br>  The request body can be created very simply: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,      //     JSON Company ompany = new Company(); //      HttpBody HttpBody&lt;Company&gt; body = new HttpBody&lt;Company&gt;(ompany);</span></span></code> </pre><br>  Everything is simple with headers too: <br><br><pre> <code class="java hljs">HttpHeaders headers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpHeaders(); headers.add(<span class="hljs-string"><span class="hljs-string">"header1"</span></span>, <span class="hljs-string"><span class="hljs-string">"value1"</span></span>); HttpHeader header = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpHeader(<span class="hljs-string"><span class="hljs-string">"header2"</span></span>, <span class="hljs-string"><span class="hljs-string">"value2"</span></span>); headers.add(header);</code> </pre><br>  Now we will create an Http request, for this we have a handy builder: <br><br><pre> <code class="java hljs">HttpRequest updateNewsRequest= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest.Builder() .setRequestKey(<span class="hljs-string"><span class="hljs-string">"update_news_request"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,       .setHttpMethod(HttpMethod.GET) //   (  HttpMethod.GET) .setUrl(url) .setHttpBody(body) .setHttpHeaders(header) .setReadTimeout(10000) //         //   30 . .setConnectTimeout(10000) //    (  30 .) .build();</span></span></code> </pre><br>  So we created our request.  To execute requests, we need the HttpExecutor class: <br><br><pre> <code class="java hljs">HttpURLConnectionClient httpURLConnectionClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpURLConnectionClient(); httpURLConnectionClient.setRequestLimit(<span class="hljs-string"><span class="hljs-string">"update_news_request"</span></span>, <span class="hljs-number"><span class="hljs-number">30000</span></span>); httpExecutor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpExecutor(httpURLConnectionClient);</code> </pre><br>  Let's figure it out.  The HttpExecutor constructor requires an implementation of the HttpConnection interface.  In our case, I use the implementation of HttpURLConnection (you can use another implementation).  The second line sets the time limit for a specific request (the same key that was specified when creating the request is used here).  That is, the server will not be accessed more than 30 seconds (in our case), all other attempts of this request will either go to the cache or do nothing at all.  This is useful when you need to reduce the load on the server. <br><br>  Now you can run the query: <br><br><pre> <code class="java hljs">RequestResponse response = httpExecutor.execute(request, RequestResponse.class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cache&lt;RequestResponse&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RequestResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syncCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RequestResponse data, String requestKey)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          //            return data; } @Override public RequestResponse readFromCache(String requestKey) { RequestResponse response = new RequestResponse(); response.hello = "hello from cache"; return response; } });</span></span></code> </pre><br>  <b>The first parameter</b> is the object of our request itself, the <b>second parameter</b> is the class in which the result of the request is written, and the <b>third parameter</b> is the implementation of the Cache interface, we will apply here if the request is made more often than indicated in the limit.  If you wish, you can not use Cache.  Everything is simple and convenient. <br><br><h3>  Work with threads </h3><br>  I decided to use <a href="http://habrahabr.ru/company/luxoft/blog/157273/">java.util.concurrent</a> to work with streams.  This package provides us with a bunch of handy tools and thread-safe data structures for working with multithreading. <br><br>  When communicating with the server, a number of problems arise that need to be solved. <br>  The first problem that needs to be solved is to make it so that two threads do not simultaneously execute the same request to the server. <br><br>  This is where Semaphore comes to the rescue.  Let's look at the code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomSemaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Semaphore&gt; mRunningTask; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomSemaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ mRunningTask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Semaphore&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String taskTag)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ Semaphore semaphore = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mRunningTask.containsKey(taskTag)) { semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Semaphore(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { semaphore = mRunningTask.get(taskTag); } semaphore.acquire(); mRunningTask.put(taskTag, semaphore); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String taskTag)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mRunningTask.containsKey(taskTag)) { mRunningTask.remove(taskTag).release(); } } }</code> </pre><br>  So how does this thing work? <br><br>  When the thread executes the request to the server, we give this thread a lock and save our Semaphore in the Map, where the key is the key of our request ‚Äúupdate_news_request‚Äù.  While the first thread fulfills the request, the second stream arrives with the same request and at this moment it checks if the Semaphore key is stored in the Map.  If there is one, then he tries to take a lock in this Semaphore, and since the first thread has already taken it, the second thread stops and waits until the first thread releases the lock.  Thus, two threads will not be able to simultaneously make the same request. <br><br>  Sometimes it is necessary that all requests to the server are executed only in turn.  Then we simply do not need to specify the key in the request and the default key will be the same for all. <br><br>  The second important problem arises when you need to make several requests in a row. <br><br>  For example, you need to log in to a social network, then get a user profile, then register with our server with the necessary data.  Thus, we get three requests.  In such cases, you do not need to do nested callbacks.  For example, you start another thread from a UI thread, which makes a request to the server, and then jerks a callback to the UI thread, which in turn starts another thread, which makes the next request - and so on.  This approach creates multi-storey nesting in the code that is difficult to read and debug.  A lot of unnecessary code is created.  But most importantly, from the point of view of multithreading, it is a bad practice to create a lot of threads without need and constantly pull the UI thread.  In such cases, it is better to make these three requests synchronous in one stream and process all the information in the same place, and send only the result to the UI stream. <br><br>  There is a convenient solution to do something on a timer.  For example, go to the server for updates every 30 seconds: <br><br><pre> <code class="java hljs"> ScheduledFuture&lt;?&gt; scheduledFuture = ThreadExecutor.doTaskWithInterval(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    } }, 0, 30, TimeUnit.SECONDS);</span></span></code> </pre><br>  This method also returns to us an implementation of the ScheduledFuture &lt;?&gt; Interface, with which we can stop the robot of our timer, and also request the result using the get () method.  Just need to remember that this method is blocking. <br><br>  Even in the ThreadExecutor class there are two convenient methods: <br><br><pre> <code class="java hljs">doNetworkTaskAsync(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Callable&lt;V&gt; task, <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorListener&lt;V&gt; listener) doBackgroundTaskAsync(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Callable&lt;V&gt; task, <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorListener&lt;V&gt; listener)</code> </pre><br>  The difference is that each has its own thread pool, which is quite convenient. <br><br><h3>  Conclusion </h3><br>  So we got to the finish.  Thank you all for your attention. <br>  All source codes can be found <a href="https://github.com/justplay1/Droidutils/">here</a> . <br>  Sound criticism is welcome. </div><p>Source: <a href="https://habr.com/ru/post/241415/">https://habr.com/ru/post/241415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241399/index.html">Textolite - a static site management system</a></li>
<li><a href="../241407/index.html">System for "My game"</a></li>
<li><a href="../241409/index.html">STM32 Nucleo. We connect TFT LCD based on ILI9341 chip</a></li>
<li><a href="../241411/index.html">Watch Translation in Russia October 26 and Java</a></li>
<li><a href="../241413/index.html">How does safe payment acceptance in the online store</a></li>
<li><a href="../241419/index.html">My little story of the development and publication of mobile games</a></li>
<li><a href="../241421/index.html">Endorphin flow mechanics on the example of three space games</a></li>
<li><a href="../241423/index.html">Create a package for Laravel</a></li>
<li><a href="../241427/index.html">VexorCI - What's new?</a></li>
<li><a href="../241433/index.html">Upgrade the rack solutions OCP and OCS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>