<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>And again about sorting: choose the best algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, at Habr√©, another one raised the topic of sorting algorithms, namely, the Timsort method was well described. 

 He, having a complexity of n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>And again about sorting: choose the best algorithm</h1><div class="post__text post__text-html js-mediator-article">  Recently, at Habr√©, another one raised the topic of sorting algorithms, namely, <a href="http://habrahabr.ru/blogs/algorithm/133303/">the Timsort method</a> was well described. <br><br>  He, having a complexity of no more than O (n log n), is accelerated in the case of sorting partially ordered data and has a complexity of O (n) if the data is initially sorted.  But this is not the only algorithm with such declared properties.  There are at least two more or less well-known methods with similar complexity - these are Smoothsort and Shell sorting. <br><br>  But the fact that they have a similar complexity does not mean at all that they all work equally fast.  I tried to compare their actual performance on different data and see who is better at their task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  Usually, the real time of operation of different algorithms with the same complexity on the same data may differ several times.  Let's remember why this happens and ask Wikipedia what the phrase ‚Äúthe algorithm has O (n log n) complexity‚Äù means <br><br><blockquote>  <em>The complexity of the algorithm O (n log n) means that for large n the running time of the algorithm (or the total number of operations) is no more than C ¬∑ n log n, where C is some positive constant.</em> <br></blockquote><br>  And this coefficient C influences the real time of the agitourt operation.  The more complex the algorithm, the more advanced the data structures used in it, the greater the number of operations that must be performed during the execution of the program to support all the necessary variables and structures.  That is, the greater the coefficient C and the real time of work.  Of course, this coefficient also depends on the specific implementation, but if you pay attention to the code you write and know the features of the development language, the main contribution to this constant will be made by the algorithm. <br><br>  Therefore, it was interesting to see what real performance gain each of these algorithms gives in the case of partially ordered data, and how significant this gain, if any, is.  For this, several experiments were carried out.  But for starters, I want, without going into details, to remind how the above-mentioned algorithms work.  If anyone is not interested, please immediately compare. <br><br><h3>  Compare Algorithms </h3><br><h4>  Timsort </h4><br>  Good description <a href="http://habrahabr.ru/blogs/algorithm/133303/">here</a> , just to quote the main idea: <br><ol><li>  A special algorithm splits the input array into subarrays. </li><li>  Each subarray is sorted by normal sorting by inserts. </li><li>  Sorted subarrays are assembled into a single array using modified merge sorting. </li></ol><br>  The complexity at best (the input data is sorted in any order, maybe even the opposite required) is O (n), and in general is not worse than O (n log n). <br>  O (n) extra memory required. <br><br>  The big advantage is that the algorithm is a combination of other fairly simple algorithms, therefore it does not require sophisticated operations with different data structures.  Therefore, good performance is expected. <br><br><h4>  Smoothsort </h4><br>  It was invented by the notorious E. V. Deikstroy in 1981 and is a development of the idea of ‚Äã‚ÄãHeapsort - sorting using the binary heap (well, or a pyramid, as you like). <br><br>  To begin, let me remind you how Heapsort works: <br><ol><li>  Build a heap by adding one element to it (complexity O (log n) for each, total O (n log n)) </li><li>  Extract the maximum element that lies in the root of the heap, until it becomes empty.  Since when a root is removed, the heap splits into two independent ones, it is required to collect them into one by O (log n).  In total for n elements - also O (n log n) </li></ol><br>  There is an optimization that allows you to perform the first step with O (n) complexity, but the second step will still have O (n log n) complexity. <br>  The algorithm requires O (1) additional memory, the heap is stored directly in the original data array. <br><br>  Dijkstra proposed replacing one binary heap in the algorithm with an ordered set of Leonardo heaps, which are based on special Leonardo numbers. <br><br>  Leonardo numbers are defined recurrently as follows: <blockquote><pre>  L (0) = 1, L (1) = 1, L (i) = L (i - 2) + L (i - 1) + 1 </pre></blockquote>  Here are the first few members of this sequence: <blockquote>  1, 3, 5, 9, 15, 25, 41, ... </blockquote><br>  <strong>Leonardo's k-th heap</strong> is a binary tree with the number of vertices L (k) satisfying the following conditions: <br><ol><li>  The number written in the root is not less than the numbers in the subtrees (and therefore a lot) </li><li>  The left subtree is (k-1) -I Leonardo heap </li><li>  Right - (k-2) -I </li></ol><br>  Heaps should be ordered by size (the largest - from the left), and the values ‚Äã‚Äãof their roots should be non-decreasing from left to right, from which it follows that the maximum element of the structure will always be the root of the right-most heap.  The structure is stored in the source array, the size of the additional memory is O (1). <br><br>  Any natural number can be decomposed into a sum of Leonardo numbers, which means that the structure described above can be constructed for any number of numbers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/862/85a/507/86285a5079f9ee27ad63706cd6890f52.png"><br>  <em>An example of the structure of Leonardo heaps for 13 elements.</em>  <em>Three heaps are used: 4th, 2nd and 1st.</em> <br><br>  To add an element to such a structure, it is necessary to rebuild some of the heaps so that the sum of their sizes becomes equal to the new number of elements, and also to make sure that the roots of the heaps remain ordered in ascending order.  Such an operation has a complexity of no more than O (log n). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/f57/363/7daf57363fb0d6048e16ee83be9c1b47.png"><br>  <em>When adding an item, you need to rebuild the heaps (Property of 1 Leonardo heap in the picture is not restored)</em> <br><br>  Extracting the maximum is similar to adding an element and also has a complexity of no more than O (log n). <br><br>  The Smoothsort sorting algorithm itself works in two stages, like Heapsort: <br><ol><li>  Adding one by one, a lot of Leonardo heaps are built for all elements (no more than O (log n) per each) </li><li>  Maximum elements are extracted from the constructed structure in turn (the root of the rightmost heap is always the maximum) and the structure is restored as necessary (no more than O (log n) per element) </li></ol><br>  The advantage of using such a structure is that in the case of an already sorted input sequence, heap operations and extraction of all elements will have total complexity O (n).  And it is argued that as the degree of ordering of the data to be sorted decreases, the complexity will smoothly (smoothly) increase from O (n) to O (n log n).  Hence the name - Smoothsort. <br><br>  In general, the algorithm is far from trivial, and in addition is not very clearly described.  Materials: <br>  <a href="http://en.wikipedia.org/wiki/Smoothsort">Wikipedia article</a> <br>  <a href="http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD796a.PDF">The original article</a> is incomprehensible, you have to understand for a long time. <br>  <a href="http://www.enterag.ch/hartwig/order/smoothsort.pdf">The original article, commented on by Hartwig Thomas</a> , is the same, but a normal font + explanatory comments.  But it doesn't get any easier :) <br>  <a href="http://www.keithschwarz.com/smoothsort/">The study of the algorithm from K. Schwarz</a> is already clearer, but some significant optimizations are not described at all.  Illustrations inserted from there. <br><br><h4>  Shellsort (Sort Shell) </h4><br>  Shell sorting is a superstructure above sorting inserts;  instead of one passage, we make several, and on the i-th passage, we sort the subarrays of elements standing apart from each other at a distance d <sub>i</sub> . <br><br>  In this case, on the last pass, d <sub>i</sub> must be equal to 1 (that is, the last step is the usual sorting by inserts), this guarantees the correctness of the algorithm. <br><br>  For example: let it be necessary to sort an array of 12 elements, the number of passes is 3, d <sub>1</sub> = 5, d <sub>2</sub> = 3, d <sub>3</sub> = 1 <br>  In the first step, the following arrays will be sorted: <br><blockquote>  (a1, a6, a11), (a2, a7, a12), (a3, a8), (a4, a9), (a5, a10) </blockquote><br>  On the second: <br><blockquote>  (a1, a4, a7, a10), (a2, a5, a8, a11), (a3, a6, a9, a12) </blockquote><br>  And on the third array (a1, ..., a12) entirely <br><br>  The advantage over the usual sorting by inserts is that in the first passes the array elements move not in steps 1, but in d <sub>i</sub> , but by the last pass some locality has already been reached (the elements are close to their final places), so there is no need to produce a large amount exchanges. <br><br>  The complexity of the algorithm depends on the choice of the number of passes and d <sub>i</sub> values, and can vary greatly;  Wikipedia has a special table.  For testing, I chose the option described <a href="http://algolist.manual.ru/sort/shell_sort.php">here</a> , in the worst case, its complexity is O (n <sup>4/3</sup> ), and on average O (n <sup>7/6</sup> ). <br><br>  If the data is initially sorted in the right order, then no exchange will be made, all passes will pass ‚Äúto idle‚Äù.  Therefore, the complexity in this case depends only on the number of passes.  If their number is fixed, then it will be just O (n). <br><br>  O (1) additional memory required. <br><br>  You can read more <a href="http://en.wikipedia.org/wiki/Shellsort">here</a> , <a href="http://algolist.manual.ru/sort/shell_sort.php">here</a> and <a href="http://www.youtube.com/watch%3Fv%3DCmPA7zE8mx0">here</a> . <br><br><h3>  Comparison </h3><br>  Actually, here's the most interesting part - to test all the above methods on different data and compare their real time. <br><br>  The following implementations took part in the testing, all code is written in pure C: <br><ul><li>  TimSort - a David R. Maclver implementation written for his <a href="http://www.drmaciver.com/2010/01/understanding-timsort-1adaptive-mergesort/">TimSort article</a> - Good, Optimized Implementation </li><li>  SmoothSort is one of my implementations, the fastest that I managed to write <br>  In general, writing this algorithm more or less effectively is not very easy.  You can probably write faster and more optimally, but after four attempts I decided not to continue :) </li><li>  ShellSort is an implementation based on an example <a href="http://algolist.manual.ru/sort/shell_sort.php">from here.</a> </li><li>  Also, the usual quicksort and heapsort recursive implementations were added to the comparison in order to be able to evaluate the advantages of the considered methods over the traditional </li></ul><br><h4>  Test parameters </h4><br>  Only the response time of the sorting algorithm (in seconds) was measured, the generation time of the test data was not taken into account.  Each algorithm was run on the same data three times, the best result was taken into account (so that the short-term system loads do not affect our honest experiment :)) <br><br>  Iron: HP dv3510er laptop, Intel Core 2 Duo 2GHz, 2GB RAM. <br>  OS: Ubuntu 11.10 <br><br>  Four experiments were performed on various data: <br><br><h4>  Experiment 1: Work on ordinary data </h4><br>  The objective of this experiment is to compare the performance of algorithms on arbitrary, in no way ordered data.  10 sets of 10 <sup>8</sup> random natural numbers were generated, the average operation time was measured for each algorithm. <br><br>  The complexity of all tested algorithms in the case of arbitrary data is equal (except for ShellSort) O (n log n).  Actually, here you can trace the influence of the very constant C. <br><br><img src="https://habrastorage.org/storage1/a0170f65/54afe800/d8b50571/a81000af.png"><br><br>  As we can see, the algorithms that do not use any data structures have pretty seriously gone ahead.  Further we will consider partially ordered data. <br><br><h4>  Experiment 2: Independent sorted groups of equal size </h4><br>  Given 10 <sup>8</sup> different natural numbers, sorted in ascending order.  We group them by k consecutive elements and rearrange all the groups in the reverse order. <br>  Example for ten numbers: 1 2 3 4 5 6 7 8 9 10 <br>  k = 1: 10 9 8 7 6 5 4 3 2 1 <br>  k = 3: 8 9 10 5 6 7 2 3 4 1 <br>  k = 5: 6 7 8 9 10 1 2 3 4 5 <br>  k = 10: 1 2 3 4 5 6 7 8 9 10 <br><br>  Groups are ‚Äúindependent‚Äù from each other in the sense that they do not intersect over the range of values ‚Äã‚Äãstored in them.  That is, elements of any group are larger than elements of all groups to the right, as well as less than those that are to the left. <br><br>  Measurements were made for all k equal to powers of 10. <br><br><img src="https://habrastorage.org/storage1/d0460884/b7d712b4/cd04f5c3/4c115b90.png"><br><br>  You may notice the following patterns: <br><ul><li>  Quicksort and Heapsort also love it when the data is partially sorted (compare both graphs).  It does not affect the asymptotic complexity, but the speed of work still increases several times </li><li>  Timsort doesn't care in which order the data is sorted, in both cases it works very fast </li><li>  Smoothsort has its own understanding of partial data ordering.  The real performance gain in this test is noticeable only with fully sorted data.  Even in the case when the array is a small amount of completely sorted pieces, in order to rearrange them in places, the algorithm needs to perform a huge number of operations with heaps of Leonardo, which are rather ‚Äúheavy‚Äù </li><li>  Shellsort, despite the greater complexity (with n = 10 <sup>8</sup> n <sup>7/6</sup> &gt; n log n), often works in less time than Smoothsort.  This is due to the relative simplicity of the algorithm.  But with fully sorted data, Shellsort is still forced to make all the passes, even if not rearranging a single element.  Therefore, for k = 10 <sup>8, the</sup> result is almost the worst of the algorithms considered. </li></ul><br><h4>  Experiment 3: Sorted groups of different sizes, limited range of values </h4><br>  10 <sup>8</sup> integers are given from a limited range (in our case [0 ... 100000]) and they are ordered by groups of arbitrary size from 1 to k. <br><br>  Such a data set already somehow corresponds to the data from real-world problems; I had to deal with those for calculating <a href="http://en.wikipedia.org/wiki/Dice%27s_coefficient">Dies proximity factors.</a> <br><br><img src="https://habrastorage.org/storage1/fd520aa1/8be42114/57e27349/d01105c5.png"><br><br>  In this example, Smoothsort showed itself from the wrong side again, it works longer than Heapsort, and behaves the same way.  Timsort is again ahead. <br><br><h4>  Experiment 4: Arbitrary Permutations </h4><br>  We will generate partially ordered data in another way: take 10 <sup>8</sup> arbitrary natural numbers, sort them and make k arbitrary permutations of two elements in places. <br><br><img src="https://habrastorage.org/storage1/0ac3016e/f3ce8871/2bf28d22/cb5cd3f2.png"><br><br>  And this experiment finally allows Smoothsort to ‚Äúopen up‚Äù: acceleration becomes noticeable with increasing degree of sorting of input data.  This is due to the fact that, unlike previous experiments, here the algorithm ‚Äúmoves‚Äù along Leonardo‚Äôs heaps only a very small fixed number of elements, which does not entail a large number of operations to move elements inside the heaps.  But after a certain point, he again becomes too "long." <br><br><h3>  Results </h3><br>  As you can see, the practical benefits of the described algorithms are there, they cope with their task with varying success.  Timsort became the absolute leader - giving a noticeable acceleration with increasing degree of data ordering and working at the Quicksort level in normal cases.  No wonder it is recognized and embedded in Python, OpenJDK and Android JDK. <br><br>  There is quite a bit of information about Smoothsort on the network (compared to other algorithms), and not surprisingly: because of the complexity of the idea and the controversial performance, it is rather an algorithmic sophistication than an applicable method.  I found only one real application of this algorithm - in the <a href="http://sofia-sip.sourceforge.net/">sofia-sip</a> library, intended for building IM and VoIP applications. <br><br>  The appearance of Shellsort in this test is a rather controversial point, because its asymptotic complexity is somewhat greater than that of the other two algorithms.  But it has two big advantages: the simplicity of the idea and the algorithm that almost always avoids Smoothsort in terms of speed and simplicity of implementation - working code takes only a few dozen lines, while good implementations of Timsort and Smoothsort require more than a hundred lines. <br><br>  I want to note that I compared exactly the performance, and did not specifically focus on other parameters (such as using additional memory). <br><br>  My subjective conclusion is that if you need a very good sorting algorithm for embedding in a library or a large project, then Timsort is best suited.  In the case of small tasks, where there is no time and the need to write complex algorithms, and the result is needed quickly, Quicksort can be easily dispensed with - as it gives the best performance that is simple in writing algorithms. <br><br>  Thanks for reading.  I hope you were interested. </div><p>Source: <a href="https://habr.com/ru/post/133996/">https://habr.com/ru/post/133996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133990/index.html">OpenOffice COM Automation: Reading Clipboard Content</a></li>
<li><a href="../133991/index.html">US court rejected Apple‚Äôs claim against Samsung</a></li>
<li><a href="../133992/index.html">Droider Show # 18. "Apple" is not passed!</a></li>
<li><a href="../133993/index.html">Filling Bitrix through internal integration mechanisms with 1C without 1C</a></li>
<li><a href="../133994/index.html">Creating a PostgreSQL Load Tester</a></li>
<li><a href="../133997/index.html">TES 5: Skyrim song bard</a></li>
<li><a href="../133998/index.html">Work with binary data using typed arrays</a></li>
<li><a href="../133999/index.html">Wanted.VC Digest # 24</a></li>
<li><a href="../134000/index.html">Tablets in the office: a change of mood in the headquarters of the CIO</a></li>
<li><a href="../134001/index.html">FINANCE.UA: our financial ports and information services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>