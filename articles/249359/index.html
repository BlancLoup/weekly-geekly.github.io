<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blowfish on guard ivi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are often contradictions between developers and products. The first ones are closer to the hardware and are responsible for it, the second ones ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blowfish on guard ivi</h1><div class="post__text post__text-html js-mediator-article">  There are often contradictions between developers and products.  The first ones are closer to the hardware and are responsible for it, the second ones are for the user interface.  Backend-developers do not want to load the system once again, store deliberately false unverified data, waste processor time and disk space.  In their worldview, a priori, all requests, all users are intruders who just want to score all the memory and disable the system.  If not for vandalism, then for the sake of competitors of similar services. <br><br><img src="https://habrastorage.org/files/f78/97c/fa1/f7897cfa157045738a7f696818484eef.jpg"><br><a name="habracut"></a><br>  For example, there are no problems to take and register a user in the database using the “email and password” combination.  If we do not send any mailings, do not work with monetary systems and user identification by his email is required solely for his convenience, then we still have a question about the hardware resources of our systems.  By running an infinite loop with requests for registration, we can drive all the disks, and the system will fail.  Therefore, we have to force users to make such inconvenient steps in the form of confirming their email.  The same thing happens with reference to phone numbers.  The same is true for linking social network accounts that have been delegated user identification tasks. <br><br>  There will always be those who are able to raise their own mail server.  Creating virtual mailboxes, clicking on confirmation links in them is trivially automated, which again can damage server resources.  However, in reality this happens so rarely that against the general statistical background of all requests it will be clearly traceable and the consequences are preventable.  A rarity: due to the high threshold of entry for registration in the system.  It is the entry threshold that, in its majority, eliminates the attempts of intruders. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#fd004c">The threshold of entry of mere mortals</font> </h2><br>  The ideal world of product managers does not contain any complex technical systems in the form of postal systems, referrals and other things.  The ideal end result for them is when the user, or rather his software client (a program in the browser, among other things), identifies and authenticates himself as a unique entity.  The user connects to the service, and he immediately recognizes it without unnecessary gestures in the form of SMS-ok and links.  In addition to unnecessary actions, this requires the user and binding to third-party services, for which he, too, will have to spend time. <br><br>  The ideal solution to the forehead is when the program simply generates a random large number (random enough so that it does not coincide with anyone else) and will use it as an identifier.  Each user is his own service and authentication tool.  We assume that it has a reliable secure long-term storage of this identifier and all communication with us occurs over an encrypted trusted channel ( <a href="https://ru.wikipedia.org/wiki/TLS">TLS</a> ). <br><br>  There remains one “but”: the threshold for entering such software solutions is almost zero for registration.  A software client can be both a good person and forgotten about the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B0_%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B8">laws of Azimov as a</a> robot. <br><br>  As a solution, you can enter something that would distinguish a robot from a human: <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D0%25BF%25D1%2587%25D0%25B0">CAPTCHA</a> .  Quite simply implemented and working effectively.  At a minimum, it gives a sufficient entry threshold to weed out many vandals (but not competitors who buy Chinese discriminator farms).  However, such a decision is strongly disliked both by users breaking eyes and nerves, and, accordingly, by products. <br><br><h2>  <font color="#fd004c">Prove that worked</font> </h2><br>  One of the solutions we use is a good old <a href="https://ru.wikipedia.org/wiki/Proof-of-work">proof-of-work</a> (PoW) system, known since the beginning of email spam, which (whether it is a robot or not) did not have enough data to identify.  Once in our context, we want to secure the waste of our resources, since sending data by the client is a much cheaper operation, then PoW is a means of restoring equity because the user will have to work out their right to process the request. <br><br>  Proof-of-work is a technology in which it is necessary to expend the minimum established work in order to perform an action.  This work is resource-intensive, but verification of the success of its implementation is cheap.  If someone wants to spend our resources, then with a hundredfold difference between the check and the solution to the work, the attacker will have to spend a hundred times more resources than necessary.  As a rule, it will be economically disadvantageous. <br><br>  The user does not have to enter any CAPTCHA or depend on third-party services.  It only has to warm up its processor a bit, transparently for the interface. <br><br>  The client-server operation scheme is simple: <br><br><pre> ──────┐ ┌──────┐
 │Customer│ │Server│
 ──┬───┘ └──┬───┘
    │ JSON-RPC REQUEST │
    ─────────────────────────────&gt;
    │ │
    │ TASK │
    │ &lt;─────────────────────────────
    │ │
    ────┐ │
    │ │ Solve (TASK)
    │ &lt;───┘ │
    │ │
    │ REQUEST, TASK, SOLUTION │
    ─────────────────────────────&gt;
    │ │
    │────┐
    │ │ │ Check (TASK, SOLUTION)
    │ │ &lt;───┘
    │ │
    │ Result of the request
    │ &lt;─────────────────────────────
</pre><br>  The data bound to the task conditions are not stored in the database and therefore must be authenticated, for example, using <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BC%25D0%25B8%25D1%2582%25D0%25BE%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0">cryptographic signatures</a> .  And in order to avoid the possibility of repeating the request, then at least, for example, tie to the time and give clear deadlines for the task. <br><br>  If the client's request is a JSON-structure <b>REQ</b> , then the client in the response from the server receives: <br><br><pre><code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"req"</span></span>: REQ, <span class="hljs-attr"><span class="hljs-attr">"bestbefore"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"task"</span></span>: TASK, <span class="hljs-attr"><span class="hljs-attr">"sign"</span></span>: <span class="hljs-string"><span class="hljs-string">"SIGN"</span></span>}</code> </pre> <br>  The client sends in response: <br><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"req"</span></span>: REQ, <span class="hljs-attr"><span class="hljs-attr">"bestbefore"</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">"task"</span></span>: TASK, <span class="hljs-attr"><span class="hljs-attr">"sign"</span></span>: <span class="hljs-string"><span class="hljs-string">"SIGN"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"answer"</span></span>: RESULT}</code> </pre><br>  where <b>bestbefore</b> is the time until which a given query can be executed, TASK is the initial conditions of the problem, and <b>SIGN</b> is the cryptographic signature of the entire serialized dictionary.  <b>RESULT</b> is a solution to a problem. <br><br>  If the client tries to change his original request, the signature will be invalid.  If he tries to do it again, after some time (for example, after the comment is published), the server, having checked with his watch, invalidates the request.  If the client tries to substitute a previously solved task, the signature will also be invalid. <br><br>  Instead of time binding, you can issue one-time tokens that are randomly generated.  For the sake of simplicity, you can keep it in <a href="http://redis.io/">Redis</a> and make a limited lifetime.  Upon request, we read 16 bytes (128 bits) from <a href="https://ru.wikipedia.org/wiki//dev/random_%25D0%25B8_/dev/urandom">/ dev / urandom</a> and put this line in Redis for ten seconds.  This token should appear in the client's response.  If it is still in Redis, then we delete and process the request.  When reused, the server no longer knows such a token.  Their short time of life guarantees us that it will not be possible to score and disable Redis, except that only with large communication channels and capacities. <br><br>  It would be even better to add some unique identifier to the request, leaving the <b>bestbefore</b> .  If the task is successfully verified, we will save this identifier in Redis with the remaining lifetime.  Thus, when issuing tasks, we do not save anything.  The user will have to solve the problem to try to repeat the action, but only within the remaining time he has the opportunity to commit them, while it is really <b>bestbefore</b> .  For a server, this translates into a cheap PoW check and a key existence check in Redis. <br><br><pre> <code class="hljs perl">TASK_SIGN_KEY = <span class="hljs-string"><span class="hljs-string">"ff7555ded9526ecf03b1617a61514d30"</span></span>.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) TASK_LIFETIME = <span class="hljs-number"><span class="hljs-number">60</span></span> def task_generate(req): result = { <span class="hljs-string"><span class="hljs-string">"req"</span></span>: req, <span class="hljs-string"><span class="hljs-string">"bestbefore"</span></span>: datetime.utcnow() + timedelta(seconds=TASK_LIFETIME), <span class="hljs-string"><span class="hljs-string">"task"</span></span>: task_new(), <span class="hljs-string"><span class="hljs-string">"id"</span></span>: urandom(<span class="hljs-number"><span class="hljs-number">16</span></span>).encode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>), } result[<span class="hljs-string"><span class="hljs-string">"sign"</span></span>] = sign(TASK_SIGN_KEY, serialize(result)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result def task_validate(req): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re<span class="hljs-string"><span class="hljs-string">q["bestbefore"]</span></span> &lt; datetime.utcnow(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False signature = req.pop(<span class="hljs-string"><span class="hljs-string">"sign"</span></span>) answer = req.pop(<span class="hljs-string"><span class="hljs-string">"answer"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> constant_time_compare(signature, sign(TASK_SIGN_KEY, req)): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> redis.exists(re<span class="hljs-string"><span class="hljs-string">q["id"]</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False redis.setex(re<span class="hljs-string"><span class="hljs-string">q["id"]</span></span>, TASK_LIFETIME) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> task_verify(re<span class="hljs-string"><span class="hljs-string">q["task"]</span></span>, answer): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre><br>  Do not forget that any strings used in cryptography and requiring comparison should not be compared simply out of the box with native language tools.  Comparison of "==" will be optimal in performance and, roughly speaking, the operation will be completed at the first unmatched byte: as a result, the test time is not constant and because of this you can make powerful attacks in the case of TLS that are able to decrypt the entire message.  Frequent practice (though not optimal in terms of performance) is a comparison through HMACs: <br><br><pre> <code class="hljs lisp">hmac(<span class="hljs-name"><span class="hljs-name">compare_key</span></span>, string1) == hmac(<span class="hljs-name"><span class="hljs-name">compare_key</span></span>, string2)</code> </pre><br>  At the same time, the comparison time is not constant, but randomized, which will prevent attacks aimed at leaking string comparison time information. <br><br><h2>  <font color="#fd004c">Tasks</font> </h2><br>  What can these tasks represent?  At the first approach to the projectile, we decided to use a part already from the 1970s of the famous <a href="https://en.wikipedia.org/wiki/Merkle%27s_Puzzles">Merkle puzzles</a> .  Officially, this can be considered the first asymmetric key exchange system, looking at which the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Diffie-Hellman</a> algorithm was invented.  Each puzzle is an encrypted line and a part of the decryption key.  If this is the <a href="https://ru.wikipedia.org/wiki/DES">DES</a> encryption algorithm, then a full brute-force search takes an average of 2 ^ 55 operations.  We can give 5 bytes (40 bits) of this key, and then it will be necessary to do 2 ^ 15 operations, that is, more than 32 thousand decryption operations.  The result of the decision will be the rest of the key: the missing two bytes.  Checking the solution on the server is a single decryption operation.  Previously it is possible to agree that the line “YOUBROKE” is encrypted. <br><br>  It is not very difficult to estimate what the parameters of such tasks should be.  We take the lowest-performing device supported, which can be found in large quantities among users.  We assume that there is old software with not very optimal implementations of algorithms (for example, it is JavaScript in the browser).  We set the maximum timeout for the user and see how many iterations can be performed.  We understand how many bits of the key not to disclose. <br><br>  What encryption algorithm do you prefer?  The choice is huge.  It would be desirable to be legally clean when using it, not to pay, so that it is both fast and cryptographically secure (although we are not secrets to transmit).  Most importantly, at the same time its implementations are on all platforms.  Among the platforms supported by ivi are Web browsers, iOS, Android, SmartTV and others.  Everywhere its developers, who, of course, would not want to write a lot of code.  JavaScript does not have any built-in cryptographic tools.  If <a href="https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> library implementation was everywhere, then the choice would be obvious - the path of least resistance (if you don’t get involved with the state, then GOST is not dictated). <br><br>  The choice fell on <a href="https://ru.wikipedia.org/wiki/Blowfish">Blowfish</a> - the block cipher known since 1993, developed by the famous cryptographer <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25BD%25D0%25B0%25D0%25B9%25D0%25B5%25D1%2580,_%25D0%2591%25D1%2580%25D1%258E%25D1%2581">Bruce Schneier</a> .  It fully satisfies the set conditions, has completely free and open implementations.  Yes, there are certainly more technically advanced algorithms, but their code is either more complicated, or the algorithm is not so well known, or there are not so many implementations in various languages.  Ciphers such as <a href="https://ru.wikipedia.org/wiki/RC4">Arcfour</a> and <a href="https://ru.wikipedia.org/wiki/Salsa20">Salsa20</a> are simpler, but they are streamed, and this limits the scope of application, which will be <a href="https://ru.wikipedia.org/wiki/RC4">discussed</a> below.  In general, the <a href="https://ru.wikipedia.org/wiki/XTEA">XTEA</a> cipher is also excellent, but human subjectivity is everywhere present and Schneier's weight was decisive. <br><br>  In addition, in all the tasks below, this cipher is used only in encryption mode, without requiring code to decrypt.  Since this is <a href="https://ru.wikipedia.org/wiki/%25D1%25E5%25F2%25FC_%25D4%25E5%25E9%25F1%25F2%25E5%25EB%25FF">a Feistel network</a> , decryption is simply an inversion of the course of operations, but it also takes its share of unused code. <br><br><h2>  <font color="#fd004c">Birthdays</font> </h2><br>  The task of finding the decryption key has a serious drawback: there is too much difference in performance between user devices.  The JavaScript code in the browser on the ARM processor is several orders of magnitude slower than what will be running on a modern PC with implementation on C. The quantitative difference becomes qualitative: either the user of mobile devices waits too long for a PoW solution, or the complexity on the PC becomes insignificant and sending traffic It will be much more expensive. <br><br>  The available resource available on all platforms except the processor is RAM.  The tasks of the processors can be implemented in hardware in the form of ASIC and FPGA solutions with higher performance per currency unit.  But the difference in memory performance on various platforms available to users is much less significant. <br><br>  A well-known algorithm for storing passwords <a href="https://ru.wikipedia.org/wiki/Scrypt">scrypt</a> uses random access memory to speed up calculations.  If everything is done on the processor, the calculations will take a very long time.  The difference is so great that ASIC / FPGA or powerful Intel Xeon processors will play absolutely no role if there is no memory. <br><br>  The solution adopted by ivi is the use of memory as a cache in the problem of searching for collisions between the results of the <a href="https://en.wikipedia.org/wiki/Pseudorandom_permutation">PRP</a> function (pseudo random permutation is a pseudo-random permutation). <br><br>  In probability theory there is a <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BA%25D1%2581_%25D0%25B4%25D0%25BD%25D0%25B5%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">paradox of birthdays</a> : if a group of 23 or more people is given, then the probability that at least two of them have birthdays (number and month) coincide, exceeds 50%.  If we take a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">hash function</a> with a 128-bit output, then the probability that two different inputs match the hash value will be one per 2 ^ 64. <br><br>  As a certain hash value, we use part of an encrypted piece of data.  For example, we take only three bytes from the encrypted data (we have 24-bit similarity to the hash function).  The server sends the key to be used for encryption.  In the client, rules for searching / collision searching are pre-protected: for example, these will be two line spaces with the length equal to the size of the cipher block used by the algorithm.  One row space is “XXXXXXX1”, “XXXXXXX2”, “XXXXXXX3” and so on.  The second is “YYYYYYY1”, “YYYYYYY2”, “YYYYYYY3” and so on.  Each element of this space is encrypted and the last 3 bytes are taken from the result.  The entire space of the first sequence is stored in RAM.  During the calculation of the second sequence, we look for matching elements with the first sequence and remember these collisions.  For example, for some given key, the element with sequence number 123 will have the same value of our hash with the element of the second sequence with sequence number 5678: that is, the last three bytes of the encrypted line “XXXXX123” will match the last three bytes of the encrypted line “YYYY5678”.  The stored hashes of the first sequence are our cache.  The required cache size (so that, for example, at least 60% of collisions fall) depends on the size of the hash values. <br><br>  The task itself is: <br><br><pre> <code class="hljs json">{<span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1048576</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">4096</span></span>}</code> </pre><br>  where <b>KEY</b> is a random encryption key, <b>size</b> is the size of the sequence to cache, and <b>count</b> is the minimum number of collisions to find.  The solution is a list of pairs of consecutive sequence numbers, where the collision was found (in our case, one of the pairs is 123 and 5678). <br><br><pre> <code class="hljs kotlin">def solve(key, size, count): bf = Blowfish(key) cache = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(size): <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = str(i) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-string"><span class="hljs-string">"X"</span></span> * (<span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = bf.encrypt(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) cache[<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>[-<span class="hljs-number"><span class="hljs-number">3</span></span>:]] = i collisions = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(size): <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = str(i) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = <span class="hljs-string"><span class="hljs-string">"Y"</span></span> * (<span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = bf.encrypt(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) found = cache.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>[-<span class="hljs-number"><span class="hljs-number">3</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> found: collisions.append((found, i)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(collisions) == count * <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collisions</code> </pre><br>  For our task from the server from the example, the client needs to perform 1048576 + 4096 encryption operations (minimum) or 1048576 + 1048576 (maximum) and three megabytes of RAM at least (in practice, a little more to store the list of hashes of the first sequence in the form of a tree to quickly find the presence of element in it).  To check, you need to perform 4096 + 4096 encryption operations and have a little more than 4 kilobytes of RAM (overhead for the work of Blowfish). <br><br>  It is highly desirable that the required number of elements be such that in the vast majority of cases, force the client to go through the entire second sequence (estimate how many collisions there are at a given cache size and take a number around this).  It is also very important to estimate the size of the cache: it can be small enough to fit completely into the cache of the processor of the second or even the first level, which will give a significant acceleration of the calculations. <br><br><h2>  <font color="#fd004c">Davier mayer</font> </h2><br>  As mentioned above, platforms that only have JavaScript do not have ready-made cryptographic tools, such as even hash functions.  There are often situations where the use of hashes is constantly required due to convenience. <br><br>  Known common functions such as MD5, SHA1, SHA2 for such platforms will have to implement (or use someone else's implementation) independently.  For political reasons, the choice of licensing restrictions can be drastically reduced.  More code means more likelihood of errors. <br><br>  Since we already have a working block cipher, it can be easily applied to data hashing tasks.  Most of the hash functions are based on <a href="https://en.wikipedia.org/wiki/One-way_compression_function">one-way compression functions</a> .  The function has two inputs and one output, all of the same size.  Upon exiting the function, it is impossible to recover and assume what was at the inputs.  A regular block cipher almost has this property and therefore it can be used as a function of compression.  This structure is called the <a href="https://en.wikipedia.org/wiki/Davies-Meyer">Davier-Meier</a> function. <br><br><pre>       ───────────────────┐
       │ ∨
     ───┐ ┌───┐ ┌─────┐
 ──&gt; │ H │ ──&gt; │ E │ ──&gt; │ XOR ──&gt;
     ───┘ └───┘ └─────┘
                 ∧
                 │
                 │<font></font>
<font></font>
                 m
</pre><br>  The message is divided into parts of <b>m</b> (the length of each is equal to the length of the cipher block), each part is encrypted.  Ciphertext <b>H of the</b> previous block is used as the encryption key.  The very first iteration uses predefined constants. <br><br><pre> <code class="hljs kotlin">def hasher(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> += <span class="hljs-string"><span class="hljs-string">"\x80"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>: pad_length = <span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pad_length = <span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) % <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> += <span class="hljs-string"><span class="hljs-string">"\x00"</span></span> * pad_length prev = <span class="hljs-string"><span class="hljs-string">"1aec98c401022e7c"</span></span>.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>): bf = Blowfish.new(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[i:i + <span class="hljs-number"><span class="hljs-number">8</span></span>]) prev = strxor(bf.encrypt(prev), prev) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev</code> </pre><br>         ,      <a href="https://en.wikipedia.org/wiki/Padding_(cryptography)"> (padding)</a> .  : <br><br><ul><li>        ,        <br></li><li>  «1»,      (   MD5  SHA1    ) <br></li><li>    ,         (ANSI X.923) <br></li><li>   ,          (ISO 10126) <br></li><li>    ,      (PKCS 7) <br></li></ul><br><br>   -   .  Blowfish    : 64 .     ,       (  ),      64   (  128  ).       TLS. ,       ,    . <br><br>      - -  ,      .  ,  ,  -    ,    ,         . <br><br>      - SHA2  ,       AES? - .          .      :  Blowfish           .  Blowfish    - ,   <a href="https://ru.wikipedia.org/wiki/S-%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8">S-</a>       ,    DES,    . <br><br> -        .  -   Arcfour  Salsa20  .  Salsa20      <a href="https://ru.wikipedia.org/wiki/BLAKE_(%25D1%2585%25D0%25B5%25D1%2588-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F)">BLAKE</a> -,              Salsa20 . <br><br><h2> <font color="#fd004c"> </font> </h2><br>        ,    -,            <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%259C%25D0%25B5%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B5"> </a> ,        . <br><br>        <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">PKI</a>  TLS.            TLS.          (  ,    curl,   ),    ,    TLS   ,   . <br><br>      ,  ,    -  JavaScript,  , ,      <a href="https://en.wikipedia.org/wiki/EdDSA">Ed25519</a>  ,  <a href="http://www.cypherpunks.ru/asymmetric/rsa/padding.html">padding     RSA</a>    —     .          ,          . <br><br>    :        —       .     :    ivi ,            .                , ,        (,  <a href="https://ru.wikipedia.org/wiki/CHAP">CHAP</a> )  ,      . <br><br> MAC (message authentication code)      .    MAC  <a href="https://ru.wikipedia.org/wiki/HMAC">HMAC</a>     (        ,   <a href="https://en.wikipedia.org/wiki/Poly1305">Poly1305</a> ).       <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%259C%25D0%25B5%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B0_%25E2%2580%2594_%25D0%2594%25D0%25B0%25D0%25BC%25D0%25B3%25D0%25B0%25D1%2580%25D0%25B4%25D0%25B0"> -</a> (       ).    ,       . <br><br>    HMAC     ,     .   MAC   ,     -. , MD5    ,   -    ,   HMAC-MD5   .        MAC,  <a href="https://ru.wikipedia.org/wiki/CBC-MAC">CBC-MAC</a> ,        <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B6%25D0%25B8%25D0%25BC_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">CBC-</a>              MAC. <br><br>  «»    CBC-MAC :        .   , -  CBC-,      MAC-,    ,     .   :           .         .            . <br><br>       JSON,           .      .          MAC. <br><br><pre> <code class="hljs kotlin">def mac(k, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = struct.pack(<span class="hljs-string"><span class="hljs-string">"!I"</span></span>, len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) + <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>: pad_length = <span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pad_length = <span class="hljs-number"><span class="hljs-number">8</span></span> - len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) % <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> += <span class="hljs-string"><span class="hljs-string">"\x00"</span></span> * pad_length k = Blowfish.new(k) prev = <span class="hljs-string"><span class="hljs-string">"\x00"</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>), <span class="hljs-number"><span class="hljs-number">8</span></span>): prev = bf.encrypt(strxor(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[i:i + <span class="hljs-number"><span class="hljs-number">8</span></span>], prev)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev</code> </pre><br>   MAC         PoW     ,      ,         ,  Blowfish. <br><br><h2>  <font color="#fd004c">findings</font> </h2><br><ul><li>     , , ,    . <br></li><li>       .       Blowfish  ,          .       RSA  ,      . <br></li><li>      . <b></b>     ,     .   .     <a href="https://www.schneier.com/blog/archives/2011/04/schneiers_law.html"> </a> ,       . <br></li><li>    ,   .  <b></b>        . <br></li><li>         .              ,          ,   ,    cookie.  ,        /       ,       . <br></li></ul><br>  All the best, do not switch! <br><br> ©  , Python  Go  ivi.ru </div><p>Source: <a href="https://habr.com/ru/post/249359/">https://habr.com/ru/post/249359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249335/index.html">We connect Ethernet ENC28J60 via SD card-reader for WEB-Servera to Arduino</a></li>
<li><a href="../249341/index.html">APEX: Why using HTML as part of SQL queries for Interactive Report can be dangerous?</a></li>
<li><a href="../249347/index.html">Invitation to FOSDEM 2015</a></li>
<li><a href="../249351/index.html">Features of creating NSString</a></li>
<li><a href="../249357/index.html">A compass pointing to the north, or how trigonometry came in handy to me</a></li>
<li><a href="../249361/index.html">Using TypeScript (using the example of angularjs) in Visual Studio 2015</a></li>
<li><a href="../249363/index.html">Car Tutorial Guide (Unity3d): Exploring an Alternative Physical Model (part 1 of 3)</a></li>
<li><a href="../249367/index.html">Templater - template manager and tweaker for MantisBT</a></li>
<li><a href="../249369/index.html">Why companies do not know how to handle money</a></li>
<li><a href="../249371/index.html">Making the game 2048 on AngularJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>