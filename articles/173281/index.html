<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Single Instance Applications on Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now I am actively writing under Qt. And I got a problem to check when you start the application, and not whether it is already running. Under Linux. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Single Instance Applications on Qt</h1><div class="post__text post__text-html js-mediator-article"> Now I am actively writing under Qt.  And I got a problem to check when you start the application, and not whether it is already running.  Under Linux.  I didn‚Äôt want to build bicycles, I wanted to give birth to something using ready-made Qt classes, so that it was immediately cross-platform.  In Windows, for example, there is a ready-made solution - named mutexes (or semaphores, it doesn't matter, the main thing is named).  Began to google.  Aha, in Qt there is something similar, called <code>QSystemSemaphore</code> . <a name="habracut"></a>  It works like this: <br><br>  - create an instance of the <code>QSystemSemaphore</code> class, it creates a global (system) semaphore <br>  - call <code>acquire</code> , reduce the semaphore count by one <br>  - do something <br>  - by calling <code>release</code> , increment the semaphore count by one <br><br>  In general, the classic semaphore, only global.  It is clear that if we create a semaphore with an initial counter value of 1 and call <code>acquire</code> , then until we call <code>release</code> no one else can capture the semaphore.  Hurray, the solution is found!  The following code of the single-instance application immediately appears: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - create semaphore <br>  - capturing <br>  - the application is running <br>  - after shutdown, the application releases the semaphore <br><br>  Everything is great, everything is beautiful.  Documentation promises us that even if you do not call <code>release</code> (for example, the program has crumbled), the system will still return all units captured from it to the semaphore.  But there is a problem.  If the user starts the second instance of the application - how will he know about it?  The call to the <code>acquire</code> blocking method and until the semaphore is released the application will ‚Äúhang‚Äù, and the user is at a loss for something to wait. <br><br>  It would seem - not a problem.  For example, the same <code>QMutex</code> besides calling <code>lock</code> to capture a mutex, has a call and <code>try_lock</code> for a non-blocking capture attempt.  There should be something similar in the system semaphore.  But - alas - it is not.  I have been googling long and unsuccessfully - the forums are full of similar topics and not a single working solution.  Problem?  Problem.  Interesting?  Quite.  I undertook to solve it. <br><br>  With the help of one <code>QSystemSemaphore</code> obviously nothing will be resolved.  What else is in Qt from global?  Still have <code>QSharedMemory</code> .  Memory shared between different applications.  It works like this: <br><br>  - create an instance of the <code>QSharedMemory</code> class <br>  - call <code>attach</code> to connect to already created memory <br>  - if the connection failed - call <code>create</code> to create shared memory <br>  - we work with shared memory (for example, we transfer some data to another process) <br>  - the destructor itself causes <code>detach</code> and detachment from shared memory <br><br>  It would seem - that's it!  If the call to <code>attach</code> was successful, then the application is already running.  If not, the application is started for the first time, we call <code>create</code> and, thus, we secure our superiority in the issue of ownership of shared memory (i.e., all other <code>attach</code> will already be successful).  There are actually two problems here. <br><br>  The first is racing.  Two processes can invoke attachments at once, fail them, both will assume that they are the first and call <code>create</code> .  One will create a memory, the other will fail.  Not good, but, in general, tolerated.  You can get around. <br><br>  The second problem is more serious.  It turns out the <code>QSharedMemory</code> Linux implementation <code>QSharedMemory</code> designed so that if <code>QSharedMemory</code> is not caused to memory, it is not destroyed.  Simply put, if a process joins shared memory and then crashes, the memory will remain created.  And the next <code>attach</code> call will succeed.  Those.  the abnormal termination of a single instance of the application will result in no more instances of the application being created.  Hmm. <br><br>  Thus, we have two classes - <code>QSystemSemaphore</code> and <code>QSharedMemory</code> , each of which partially implements the necessary functionality, but does not completely solve the final task.  Maybe it will be possible to combine these two "underclass" harmoniously? <br><br>  And yes!  <code>QSystemSemaphore</code> solves the first problem <code>QSharedMemory</code> , the problem of racing.  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QSystemSemaphore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"&lt;Unique name1&gt;"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRunning; sema.acquire(); <span class="hljs-function"><span class="hljs-function">QSharedMemory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shmem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"&lt;Unique name2&gt;"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shmem.attach()) { isRunning = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { shmem.create(<span class="hljs-number"><span class="hljs-number">1</span></span>); isRunning = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } sema.release();</code> </pre> <br><br>  Simply put, the global semaphore synchronizes shared memory management.  As they say, elementary, Watson. <br><br>  The second problem, as it turned out, also has a solution.  Pretty funny.  In order for the Linux implementation of shared memory to check the counter of references to it and destroy it, if there are no more links, it is enough to join it and disconnect.  And if, as a result of the abnormal termination of the previous instance of the application, there remains an unloaded shared memory with a zero (actually) reference counter, connecting to it and immediately disconnecting it will destroy this memory.  And if the reference count is non-zero, it will remain the same.  What, in general, and required. <br><br>  The final code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QSystemSemaphore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"&lt;Unique name1&gt;"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRunning; sema.acquire(); { <span class="hljs-function"><span class="hljs-function">QSharedMemory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shmem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"&lt;Unique name2&gt;"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; shmem.attach(); } <span class="hljs-function"><span class="hljs-function">QSharedMemory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shmem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"&lt;Unique name2&gt;"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shmem.attach()) { isRunning = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { shmem.create(<span class="hljs-number"><span class="hljs-number">1</span></span>); isRunning = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } sema.release();</code> </pre> <br><br>  It is clear that the second instance of the <code>QSharedMemory</code> class <code>QSharedMemory</code> be kept until the end of the application.  And then everything works exactly as needed. </div><p>Source: <a href="https://habr.com/ru/post/173281/">https://habr.com/ru/post/173281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173269/index.html">My version of "gravitsapy"</a></li>
<li><a href="../173271/index.html">Why HTML coders don't like web designers</a></li>
<li><a href="../173273/index.html">On artificial intelligence in poker</a></li>
<li><a href="../173275/index.html">Dependency injection in a Doctrine entity using the Symfony Dependency Injection Component</a></li>
<li><a href="../173277/index.html">Tetris first person</a></li>
<li><a href="../173283/index.html">Qt driver assembly for working with PostgreSQL (Windows)</a></li>
<li><a href="../173285/index.html">Freelancer - the story of one pentest</a></li>
<li><a href="../173287/index.html">Rapidly Deploy Development Environment for Ruby on Rails</a></li>
<li><a href="../173291/index.html">Re-flashing network storage NS-2502 from Edimax through the console cable</a></li>
<li><a href="../173293/index.html">Installing your own applications without a developer certificate in 7 steps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>