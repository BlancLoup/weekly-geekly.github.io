<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cocoa Delphi Flavored</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There comes a moment in the life of every man when, having looked at the latest global statistics on the use of operating systems, he realizes that th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cocoa Delphi Flavored</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="http://www.tamos.com/temp/hb/shot0.png" alt="Cocoa delphi flavored"></div><br>  There comes a moment in the life of every man when, having looked at the latest global statistics on the use of operating systems, he realizes that the time has come for a big change.  It‚Äôs not at all necessary to change the house, work and wife, but it‚Äôs worth trying to reach an audience that has grown significantly over the last ten years.  It will be about development on Delphi for macOS (nee OS X) and how we in the TamoSoft company chose tools, mastered the new, studied, were undermined by mines and enjoyed the process. <br><a name="habracut"></a><br><h3>  Task </h3><br>  Departure point: our main product TamoGraph Site Survey is a tool for inspecting Wi-Fi networks, which allows you to build coverage maps, optimize the placement of access points, create virtual models of signal propagation and do many more useful things for engineers working in this area.  TamoGraph works under Windows.  Destination point: well, you guessed it.  TamoGraph, which would work under macOS. <br><br>  The product is written mostly in Delphi, individual modules are written in C ++.  Why Delphi?  (Variants of the question: Is he not dead yet? Are you sick? Language X is much better, and you are retrogrades unable to master the new!) Friends, why we are using the not so fashionable and popular language / environment (according to <a href="http://www.tiobe.com/tiobe-index/">Tiobe</a> , today is Object Pascal The 11th most popular language is a lot.  This is an excellent productivity, and yes, the power of habit, and a fast compiler, but the main reason lies entirely in the field of technology.  We just like to write in Delphi, we get the buzz from it.  And when the product is written with pleasure and love, it usually works well.  So let's not engage in religious controversy, but go directly to the case. <br><br>  So, from the point of departure (Windows, Delphi) we have to get to the destination by the shortest route (macOS, as yet unknown language / environment).  The following main options were considered: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Redo everything on Xcode using Swift or Objective-C. <br>  2. Redo much of the Xcode using part of the existing Delphi-code in the form of dynamic libraries. <br>  3. Transform most of it in Delphi using the FMX framework (FireMonkey), and write a small part of the code in Objective-C and use it in the form of dynamic libraries. <br>  4. Redo everything on RemObjects Elements using Oxygene, their kind of Object Pascal. <br><br>  Each option, of course, found many advantages and disadvantages.  Xcode is the complete native GUI, the absence of any problems when interacting with the operating system, the mass of sample code and libraries.  But, and this is a very big ‚Äúbut‚Äù, with all this ‚Äúin the bundle‚Äù there is the need to rewrite a lot of code into another language.  RemObjects Elements is also a complete GUI native, very close to Object Pascal language, which means that existing non-GUI code could be used with relatively minor changes.  However, none of us have yet tried this tool.  And finally, Delphi FMX.  One of the advantages is the use of the existing debugged code to its fullest, familiar environment, but non-native controls (although, as it turned out, this is not quite true, more detailed below), possible difficulties in interacting with the macOS API, and many other doubts. <br><br>  Having deliberately conferred and having carried out some tests, we, as you guessed from the title of this article, stopped at option (3), i.e.  Delphi FMX.  The possibility of not rewriting a significant part of the code was very attractive.  And, to admit, I really didn‚Äôt like RemObjects Elements, which I was initially inclined to.  So, the choice is made, roll up their sleeves and go ... <br><br><h3>  Art preparation </h3><br>  Part of the team already at least had experience of close communication with macOS and was well aware of its structure.  Some of them were completely newcomers who needed theoretical training.  For these purposes, the book <i>Mac OS X and iOS Internals: To the Apple's Core</i> did a good job.  As for practice, MacBooks were bought for all those in need, and different versions of macOS were deployed on virtual machines, from 10.9 to the latest 10.12. <br><br>  The process of debugging programs for macOS on Delphi is different from the usual process for Windows, where, as a rule, you run the debugged program on the same computer where the Delphi environment is running.  C macOS is a bit more complicated: first you install it on a machine with macOS Platform Assistant, i.e.  an auxiliary application (part of Delphi) that provides deployment and debugging of the application, and from Delphi, already under Windows, you specify the IP address of the machine running the Platform Assistant: <br><br><div style="text-align:center;"><img src="http://www.tamos.com/temp/hb/shot1.png" alt="Delphi Platform Assistant"></div><br><br>  Then you just run your program, which immediately starts working on the Mac.  Naturally, it can be debugged exactly the same way as we all used to debug Windows programs. <br><br><h3>  FMX controls </h3><br>  So, everything is set up, you can run your first ‚ÄúHello World‚Äù on the Mac.  The GUI is done in the familiar Delphi visual editor using the FMX visual components.  The FMX framework appeared in Delphi back in 2011, in the Delphi XE2 version.  I must say that at first he was extremely buggy, but during these six years he was thoroughly rewritten, significantly reducing the number of problems.  Now it is quite a usable set of components, starting from the simplest TButton and ending with grids, listview, and other familiar controls.  Therefore, it is quite realistic and comfortable to do interfaces on FMX today, however there are some special features. <br><br>  First, FMX controls are not native.  This is not a wrapper around system controls, as is done in the VCL, where, for example, TButton is the system control that Windows draws, not Delphi.  Here, Delphi draws controls, using its style engine, which uses a style that matches the style of the version of macOS on which the program is running. <br>  An example of a dialogue on Yosemite (10.10): <br><br><div style="text-align:center;"><img src="http://www.tamos.com/temp/hb/shot2.png" alt="Conversation in macOS 10.10"></div><br>  Below is the same dialogue on the Mavericks (10.9).  GUI styles automatically adapted to the Mavericks ‚Äúnative‚Äù style and look different: <br><br><div style="text-align:center;"><img src="http://www.tamos.com/temp/hb/shot3.png" alt="Conversation in macOS 10.9"></div><br>  In principle, this works well, although some things in styles have to be corrected (or use native controls, which is discussed below).  For example, the ‚Äúgraphite‚Äù style of macOS, which appeared in Yosemite, is absent in Delphi, and it had to be done independently.  It took two man-days. <br><br>  The second problem is ‚Äúchildhood diseases‚Äù.  The child (FMX framework), as I said, is six years old, and despite the efforts of Embarcadero, he has not fully recovered from all that he needs.  For example, in the main menu of the application, the OnClick event is triggered for all items, except top-level items.  Those.  if you have the File ‚Üí Open, File ‚Üí Save menu and so on, then the OnClick event will happen when you click on Open and Save, but it does not happen when you click on File, when the list of sabitems drops out.  Or take the standard dialogs Open and Save.  Quite unexpectedly, the dialogue display completely ‚Äúcloses‚Äù the application's event loop, and something ceases to happen (including the timer ticks) while the dialogue is open.  All this, in my opinion, is the result of too weak in-house testing and too slow response from Embarcadero to bug reports. <br><br>  These diseases are treated at run-time, without patching system units.  We cured the absence of OnClick by intercepting the call 'menuWillOpen:' of the class TFMXMenuDelegate, we generally rewrote the system dialogs entirely, but to fix the bug, you must first explode it.  Be careful, do not neglect testing, and do not forget to report bugs on <a href="https://quality.embarcadero.com/">quality.embarcadero.com</a> . <br><br>  Finally, closing the topic of FMX controls, I advise you to take a look at the TMS FMX UI Pack, which includes many very good written visual components, including an excellent TreeView that can work in a virtual mode.  This is exactly what is missing from standard FMX components. <br><br><h3>  Run-time library </h3><br>  Using Delphi RTL expectedly turned out to be the most trouble-free part when porting code to macOS.  RTL has long been "sharpened" under multiplatform, so you can safely use any functions and non-visual classes without changes.  It is only necessary to monitor such trifles as, for example, the use of the platform-independent IncludeTrailingPathDelimiter instead of the hard-coded "\" separator. <br><br><h3>  macOS API </h3><br>  When you write something a little more complicated than a calculator, you will sooner or later have to use the native API.  Only RTL and the FMX framework are completely unrealistic, just as under Windows, RTL and VCL alone are unrealistic.  Need to know the system locale?  Implement interprocess communications?  Find out the size of the virtual memory process?  Encryption?  Speech synthesis?  All this, of course, native API.  But this should not scare at all, as we are not afraid of calling any FindWindow or GetLocaleInfo under Windows.  And if something is not declared in Delphi, then you can declare, add and redo anything. <br><br>  The API itself consists of several components (BSD, Mach, Carbon, Cocoa, etc.), but for our purposes Cocoa is of primary interest.  Simply put, Cocoa is a collection of classes, which is rather unusual for those who are used to using the Windows API.  For example, if you need to know the offset of the computer's time zone relative to UTC, then in Windows it is just a function GetTimeZoneInformation.  But in macOS it is already an <a href="https://developer.apple.com/reference/foundation/nstimezone">NSTimeZone</a> class.  Over time, you get used to this by smoking the <a href="https://developer.apple.com/reference">Apple API Reference</a> at your leisure, just like almost all of us used to smoke MSDN at the beginning of our journey.  But what really causes the brain to explode at first is the syntax of the ‚Äúbridge‚Äù between Delphi and Cocoa classes.  This is very unusual. <br><br>  Class functions are called through the magic word OCClass: <br><br><pre><code class="delphi hljs">TNSTimeZone.OCClass.localTimeZone</code> </pre> <br>  They usually return pointers, but not everything is not so simple.  These pointers to objects cannot be used directly;  pointers are what is called id in Objective-C, and to convert such a pointer into an object, you need to make magic Wrap: <br><br><pre> <code class="delphi hljs">TNSTimeZone.Wrap(TNSTimeZone.OCClass.localTimeZone)</code> </pre> <br>  And now we can already call the function of the class instance and finally get the required offset: <br><br><pre> <code class="delphi hljs">TimeZoneShift:= TNSTimeZone.Wrap(TNSTimeZone.OCClass.localTimeZone).secondsFromGMT;</code> </pre> <br>  Another example?  You are welcome!  Checking server availability: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlockingGetTestURL</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> URL: NSURL; URLRequest: NSURLRequest; aData: NSData; Response: Pointer; Policy: NSURLRequestCachePolicy; TimeOut: NSTimeInterval; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL_TO_CHECK = <span class="hljs-string"><span class="hljs-string">'http://open.mapquestapi.com'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> URL := TNSURL.Wrap(TNSURL.OCClass.URLWithString(StrToNSStr(URL_TO_CHECK))); Policy:= NSURLRequestReloadIgnoringLocalCacheData; TimeOut:= <span class="hljs-number"><span class="hljs-number">10</span></span>; URLRequest := TNSURLRequest.Wrap(TNSURLRequest.OCClass.requestWithURL(URL, Policy, TimeOut )); aData := TNSURLConnection.OCClass.sendSynchronousRequest(URLRequest, @Response, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); result:= (aData &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (aData.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  When an Objective-C class function wants a pointer to an object from us, again, we cannot simply take and pass an @MyDelphiObject, we must perform a ritual dance to convert this pointer to id using the GetObjectID function: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserDefaultMeasureUnit</span></span></span><span class="hljs-function"> :</span></span> TSSMeasureUnitType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; ns: NSString; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppKitFwk: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">'/System/Library/Frameworks/AppKit.framework/AppKit'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ns:= CocoaNSStringConst( AppKitFwk, <span class="hljs-string"><span class="hljs-string">'NSLocaleUsesMetricSystem'</span></span>); p := TNSLocale.Wrap(TNSLocale.OCClass.currentLocale).objectForKey((NS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TNSNumber.Wrap(p).boolValue <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := msMeters <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result:= msFeet; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  In general, it is quite possible to get used to the syntax, having studied the examples.  I advise you to read the article <a href="http://delphiblog.twodesk.com/using_os_x_apis_directly_from_delphi">Using OS X APIs directly from Delphi</a> , in which this topic is well disclosed. <br><br>  If we talk directly about the API (not limited to Cocoa), it leaves a pretty pleasant feeling.  There are simply no things in the Windows API in the macOS API, and vice versa.  Some things in macOS are made more complicated than in Windows, some are simpler.  Take, for example, AES encryption.  In Windows, in order to encrypt an array of bytes, you need to use five functions and a couple dozen lines of code, whereas in macOS you can do this on almost one line with the CCCrypt function.  And this is no longer part of Cocoa. <br><br><h3>  Sweet, sweet POSIX </h3><br>  POSIX isn't part of Cocoa either, but damn it, thanks a lot to him for being on macOS!  It makes life so much easier.  Much that can be done through classes at a high level is much easier to do at a low level through POSIX.  For example, how to implement interprocess communications?  Distributed Objects and the NSProxy class?  NSConnection?  Forget, everything is solved in a couple of lines of code through memory-mapped files and POSIX functions.  We need shm_open, shm_unlink and mmap.  The first two, by the way, are not declared in Delphi, but this is not a problem.  Carefully read the description, declare: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shm_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__name: PAnsiChar; __oflag: integer; __mode: mode_t)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'shm_open'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shm_unlink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__name: PAnsiChar)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'shm_unlink'</span></span>;</code> </pre> <br>  And then everything is simple, we call: <br><br><pre> <code class="delphi hljs">fd := shm_open( PAnsiChar(UTF8Encode(ID)), O_RDWR <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> O_CREAT, S_IRUSR <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> S_IWUSR <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> S_IRGRP <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> S_IROTH ); ftruncate(fd, aSize); mmap(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, aSize, PROT_READ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Everything, we have created a mapping, accessible by name from other processes. <br><br>  Why do we still need POSIX?  Yes, for many things.  For example, here: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPhysicalCoreCount</span></span></span><span class="hljs-function">:</span></span> Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CoreCount: Cardinal; Size: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Size:= SizeOf(Cardinal); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sysctlbyname(<span class="hljs-string"><span class="hljs-string">'hw.physicalcpu'</span></span>,@CoreCount, @Size, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result:= CoreCount <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result:= System.CPUCount; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Working with sockets, with COM ports, and much more - simple and familiar POSIX is suitable for all of this, with almost the same syntax as in Windows.  Among other things, we needed to port the Delphi-class to work with COM ports, which we used under Windows to work with GPS receivers.  There are approximately 1500 lines of code.  Complicated?  Not, no so much.  Day of work and about 50 IFDEFs of this type: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGPSReceiver</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearInputBuffer</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(ComThread) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((ComThread <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TComThread).ComDevice &lt;&gt; GPS_INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF MSWINDOWS}</span></span> Result := PurgeComm((ComThread <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TComThread).ComDevice, PURGE_RXCLEAR); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF MACOS}</span></span> result:= tcflush((ComThread <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TComThread).ComDevice, TCIFLUSH) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Result := False; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Ported, tested, by the end of the working day we got a module for working with GPS that was flashing with images of satellites. <br><br><h3>  Native controls </h3><br>  If you are not satisfied with the standard set of FMX controls, then it does not matter.  Nobody forbids the use of native visual classes and even mix them with FMX controls, following certain rules.  As a matter of fact, nobody forbids even to use the FMX framework in your Delphi application at all (although this is already a bit extreme). <br><br>  Native classes should be used for performance.  We, for example, faced with the fact that the viewport, made on FMX components, significantly slowed down when zooming and scrolling large bitmaps, we replaced it with a native NSScrollView with NSImageView inside.  To access the events of native classes, they need to subclass and / or use delegates.  This is rather trivially encoded in Delphi, and as a result you get access to any events.  Need event magnifyWithEvent class NSImageView?  No problem.  We inherit the interface: <br><br><pre> <code class="delphi hljs">NSImageViewEx = <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>(NSImageView) [<span class="hljs-string"><span class="hljs-string">'{3E4F87DA-0577-4F21-A1CF-8BCA774FA903}'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magnifyWithEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: NSEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Make the implementation class: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TExtendedNSImageView</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TOCLocal) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magnifyWithEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: NSEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  And we do everything we want when the method of the implementation class is called: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TExtendedNSImageView</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">magnifyWithEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: NSEvent)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Do whatever you want end;</span></span></code> </pre><br>  For this to work, you need some more code when creating the class;  examples can be easily found on the Internet.  Subclassing is not the only way to intercept events, you can also use method swizzling, and I will even give an example below. <br><br>  This is how we live, mixing the native and FMX controls. <br><br><div style="text-align:center;"><img src="http://www.tamos.com/temp/hb/shot4.png" alt="TamoGraph on macOS"></div><br><br><h3>  What (so far) Delphi can't on macOS </h3><br>  With a large barrel of honey often comes a certain amount of not so beautiful substance.  Let's talk for a change about the shortcomings. <br><br>  Of the unsolvable problems, there is one, but rather important.  This is a 64-bit compiler for macOS, which is in the roadmap, but not yet done.  This, of course, is a shame for Idera / Embarcadero, who are, in our opinion, passionate about much less important things, neglecting the Mac branch of the product.  So, we look forward to it. <br><br>  From solved - <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">code blocks</a> , language feature  ++ and Objective-C, which is not supported in Delphi.  More precisely, Delphi has its analogue of code blocks, but it is incompatible with those code blocks that it expects from macOS API.  The fact is that many classes have functions that use code blocks as handler's for completion.  The simplest example is the <a href="https://developer.apple.com/reference/appkit/nssavepanel/1527007-beginwithcompletionhandler%3Flanguage%3Dobjc">beginWithCompletionHandler</a> classes NSSavePanel and NSOpenPanel.  The transmitted code block is executed at the moment of closing the dialog: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)openExistingDocument:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender { <span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span>* panel = [<span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span> openPanel]; <span class="hljs-comment"><span class="hljs-comment">// This method displays the panel and returns immediately. // The completion handler is called when the user selects an // item or cancels the panel. [panel beginWithCompletionHandler:^(NSInteger result){ if (result == NSFileHandlingPanelOKButton) { NSURL* theDoc = [[panel URLs] objectAtIndex:0]; // Open the document. } }]; }</span></span></code> </pre> <br>  On Delphi, this "trick with the ears" is apparently extremely difficult to perform (at least we did not succeed).  In other words, in the normal way we cannot learn about closing the dialogue.  But the normal way is even boring!  Who prevents us from going abnormal way?  There are several perverse approaches to solving such problems, but in this case, for example, the following will work well.  For a start, we can get a list of all the functions, both documented and undocumented, of the NSSavePanel class.  This is done like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListMethodsForClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aClassName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aClass: Pointer; OutCount, i: integer; Arr: PPointerArray; p: PAnsiChar; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= <span class="hljs-string"><span class="hljs-string">'Instance methods for class '</span></span> + aClassName + <span class="hljs-string"><span class="hljs-string">':'</span></span> + <span class="hljs-string"><span class="hljs-string">#13#10</span></span>; aClass := objc_getClass(PAnsiChar(ansistring(aClassName))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aClass &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Arr:= class_copyMethodList(aClass, OutCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Arr &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> OutCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p:= sel_getName(method_getName(Arr^[i])); result:= result + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(p) + <span class="hljs-string"><span class="hljs-string">#13#10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Posix.Stdlib.free(Arr); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; result:= result + <span class="hljs-string"><span class="hljs-string">'Class methods:'</span></span> + <span class="hljs-string"><span class="hljs-string">#13#10</span></span>; Arr:= class_copyMethodList(object_getClass(aClass), OutCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Arr &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> OutCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p:= sel_getName(method_getName(Arr^[i])); result:= result + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(p) + <span class="hljs-string"><span class="hljs-string">#13#10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Posix.Stdlib.free(Arr); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Got a list and look for something delicious ... Yeah, found: "_didEndSheet: returnCode: contextInfo:".  Very similar to what we need.  It is necessary to check the theory whether this selector is called when the dialog is closed.  You can make a subclass of NSSavePanel, and you can roughly and shamelessly put a hook on this selector by replacing method sizzling: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> END_SHEET_SELECTOR : ansistring = <span class="hljs-string"><span class="hljs-string">'_didEndSheet:returnCode:contextInfo:'</span></span>; SAVE_PANEL_CLASS : ansistring = <span class="hljs-string"><span class="hljs-string">'NSSavePanel'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endSheetOld: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self: pointer; _cmd: pointer; sheet: pointer; returncode: NSinteger; contextinfo: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endSheetNew</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self: pointer; _cmd: pointer; sheet: pointer; returncode: NSinteger; contextinfo: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> endSheetOld(self, _cmd, sheet, returncode, contextinfo); FDialogClosed:= ReturnCode; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoDialogHooks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FM1, aClass: pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> aClass := objc_getClass(PAnsiChar(SAVE_PANEL_CLASS)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aClass &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FM1 := class_getInstanceMethod(aClass, sel_getUid(PAnsiChar(END_SHEET_SELECTOR))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FM1 &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> @endSheetOld := method_getImplementation(FM1); method_setImplementation(FM1, @endSheetNew); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception.Create(<span class="hljs-string"><span class="hljs-string">'Failed to hook NSSavePanel'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  We check - and about a miracle, at the moment of closing the dialogue by Cancel or OK, we find ourselves in the hooked function and, accordingly, we learn that the dialogue is closed, as well as the result of the closing itself. <br><br><h3>  Mines </h3><br>  Probably no one was able to create a product without exploding mines, but I‚Äôll emphasize it specifically once again, the number of explosions can be minimized if you look more at someone else‚Äôs code, read books and API reference.  No, really, it's better to read about some App Nap on <a href="https://developer.apple.com/">developer.apple.com</a> , than not to read and then wonder for a long time why all the timers in your application suddenly began to tick 10 times less often.  And it is better to know in advance that the string parameters in POSIH functions must be encoded in UTF-8, and not ANSI or UTF-16.  And test, test, test ... And "for myself and for that guy."  Yes, there will be mines in Delphi too, Idera / Embarcadero doesn‚Äôt like to test the Mac part of the product.  Well, Macapi.Foundation.NSMakeRect would not have fallen if they had organized the testing normally. <br><br><h3>  Results </h3><br>  I hope, for those who are thinking about how to make a product for macOS, the first acquaintance with Delphi + Cocoa turned out to be informative.  A bunch of quite working, allowing you to do serious software.  And my wishes Idera / Embarcadero - do not forget about macOS.  I understand that mobile development is very fashionable, but the development of desktop software is a very decent market, as you can see with the example of Windows in the last 20 years. You have <b>almost</b> everything for a great product for macOS, you just need to work a little more.  Roll out a 64-bit compiler rather and correct what you were told about at <a href="https://quality.embarcadero.com/">quality.embarcadero.com</a> . </div><p>Source: <a href="https://habr.com/ru/post/319922/">https://habr.com/ru/post/319922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319912/index.html">With a magnifying glass on an elephant</a></li>
<li><a href="../319914/index.html">How flitk manages people online with overwhelming levels of paranoia</a></li>
<li><a href="../319916/index.html">How can you remotely and centrally carry out an inventory and audit of all IT assets of a company?</a></li>
<li><a href="../319918/index.html">Photoshop settings after installation</a></li>
<li><a href="../319920/index.html">Why data can be open and free</a></li>
<li><a href="../319926/index.html">How to test the DSU in the data center</a></li>
<li><a href="../319928/index.html">Plan without B: planning in the company from ‚ÄúI‚Äù to ‚Äúwe‚Äù</a></li>
<li><a href="../319932/index.html">Site security by its headers, or what to do if you want to crawl into the insides of each site</a></li>
<li><a href="../319934/index.html">Application Monitoring with Pinba</a></li>
<li><a href="../319936/index.html">JS optimization killers are no longer so scary</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>