<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We design microservice architecture taking into account failures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article Designing a Microservices Architecture for Failure . 

 Microservice architecture due to precisely defined boundaries of se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We design microservice architecture taking into account failures</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the article <a href="https://blog.risingstack.com/designing-microservices-architecture-for-failure/">Designing a Microservices Architecture for Failure</a> .</i> <br><br>  Microservice architecture due to precisely defined boundaries of services allows you to <b>isolate failures</b> .  However, as in any distributed system, there is a <b>higher probability of</b> problems at the network level, equipment or applications.  As a consequence of service dependencies, any component may be temporarily unavailable to users.  To minimize the impact of partial failures, we need to build services that are resistant to them, which can <b>correctly</b> respond to certain types of problems. <br><br>  This article presents the most common techniques and architectural patterns for building and operating a <b>highly available microservice system</b> . <br><a name="habracut"></a><br>  If you are not familiar with the templates mentioned here, then it is not at all necessary that you do something wrong.  Building a reliable system always requires additional investments. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  The risk of microservice architecture </h2><br>  With this architecture, the application logic is transferred to the services, and the network layer is used for interaction between them.  Interaction over the network, rather than through calls within memory, increases the latency and complexity of the system, which requires the cooperation of numerous physical and logical components.  And the increasing complexity of a distributed system leads to the fact that the chances of the occurrence of certain <b>network failures</b> increase. <br><br>  One of the main advantages of the microservice architecture in comparison with the monolithic one is that teams can independently design, develop and deploy services.  They fully manage the entire life cycle of their services.  It also means that teams do not have control over service dependencies, as they are usually managed by other people.  When using the microservice architecture, you need to remember that the <b>provider services may be temporarily unavailable</b> due to jigsaw releases, configurations and various changes, since this does not depend on the developers, and the components change independently of each other. <br><br><h2>  Gradual degradation of service </h2><br>  One of the most attractive aspects of microservice architecture is the ability to isolate failures, and due to the fact that the components fail separately from each other, it is possible to achieve a gradual degradation of service (graceful service degradation).  For example, when an application that allows sharing of photos fails, users may not be able to upload new images, but they will be able to view, edit and share existing photos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/lv/hv/mblvhv1lmskutlcyauikxebddpw.png"></div><br>  <i>Separate failures of microservices (in theory).</i> <br><br>  However, in most cases it is difficult to implement this type of gradual degradation of service, because applications in distributed systems are dependent on each other, and you need to apply several different types of failure handling logic (some of them will be discussed below) to prepare for temporary difficulties and failures. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/zm/wc/rnzmwcnx5fqcnyqroutcj3eqlsq.png"></div><br>  <i>Without failure handling logic, services depend on each other and fail all together.</i> <br><br><h2>  Change management </h2><br>  The Google reliability team found that about <b>70% of the failures are caused by changes</b> in living systems.  Changing something in your system ‚Äî deploying a new version of the code or changing some configuration ‚Äî you risk causing a crash or adding new bugs. <br><br>  In microservice architecture, services depend on each other.  Therefore, it is necessary to minimize failures and limit their negative impact.  To cope with problems caused by changes, you can implement change management strategies and <b>automatic rollbacks</b> . <br><br>  For example, when making changes, gradually apply them to a subset of your instances, track and automatically roll back the deployment if you notice a deterioration in key metrics. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/yt/6f/nsyt6f-btip9joi6mps3_q2z9mm.png"></div><br>  <i>Change Management - Rolling Deployment.</i> <br><br>  Another solution would be to use two production-environments.  Always deploy only one of them, and apply a load balancer to it only after making sure that the new version works as expected.  This is called ‚Äúblue-green‚Äù or ‚Äúblack-red‚Äù deployment. <br><br>  <b>Code rollback is not a problem</b> .  You can't leave broken code in production and then puzzle over what went wrong.  Always roll back changes if necessary.  The earlier the better. <br><br><h2>  Health Check and Load Balancing </h2><br>  Instances are constantly started, restarted and stopped due to crashes, deployments or autoscaling.  And therefore become temporarily or permanently unavailable.  To avoid such problems, your balancer should exclude failed instances from rotation if they cannot serve clients or other subsystems. <br><br>  The health of application instances can be determined by external observation.  You can do this with regular <code>GET /health</code> endpoint calls or by automatically sending reports.  Modern <b>solutions for service discovery</b> constantly collect health information from the instances and configure balancers to allow traffic only to fully functioning components. <br><br><h2>  Self-healing </h2><br>  You can ‚Äúreanimate‚Äù the application using self-healing.  You can talk about this mechanism in the event that the application <b>performs the necessary actions</b> to exit from the failed state.  In most cases, self-healing is implemented by an external system that monitors the working capacity of the instances and restarts them if they are in a state of failure for a certain period.  Self-healing is often very useful, but in some situations it <b>can cause problems</b> by constantly restarting the application.  This is possible if the application cannot report a positive status due to overload or timeouts when connecting to the database. <br><br>  It may be difficult to implement an advanced self-medication mechanism that will be ready for delicate situations like losing connection to the database.  In this case, you need additional logic that will handle extreme cases and let the external system know that you do not need to restart the instance immediately. <br><br><h2>  Failover caching (failover caching) </h2><br>  Usually services fail due to network problems and system changes.  However, most failures are temporary due to self-healing mechanisms and advanced balancing.  And we need to find a solution that allows services to work during such incidents.  <b>Failover caching</b> can help here, which will provide the necessary data to applications. <br><br>  Failover caches typically use <b>two different expiration times</b> .  A shorter one tells how long you can use the cache in a normal situation, and a longer one tells how long you can use cached data during a crash. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/h3/_w/pih3_wmim856ykqn0r5wstvdhbq.png"></div><br>  <i>Failover caching.</i> <br><br>  It is important to mention that you can use fault-tolerant caching only when <b>outdated data is better than nothing</b> . <br><br>  To configure the normal and fault-tolerant cache, you can use the standard HTTP response headers. <br><br>  For example, using the <code>max-age</code> header, you can set the time during which the resource will be considered fresh.  And with the help of the <code>stale-if-error</code> header - how long the resource will be provided from the cache in case of failure. <br><br>  Modern CDN and balancers provide various caching and fault tolerance schemes, but you can also create a common library for your company that contains standard reliability solutions. <br><br><h2>  Retry Logic </h2><br>  There are situations when we cannot cache data, or when we need to make changes to them, but our operations fail.  Then you can try to <b>repeat our actions</b> , if there is a chance that resources will be restored some time later, or if our balancer sends our requests to the working instance. <br><br>  Be careful with adding replay logic to your applications and clients, because a <b>large number of repetitions can worsen the situation</b> or even prevent applications from recovering. <br><br>  In a distributed system, repeats in the microservice structure can generate numerous answers or other repetitions, which will create a <b>cascade effect</b> .  To minimize the effect of repetitions, limit their number and use the exponential delay algorithm to increase the delay between repetitions each time until you reach the limit. <br><br>  Since the replay is initiated by the client (browser, other microservice, and so on), who does not know whether the operation failed before or after processing the request, the application must be able to handle <b>idempotency</b> .  For example, when you repeat a purchase operation, you should not duplicate the collection of funds from the buyer.  You will be helped by using a unique <b>idempotency key</b> for each transaction. <br><br><h2>  Speed ‚Äã‚ÄãLimit and Load Shedders </h2><br>  Speed ‚Äã‚Äãlimit is a technique for determining the number of requests that can be accepted or processed by a specific consumer or application within a certain time.  Using the speed limit, we can, for example, filter out our customers and microservices, because of which there are <b>surges in traffic</b> .  Or we can make sure that the application will not be overloaded until autoscaling comes to the rescue. <br><br>  You can also restrict low priority traffic to allocate more resources to critical transactions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qy/gl/bd/qyglbdegp-fj16uf3qqds20eetw.png"></div><br>  <i>A speed limiter can prevent traffic spikes.</i> <br><br>  Another type of speed limiter is called a concurrent request limiter.  It can be useful when you have ‚Äúexpensive‚Äù endpoints that are not recommended to be called more than a certain number of times if you want to serve traffic. <br><br>  To always have the resources to <b>handle critical transactions</b> , use fleet usage load shedder.  It holds part of the resources for high-priority requests and does not allow low-priority transactions to use them.  Load shedder makes its decisions based on the overall state of the system, rather than the size of a single user request.  LSs <b>will</b> also <b>help your system recover</b> , as they provide key functionality during the incident. <br><br>  You can read more about speed limiters and load shedders in this article: <a href="https://stripe.com/blog/rate-limiters">https://stripe.com/blog/rate-limiters</a> . <br><br><h2>  Fail quickly and separately </h2><br>  In the microservice architecture, you need to prepare your services to <b>fail quickly and separately</b> .  To isolate problems at the service level, we can use <i>the bulkhead template</i> . <br><br>  <b>A quick</b> component <b>failure</b> is needed because we don‚Äôt want to wait for the timeouts of the broken instances to end.  Nothing is as annoying as a hung query and an interface that does not respond to your actions.  This is not only lost resources, but also a spoiled user experience.  Services cause each other in a chain, so you need to pay special attention to the prevention of hanging operations, avoiding the accumulation of delays. <br><br>  Probably, you immediately got the idea of ‚Äã‚Äãapplying small timeouts (fine grade timeouts) for each service call.  But the problem is that you cannot know what timeout value will be appropriate, because there are situations when network failures and other problems that occur affect only one or two operations.  In this case, you probably don‚Äôt want to reject these requests due to the fact that some of them are timed out. <br><br>  It can be said that the use of the ‚Äúrapid failure‚Äù paradigm in microservices <b>through timeouts</b> is an antipattern that should be avoided.  Instead of timeouts, you can use the <i>circuit-breaker</i> pattern, which depends on the statistics of successful / failed operations. <br><br><h2>  Bulkheads </h2><br>  Bulkheads are used in shipbuilding to <b>divide a</b> ship <b>into sections</b> so that each section can be battened in the event of a hull breakdown. <br><br>  The bulkhead principle can be applied in software development to <b>share resources</b> to <b>protect them from exhaustion</b> .  For example, if we have two types of operations that interact with one database instance that has a limit on the number of connections, then you can use two connection pools instead of one common.  As a result of this ‚Äúclient ‚Äì ‚Äã‚Äãresource‚Äù separation, an operation that initiates a timeout or abuses the pool will not affect the operation of other operations. <br><br>  One of the main reasons for the death of the "Titanic" was the unsuccessful design of the bulkheads, in which water could flow over the decks into other compartments, filling the entire hull. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3n/ag/5e/3nag5ex26enucwq13tqmim_fn_8.png"></div><br>  <i>Bulkheads on the "Titanic" (they did not work).</i> <br><br><h2>  Circuit Breakers </h2><br>  Timeouts can be used to limit the duration of operations.  They can prevent operations from hanging up and keep the system responding to your actions.  The use of static, finely tuned timeouts in the microservice architecture is <b>antipattern</b> , since we are talking about a highly dynamic environment in which it is almost impossible to find suitable time constraints that work well in all situations. <br><br>  Instead of using small, transaction-dependent timeouts, you can use circuit breakers for error handling.  The action of these software mechanisms is similar to the electrotechnical devices of the same name.  With the help of circuit breakers, you can <b>protect resources</b> and <b>help them recover</b> .  They can be very useful in distributed systems, where repeated failures can cause an avalanche effect that puts the entire system. <br><br>  The circuit breaker opens when <b>a</b> certain type of <b>error occurs several times</b> in a short time.  An open automaton prevents the transmission of requests - just like a real automaton interrupts an electrical circuit and prevents current from flowing through the wires.  Circuit breakers usually close after a certain time, giving services a breather for recovery. <br><br>  Remember that not all errors should initiate a circuit breaker.  For example, you probably want to skip errors on the client side like requests with 4xx codes, but at the same time respond to server failures with 5xx codes.  Some circuit breakers may be in a half-open state.  This means that the service sends the first request to check the availability of the system, and the remaining requests are truncated.  If the first request was successful, the machine goes into the closed state and does not prevent the flow of traffic.  Otherwise, the machine remains open. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vz/71/rm/vz71rm9wc6elfadgz7fsy-sxx8c.png"></div><br>  <i>Automatic circuit.</i> <br><br><h2>  Check for failures </h2><br>  You must constantly <b>check the behavior of your system in the face of common problems</b> to make sure that your services can <b>survive various failures</b> .  Test frequently so your team is ready for incidents. <br><br>  You can use an external service that identifies the group of instances and randomly interrupts the work of one of the group members.  So you will be ready to crash a single instance.  Or you can overlap entire regions to emulate a crash with a cloud provider. <br><br>  One of the most popular solutions is the <a href="https://github.com/Netflix/chaosmonkey">ChaosMonkey</a> fault tolerance <a href="https://github.com/Netflix/chaosmonkey">tool</a> . <br><br><h2>  Conclusion </h2><br>  Implementing and maintaining reliable service is not an easy task.  It requires a lot of effort and costs a lot of money. <br><br>  Reliability has different levels and aspects, so it is important to find a solution that is best suited for your team.  Make reliability one of the factors in the process of making business decisions and allocate enough money and time for this. <br><br><h2>  Key findings </h2><br><ul><li>  For dynamic environments and distributed systems ‚Äî such as microservices ‚Äî there is an increased risk of disruption. </li><li>  Services should fail separately to ensure smooth degradation of the service and not collapse the user experience. </li><li>  70% of failures are caused by changes, so do not be shy of code retracement. </li><li>  Failures must occur quickly and separately.  The teams have no control over the dependencies of their services. </li><li>  Architectural patterns and techniques such as caching, bulkheads, circuit breakers, and speed limiters help create robust microservices. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/342058/">https://habr.com/ru/post/342058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342046/index.html">How to get a DUNS number for free</a></li>
<li><a href="../342048/index.html">Automated workshop - 1. Example ‚ÄúDisplay‚Äù, development of OA and UA</a></li>
<li><a href="../342052/index.html">Normal reset</a></li>
<li><a href="../342054/index.html">Why do we need algorithms and patterns</a></li>
<li><a href="../342056/index.html">Birds Detection with Azure ML Workbench</a></li>
<li><a href="../342060/index.html">Centralized backup of Mikrotik devices using a bash script</a></li>
<li><a href="../342064/index.html">$ mol_app_life: DIY God Simulator</a></li>
<li><a href="../342066/index.html">Adaptive layout</a></li>
<li><a href="../342070/index.html">Cybersecurity Gap: Next Generation Training</a></li>
<li><a href="../342072/index.html">‚ÄúRussia, Institute, Department and Me‚Äù - the second part of an interview with Anatoly Abramovich Shalyto, Professor at ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>