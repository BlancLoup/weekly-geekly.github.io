<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>To the question about pins</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Day of Knowledge is dedicated to ... 
 This post is devoted to what all users of Arduino (hereinafter referred to as A, keep in mind that under th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>To the question about pins</h1><div class="post__text post__text-html js-mediator-article"><h3>  The Day of Knowledge is dedicated to ... </h3><br>  This post is devoted to what all users of Arduino (hereinafter referred to as A, keep in mind that under this letter will hide both the crystal itself and the development environment of programs), namely with the work of I / O ports. <br><br>  You may ask, what exactly is there to consider?  The functions of working with ports are spelled out clearly, there are a large number of examples, so the use of ports presents no difficulty.  The initial LED flashing program uses these functions and works great, what are we talking about? <br><br>  All this is true, but only up to the moment when you need to connect to A something farther than the LED (I have no complaints about these wonderful devices, but usually, due to the specifics of using particular speed, they are not required), and then you will need effective work with pins (we will call I / O ports for brevity), and then the forums have questions like ‚Äúwhy the program works so slowly for me,‚Äù to which the young gurus instantly answer ‚Äúwork directly with the registers and you will be happy‚Äù and show  vayut exactly how, in their opinion, it should do so. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Despite the fact that their answer contains a bit of truth, nevertheless, such an answer is far from complete, which is not quite correct (see how they recommend working with registers), is not quite optimal, and is not very clear.  This post is intended to fill the space between standard sketches and a similar answer. <br><br>  Since I see a reader with a different level of training in front of me, I will try to focus on a different range of knowledge in the field of MK (microcontrollers), so if something seems well known to you (and there will be many such places) feel free to skip this fragment, but if that it will not be completely clear, the comments and there are in order to ask questions there, I read them and, as far as I can, I try to answer. <br><a name="habracut"></a><br>  For a start, a little theory.  Pins, as follows from their definition, are intended for the interaction of the program created by you with the outside world (while the inner world is considered only the MC).  In order to use pins, you must be aware of their existence and, since there are more than one of them, be able to specify these pins (this is called naming or addressing).  Therefore, each pin available to you (and there are also inaccessible ones, but they are not interesting to us from a practical point of view) must have a unique parameter characterizing it.  In A, pin numbers are taken as such a parameter and, although this is not the only possible way, it is not bad in its own way.  Further, all you need to know is the presence of a pin connection that has a specific number, with a specific MK pin and, accordingly, contact on the comb through which you connect to your board (of course, this is board A, but since you bought it, it is yours) various external devices, and accordingly, on the effect of a particular pin on a specific external device. <br><br>  For example, if you want the LED located on board A to light up, then you need to submit the ‚ÄúLow‚Äù level to pin 13, and to move the data through the shift register chip to form a transition from pin 6 to low to high and so on.  Moreover, for the first case ‚Äî the LED control ‚Äî further reasoning does not make much sense, since the human eye is the receiver of information, and its capabilities in terms of speed do not exceed a dozen Hertz, then for controlling the shift register, the time at which the level changes at the leg is very important, since to an external device (for example, a seven-segment indicator), you will need many changes and their total time may be unacceptable for a particular case (it will block  the work of the other parts of the program that are critical for the polling period, such as processing the encoder, which will disrupt their work).  Well, if you control the pin of a virtual SPI, then the resulting speed of the SD card will surprise you very unpleasantly, so the task of speeding up work with pins is quite practical. <br><br>  To control pins in A, there are predefined functions, the main one of which is DigitalWrite, to which you must report the pin number for the modification and the value on it after the function has been executed.  However, if you have problems after writing the DigitalWrite (13, Low) command (provided that you have not forgotten the pin mode setting command somewhere before), then they are just beginning for the executing system.  The fact is that there are MK architectures in which each pin really has a unique address, which ensures that your command is easily mapped to the MK command system, and this is what the execution system (the compiler bundle and the system library) does, but Atmel is at a time when was created by A, did not indulge her admirers with such delights (this is not quite true, but in the first approximation so).  In the microcontrollers of the Mega family, on which platform A was historically based, a slightly different scheme of working with pins was adopted.  Here, the work with the outside world is carried out not through unique pins, but through input / output ports, which are a collection of pins (in this case no more than 8) and, accordingly, each pin has 2 parameters in the physical representation - the port name (represented by a letter from And to E in different members of the family MK) and the number of bits inside the port (figure from 0 to 7).  So, for example, pin 13 can have a physical address PB.5 in one MK, and RC.0 in another. <br><br>  Therefore, the first task of the performing system is to convert the pin number into a physical representation for subsequent work with them.  This problem can be solved in various ways and, in my opinion, in A this is not done in the best way, but, fortunately, the system is open, and we can make the necessary changes and corrections to it. <br><br>  First of all, we note that the executing system consists of two components - the compiler (in fact, under this collective name, it is not just one function that hides, but at least the preprocessor, the compiler itself, the assembler, the linker and the librarian, as well as the executing subsystem represented by library modules (sketches). So, the transformation task should be solved either at the compilation stage, or at the execution stage, or somehow distributed between these stages. And it‚Äôs preferable to do as much work as possible  at the first stage, since the time spent on it is negligible compared to the time of actually writing the code, but any costs (memory and time) at the execution stage require the expenditure of limited MC resources (compared to the development platform) resources Unfortunately, this proposal is not always realizable, but under the conditions when the specific composition of the execution system is known and all the source files are present, it can be very useful, but I ran a little ahead, paused and looked at the implementation of the function of working with pin in A.  Here is the source code of the function. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digitalWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> timer = digitalPinToTimer(pin); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bit = digitalPinToBitMask(pin); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port = digitalPinToPort(pin); <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *out; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port == NOT_A_PIN) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// If the pin that support PWM output, we need to turn it off before doing a digital write. if (timer != NOT_ON_TIMER) turnOffPWM(timer); out = portOutputRegister(port); uint8_t oldSREG = SREG; cli(); if (val == LOW) { *out &amp;= ~bit; } else { *out |= bit; } SREG = oldSREG; }</span></span></code> </pre> <br>  Immediately, I note that this code is taken <a href="http://garretlab.web.fc2.com/en/arduino/inside/arduino/wiring_digital.c/digitalWrite.html">from here</a> , as well as the subsequent source codes, but it does not look like fake, and in other sources I came across just such a code, so we will consider it really code for A. <br><br>  Before we move through the text, to begin with, I will express my displeasure with the signature of the function, and this displeasure is quite reasonable.  Both parameters are obviously not integer numbers and accept a limited set of values, so they must be defined as instances of enumerated types, which will allow us to check the correctness of the actual parameters passed to them, at least with respect to constant expressions, which is what I have done. implementation.  Well, now you can go to the consideration of the code. <br><br>  What we see here is first of all the conversion of the pin number to the physical address, implemented by extracting information from the table of constants.  Consider this operation in more detail, why go through the source text, look at the code and see the operation of obtaining a bit mask: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )</span></span></code> </pre> <br>  And we find out that this is a macro extension, which passes the pin number to another function and adds the name of the table where the numbers of bits are stored.  Next, we find out that: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> pgm_read_byte(address_short) pgm_read_byte_near(address_short)</span></span></code> </pre> <br>  This is also a macro wrapper, passing its arguments to the following function, it immediately turns out that: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> pgm_read_byte_near(address_short) __LPM((uint16_t)(address_short))</span></span></code> </pre> <br>  This ... yes, right, the macro wrapper, you begin to pick up the principle that passes its arguments to the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __LPM(addr) __LPM_enhanced__(addr)</span></span></code> </pre> <br>  Which is (who would have thought) a macro wrapper for a function that is ... and here it was not guessed, it all had to end sooner or later, a real macro substitution of the assembler insert.  I don‚Äôt understand too much about the presence of four wrappers, but since we agreed (or rather, I stated it, and you didn‚Äôt argue or argue, but I didn‚Äôt notice it) that the compiler time is not worth anything, we will not focus on this aspect, But let's just be surprised out loud, fix our surprise on paper and go on to look at the code. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __LPM_enhanced__(addr) (__extension__({ uint16_t __addr16 = (uint16_t)(addr); uint8_t __result; __asm__ ( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lpm %0, Z"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=r"</span></span></span><span class="hljs-meta"> (__result) : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"z"</span></span></span><span class="hljs-meta"> (__addr16) ); __result; }))</span></span></code> </pre> <br>  Let's consider the text of the function of data extraction from the table more closely, there are a number of interesting points.  Since we have been given an assembler insert, we should take into account the specifics of the implementation of the MK architecture, it is important for us that it is 8-bit and battery-powered. <br><br>  Let us pay attention to the first two lines, where the actual parameter is not extracted from the macro substitution text, but from the intermediate variable __addr16, and ask the question - why it was done this way, this is unnecessary forwarding.  The answer that I came up with was maybe it was really necessary if we wanted to use statically noncomputable expressions as a pin number, that is, a string of characters whose value cannot be determined at the compilation stage with an accuracy of one transfer.  Then, when the macro is opened, commands will be generated that calculate this expression ‚Äúon the fly‚Äù, the result is transferred to the intermediate variable, and then used for its intended purpose.  That is, in this case we have an account of the features of the preprocessor, and not the architecture of the MC, for which you have to pay for speed.  You have already guessed that I am not thrilled with this practice, when the opportunity to use statically undefined expressions must pay all function calls, including those with constant parameters, of which there will be an overwhelming majority. <br><br>  We will immediately think about alternatives - firstly, it can be a variant implementation based on determining the type of the parameter, if this is possible in this preprocessor (I don‚Äôt know it well enough to bring this solution), secondly, it can be direct prohibiting the use of statically undefined expressions when the <code>DigitalWrite(BasePinNumber+6, Low)</code> construction will result in a compiler error and you will have to turn it into <code>int PinNumber=BasePinNumber+6; DigitalWrite(PinNumber,Low)</code>  <code>int PinNumber=BasePinNumber+6; DigitalWrite(PinNumber,Low)</code> , which seems to me a reasonable price for an increase in performance in other cases. <br><br>  (Later note. Viewing the real code showed that this line does not generate additional code in the compiler in question, removing it and sending the macro argument to the assembler does not change the code as much as possible, so apparently this legacy of the damned past will be left at maximum speed It does not affect, but I do not want to delete the text, the idea was not bad). <br><br>  The necessary explanation is that although I argue about the shortcomings of the implementation of the A function, I nevertheless have to admit that I do not have the board, that is, of course it does, but this is the so-called And compatible Intel Edisson board, which, although it can be programmed from A, Nevertheless, in no way is the replacement of the board itself A. The next sin, in which I must admit - I do not use the A development environment, for which there are many reasons ... <br><br><blockquote>  There is a great joke on this subject.  After one of the battles, Napoleon asks the Marshal of the artillery why the artillery did not shoot.  Marshal replies: ‚ÄúThere were many reasons for this, Sire.  First, we did not have shells.  Secondly ...".  Napoleon interrupts him: "Enough" </blockquote><br>  ... of which at the moment it is decisive that it is very inconvenient to watch intermediate files, including assembly language code.  Therefore, the further results considered are related to the code obtained in the <a href="http://gcc.godbolt.org/">gcc.godbolt.org</a> online compiler in the AVR gcc 4.5.2 mode with -O optimization enabled.  Immediately I want to assure the reader that this compiler generates a very effective code, if I wrote it with my hands, it would not be much better (although still a little better), I think that in A compiler the results are better than those obtained by this method just will not. <br><br>  Further (or rather, a little earlier), we see the extraction of additional information from the auxiliary table, which tells us whether this pin is not the output port of the timer.  I don‚Äôt really understand how exactly this fact can affect the reluctance of the executing system to work with such a pin without disconnecting the timer (it seems to me that in this case it takes a lot of itself), but the fact that such testing requires additional time is undoubtedly for me .  Perhaps this is the legacy of the damned past, the true meaning of such a decision is inaccessible to the uninitiated in the innermost secrets of A. What can we do to speed up the work?  Well, you can combine this check with getting the port index by entering a special value, especially since such a similar check of the port index for admissibility is carried out several lines later.  Further, we can define a conditional compilation, giving the user the opportunity to determine if he is willing to pay the execution time (if it was about compile time, I would only be happy) for an additional check.  Well, like a cherry on a cake, the verification condition itself using double negation seems to me to be somewhat fanciful, the simple <code>if (timer == IS_ON_TIMER)</code> condition <code>if (timer == IS_ON_TIMER)</code> is not inferior to the original condition, but more readable.  Let's also pay attention to the fact that we get this value in one place, and use (and once) much later, which is also not beautiful, which is inevitable for the C language, but we have C ++, and we can do it more correctly, at least and not faster. <br><br>  Another interesting point related to checking for a timer.  There is an undoubted error here, if you look at the generated code in the Shima off function (see this code yourself) turnOffPWM (), you will see the possibility of interruption of the operation of other modules.  Of course, it will appear extremely rarely, perhaps, it will never appear at all (but do not forget about the laws of Murphy), but it is and should be definitely corrected, because otherwise children can see THAT, and decide, ‚Äúbut I didn‚Äôt know that is so possible. " <br><br>  This is followed by checking the port index for admissibility, since not all pins can have a physical representation in a particular MC.  And again, not everything has been done well.  First, the rule is violated that each function must have one exit point, well, here it is enough to slightly correct the text.  True, the cyclomatic complexity of the program will increase, but here you have to choose which of the mutually exclusive rules to support.  Secondly, we again have to pay for the paranoia of developers by the time of execution, and we are not asked if we need such care.  There are two options for increasing the speed of this fragment - the first is a conditional compilation, but the second is more cunning - specifying in the table elements corresponding to the missing pins, the port address and the bit number, the change of which is neutral with respect to external outputs (and internal registers MK, which is even more important).  The easiest way to specify a zero bit mask for the real port, but options are possible.  Yes, in this case we will do the useless work in case of a wrong pin number (which is absent in this MC), but we will not waste time with the correct number. <br><br>  This is what the developers can not but agree with, the need to prevent the internal bits of the MK registers from being modified when the pin number is set incorrectly, and the specified code fragment does, but then why the hell is there no such check at the very beginning of the function, because we ask to change the state of pin 137, then we get a completely unpredictable behavior of the program, and this is the developer. But he doesn‚Äôt care at all - there is a funny combination of paranoia and pofigism, I thought, the last is peculiar only to us, Slavs.  We can insert such a check into the text of the function, but it is much better to do it, as I advised at the very beginning - to create a custom type and the compiler will do the necessary checks itself and there will be nothing left for the execution phase.  Again, you can easily bypass this test and shoot wherever you want, but you will have to clearly and clearly the compiler about your intention to warn and then do not complain. <br><br>  We look further and notice that the bit number is extracted in one stage, and the port address is in two stages; first, by the pin number, we get the port index - a number from 0 to the number of ports, and then, based on the index, we retrieve the port address itself.  Why this is done, because it is obviously longer than immediately get the address we need - you can think of two explanations.  Firstly, such a technique gives a great deal of flexibility - frankly, a far-fetched explanation.  The second possible reason is saving the size of the ROM, which will be in bytes the number of pins minus the size of the additional code, that is, bytes 6-8, which seems to me obviously insufficient compensation for a significant decrease in performance.  Moreover, the same result can be achieved by specifying in the first table not an index, but an offset and then turning it into an address by a less expensive way of adding to the base or even combining, as demonstrated in my implementation.  Yes, this method is not as portable as the original one, but as far as I remember, nobody canceled the conditional compilation directives.  Actually, I have the impression that many components of libraries A were made in haste from existing universal (who is a universal - a person who can do a lot of things equally bad) blanks, and then acted on the principle ‚ÄúDoes this thing work?  - Yes.  ‚ÄúDo not touch it.‚Äù Unfortunately, a much faster way to access ports through the in and out commands is not acceptable in this case, since it is impossible to specify the port number as an argument to the command. <br><br>  Continue to review the code.  We received the port address and the bit mask and can proceed with the actual execution of the operation, that is, here we see exactly what the young gurus from A. recommend us. Once again, as I have repeatedly done in my posts, I beg you not to do so.  That is, there is no other way to change the content of the bit in the port (but I deceived you, there is, but more on that later), but it is not necessary to register this way as a direct operation.  Be sure to wrap the call to registers in a macro or inline function, this can save you a lot of time when debugging.  Of course, if you are among the lucky ones who have never forgotten the ~ character in front of the mask, then you don‚Äôt need a wrapper (but then why do you read it at all, my post is not for the demigods from programming), but it doesn‚Äôt do any harm , but for normal people who are prone to make mistakes, it is very useful.  Moreover, the authors And they know about this need, look at the implementation of switching off the PWM, there is just a macro for resetting a bit, but in this particular place they arrogantly ignore this possibility. <br><br>  And let us pay attention to the fact that the actual work with the register, namely reading-modification-writing, is framed with additional lines, the purpose of which is not clear to neophytes.  We all understand that this is a resource sharing protection made in the classic style of the critical section, where the interrupt enable bit is used as a semaphore, but it inevitably takes time to execute, even if it is in this particular program (I hope no one I was not offended that I called the sketch like that) is not needed.  By invoking conditional compilation, we can further improve the speed of the function.  I recommend to pay attention to the fact that all newly introduced compilation conditions were initially set in such a way that the operation of the function in the default mode did not change at all in order to preserve continuity, all of a sudden it was taken into account in some sketch that the operation time of the function is this and that is important should not change. <br><br>  By the way, one interesting observation.  In the absence of protection against register sharing, work on changing the state of the port bits produced by that part of the program that interrupted the work of another part, and never vice versa, can be lost.  Apparently, in this way world justice realizes itself, expressed in popular wisdom ‚Äúwho interferes, is beaten‚Äù. <br><br>  And another small pebble in the garden A - from the text of the function it is easy to see that the description of the function is not quite right - if the value of the second parameter is LOW, then the bit will be cleared, otherwise (and not if the parameter is equal to HIGH, as in the description a) the bit will be set.  If this parameter accepts only the specified values, then this clarification does not make sense, but in the original function its values ‚Äã‚Äãare not limited by anything except the goodwill of the programmer. <br><br>  In order for you to understand the following calculations, under the spoiler there is a code with comments when compiled: <br><br><div class="spoiler">  <b class="spoiler_title">Assembly code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">digitalWrite(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>):  <span class="hljs-number"><span class="hljs-number">9</span></span>  push r15 push r16 push r17 mov r16,r22 mov r18,r24 ldi r19,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> timer = digitalPinToTimer(pin); <span class="hljs-number"><span class="hljs-number">7</span></span>  mov r30,r18 mov r31,r19 subi r30,lo8(-(digital_pin_to_timer_PGM)) sbci r31,hi8(-(digital_pin_to_timer_PGM)) lpm r24, Z <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bit = digitalPinToBitMask(pin); <span class="hljs-number"><span class="hljs-number">7</span></span>  mov r30,r18 mov r31,r19 subi r30,lo8(-(digital_pin_to_bit_mask_PGM)) sbci r31,hi8(-(digital_pin_to_bit_mask_PGM)) lpm r17, Z <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port = digitalPinToPort(pin); <span class="hljs-number"><span class="hljs-number">7</span></span>  subi r18,lo8(-(digital_pin_to_port_PGM)) sbci r19,hi8(-(digital_pin_to_port_PGM)) mov r30,r18 mov r31,r19 lpm r15, <span class="hljs-function"><span class="hljs-function">Z </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(port == NOT_A_PIN)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>  tst r15 breq .<span class="hljs-function"><span class="hljs-function">L12 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timer != NOT_ON_TIMER)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">turnOffPWM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timer)</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>     ,       cpse r24,__<span class="hljs-function"><span class="hljs-function">zero_reg__ rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">turnOffPWM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> out </span></span>= portOutputRegister(port); <span class="hljs-number"><span class="hljs-number">14</span></span>  mov r30,r15 ldi r31,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) lsl r30 rol r31 subi r30,lo8(-(port_to_output_PGM)) sbci r31,hi8(-(port_to_output_PGM)) lpm r24, Z+ lpm r25, Z mov r30,r24 mov r31,r25 <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> oldSREG = SREG; <span class="hljs-number"><span class="hljs-number">1</span></span>  in r24,__<span class="hljs-function"><span class="hljs-function">SREG__ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-function"><span class="hljs-function">cli </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val == LOW)</span></span></span><span class="hljs-function"> </span></span>{ *out &amp;= ~bit; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *out |= bit; } <span class="hljs-number"><span class="hljs-number">10</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>  LOW/HIGH tst r16 brne .L15 ld r25,Z com r17 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r17,r25 st Z,r17 rjmp .L16 .L15: ld r25,Z <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r17,r25 st Z,r17 .L16: SREG = oldSREG; <span class="hljs-number"><span class="hljs-number">1</span></span>  out __SREG__,r24 .L12:  <span class="hljs-number"><span class="hljs-number">10</span></span>  pop r17 pop r16 pop r15 ret main: ....   <span class="hljs-number"><span class="hljs-number">4</span></span>  ldi r24,lo8(<span class="hljs-number"><span class="hljs-number">1</span></span>) ldi r22,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-function">rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digitalWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ..... ret</span></span></code> </pre> <br></div></div><br>  Now you can take stock.  Call + preamble + postambula - 4 + 9 + 10 = 23, resource protection - 3, timer protection - 7 + 3 = 10, pin protection - 2 getting the bit number - 7, getting the port address - 7 + 14 = 21, modifying the value - 10/8, which gives us the execution time of the function 76/74 clock cycle, or at a clock frequency of 16 MHz MK it will be 4.75 / 4.625 microsecond - the result is quite expected for someone who saw the source code and is familiar with the AVR architecture.  In different sources I saw different digits of the execution time of the digitalWrite function, but they were only more received in this case. <br><br>  An interesting observation is that the time of setting and resetting a bit is different, which is not too good.  This disadvantage is easy to fix, replacing the condition with the opposite, then we get 9/9 - alignment leads to an increase in one of the times, but they are aligned - a trifle, but nice. <br><br><div class="spoiler">  <b class="spoiler_title">It would be great</b> <div class="spoiler_text">  The same result is obtained when using the skip command, and we get 8/8, but for some reason (it is clear why, because the logic of the function changes, which is unacceptable) the compiler refuses to use it and does not want to make such code as we would like, but from the following code <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp; tmp=*out; tmp |= bit; bit = ~ bit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == HIGH) tmp &amp;= bit; *out=tmp;</code> </pre>  get the next lowest possible program <pre> <code class="cpp hljs"> ld r18,Z <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r18,r17 com r17 cpse r16,one_reg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r18,r17 st Z,r25</code> </pre> </div></div><br>  Unexpectedly, the following consideration came to mind - the standard implementation of the temporary interruption shutdown, recommended by Atmel in numerous examples, is unsafe.  It is vulnerable at the point from reading the current value of the status register and until the interrupt is disabled, so the results of the function interrupting the program at this point for changing the interrupt enable bit will be lost when the state register is restored to the saved value. ,  0-1  ,   1-0   .          ,     ,    . ,        ‚Äî      1     ,        .     ‚Äî   . <br><br>    ,             .   : <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_NEED_TIMER_CHECKING 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_NEED_PORT_CHEKING 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_NEED_OLD_DATA 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS 0 void digitalWrite(uint8_t pin, uint8_t val) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( I_NEED_TIMER_CHECKING == 1) uint8_t timer = digitalPinToTimer(pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> uint8_t bit = digitalPinToBitMask(pin); uint8_t port; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 port = digitalPinToPort(pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> port = digitalPinToPortNew(pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_PORT_CHEKING == 1 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (port == NOT_A_PIN) return; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( I_NEED_TIMER_CHECKING == 1) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timer != NOT_ON_TIMER) turnOffPWM(timer); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> uint8_t *out; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 out = (uint8_t *) portOutputRegister(port); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> out = (uint8_t *) ( port + BASEPORT ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 uint8_t oldSREG = SREG; cli(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_DATA == 0 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val == LOW) { *out &amp;= ~bit; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { *out |= bit; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val != LOW) { *out |= bit; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { *out &amp;= ~bit; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 SREG = oldSREG; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="cpp hljs">digitalWrite(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>):  <span class="hljs-number"><span class="hljs-number">1</span></span>  ldi r25,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bit = digitalPinToBitMask(pin); <span class="hljs-number"><span class="hljs-number">7</span></span>  mov r30,r24 mov r31,r25 subi r30,lo8(-(digital_pin_to_bit_mask_PGM)) sbci r31,hi8(-(digital_pin_to_bit_mask_PGM)) lpm r18, Z <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port = digitalPinToPortNew(pin); <span class="hljs-number"><span class="hljs-number">7</span></span>  subi r24,lo8(-(digital_pin_to_port_new_PGM)) sbci r25,hi8(-(digital_pin_to_port_new_PGM)) mov r30,r24 mov r31,r25 lpm r24, Z <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *out = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *) ( port + BASEPORT ); <span class="hljs-number"><span class="hljs-number">2</span></span>  mov r26,r24 ldi r27,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == LOW) { *out &amp;= ~bit;} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *out |= bit; } <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>  tst r22 brne .L13 com r18 ld r30,X <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r18,r30 st X,r18 ret .L13: ld r30,X <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r18,r30 st X,r18  <span class="hljs-number"><span class="hljs-number">4</span></span>  ret main: ....   <span class="hljs-number"><span class="hljs-number">4</span></span>  ldi r24,lo8(<span class="hljs-number"><span class="hljs-number">1</span></span>) ldi r22,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-function">rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digitalWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ....</span></span></code> </pre> </div></div><br> ++ ‚Äî 4+1+4 = 9,   ‚Äî 0,   ‚Äî 0,   ‚Äî 0,    ‚Äî 7,    ‚Äî 7+2 = 9,   ‚Äî 8/8,       9+7+9+8/8 = 33/33 ,      16   2.062/2.062 ,  ,   2 ,    ,     . <br><br>         ,            .            ‚Äî                     ,   . ,                ,           ,         .           ,        , .   ,   : <br><br><pre> <code class="cpp hljs">PinAdr Pin13=TransferPin(PIN13); DigitalPut(&amp;Pin13,LOW);</code> </pre> <br>   ,      ‚Äî       13+3+9+8/8 = 33        30    (      ,     ,           ),       ,    .      ,   10%,         ?           ,    ,        (9)       . <br><br>        ,   <code>DigitalPut2(Pin13.Port,Pin13.Mask,LOW);</code>      15+8/8 = 24     (27  ),    30%     30    3    : <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *Port; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Mask;} PinAdr; <span class="hljs-function"><span class="hljs-function">PinAdr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransferPin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pin)</span></span></span><span class="hljs-function"> </span></span>{ PinAdr PinAdrTmp; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 port = digitalPinToPort(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> port = digitalPinToPortNew(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_PORT_CHEKING == 1 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (port == NOT_A_PIN) PinAdrTmp.Mask=0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> PinAdrTmp.Mask = digitalPinToBitMask(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( I_NEED_TIMER_CHECKING == 1) uint8_t timer = digitalPinToTimer(Pin); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timer != NOT_ON_TIMER) turnOffPWM(timer); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 PinAdrTmp.Port = (uint8_t *) portOutputRegister(port); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> PinAdrTmp.Port = (uint8_t *) ( port + BASEPORT ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return PinAdrTmp; } void DigitalPut(PinAdr &amp;Pin, uint8_t val) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 uint8_t oldSREG = SREG; cli(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val != LOW) { *(Pin.Port) |= Pin.Mask; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { *(Pin.Port) &amp;= ~ Pin.Mask; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 SREG = oldSREG; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }; void DigitalPut2(uint8_t *Port, uint8_t Mask, uint8_t val) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 uint8_t oldSREG = SREG; cli(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val != LOW) { *Port |= Mask; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { *Port &amp;= ~ Mask; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_INTERRUPTS ==1 SREG = oldSREG; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cpp hljs">DigitalPut(PinAdr&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>): mov r30,r24 mov r31,r25 tst r22 breq .L14 ld r26,Z ldd r27,Z+<span class="hljs-number"><span class="hljs-number">1</span></span> ld r25,X ldd r24,Z+<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r24,r25 st X,r24 ret .L14: ld r26,Z ldd r27,Z+<span class="hljs-number"><span class="hljs-number">1</span></span> ldd r24,Z+<span class="hljs-number"><span class="hljs-number">2</span></span> com r24 ld r25,X <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r24,r25 st X,<span class="hljs-function"><span class="hljs-function">r24 ret </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigitalPut2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: mov r30,r24 mov r31,r25 tst r20 breq .L17 ld r24,Z </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">or</span></span></span><span class="hljs-function"> r22,r24 st Z,r22 ret .L17: com r22 ld r24,Z </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> r22,r24 st Z,r22 ret main: ..... mov r24,r28 mov r25,r29 adiw r24,1 ldi r22,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lo8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigitalPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PinAdr&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ldd r24,Y+1 ldd r25,Y+2 ldd r22,Y+3 ldi r20,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lo8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigitalPut2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </div></div><br>  Not bad.      . ,      ,       ,       ? <br><br> , ,       .        ,      . ,   ,         (           ),        (      ),       ,   ¬´     ...¬ª,               (   ,            ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that when I declared the impossibility of another way of changing the state of a bit in a register, I hinted that it did exist. And this way is connected with the use of special commands for working with bits, namely, commands with CBI and SBI mnemonics. Why we left this opportunity at last - because it is a dependent solution and it is poorly implemented (not implemented at all) within the C language, but the same can be said about reading the data from the tables, the assembler involvement is inevitable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, both of these commands do not accept any parameters, which does not allow specifying the pin number for the modification and the type of modification, and this information is part of the command itself and we have, theoretically, 32 different commands for 32 different ports. </font><font style="vertical-align: inherit;">We take into account the possibility that each port has 8 bits and we get 256 different commands. </font><font style="vertical-align: inherit;">Since the type of pin modification, namely setting or resetting a bit, is also part of the command, 512 different commands are obtained in total.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A rather large number, in the architecture of 51 teams there were no more than 256, and there is such a luxury, but a 16-bit command system can afford it. </font><font style="vertical-align: inherit;">Of course, not all of these 512 teams will perform meaningful actions on a particular MC, but some will, and we should be able as quickly as possible to execute one specific command from this set.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reader will immediately have a question - why do we need such problems with the use of assembler and other difficulties, and I immediately answer it - these commands are atomic (non-interruptible) which allows us to significantly save on execution time without disabling protection from resource sharing because for atomic operation it is unnecessary. </font><font style="vertical-align: inherit;">So, we can implement a call to a specific command we need in the classical way, by creating a table of commands and gaining access to it when calculating the index in the table on the fly, as shown in the following code fragment:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first option with a table</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fnull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fres1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{(__extension__({__asm__(<span class="hljs-string"><span class="hljs-string">"cbi PORTD,0"</span></span><span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>);}));}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fset1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{(__extension__({__asm__(<span class="hljs-string"><span class="hljs-string">"sbi PORTD,0"</span></span><span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>);}));}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fres2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{(__extension__({__asm__(<span class="hljs-string"><span class="hljs-string">"cbi PORTD,1"</span></span><span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>);}));}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fset2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{(__extension__({__asm__(<span class="hljs-string"><span class="hljs-string">"sbi PORTD,1"</span></span><span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>);}));}; func *funcAdr_PGM[] PROGMEM = { fnull,fnull, fres1,fset1, fres2,fset2, }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> funcOfPin(P) ( (func *)(pgm_read_word( funcAdr_PGM + (P))) ) void digitalWriteF(uint8_t Pin, uint8_t val) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_PORT_CHEKING == 1 uint8_t port; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 port = digitalPinToPort(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> port = digitalPinToPortNew(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (port == NOT_A_PIN) return; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( I_NEED_TIMER_CHECKING == 1) uint8_t timer = digitalPinToTimer(Pin); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timer != NOT_ON_TIMER) turnOffPWM(timer); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Pin=Pin*2; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val!=LOW) Pin++; funcOfPin(Pin)(); }; main: digitalWriteF(13,LOW);};</span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here are the results of the broadcast</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">digitalWriteF(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>): Pin=Pin*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val!=LOW) Pin++; lsl r24 cpse r22,__zero_reg__ subi r24,lo8(-(<span class="hljs-number"><span class="hljs-number">1</span></span>)) func *p=funcOfPin(Pin); mov r30,r24 ldi r31,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) lsl r30 rol r31 subi r30,lo8(-(funcAdr_PGM)) sbci r31,hi8(-(funcAdr_PGM)) lpm r24, Z+ lpm r25, <span class="hljs-function"><span class="hljs-function">Z </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; mov r30,r24 mov r31,r25 icall ret main: ldi r24,lo8(<span class="hljs-number"><span class="hljs-number">13</span></span>) ldi r22,lo8(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-function">rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digitalWriteF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </div></div><br> ++ ‚Äî 4+0+4 = 8,   ‚Äî 0 (  ),   ‚Äî 3,    ‚Äî 6,    ‚Äî 3+3+2 = 8,   3+2+4 = 9,       8+3+6+8+9 = 34/34 .    ,      ,      ,    ( )   ,  ,     p()  asm (¬´ijmp \n\t¬ª) (   ,   ),     4       ,  30   . <br><br>     3* (  )     2   ‚Äî 1     , 1          1        .   ,      ,               2*1 (    + 1)+   ,         . <br><br>           : <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"nop \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"nop \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cbi PORTD,0 \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sbi PORTD,0 \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cbi PORTD,1 \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sbi PORTD,1 \n \t ret \n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> func *PinAdr; <span class="hljs-function"><span class="hljs-function">PinAdr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransferPin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pin)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_PORT_CHEKING == 1 uint8_t port; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> I_NEED_OLD_PORT == 1 port = digitalPinToPort(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> port = digitalPinToPortNew(Pin); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (port == NOT_A_PIN) return; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( I_NEED_TIMER_CHECKING == 1) uint8_t timer = digitalPinToTimer(Pin); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (timer != NOT_ON_TIMER) turnOffPWM(timer); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> Pin=Pin*4; PinAdr PinTmp = (PinAdr) ((int)funcAll + Pin); return PinTmp; }; void DigitalPut(func *Pin, uint8_t val) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val != LOW) { Pin = (PinAdr) ((int)(Pin)+2); }; Pin(); main: digitalPut(Pin13,LOW); };</span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">,  ,  </b> <div class="spoiler_text"><pre> <code class="cpp hljs">DigitalPut(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)(), <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>): cpse r22,__zero_reg__ adiw r24,<span class="hljs-number"><span class="hljs-number">2</span></span> mov r30,r24 mov r31,<span class="hljs-function"><span class="hljs-function">r25 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">icall</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ijmp )</span></span></span><span class="hljs-function"> ret main: lds r24,main::Pin13 lds r25,main::Pin13+1 ldi r22,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lo8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> rcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DigitalPut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*)(), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre></div></div><br> ++ ‚Äî 7+0+4 = 11,   ‚Äî 0 (  ),   ‚Äî 3,    ‚Äî 0,    ‚Äî 0,   2+3+2+4 = 11(7),       11+3+11(7) = 25(21) ,  ,        6 . ,      ,       ,     2*    .  ,   ,   . <br><br>               (      ),   11+3+(3+2)5=19 ,  , ,  . <br><br>          ‚Äî           ,         ,     .   ,   ,        ,             .   ,                  2      4     (        ,   ,           ),   4+4=8   ,   1+4=5        2 ,         ‚Äî    ,    .                     . <br><br>    , ,  ,     ,      ,        (         ),                    ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are these cases and why they are not always present, although quite often? </font><font style="vertical-align: inherit;">We are talking about a situation where two conditions are fulfilled: first, the source codes of the program modules are available for which fast work with pins is necessary, and second, the pin numbers must be constant, that is, known at the compilation stage (it is constant, but not statically defined , it is important). </font><font style="vertical-align: inherit;">Then we can create macro substitution to work with the pins of the following form:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The perfect solution in terms of speed</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> digitalWriteC(pin,val) \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pin == 0) { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val == LOW) asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cbi PORTD, 0 \n\t"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sbi PORTD, 0 \n\t"</span></span></span><span class="hljs-meta">);\ }; \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pin == 1) { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val == LOW) asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cbi PORTD, 1 \n\t"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sbi PORTD, 1 \n\t"</span></span></span><span class="hljs-meta">);\ }; \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pin == 2) { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (val == LOW) asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cbi PORTD, 2 \n\t"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sbi PORTD, 2 \n\t"</span></span></span><span class="hljs-meta">);\ }; main: digitalWriteC(13,HIGH);</span></span></code> </pre> </div></div><br>    ,   ,            ,        ,   ,     -          (   ),         .   ,       -  ,         ,   ,    ,       .      ,           ,     (   ,     )    (,     ,      ),        .    ,     . <br><br>     , , ,     I2C  SPI     ,    ,         ,       ,        ,   ,    ,     ,           . <br><br>            ,       ,   : <br><br><pre> <code class="hljs lisp">#define DigitalPut(<span class="hljs-name"><span class="hljs-name">Pin</span></span>,Data) ( <span class="hljs-name"><span class="hljs-name">asm</span></span> ( <span class="hljs-string"><span class="hljs-string">"DW 0x0123+((Pin / 8) &lt;&lt; 4)+(Pin % 8) + (Data &lt;&lt; 8))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for some reason I didn‚Äôt manage to build such a construction, if anyone knows how to do it, I ask in the comment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we had a normal macro language in the preprocessor, then we could write a generalized substitution that would generate the optimal variant for each case, without forcing the programmer to think about which construct to call and which paradigm to use, but this is from the field of baseless dreams , since the standard preprocessor does not provide such opportunities (at least it does not provide me, if you are with it on more friendly terms, share secrets).</font></font><br><br>             ,  ,        ,            . ,              (,     ,         ,      ),        ,  , ,       ,          ,      ,  .         ,    ‚Äî     ,   ,     . </div><p>Source: <a href="https://habr.com/ru/post/308662/">https://habr.com/ru/post/308662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308652/index.html">Asterisk REST Interface (ARI) Overview</a></li>
<li><a href="../308654/index.html">PHP function speed analysis tool</a></li>
<li><a href="../308656/index.html">Interfaces in the real world: user error insurance</a></li>
<li><a href="../308658/index.html">Facebook is trying to please everyone, constantly changing the "rules of the game"</a></li>
<li><a href="../308660/index.html">Scrapy: collect data and save to database</a></li>
<li><a href="../308672/index.html">In the shadow of a random forest</a></li>
<li><a href="../308674/index.html">The digest of interesting materials for the mobile # 168 developer (August 22-28)</a></li>
<li><a href="../308676/index.html">Solve problems with remote connections in 3CX</a></li>
<li><a href="../308680/index.html">15 bugs or html and css tips</a></li>
<li><a href="../308684/index.html">We optimize our effort when developing an application in Google Material Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>