<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop using MVVM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the recent DroidCon Moscow 2016, there was a report on MVVM with the Databinding Library and a report on the Moxy library, which helps to work with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop using MVVM</h1><div class="post__text post__text-html js-mediator-article"><img alt="Two-headed MVVM" src="https://habrastorage.org/files/cb6/a06/568/cb6a06568f714f0f8ee2be5bdd777c4f.jpg" width="200"><br><p>  At the recent <a href="http://droidcon.moscow/ru/">DroidCon Moscow 2016, there</a> was a report on MVVM with the Databinding Library and a report on the <a href="https://github.com/Arello-Mobile/Moxy">Moxy</a> library, which helps to work with MVP.  The fact is that over the past six months we have managed to test both approaches on live projects.  And I want to talk about my journey from mastering the Databinding Library and releasing a MVVM project in production to understanding <strong>why I no longer want to use this pattern</strong> . <a name="habracut"></a></p><br><blockquote>  Dedicated to all those who are hooked by the Databinding Library and who decided to build an application on MVVM - you are brave people! </blockquote><br><h2 id="databinding-library">  Databinding library </h2><br><p>  <a href="https://developer.android.com/topic/libraries/data-binding/index.html">When</a> I started with the <a href="https://developer.android.com/topic/libraries/data-binding/index.html">Databinding Library</a> , I was impressed.  Those who are already familiar with it will understand me, and for others, this is how the work with this library looks like: </p><br><p><img src="https://habrastorage.org/files/7ea/02e/a55/7ea02ea555b94dbdbd925cac722fb454.png"></p><br><p>  Using the Databinding Library allows you to: </p><br><ul><li> Get rid of <code>findViewById</code> and <code>setOnClickListener</code> .  That is, specifying the id in <em>xml</em> , you can access the <em>view</em> via <code>binding.viewId</code> .  And you can set method calls directly from <em>xml</em> ; </li><li>  Link data directly to <em>view</em> elements.  We call <code>binding.setUser(user)</code> , and in <em>xml we</em> specify, for example, <code>android:text = ‚Äú@{user.name}‚Äù</code> ; </li><li>  Create custom attributes.  For example, if we want to load images into ImageView using the Picasso library, we can create a <em>BindingAdapter</em> for the ‚ÄúimageUrl‚Äù attribute, and write <code>bind:url=‚Äù@{user.avatarUrl}‚Äù</code> in <em>xml</em> . <br>  Such a BindingAdapter would look like this: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindingAdapter</span></span>(<span class="hljs-string"><span class="hljs-string">"bind:imageUrl"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImageView view, String url)</span></span></span><span class="hljs-function"> </span></span>{ Picasso.with(view.getContext()).load(url).into(view); }</code> </pre> </li><li>  Make the <em>view</em> state dependent on the data.  For example, whether the load indicator is displayed will depend on whether there is data. </li></ul><br><p>  This last point is especially pleasing to me because states have always been a complex topic.  If you need to display three states on the screen (load, data, error), that's all right.  But, when there are different requirements for the state of elements depending on the data (for example, display text only if it is not empty, or change color depending on the value), you may need a large <em>switch</em> with all possible interface states, or a lot of flags and code in the methods of setting values ‚Äã‚Äãto elements. <br>  Therefore, the fact that the Databinding Library allows you to simplify working with states is a huge plus.  For example, writing in <em>xml</em> <code>android:visibility=‚Äù@{user.name != null ? View.VISIBLE : View.GONE}‚Äù</code>  <code>android:visibility=‚Äù@{user.name != null ? View.VISIBLE : View.GONE}‚Äù</code> , we can no longer think about when to hide or show the TextView with the user name.  We simply set the name, and the visibility changes automatically. </p><br><h2 id="viewmodel">  Viewmodel </h2><br><p>  But, starting to use the <em>databinding</em> more actively, you will get more and more code in <em>xml</em> .  And in order not to turn the <em>layout</em> into a dump, we will create a class into which we will render this code.  And in <em>xml there</em> will be only calls of properties.  I will give a small example.  Suppose there is a class User: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> firstname; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> lastname; }</code> </pre> <br><p>  And in UI, we want to see the full name and write in <em>xml</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{user.firstname + user.lastname}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  You don‚Äôt really want to see this in <em>xml</em> , and we create a class in which we put this logic: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseObservable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@Bindable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ name = user.firstname + user.lastname; notifyPropertyChanged(BR.name); } }</code> </pre> <br><p>  The creators of the library propose to call such classes <strong>ViewModel</strong> (straight, as in the MVVM pattern, surprisingly). </p><br><blockquote>  In the example, the class is inherited from BaseObservable, and in the code it calls notifyPropertyChanged (), but this is not the only way.  You can also wrap the fields in an ObservableField, and dependent UI elements will be updated automatically.  But I think this method is less flexible and rarely use it. </blockquote><p>  Now in <em>xml</em> we will have: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{viewmodel.name}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  Much better, isn't it? </p><br><p>  So, we have a ViewModel class, which acts as an interlayer between the data and the <em>view</em> .  It deals with data transformations, controls which fields (and associated UI elements) and when updated, contains the logic of how some fields depend on others.  This allows you to clear the <em>xml</em> from the code.  In addition, it is convenient to use this class to handle events from the <em>view</em> (clicks, etc.). </p><br><p>  And here comes the thought: <strong>If we already have a <em>databinding</em> , there is a ViewModel class containing the display logic, then why not use the MVVM pattern?</strong> </p><br><p>  This thought comes inevitably.  Because what we have at the moment is very, very close to what the MVVM pattern is.  Let's take a quick look at it. </p><br><h2 id="mvvm">  MVVM </h2><br><p>  In the <a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx">Model-View-ViewModel</a> pattern there are three main components: </p><br><ul><li>  <strong>Model</strong> .  The business logic of the application that provides the data to display. </li><li>  <strong>View</strong> .  Responsible for the appearance, location and structure of all UI-elements that the user sees on the screen. </li><li>  <strong>ViewModel</strong> .  Acts as a bridge between View and Model and processes the display logic.  It requests data from the Model and sends it to the View in a form that View can easily use.  Also contains the handling of events made by the user of the application in the View, such as clicking a button.  In addition, the ViewModel is responsible for defining additional View states that need to be displayed, for example, whether a download is in progress. </li></ul><br><p>  The relationship and interaction between these components we see in the picture: </p><br><p><img src="https://i-msdn.sec.s-msft.com/dynimg/IC564167.png"></p><br><p>  The arrows show the dependencies: View knows about the ViewModel, and the ViewModel knows about the Model, but the model knows nothing about the ViewModel, which knows nothing about the View. </p><br><p>  The process is as follows: ViewModel requests data from the Model and updates it when necessary.  Model notifies the ViewModel that the data is there.  The ViewModel takes the data, converts it and notifies View that the data for the UI is ready.  The connection between ViewModel and View is carried out by automatic data binding and display.  In our case, this is achieved through the use of the Databinding Library.  With <em>databinding, the</em> View is updated using data from the ViewModel. </p><br><blockquote>  The presence of automatic binding (databinding) is the main difference of this pattern from the <a href="http://martinfowler.com/eaaDev/PresentationModel.html">PresentationModel</a> and <a href="https://ru.wikipedia.org/wiki/Model-View-Presenter">MVP</a> patterns (in MVP, the Presenter changes the View by calling methods on it through the provided interface). </blockquote><br><h2 id="mvvm-v-android">  MVVM in Android </h2><br><p>  So I started using MVVM in my project.  But, as often happens in programming, theory and practice are not the same thing.  And after the completion of the project, I still have a feeling of dissatisfaction.  <strong>Something was wrong in this approach, something did not like it, but I could not understand what it was</strong> . </p><br><p>  Then I decided to draw the MVVM scheme on Android: </p><br><p><img src="https://habrastorage.org/files/52c/fa1/862/52cfa18625004e1687890fbd92e7c585.png"></p><br><p>  Consider what the result is: </p><br><p>  <strong>ViewModel</strong> contains fields used in <em>xml</em> for data binding ( <code>android:text=‚Äù@{viewmodel.username}‚Äù</code> ), handles events <code>android:onClick=‚Äù@{viewmodel::buttonClicked}‚Äù</code> on View ( <code>android:onClick=‚Äù@{viewmodel::buttonClicked}‚Äù</code> ).  It requests data from Model, transforms it, and with the help of <em>databinding</em> 'a, this data gets into the View. </p><br><p>  <strong>Fragment</strong> simultaneously performs two roles: an entry point that provides initialization and communication with the system, and View. </p><br><p>  The fact that Fragment (or Activity) is considered as View in understanding MVP and MVVM patterns has already become a common practice, so I will not dwell on this. </p><br><p>  To survive the turns and the re-creation of the Activity, we leave the ViewModel live for the time while the View is being recreated (in our case, Fragment).  This is achieved using <a href="https://google.github.io/dagger/">dagger</a> and custom <a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-custom-scopes/">scopes</a> .  I will not go into details, many good articles about <em>dagger</em> have already been written.  In your own words, the following happens: </p><br><ul><li>  The ViewModel is created using a <em>dagger</em> (and its instance lives in it), and the fragment takes it when needed. </li><li>  When a fragment dies when it is rotated, it calls <em>detachView ()</em> on the ViewModel. </li><li>  ViewModel continues to live, its background processes too, and it is very convenient. </li><li>  Then, when the fragment is recreated, it calls <em>attachView ()</em> and transfers itself as a View (using the interface). </li><li>  If the fragment dies completely, and not because of the rotation, then it kills the <em>scope</em> (the necessary <em>dagger</em> component is reset, and the ViewModel can be collected by the <em>garbage collector</em> along with this component) and the ViewModel dies.  This is implemented in <strong>BaseFragment</strong> . </li></ul><br><blockquote>  Why <strong>does the fragment send</strong> itself to the ViewModel using the <strong>MvvmView</strong> interface?  This is necessary so that we can <strong>call the commands "manually"</strong> on the View.  Not everything can be done with the Databinding Library. </blockquote><p>  If it is necessary to save the state when the system has killed the application, we can save and restore the state of the ViewModel using the fragment <em>savedInstanceState</em> . </p><br><p>  That's about how it works. </p><br><p>  The attentive reader will ask: ‚ÄúWhy suffer with <em>dagger custom scopes</em> , if you can just use Fragment as a container and call <code>setRetainInstance(true)</code> in it?‚Äù Yes, you can do that.  But, while drawing a diagram, I took into account that you can use an Activity or ViewGroup as a View. </p><br><blockquote>  Recently, I found a <a href="https://github.com/patloew/countries">good example of MVVM implementation</a> that completely reflects the structure I have drawn.  Except for a couple of nuances, everything is done very well.  See if interested. </blockquote><br><h2 id="problema-dvoystvennosti">  Duality problem </h2><br><p>  Having drawn a diagram and thought it over, I realized that it was not exactly what I was comfortable with when working with this approach.  Take a look at the diagram again.  See the thick arrows ‚Äú <em>databinding</em> ‚Äù and ‚Äú <em>manual commands to view</em> ‚Äù?  Here it is.  Now I will tell more. </p><br><p>  Once we have the <em>databinding</em> , then most of the data we can simply set to View with <em>xml</em> (by creating the necessary BindingAdapter if necessary).  But <strong>there are cases that do not fit into this approach</strong> .  These include dialogues, <em>toast</em> 's, animations, actions with a delay and other complex actions with View elements. </p><br><p>  Recall the TextView example: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{viewmodel.name}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  What if we need to set this text using <code>view.post(new Runnable())</code> ?  (We do not think why, we think how) </p><br><p>  You can make a BindingAdapter, in which you create the ‚ÄúbyPost‚Äù attribute, and have the presence of the listed attributes on the element be taken into account. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindingAdapter</span></span>(value = {<span class="hljs-string"><span class="hljs-string">"text"</span></span>, <span class="hljs-string"><span class="hljs-string">"byPost"</span></span>}, requireAll = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTextByPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TextView textView, String text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byPost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byPost) { textView.post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ textView.setText(text); } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { textView.setText(text); } }</code> </pre> <br><p>  And now every time both attributes are specified for a TextView, this BindingAdapter will be used.  Add an attribute to <em>xml</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{viewmodel.name}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:byPost</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@{viewmodel.usePost}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  The ViewModel should now have a property indicating that at the time of setting the value, we should use <code>view.post()</code> .  Add it: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseObservable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> usePost = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// only first time @Bindable public String getFullname() { return name; } @Bindable public boolean getUsePost() { return usePost; } public void setUser(User user) { name = user.firstname + user.lastname; notifyPropertyChanged(BR.name); notifyPropertyChanged(BR.usePost); usePost = false; } }</span></span></code> </pre> <br><p>  See how much you need to do to realize a very simple action? </p><br><p>  <strong>Therefore, it is much easier to do these things right on View</strong> .  That is, use the MvvmView interface, which is implemented by our fragment, and call View methods (just like in MVP). </p><br><blockquote>  This is where the <strong>duality problem</strong> manifests itself <strong>: we work with View in two different ways</strong> .  One is automatic (through the state of the data), the second is manual (through calls to commands on the view).  I personally do not like it. </blockquote><br><h2 id="problema-sostoyaniy">  State problem </h2><br><p>  Now I will tell about one more problem.  Imagine the situation with the rotation of the phone. </p><br><ol><li>  We have launched the application.  ViewModel and View (fragment) are alive. </li><li>  They turned the phone - the fragment died, and the ViewModel lives.  All her background tasks continue to work. </li><li>  New fragment was created, joined.  View through the <em>databinding</em> received the saved state (fields) from the ViewModel.  Everything cool. </li><li>  But what if at that moment when the fragment (View) is disconnected, the background process ended with an error, and we want to show <em>toast</em> about it?  The fragment (acting as View) is dead, and you cannot call a method on it. </li><li>  We will lose this result. </li></ol><br><p>  It turns out that <strong>you need to somehow store not only the View state, represented by a set of ViewModel fields, but also the methods that the ViewModel calls on the View</strong> . </p><br><p>  This problem can be solved by setting the field flags in ViewModel for each such case.  It is not very beautiful and not universal.  But it will work. </p><br><h2 id="pro-sostoyaniya">  About states </h2><br><p>  The problem of states prompted me to think that the <em>state of an object can be recreated in two ways: a set of parameters characterizing the state, or a set of actions that need to be performed to bring the object to the desired state</em> . </p><br><p>  Imagine a Rubik's Cube.  His condition can be described in 9 colors on one of the faces.  And you can set of movements that will lead him from the initial state to the desired. </p><br><p><img src="https://habrastorage.org/files/eaa/316/265/eaa316265ec142379a0ccfcf125cd60f.png"></p><br><p>  You may need just one turn, and maybe a lot more than nine.  It turns out, depending on the situation, some way of describing the state is better or worse (less data is needed). </p><br><h2 id="moxy">  Moxy </h2><br><p>  Considering ways to recreate the state, I could not remember the Moxy library.  My colleagues in parallel did the project using the MVP pattern and this library.  I won't talk about it in detail, there is already a <a href="https://habrahabr.ru/post/276189/">great article from the authors</a> . </p><br><p>  In the context of my reasoning, one <strong>feature of Moxy is</strong> interesting <strong>: it stores the <em>view</em> state as a set of commands invoked in this <em>view</em></strong> .  And when I found out about it for the first time, it seemed strange to me. </p><br><p>  But now, after all the reflections (which I shared with you above), I think this is a very good decision. <br>  Because: </p><br><ul><li>  It is not always possible (conveniently) to present the state only with data (fields). </li><li>  In MVP, communication with View goes through command calls.  Why not use it? </li><li>  In reality, the number of <em>view</em> fields needed to recreate its state may be much greater than the number of commands invoked on it. </li></ul><br><p>  In addition, this approach gives another plus.  It also, like the Databinding Library, in its own way solves the problem of a large number of different states.  You also don't have to write a huge <em>switch</em> that changes the UI depending on the set of fields or the name of one of the states, since the changes are recreated by a set of method calls. </p><br><p>  And yet I can‚Äôt say nothing more about Moxy.  In my opinion and the opinion of my colleagues, today it is the best library that helps to work with the MVP pattern.  It uses code generation to minimize developer effort.  You can not think about the implementation of the pattern, but think about the functionality of your project.  And that's good. </p><br><p>  But enough about MVP.  Still, we are talking about MVVM, and it's time to take stock. </p><br><h2 id="vyvody">  findings </h2><br><p>  I like MVVM as a pattern, and I do not dispute its advantages.  But for the most part they are the same as other patterns, or they are a matter of developer taste.  And the main plus gives all the same <em>databinding</em> , and not the pattern itself. </p><br><p>  Driven by sympathy for MVVM, I implemented a project on it.  He studied the topic for a long time, pondered, discussed and made for himself a set of minuses of this pattern: </p><br><ul><li>  MVVM forces you to work with View simultaneously in two ways: through <em>databinding</em> and through View methods. </li><li>  With MVVM, you cannot beautifully solve the state problem (the need to save a call to the View method that was called when the View was disconnected from the ViewModel). </li><li>  It requires advanced use of the Databinding Library, which takes time to master. </li><li>  Not everyone likes the code in <em>xml</em> . </li></ul><br><p>  Yes, you can get used to these minuses.  But after much thought, I came to the conclusion that <strong>I do not want to work with a pattern that creates fragmentation of approaches</strong> .  And I decided that I would write the next project using MVP and Moxy. </p><br><p>  Whether you use this pattern - decide for yourself. <del>  But I warned you. </del></p><br><h4 id="ps-databinding-library">  PS: Databinding Library </h4><br><p>  Let's end, perhaps, with the same thing that we started with - the Databinding Library.  I still like it.  But I am going to use it only in limited quantities: </p><br><ul><li>  Not to write <code>findViewById</code> and <code>setOnClickListener</code> . </li><li>  And to create convenient <em>xml</em> attributes using BindingAdapters (for example, <code>bind:font=‚ÄùRoboto.ttf‚Äù</code> ). </li></ul><br><p>  And that's all.  This will give advantages, but will not beckon towards MVVM. </p><br><p>  If you also plan to work with the Databinding Library, here is some useful information: </p><br><ul><li>  Call <code>binding.executePendingBindings()</code> in <code>onViewCreated()</code> after setting the variables for binding.  This will help if you want to change something in the newly created <em>view</em> from the code.  You won't have to write <code>view.post()</code> , having learned that <em>view</em> is not ready yet. </li><li>  You cannot transfer a variable to the <em>&lt;fragment&gt;</em> tag (as you can in the <em>&lt;include&gt;</em> ): <a href="https://code.google.com/p/android/issues/detail%3Fid%3D175338">https://code.google.com/p/android/issues/detail?id=175338</a> . </li><li>  Lambda in <em>xml</em> in the Databinding Library with features.  You cannot write without parentheses ( <code>() -&gt; method()</code> ).  Cannot block code.  But you can omit the parameters if not used in the ( <code>android:onClick=‚Äù@{() -&gt; handler.buttonClicked()}‚Äù</code> ). </li><li>  backtick (`) can be used instead of double quotes (‚Äú). </li><li>  In BindingAdapter-ah write only attributes ( <code>@BindingAdapter(‚ÄúattributeName‚Äù)</code> ), the <em>namespace</em> is still ignored.  And in <em>xml it</em> doesn't matter what the <em>namespace</em> will be.  But they often use <em>bind</em> to distinguish ( <code>bind:attributeName=‚Äù...‚Äù</code> ). </li><li>  Look for the generated databinding classes here: app / build / intermediates / classes / debug </li><li>  Ready adapters can be found <a href="http://androidxref.com/7.0.0_r1/xref/frameworks/data-binding/extensions/baseAdapters/src/main/java/android/databinding/adapters/">here</a> . </li><li>  What to read except documentation: <br>  <a href="https://realm.io/news/data-binding-android-boyar-mount/">https://realm.io/news/data-binding-android-boyar-mount/</a> <br>  <a href="https://www.bignerdranch.com/blog/descent-into-databinding/">https://www.bignerdranch.com/blog/descent-into-databinding/</a> <br>  <a href="https://halfthought.wordpress.com/2016/03/23/2-way-data-binding-on-android/">https://halfthought.wordpress.com/2016/03/23/2-way-data-binding-on-android/</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312548/">https://habr.com/ru/post/312548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312536/index.html">Event when resizing a block element - resize</a></li>
<li><a href="../312538/index.html">What should be the TK for Corporate IP?</a></li>
<li><a href="../312542/index.html">DellEMC Unity 400F: some testing</a></li>
<li><a href="../312544/index.html">An example of corporate anti-virus integration with a SIEM platform</a></li>
<li><a href="../312546/index.html">Stories old maylrushechki</a></li>
<li><a href="../312550/index.html">It's time to teach your designer to buy illustrations in photobanks</a></li>
<li><a href="../312552/index.html">Statistics for mathematics</a></li>
<li><a href="../312554/index.html">How I did the Brick Game on Unity3D for Android and got a lock from Google</a></li>
<li><a href="../312556/index.html">Methods for remote access to the Linux GUI</a></li>
<li><a href="../312558/index.html">node-direct - one NodeJS server for several sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>