<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scalable and high-performance web applications. Ch. 1. The HTTP protocol. Draft.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Topics covered: HTTP requests; HTTP responses; Optimization using HTTP keep-alive; Optimize with HTTP pipelining; Optimizing using HTTP caching: Cachi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scalable and high-performance web applications. Ch. 1. The HTTP protocol. Draft.</h1><div class="post__text post__text-html js-mediator-article">  Topics covered: HTTP requests;  HTTP responses;  Optimization using HTTP keep-alive;  Optimize with HTTP pipelining;  Optimizing using HTTP caching: Caching in modern clients, revalidation strategies, caching turned off and interactive pages;  Optimization with compression;  Specific optimization of the content delivered;  Combining content. <br><br>  Comments are welcome. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      &lt;div class = "chapter" lang = "ru" xml: lang = "ru"&gt; <h2>  Chapter 1. The HTTP Protocol </h2>  <b>Content</b> <a href="https://habr.com/ru/post/24313/">HTTP requests</a> <a href="https://habr.com/ru/post/24313/">HTTP responses</a> <a href="https://habr.com/ru/post/24313/">Optimization using HTTP keep-alive</a> <a href="https://habr.com/ru/post/24313/">Optimization using HTTP-pipelining</a> <a href="https://habr.com/ru/post/24313/">Optimization using HTTP caching</a> <a href="https://habr.com/ru/post/24313/">Caching in modern clients</a> <a href="https://habr.com/ru/post/24313/">Revalidation strategies</a> <a href="https://habr.com/ru/post/24313/">Disabling caching and interactive pages</a> <a href="https://habr.com/ru/post/24313/">Optimization using compression</a> <a href="https://habr.com/ru/post/24313/"><br></a>  <a href="https://habr.com/ru/post/24313/">content</a> <a href="https://habr.com/ru/post/24313/">Combining content</a> Clients (i.e. browsers or robots) communicate with web servers <br>  it is via HTTP.  Fine details of http work and its <br>  interactions with the lower and upper layers of technology - one of <br>  keys to high performance. https stands for Hyper Text Transport Protocol. <br>  Of course, it is used not only to transfer from server to client <br>  HTML files, but also for any other objects: images, scripts, <br>  CSS files, data files.  It also works in reverse. <br>  side - for uploading files to the server, sending forms and <br>  etc. AJAX applications also obviously communicate with the server over <br>  HTTP  Sometimes HTTP is used for more specific things. <br>  for example, to manage server content via WebDAV and <br>  etc. HTTP communication consists of a series of interleaved <br>  HTTP requests and HTTP responses between client and servers. &lt;Div class = "sect1" lang = "ru" xml: lang = "en"&gt; <h2>  HTTP requests </h2>  An HTTP request consists of three parts: the query string, headers, and <br>  message body.  Here is an example of an HTTP request that retrieves a file. <br>  <a href="http://www.habrahabr.ru/robots.txt">www.habrahabr.ru/robots.txt</a> : <pre>  GET /robots.txt HTTP / 1.1
 Host: www.habrahabr.ru
 User-Agent: Wget 1.8.3<font></font>
<font></font>
<font></font>
</pre> The vast majority of HTTP requests in the modern web - <br>  these are GET requests, whose request body is empty (zero length), that we <br>  and observe in this case.  POST requests, for example, body <br>  almost always non-empty. Let's look at the sample query in detail.  The first word in the request is <br>  <code>GET</code> .  This is the so-called "method" <br>  HTTP request.  The most common method is just <br>  <code>GET</code> .  The <code>GET</code> method means that we simply <br>  request content (page or file) available at specified <br>  URL'u.  An important fact is that GET requests can <br>  cached. Another frequently encountered request is <code>POST</code> . <br>  POST requests almost always contain the request body encoded <br>  in one of the special formats.  POST requests are usually sent to <br>  the result of the user clicking on the ‚ÄúSubmit‚Äù button or similar <br>  Action. The <code>HEAD</code> method (a neighbor of the GET method) is also used, and <br>  a whole series of more rare methods like <code>PUT</code> , <br><br>  <code>DELETE</code> , as well as a large set of methods specific to <br>  WebDAV protocol.  More about them is in other chapters. The second word in our query: <code>/robots.txt</code> - <br>  This is the URL of the page or file we want to get. The third word in our request is <code>HTTP/1.1</code> .  it <br>  proper protocol name and version number.  HTTP 1.1 <br>  almost universally used, but for some it's enough <br>  specific goals can sometimes be useful to reduce the version to HTTP <br>  1.0.  The main differences between HTTP 1.1 and HTTP 1.0 are mandatory. <br>  support for virtual hosts, improved caching support, <br>  HTTP support for keep-alive, and some more important <br>  capabilities. The query string is terminated with a CR-LF (\ r \ n) character combination. <br>  Next come the request headers, separated from each other as well. <br>  CR-LF combination.  The only required (in HTTP 1.1) <br>  the header is the <code>Host</code> containing the domain name on <br>  which is a page or file.  The HTTP standard describes <br>  many different request headers, many of which play <br>  key role in ensuring high performance.  AT <br>  The example shows another header, the <code>User-Agent</code> , containing <br>  client identifier line. The list of headers ends with another character combination <br>  CR-LF (i.e., empty string).  After the heading is the body <br>  request.  In our example, the request body is empty (zero length). &lt;Div class = "sect1" lang = "ru" xml: lang = "ru"&gt; <h2>  HTTP responses </h2>  By sending an HTTP request to the server, the client is waiting for a response.  HTTP response <br>  It looks generally similar to a query: status bar, list <br>  headers and response body. <pre>  HTTP / 1.1 200 OK
 Server: nginx / 0.5.35
 Date: Tue, Apr 22, 2008 10:18:08 GMT
 Content-Type: text / plain;  charset = windows-1251
 Connection: close
 Last-Modified: Fri, 30 Nov 2007 12:46:53 GMT
 ETag: "27e74f-43-4750063d"
 Accept-Ranges: bytes
 Content-Length: 34<font></font>
<font></font>
 User-agent: *
 Disallow: / people<font></font>
<font></font>
</pre>  The first word in the response is <code>HTTP/1.1</code> , version <br>  of the protocol.  The second word is <code>200</code> .  This is the most common <br>  response code indicating that the requested file or page is detected and <br>  given to the client.  There are many different response codes, some of <br>  which plays a key role in ensuring high <br>  performance.  The rest of the line is <br>  the human-readable description of the response code (in this case, <br>  <code>OK</code> ). After the status bar, there is a list of headers containing <br>  additional, sometimes extremely important information about the file or <br>  page.  In this case, of interest is the MIME type of content <br>  the last modified date of the file ( <code>Last-Modified</code> ) <br>  length ( <code>Content-Length</code> ), and also <code>ETag</code> (this <br>  special token used for caching).  Also in response <br>  there is some server information ( <code>Server</code> and <br><br>  <code>Date</code> ) and about the connection ( <code>Connection</code> ). After the list of titles, we see another empty line and, <br>  finally, the actual content of the response (in this case, these are two <br>  text lines). It can be concluded that HTTP is simple, flexible due to <br>  text syntax protocol.  Careful use of the set <br>  request and response headers will allow to achieve significant improvements in <br>  areas of high performance web system.  Detailed analysis <br>  we will deal with the following technologies in the following chapters. &lt;div class = "sect1" lang = "en" xml: lang = "en"&gt; <h2>  Optimize with HTTP keep-alive </h2>  The HTTP protocol runs on top of the TCP protocol (Transmission <br>  Control Protocol).  TCP is a reliable protocol. <br>  two-way data stream transmission.  TCP works by sending packets <br>  data from the client to the server and back.  TCP packet consists of a header <br>  and data.  The title indicates, among other things, the client‚Äôs IP address and <br>  server numbers, TCP port numbers used on the client and server, and dialing <br>  flags.  The server typically uses a standard TCP port. <br>  The number 80.TCP-connection between the client and the server is established with <br>  using the classic "TCP three-way handshake".  First client <br>  sends a packet with a SYN flag to the server.  In response, the server sends a packet with <br>  SYN + ACK flags.  Finally, the client sends another packet, with the flag <br>  ACK and from now on the connection is considered established, and the client can <br>  send your data, in our case - an HTTP request. It can be seen that this part of the protocol interaction requires one <br>  just wait for the response packet from the server before you could <br>  send an HTTP request.  That is, the operation of establishing a TCP connection <br>  may be relatively expensive, and on some channels with high <br>  latency and quite expensive.  In other words, we <br>  interested in reducing the number of TCP connections. In HTTP 1.1, this optimization is enabled by default.  Once <br>  having connected to the server, the client exchanges requests with it and <br>  answers without breaking the connection.  This is called HTTP <br>  keep-alive. It is clear that if a dozen thousand browsers install with the server <br>  keep-alive connection, they quickly exhaust its resources. <br>  Therefore, all servers have a configurable timeout after expiration <br>  which keep-alive connection is broken if it was not <br>  no activity. The client may request a disconnection after a response by sending to <br>  request header <code>Connection: close</code> .  Similarly <br>  the server may indicate in the response that it does not wish to support keep-alive <br>  connection, passing the exact same header: <br>  <code>Connection: close</code> .  Generally speaking, all these <br>  splicing with mutual notification, strictly speaking, do not impose <br>  no duties.  Both server and client must be fully prepared. <br>  to the fact that the connection is interrupted at any time on the initiative <br>  the other party without any notification. In order to maintain the integrity of the keep-alive connection, <br>  the server must know the length of the response.  The easiest way - <br>  specify it in the <code>Content-Length</code> header.  If the length <br>  the response is not specified by the handler, the server is forced before sending <br>  response set header <code>Connection: close</code> and <br>  close the connection for its part after sending the response.  Make sure your web application correctly exposes <br>  <code>Content-Length</code> header, otherwise keep-alive connections <br>  will not work. Sometimes the size of the response is difficult to determine at the stage of creation.  AT <br>  In this case, you can either donate a keep-alive connection, or <br>  use a special chunked response encoding (it is given with <br>  using the <code>Transfer-Encoding: chunked</code> header. <br>  Details can be found in the HTTP standard. &lt;Div class = "sect2" lang = "ru" xml: lang = "ru"&gt; <h3>  Optimize with HTTP pipelining </h3>  When we make a series of requests and responses within one <br>  keep-alive connections, time plays an important role in performance <br>  latency between request and response.  Delay may be <br>  caused by both high channel latency and long time <br>  processing requests on the server.  Before sending the next request, we <br>  Must wait for the processing of the next.  To cope with <br>  this problem, technology can be used <br>  HTTP-pipelining. The meaning of HTTP-pipelining is simply that the client <br>  sends several requests in succession, and then starts gradually <br>  to rake incoming answers.  Server support in general <br>  good, but unfortunately at the moment, customers supporting <br>  HTTP-pipelining, make up a very small percentage of the market. &lt;Div class = "sect1" lang = "en" xml: lang = "en"&gt; <h2>  Optimize with HTTP caching </h2>  Over the years, a lot of caching has accumulated around HTTP caching. <br>  myths and prejudices.  Chapter 13 RFC2616 (Caching in HTTP) <br>  pretty messy.  The main reason for this is that the authors <br>  tried to explain everything to everyone at once: both to the developers of the servers, and <br>  developers of clients, and developers of caching proxies.  Besides <br>  Moreover, the confusion adds a discussion of the fight against obsolete <br>  (HTTP 1.0) clients, servers and proxies. In this chapter we will try to accurately tell the whole story with <br>  point of view of a modern developer (that is, supporting <br>  HTTP 1.1) server.  First we discuss the simplest situation: how <br>  work with a modern client (without caching proxies on the way). <br>  Then - how to work with a modern client through one or <br>  several modern cache proxies.  Finally, we will discuss <br>  Additionally, which (obsolete) headers should be added to the response, <br>  to achieve acceptable results from old and outdated customers <br>  proxy on the way (note, however, that the existence of these two types <br>  animals prove extremely difficult). &lt;div class = "sect2" lang = "ru" xml: lang = "ru"&gt; <h3>  Caching in modern clients </h3>  In general, the caching process consists of two parts: <br>  the expiration date of the content and the revalidation procedure. To set the expiration date of the content, it is used <br>  <code>Cache-Control: max-age=300</code> response header <code>Cache-Control: max-age=300</code> .  Here <br><br>  <code>300</code> is the expiration date of the content in seconds <br>  (i.e., five minutes).  This means that within five minutes the client <br>  can freely use the received object without asking at all <br>  re-server. If an object is required after the expiration date, its <br>  must be revalidated.  Revalidation is just <br>  repeated request of the same object, but with additional <br>  headings.  Revalidation may result in either retransmission <br>  object, or to sending a special response code <br>  <code>304 Not Modified</code> .  Obviously, the second option <br>  is preferred.  There are three main methods of revalidation: <br><br><ul><li>  by last modified time <br>  ( <code>Last-Modified</code> ); </li><li>  by object identifier ( <code>ETag</code> ); </li><li>  unconditional (just give the contents of the object); </li></ul>  In order to work revalidation on the last <br>  changes, there should be a special header among the response headers <br>  <code>Last-Modified</code> , containing, naturally, the last time <br>  object changes.  When revalidation, this value is transmitted by the client to <br>  special request header: <code>If-Modified-Since</code> . <br>  The request handler can check if the object has changed, and if <br>  no - return the answer with an empty body and a response code <br><br>  <code>304 Not Modified</code> .  The content itself is not <br>  transmitted, and the client will use the content that <br>  stored in his cache. Use revalidation by last modified time is easier <br>  all for static files, and all default servers automatically <br>  include this feature.  For the case of dynamically generated pages <br>  the question of choosing the right architecture for processing the request and in general <br>  The possibility and expediency of such a revalidation is discussed. <br>  below. In order for revalidation to work by object identifier, <br>  among the response headers there should be a special header <br>  <code>ETag</code> .  It returns some unspecified <br>  object version identifier (for example, for Apache static files <br>  by default it uses a combination of the last modified date of the file, <br>  its size and inode number in the file system).  With revalidation <br>  the client sends a special header in the request <br>  <code>If-None-Match</code> containing the same identifier. <br>  The server compares the current value of the version identifier, and if <br>  matches, returns the response with the empty body and the response code <br>  <code>304 Not Modified</code> As in the case of revalidation on the last modification time, <br>  This revalidation is easiest to use for static files.  For <br>  the case of dynamically generated pages the question of choosing the right <br>  Content architecture is discussed below.  Both ways of revalidation can <br>  shared. For compatibility with mythological browsers and proxies, not <br>  support HTTP 1.1, add a header to the response <br>  <code>Expires</code> , which indicates the required expiration time <br>  file or page.  The format of this header is: <br>  <code>Tue, 15 Nov 1994 08:12:31 GMT</code> .  &lt;div class = "sect2" lang = "ru" xml: lang = "ru"&gt; <h3>  Revalidation strategies </h3>  As already mentioned, the easiest and most understandable is caching. <br>  static files like design images, javascript files and <br>  CSS files.  For static files it is very easy to generate and <br>  check the value of both conditions: as <code>Last-Modified</code> , so <br>  and <code>ETag</code> . The <code>ETag</code> difficult question in the case of static <br>  files - choose a convenient expiration date.  Developers <br>  Yahoo.com advises a simple strategy: a) put on static <br>  files have a one-year shelf life (read: "forever") and b) <br>  introduce a system for changing urls when posting a new version of the project <br>  on a production server. For example, in Ruby on Rails you can set up a project so that the URL <br>  CSS files will look like this: <br><br>  <code>/stylesheets/main.css?31415</code> , where <br>  <code>31415</code> is the latest revision number in the system. <br>  version control.  A similar mechanism should be easy to implement in <br>  any engine. Another conservative strategy is to cache <br>  static files for a short time, about half an hour.  So <br>  Thus, we speed up a typical user session.  When will he go <br>  to the site next time, the first time you just happen <br>  Mass revalidation of all statics.  This strategy is not required <br>  make changes to the system of removal of code for production (which, in principle, <br>  can be considered a disadvantage of this strategy - it is often <br>  may mean that there is no such system at all). In general, in order to achieve some significant increase <br>  performance, you need a happy combination of conditions. <br>  First, it should be relatively easy for a page to be calculated. <br>  validator (last modification time or ETag).  Secondly, <br>  info-page design should allow client download enough <br>  obsolete copies.  By experience, rare classes of pages <br>  provide this combination, not to mention some kind of measurable effect <br>  from the introduction of revalidation.  It is possible that for modern <br>  interactive projects in general no longer makes sense to think in this <br>  direction and concentrate on extremely high-speed generation <br>  these same pages. We repeat, however, that the above caching of static <br>  files plays a crucial role in the user experience of each particular <br>  user, and such caching should be given attention (good <br>  this is not difficult). Another aspect of this problem is that search engines <br>  systems are highly recommended to set a more or less correct time. <br>  Last-modified ( <code>Last-Modified</code> ) on all pages, <br>  who are you going to feed the search robot.  It is possible that <br>  the process of making corrections to the engine on this topic you will succeed without <br>  special effort to introduce also the strategy itself <br>  caching. &lt;div class = "sect2" lang = "ru" xml: lang = "ru"&gt; <h3>  Disable caching and interactive pages </h3>  Often it is necessary to solve also the inverse problem: how to make <br>  so that certain pages of the site are reloaded from the site each <br>  time the user logs in to them.  There is one on this topic. <br>  of the common myths associated with caching in HTTP.  He is bound <br>  with the ritual repetition of the magical incantation of the three magical <br>  headers: <br><br><pre> Cache-Control: no-cache
 Pragma: no-cache
 Expires: now
</pre>  We will not dwell on the detailed analysis of errors, <br>  collected in these three lines.  We just say that the first line <br>  not completely intended for this purpose, the second line never <br>  it did not make sense, and the third one was catastrophically obsolete (although it does <br>  assigned task). The correct modern way is to use <br>  <code>Cache-Control: max-age=0</code> header <code>Cache-Control: max-age=0</code> .  He means <br>  that the contents of the page become obsolete immediately upon receipt, and <br>  the browser must revalidate it.  The server, having received a request for <br>  revalidation, simply returns to the user a new version <br>  pages. For compatibility with mythological old browsers and <br>  proxies that do not support HTTP 1.1 should also be answered <br>  add an <code>Expires: now</code> header.  He has the same <br>  sense as <code>Cache-Control: max-age=0</code> &lt;div class = "sect1" lang = "en" xml: lang = "en"&gt; <h2>  Optimization with compression </h2>  An excellent way to significantly reduce traffic and speed up the response. <br>  server is the compression of the given files and pages.  Practically <br>  all modern web servers somehow support this <br>  functionality.  The compression ratio varies depending on <br>  each specific page and can reach values ‚Äã‚Äãof the order of 10. For <br>  web application developer compression is completely transparent and does not require <br>  no effort. The ability to take compressed client content <br>  announces server using header <br><br>  <code>Accept-Encoding: gzip</code> .  If the server is configured to <br>  compressing the relevant content, then it can add a header <br>  <code>Content-Encoding: gzip</code> response (not to be confused with <br>  <code>Transfer-Encoding</code> ) and send the client compressed <br>  Content. Historically different browsers had many different errors. <br>  in the processing of compressed content.  Now (mid 2008) <br>  It seems that the percentage of actually used clients with errors has decreased to <br>  negligible.  Usually the documentation for the server is set forth. <br>  An exemplary set of combinations of content types and browsers that <br>  work, as well as recommendations to work around errors in old clients. <br>  &lt;div class = "sect2" lang = "ru" xml: lang = "ru"&gt; <h3>  Specific optimization given <br>  the contents </h3>  Simply put, it removes extra spaces and line breaks. <br>  from html files and css files, minification of javascript as well <br>  optimization of file sizes with pictures.  Besides influencing the size <br>  transmitted data, this optimization can also lead to an increase in <br>  client-side performance: the browser will have less <br>  parsing and taking up less memory for page source and DOM nodes <br>  processed page.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript minification can also occur simultaneously with </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obfuscation (obscuring the meaning of the code), which may have some meaning in </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terms of intellectual property protection policies.</font></font> Libraries <br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multi-purpose tools </font><font style="vertical-align: inherit;">such as prototype.js contain built-in </font><font style="vertical-align: inherit;">support for minification, as well as the ability to remove a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subset of components </font><font style="vertical-align: inherit;">that are not used in the </font><font style="vertical-align: inherit;">project. &lt;div class = "sect2" lang = "ru" xml: lang = "en"&gt;</font></font><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combining content </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to reduce the number of HTTP requests, you can simply </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combine several files into one. </font><font style="vertical-align: inherit;">Often, with a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">combination, you can also minify the resulting file. The CSS files can simply be concatenated into one. </font><font style="vertical-align: inherit;">JavaScript files </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">require caution in this regard, but in general we can assume that </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if your JavaScript is not concatenated, you have some </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problem with the JS code architecture. Icons, navigation graphics, etc. can be combined into </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one file using t n. </font><font style="vertical-align: inherit;">CSS spriting. </font><font style="vertical-align: inherit;">See the numerous </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guides on this topic on the Internet.</font></font></div><p>Source: <a href="https://habr.com/ru/post/24313/">https://habr.com/ru/post/24313/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243121/index.html">Secure ABAP Development in SAP</a></li>
<li><a href="../243123/index.html">How to create and earn SaaS | Part 12 | Mobile revolution of access to the clouds: how to change the operator in "one click"</a></li>
<li><a href="../243125/index.html">Dialplan on LUA for Asterisk</a></li>
<li><a href="../243127/index.html">Everything begins with the announcement on Habr√©</a></li>
<li><a href="../243129/index.html">XFeatures - Useful extension for ATMEL STUDIO 6</a></li>
<li><a href="../243133/index.html">Website hosting provider redesign: errors and solutions</a></li>
<li><a href="../243135/index.html">Archivelink - Attachment Attachment Technology in SAP for Beginning Consultants</a></li>
<li><a href="../243139/index.html">Forwarding to mobile and SMS notification in the absence of a response. One of the possible implementations of the "callback"</a></li>
<li><a href="../24314/index.html">Testing abilities instead of a lottery for H1-B visas</a></li>
<li><a href="../243141/index.html">Another heart on Atmega</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>