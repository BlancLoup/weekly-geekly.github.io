<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AsyncDisplayKit 2.0 (Texture) Tutorial: Getting Started</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúArt is all you can do well. Everything you can do qualitatively ‚Äù(Robert M. Pirsig). 
 From the translator : 
 With the advent of autoLayout, creatin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AsyncDisplayKit 2.0 (Texture) Tutorial: Getting Started</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/692/75a/d06/69275ad06d8b462c9d022581eec82ec9.png"></p><br><p>  ‚ÄúArt is all you can do well.  Everything you can do qualitatively ‚Äù(Robert M. Pirsig). </p><br><blockquote>  <em>From the translator</em> : <br>  With the advent of autoLayout, creating an interface for an iOS application has become much easier and faster.  You no longer need to think about fitting the sizes for certain devices, autoLayout will do it for you.  Calculation occurs on the basis of constraints relative to the nearest elements.  The more such dependencies, the longer autoLayout will be built, and this is the main problem of all applications with a complex interface. <br>  Using AsyncDisplayKit will allow you to reduce the amount of work performed in the main thread by an order of magnitude and implement complex interfaces with a minimal amount of code.  The guys from Raywenderlich made a detailed and visual tutorial on working with him.  I hope that the translation of the article will help you to master this framework even faster. <br><a name="habracut"></a><br></blockquote><p>  AsyncDisplayKit is a UI framework that was developed and applied by Facebook in the Paper application.  He helped the Paper development team find the answer to one of the key questions: how to keep the main application stream as free as possible. </p><br><p>  Now many applications are based on the user interface, which is largely dependent on continuous movements and animation based on physics.  At least your UI is probably based on some type of Scroll View. </p><br><p>  These types of user interfaces are completely dependent on the main thread and extremely sensitive to its brakes.  Loaded mainstream means dropped frames and an unpleasant user experience. </p><br><p>  The main factors of work flow include: </p><br><ul><li>  <strong>Measurement and Layout</strong> : events such as calling the <strong>heightForRowAtIndexPath:</strong> method or <strong>sizeThatFits of the UILabel</strong> class, as well as the exponential cost of calculating the constraints. </li><li>  <strong>Image Decoding</strong> : Using a <strong>UIImage</strong> in image view mode means that image data must first be decoded. </li><li>  <strong>Drawing</strong> : complex text, as well as drawing gradients and shadows manually. </li><li>  <strong>Object Life Cycle</strong> : creating, managing, and destroying system objects (i.e. creating a <strong>UIView</strong> ). </li></ul><br><p>  When used correctly, AsyncDisplayKit allows you to perform all measurements, layout and rendering asynchronously by default.  Without additional optimization, the application can reduce the amount of work performed in the main flow by about an order of magnitude. </p><br><p>  In addition to these performance advantages, the modern AsyncDisplayKit offers an impressive array of amenities for developers, allowing you to implement complex interfaces with a minimal amount of code. </p><br><p>  In this tutorial AsyncDisplayKit 2.0, consisting of two parts, you will learn everything you need to create a useful and dynamic application using ASDK. </p><br><blockquote>  <strong>Note</strong> : ASDK is incompatible with either <a href="http://www.youtube.com/watch%3Fv%3DRY_X7l1g79Q%26feature%3Dyoutu.be%26t%3D29m37s">Interface Builder</a> or AutoLayout, so you will not use them.  Although ASDK fully supports Swift (as opposed to ComponentKit), many of its users still write in Objective-C.  At the time of creation of this tutorial, most of the top 100 free applications did not contain any Swift code at all (although 6 used ASDK).  Therefore, the article focuses on Objective-C.  But there is also a Swift version of the sample project in case you hate <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25BE%25D0%25B1%25D0%25BA%25D0%25B8">brackets</a> . </blockquote><br><h2 id="nachnem">  Let's start </h2><br><p>  To get started, <a href="">download your start project</a> . <br>  The project uses <a href="https://cocoapods.org/">CocoaPods</a> to connect AsyncDisplayKit.  So, in the usual CocoaPods style, go and open the <strong>RainforestStarter.xcworkspace</strong> , but NOT the <strong>RainforestStarter.xcodeproj</strong> . </p><br><blockquote>  <strong>Note</strong> : An Internet connection is required to work with this tutorial. </blockquote><p>  Compile and run an application consisting of a single <strong>UITableView</strong> containing a list of animals.  If you look at the code in <strong>AnimalTableController</strong> , you will see that this is the usual class <strong>UITableViewController</strong> , which you have probably seen many times. </p><br><blockquote>  <strong>Note</strong> : Make sure that the code is running on a real device, and not on the simulator. </blockquote><p>  Scroll through the table and note the number of frames that were skipped.  You do not need to run the tools to see that this application needs to improve performance. </p><br><p><img src="https://habrastorage.org/web/c1d/549/7bf/c1d5497bfacd4061a9fdd15a960733f9.gif"></p><br><p>  You can fix this using AsyncDisplayKit. </p><br><h2 id="predstavlyaem-asdisplaynode">  Introducing ASDisplayNode </h2><br><p>  <strong>ASDisplayNode</strong> is the <strong>ASDK</strong> base class and, in fact, just the ‚Äúview‚Äù object in the MVC pattern, similar to <strong>UIView</strong> or <strong>CALayer</strong> .  The best way to present ASDisplayNode is to think about the relationship between <strong>UIViews</strong> and <strong>CALayers</strong> , with which you should already be familiar. </p><br><p>  Remember that on the screen in the iOS application everything is represented through the <strong>CALayer</strong> object.  <strong>UIViews</strong> create and own <strong>CALayer</strong> support, to which they add touch processing and other functions.  The <strong>UIView</strong> class <strong>itself is</strong> not a <em>subclass of</em> <strong>CALayer</strong> .  Instead, it wraps the layer object, extending its functionality. </p><br><p><img src="https://habrastorage.org/web/789/ac2/842/789ac28421bc4fc781170abff839d4ff.png"></p><br><p>  In the case of <strong>ASDisplayNode,</strong> this abstraction expands: you can think of them as wrapping the view in the same way that the view wraps the layer. <br>  What the nodes bring to the table, besides the usual view, is that they can be created and configured in background queues and simultaneously presented by default. </p><br><p><img src="https://habrastorage.org/web/789/ac2/842/789ac28421bc4fc781170abff839d4ff.png"></p><br><p>  Fortunately, the API for working with nodes should be incredibly familiar to anyone who has used <strong>UIViews</strong> or <strong>CALayers</strong> .  All the view properties that you normally use are available in the equivalent node class.  You can even get access to the view or leer itself, as well as to the <strong>.layer</strong> class of the <strong>UIView</strong> . </p><br><h2 id="konteynery-uzla">  Node containers </h2><br><p>  Although the nodes themselves provide the opportunity for significant performance improvements, real magic happens when they are used in conjunction with one of four container classes. </p><br><p>  These classes include: </p><br><ul><li>  <strong>ASViewController</strong> : A subclass of <strong>UIViewController</strong> that allows you to provide the node that you want to manage. </li><li>  <strong>ASCollectionNode and ASTableNode</strong> : equivalents for the <strong>UICollectionView</strong> and <strong>UITableView</strong> nodes, a subclass of which is supported under the hood. </li><li>  <strong>ASPagerNode</strong> : <strong>ASCollectionNode</strong> subclass that provides high read performance over <strong>UIPageViewController</strong> from the <strong>UIKit</strong> framework. </li></ul><br><p><img src="https://habrastorage.org/web/152/8ec/53d/1528ec53d5604a21a1a8faf9c9eb42d9.png"></p><br><p>  To be honest, real magic comes from <strong>ASRangeController</strong> , which uses each of these classes to influence the behavior of the contained nodes.  For now, just trust me and remember this for the future. </p><br><h2 id="preobrazovanie-tableview">  TableView conversion </h2><br><p>  The first thing you need to do is convert the current table view to a table node.  It is quite simple. </p><br><h3 id="zamena-tableview-na-tablenode">  Replacing tableView with tableNode </h3><br><p>  First go to AnimalTableController.m.  Add the following line below the other imports in this class: </p><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;</span></span></span></span></code> </pre> <br><p>  So you import ASDK to use the framework. <br>  Then go and replace the <strong>tableView</strong> property <strong>declaration</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> *tableView;</code> </pre> <br><p>  on <strong>tableNode</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) ASTableNode *tableNode;</code> </pre> <br><p>  This will cause most of the code in this class to break, but don‚Äôt panic! </p><br><p><img src="https://habrastorage.org/web/296/4d2/a9e/2964d2a9e648404d808df3168eb193bc.png"></p><br><p>  Seriously, don't worry.  These errors and warnings will serve as your guide when converting what you have now into what you want. </p><br><p>  The errors in <strong>-viewDidLoad are</strong> , of course, related to the fact that the <strong>tableView</strong> no longer exists.  I'm not going to force you to view the entire project and change all instances of <strong>tableView</strong> to <strong>tableNode</strong> (it is not so difficult to find and replace, so don‚Äôt be afraid), but if you did, you will see that: </p><br><ol><li>  You must assign an <strong>ASTableNode</strong> property. </li><li>  The table node does not have a method named <strong>-registerClass: forCellReuseIdentifier:.</strong> </li><li>  You cannot add a node as a subview. </li></ol><br><p>  At this point, you should simply replace <strong>-viewDidLoad</strong> with the following: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view addSubnode:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> applyStyle]; }</code> </pre> <br><p>  Interestingly, you call <strong>-addSubnode:</strong> for <strong>UIView</strong> .  This method was added to all <strong>UIViews</strong> through a category and is exactly equivalent: </p><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view addSubview:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.view];</code> </pre> <br><p>  Then correct <strong>-viewWillLayoutSubviews</strong> , replace the implementation of this method with the following: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewWillLayoutSubviews { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewWillLayoutSubviews]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.frame = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.bounds; }</code> </pre> <br><p>  All this replaces <strong>self.tableView</strong> with <strong>self.tableNode</strong> for setting the frame of the table. <br>  Then find the <strong>-applyStyle</strong> method and replace the implementation with the following: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)applyStyle { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> blackColor]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.view.separatorStyle = <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellSeparatorStyleNone</span></span>; }</code> </pre> <br><p>  The string that specifies the <strong>separatorStyle</strong> for the table is the only modified string.  Notice how the view property of the table node is accessed to set the <strong>separatorStyle</strong> for the table.  <strong>ASTableNode</strong> does not disclose all <strong>UITableView</strong> properties, so you need to access the <strong>UITableView</strong> instance of the base table node to change certain <strong>UITableView</strong> properties. </p><br><p>  Then add the following line at the very beginning of <strong>-InitWithAnimals</strong> : </p><br><pre> <code class="objectivec hljs">_tableNode = [[ASTableNode alloc] initWithStyle:<span class="hljs-built_in"><span class="hljs-built_in">UITableViewStylePlain</span></span>];</code> </pre> <br><p>  And add this code to the end, before the initializer's return statement: </p><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> wireDelegation];</code> </pre> <br><p>  So you initialize <strong>AnimalTableController</strong> with a table node and call <strong>-wireDelegation</strong> to connect the delegates to the table node. </p><br><h3 id="nastroyka-istochnika-dannyh-i-delegata-tablichnogo-uzla">  Configuring a data source and table node delegate </h3><br><p>  Like <strong>UITableView</strong> , <strong>ASTableNode</strong> uses a data source and delegate to get information about itself.  The <strong>ASTableDataSource</strong> protocols Tables and <strong>ASTableDelegate are</strong> very similar to <strong>UITableViewDataSource</strong> and <strong>UITableViewDelegate</strong> .  In fact, they define some of the same methods, such as <strong>-tableNode: numberOfRowsInSection:.</strong>  The two sets of protocols do not completely match each other, because <strong>ASTableNode</strong> behaves slightly differently than <strong>UITableView</strong> . </p><br><p>  Find <strong>-wireDelegation</strong> and replace <strong>tableView</strong> with <strong>tableNode</strong> in the implementation: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)wireDelegation { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; }</code> </pre> <br><p>  Now you will receive a warning that <strong>AnimalTableController</strong> does not actually conform to the correct protocol.  Now <strong>AnimalTableController</strong> corresponds to <strong>UITableViewDataSource</strong> and <strong>UITableViewDelegate</strong> .  In the following sections, you will accept and implement each of these protocols so that the table node can function. </p><br><h3 id="sootvetstvie-astabledatasource">  ASTableDataSource compliance </h3><br><p>  At the top of <strong>AnimalTableController.m,</strong> locate the following <strong>DataSource</strong> category interface declaration: </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimalTableController</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">)&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewDataSource</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  And replace <strong>UITableViewDataSource</strong> with <strong>ASTableDataSource</strong> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimalTableController</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">)&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ASTableDataSource</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  Now that the <strong>AnimalTableController</strong> declaration is <strong>an</strong> <strong>ASTableDataSource</strong> , it's time to do it. </p><br><p>  Scroll to the bottom of <strong>AnimalTableController.m</strong> and look for the implementation of the <strong>DataSource</strong> category. <br>  First, change the <strong>UITableViewDataSource</strong> method <strong>-tableView: numberOfRowsInSection:</strong> to the <strong>ASTableDataSource</strong> protocol <strong>method</strong> , replacing it with the following. </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)section { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animals.count; }</code> </pre> <br><p>  Further, <strong>ASTableNodes</strong> expects its cells to be returned differently than <strong>UITableView</strong> cells.  To adapt to the new paradigm, replace <strong>-tableView: cellForRowAtIndexPath:</strong> with the following method: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//1 - (ASCellNodeBlock)tableNode:(ASTableView *)tableView nodeBlockForRowAtIndexPath:(NSIndexPath *)indexPath { //2 RainforestCardInfo *animal = self.animals[indexPath.row]; //3 return ^{ //4 CardNode *cardNode = [[CardNode alloc] initWithAnimal:animal]; //   - ‚Ä¶ return cardNode; }; }</span></span></code> </pre> <br><p>  Consider this section: </p><br><ol><li>  <strong>ASCellNode</strong> is ASDK equivalent to <strong>UITableViewCell</strong> or <strong>UICollectionViewCell</strong> .  It is important to note that this method returns an <strong>ASCellNodeBlock</strong> .  This is due to the fact that <strong>ASTableNode</strong> supports all its cells inside and provides a block for each index path, it can simultaneously initialize all its cells when it is ready. </li><li>  The first thing you do is take the link to the data model you need to fill this cell.  This is a very important pattern.  You capture the data, and then get it in the next block.  <strong>IndexPath</strong> should not be used inside a block if the data changes before the block was called. </li><li>  Then you return the block whose return value should be <strong>ASCellNode</strong> . </li><li>  No need to worry about reusing the cell, relax and initialize it in the usual way.  Notice that now you are returning <strong>CardNode</strong> instead of <strong>CardCell</strong> . </li></ol><br><p>  This brings me to an important point.  As you may have already noticed, there is no reuse of cells when using ASDK.  This has already been mentioned twice, but just keep that in mind.  Do not be afraid to go to the beginning of the class and delete. </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *kCellReuseIdentifier = @¬´CellReuseIdentifier¬ª;</code> </pre> <br><p>  You no longer need it.  Just think.  You never have to worry about <strong>-prepareForReuse</strong> again ... </p><br><h3 id="sootvetstvie-astabledelegate">  ASTableDelegate compliance </h3><br><p>  Go to the beginning of <strong>AnimalTableController.m</strong> and locate the following <strong>delegate</strong> category interface declaration: </p><br><pre> <code class="objectivec hljs">interface AnimalTableController (Delegate)<span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre> <br><p>  and replace <strong>UITableViewDelegate</strong> with <strong>ASTableDelegate</strong> : </p><br><pre> <code class="objectivec hljs">interface AnimalTableController (Delegate)<span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre> <br><p>  Now that <strong>AnimalTableController</strong> accepts <strong>ASTableDelegate</strong> , it's time to move on to implementation.  Navigate to the bottom of <strong>AnimalTableController.m</strong> and look for the implementation of this <strong>Delegate</strong> category. </p><br><p>  Sure, you know that with <strong>UITableView</strong> you need to provide an implementation of <strong>-tableView: heightForRowAtIndexPath:.</strong>  This is due to the fact that with <strong>UIKit</strong> , the height of each cell is calculated and returned by the table delegate. </p><br><p>  <strong>ASTableDelegate</strong> does not need <strong>-tableView: heightForRowAtIndexPath:.</strong>  In ASDK, all <strong>ASCellNodes are</strong> responsible for determining their own size.  Instead of providing a static height, you can optionally define a minimum and maximum size for your cells.  In this case, it is necessary that each cell be at least as high as 2/3 of the screen. </p><br><p>  For now just replace <strong>-tableView: heightForRowAtIndexPath:</strong> with: </p><br><pre> <code class="objectivec hljs">- (ASSizeRange)tableView:(ASTableView *)tableNode constrainedSizeForRowAtIndexPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *)indexPath { <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> width = [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].bounds.size.width; <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> min = <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(width, ([<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].bounds.size.height/<span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGSize</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">CGSizeMake</span></span>(width, INFINITY); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ASSizeRangeMake(min, max); }</code> </pre> <br><p>  Compile and run the project to see what happened. </p><br><p>  We have a smooth table!  Once you have done this, prepare to do even better. </p><br><h2 id="beskonechnyy-skroll-s-paketnoy-vyborkoy">  Infinite scroll with batch sampling </h2><br><p>  In most applications, the server has more data available than the number of cells you would like to show in the table.  This means that every application you are working on will have a mechanism for downloading the next data packet from the server, because the user is nearing the end of the current data set. </p><br><p>  Many times this was handled manually, remembering the content offset in the scrollView delegate in the <strong>-scrollViewDidScroll:</strong> method.  With ASDK, there is a more declarative way to do this.  You can tell in advance how many pages you need to download new data. </p><br><p>  First uncomment the helper methods that were included.  Go to the end of <strong>AnimalTableController.m</strong> and uncomment these two methods in the <strong>Helpers</strong> category.  You can think of <strong>-retrieveNextPageWithCompletion: as a</strong> network call, while <strong>-insertNewRowsInTableNode</strong> is the standard method for adding new items to a table. </p><br><p>  Then add the following line to <strong>-viewDidLoad:.</strong> </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableNode.view.leadingScreensForBatching = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// overriding default of 2.0</span></span></code> </pre> <br><p>  Setting <strong>leadingScreensForBatching</strong> to 1.0 means that you want the new packages to be loaded each time the user scrolls to the point where only 1 item remains to the end of the table. </p><br><p>  Now add the following method to the implementation of the <strong>Delegate</strong> category: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)shouldBatchFetchForTableNode:(ASTableNode *)tableNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; }</code> </pre> <br><p>  This method is needed to tell the table whether it should continue to execute queries in order to download new packages.  If you know that there is nothing more to download, return <strong>NO</strong> . <br>  If you really want this table to scroll endlessly, simply return <strong>YES</strong> to ensure that new packages will always be requested. </p><br><p>  Then also add: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context { <span class="hljs-comment"><span class="hljs-comment">//1 [self retrieveNextPageWithCompletion:^(NSArray *animals) { //2 [self insertNewRowsInTableNode:animals]; //3 [context completeBatchFetching:YES]; }]; }</span></span></code> </pre> <br><p>  This method will be called when the user approaches the end of the table, and the table will receive <strong>YES</strong> from <strong>-shouldBatchFetchForTableNode:.</strong> </p><br><p>  Let's take a look at this section: </p><br><ol><li>  First, you must complete the query to display the next batch of animals.  This is usually an array of objects returned by the API. </li><li>  After completion, refresh the table with the newly uploaded data. </li><li>  Finally, make sure to <strong>call -completeBatchFetching:</strong> with <strong>YES</strong> .  Requests for new data will not be fulfilled until the previous one has been completed. <br>  Compile, run and start scrolling.  Do not stop until you see another bird.  They are endless. </li></ol><br><p><img src="https://habrastorage.org/web/0d7/9a4/98b/0d79a498b6e34fcbb6807b2d1d53df85.gif"></p><br><h2 id="umnyy-preloading">  Smart preloading </h2><br><p>  Have you ever tried to load content in advance in an application using scrollView or PageViewController?  Perhaps you worked on a full-screen photo gallery and wanted the next few images to be uploaded and waiting for, and users rarely saw the placeholder. </p><br><p><img src="https://habrastorage.org/web/5ea/a9e/df7/5eaa9edf7dcb4c1198db44d9fccd2ee6.png"></p><br><p>  When you work on a system like this, you begin to realize that there are many things that are worth thinking about. </p><br><ul><li>  How much memory do you occupy? </li><li>  How much information do you need to upload in advance? </li><li>  When do you decide to output an answer to users? <br>  And the task becomes much more difficult when you have content of different sizes.  Do you have a PageViewController with a CollectionView inside each controller?  Now you need to think about how to dynamically load content in both directions ... And customize the display for each device you support. </li></ul><br><p><img src="https://habrastorage.org/web/ce4/c0d/c13/ce4c0dc137184c739617e61311ceb035.png"></p><br><p>  In each of the container classes there is a concept of the interface state for each of the nodes.  At any time, a node can be in any combination: </p><br><img src="https://habrastorage.org/web/480/ba3/c47/480ba3c479804771b7b981f7459feacf.png" align="right"><br><ul><li>  <strong>Preload Range:</strong> Usually the far range from the visible.  When content for each subnode in a cell, such as ASNetworkImageNode, must be loaded from an external source;  from the API or local cache, for example.  This contrasts with the batch sampling, which should be used to select model objects representing the cells themselves. </li><li>  <strong>Display Range:</strong> Text drawing and image decoding take place here. </li><li>  <strong>Visible Range:</strong> In this range, a node on the screen occupies at least one pixel. </li></ul><br><p>  These ranges also work with the screenfuls metric and can be easily configured using the <strong>ASRangeTuningParameters</strong> property. </p><br><p>  For example, you use <strong>ASNetworkImageNode</strong> to display an image on each gallery page.  Each node requests data from the network when it enters the preload range, and decodes the image that was extracted when it enters the display range. </p><br><p>  In fact, you don‚Äôt have to constantly think about these bands if you don‚Äôt want to.  Built-in components, such as <strong>ASNetworkImageNode</strong> and <strong>ASTextNode</strong> , make full use of them.  This means that you will see the benefits by default. </p><br><blockquote>  <strong>Note</strong> : One thing that may not be obvious is that these ranges do not add up.  Instead, they overlap and converge on the visible range.  If you set the display and select both ranges on the same screen, they will appear at the same time.  This data is usually needed for display on the screen, so usually the range of the prefetch must be slightly larger so that the nodes are ready to start the display process when they get to this range. <br>  In general, the leading side of the range is larger than the end.  When the user changes the direction of the scroll, the sizes of the ranges also change to prepare for the content to which the user is moving. </blockquote><br><h2 id="interfeys-uzla-v-sostoyanii-obratnogo-vyzova">  Node interface in callback state </h2><br><p>  Perhaps you wonder how these bands work correctly?  Well, that was asked. <br>  Each node in the system has an <strong>interfaceState</strong> property, which is a type of ‚Äúbit field‚Äù (NS_OPTION) <strong>ASInterfaceState</strong> .  As the <strong>ASCellNode</strong> moves through the scroll view, which is controlled by the <strong>ASRangeController</strong> , each subnode updates the <strong>interfaceState</strong> property.  This means that even the deepest nodes in the tree can react to <strong>interfaceState</strong> changes. </p><br><p>  Fortunately, you rarely have to tinker with the <strong>interfaceState</strong> node bits directly.  Most often, you just want to respond to the transition of a node to a certain state or exit from it.  This is where the interface status callbacks appear. </p><br><h3 id="naimenovanie-uzlov">  The name of the nodes </h3><br><p>  To see how a node goes from one state to another, it is helpful to give it a name.  This way, you can observe how each node loads its data, displays its contents, appears on the screen, and then does it all the other way around when it disappears. <br>  Go back to <strong>-tableNode: nodeBlockForRowAtIndexPath:</strong> and find the comment that says: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   - ‚Ä¶</span></span></code> </pre> <br><p>  Below, add the following line to give each cell a <strong>debugName</strong> . </p><br><pre> <code class="objectivec hljs">cardNode.debugName = [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:@¬´cell %zd¬ª, indexPath.row];</code> </pre> <br><p>  Now you can track the movement of cells across ranges. </p><br><h3 id="nablyudenie-za-yacheykami">  Cell monitoring </h3><br><p>  Go to <strong>CardNode_InterfaceCallbacks.m</strong> .  Here you will find six methods that you can use to track the progress of a node through various ranges.  Uncomment them, then compile and run.  Make sure your console is visible in Xcode, and then slowly scroll.  See how different cells react to their changing states. </p><br><p><img src="https://habrastorage.org/web/dd1/4bf/c7d/dd14bfc7d58a4fa38043401a691200fe.gif"></p><br><blockquote>  <strong>Note</strong> : In most cases, the only way to change the ASInterfaceState that you need is the <strong>-didEnterVisibleState</strong> or <strong>-didExitVisibleState method</strong> . <br>  The main implementation is hidden from you.  To check what you can do by integrating the Preload and Display states, look at the code in <strong>ASNetworkImageNode</strong> .  All network image nodes will automatically extract and decode their contents, as well as free up memory, without the need to move a finger. </blockquote><br><h2 id="intellektualnyy-preloading2">  (Intelligent Preloading) 2 </h2><br><p>  In version 2.0, the concept of intelligent preloading of content in several directions was introduced.  Let's say you have a vertically scrollable table view, and at some point a cell appears on the screen containing a horizontal view of the collection. </p><br><p><img src="https://habrastorage.org/web/b0d/a32/764/b0da32764bd64088b9da25ec7bfb63d6.gif"></p><br><p>  Although this collection is now technically in the visible area, you would not want to download the entire collection in advance.  Instead, both scrolls have their own <strong>ASRangeController</strong> with separate adjustable range settings. </p><br><h3 id="vvod-vtoroy-razmernosti">  Enter the second dimension </h3><br><p>  Now that you have completed <strong>AnimalTableController</strong> , you can use it as a page in <strong>ASPagerNode</strong> . </p><br><p>  The view controller that you will use to host this pager is already in the project, so the first thing you need to do is go to <strong>AppDelegate.m</strong> . <br>  Find <strong>-installRootViewController</strong> and replace: </p><br><pre> <code class="objectivec hljs">AnimalTableController *vc = [[AnimalTableController alloc] initWithAnimals:[RainforestCardInfo allAnimals]];</code> </pre> <br><p>  on: </p><br><pre> <code class="objectivec hljs">AnimalPagerController *vc = [[AnimalPagerController alloc] init];</code> </pre> <br><p>  Then go to <strong>AnimalPagerController.m</strong> and add the following lines to the initializer, just before the return statement.  All you need to do is create a new pager and set its <strong>dataSource</strong> as this view controller. </p><br><pre> <code class="objectivec hljs">_pagerNode = [[ASPagerNode alloc] init]; _pagerNode.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>;</code> </pre> <br><p>  The pager node is actually a subclass of <strong>ASCollectionNode</strong> , preconfigured for use in the same way as a <strong>UIPageViewController</strong> .  Well, what to think about the API is actually a bit simpler than about the <strong>UIPageViewController</strong> . </p><br><p>  The next thing you need to do is implement the methods of the pager data source.  Navigate to the implementation of the <strong>ASPagerDataSource</strong> category at the end of this file. </p><br><p>  First tell the pager that the number of its pages is equal to the number of animal arrays, in this case, three, replacing the existing <strong>-numberOfPagesInPagerNode:.</strong> </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)numberOfPagesInPagerNode:(ASPagerNode *)pagerNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animals.count; }</code> </pre> <br><p>  Then you need to implement <strong>-pagerNode: nodeAtIndex:</strong> similar to the node's data source method that you previously implemented for <strong>ASTableNode</strong> . </p><br><pre> <code class="objectivec hljs">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)index { <span class="hljs-comment"><span class="hljs-comment">//1 CGSize pagerNodeSize = pagerNode.bounds.size; NSArray *animals = self.animals[index]; //2 ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^{ return [[AnimalTableController alloc] initWithAnimals:animals]; } didLoadBlock:nil]; return node; }</span></span></code> </pre> <br><p>  Let's take a look at this section: </p><br><ol><li>  Although this version is not a block version, it is good practice to first capture your data model. </li><li>  This time you are using the powerful initializer <strong>-initWithViewControllerBlock:.</strong>  All you need to do is return a block that returns the controller to the table node that you fixed earlier, and the managed view will automatically be used as the view for each page. </li></ol><br><p>  After adding this method, you will have a fully functioning pager whose cells will be generated from the previously created <strong>tableNodeController</strong> .  It fully comes with a two-dimensional preload, based on the user‚Äôs vertical and horizontal scrolling! </p><br><p><img src="https://habrastorage.org/web/652/7ce/13a/6527ce13a5d545d695faedd67d7d087c.gif"></p><br><h2 id="kuda-idti-dalshe">  Where to go next? </h2><br><p>  The full version of the project for this tutorial on AsyncDisplayKit 2.0 can be downloaded <a href="">here</a> .  We also have an <a href="">option</a> on Swift. </p><br><p>  Translation of part 2 of this project will be ready soon.  It will let you know about the new, powerful layout system introduced in AsyncDisplayKit 2.0. </p><br><p>  You can do a little research before moving on: open the <a href="http://texturegroup.org/">AsyncDisplayKit</a> home page and read some of the documentation.  Scott Goodson (Scott Goodson, original author AsyncDisplayKit) also has a few lectures that may interest you, the <a href="https://www.youtube.com/watch%3Fv%3D0bOdPUvSzG0">newest</a> of which give a good overview of several large image problems that the framework is trying to solve. </p><br><p>  You might be interested in <a href="https://www.youtube.com/watch%3Fv%3DOiY1cheLpmI">Building Paper</a> .  Although at the time all this was not an open source, and much had changed, it was rather interesting to see how it all began. </p><br><p>  Finally, the AsyncDisplayKit community welcomes newcomers.  There is a publicly accessible <a href="http://texturegroup.org/slack.html">channel on Slack</a> that anyone can join and ask questions. </p><br><p>  We hope you enjoyed this tutorial, let us know if you have any questions or comments by joining the discussion on the forum. </p><br><p>  <strong>From the translator:</strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In April, the developers renamed the framework. </font><font style="vertical-align: inherit;">Now it is called Texture. </font><font style="vertical-align: inherit;">Read more </font></font><a href="https://medium.com/%40Pinterest_Engineering/introducing-texture-a-new-home-for-asyncdisplaykit-e7c003308f50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br><p>  PS Special thanks to <a href="https://habrahabr.ru/users/beatasunshine/" class="user_link">BeataSunshine</a> and <a href="https://habrahabr.ru/users/evgen/" class="user_link">evgen</a> for their help in translating the article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329002/">https://habr.com/ru/post/329002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328992/index.html">We clean the tails of Microsoft Exchange Server 2016 using Powershell</a></li>
<li><a href="../328994/index.html">Tale of two printers, or how we drove the Ricoh printers</a></li>
<li><a href="../328996/index.html">Marketing research. How to check the business idea for a week, spending a penny?</a></li>
<li><a href="../328998/index.html">Why constant traffic filtering is a necessity</a></li>
<li><a href="../329000/index.html">Test analysis in mobile development</a></li>
<li><a href="../329004/index.html">Redefining javascript: death for</a></li>
<li><a href="../329006/index.html">Non-standard way of teaching a new programming language (translation of the article Sahil Dua)</a></li>
<li><a href="../329008/index.html">Cognitive dissonance and its application in marketing</a></li>
<li><a href="../329010/index.html">Is the impact of speed on site results critical and what can be done about it?</a></li>
<li><a href="../329012/index.html">Attorney Broflowski principle, or do-it-yourself cloud load balancing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>