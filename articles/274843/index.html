<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúStupid‚Äù watches on FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all! 

 I decided to write another article that would be useful for novice developers in the field of FPGA. He postponed the moment of public...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúStupid‚Äù watches on FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello to all! <br><br>  I decided to write another article that would be useful for novice developers in the field of FPGA.  He postponed the moment of publication for a very long time, the material itself was prepared several months ago, but somehow it didn‚Äôt get around to sit down and write all this in the whole article.  But at last free time appeared, therefore I invite all interested in reading. <br><img src="https://habrastorage.org/files/246/d07/562/246d075621254b858cf6c34c054bc84d.jpg"><br><br>  The project is called a ‚Äústupid clock‚Äù because it doesn‚Äôt know anything except how to count the time and date and display them.  First of all, the project is designed for senior students and beginners.  There are no unusual blocks in it, vendor IP cores are not used, and even more so there are no complicated exchange interfaces (such as PCIe, Ethernet, USB, etc.). <br>  This time the project on programmable logic integrated circuits (FPGAs) will be primitive and extremely simple, and I will try to tell you about all the difficulties that I had to face in carrying out the task. <br><a name="habracut"></a><br><h3>  Initial data </h3><br>  Debugging board: the same small and simple devkit based on Spartan3E FPGA.  Its characteristics: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Key Features:</b> <br><ul><li>  FPGA Spartan3E ( <b>XC3S500E-4PQ208C</b> ) - 500K logic gates, </li><li>  Clock source CLK = 50 MHz, </li><li>  64M SDRAM external memory, </li><li>  SPI Flash (M25P80) for storing FPGA firmware, </li><li>  LED matrix 8x8, LED line 8 pcs., </li><li>  8 switches and 5 buttons, </li><li>  Connectors for connecting LED displays, </li><li>  VGA connector for connecting the display, </li><li>  <b>DS1302 timer</b> , </li><li>  <b>LCD1602 display</b> </li><li>  PS / 2 connectors, etc. </li></ul><br>  From this list, we will need directly the FPGA itself, which will manage this whole business.  Two devices are also needed (DS1302 chip and LCD1602 display) and several trigger switches. <br><br>  <a href="http://datasheets.maximintegrated.com/en/ds/DS1302.pdf">DS1302</a> - timer with serial interface transfer (manufactured by Maxim Integrated), <br>  <a href="http://www.elecrow.com/download/LCD1602.pdf">LCD1602</a> - LCD display with the ability to display two lines of 16 characters (manufactured by Noname). <br><br>  Below is a block diagram of the connections: <br><img src="https://habrastorage.org/files/8e2/692/85a/8e269285a1e24aa88b277e307e4df620.png"><br>  Let us turn to the description of the used chips. <br><br><h3>  Timer </h3><br>  The DS1302 is a small microchip that uses three lines for data exchange, which form a serial interface. <br><ul><li>  <b>CE</b> - clock enable, enables SCLK clocking. </li><li>  <b>SCLK</b> - clock signal (maximum frequency of operation = 2 MHz). </li><li>  <b>I / O</b> is an input / output port through which data and commands are transmitted in serial form. </li></ul><br>  The main feature of the chip is that the passage of time does not stop, even if the FPGA and the display is disconnected from the power supply.  The timer allows you to count seconds, minutes, hours, days of the week, days, months, as well as years, that is, a full set of "hours." <br><img src="https://habrastorage.org/files/98d/63c/bfb/98d63cbfb4be4f069d47e04cfc2900d0.png"><br>  Also, the chip stores the latest "stitched" values ‚Äã‚Äãof time and date.  But by itself, the chip is "stupid", that is, it needs to set all the parameters, including the day of the week.  Inside the timer there is a counter, which correctly increments the time and date values, if everything was properly flashed on the chip. <br>  A quartz oscillator tuned to the frequency f = 32.768 kHz is connected to the chip from the outside. <br><br>  The following figure shows the interface for exchanging data in read and write mode: <br><img src="https://habrastorage.org/files/d33/c46/0ef/d33c460efce1483ab6082dc1335cf548.png"><br><br>  <b>How it works?</b> <br>  a) In order to record or read any value from the timer, it is necessary at the time of the transmission to set the high level (logical 1) to the CE input, <br>  b) Depending on the read or write operation, with a high CE level, 15 or 16 clocks are required, respectively.  The operation of writing data from the I / O input occurs on the rising edge of the SCLK clock signal, and the data reading operation occurs on the falling edge of the SCLK signal.  The data is transmitted in order from the low-order bit to the high-order one. <br>  c) The first byte in the transmission process is always overhead and is always ‚Äúwritten‚Äù to the timer.  This means that it selects the type and direction of the transmitted command.  The zero bit of R / W is responsible for the type of operation: ‚Äúread‚Äù - at high level, ‚Äúwrite‚Äù - at low signal level.  Bit field from 1 to 5 sets the address of the command or the internal memory of the timer.  The sixth bit defines work with timer registers or internal memory: ‚Äúmemory‚Äù at high logic level, ‚Äútimer‚Äù at low logic level.  The seventh bit should always be set to 1 (if the seventh bit is randomly equal to 0, then the timer does not respond to the command). <br>  d) Second byte - data written to or read from the timer. <br><br>  The following figure shows a table of timer commands: <br><img src="https://habrastorage.org/files/79d/fde/9ea/79dfde9ea9ca4d0eb94473579304a895.png"><br><br>  <b>How to work with the table?</b> <br>  The table shows that the timer processes the data in <a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary coded decimal format (BCD)</a> .  In this regard, further on the FPGA you will have to write a data converter from binary format to binary-decimal. <br>  <b>Example:</b> to read seconds from a timer, you need to create a command byte 0x81.  To record the minutes, you need to create a command byte 0x82. <br><br>  When working with a timer chip, there is a small subtlety, because of which I killed a whole day in search of problems and even rewrote the timer controller on the FPGA a couple of times.  Therefore, I urge everyone to read the datasheets more attentively.  :) <br>  To record the date and time in the microcircuit, you must first "allow recording".  See in the table at addresses <b>0x8F</b> and <b>0x8E</b> bit <b>WP</b> (write protect)?  By default, the bit is at 0, which means a ban on any write operations.  Therefore, to write the date and time to the microcircuit, you must first transfer WP to the state of logical one.  This is done by sending two bytes one after another (command and data): <b>0x8E 0x80</b> .  After that, the timer will become obedient and allow you to write information to yourself. <br><br>  Also note the 7 bits in the seconds register - <b>CH</b> (clock halt).  The timer stops if this bit is in high state.  Therefore, when you first write to the register of seconds, you need to reset the most significant bit. <br><br><h3>  LCD </h3><br>  LCD1602 is a normal LCD display that allows you to display two lines of 16 characters each, using a parallel exchange interface.  The interface is primitive and simple. <br><ul><li>  <b>DB [7: 0]</b> - parallel command / data bus. </li><li>  <b>RS</b> - register select, select signal: '0' - commands, '1' - data. </li><li>  <b>R / W</b> - data transfer direction ('0' - write / '1' - read). </li><li>  <b>E</b> - enable, synchronization, set to a logical unit at the moment of transmission through the DB line </li></ul><br><br><img src="https://habrastorage.org/files/2e1/e63/147/2e1e63147f464bfbaa332ff0806a8897.png"><br><br>  I used the display in recording mode, that is, the port R / W = 0 always.  In connection, data exchange is somewhat simplified, as is the controller itself implemented on the FPGA. <br><br>  <b>How to work with the display?</b> <br>  Before each first display, it is necessary to initialize it with a set of commands that are given in the datasheet. <br>  For my implementation of the display controller, this was a set of four commands that were executed sequentially one after another each time the firmware was started.  Several initialization bytes must be <b>sent</b> to the <b>DB</b> line: <br>  <b>0x00</b> (or 0x01) - clears the display. <br>  <b>0x38</b> - sets the number of lines and font size (I need 2 lines of 16 characters <b>each</b> with the maximum size of characters). <br>  <b>0x0C</b> - sets the cursor to the on / off position.  ("Incl." In my case). <br>  <b>0x06</b> - sets the direction of the cursor movement and the shift on the display (to the right, ie the increment of the shift counter). <br>  In this case, the signals <b>RS</b> and <b>R / W</b> must be in a state of logical zero. <br><br>  After the initialization process, commands and data are transmitted through the DB line in turn.  The command determines the position of the character on the display, the data determines the character from the table below. <br><img src="https://habrastorage.org/files/b08/bd8/ee7/b08bd8ee7e524f18b8fee459e9ecb828.png"><br>  For example, to write the character " <b>Q</b> " you need to write the number 0x51 along the DB line.  Thus, the entire transfer of data on the display is reduced to the choice of position and character. <br><br><h3>  FPGA Project </h3><br>  Let us turn to the implementation of the project on the FPGA.  The programming language used in the project is VHDL.  Differs from the rest of its simplicity and at the same time cumbersome structures. <br>  In order for the clock to start ticking, and the display to display the date and time you need to do several actions that, in principle, are made for each project on the FPGA.  Required: <br><ul><li>  two independent controllers - for DS1302 and for LCD1602. </li><li>  two test bundles - to set the start time and to initialize the display. </li><li>  top level file linking it all together. </li><li>  FPGA pinout file (UCF file). </li></ul><br>  <b>UCF</b> <br>  Let's start with the simple.  Determine the pins that will be used in the project. <br><pre><code class="html hljs xml">## CLK 50 MHz NET "CLK" LOC = "P183" | IOSTANDARD = LVCMOS33 ; ## Switches NET "RESET" LOC = "P148" | IOSTANDARD = LVTTL | PULLUP ; ## SW<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">0</span></span></span><span class="hljs-tag">&gt;</span></span> NET "START" LOC = "P130" | IOSTANDARD = LVTTL | PULLUP ; ## SW<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">3</span></span></span><span class="hljs-tag">&gt;</span></span> NET "RESTART" LOC = "P124" | IOSTANDARD = LVTTL | PULLUP ; ## SW<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">4</span></span></span><span class="hljs-tag">&gt;</span></span> NET "TEST_LCD" LOC = "P118" | IOSTANDARD = LVTTL | PULLUP ; ## SW<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">5</span></span></span><span class="hljs-tag">&gt;</span></span> ## LCD ports NET "LCD_RS" LOC = "P77" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_RW" LOC = "P68" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_EN" LOC = "P65" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">0</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P49" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">1</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P48" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">2</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P40" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">3</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P50" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">4</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P62" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">5</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P98" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">6</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P64" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; NET "LCD_DT<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">7</span></span></span><span class="hljs-tag">&gt;</span></span>" LOC = "P63" | IOSTANDARD = LVTTL | DRIVE = 8 | SLEW = FAST ; # SERIAL PORTS VIA HEADEX NET "T_CE" LOC = "P147" | IOSTANDARD = LVTTL | SLEW = SLOW | DRIVE = 8 ; NET "T_CK" LOC = "P146" | IOSTANDARD = LVTTL | SLEW = SLOW | DRIVE = 8 ; NET "T_DT" LOC = "P145" | IOSTANDARD = LVTTL | SLEW = SLOW | DRIVE = 8 ;</code> </pre> <br>  In the UCF file, the port name used in the top-level file, the pin to which it is connected, as well as other parameters (electrical type, current level, driver speed, pull-up, etc.) are specified.  Signals for connecting to the timer and LCD display were described above, therefore I will give a description of the missing ports connected to the switches. <br><ul><li>  <b>RESET</b> - '0' - global reset FPGA. </li><li>  <b>START</b> - '1' - start for LCD display (starts initialization and data transfer process). </li><li>  <b>RESTART</b> - '0' - restart the timer (translates the date and time to the state defined in the FPGA memory). </li><li>  <b>TEST_LCD</b> - port for test purposes, '0' - displays data from the timer, '1' displays a static message (‚Äúhello habr '). </li></ul><br>  The second pitfall I encountered is that the devikit developers forgot to connect the timer chip to the FPGA.  But, fortunately, they brought the serial interface to the pins, which I connected with other pins, connected by conductors, directly to the FPGA. <br><br>  <b>Hdl</b> <br>  Next is written timer controller and display controller.  There is no point in presenting the full text on VHDL here, but I‚Äôll tell you about the principles of data exchange.  During the initial start-up (when all control signals are set and reset), the LCD display is initialized, and the date and time constants defined in the top-level file are written to the timer.  Below is the code of the function to convert data from binary to binary decimal format: <br><pre> <code class="vhdl hljs"><span class="hljs-comment"><span class="hljs-comment">---------------- INTEGER TO STD_LOGIC_VECTOR TO BCD CONVERTER ---------------- constant n : integer:=8; constant q : integer:=2; function to_bcd ( bin : std_logic_vector((n-1) downto 0) ) return std_logic_vector is variable i : integer:=0; variable j : integer:=1; variable bcd : std_logic_vector(((4*q)-1) downto 0) := (others =&gt; '0'); variable bint : std_logic_vector((n-1) downto 0) := bin; begin for i in 0 to n-1 loop -- repeating 8 times. bcd(((4*q)-1) downto 1) := bcd(((4*q)-2) downto 0); --shifting the bits. bcd(0) := bint(n-1); bint((n-1) downto 1) := bint((n-2) downto 0); bint(0) :='0'; l1: for j in 1 to q loop if(i &lt; n-1 and bcd(((4*j)-1) downto ((4*j)-4)) &gt; "0100") then --add 3 if BCD digit is greater than 4. bcd(((4*j)-1) downto ((4*j)-4)) := bcd(((4*j)-1) downto ((4*j)-4)) + "0011"; end if; end loop l1; end loop; return bcd; end to_bcd;</span></span></code> </pre><br>  The following figure shows the timing diagrams obtained during the debugging of the timer controller.  Bold lines are allocated to the serial transfer interface.  Three data_i, data_o, data_t lines are connected to the IOBUF I / O port in the top-level file. <br><img src="https://habrastorage.org/files/06c/168/184/06c1681849e546b0bfb5fb1c1e071c32.png"><br><br>  Inside the FPGA in an infinite loop begins to poll the timer registers responsible for setting the time (0x80-0x8D).  Registers are polled in a circle, starting with the years and ending with seconds.  After each reading from the timer, the data is entered into the registers of the FPGA bearing the typical names (second, minute, etc.).  After receiving the resolution signal from the LCD controller, the data from the timer controller is transmitted to the control node for the display controller.  Depending on the type of the timer register and its value, the data is converted into the format required for the display and set the desired position on the display by setting the appropriate address.  The LCD controller receives the data from the timer and writes it to a dual-port 8x32 RAM-memory in the FPGA, performed on the distributed logic of the crystal (cell SLICEM).  Then the controller reads all the information from the memory and thereby updates the characters on the LCD display.  The whole project operates at a relatively high frequency of 50 MHz, so it‚Äôs unrealistic to see any delays when counting seconds with an eye. <br><br>  The following figure shows the placement of the project in the FPGA chip. <br><img src="https://habrastorage.org/files/0eb/edd/404/0ebedd40444d425780cfc2c52d6ff6e3.png"><br><br>  Green lines indicate connections of input / output ports to internal FPGA resources, the Blue area is the area of ‚Äã‚Äãlogic gates, the red rectangles are a bunch of built-in multipliers 18x18 and RAMB16K block memory, the orange squares are digital clocks manager DCM synthesis blocks.  The rectangles are highlighted in purple - ‚Äûp-block‚Äú, within the boundaries of which one or another component of the project is bred with the option ‚ÄúKeep Hierarchy‚Äù enabled.  White highlighted areas are cells of controllers and test modules.  The remaining p-blocks were left from <a href="http://geektimes.ru/post/254928/">my old project on the FPGA</a> , I decided not to delete them (what if someone wants to play a sapper?). <br><br><h3>  Result: </h3><br>  So, in the course of the work, the FPGA firmware was created to connect the timer with the LCD display. <br>  With the help of <b>Aldec Active-HDL</b> CAD, a temporary modeling of the project was carried out, as well as all the writing of code and models.  In the <b>Xilinx ISE Design Suite</b> environment, the project was synthesized and traced on the FPGA Spartan3E.  Also used aids: <b>PlanAhead</b> - used for pinout, the location of the project nodes in the crystal and tracing.  <b>ChipScope Pro</b> - is used for debugging in real hardware by loading special debug kernels into FPGA. <br><img src="https://habrastorage.org/files/abc/21f/d4b/abc21fd4bae149a18d68cc0bd8ce4426.jpg"><br><br>  <b>Automatic project documentation</b> <br>  It so happened that during the creation of this project, we had at work proposed another attempt at introducing the source code documentation.  One solution was to use the <b>Doxygen</b> automated documentation tool.  I really like how hierarchy graphs are built in this application.  For HDL projects this is a very important point.  On Habr√© <a href="http://habrahabr.ru/post/252101/">there are</a> several <a href="http://habrahabr.ru/post/252443/">articles</a> on this <a href="http://habrahabr.ru/post/253223/">tool</a> .  In conjunction with the <b>HTML Help Workshop</b> , Doxygen allows you to generate only one documentation file in <b>CHM</b> format. <br><br>  Unfortunately, the attempt to implement failed, but the experience with the tool remained.  Therefore, for the project of ‚Äústupid‚Äù clocks on FPGA, I decided to use automatic documentation.  On the githaba in the project folder is the configuration file for <b>DoxyWizard</b> and the result of its work.  Here is one page of what happened in the documentation process. <br><img src="https://habrastorage.org/files/303/263/692/303263692d8c4efcad908499410e4785.png"><br><br><div class="spoiler">  <b class="spoiler_title">Still different pictures ...</b> <div class="spoiler_text">  <b>Schematic view of the project:</b> <br><img src="https://habrastorage.org/files/dca/0f1/eb7/dca0f1eb7caa4f4ea1984955c88fea2a.png"><br><br>  <b>ChipScope debug process:</b> <br><img src="https://habrastorage.org/files/cdd/77a/b4a/cdd77ab4ac2e4d6794b71010ae825b90.png"><br></div></div><br>  <b>The source code on github</b> is <a href="https://github.com/capitanov/Stupid_watch">LCD Timer on FPGA</a> . <br><br>  <b>Video demonstration of the project performance:</b> <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/e-I3Ej0h0AY%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgJ6fHKF5wtWyIU1Z6Fc_5FILe6wA" frameborder="0" allowfullscreen=""></iframe><br>  Do not be surprised by the date displayed on the display.  The material was filmed and prepared a long time ago, and only now came to the article.  Lazy to retake ... :) <br><br>  <b>Related projects:</b> <br><ul><li>  The project is based on the <a href="http://www.avislab.com/blog/ds1302/">AVR microcontroller</a> . </li><li>  <a href="http://kazus.ru/shemes/showpage/0/1206/1.html">Arduino</a> based <a href="http://kazus.ru/shemes/showpage/0/1206/1.html">project</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/274843/">https://habr.com/ru/post/274843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274833/index.html">Create a hardware random number generator</a></li>
<li><a href="../274835/index.html">Create a hardware keyboard logger</a></li>
<li><a href="../274837/index.html">Installing Quartus II Web Edition for Linux</a></li>
<li><a href="../274839/index.html">MIPSfpga: outside of canon</a></li>
<li><a href="../274841/index.html">Minesweeper on FPGA</a></li>
<li><a href="../274847/index.html">Digital filtering on FPGA - Part 2</a></li>
<li><a href="../274849/index.html">How we started production, or my software development experience for a Siemens Simatic PLC</a></li>
<li><a href="../274851/index.html">Mikhail Romanovich Shura-Bura - the patriarch of domestic programming and its development</a></li>
<li><a href="../274853/index.html">Community DevCamp reports are available.</a></li>
<li><a href="../274855/index.html">Dangerous video: how I found a vulnerability in video hosting and did not die after 7 days</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>