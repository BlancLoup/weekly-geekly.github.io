<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As a result, I wrote a new RTOS, tested and stable</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have been working with embedded systems for several years: our company develops and manufactures on-board computers for cars, chargers, etc. 



 Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As a result, I wrote a new RTOS, tested and stable</h1><div class="post__text post__text-html js-mediator-article">  I have been working with embedded systems for several years: our company develops and manufactures on-board computers for cars, chargers, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21d/c9f/576/21dc9f576eaccd236cad0fad21f5cdbb.jpg" alt="image"></div><br><br>  The processors used in our products are mainly 16- and 32-bit Microchip microcontrollers with 8 to 32 kB RAM, and 128 to 512 kB RAM, without MMU.  Sometimes, for the most simple devices, even more modest 8-bit chips are used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Obviously, we have no (reasonable) chance of using the Linux kernel.  So we need some RTOS (Real-Time Operating System).  There are even people who do not use any OS in microcontrollers, but I do not consider this a good practice: if the iron allows me to use the OS, I use it. <br><br>  A few years ago, when we were switching from 8-bit to the more powerful 16-bit microcontrollers, my colleagues, who were much more experienced than I, recommended the preemptive RTOS <a href="http://tnkernel.com/">TNKernel</a> .  So this is the OS that I used in different projects for a couple of years. <br><br>  Not that I was very pleased with it: for example, there are no timers in it.  And it does not allow the thread to wait for messages from several queues at once.  And there is no software control over stack overflow (this really strained).  But she worked, so I continued to use it. <br><a name="habracut"></a><br><h1>  How does the forcing OS work </h1><br>  Just to make sure that we understand each other, I will make a brief overview of how the preemptive OS works in principle.  I apologize if the things I present here are too trivial for the reader. <br><br><h2>  Run multiple threads </h2><br>  Microcontrollers are "single-threaded": they can execute only one instruction at a time (of course, there are multi-core processors, but now this is not about that).  To run multiple threads on a single core processor, we need to switch between threads, so the user feels that they are running in parallel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/655/3a6/c2e6553a6d05d801375f45a34019f6ef.png" alt="image"></div><br><br>  This is what the OS is all about in the first place: it switches control between threads.  How exactly does she do it? <br><br>  The microcontroller has a set of registers.  Since  microcontrollers are single-threaded, this set of registers belongs to only one thread.  For example, when we find the sum of two numbers: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- assume we have two ints: a and b int c = a + b;</span></span></code> </pre> <br>  In fact, something like the following is happening (of course, the specific sequence of actions depends on the architecture, but in general the idea remains the same): <br><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta"># the MIPS disassembly: LW V0, -32744(GP) #    a </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> RAM   V0 LW V1, -32740(GP) #    b </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> RAM   V1 ADDU V0, V1, V0 #   V1  V0 ,    V0 SW V0, -32496(GP) #    V0  RAM (</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   c)</span></span></code> </pre><br>  There are 4 actions.  Since  in a preemptive OS, one thread can <i>force out</i> another thread at any time, then, of course, this can happen in the middle of this sequence.  Imagine that another thread pushes the current one after the values ‚Äã‚Äãfor summation have been loaded into the V0 and V1 registers.  The new thread has its own business and, therefore, it uses these registers as it needs.  Of course, the two streams should not interfere with each other, so that when the first thread gets control again, the values ‚Äã‚Äãof the V0 and V1 registers (and others) should be as they were before crowding out. <br><br>  So, when we switch from flow A to flow B, first of all we have to save the values ‚Äã‚Äãof all the registers of flow A, then restore the values ‚Äã‚Äãof all the registers of flow B. And only then the flow B gets control, and continues to work. <br><br>  So a more accurate flow switching diagram will look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/4cb/b6c/2d44cbb6c1a8d8687e1cf020ad143f99.png" alt="image"></div><br><br>  When you need to switch from one thread to another, the kernel receives control, performs the necessary service actions (at least, saves and restores the values ‚Äã‚Äãof the registers), and then control is transferred to the next thread. <br><br>  Where exactly are the values ‚Äã‚Äãof the registers for each thread?  Very often, this is a thread stack. <br><br><h2>  Flow stack </h2><br>  In modern operating systems, the (user) stack grows dynamically thanks to the MMU: the more the thread needs, the more it gets (if the kernel allows it).  But the microcontrollers I work with do not have this luxury: all RAM is statically mapped to the address space.  So each thread gets its some RAM, which is used under the stack;  and if the thread uses more stack than it was allocated, then this leads to memory corruption and, therefore, to incorrect operation.  In fact, the stack space for each thread is just an array of bytes. <br><br>  When we decide how much stack each particular thread needs, first we just figure out how much it may need it, and take it with some margin.  For example, if it is a deeply nested GUI stream, it may require several kilobytes, but if it is a small stream that processes user input, then a few hundred bytes may suffice. <br><br>  Let's assume that we have three threads, and their stack consumption is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37d/7ff/09d/37d7ff09d955d4f3df0ca2e8a5bcff01.png" alt="image"></div><br><br>  As I have already indicated, the set of register values ‚Äã‚Äãfor each thread is saved to the stack of that thread.  This set of register values ‚Äã‚Äãis called <i>a</i> thread <i>context</i> .  The following diagram reflects this (the active stream is indicated by an asterisk): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b0/320/4bd/6b03204bd74e4a2ecce393603db73fd4.png" alt="image"></div><br><br>  Notice that the active thread (thread A) has no context saved to the stack.  The stack pointer in the microcontroller points to the top of user data stream A, and the entire set of registers of the microcontroller belongs to stream A (in fact, there may be special registers that are not related to the stream, but this does not interest us now). <br><br>  When the kernel decides to switch control from thread A to thread B, it does the following: <br><br><ul><li>  Saves the values ‚Äã‚Äãof all registers to the stack (that is, to the stack of thread A); </li><li>  Switches the stack pointer to the top of the thread B stack; </li><li>  Restores the values ‚Äã‚Äãof all registers from the stack (that is, from the stack of thread B). </li></ul><br>  After that, we have the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1e/286/df1/a1e286df1c9a6d99a4ac11898f79de8c.png" alt="image"></div><br><br>  And stream B continues to go about its business. <br><br><h2>  Interruptions </h2><br>  We have not yet touched on a very important topic: interruptions. <br><br>  An interrupt is when a thread currently executing stops (most often, due to an external event), the processor switches to something else for a while (to interrupt processing), and then returns to the interrupted thread.  An interrupt can be generated at any time, and we need to be ready for this. <br><br>  Microcontrollers used for embedded systems usually have quite a lot of peripherals: timers, transceivers (UART, SPI, CAN, etc.), ADCs, etc.  This periphery can generate interrupts when a certain event occurs: for example, the UART periphery can generate an interrupt when a new byte is received, so the program can save it somewhere.  Timers generate an overflow interrupt, so the program can use this for some periodic tasks, etc. <br><br>  The interrupt handler is called ISR (Interrupt Service Routine). <br><br>  Interrupts can have different priorities: for example, when a low priority interrupt is generated, the thread being executed is suspended, and the ISR gets control.  Now, if a high-priority interrupt is generated, then the current ISR, again, is suspended, and the ISR of the new interrupt gets control.  Obviously, when it completes, the first ISR continues its work, and when it completes, then, as a result, control is transferred back to the interrupted flow. <br><br>  There are short periods of time when interrupts are not allowed: for example, if we process some data that may change in the ISR.  If we process this data in several steps, the interruption can occur in the middle of processing and change the data.  As a result, the stream will process non-integral data, which leads to incorrect operation of the program. <br><br>  These short periods of time are called ‚Äúcritical sections‚Äù: when we enter a critical section, we prohibit interrupts, and when we exit it, we allow interrupts back.  That is, if some interrupt is generated inside the critical section, then the ISR will be called only at the moment of exiting it (when the interrupts are enabled). <br><br>  Very interesting question: where to save the ISR stack? <br><br><h2>  Interrupt stack </h2><br>  In general, we have two options: <br><br><ul><li>  Use the stack of the thread that was interrupted; </li><li>  Use a separate stack for interrupts. </li></ul><br>  If we use the stack of the interrupted thread, it looks like this (in the diagram below, flow B is interrupted): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/4c5/742/ca94c5742bb4707a2f75a9c3515db7a3.png" alt="image"></div><br><br>  When the interrupt is generated: <br><br><ul><li>  The context of the current thread is saved to the thread stack (so that when the ISR is completed, we can immediately switch to another thread); </li><li>  ISR does its work (handles interruption); </li><li>  If you need to switch to another thread, switch (at least, modify the stack pointer); </li><li>  The thread context is restored from the stack; </li><li>  The flow continues its work. </li></ul><br>  This can work quite quickly, but in the context of embedded systems, where our resources are very limited, this approach has a significant drawback.  Guess exactly how? <br><br>  Remember that an interrupt can occur at any time, so obviously we cannot know in advance which thread will be active when the interrupt happens.  So, when we estimate the stack size for each thread, we must assume that all existing interrupts can occur in this thread, given their worst nesting.  This can significantly increase the size of stacks for all streams: 1 KB is easy, and maybe more (it depends on the application, of course).  For example, if in our application there are 7 threads, then the required RAM size for interrupts is 1 * 7 = 7 KB.  If our microcontroller has only 32 kb of RAM (and this is already a rich microcontroller), then 7 kb is 20%!  <b>Oh shi ~.</b> <br><br>  In total, the stack of each thread should contain the following: <br><br><ul><li>  Own data flow; </li><li>  Flow context (values ‚Äã‚Äãof all registers); </li><li>  The data of all ISRs with the worst nesting. </li></ul><br>  Ok, move to the next option when we use a separate stack for interrupts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/491/add/a06/491adda06e53d8a07f505de7dc2e37bf.png" alt="image"></div><br><br>  Now, 1 kB for the ISR from the previous example should be allocated only once.  I think this is a much more competent approach: in embedded systems, RAM is a very expensive resource. <br><br>  After such a superficial overview of the principles of RTOS, go on. <br><br><h1>  TNKernel </h1><br>  As I indicated at the beginning of the article, we used TNKernel for our development on 16-bit and 32-bit microcontrollers. <br><br>  Unfortunately, the author of the <a href="http://tnkernel.com/tn_port_pic24_dsPIC_PIC32.html">port of TNKernel for PIC32</a> , Alex Borisov, used the approach when interrupts use the stack of the interrupted thread.  It wastes a lot of RAM in vain and does not make me very happy, but otherwise TNKernel looked good: it is compact and fast, so I continued to use it.  Until the day of X, when I was very surprised to learn that in fact everything is much worse. <br><br><h2>  Fail TNKernel under PIC32 </h2><br>  I was working on another project: a device analyzing an analog signal from a car plug and allowing the user to see some parameters of this signal: duration, amplitude, etc.  Since the signal changes rapidly, we need to measure it often enough: once every 1 or 2 microseconds. <br><br>  For this task, the Microchip PIC32 processor (with the MIPS core) was chosen. <br><br>  The task should not be very difficult, but one day I had problems: sometimes, when the device started measuring, the program fell in a completely unexpected place.  ‚ÄúIt must be the case of a tainted memory,‚Äù I thought, and I was very upset because  the process of finding errors related to memory corruption can be long and completely non-trivial: as I said, there is no MMU, and all RAM is available to all threads in the system, so if one of the threads gets out of control and corrupts the memory of another thread , the problem can manifest itself very far from the actual place with an error. <br><br>  I have already said that TNKernel does not have software control over stack overflow, so when there is a suspicion of memory corruption, first of all it is worth checking whether the stack of any thread is full.  When a thread is created, its stack is initialized to a specific value (in TNKernel under PIC32, it‚Äôs just <code>0xffffffff</code> ), so we can easily see if the end of the stack is dirty.  I checked, and indeed, the idle thread stack is clearly full: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/960/56c/34596056cfd04fc5e177bccb9bb0ef86.png" alt="image"></div><br><br>  On MIPS, the stack grows down, so <code>task_idle_stack[0]</code> is the last available word in the idle thread stack. <br><br>  Well, this is already something.  But the fact is that the stack for this stream was allocated with a large margin: when the device works normally, only about 300 bytes from 880 are used!  There must be some wild mistake that so hard overflows the stack. <br><br>  Then I began to study memory more carefully, and it became clear that the stack was filled with repeating patterns.  See: sequence <code>0xFFFFFFFF, 0xFFFFFFFA, 0xA0006280, 0xA0005454</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/550/14d/5db/55014d5db0902874e8e2ac63febf936f.png" alt="image"></div><br><br>  And the same sequence again: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c41/e8b/919/c41e8b9195e370308e11055e7057176e.png" alt="image"></div><br><br>  Addresses <code>0xA000051C</code> and <code>0xA00005A4</code> .  The difference is 136 bytes.  We divide by 4 (word size), these are 34 words. <br><br>  Hmm, 34 words ... This is just the size of the context in MIPS!  And the same pattern repeats over and over again.  So it seems that the context has been saved several times in a row.  But ... How can this be ?! <br><br>  Unfortunately, it took me a long time to figure everything out.  First of all, I tried to examine the saved context in more detail: among other things, there should be an address in the program memory, where the interrupted thread should resume work later.  On the PIC32, the program memory is mapped to a region from <code>0x9D000000</code> to <code>0x9D007FFF</code> , so these addresses are easily distinguishable from the rest of the data.  I took these addresses from a saved context: one of them was <code>0x9D012C28</code> .  We look into the disassembler: <br><br><pre> <code class="hljs objectivec"><span class="hljs-number"><span class="hljs-number">9</span></span>D012C04 AD090000 SW T1, <span class="hljs-number"><span class="hljs-number">0</span></span>(T0) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C08 <span class="hljs-number"><span class="hljs-number">8</span></span>FA80008 LW T0, <span class="hljs-number"><span class="hljs-number">8</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C0C <span class="hljs-number"><span class="hljs-number">8</span></span>FA9000C LW T1, <span class="hljs-number"><span class="hljs-number">12</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C10 <span class="hljs-number"><span class="hljs-number">01000013</span></span> <span class="hljs-built_in"><span class="hljs-built_in">MTLO</span></span> T0, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>D012C14 <span class="hljs-number"><span class="hljs-number">01200011</span></span> MTHI T1, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>D012C18 <span class="hljs-number"><span class="hljs-number">8</span></span>FA10010 LW AT, <span class="hljs-number"><span class="hljs-number">16</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C1C <span class="hljs-number"><span class="hljs-number">8</span></span>FA20014 LW V0, <span class="hljs-number"><span class="hljs-number">20</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C20 <span class="hljs-number"><span class="hljs-number">8</span></span>FA30018 LW V1, <span class="hljs-number"><span class="hljs-number">24</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C24 <span class="hljs-number"><span class="hljs-number">8</span></span>FA4001C LW A0, <span class="hljs-number"><span class="hljs-number">28</span></span>(SP) <span class="hljs-number"><span class="hljs-number">9</span></span>D012C28 <span class="hljs-number"><span class="hljs-number">8</span></span>FA50020 LW A1, <span class="hljs-number"><span class="hljs-number">32</span></span>(SP) <span class="hljs-meta"><span class="hljs-meta"># </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;-   9D012C2C 8FA60024 LW A2, 36(SP) 9D012C30 8FA70028 LW A3, 40(SP) 9D012C34 8FA8002C LW T0, 44(SP) 9D012C38 8FA90030 LW T1, 48(SP) 9D012C3C 8FAA0034 LW T2, 52(SP) 9D012C40 8FAB0038 LW T3, 56(SP) 9D012C44 8FAC003C LW T4, 60(SP) 9D012C48 8FAD0040 LW T5, 64(SP) 9D012C4C 8FAE0044 LW T6, 68(SP) 9D012C50 8FAF0048 LW T7, 72(SP) 9D012C54 8FB0004C LW S0, 76(SP) 9D012C58 8FB10050 LW S1, 80(SP) 9D012C5C 8FB20054 LW S2, 84(SP) 9D012C60 8FB30058 LW S3, 88(SP) 9D012C64 8FB4005C LW S4, 92(SP) 9D012C68 8FB50060 LW S5, 96(SP) 9D012C6C 8FB60064 LW S6, 100(SP) 9D012C70 8FB70068 LW S7, 104(SP) 9D012C74 8FB8006C LW T8, 108(SP) 9D012C78 8FB90070 LW T9, 112(SP) 9D012C7C 8FBA0074 LW K0, 116(SP) 9D012C80 8FBB0078 LW K1, 120(SP) 9D012C84 8FBC007C LW GP, 124(SP) 9D012C88 8FBE0080 LW S8, 128(SP) 9D012C8C 8FBF0084 LW RA, 132(SP) 9D012C90 41606000 DI ZERO 9D012C94 000000C0 EHB 9D012C98 8FBA0000 LW K0, 0(SP) 9D012C9C 8FBB0004 LW K1, 4(SP) 9D012CA0 409B7000 MTC0 K1, EPC</span></span></span></span></code> </pre><br>  This characteristic sequence from LW (Load Word) from addresses relative to SP (Stack Pointer) is a context recovery procedure.  Now it is clear that the thread was preempted when the context was restored from the stack.  Well, this can happen because of an interruption, but why so many times in a row?  I don't even have so many interrupts in the system. <br><br>  Before that, I just used TNKernel without a clear understanding of how it works, because it just worked.  So I was even somewhat scared to go deep into the core.  But this time, I had to. <br><br><h2>  Context switch in TNKernel under PIC32 </h2><br>  We have already discussed the context switching process in general, but for now, let's refresh this topic and add some details of a specific implementation (TNKernel). <br><br>  When the kernel decides to switch the context from thread A to thread B, it does the following: <br><br><ul><li>  Saves the values ‚Äã‚Äãof all registers to the stack (that is, to the stack of thread A); </li><li>  <i>Disable interrupts</i> ; </li><li>  Switches the stack pointer to the top of the thread B stack; </li><li>  Toggles pointer to active stream descriptor (to stream B descriptor) </li><li>  <i>Enable interrupts</i> ; </li><li>  Restores the values ‚Äã‚Äãof all registers from the stack (that is, from the stack of thread B). </li></ul><br>  As you can see, there is a short critical section, while the kernel operates with pointers to the thread descriptor and to the top of the stack: otherwise a situation may occur when an interrupt is generated between these actions, and the non-integrity of the data, of course, leads to incorrect operation. <br><br><h2>  Interrupts in TNKernel under PIC32 </h2><br>  In TNKernel, under PIC32, there are two types of interrupts: <br><br><ul><li>  System interrupts: they can cause kernel services, which can lead to context switching immediately after the execution of an ISR.  When such an interrupt is called, the kernel saves full context to the stack of the current thread. </li><li>  User interrupts: they cannot call kernel services.  The kernel takes no action when this interrupt is generated. </li></ul><br>  Now we are only interested in system interrupts.  And TNKernel has a restriction for this type of interrupt: all System Interrupts in the application must have the same priority, so these interrupts cannot be nested. <br><br>  As a small reminder, this is what happens when an interrupt is generated: <br><br><ul><li>  The context of the current thread is saved to the thread stack; </li><li>  ISR gets control. </li></ul><br>  Now the ISR is active, and using the stack looks like this: <br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/thread_stacks_with_interrupt.png" alt="image"></div><br><br>  As already mentioned, this approach significantly increases the required stack size for threads: each thread must be large enough to accommodate the following: <br><br><ul><li>  Own data flow; </li><li>  Flow context (values ‚Äã‚Äãof all registers); </li><li>  The data of all ISRs with the worst nesting. </li></ul><br>  The need to multiply the ISR stack by the number of threads is not the most pleasant thing, but, generally speaking, with this I was ready to live. <br><br><h2>  Interrupt at the time of context switching </h2><br>  And what happens if the interrupt is generated during the context switch process, i.e.  while the context of the current thread is saved to the stack or restored from the stack? <br><br>  I think you guessed it:  interrupts are not prohibited in the process of saving / restoring the context, the context will be saved <b>twice</b> .  Here is: <br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/thread_stacks_with_interrupt_double_context.png" alt="image"></div><br><br>  So, when the kernel decides to switch from thread B to thread A, this is what happens: <br><br><ul><li>  The context is saved to thread stack B; </li><li>  In the middle of this process, an interrupt occurs; </li><li>  In thread stack B, space is allocated for another context, and the context is stored there. </li><li>  ISR gets control, does its work and ends </li><li>  When the ISR is complete, the kernel looks to which thread the control should be transferred (this is flow A: remember, we wanted to switch to thread And before the interruption occurred) </li><li>  We prohibit interruptions </li><li>  Switch the stack pointer and the pointer to the current thread handle </li><li>  Allow interrupts </li><li>  Context is restored from the stack (i.e., from the top of task A stack) </li></ul><br>  We get the following picture: <br><br><div style="text-align:center;"><img src="http://1450830772608537573327" alt="image"></div><br><br>  See: the context is saved twice in the stack of thread B. In fact, this is not a disaster if the stack is not full, since  this double-saved context will be restored twice as soon as thread B has control.  For example, suppose that thread A goes into waiting for something, and the kernel switches control back to thread B: <br><br><ul><li>  The context is saved to thread stack A; </li><li>  We prohibit interrupts, switch the stack pointer, etc., enable interrupts; </li><li>  The context is restored from the stack of thread B. </li></ul><br>  Now we, in fact, have returned at that moment when the context was saved to thread stack B before switching to thread A. So we just continue to keep the context: <br><br><ul><li>  We finish saving the context to the stack of thread B; </li><li>  We take the stream that needs to be activated (in fact, it is already activated: stream B); </li><li>  Restoring context back. </li></ul><br>  After that, the flow continues to work, as if nothing had happened: <br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/thread_stacks_with_context_b.png" alt="image"></div><br><br>  As you can see, in fact, nothing broke, but we have to draw an important conclusion from this study: our assumption that it should accommodate the context of each stream was <b>wrong</b> .  At a minimum, it should contain two contexts, not one. <br><br>  As you remember, all system interrupts in TNKernel must have the same priority, so that they cannot be nested: this means that the context cannot be saved more than twice. <br><br>  If so, then the final conclusion: the stack of each thread should contain the following: <br><br><ul><li>  Own data flow; </li><li>  Flow context (values ‚Äã‚Äãof all registers); </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second context</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in case the interruption occurs at the moment the context is saved;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The data of all ISRs with the worst nesting. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh ... another 136 bytes for each stream. </font><font style="vertical-align: inherit;">Again, multiply by the number of threads: for 7 threads, this is almost 1 kilobyte: another 3% from 32 KB.</font></font><br><br>  OK.  Good.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">probably</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , would agree on this situation, but our final conclusion, in fact, it is not final. </font><font style="vertical-align: inherit;">All the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> worse.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Digging deeper </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's examine the process of saving dual context more deeply: even after our recent research, we still cannot explain how it happened that the context was saved on the thread stack many times: when the interrupt is generated, the current interrupt level of the processor is increased (to the priority of the generated interrupt) ), and if another system interrupt occurs, it will be processed after the current ISR returns control. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take another look at this diagram: the ISR has already returned control, and we switched to stream A:</font></font><br><br><div style="text-align:center;"><img src="http://1450830772608537573327" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this moment, the interrupt level of the processor is again lowered, and the context is saved to thread stack B </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twice</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guess what's next? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's right: when we switch back to thread B, and while its context is restored, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interrupt </font><font style="vertical-align: inherit;">can occur </font><font style="vertical-align: inherit;">. Consider:</font></font><br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/thread_stacks_with_interrupt_triple_context.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, the context has already been saved to the thread stack three times. </font><font style="vertical-align: inherit;">And what's worse, it can even be the same interrupt: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the same interrupt can save the context to the thread's stack several times</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, if you are so unlucky that an interrupt will be generated periodically, and with the same frequency with which threads will switch back and forth, then the context will be stored in the thread stack over and over again, which ultimately leads to stack overflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This was clearly not taken into account by the author of the TNKernel port under PIC32. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is exactly what happened with my device, which measured the analog signal: the ADC interrupt was generated with exactly this ‚Äúsuccessful‚Äù frequency. </font><font style="vertical-align: inherit;">This is what happened:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The periphery of the ADC completes the next measurement, and generates an interrupt; </font></font></li><li>  ISR ,   ,       ,   -    ; </li><li>  ISR ,       (..   ,    ); </li><li>            ; </li><li>      ,    -  .     ,     . </li><li>    2. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this is my cant that ADC interrupts are generated so often, but the behavior of the system is completely unacceptable. Correct behavior: my threads stop receiving control (because there is no time) until such frequent interrupt generation is stopped. The stack should not be filled with a bunch of saved contexts, and when interrupts are no longer generated so often, the system quietly continues its work.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And one more consequence: even if we don‚Äôt have such periodic interruptions, there‚Äôs still a non-zero probability that the different interruptions that exist in the application will occur at such unsuccessful moments that the context will be saved again and again. Embedded systems are often designed for continuous operation over a long period of time (months and years): for example, car alarms, on-board computers, etc. And if the operating time of the device will tend to infinity, then the probability of such a development of events will tend to unity. Sooner or later, it happens. Of course, this is unacceptable, so it is impossible to leave the current state of affairs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good: at least now I know the cause of the problems. Next question: how to eliminate this cause?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the fastest and dirtiest hack is to simply disable interrupts for the duration of the save / restore context. </font><font style="vertical-align: inherit;">Yes, this will eliminate the problem, but this is a very, very bad decision: the critical sections should be as short as possible, and prohibiting interruptions for such long periods of time is hardly a good idea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A much better solution is to use a separate stack for interrupts.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We are trying to improve TNKernel </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is </font></font><a href="https://github.com/andersm/TNKernel-PIC32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another TNKernel port under PIC32</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Anders Montonen, and it uses a separate stack for interrupts. </font><font style="vertical-align: inherit;">But this port does not have some convenient buns that are present in the port of Alex Borisov: convenient Sishny macros for announcing system interrupts, services for working with system ticks, and others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So I decided to fork it and implement what I need. </font><font style="vertical-align: inherit;">Of course, in order to make such changes in the core, I needed to understand how it works. </font><font style="vertical-align: inherit;">And the more I studied the TNKernel code, the less I liked it. </font><font style="vertical-align: inherit;">TNKernel gives the impression of a project written on the knee: a lot of duplicate code and there is no integrity.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Examples of poor implementation </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Violation of the rule ‚ÄúOne entry point, one exit point‚Äù </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The most common example found everywhere in the kernel is a code like the following: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ tn_disable_interrupt(); <span class="hljs-comment"><span class="hljs-comment">//-- do something if (error()){ //-- do something tn_enable_interrupt(); return ERROR; } //-- do something tn_enable_interrupt(); return SUCCESS; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have several operators </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and even more so if we need to perform some actions before returning, such a code is a guarantee of problems. </font><font style="vertical-align: inherit;">It would be much better to rewrite it as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = SUCCESS; tn_disable_interrupt(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error()){ rc = ERROR; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//-- so something } tn_enable_interrupt(); return rc; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, we do not need to remember that before returning it is necessary to enable interrupts. </font><font style="vertical-align: inherit;">Let the compiler do this work for us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no need to go far for the consequences: here is the function from the last TNKernel 2.7 currently:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tn_sys_tslice_ticks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> priority,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">TN_INTSAVE_DATA TN_CHECK_NON_INT_CONTEXT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tn_disable_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(priority &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || priority &gt;= TN_NUM_PRIORITY<span class="hljs-number"><span class="hljs-number">-1</span></span> || value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || value &gt; MAX_TIME_SLICE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TERR_WRONG_PARAM; tn_tslice_ticks[priority] = value; tn_enable_interrupt(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TERR_NO_ERR; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See: if incorrect parameters are passed to the function, it returns </font></font><code>TERR_WRONG_PARAM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and interrupts remain prohibited. </font><font style="vertical-align: inherit;">If we followed the rule of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one entry point, one exit point</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then this error most likely would not have occurred.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Violation of the principle of DRY </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(don't repeat yourself) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The original TNKernel 2.7 code contains a huge amount of code duplication. </font><font style="vertical-align: inherit;">A lot of similar things are done in different places through a simple copy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have several similar services (for example, services that send a message: from a stream, from a stream without waiting, or from an interrupt), then these are three very similar functions, in which there are 1-2 lines, without any attempts to generalize things .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Switching between thread states is implemented very inextricably. </font><font style="vertical-align: inherit;">For example, when we need to move a stream from the Runnable state to the Wait state, it is not enough just to remove one flag and put another: we also need to remove it from the start queue in which the thread was, then, perhaps, find the next thread to start, set the cause wait, add stream to queue for wait (if needed), set timeout (if needed), etc. </font><font style="vertical-align: inherit;">In TNKernel 2.7, there is no general mechanism for this, for each case the code is written ‚Äúhere and now‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the meantime, the correct way to implement these things is to write three functions for each state:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter the stream in the specified state; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remove the stream from the specified state; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check if the stream is in the given state. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when we need to transfer a stream from one state to another, we usually just need to call two functions: one to output the stream from the old state, and another to enter it in the new state. Simple and reliable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of regular violation of the DRY rule, when we need to change something, we need to edit the code in several places. Needless to say, this is a vicious practice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In short, TNKernel has a bunch of things that need to be implemented differently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to refactor it thorough. To make sure that I didn't break anything, I started implementing unit tests for the kernel. And it soon became clear that TNKernel was not tested at all: there are unpleasant bugs in the core itself! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For specific information about found and fixed bugs, see</font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/latest/html/why_reimplement.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why reimplement TNKernel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meet: TNeo </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At a certain point, it became clear that what I was doing went far beyond the framework of ‚Äúrefactoring‚Äù: I, in fact, rewrote almost everything in its entirety. </font><font style="vertical-align: inherit;">Plus, there are some things in the TNKernel API that have strained me for a long time, so I slightly changed the API; </font><font style="vertical-align: inherit;">and also there are things that I lacked, so I implemented them: timers, program control of stack overflow, the ability to wait for messages from several queues, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I thought about the name for a long time: I wanted to designate a direct link with TNKernel, but add something fresh and cool. </font><font style="vertical-align: inherit;">So the first name was: TNeoKernel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But after a while, it naturally shrunk to concise TNeo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo has a standard feature set for RTOS, plus some bonuses that are not everywhere. </font><font style="vertical-align: inherit;">Most features are optional, so you can turn them off, thereby saving memory and slightly increasing performance.</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or threads: the most basic feature for which the kernel was written at all;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutexes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : objects to protect shared resources:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursive mutexes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : optional, mutexes allow nested locking</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deadlock detection</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if a deadlock occurs, the kernel can notify you by calling an arbitrary callback function</font></font></li></ul><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semaphores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : objects to synchronize tasks</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fixed-size memory blocks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a simple and deterministic memory manager</font></font></li><li> <b> </b> : ,   ,    ,   ; <br><ul><li> <b>      </b> :         -  : ,          </li></ul><br></li><li> <b> </b> : FIFO  ,       </li><li> <b></b> :        . </li><li> <b>   </b> :     RAM </li><li> <b>   </b> :  ,       </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic tick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if the system has nothing to do, then you can not be distracted by the periodic processing of system ticks</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : allows you to find out how much time each of the threads was executed, the maximum execution time for a row, and other information</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project posted on GitHub: </font></font><a href="https://github.com/dimonomid/tneo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, the kernel is ported to the following architectures:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ARM Cortex-M cores: Cortex-M0 / M0 + / M1 / ‚Äã‚ÄãM3 / M4 / M4F (supported toolchains: GCC, Keil RealView, clang, IAR) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Microchip: PIC32MX / PIC24 / dsPIC </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Full documentation is available in two versions: html and pdf. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latest stable TNeo: </font></font><a href="http://goo.gl/SCSvdd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/latest/latex/tneo.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current development TNeo BETA: </font></font><a href="http://goo.gl/9NFZEm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/dev/latex/tneo.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></a> </li><li> <a href="http://goo.gl/rPv823"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changelog</font></font></a> </li></ul><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TNeo implementation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, it is very difficult to cover the implementation of the entire kernel in one article; </font><font style="vertical-align: inherit;">instead, I will try to remember what was not clear to me myself, and focus on these things. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But above all, we need to consider one internal structure: a linked list.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Related Lists </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A linked list is a well-known data structure, and the reader is likely already familiar with it. </font><font style="vertical-align: inherit;">However, for completeness, let's look at the implementation of linked lists in TNeo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Related lists are used throughout TNeo. </font><font style="vertical-align: inherit;">More specifically, a circular bidirectional linked list is used. </font><font style="vertical-align: inherit;">The structure in C is as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Circular doubly linked list item, for internal kernel usage. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TN_ListItem</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/// /// pointer to previous item struct TN_ListItem *prev; /// /// pointer to next item struct TN_ListItem *next; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is declared in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / tn_list.c file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the structure contains pointers to instances of the same structure: the previous one and the next one. </font><font style="vertical-align: inherit;">We can organize a chain of such structures, so that they will be linked as follows:</font></font><br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/linked_list_1.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is great, but there is not a lot of benefit from this: we would like to have some useful data in each object, right? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The solution is to embed </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another structure, the instances of which we want to link. </font><font style="vertical-align: inherit;">For example, suppose we have a structure </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBlock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field2; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field3; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we want to be able to build a sequence of instances of this structure. </font><font style="vertical-align: inherit;">First of all, we embed </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it inside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this example, it would be logical to place it </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the beginning </font></font><code>struct MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but just to emphasize that it </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be anywhere, not only at the beginning, let's put it in the middle:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBlock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field2; <span class="hljs-comment"><span class="hljs-comment">//-- say, embed it here. struct TN_ListItem list_item; int field3; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Okay, and now let's create some instances: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- blocks to put in the list struct MyBlock block_first = { /* ... */ }; struct MyBlock block_second = { /* ... */ }; struct MyBlock block_third = { /* ... */ };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now, one more important point: create a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list itself</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which can be either empty or non-empty. </font><font style="vertical-align: inherit;">This is just an instance of the same structure </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not embedded anywhere:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- list head struct TN_ListItem my_blocks;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the list is empty, both its pointers to the previous and next items point to itself </font></font><code>my_blocks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can organize the list as follows:</font></font><br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/_media/articles/linked_list_2.png" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It can be created using code like the following: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- ,         , // .     . my_blocks.next = &amp;block_first.list_item; my_blocks.prev = &amp;block_third.list_item; block_first.list_item.next = &amp;block_second.list_item; block_first.list_item.prev = &amp;my_blocks; block_second.list_item.next = &amp;block_third.list_item; block_second.list_item.prev = &amp;block_first.list_item; block_third.list_item.next = &amp;my_blocks; block_third.list_item.prev = &amp;block_second.list_item;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is excellent, but from the above, it is clear that we still have a list of </font></font><code>TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, not of </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But the idea is that the offset from the beginning </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the </font></font><code>list_item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">same is the same for all instances </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">So if we have a pointer to </font></font><code>TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and we know that this instance is embedded in </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then we can subtract a certain offset from the pointer, and get a pointer to </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a special macro for this: </font></font><code>container_of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(defined in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / internal / _tn_sys.h file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(container_of) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* given a pointer @ptr to the field @member embedded into type (usually * struct) @type, return pointer to the embedding instance of @type. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> container_of(ptr, type, member) \ ((type *)((char *)(ptr)-(char *)(&amp;((type *)0)-&gt;member))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So having a pointer to </font></font><code>TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we get a pointer to the external </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TN_ListItem</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_list_item</span></span></span><span class="hljs-class"> = /* ... */;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBlock</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_my_block</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_list_item</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBlock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_item</span></span></span><span class="hljs-class">);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can, for example, bypass all the elements in the list </font></font><code>my_blocks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- loop cursor struct TN_ListItem *p_cur; //--      my_blocks for (p_cur = my_blocks.next; p_cur != &amp;my_blocks; p_cur = p_cur-&gt;next) { struct MyBlock *p_cur_block = container_of(p_cur, struct MyBlock, list_item); //-- , p_cur_block     MyBlock }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code works, but it is somewhat confused and overloaded with implementation details of the list. </font><font style="vertical-align: inherit;">It is better to have a special macro to bypass the lists: </font></font><code>_tn_list_for_each_entry()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / internal / _tn_list.h file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we can hide all the details and go around the list of our copies </font></font><code>MyBlock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBlock</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p_cur_block</span></span></span><span class="hljs-class">;</span></span> _tn_list_for_each_entry( p_cur_block, struct MyBlock, &amp;my_blocks, list_item ) { <span class="hljs-comment"><span class="hljs-comment">//-- , p_cur_block     MyBlock }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In summary, this is a fairly convenient way to create lists of objects. </font><font style="vertical-align: inherit;">And, of course, we can include the same object in several lists: for this, the structure must have several built-in instances </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: for each list in which it is planned to include this object.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After I posted a link to the original article (English) on </font></font><a href="https://news.ycombinator.com/item%3Fid%3D10251471"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker News</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , one of the readers asked the question: why linked lists are implemented by embedding it </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in other structures, and not, for example, like this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TN_ListItem</span></span></span><span class="hljs-class"> {</span></span> TN_ListItem *prev; TN_ListItem *next; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; <span class="hljs-comment"><span class="hljs-comment">//--      }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The question is interesting, so I decided to include the answer in the article itself: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo never allocates memory from the heap: it operates only with objects, pointers to which are passed as parameters to one or another kernel service. And this is, in fact, very good: often, embedded systems do not use a bunch at all, because her behavior is not sufficiently deterministic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, for example, when a task goes into waiting for a mutex, this task is added to the list of tasks waiting for this particular mutex, and the complexity of this operation is O (1), i.e. it is always executed in constant (and, by the way, short) time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we use the approach with </font></font><code>void *data;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then we have two options:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we add a new object to some list, the kernel has to allocate an instance somewhere </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(from a heap or, possibly, from some pool of objects);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client code must allocate </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">independently (in any way) and transfer it to any kernel service that may need it.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both options are unacceptable. </font><font style="vertical-align: inherit;">Therefore, the version with embedding is used and, by the way, the exact same approach is used in the Linux kernel (see the book ‚ÄúLinux Kernel Development‚Äù by Robert Love). </font><font style="vertical-align: inherit;">And almost all the helper macros (to bypass the lists) were taken from the Linux kernel, with a few changes: at a minimum, we cannot use GCC-specific language extensions, for example </font></font><code>typeof()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because </font><font style="vertical-align: inherit;">TNeo should not be compiled by GCC at all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As already mentioned, TNeo uses lists intensively:</font></font><br><br><ul><li>       :       (,    ) </li><li>     ,          (    ) </li><li>      ,     ,       </li><li>  Etc. </li></ul><br><h2>  () </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasks or streams are the most important part of the system: after all, this is exactly what RTOS does exist for. In the context of TNeo and other RTOS for relatively simple microcontrollers, a task is a subroutine that runs (as if) in parallel with other tasks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generally speaking, I prefer the term ‚Äúthread‚Äù (thread), but TNKernel uses the term ‚Äútask‚Äù (task), so TNeo also uses the term task to maintain compatibility. In this article, I use both terms in the same sense. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each existing task in the system has its own descriptor:, </font></font><code>struct TN_Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declared in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / tn_tasks.h file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a rather large structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first element of the task descriptor is a pointer to the top of the task stack:</font></font><code>stack_cur_pt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This fact is actively used by assembler context switching routines: having a pointer to a task handle, we can simply distribute it, and the resulting value will point to the top of the task stack. </font><font style="vertical-align: inherit;">Pretty comfortable.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Current and next tasks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two pointers in the kernel: to the task currently being executed, and to the next task that needs to be started. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / internal / _tn_sys.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// task that is running now extern struct TN_Task *_tn_curr_run_task; /// task that should run as soon as possible (if it isn't equal to /// _tn_curr_run_task, context switch is needed) extern struct TN_Task *_tn_next_task_to_run;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As can be seen from the comments, if they point to different descriptors, then the context should be switched as soon as possible. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task Priorities and Launch Queues </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tasks have different priorities. </font><font style="vertical-align: inherit;">The maximum number of available priorities is determined by the dimension of the processor word: on 16-bit microcontrollers, we have 16 priorities, and on 32-bit ones - 32. Why this will be clear later, but, generally speaking, for our applications I never needed more, than 5 or 6 priorities. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each priority, there is a linked list of ready-to-run tasks that have this priority. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / internal / _tn_sys.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// list of all ready to run (TN_TASK_STATE_RUNNABLE) tasks extern struct TN_ListItem _tn_tasks_ready_list[TN_PRIORITIES_CNT];</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where </font></font><code>TN_PRIORITIES_CNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- user configurable value (of course, it can not be greater than the maximum). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the task descriptor has an instance </font></font><code>struct TN_ListItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is added to one of these task lists:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Task */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TN_Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/// queue is used to include task in ready/wait lists struct TN_ListItem task_queue; /* ... */ }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The core also has a bitmask (one word size), where each bit corresponds to one priority. </font><font style="vertical-align: inherit;">If the bit is set, this means that there are tasks in the system that are ready to start and have a corresponding priority:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// bitmask of priorities with runnable tasks. /// lowest priority bit (1 &lt;&lt; (TN_PRIORITIES_CNT - 1)) should always be set, /// since this priority is used by idle task which should be always runnable, /// by design. extern volatile unsigned int _tn_ready_to_run_bmp;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, when the kernel needs to determine which task it is necessary to transfer control to, it executes an architecture </font></font><a href="https://en.wikipedia.org/wiki/Find_first_set"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specific </font><a href="https://en.wikipedia.org/wiki/Find_first_set"><font style="vertical-align: inherit;">find-first-set</font></a><font style="vertical-align: inherit;"> instruction </font><font style="vertical-align: inherit;">for </font></font><code>_tn_ready_to_run_bmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and immediately receives the highest priority from all tasks ready for launching. </font><font style="vertical-align: inherit;">Then, we take the first task from the task list for the corresponding priority, and transfer control to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, when a task enters or exits the Runnable state (ready to run), it serves the corresponding bit in </font></font><code>_tn_ready_to_run_bmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is rather trivial. </font><font style="vertical-align: inherit;">In general, everything works quickly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task context </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall that when a task is not currently running, its context (the value of all registers, plus the address in program memory from which the task should continue execution) is stored in its stack. </font><font style="vertical-align: inherit;">And </font></font><code>stack_cur_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the task descriptor it indicates exactly the top of this saved context. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each core architecture supported (MIPS, ARM Cortex-M, etc.) there is a specific contest structure, i.e. </font><font style="vertical-align: inherit;">exactly how all these registers are placed on the stack. </font><font style="vertical-align: inherit;">When a task has just been created and is preparing to start, the beginning of its stack is filled with an ‚Äúinitialization‚Äù context, so that when the task finally gets control, this initialization context is restored. </font><font style="vertical-align: inherit;">Thus, each task runs in an isolated, clean environment.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task states </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A task can be in one of the following states: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Runnable: the task is ready to start (this does not mean that the task is actually running at the moment) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wait: the task is waiting for something (messages from the queue, mutex, semaphore, etc.) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suspended: The task has been suspended by another task. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wait + Suspended: the task was in the Wait state, after which it was suspended by another task </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dormant: the task has not yet been activated after creation, or was destroyed by a call </font></font><code>tn_task_terminate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The next time the task is activated, its previous state will be reset to zero and it will run in a clean environment.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When a task goes out of a state or, on the contrary, enters it, there is a certain set of actions that must be performed. </font></font> For example: <br><br><ul><li>      Dormant,    ,      ,       </li><li>      Runnable,              <code>_tn_ready_to_run_bmp</code> ,          </li><li>      Runnable,       , -  <code>_tn_ready_to_run_bmp</code> ,         ,        </li><li>      Wait,        ( ),    ,     </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When the task exits the Wait state, we remove it from the wait queue (if it was in such a queue), and reset the timer (if it was set) </font></font></li><li>  Etc. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that when a task, for example, exits the Runnable state, we don‚Äôt need to worry about the new state that the task goes to: Wait? </font><font style="vertical-align: inherit;">Suspended? </font><font style="vertical-align: inherit;">Dormant? </font><font style="vertical-align: inherit;">It does not matter: in any case, we must always remove it from the launch queue, and perform the remaining mandatory actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simple and reliable way to do this is to write three functions for each state:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enter the task in the specified state; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Take the task out of the specified state; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check whether the task is in a given state. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src / core / tn_tasks.c file</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we have the following functions:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _tn_task_set_runnable(struct TN_Task * task) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _tn_task_clear_runnable(struct TN_Task * task) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _tn_task_set_waiting( struct TN_Task *task, struct TN_ListItem *wait_que, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TN_WaitReason wait_reason, TN_TickCnt timeout ) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _tn_task_clear_waiting(struct TN_Task *task, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TN_RCode wait_rc) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">//-- etc.</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And when we need to transfer a task from one state to another, it usually boils down to the following: </font></font><br><br><pre> <code class="cpp hljs"> _tn_task_clear_dormant(task); _tn_task_set_runnable(task);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we can be sure that all internal affairs will be settled. </font><font style="vertical-align: inherit;">Is it cool?</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating tasks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is one thing that a task needs to perform: a space for the stack. </font><font style="vertical-align: inherit;">So, before a task can be created, we need to allocate an array that will be used as a stack for this task, and pass this array along with the rest of the things to </font></font><code>tn_task_create()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kernel sets the top of the task stack at the beginning of this array (or at the end ‚Äî depending on the architecture), and puts the task in the Dormant state. </font><font style="vertical-align: inherit;">At the moment, it is not yet ready to launch. </font><font style="vertical-align: inherit;">When the user calls </font></font><code>tn_task_activate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or if the flag </font></font><code>TN_TASK_CREATE_OPT_START</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was passed in </font></font><code>tn_task_create()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), the kernel acts as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Displays a task from the Dormant state: as you already know, at this moment the task stack is initialized with a clean context; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enters the task into the Runnable state: as you already know, at this moment the task is placed at the end of the corresponding launch queue. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the scheduler will take care of this task, and run it when needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a look at how tasks get started.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Running tasks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The exact sequence of actions required to run a task, of course, depends on the architecture. </font><font style="vertical-align: inherit;">But, as a general idea, the kernel acts as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retrieves the stack pointer from the task handle it points </font></font><code>_tn_next_task_to_run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to and sets it as the current stack pointer;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performs </font></font><code>_tn_curr_run_task = _tn_next_task_to_run;</code>  ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loads the values ‚Äã‚Äãof all registers from the stack, one by one (remember that the stack pointer has just been set to the top of the task stack). </font><font style="vertical-align: inherit;">Among other things, the address is also loaded in the program memory where the task should be resumed;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sends control to the task. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How exactly the kernel transfers control to the task is completely dependent on the architecture. </font><font style="vertical-align: inherit;">For example, on MIPS, you need to save the program counter of the task in the EPC (Exception Program Counter) register, and execute the instruction </font></font><code>eret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(return from exception). </font><font style="vertical-align: inherit;">That is, the kernel "deceives" the processor so that it behaves as if it is returned from the "normal" interrupt. </font><font style="vertical-align: inherit;">After execution </font></font><code>eret</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the current PC (Program Counter) is set to the value stored in the EPC, and, in fact, the task continues execution.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Context switch </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process, when the kernel suspends the execution of the current task and transfers control to the next task, is called ‚Äúcontext switching‚Äù. This procedure is always performed in a special ISR that has the lowest priority. So, when you need to switch the context, the kernel sets the corresponding interrupt bit. If a user task is currently running, then the ISR, which switches the context, is called by the processor immediately. If this bit is set from some other ISR (regardless of the interrupt priority), then the context switch will be triggered later: when all the ISRs currently being executed return control.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the specific interrupt that is used to switch the context depends on the architecture. </font><font style="vertical-align: inherit;">For example, to use PIC32 Core Software Interrupt 0. there is a special exception provided for OS context switching on the Cortex-M on ARM: </font></font><code>PendSV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the core ISR switching context is invoked, it does the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saves the values ‚Äã‚Äãof all registers to the stack of the current task, one after another. </font><font style="vertical-align: inherit;">Among other things, the address is stored in the program memory at which the task was interrupted;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When all registers are saved to the stack, the kernel saves the current stack pointer to the current task handle; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Possibly, performs on-context-switch handler (it is needed for the profiler and for software control over stack overflow, if any of these functions is enabled); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then go to the sequence specified in the previous section "Running Tasks". </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Context switching occurs when a task with a higher priority than the current task becomes ready to be executed; </font><font style="vertical-align: inherit;">or when the current task goes to the Wait state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, suppose we have two tasks: a low-priority Transmitter and a high-priority Receiver. </font><font style="vertical-align: inherit;">Receiver is trying to get a message from the queue, and since </font><font style="vertical-align: inherit;">the queue is empty, the task goes to the Wait state. </font><font style="vertical-align: inherit;">It is no longer available for execution, so the kernel shifts to the low-priority Transmitter task.</font></font><br><br><div style="text-align:center;"><img src="http://dmitryfrank.com/lib/plugins/plantuml/img.php?width=0&amp;height=0&amp;title=PlantUML%20Graph&amp;align=center&amp;version=2011-07-16&amp;md5=24c2a8b646a0e792b059bcb3f2fa31be" alt="image"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see from the diagram, when the low-priority task Transmitter sends a message calling the service </font></font><code>tn_queue_send()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this task is pushed out by the core in favor of the high-priority Receiver immediately. </font><font style="vertical-align: inherit;">So, by the time the </font></font><code>tn_queue_send()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control returns to Transmitter, many things have already happened:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Context switches to Receiver; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Receiver receives the message and processes it; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Receiver tries to get the next message, and goes to the Wait state; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Context switches back to Transmitter. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, the system is very responsive: if you set the correct priorities of tasks, then the events are processed very quickly. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idle task </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo has one special task: Idle. </font><font style="vertical-align: inherit;">It has the lowest priority (user tasks cannot have such a low priority), and it should always be ready to start, so it </font></font><code>_tn_ready_to_run_bmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always has at least one set bit: the bit for the lowest priority of the Idle task. </font><font style="vertical-align: inherit;">Obviously, the kernel transfers control to this task when there are no other tasks ready to run. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An application can implement a callback function that will be called from the Idle task all the time. </font><font style="vertical-align: inherit;">This can be used for various useful purposes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCU sleep. </font><font style="vertical-align: inherit;">When the system has nothing to do, it often makes sense to put the processor in sleep to reduce power consumption. </font><font style="vertical-align: inherit;">Of course, the application must configure some condition on which the processor must exit sleep: most often, this is some kind of interruption;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculate system load. </font><font style="vertical-align: inherit;">The simplest implementation: simply increment by one the value of a variable in an infinite loop. </font><font style="vertical-align: inherit;">The faster the value changes, the less load on the system.</font></font></li></ul><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Idle task must always be ready to start, it is forbidden to call any kernel services from this callback that can transfer the task to the Wait state. </font></font><br><br><h2>  Timers </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kernel must have an idea of ‚Äã‚Äãthe time. </font><font style="vertical-align: inherit;">Two schemes are available: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static tick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic tick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Static tick </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A static tick is the simplest way to implement timeouts: we need some kind of hardware timer that will generate interrupts at regular intervals. In this article, this timer will be called the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system timer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The period of this timer is user defined (I always used 1 ms, but, of course, you can set an arbitrary period). In the ISR of this timer, we just need to call a special kernel service:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//-- example for PIC32, hardware timer 5 interrupt: tn_p32_soft_isr(_TIMER_5_VECTOR) { INTClearFlag(INT_T5); tn_tick_int_processing(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Every time when it </font></font><code>tn_tick_int_processing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called, we say that a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system tick has</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> occurred </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Inside this function, the kernel checks if it is time to call a callback of some timer, and if it is time, then it calls it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest implementation of timers can look like this: we have a linked list with all active timers, and for each system tick we go through the entire list of timers by performing the following actions for each timer:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce the timeout value by 1; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the new value is zero, then remove this timer from the list (i.e., make the timer inactive), and start the callback timer. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This approach has significant drawbacks: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We cannot manage timers from callbacks: if we, for example, add a new timer, the list of timers will be modified. </font></font> But since         ,     ; </li><li>         :          . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last item may not be so important in embedded systems, because </font><font style="vertical-align: inherit;">it is unlikely that anyone would need such a large number of timers; </font><font style="vertical-align: inherit;">but the first point is very significant: we definitely want to be able to add (or reconfigure) a timer from the timer callback. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So in TNeo, a more cunning approach is applied. </font><font style="vertical-align: inherit;">The basic idea is taken from the Linux kernel, but the implementation is much simpler because: (1) embedded systems have significantly fewer resources than the machines for which Linux is written, and (2) TNeo does not need to scale as well as Linux should scale. </font><font style="vertical-align: inherit;">You can read about the implementation of timers in Linux in the book Linux Device Drivers, 3rd edition:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Time, Delays, and Deferred Work </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kernel timers </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The Implementation of Kernel Timers </font></font><br></li></ul></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This book is available to everyone at the link: </font></font><a href="http://lwn.net/Kernel/LDD3/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://lwn.net/Kernel/LDD3/</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So, we proceed to the implementation of timers in TNeo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a custom value of N, which should be a power of two; typical values ‚Äã‚Äãare 4, 8, or 16. And there is an array of lists (so-called tick lists), this array consists of N elements. That is, we have N tick-lists. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the timer expires after the number of system ticks from 1 to (N - 1), then this timer is added to one of these tick lists. The tick-list number is calculated simply by overlaying the corresponding mask with a timeout (which is why N must be a power of two). If the timer expires later, then it is added to the ‚Äúgeneric‚Äù list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mask, of course, corresponds to N: for example, when N = 4, the mask is used</font></font><code>0b0011</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">when N = 8, a mask is used </font></font><code>0b0111</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each N-th system tick, the kernel passes through all the timers from the "general" list, and for each timer performs the following actions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The timeout is reduced by N; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the resulting timeout is less than N, then the timer moves to the corresponding tick list. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And for each system tick, we go through one corresponding tick-list, and unconditionally execute callbacks of all timers from this list. This solution is more efficient than the simplest one discussed above: we have to go through the entire list of timers only 1 time in N ticks, but in other cases, we simply unconditionally shoot all the timers, the list of which has already been prepared. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The attentive reader may wonder: why do we use only (N - 1) tick-lists, when we actually have N lists? This is due to the fact that we just want to be able to modify the timers from the timer callbacks. If we used N lists, and the user adds a timer with a timeout equal to N, then the new timer will be added to the list that we are currently passing. This can not be done.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we use (N - 1) lists, then we guarantee that the new timer cannot be added to the tick-list that we are going through at the moment (by the way, the timer can be removed from this list, but this will not create problems) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this implementation of timers is quite acceptable for many applications, sometimes it is not ideal: if a device spends most of the time without doing anything, instead of constantly being on standby (with reduced consumption), the MCU will have to wake up regularly to process the system tick and go back to sleep. </font><font style="vertical-align: inherit;">For this, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic tick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was implemented </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic tick </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic idea is to get rid of useless calls </font></font><code>tn_tick_int_processing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the kernel has to wake up some task through 100 system ticks, then it </font></font><code>tn_tick_int_processing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be called after exactly 100 periods of the system tick (but external asynchronous events, of course, can occur and change this). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, the kernel must be able to communicate with the application:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To schedule the next call </font></font><code>tn_tick_int_processing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via N ticks;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To ask how much time (i.e. get the current system ticks count). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, when the dynamic tick mode is active ( </font></font><code>TN_DYNAMIC_TICK</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set to 1), the application must provide pointers to these callbacks at system startup. </font><font style="vertical-align: inherit;">Of course, the actual implementation of these callbacks depends entirely on the type of MCU (even on the same architecture there are a huge number of different MCUs that have different peripherals, etc.), therefore the correct implementation of these callbacks lies on the application.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> System start </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For normal operation, the kernel needs the following: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Space for the Idle task stack; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Space for interrupt stack; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Callback for idle task; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Any user task (tasks). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, before starting the system, the application must allocate arrays for the Idle task stack and for interrupts, provide the Idle callback task (it can be empty), and provide a special callback that must create at least one (and usually just one) user task. </font><font style="vertical-align: inherit;">This is the first task to be launched, and in my applications I usually call it </font></font><code>task_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>task_conf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obviously, it initializes the application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the application should:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disable system interrupts by calling </font></font><code>tn_arch_int_dis()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perform the main initialization of the microcontroller: at least, the oscillator settings; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configure a system timer interrupt (from which the ISR is called </font></font><code>tn_tick_int_processing()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call </font></font><code>tn_sys_start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, providing all the necessary information: pointers to arrays for stacks, their sizes, and callback functions.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The kernel does the following: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initializes startup queues (an array of lists </font></font><code>_tn_tasks_ready_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and other aspects of the internal state of the kernel;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creates and activates the Idle task (after that, </font></font><code>_tn_next_task_to_run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">points to the Idle task handle)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invokes a user-defined function, in which the first user task is created and activated (after that, it </font></font><code>_tn_next_task_to_run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicates the handle of the highest-priority user task);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invokes an architecture-specific function </font></font><code>_tn_arch_sys_start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that initializes an interrupt for a context switch, and performs the first context switch to the task that it is pointing to </font></font><code>_tn_next_task_to_run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that, the system works as usual: a user task takes control and can do everything that any user task can do. </font><font style="vertical-align: inherit;">Usually, she does the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initializes various peripherals on the board (LCD displays, flash drives, or whatever); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initializes software modules used in the application; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creates all other user tasks (since everything is already initialized, they can now begin their work). </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> More implementation details </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Okay, it seems I should stop at some point: it‚Äôs unlikely that I will be able to describe every detail of the implementation in this article, which, frankly, is too big. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I tried to touch on the most interesting topics that are needed to understand the picture as a whole; </font><font style="vertical-align: inherit;">for other topics, the reader can easily study the source code, which I tried to make really good and understandable. </font></font><a href="https://github.com/dimonomid/tneo/blob/master/src/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources are available: use them</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have any questions, ask in the comments.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, when they talk about unit tests, they mean tests run on the host machine. </font><font style="vertical-align: inherit;">But, unfortunately, the compilers used for embedded systems often contain errors, so I decided to test the kernel right in the hardware. </font><font style="vertical-align: inherit;">Thus, I can be sure that the kernel works 100% on my device. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overview of test implementation: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a high-priority task ‚Äútest director‚Äù, which creates for itself ‚Äúworking‚Äù tasks and various RTOS objects (message queues, mutexes, etc.), and then tells work tasks what to do.</font></font> For example: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task A, you block mutex M1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task B, you block mutex m1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task C, you block mutex M1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Task A, you delete mutex M1 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After each step, the test director waits for the workers to do their work, and then checks that everything is going according to plan: checks the status of tasks, their priorities, the last returned values ‚Äã‚Äãfrom the kernel services, various properties of objects, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The detailed log is displayed in the UART. </font><font style="vertical-align: inherit;">Usually, after each step, the following is displayed:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbatim comment; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test director writes what he does; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each work task writes what it does; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Test director checks everything and writes a report. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an example of the output log: </font></font><br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>-- A locks M1 (line <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ..<span class="hljs-regexp"><span class="hljs-regexp">/source/appl/appl_tntest/appl_tntest_mutex.c) [I]: tnt_item_proceed():2101: ----- Command to task A: lock mutex M1 (0xa0004c40) [I]: tnt_item_proceed():2160: Wait 80 ticks [I]: [Task A]: locking mutex (0xa0004c40).. [I]: [Task A]: mutex (0xa0004c40) locked [I]: [Task A]: waiting for command.. [I]: tnt_item_proceed():2178: Checking: [I]: * Task A: priority=6 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=TN_RC_OK (as expected) [I]: * Task B: priority=5 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Task C: priority=4 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Mutex M1: holder=A (as expected), lock_cnt=1 (as expected), exists=yes (as expected) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/-- B tries to lock M1 -&gt; B blocks, A has priority of B (line 413 in ../source/appl/appl_tntest/appl_tntest_mutex.c) [I]: tnt_item_proceed():2101: ----- Command to task B: lock mutex M1 (0xa0004c40) [I]: tnt_item_proceed():2160: Wait 80 ticks [I]: [Task B]: locking mutex (0xa0004c40).. [I]: tnt_item_proceed():2178: Checking: [I]: * Task A: priority=5 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=TN_RC_OK (as expected) [I]: * Task B: priority=5 (as expected), wait_reason=MUTEX_I (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Task C: priority=4 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Mutex M1: holder=A (as expected), lock_cnt=1 (as expected), exists=yes (as expected) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/-- C tries to lock M1 -&gt; B blocks, A has priority of C (line 422 in ../source/appl/appl_tntest/appl_tntest_mutex.c) [I]: tnt_item_proceed():2101: ----- Command to task C: lock mutex M1 (0xa0004c40) [I]: tnt_item_proceed():2160: Wait 80 ticks [I]: [Task C]: locking mutex (0xa0004c40).. [I]: tnt_item_proceed():2178: Checking: [I]: * Task A: priority=4 (as expected), wait_reason=DQUE_WRECEIVE (as expected), last_retval=TN_RC_OK (as expected) [I]: * Task B: priority=5 (as expected), wait_reason=MUTEX_I (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Task C: priority=4 (as expected), wait_reason=MUTEX_I (as expected), last_retval=NOT-YET-RECEIVED (as expected) [I]: * Mutex M1: holder=A (as expected), lock_cnt=1 (as expected), exists=yes (as expected) /</span></span>/-- A deleted M1 -&gt; B <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> C become runnable <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> have retval TN_RC_DELETED, A has its base priority (line <span class="hljs-number"><span class="hljs-number">431</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ../source/appl/appl_tntest/appl_tntest_mutex.c) [I]: tnt_item_proceed():<span class="hljs-number"><span class="hljs-number">2101</span></span>: ----- Command to task A: <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mutex M1 (<span class="hljs-number"><span class="hljs-number">0xa0004c40</span></span>) [I]: tnt_item_proceed():<span class="hljs-number"><span class="hljs-number">2160</span></span>: Wait <span class="hljs-number"><span class="hljs-number">80</span></span> ticks [I]: [Task A]: deleting mutex (<span class="hljs-number"><span class="hljs-number">0xa0004c40</span></span>).. [I]: [Task C]: mutex (<span class="hljs-number"><span class="hljs-number">0xa0004c40</span></span>) locking failed with err=<span class="hljs-number"><span class="hljs-number">-8</span></span> [I]: [Task C]: waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> command.. [I]: [Task B]: mutex (<span class="hljs-number"><span class="hljs-number">0xa0004c40</span></span>) locking failed with err=<span class="hljs-number"><span class="hljs-number">-8</span></span> [I]: [Task B]: waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> command.. [I]: [Task A]: mutex (<span class="hljs-number"><span class="hljs-number">0xa0004c40</span></span>) deleted [I]: [Task A]: waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> command.. [I]: tnt_item_proceed():<span class="hljs-number"><span class="hljs-number">2178</span></span>: Checking: [I]: * Task A: priority=<span class="hljs-number"><span class="hljs-number">6</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), wait_reason=DQUE_WRECEIVE (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), last_retval=TN_RC_OK (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected) [I]: * Task B: priority=<span class="hljs-number"><span class="hljs-number">5</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), wait_reason=DQUE_WRECEIVE (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), last_retval=TN_RC_DELETED (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected) [I]: * Task C: priority=<span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), wait_reason=DQUE_WRECEIVE (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), last_retval=TN_RC_DELETED (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected) [I]: * Mutex M1: holder=NONE (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), lock_cnt=<span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected), exists=<span class="hljs-literal"><span class="hljs-literal">no</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If something goes wrong, there will be no ‚Äúas expected‚Äù, but an error and details. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I really tried to simulate all possible situations within a single subsystem (mutexes, queues, etc.), including situations with suspended tasks, remote tasks, remote objects, etc. </font><font style="vertical-align: inherit;">This helps a lot to keep the core really stable.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final words </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why not just use FreeRTOS? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OK, there are several reasons. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firstly, I do not like their license:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> under license, FreeRTOS is forbidden to compare with other products! </font><font style="vertical-align: inherit;">Look at the last paragraph of </font></font><a href="http://www.freertos.org/license.txt"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FreeRTOS license</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote> FreeRTOS may not be used for any competitive or comparative purpose, including the publication of any form of run time or compile time metric, without the express permission of Real Time Engineers Ltd. (this is the norm within the industry and is intended to ensure information accuracy). <br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As far as I know, they added this condition after a </font></font><a href="http://goo.gl/lSI40j"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very old discussion on the Microchip forum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where people posted graphs comparing several cores, and these graphs were not in favor of FreeRTOS. The author of FreeRTOS </font></font><a href="http://goo.gl/pcb2wk"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stated that the measurements are incorrect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but, no matter how funny, could not provide the "correct" measurements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, if I write a kernel that FreeRTOS leaves behind in one or another aspect, I will not be able to write about it. Maybe I do not understand something, but, in my opinion, some kind of nonsense. I do not like these things.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, a few years ago, when my colleagues recommended TNKernel, they said that TNKernel is much faster than FreeRTOS. After I implemented TNeo, out of curiosity, I, of course, made a couple of comparisons, but, unfortunately, I cannot publish them because of the FreeRTOS license. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, I don‚Äôt like its source code either</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Maybe I‚Äôm just too idealistic, but for me, the real-time core is, to some extent, a special project, and I want it to be as close to the ideal as possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, now is the time to check out </font></font><a href="https://github.com/dimonomid/tneo/blob/master/src"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the TNeo code on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and explain why it sucks. Perhaps this will help me make the kernel even better! </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, I wanted to have a more or less ready TNKernel replacement.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that I can easily port existing applications to the new kernel. </font><font style="vertical-align: inherit;">Taking into account the problems in TNKernel under microchip microcontrollers described in the first part of the article, our devices always had the probability of undefined behavior. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And last but not least</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , working on the core is an extremely exciting experience! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, FreeRTOS has an undeniable advantage over (possibly) all other similar products: it is ported to a huge number of architectures. </font><font style="vertical-align: inherit;">Fortunately, I do not need so much.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where is TNeo used? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, I ported to TNeo all existing applications that previously worked on TNKernel: on-board computers, chargers, etc. </font><font style="vertical-align: inherit;">Works flawlessly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also presented the core at the annual Microchip MASTERS 2014 seminar, the head of the StarLine development department became interested and asked me to port the core to the Cortex-M architecture. </font><font style="vertical-align: inherit;">Now it is already ready for a long time, and the core is used in their latest products.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Documentation and source code </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo is a thoroughly tested replacement RTOS for 16-bit and 32-bit open source microcontrollers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project posted on GitHub: </font></font><a href="https://github.com/dimonomid/tneo"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TNeo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment, the kernel is ported to the following architectures:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ARM Cortex-M cores: Cortex-M0 / M0 + / M1 / ‚Äã‚ÄãM3 / M4 / M4F (supported toolchains: GCC, Keil RealView, clang, IAR) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Microchip: PIC32MX / PIC24 / dsPIC </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Full documentation is available in two versions: html and pdf. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latest stable TNeo: </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/latest/html/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/latest/latex/tneo.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current development TNeo BETA: </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/dev/html/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://dfrank.bitbucket.io/tneokernel_api/dev/latex/tneo.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pdf</font></font></a> </li><li> <a href="https://dfrank.bitbucket.io/tneokernel_api/dev/html/changelog.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changelog</font></font></a> </li></ul><br><hr><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My original article in English: </font></font><a href="https://dmitryfrank.com/articles/how_i_ended_up_writing_my_own_kernel"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How I ended up writing new real-time kernel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Since </font><font style="vertical-align: inherit;">the author of the original article is myself, then, with your permission, I did not place this article in the category of "translation"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/267573/">https://habr.com/ru/post/267573/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267563/index.html">Technical method of protection against unauthorized issuance of duplicate SIM cards (and personal data in general), implemented at the operator level</a></li>
<li><a href="../267565/index.html">How to create an image slider in a mail message</a></li>
<li><a href="../267567/index.html">Telegram check using PVS-Studio and vice versa</a></li>
<li><a href="../267569/index.html">Software design</a></li>
<li><a href="../267571/index.html">Impressions from the trainings Certified Scrum Master and Certified Scrum Product Owner</a></li>
<li><a href="../267575/index.html">Construction integration. Interview with CIO of the largest stock exchange in Russia and Eastern Europe</a></li>
<li><a href="../267577/index.html">Trojan Android app bypasses Google Bouncer checks</a></li>
<li><a href="../267579/index.html">Tehnokniga, part 3: literature on the design of highly loaded systems, on the security of web applications, on ensuring the quality of development and on mobile development</a></li>
<li><a href="../267583/index.html">Symantec voluntarily issued a certificate for google.com and www.google.com</a></li>
<li><a href="../267587/index.html">Deep Linking for Mobile Applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>