<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building a microservice architecture on Golang and gRPC, part 2 (docker)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's time to take up the containers 
 First of all, we use the latest Linux Alpine image. Linux Alpine is a lightweight Linux distribution designed an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building a microservice architecture on Golang and gRPC, part 2 (docker)</h1><div class="post__text post__text-html js-mediator-article"><h3>  It's time to take up the containers </h3><br>  First of all, we use the latest Linux Alpine image.  Linux Alpine is a lightweight Linux distribution designed and optimized for running web applications in Docker.  In other words, Linux Alpine has enough dependencies and functionality to run most applications.  This means that the size of the image is about 8 MB! <br><br>  Compared to, let's say ... a Ubuntu virtual machine of about 1 GB, which is why Docker images have become more naturally suited for microservices and cloud computing. <br><br>  So, now I hope that you see the value in containerization, and we can start ‚ÄúDockerising‚Äù our first service.  Let's create a Dockerfile <b>$ touch consignment-service / Dockerfile</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://habr.com/ru/post/425653/">First part</a> <br>  <a href="https://github.com/EwanValentine/shippy">Original EwanValentine repository</a> <br>  <a href="https://ewanvalentine.io/microservices-in-golang-part-2/">Original article</a> <br><br>  In the Dockerfile, add the following: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Then we create a new directory to host our application.  Then we add our compiled binary file to our Docker container and run it. <br><br>  Now let's update the build entry of our Makefile to create a Docker image. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  We added two more steps, and I would like to explain them in a bit more detail.  First of all, we create our binary Go file.  However, you will notice two environment variables before we run $ go build.  GOOS and GOARCH allow you to cross-compile your binary file for another operating system.  Since I am developing for a Macbook, I cannot compile the go executable, and then run it in a Docker container that uses Linux.  The binary will be completely meaningless in your Docker container, and it will generate an error. <br><br>  The second step I added is the docker build process.  Docker will read your Dockerfile and create an image with the name consignment-service, the dot indicates the path to the directory, so here we just want the build process to look into the current directory. <br><br>  I'm going to add a new entry to our Makefile: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Here we launch our docker image, opening port 50051. Since Docker is working on a separate network level, you need to redirect the port.  For example, if you want to start this service on port 8080, you must change the argument -p to 8080: 50051.  You can also run the container in the background by including the -d flag.  For example, <b>docker run -d -p 50051: 50051 consignment-service</b> . <br><br>  Run <b>$ make run</b> , then in a separate terminal panel again <b>$ go run main.go</b> and check that it still works. <br><br>  When you run $ docker build, you embed your code and runtime into an image.  Docker images are portable images of your environment and its dependencies.  You can share Docker images by posting them in the Docker Hub.  This is similar to npm or the yum repository for dockers.  When you define a FROM in your Dockerfile, you tell Docker to pull this image out of the Docker storage for use as a base.  Then you can expand and redefine portions of this base file, overriding them as you like.  We will not publish our images of dockers, but feel free to browse through the dockers repository and note that virtually any software has already been packaged in containers.  Some really wonderful things were dockerised. <br><br>  Each ad in the Dockerfile is cached when it is first built.  This eliminates the need to rebuild the entire runtime environment each time you make changes.  Docker is smart enough to figure out which parts have changed and which need to be rebuilt.  This makes the build process incredibly fast. <br><br>  Enough about containers!  Let's go back to our code. <br><br>  When creating a gRPC service, there is a lot of standard code for creating connections, and you need to hard-code the location of the service address in the client or another service so that it can connect to it.  This is difficult because when you start services in the cloud, they may not use the same host, or the address or ip may change after redeploying the service. <br><br>  This is where the discovery service comes into play.  Discovery Service updates the directory of all your services and their location.  Each service is registered at run time and cancels registration at closing.  Each service is then assigned a name or identifier.  Thus, even if it may have a new IP address or host address, provided that the service name remains the same, you do not need to update calls to this service from other services. <br><br>  As a rule, there are many approaches to this problem, but, like most things in programming, if someone has already dealt with this problem, there is no point in reinventing the wheel.  @Chuhnk (Asim Aslam), the creator of <a href="https://github.com/micro/go-micro">Go-micro</a> , solves these problems with fantastic clarity and ease of use.  He single-handedly produces fantastic software.  Please consider helping him if you like what you see! <br><br><h3>  Go-micro </h3><br>  Go-micro is a powerful microservice framework written in Go, for use mostly with Go.  However, you can use Sidecar to interact with other languages. <br><br>  Go-micro has useful features for creating microservices in Go.  But we will start with perhaps the most common problem that he solves, and this is the discovery of the service. <br><br>  We will need to make several updates to our service in order to work with go-micro.  Go-micro integrates as a Protoc plugin, in this case replacing the standard gRPC plugin that we currently use.  So let's start by replacing this in our Makefile. <br><br>  Be sure to install the go-micro dependencies: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Update our Makefile to use the go-micro plugin instead of the gRPC plugin: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Now we need to update our shippy-service-consignment / main.go to use go-micro.  This abstracts most of our previous gRPC code.  It easily handles the registration and speeds up the writing of the service. <br><br><div class="spoiler">  <b class="spoiler_title">shippy-service-consignment / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  The main changes here are the way we create our gRPC server, which was carefully abstracted from mico.NewService (), which handles the registration of our service.  And finally, the service.Run () function, which handles the connection itself.  As before, we register our implementation, but this time with a slightly different method. <br><br>  The second largest change concerns the service methods themselves: the arguments and types of responses are slightly modified to take both the request and the response structure as arguments, and now only return an error.  In our methods, we set the answer, which is processed by go-micro. <br><br>  Finally, we no longer program the port.  Go-micro must be configured using environment variables or command line arguments.  To set the address, use MICRO_SERVER_ADDRESS =: 50051.  By default, Micro uses mdns (multicast dns) as a service discovery broker for local use.  Usually you do not use mdns to discover services in a production environment, but we want to avoid having to run something like Consul or etcd locally for testing.  More on this later. <br><br>  Let's update our Makefile to reflect this. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e is the flag of the environment variable, it allows you to transfer environment variables to your Docker container.  You must have a flag for each variable, for example -e ENV = staging -e DB_HOST = localhost, etc. <br><br>  Now, if you run $ make run, you will have a Dockerised service with service discovery.  So let's update our Cli tool to use it. <br><br><div class="spoiler">  <b class="spoiler_title">consignment-cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Here we imported go-micro libraries to create clients and replaced the existing connection code with the go-micro client code, which uses the service permission instead of directly connecting to the address. <br><br>  However, if you run it, it will not work.  This is because we are now running our service in the Docker container, which has its own mdns, separate from the mdns host we are currently using.  The easiest way to fix this is to make sure that both the service and the client are running in dockerland, so they both work on the same host and use the same network layer.  So let's create a make consignment-cli / Makefile and create several entries. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  As before, we want to compile our binary file for Linux.  When we run our docker image, we want to pass an environment variable to tell the go-micro command to use mdns. <br><br>  Now let's create a Dockerfile for our CLI tool: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  This is very similar to our service Dockerfile, except that it also retrieves our json data file. <br><br>  Now, when you run $ make run in your shippy-cli-consignment, you should see Created: true, just like before. <br><br>  Now it seems like a good time to take a look at the new Docker feature: multi-stage builds.  This allows us to use multiple Docker images in a single Dockerfile. <br><br>  This is especially useful in our case, since we can use one image to create our binary file with all the right dependencies.  And then use the second image to launch it.  Let's try this, I will leave detailed comments along with the code: <br><div class="spoiler">  <b class="spoiler_title">consignment-service / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Now I will go to the other Docker files and apply this new approach.  Oh, and don't forget to remove the $ go build from your Makefiles! <br><br><h3>  Ship service </h3><br>  Let's create the second service.  We have a service (shippy-service-consignment) that deals with the coordination of a lot of containers with a vessel that is best suited for this lot.  To comply with our lot, we must send the weight and number of containers to our new ship service, which will then find a ship that can handle this lot. <br><br>  Create a new directory in your <b>$ mkdir vessel-service</b> root directory, now create a subdirectory for our new protobuf services definition, <b>$ mkdir -p shippy-service-vessel / proto / vessel</b> .  Now let's create a new protobuf, <b>$ touch shippy-service-vessel / proto / vessel / vessel.proto</b> . <br><br>  Since the protobuf definition is really the core of our software design, let's start with it. <br><br><div class="spoiler">  <b class="spoiler_title">vessel / vessel.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  As you can see, this is very similar to our first service.  We create a service with one rpc method called FindAvailable.  This takes the type Specification and returns the type Response.  The Response type returns either a Vessel type or multiple ships using a repeating field. <br><br>  Now we need to create a Makefile to handle our build logic and our startup script.  <b>$ touch shippy-service-vessel / Makefile</b> .  Open this file and add the following: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  This is almost identical to the first Makefile we created for our consignment service, but notice that the service names and ports have changed a bit.  We cannot launch two docking containers on the same port, so we use port forwarding for Dockers so that this service redirects from 50051 to 50052 on the host network. <br><br>  Now we need a Dockerfile using our new multi-step format: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Finally, we can write our implementation: <br><br><div class="spoiler">  <b class="spoiler_title">vessel-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  We now turn to the interesting part.  When we create a shipment, we need to change our cargo handling service in order to contact the ship search service, find the ship and update the ship_id parameter in the created lot: <br><br><div class="spoiler">  <b class="spoiler_title">shippy / consignment-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Here we have created a client instance for our vessel service, which allows us to use the name of the service, i.e.  shipy.service.vessel to call the ship's service as a client and interact with its methods.  In this case, only one method (FindAvailable).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We ship the batch weight along with the number of containers we want to ship as a specification for the vessel‚Äôs service. Which returns us to the vessel corresponding to this specification. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Update the consignment-cli / consignment.json file, delete the hard-coded ship_id, because we want to confirm that our ship search service is working. So let's add some more containers and increase the weight.</font></font> For example: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now run </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ make build &amp;&amp; make run</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in consignment-cli. </font><font style="vertical-align: inherit;">You should see the answer with a list of generated shipments. </font><font style="vertical-align: inherit;">In your batches, you should see that the vessel_id parameter is set. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have two interconnected microservice and command line interface! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next part of this series, we will look at saving some of this data using MongoDB. </font><font style="vertical-align: inherit;">We will also add a third service and use docker-compose to locally manage our growing container ecosystem. </font></font><br><br> <a href="https://habr.com/ru/post/425653/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first part of the </font></font></a> <br> <a href="https://github.com/EwanValentine/shippy"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original repository EwanValentine</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/455812/">https://habr.com/ru/post/455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45580/index.html">Computer addiction does not exist</a></li>
<li><a href="../455800/index.html">Matrix 1.0 - Decentralized Messaging Protocol Release</a></li>
<li><a href="../455802/index.html">How to collect "Olympic" thanks to email-mailings. Case Black Star</a></li>
<li><a href="../455806/index.html">The birth and death of the album: we understand how music formats have changed over the past 100 years</a></li>
<li><a href="../455808/index.html">Submission of auto-requests on the FTS website in USR on python</a></li>
<li><a href="../455816/index.html">How to create a cool action for Google Assistant. Just AI's life hacking</a></li>
<li><a href="../45582/index.html">Another testing of 5 browsers from extremetech.com</a></li>
<li><a href="../455820/index.html">VM performance analysis in VMware vSphere. Part 2: Memory</a></li>
<li><a href="../455826/index.html">Auto watering colors with remote control</a></li>
<li><a href="../455828/index.html">Scientists have discovered new exotic forms of synchronization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>