<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "Learning Java EE. Modern programming for large enterprises ¬ª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! 

 This book describes the new generation of Java EE. You will go on a journey through Java EE in the context of the modern world of microser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "Learning Java EE. Modern programming for large enterprises ¬ª</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/company/piter/blog/418025/"><img src="https://habrastorage.org/webt/ct/ac/t4/ctact4noq-x7eg0x5gqj_8kbm7g.jpeg" align="left" alt="image"></a>  Hi Habr! <br><br>  This book describes the new generation of Java EE.  You will go on a journey through Java EE in the context of the modern world of microservices and containers.  Rather, it is not an API syntax guide ‚Äî the concepts and methodologies outlined here reflect the real experience of the person who himself recently walked this path, paying close attention to the obstacles encountered and is willing to share his knowledge.  In various situations, starting with creating a package for testing and cloud use, this book will be an ideal companion for both beginners and experienced developers looking to understand more than just an API, and help them rebuild their thinking to create an architecture of modern applications in Java EE . <br><a name="habracut"></a><br><h3>  Sequence of execution </h3><br>  Business processes implemented in enterprise applications describe specific process flows.  For the involved business scenarios, this is either a process of synchronous requests and responses, or asynchronous processing of the initiated process. <br><br>  Business scripts are called in separate threads, one by one for a request or a call.  Flows are created by the container and placed in the drive for reuse after the call has been successfully processed.  By default, business processes defined in application classes, as well as end-to-end tasks, such as transactions, are performed sequentially. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Synchronous execution </h3><br>  A typical scenario where an HTTP request for a response from a database is implemented as follows.  One thread processes the request coming into the loop, for example, JAX-RS UsersResource, by inverting the control principle;  The JAX-RS resource method is called by the container.  A resource embeds and uses an UserManagement EJB object, which is also implicitly called by the container.  All operations are performed by intermediaries synchronously.  The EJB will use the entity manager to store the User entity, and as soon as the business method that initiated the current active transaction is finished, the container will attempt to commit the transaction to the database.  Depending on the result of the transaction, the resource method of the circuit resumes operation and generates a response to the client.  Everything happens synchronously, at this time the client is blocked and waiting for a response. <br><br>  Synchronous execution involves processing synchronous CDI events.  They separate the triggering of domain events from their processing, however, events are processed synchronously.  There are several transaction monitoring methods.  If a transaction stage is specified, the event can be processed at this stage ‚Äî while the transaction is committed, before it is completed, after completion, in the event of a unsuccessful or successful transaction.  By default or when a transaction is inactive, CDI events are processed as soon as they occur.  This allows engineers to implement complex solutions ‚Äî for example, using events that occur only after successfully adding entities to the database.  Be that as it may, in all cases the processing is performed synchronously. <br><br><h3>  Asynchronous execution </h3><br>  Synchronous execution of tasks meets the requirements of many business scenarios, but there are times when asynchronous behavior is needed.  In the Java EE environment, there are a number of restrictions on the application's use of threads.  The container manages resources and streams and puts them into the drive.  External concurrency control utilities are outside the container and they know nothing about these threads.  Therefore, the application code should not run and manage its threads.  To do this, it uses the Java EE functions.  There are several APIs with built-in asynchronous support. <br><br>  <b>Asynchronous EJB Methods</b> <br><br>  The easiest way to implement asynchronous behavior is to use the @Asynchronous annotation for an EJB business method or an EJB class.  Calls to these methods are immediately returned, sometimes with a response like Future.  They are executed in a separate thread, managed by the container.  This works well for simple scripts, but is limited to EJB objects: <br><br><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre> <br>  <b>Performance Management Service</b> <br><br>  For asynchronous execution of tasks in managed CDI objects or using Java SE concurrency control utilities, Java EE includes container-managed versions of the ExecutorService and ScheduledExecutorService functions.  They are used to implement asynchronous tasks in container-managed threads.  Instances of the ManagedExecutorService and the ManagedScheduledExecutorService are embedded in the application code.  They can be used to execute custom logic, but are most effective when combined with Java SE concurrency control utilities, such as complemented future values.  The following example shows the creation of padded future values ‚Äã‚Äãusing container-managed streams: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Resource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.enterprise.concurrent.ManagedExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CompletableFuture; <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRandomPi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxDecimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(maxDecimalPlaces) + <span class="hljs-number"><span class="hljs-number">1</span></span>, mes) .thenApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculatePi); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  The Calculator object returns a complemented future double value, which can still be calculated when the calling context resumes.  It can be queried when the calculations are completed, as well as merged with subsequent calculations.  Regardless of where new threads are required in a corporate application, you should use Java EE functionality to manage them. <br><br>  <b>Asynchronous CDI events</b> <br><br>  CDI events can also be processed asynchronously.  In this case, the container also provides a stream for handling events.  To describe an asynchronous event handler, the method is annotated with @ObservesAsync, and the event is activated using the fireAsync () method.  The following code snippets demonstrate asynchronous CDI events: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarManufacturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CarFactory carFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Event&lt;CarCreated&gt; carCreated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Car </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manufactureCar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Specification spec)</span></span></span><span class="hljs-function"> </span></span>{ Car car = carFactory.createCar(spec); carCreated.fireAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CarCreated(spec)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } }</code> </pre> <br>  The event handler is called in its own container-managed thread: <br><br><pre> <code class="hljs cs">import javax.enterprise.<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.ObservesAsync; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedCarListener</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCarCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">@ObservesAsync CarCreated </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre> <br>  For backward compatibility reasons, synchronous CDI events can also be handled in an asynchronous EJB method.  Thus, events and handlers are defined as synchronous, and the handler method is an EJB business method with the @Asynchronous annotation.  Before asynchronous events were added to the CDI standard for Java EE 8, this was the only way to implement this function.  To avoid confusion in Java EE 8 and later versions of this implementation, it is better to avoid. <br><br>  <b>Visibility areas for asynchronous processing</b> <br><br>  Since the container does not have information on how long asynchronous tasks can run, the use of scopes in this case is restricted.  Objects with a scope within a request or session that were available at the start of an asynchronous task will not necessarily be active throughout its implementation - the request and session may end well before its completion.  Thus, threads that perform asynchronous tasks, such as those provided by the service of scheduled executors or asynchronous events, may not have access to instances of managed objects with a scope within a request or session that were active during a call.  The same applies to accessing links to embedded instances, for example, in lambda methods that are part of synchronous execution. <br><br>  This must be taken into account when modeling asynchronous tasks.  All information about a specific call must be provided at the time of launching the task.  However, an asynchronous task can have its own instances of managed objects with limited scope. <br><br>  <b>Execution at a specified time</b> <br><br>  Business scripts can be invoked not only from the outside, for example, via an HTTP request, but also from within the application ‚Äî a task that runs at a specific time. <br><br>  In the Unix world, the functionality for running periodic tasks is popular - these are the tasks of the scheduler.  EJB objects provide similar capabilities using EJB timers.  Timers invoke business methods at specified intervals or after a specified time.  The following example describes a cyclic timer that runs every ten minutes: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Schedule; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Startup; <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Startup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeriodicJob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Schedule</span></span>(minute = <span class="hljs-string"><span class="hljs-string">"*/10"</span></span>, hour = <span class="hljs-string"><span class="hljs-string">"*"</span></span>, persistent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   10  } }</span></span></code> </pre> <br>  Any EJB objects ‚Äî singletones, managed objects with or without state preservation ‚Äî can create timers.  However, in most scenarios it makes sense to create timers only for singletons.  The delay is set for all active objects.  Usually it is needed in order to launch scheduled tasks on time, which is why it is used in singleton.  For the same reason, in this example, the EJB object must be active when the application starts.  This ensures that the timer starts working immediately. <br><br>  If the timer is described as permanent, its lifetime will extend over the entire life cycle of the JVM.  The container is responsible for maintaining persistent timers, usually in the database.  Permanent timers, which should work while the application is not available, are enabled at startup.  It also allows you to use the same timers with multiple instances of an object.  Constant timers with the appropriate server configuration is the right solution if you need to run a business process exactly once on multiple servers. <br><br>  Timers that are created automatically using <a href="https://habr.com/users/schedule/" class="user_link">Schedule</a> annotation are described using Unix-like cron expressions.  For greater flexibility, EJB timers are described programmatically using the container provided by the timer service, which creates callback methods Timers and <a href="https://habr.com/users/timeout/" class="user_link">Timeout</a> . <br><br>  Periodic and deferred tasks can also be described outside of the EJB components using the container-managed service of scheduled implementers.  An instance of the ManagedScheduledExecutorService that performs tasks after a specified delay or at a specified interval is embedded in the managed components.  These tasks will be implemented in streams managed by containers: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periodic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedScheduledExecutorService mses; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAsyncJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mses.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); mses.scheduleAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  Calling the startAsyncJobs () method will launch the execute () function in a controlled stream ten seconds after the call and then every ten seconds after the first minute. <br><br>  <b>Asynchrony and reactivity in JAX-RS</b> <br><br>  JAX-RS supports asynchronous behavior, so as not to unnecessarily block request flows on the server side.  Even if the HTTP connection is waiting for a response, the request flow may continue to process other requests while the server is running a long process.  Query streams are combined in a container, and this query store has a specific size.  In order not to waste the request flow, JAX-RS asynchronous resource methods create tasks that run when the request flow returns and can be reused.  The HTTP connection resumes and responds when the asynchronous task completes or expires.  The following example shows the asynchronous JAX-RS resource method: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Consumes(MediaType.APPLICATION_JSON)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">@POST</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletionStage&lt;Response&gt; createUserAsync(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; createUser(user), mes); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Response createUser(User user) { userStore.create(user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.accepted().build(); } }</code> </pre> <br>  In order for the request flow not to be busy for too long, the JAX-RS method must end quickly.  This is due to the fact that the resource method is called from the container by means of the inversion control.  The result obtained at the completion stage will be used to resume the client connection at the end of processing. <br><br>  Returning completion stages is a relatively new technology in the JAX-RS API.  If you need to describe the delay and at the same time provide greater flexibility in the asynchronous response, then you can include the AsyncResponse type in the method.  This approach is demonstrated in the following example: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AsyncResponse</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Suspended</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">Path</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>") @Consumes(MediaType.APPLICATION_JSON) public class UsersResource { @<span class="hljs-keyword"><span class="hljs-keyword">Resource</span></span> ManagedExecutorService mes; ‚Ä¶ @<span class="hljs-keyword"><span class="hljs-keyword">POST</span></span> public void createUserAsync(User user, @Suspended AsyncResponse response) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeout</span></span>(5, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SECONDS</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeoutHandler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.status</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Status</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SERVICE_UNAVAILABLE</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.build</span></span>())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">mes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(() <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">createUser</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span>))); } }</code> </pre> <br>  Thanks to the created timeouts, the client request will not wait indefinitely, but only until the result is received or the call has timed out.  However, the calculations will continue as they are performed asynchronously.  For JAX-RS resources that are implemented as EJB objects, you can use the @Asynchronous annotation in order not to invoke asynchronous business methods explicitly through the service provider. <br><br>  The JAX-RS client also supports asynchronous behavior.  Depending on the requirements, it makes sense not to block it during HTTP calls.  The previous example shows how to set delays for client requests.  For long-running and especially parallel external system calls, it is better to use asynchronous and reactive behavior. <br><br>  Consider a few server applications that provide weather information.  The client component refers to all of these applications and calculates the average weather forecast.  Ideally, access to the systems could be parallel: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Client client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WebTarget&gt; targets; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client = ClientBuilder.newClient(); targets = ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageForecast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .map(CompletableFuture::join) .reduce(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculateAverage) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CompletableFuture&lt;Forecast&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .map(t -&gt; CompletableFuture.supplyAsync(() -&gt; t .request(MediaType.APPLICATION_JSON_TYPE) .get(Forecast.class), mes)) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast first, Forecast second)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@PreDestroy</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client.close(); } }</code> </pre> <br>  The invokeTargetsAsync () method calls the available objects asynchronously, using the service of scheduled artists.  CompletableFuture descriptors are returned and used to calculate averaged results.  The start of the join () method will be blocked until the call is completed and the results are received. <br><br>  Objects invoked asynchronously start and expect a response from several resources at once, possibly slower.  In this case, waiting for responses from the weather service resources takes as much time as you have to expect the slowest response, rather than all responses together. <br><br>  The latest version of JAX-RS has built-in support for the completion steps, which reduces the stereotypical code in applications.  As in the case of padding values, the call immediately returns the code of the completion stage for further use.  The following example shows JAX-RS reactive client functions using an rx () call: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Forecast</span></span> getAverageForecast() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>((l, r) -&gt; l.thenCombine(r, this::calculateAverage)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(s -&gt; s.toCompletableFuture().<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()) .orElseThrow(() -&gt; new <span class="hljs-type"><span class="hljs-type">IllegalStateException</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CompletionStage</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Forecast</span></span>&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(t -&gt; t .request(<span class="hljs-type"><span class="hljs-type">MediaType</span></span>.<span class="hljs-type"><span class="hljs-type">APPLICATION_JSON_TYPE</span></span>) .rx() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">Forecast</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>)) .collect(<span class="hljs-type"><span class="hljs-type">Collectors</span></span>.toList()); }</code> </pre> <br>  In the example above, it is not necessary to look for the service of scheduled artists ‚Äî the JAX-RS client will manage this itself.  Before the rx () method appeared, an explicit call to async () was used in clients.  This method behaved similarly, but returned only Future objects.  The use of a reactive approach in clients is optimal for most projects. <br>  As you can see, in the Java EE environment, a container-managed executor service is involved. <br><br><h3>  Concepts and design principles in modern Java EE </h3><br>  The Java EE API is based on conventions and design principles that are spelled out in the form of standards.  Software engineers will recognize familiar API patterns and approaches to application development.  The goal of Java EE is to encourage consistent use of the API. <br><br>  The main principle of applications focused primarily on the implementation of business scenarios, sounds like this: technology should not interfere.  As already mentioned, engineers should be able to focus on the implementation of business logic, without spending most of their time on technological and infrastructure issues.  Ideally, the domain logic is implemented in simple Java and is supplemented with annotations and other properties supported by the corporate environment without affecting the code of the domain and without complicating it.  This means that the technology does not require much attention of engineers and does not impose too large restrictions.  Previously, the J2EE environment required many very complex solutions.  To implement interfaces and extend base classes, you had to use managed objects and persistent storage objects.  This complicated the domain logic and made testing difficult. <br><br>  In Java EE, the domain logic is implemented as simple Java classes with annotations, according to which the container solves certain corporate tasks during the execution of the application.  The practice of creating clean code often involves writing code more beautiful than convenient to reuse.  Java EE supports this approach.  If, for some reason, you need to remove the technology and leave the pure domain logic, this is done by simply deleting the corresponding annotations. <br><br>  As we will see in Chapter 7, such an approach to programming implies the need for testing, since for programmers most of the Java EE specifications are nothing more than annotations. <br><br>  The entire API adopts the design principle called inversion of control (IoC), in other words, ‚Äúdo not call us, we will call ourselves‚Äù.  This is especially noticeable in application loops, such as JAX-RS resources.  Resource methods are described using Java method annotations, which are later called by the container in the appropriate context.  The same is true for dependency injection, for which you have to choose generators or take into account such end-to-end tasks as interceptors.  Application developers can focus on bringing logic and relationship description to life, leaving the implementation of technical details in a container.  Another example, not so obvious, is the description of converting Java objects to JSON and vice versa using JSON-B annotations.  Objects are converted not only in an explicit, programmed form, but also implicitly, in a declarative style. <br><br>  Another principle that allows engineers to effectively use this technology is programming by convention.  By default, Java EE has a specific behavior defined for most use cases.  If it is insufficient or does not meet the requirements, the behavior can be redefined, often at several levels. <br>  There are many examples of programming by agreement.  One of them is the use of JAX-RS resource methods that transform Java functionality into HTTP responses.  If the standard JAX-RS behavior with respect to the responses does not meet the requirements, you can use the return response type Response.  Another example is the specification of managed objects, which is usually implemented using annotations.  In order to change this behavior, you can use the XML-descriptor beans.xml.  For programmers, it‚Äôs very convenient that in the modern world of Java EE, corporate applications are developed in a pragmatic and high-performance way, which usually does not require such intensive use of XML as before. <br><br>  As for the productivity of programmers, another important principle for developing in Java EE is that this platform requires integration into a container of various standards.  Because containers support a specific set of APIs ‚Äî and if they support all of the Java EE APIs ‚Äî that‚Äôs the case, it‚Äôs also required that the API implementations allow for easy integration of other APIs.  The advantage of this approach is the ability of JAX-RS resources to use JSON-B conversion and Bean Validation technology without additional explicit configuration, with the exception of annotations.  In the previous examples, we saw how the functions defined in the individual standards can be used together without additional effort.  This is one of the biggest advantages of the Java EE platform.  The generic specification guarantees a combination of separate standards among themselves.  Programmers can rely on certain functions and implementation provided by the application server. <br><br><h3>  Convenient, high-quality code </h3><br>  Programmers generally agree that you should strive to write high-quality code.  However, not all technologies are equally well suited for this. <br><br>  As mentioned at the beginning of the book, business logic should be in the spotlight when developing applications.  In case of changes in business logic or the emergence of new knowledge, it is necessary to update the domain model, as well as the source code.  To create and maintain a high-quality domain model and the source code as a whole, iterative refactoring is required.  Efforts aimed at deepening the understanding of the subject area are described in the concept of problem-oriented design. <br><br>  There is a lot of literature on refactoring at the code level.  After the business logic is presented in the form of a code and verified by tests, programmers should spend some time and make efforts to rethink and improve the first option.  This applies to identifiers of names, methods and classes.    ,      . <br><br>   -           .  ,  ,    ‚Äî  , ,    -    .    ‚Äî    ,            ,    .        .      ,   ,         . <br><br>  ,        .    ,      . <br><br>     ,    ,  ,        .    ,   ,     -      .  ,      ,    ,       -  ,  .       ,      .       7. <br><br>       ,  .      ,    ,   ,    . Java EE     :  ,    ,   .     . <br><br>        .  ,        , ,         .             .   6  ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, it is recommended to constantly reorganize the code and improve its quality. Software projects are often created to introduce new revenue-generating functions, rather than to improve existing functionality. The problem is that refactoring and improving the quality of the code at first glance does not bring benefits to the business. This is certainly not the case. In order to achieve stable speed and integrate new functions with satisfactory quality, it is necessary to revise existing functions. Ideally, the refactoring cycles should be embedded in the project outline. Experience shows that project managers are often unaware of this problem. However, a team of software engineers is responsible for maintaining quality.</font></font><br><br><h3>  about the author </h3><br> <b>  (Sebastian Daschner)</b> ‚Äî Java-,    ,    Java (EE).     JCP,     Java EE,   JSR   370  374         .        Java      Java  - Oracle. <br><br>       IT-,  JavaLand, JavaOne  Jfokus.    JavaOne Rockstar   JavaOne 2016.     Java   (Steve Chin)        Java,   .     JOnsen ‚Äî  Java,          . <br><br><h3>   </h3><br> <b>  (Melissa McKay)</b> ‚Äî     15-         ,    .       Java-,       .       ,       ,       . <br><br>     JCrete   ()         JOnsen  .      IT-  ,  JavaOne4Kids  JCrete4Kids.       JavaOne 2017     Denver Java User Group. <br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/new/product/izuchaem-java-ee-sovremennoe-programmirovanie-dlya-bolshih-predpriyatiy">the publisher site.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610774/978544610774_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610774/978544610774_p.pdf">Excerpt</a> <br><br>    20%   ‚Äî <b>Java EE</b> </div><p>Source: <a href="https://habr.com/ru/post/418025/">https://habr.com/ru/post/418025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418011/index.html">One-page and SEO. Optimization secrets</a></li>
<li><a href="../418013/index.html">The Intel Core i7-8086K (Part 3)</a></li>
<li><a href="../418015/index.html">New Vasyuki. Innovative development of Moscow until 2100</a></li>
<li><a href="../418017/index.html">Analysis of the behavior of the Pegasus Trojan in the network</a></li>
<li><a href="../418023/index.html">Pointers in C are more abstract than they might seem.</a></li>
<li><a href="../418027/index.html">Microservice blitz</a></li>
<li><a href="../418029/index.html">ReactOS 0.4.9: Hayters will have to look for new arguments</a></li>
<li><a href="../418031/index.html">Mass stacking of ML models in production: is it real or not?</a></li>
<li><a href="../418035/index.html">Introduction to the Timeline in Unity</a></li>
<li><a href="../418037/index.html">Mobile testers get ready. Welcome to Avito Mobile Testing Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>