<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C # is a multi-paradigm language. Recently, the roll has been outlined in the direction of the functional area . You can go ahead and add some more ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional C #</h1><div class="post__text post__text-html js-mediator-article">  C # is a multi-paradigm language.  Recently, the roll has been outlined in the direction of the <a href="https://habrahabr.ru/post/280978/">functional area</a> .  You can go ahead and add some more extension methods that allow you to write less code without ‚Äúgetting into‚Äù the F # territory. <br><a name="habracut"></a><br><h4>  PipeTo </h4><br>  While the <a href="https://github.com/dotnet/roslyn/issues/5445">Pipe Operator is</a> not going to include the next release.  Well, you can do with the method. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TResult PipeTo&lt;TSource, TResult&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> TSource source, Func&lt;TSource, TResult&gt; func) =&gt; func(source);</code> </pre> <br>  <b>Imperative option</b> <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someData = query .Where(x =&gt; x.IsActive) .OrderBy(x =&gt; x.Id) .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Ok(someData); }</code> </pre><br>  <b>With PipeTo</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; query .Where(x =&gt; x.IsActive) .OrderBy(x =&gt; x.Id) .ToArray() .PipeTo(Ok);</code> </pre> <br>  Did you notice?  In the first option, I needed to return the view to the declaration of the variable and then go to Ok.  With PipeTo execution-flow strictly left-to-right, top-down. <br><br><h4>  Either </h4><br>  In the real world, algorithms often contain branching than linear ones: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(x =&gt; x.Id == id) .SingleOrDefault() .PipeTo(x =&gt; x != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? Ok(x) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(‚ÄúNot Found‚Äù));</code> </pre> <br>  Looks not so good.  Fix it with the <code>Either</code> method: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TOutput Either&lt;TInput, TOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> TInput o, Func&lt;TInput, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; condition, Func&lt;TInput, TOutput&gt; ifTrue, Func&lt;TInput, TOutput&gt; ifFalse) =&gt; condition(o) ? ifTrue(o) : ifFalse(o); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(x =&gt; x.Id == id) .SingleOrDefault() .Either(x =&gt; x != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, Ok, _ =&gt; (IActionResult)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(<span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>));</code> </pre> <br>  Add a null overload: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TOutput Either&lt;TInput, TOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> TInput o, Func&lt;TInput, TOutput&gt; ifTrue, Func&lt;TInput, TOutput&gt; ifFalse) =&gt; o.Either(x =&gt; x != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ifTrue, ifFalse); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(x =&gt; x.Id == id) .SingleOrDefault() .Either(Ok, _ =&gt; (IActionResult)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(<span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>));</code> </pre> <br>  Unfortunately, type inference in C # is not perfect yet, so I had to add an explicit caste to an <code>IActionResult</code> . <br><br><h4>  Do </h4><br>  Get-methods of controllers do not have to create side effects, but sometimes "very necessary". <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Do&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj, Action&lt;T&gt; action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { action(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(x =&gt; x.Id == id) .Do(x =&gt; ViewBag.Title = x.Name) .SingleOrDefault() .Either(Ok, _ =&gt; (IActionResult)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(<span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>));</code> </pre> <br><blockquote>  With this kind of code organization, a side effect with Do is sure to catch your eye during code review.  Although in general, using Do is a very controversial idea. </blockquote><br><h4>  ById </h4><br>  Do not find that repeating constantly <code>q.Where(x =&gt; x.Id == id).SingleOrDefault()</code> chore? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TEntity ById&lt;TKey, TEntity&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;TEntity&gt; queryable, TKey id) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TKey</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TKey</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>, <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TKey</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IEquatable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TKey</span></span>&gt; =&gt; queryable.SingleOrDefault(x =&gt; x.Id.Equals(id)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .ById(id) .Do(x =&gt; ViewBag.Title = x.Name) .Either(Ok, _ =&gt; (IActionResult)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(<span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>));</code> </pre> <br>  And if I don‚Äôt want to get the whole entity and I need a projection: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TProjection ById&lt;TKey, TEntity, TProjection&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;TEntity&gt; queryable, TKey id, Expression&lt;Func&lt;TEntity, TProjection&gt;&gt; projectionExpression) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TKey : IComparable, IComparable&lt;TKey&gt;, IEquatable&lt;TKey&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TKey</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TProjection</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TKey</span></span>&gt; =&gt; queryable.Select(projectionExpression).SingleOrDefault(x =&gt; x.Id.Equals(id)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; query .ById(id, x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> {Id = x.Id, Name = x.Name, Data = x.Data}) .Do(x =&gt; ViewBag.Title = x.Name) .Either(Ok, _ =&gt; (IActionResult)<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotFoundResult(<span class="hljs-string"><span class="hljs-string">"Not Found"</span></span>));</code> </pre> <br>  I think that by the current moment <code>(IActionResult)new NotFoundResult("Not Found"))</code> has already become familiar, and you yourself can easily write the <code>OkOrNotFound</code> method <br><br><h4>  Paginate </h4><br>  Perhaps there are no applications that work with data without paginated output. <br><br>  Instead: <br><br><pre> <code class="cs hljs">.Skip((paging.Page - <span class="hljs-number"><span class="hljs-number">1</span></span>) * paging.Take) .Take(paging.Take);</code> </pre> <br>  You can do this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPagedEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> TotalCount { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; Paginate&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IOrderedQueryable&lt;T&gt; queryable, IPaging paging) =&gt; queryable .Skip((paging.Page - <span class="hljs-number"><span class="hljs-number">1</span></span>) * paging.Take) .Take(paging.Take); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IPagedEnumerable&lt;T&gt; ToPagedEnumerable&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IOrderedQueryable&lt;T&gt; queryable, IPaging paging) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> =&gt; From(queryable.Paginate(paging).ToArray(), queryable.Count()); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IPagedEnumerable&lt;T&gt; From&lt;T&gt;(IEnumerable&lt;T&gt; inner, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCount) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PagedEnumerable&lt;T&gt;(inner, totalCount); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IPaging paging</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(x =&gt; x.IsActive) .OrderBy(x =&gt; x.Id) .ToPagedEnumerable(paging) .PipeTo(Ok);</code> </pre> <br><h4>  <s>IQueryableSpecification</s> <a href="https://habrahabr.ru/post/325280/">IQueryableFilter</a> </h4><br>  If you've read this far, you might like the <a href="https://habrahabr.ru/post/325280/">idea of ‚Äã‚Äãarranging Where and OrderBy in LINQ expressions in another way</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyNiceSpec</span></span> : <span class="hljs-title"><span class="hljs-title">AutoSpec</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyNiceEntity</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Code { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Description { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyNiceSpec spec</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Where(spec) .OrderBy(spec) .ToPagedEnumerable(paging) .PipeTo(Ok);</code> </pre><br>  In this case, it sometimes makes sense to use <code>Where</code> before calling <code>Select</code> , and sometimes after.  Add a <code>MaybeWhere</code> method that can work with both <code>IQueryableSpecification</code> and <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; MaybeWhere&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; source, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> spec) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = spec <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IQueryableSpecification&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specification != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { source = specification.Apply(source); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = spec <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { source = source.Where(expr); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source; }</code> </pre> <br>  And now you can write a method that takes into account different options: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IPagedEnumerable&lt;TDest&gt; Paged&lt;TEntity, TDest&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryableProvider queryableProvider, IPaging spec , Expression&lt;Func&lt;TEntity, TDest&gt;&gt; projectionExpression) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TDest</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> =&gt; queryableProvider .Query&lt;TEntity&gt;() .MaybeWhere(spec) .Select(projectionExpression) .MaybeWhere(spec) .MaybeOrderBy(spec) .OrderByIdIfNotOrdered() .ToPagedEnumerable(spec);</code> </pre> <br>  Or using <a href="https://github.com/AutoMapper/AutoMapper/wiki/Queryable-Extensions">Queryable Extensions AutoMapper</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IPagedEnumerable&lt;TDest&gt; Paged&lt;TEntity, TDest&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryableProvider queryableProvider, IPaging spec) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TDest</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> =&gt; queryableProvider .Query&lt;TEntity&gt;() .MaybeWhere(spec) .ProjectTo&lt;TDest&gt;() .MaybeWhere(spec) .MaybeOrderBy(spec) .OrderByIdIfNotOrdered() .ToPagedEnumerable(spec);</code> </pre> <br>  If you think that <code>IPaging</code> , <code>IQueryableSpecififcation</code> and <code>IQueryableOrderBy</code> on one object is useless, then your version is: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IPagedEnumerable&lt;TDest&gt; Paged&lt;TEntity, TDest&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryableProvider queryableProvider, IPaging paging, IQueryableOrderBy&lt;TDest&gt; queryableOrderBy, IQueryableSpecification&lt;TEntity&gt; entitySpec = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, IQueryableSpecification&lt;TDest&gt; destSpec = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TDest</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span> =&gt; queryableProvider .Query&lt;TEntity&gt;() .EitherOrSelf(entitySpec, x =&gt; x.Where(entitySpec)) .ProjectTo&lt;TDest&gt;() .EitherOrSelf(destSpec, x =&gt; x.Where(destSpec)) .OrderBy(queryableOrderBy) .ToPagedEnumerable(paging);</code> </pre> <br>  As a result, we get three lines of code for a method that filters, sorts, and provides paginated output for any data sources that support LINQ. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyNiceSpec spec</span></span></span><span class="hljs-function">)</span></span> =&gt; query .Paged&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, MyNiceEntity, MyNiceDto&gt;(spec) .PipeTo(Ok);</code> </pre> <br>  Unfortunately, the method signatures in C # look monstrous because of the abundance of generics.  Fortunately, in the application code method parameters can be omitted.  The signatures of LINQ extensions look pretty much the same.  How often do you specify the type returned from <code>Select</code> ?  Praise the <code>var</code> who saved us from this torment. </div><p>Source: <a href="https://habr.com/ru/post/325308/">https://habr.com/ru/post/325308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325296/index.html">Experience in developing an automated proctoring system to confirm the results of online exams</a></li>
<li><a href="../325298/index.html">An overview of hash-opening tools: John the Ripper password cracker and MDCrack</a></li>
<li><a href="../325300/index.html">Certificates from StartCom and WoSign finally turned into a pumpkin</a></li>
<li><a href="../325302/index.html">Necurs, one of the largest botnets in the world, received a DDoS module</a></li>
<li><a href="../325304/index.html">How we ported the software / hardware solution from SPARC Solaris to AMD64 Linux and virtualized it all</a></li>
<li><a href="../325310/index.html">Development ‚Üí Kazakhstan: How I helped to submit 100 forms of tax reporting. Continuation 300 form</a></li>
<li><a href="../325312/index.html">The right to oblivion does not apply to data in business registers: decision of the Court of Justice of the European Union of March 9, 2017</a></li>
<li><a href="../325316/index.html">MySQL sample rotation</a></li>
<li><a href="../325318/index.html">How I stopped being afraid and re-invented QML</a></li>
<li><a href="../325320/index.html">Node.js Streams and Reactive Programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>