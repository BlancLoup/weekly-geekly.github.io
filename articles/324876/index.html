<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do I make SQLAlchemy handy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that SQLAlchemy is the most popular ORM in Python. It allows you to write much more advanced things than most fellows Active Record. Bu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How do I make SQLAlchemy handy</h1><div class="post__text post__text-html js-mediator-article"><p>  It's no secret that <a href="https://www.sqlalchemy.org/">SQLAlchemy</a> is the most popular ORM in Python.  It allows you to write much more advanced things than most fellows Active Record.  But the charge for this is more complex code, and in simple tasks like <a href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> it is annoying. </p><br><p>  How I have made Alchemy convenient, using the experience of the best Active Record ORM, read under the cut. </p><br><a name="habracut"></a><br><h1 id="vvedenie">  Introduction </h1><br><p>  I started using SQLAlchemy, having previously worked with <a href="http://rusrails.ru/active-record-basics">Active Record</a> in Ruby on Rails, with <a href="http://laravel.su/docs/5.0/eloquent">Eloquent ORM</a> in PHP and with <a href="https://docs.djangoproject.com/en/1.10/topics/db/">Django ORM</a> and <a href="https://habrahabr.ru/post/207110/">Peewee</a> in Python.  All these <a href="https://ru.wikipedia.org/wiki/ActiveRecord">Active Record</a> ORM have a concise code, and I really like them. </p><br><p>  Alchemy is very good: it can build quite complex queries, and the <a href="http://designpatternsphp.readthedocs.io/ru/latest/Structural/DataMapper/README.html">Data Mapper</a> pattern also rules.  But, alas, after Active Record, the Alchemy code seems too complicated, and this is a price to pay for flexibility. </p><br><p>  During the year I worked with Alchemy on a complex project, and realized that for complete happiness I want to have: </p><br><ol><li> Convenient <a href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> : for a simple <code>create</code> in Alchemy, you need to create an object, add it to the <a href="http://docs.sqlalchemy.org/en/latest/orm/session_basics.html">session</a> , and make it flush </li><li>  Dynamic construction of filters / sorting based on <em>magic strings</em> as in <a href="https://docs.djangoproject.com/en/1.10/topics/db/queries/">Django</a> : <code>Post.objects.filter(user__name__startswith='John')</code> </li><li>  Attached <a href="http://docs.sqlalchemy.org/en/latest/orm/tutorial.html%3Fhighlight%3Deager%2520load">eager load</a> , when you need to immediately upload a post with a comment, and to the post of its user (well, it <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">is</a> , but not very convenient) </li><li>  Informative <code>__repr__</code> : <code>print(post)</code> gives something like <code>&lt;myapp.models.Post at 0x04287A50&gt;</code> , it is not suitable for debugging </li></ol><br><p>  I sadly recalled the Active Record ORM, where all this was (of course, in each ORM there were not all features, but most).  As time went on, the project became more complicated, and in the end could not stand it and decided the tasks described. </p><br><p>  The solution is packaged in a <a href="https://github.com/absent1706/sqlalchemy-mixins">well-tested and documented package</a> .  Works on a combat project and feels very good. </p><br><div class="spoiler">  <b class="spoiler_title">There are ready-made solutions, you say!</b> <div class="spoiler_text"><p>  Yes, there is, but they are either hard to implement, or sharpened for a specific framework, or poorly documented. <br>  I wanted to have a <em>universal, easily connectable</em> solution, for example, to write </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ActiveRecordMixin <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Base, ActiveRecordMixin)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  and have ready Active Record. <br>  The options <a href="https://github.com/mardix/active-alchemy/">"initialize Alchemy only through me"</a> and <a href="https://github.com/kofrasa/flask-activerecord">additions to flask-sqlalchemy are</a> no good. </p><br><p>  What is not satisfied with the specific packages, see <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p></div></div><br><p>  More details about each task - below in the article. </p><br><p>  <strong>About examples in the article</strong> </p><br><p>  I will give examples for a simple blog with typical entities <code>User</code> , <code>Post</code> , <code>Comment</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Database schema and ORM code</b> <div class="spoiler_text"><p><img src="http://i.piccy.info/i9/48bcc885c5ac01ac036cccfb9c4cbe74/1489598411/10896/1127895/diagram.png" alt="DB"></p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Base)</span></span></span><span class="hljs-class">:</span></span> __tablename__ = <span class="hljs-string"><span class="hljs-string">'user'</span></span> id = Column(Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) name = Column(String) posts = relationship(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Base)</span></span></span><span class="hljs-class">:</span></span> __tablename__ = <span class="hljs-string"><span class="hljs-string">'post'</span></span> id = Column(Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) body = Column(String) user_id = Column(Integer, ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)) user = relationship(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) comments = relationship(<span class="hljs-string"><span class="hljs-string">'Comment'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Base)</span></span></span><span class="hljs-class">:</span></span> __tablename__ = <span class="hljs-string"><span class="hljs-string">'comment'</span></span> id = Column(Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) body = Column(String) user_id = Column(Integer, ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)) post_id = Column(Integer, ForeignKey(<span class="hljs-string"><span class="hljs-string">'post.id'</span></span>)) rating = Column(Integer) user = relationship(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) post = relationship(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>)</code> </pre> <br><p>  You can play <a href="https://gist.github.com/absent1706/6d2b3ce1ecb47aeb6df6fa09f30819f0">around</a> with the code <a href="https://gist.github.com/absent1706/6d2b3ce1ecb47aeb6df6fa09f30819f0">here</a> . <br>  There are ORM classes, initialization of pure Alchemy (without my package) and filling with initial data. </p><br><div class="spoiler">  <b class="spoiler_title">How to start</b> <div class="spoiler_text"><p>  Install Alchemy: </p><br><pre> <code class="hljs sql">pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> sqlalchemy</code> </pre> <br><p>  Then save the test application to a file and run: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">python</span></span> .py</code> </pre> </div></div></div></div><br><h2 id="active-record">  Active record </h2><br><p>  After Active Record ORM, I did not understand why I should write 3 lines to create an object </p><br><pre> <code class="python hljs">bob = User(name=<span class="hljs-string"><span class="hljs-string">'Bobby'</span></span>, age=<span class="hljs-number"><span class="hljs-number">1</span></span>) session.add(bob) session.flush()</code> </pre> <br><p>  instead of one? </p><br><pre> <code class="python hljs"> bob = User.create(name=<span class="hljs-string"><span class="hljs-string">'Bobby'</span></span>, age=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  I understand that a manual flush <a href="http://docs.sqlalchemy.org/en/latest/orm/session_basics.html">session is</a> needed so that requests to the database go in one bundle, and indeed the <a href="https://martinfowler.com/eaaCatalog/unitOfWork.html">unit of work</a> pattern gives many advantages in terms of performance. </p><br><p>  But in real web applications, most of the tasks are trivial <a href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> , and because not 3 requests will be made in the database, but one, the gain is not great.  In any case, it is not worth the complexity of the code.  And in general, not for nothing that the creators of Django, Ruby on Rails, Laravel, Yii chose Active Record ORM. </p><br><p>  Well, nothing prevents implement <strong>Active Record over Data Mapper</strong> !  For this, all that‚Äôs necessary is that when the application is initialized, the session is passed to the model </p><br><pre> <code class="python hljs">BaseModel.set_session(session) <span class="hljs-comment"><span class="hljs-comment">#     #       BaseModel.session</span></span></code> </pre> <br><p>  Now ORM has access to the session, and you can implement the <a href="https://github.com/absent1706/sqlalchemy-mixins/blob/master/sqlalchemy_mixins/activerecord.py">methods save, create, update, delete</a> , etc. </p><br><pre> <code class="python hljs">bob = User.create(name=<span class="hljs-string"><span class="hljs-string">'Bobby'</span></span>, age=<span class="hljs-number"><span class="hljs-number">1</span></span>) bob.update(name=<span class="hljs-string"><span class="hljs-string">'Bob'</span></span>, age=<span class="hljs-number"><span class="hljs-number">21</span></span>) bob.delete()</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">About update</b> <div class="spoiler_text"><p>  In fact, on the lower layer of SQLAlchemy there is an update of fields from the array, but I want to have it at the ORM level. </p></div></div><br><p>  Well, I also want to quickly create a request for a model </p><br><pre> <code class="python hljs">User.query <span class="hljs-comment"><span class="hljs-comment">#  session.query(User)</span></span></code> </pre> <br><p>  and quickly get the first or all records </p><br><pre> <code class="python hljs">User.first() <span class="hljs-comment"><span class="hljs-comment">#  session.query(User).first() User.all() #  session.query(User).all()</span></span></code> </pre> <br><p>  or find the record by id, collapsing with an error if necessary </p><br><pre> <code class="python hljs">User.find(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  session.query(User).get(1) User.find_or_fail(123987) #  ,   </span></span></code> </pre> <br><p>  As a result, we get a full-fledged Active Record as in my favorite Django, Laravel and Ruby on Rails, but under the hood we have a powerful Data Mapper.  Thus, we have the <em>best of both worlds</em> . </p><br><blockquote>  I am <strong>not against the</strong> standard approach of Alchemy, but for <em>simple</em> tasks I want to have a simpler code (see the <a href="https://habr.com/ru/post/324876/">spoiler at the end of the article</a> ) </blockquote><p>  A detailed description and examples, see <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><h2 id="eager-load">  Eager load </h2><br><p>  To solve the <a href="http://docs.sqlalchemy.org/en/latest/orm/tutorial.html%3Fhighlight%3Deager%2520load">problem of N + 1 requests,</a> each ORM has its own solutions. </p><br><p>  Suppose we display on page 10 users and all posts of each user.  To avoid 11 queries (1 for users and 10 for posts), in <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">SQLAlchemy</a> these posts can be added </p><br><pre> <code class="python hljs">session.query(User).options(joinedload(<span class="hljs-string"><span class="hljs-string">'posts'</span></span>))</code> </pre> <br><p>  or download a separate request </p><br><pre> <code class="python hljs">session.query(User).options(subqueryload(<span class="hljs-string"><span class="hljs-string">'posts'</span></span>))</code> </pre> <br><p>  Well, great!  Only now if you need to display comments with posts, and with the comments of their authors?  Alchemy <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">allows it</a> , but in practice it turned out to be inconvenient. </p><br><p>  I would like to declaratively define the relationships that we want to load: </p><br><pre> <code class="python hljs">User.with_({ <span class="hljs-string"><span class="hljs-string">'posts'</span></span>: { <span class="hljs-string"><span class="hljs-string">'comments'</span></span>: { <span class="hljs-string"><span class="hljs-string">'user'</span></span>: JOINED } } }).all()</code> </pre> <br><p>  it is possible and without magic lines: </p><br><pre> <code class="python hljs">User.with_({ User.posts: { Post.comments: { Comment.user: JOINED } } }).all()</code> </pre> <br><p>  In addition, you can set a different download strategy: <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">joinedload</a> or <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">subqueryload</a> . <br>  The following code will lead to 2 requests: for posts (with posts by the authors authors) and for comments (with posts by the authors authors comments): </p><br><pre> <code class="python hljs">Post.with_({ <span class="hljs-string"><span class="hljs-string">'user'</span></span>: JOINED, <span class="hljs-comment"><span class="hljs-comment">#   'comments': (SUBQUERY, { #      'user': JOINED #           }) }).all()</span></span></code> </pre> <br><p>  Well, for simple cases, when you need a <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">joinload</a> or <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">subqueryload of a</a> couple of relations, there is a simple syntax (the <code>with_subquery</code> method <code>with_subquery</code> out just like in <a href="https://laravel.com/docs/5.4/eloquent-relationships">Eloquent</a> ): </p><br><pre> <code class="python hljs">Comment.with_joined(<span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>, <span class="hljs-string"><span class="hljs-string">'post.comments'</span></span>).all() <span class="hljs-comment"><span class="hljs-comment">#      : # session.query(Comment).options(joinedload('user'), joinedload('post'), # joinedload('post.comments')).all() User.with_subquery('posts', 'posts.comments').all() #      : # session.query(User).options(subqueryload('posts'), subqueryload('posts.comments')).all()</span></span></code> </pre> <br><p>  Note that you can load nested relationships like <code>posts.comments</code> .  This is not my feature, but Alchemy (unfortunately, I could not find the dock on this feature). </p><br><p>  A detailed description with examples can be found <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><p>  <strong>PS</strong> Special thanks to my colleagues for the code. </p><br><h2 id="magicheskie-operatory-i-join-otnosheniy-kak-v-django">  Magic operators and join relations, as in Django </h2><br><p>  The first thing that struck me when studying Django was the <a href="https://docs.djangoproject.com/en/1.10/topics/db/queries/">magic operators in the filters</a> : </p><br><pre> <code class="python hljs">Entry.objects.filter(headline__startswith=<span class="hljs-string"><span class="hljs-string">"What"</span></span>)</code> </pre> <br><p>  and absolutely struck by the <a href="https://docs.djangoproject.com/en/1.10/topics/db/queries/">filtering links</a> : </p><br><pre> <code class="python hljs">Entry.objects.filter(blog__name=<span class="hljs-string"><span class="hljs-string">'Beatles Blog'</span></span>)</code> </pre> <br><p>  it is simpler than a more "correct" decision in Alchemy: </p><br><pre> <code class="python hljs">session.query(Entry).join(Entry.blog).filter(Blog.name==<span class="hljs-string"><span class="hljs-string">'Beatles Blog'</span></span>)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Although...</b> <div class="spoiler_text"><ul><li>  Of course, this is less flexible, complex queries will not work here. </li><li>  magic lines and can potentially give a bug in Runtime, if you make a typo, for example, instead of <code>blog__name</code> write <code>blogg__name</code> .  Such strings, unlike class properties like <code>Entry.blog</code> , IDE will not inspect. </li></ul></div></div><br><p>  In addition to aesthetics, magic lines allow you to build queries dynamically (for example, passing filters with UI): </p><br><pre> <code class="python hljs">filters = {<span class="hljs-string"><span class="hljs-string">'entry__headline__contains'</span></span>: <span class="hljs-string"><span class="hljs-string">'Lennon'</span></span>, <span class="hljs-string"><span class="hljs-string">'entry__pub_date__year'</span></span>: <span class="hljs-number"><span class="hljs-number">2008</span></span>} <span class="hljs-comment"><span class="hljs-comment">#     Blog.objects.filter(**filters)</span></span></code> </pre> <br><p>  This is especially useful in applications where the user can build arbitrary filters. </p><br><p>  Alas, in Alchemy there is no possibility to build queries so dynamically.  The maximum that it allows is a <a href="http://docs.sqlalchemy.org/en/latest/orm/query.html">simple filtering of the</a> type "column = value": </p><br><pre> <code class="python hljs">session.query(MyClass).filter_by(name = <span class="hljs-string"><span class="hljs-string">'some name'</span></span>)</code> </pre> <br><p>  Taking a <a href="https://github.com/mitsuhiko/sqlalchemy-django-query">ready-made solution</a> as a model (which was still not <a href="https://github.com/absent1706/sqlalchemy-mixins">enough</a> ), I made my own analogue of Jange and now I can filter declaratively: </p><br><pre> <code class="python hljs">Post.where(rating__in=[<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], user___name__like=<span class="hljs-string"><span class="hljs-string">'%Bi%'</span></span>).all()</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">How is it done</b> <div class="spoiler_text"><p>  The string <code>user___name__like</code> parsed and we understand that you need to posttify the Post.user relationship and apply the filter <code>User.name.like('...')</code> . <br>  I.e </p><br><pre> <code class="python hljs">Post.where(user___name__like=<span class="hljs-string"><span class="hljs-string">'%Bi%'</span></span>).all()</code> </pre> <br><p>  turns into </p><br><pre> <code class="python hljs">session.query(Post).join(Post.user).filter(User.name.like(<span class="hljs-string"><span class="hljs-string">'%Bi%'</span></span>)).all()</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">And in fact it's harder</b> <div class="spoiler_text"><p>  In fact, it may happen that in the query some table will appear 2 times. <br>  Suppose I want to get users who commented on posts by Vasya </p><br><pre> <code class="python hljs">User.where(posts___comments___user___name=<span class="hljs-string"><span class="hljs-string">'Vasya'</span></span>).all()</code> </pre> <br><p>  It turns out that there is a user whom I request, and there is a comment author. <br>  The problem is solved through <a href="http://docs.sqlalchemy.org/en/latest/orm/query.html">alias</a> , i.  The <a href="http://www.qopy.me/4KOkgXYKTOiXHUbc4R6EnQ">final query</a> will contain 2 tables: <code>user</code> and <code>user_1</code> . </p><br><p>  Of course, we cannot know in advance whether the tables will be repeated, so we make each relation that the join has its own alias: </p><br><pre> <code class="python hljs">post_alias = User.posts.property.argument() <span class="hljs-comment"><span class="hljs-comment">#       relationship session.query(User).outerjoin(post_alias) #  ..</span></span></code> </pre> <br><p>  Here is a simplified analogue of the <a href="https://github.com/absent1706/sqlalchemy-mixins/blob/master/sqlalchemy_mixins/smartquery.py">real code</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sqlalchemy.orm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aliased <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sqlalchemy.sql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> operators <span class="hljs-comment"><span class="hljs-comment">#    {'posts___comments___user___name__like': 'Vasya'}. : relations = ['posts', 'comments', 'user'] # 1. ,    ___ attr_name = 'name' # 2. ,     ___ op_name = 'like' # 3. ,    __ #      op_name. #      OPERATORS = {'like': operators.like_op}, #       OPERATORS[op_name] operator = operators.like_op value = 'Vasya' cls = User #           cls query = session.query(cls) #    #      last_alias = cls for relation in relations: relation = getattr(last_alias, relation) #  relation,  User.posts next_alias = aliased(relation.property.argument()) #    (Post  User.posts) #     alias query = query.outerjoin(next_alias) #  / last_alias = next_alias #   SQL-   /   (   User) attr = getattr(last_alias, attr_name) #    User.name query = query.filter(operator(attr, value)) #  SQL-,    User.name   print(query.all())</span></span></code> </pre> <br><p>  Here is the <a href="https://gist.github.com/absent1706/6d2b3ce1ecb47aeb6df6fa09f30819f0">ready-to-run code</a> . </p></div></div></div></div><br><p>  and sort: </p><br><pre> <code class="python hljs">Post.sort(<span class="hljs-string"><span class="hljs-string">'-rating'</span></span>, <span class="hljs-string"><span class="hljs-string">'user___name'</span></span>).all() <span class="hljs-comment"><span class="hljs-comment"># sort by rating DESC, user name ASC</span></span></code> </pre> <br><h3 id="avtomaticheskiy-eager-load">  Automatic eager load </h3><br><p>  Moreover, since we automatically join join relations, it is logical to indicate to SQLAlchemy that the specified relations are already fuzzy with the help of <a href="http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html">contains_eager</a> .  Now, if the <code>Post.user</code> relationship <code>Post.user</code> used in <code>Post.user</code> / sorting, then we can get the user <strong>without an additional query</strong> : </p><br><pre> <code class="python hljs">post = Post.sort(<span class="hljs-string"><span class="hljs-string">'user___name'</span></span>).first() print(post.user) <span class="hljs-comment"><span class="hljs-comment">#      , ..   </span></span></code> </pre> <br><p>  A detailed description with examples, see <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><h3 id="esli-vy-ne-lyubite-magiyu">  If you do not like magic </h3><br><p>  Here is <a href="">an example of magic filtering and sorting in a real project</a> . <br>  Question to all, especially to those who dislike magic lines: </p><br><ol><li>  How many lines are needed for such filters and sorting on pure Alchemy? </li><li>  To what extent will the purely alchemical correct code be clear and maintained? </li><li>  How easy will it be to reuse? </li><li>  Overall, which is better: a bit of <a href="https://github.com/absent1706/sqlalchemy-mixins">tested, documented magic</a> or a custom bike on pure Alchemy with 100 lines <em>each time</em> complex filters are needed? </li></ol><br><h2 id="vsyo-v-kuchu-filtry-sortirovka-eager-load">  All in a bunch: filters, sorting, eager load </h2><br><p>  In the real world, you have to simultaneously filter, sort, and even eager to load connections. </p><br><p>  Suppose we filter and sort posts by the same <code>Post.user</code> relation.  It may be that filtering and sorting 2 times pridoyunyat the same attitude, which will affect the speed. </p><br><div class="spoiler">  <b class="spoiler_title">Doesn't Alchemy itself figure it out?</b> <div class="spoiler_text"><p>  If you just write </p><br><pre> <code class="python hljs">session.query(Post).join(Post.user).join(Post.user)</code> </pre> <br><p>  then, indeed, Alchemy will make only one join. <br>  The thing is that we make our own alias for each relationship (see the spoiler " <em>how it's done</em> " above), and therefore Alchemy does not know that 2 alias on <code>Post.user</code> is essentially the same thing, and follow up on your own. </p></div></div><br><p>  Therefore, filtering, sorting and eager load (yes, it too) had to be done in one function in order to have information about all required joins (or rather, to have a single list of alias, see the spoiler " <em>how it's done</em> ") and make them only one time: </p><br><pre> <code class="python hljs"> Comment.smart_query( filters={ <span class="hljs-string"><span class="hljs-string">'post___public'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-string"><span class="hljs-string">'user__isnull'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> }, sort_attrs=[<span class="hljs-string"><span class="hljs-string">'user___name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-created_at'</span></span>], schema={ <span class="hljs-string"><span class="hljs-string">'post'</span></span>: { <span class="hljs-string"><span class="hljs-string">'user'</span></span>: JOINED } }).all()</code> </pre> <br><p>  A detailed description with examples can be found <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><h1 id="udobnaya-otladka-s-udobnym-__repr__">  Easy debugging with convenient <code>__repr__</code> </h1><br><p>  As a developer, it's very important for me to play with the application in the console.  And it was very unpleasant after the <a href="">beauty</a> in <a href="https://scotch.io/tutorials/tinker-with-the-data-in-your-laravel-apps-with-php-artisan-tinker">Laravel</a> to see this: </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.query(Post).<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() [&lt;myapp.models.Post <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> at <span class="hljs-number"><span class="hljs-number">0x04287A50</span></span>&gt;, &lt;myapp.models.Post <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> at <span class="hljs-number"><span class="hljs-number">0x04287A90</span></span>&gt;]</code> </pre> <br><p>  This is terribly uninformative. <del>  and very furious </del>  .  Therefore, I decided to display at least ID </p><br><pre> <code class="hljs css">&gt;&gt;&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">session</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.query</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Post</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.all</span></span>() <span class="hljs-selector-attr"><span class="hljs-selector-attr">[&lt;Post #11&gt;, &lt;Post #12&gt;]</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">How to universally get an ID</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sqlalchemy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> inspect ids = inspect(post).identity <span class="hljs-comment"><span class="hljs-comment">#     primary </span></span></code> </pre> </div></div><br><p>  In general, each model has 1-2 attributes that reflect its essence.  For example, the user is the name, and the post is the user and the body of the post.  Therefore, I made it possible to set these attributes declaratively: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseModel)</span></span></span><span class="hljs-class">:</span></span> __repr_attrs__ = [<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-comment"><span class="hljs-comment"># ... class Post(BaseModel): __repr_attrs__ = ['user', 'body'] # body is just column, user is relationship # ...</span></span></code> </pre><br><p>  Now we have a very convenient <code>__repr__</code> : </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.query(Post).<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>() [&lt;Post #<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>:&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">'Bill'</span></span>&gt; body:<span class="hljs-string"><span class="hljs-string">'post 11'</span></span>&gt;, &lt;Post #<span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>:&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> #<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>&gt; body:<span class="hljs-string"><span class="hljs-string">'post 12'</span></span>&gt;]</code> </pre><br><p>  Detailed description with examples <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><h1 id="itogi">  Results </h1><br><p>  Implemented features, without which I personally worked very hard with Alchemy. <br>  Now life has become easier, because: </p><br><ol><li>  With Active Record, we can quickly do CRUD without bothering with the flush session. </li><li>  With powerful filtering / sorting in the Django style, we can make very complex, <em>dynamic</em> joins in one line, which can even be <a href="">transferred</a> from the <a href="">UI</a> . </li><li>  We can set the eager load declaratively. </li><li>  Debugging has become more convenient with informative <code>__repr__</code> . </li></ol><br><p>  On a combat project, this helped greatly simplify support and improve readability of the code. <br>  All features, again, implemented <a href="https://github.com/absent1706/sqlalchemy-mixins">here</a> . </p><br><div class="spoiler">  <b class="spoiler_title">If it seems to you that: (1) all this is evil;</b>  <b class="spoiler_title">(2) I am against pure Alchemy;</b>  <b class="spoiler_title">(3) I did not understand, climbed to improve it</b> <div class="spoiler_text"><ol><li><p>  I have been working very closely with Alchemy for a year on a complex combat project.  All the tasks that I have brought are not a whim, but a real necessity. </p><br></li><li><p>  I love Alchemy and its standard approach.  I like its flexibility, control over SQL, explicitness, etc.  I consider Alchemy the <strong>best ORM</strong> that I have met.  No Active Record can compare with it. </p><br></li><li><p>  But the flexibility fee is a longer code.  And in <em>simple</em> tasks like CRUD, the code of Alchemy is much more complex than that in Active Record ORM. <br>  That's why I wrote my package, which can sometimes be used as an addition to pure Alchemy. <br>  My package is just an <em>add-</em> on for Alchemy.  I still love Alchemy for what it is and <em>do not</em> propose to abandon its original use. </p><br></li><li><p>  About Active Record: <br>  I understand the power of the <a href="https://martinfowler.com/eaaCatalog/unitOfWork.html">unit of work</a> pattern to optimize application performance.  But in simple tasks, when you need to simply create an object in the controller, writing the same 3 lines for this (create an object, add to a session, flush sessions) does not inspire.  That's why I did Active Record <strong>over, rather than instead of a</strong> Data Mapper for <em>simple</em> tasks. </p><br></li><li><p>  About filtering / sorting in Django style: </p><br><ul><li><p>  I know that magic strings like <code>user___name__like</code> are implicit and fraught with runtime errors.  But <em>sometimes</em> it can be convenient. </p><br></li><li><p>  I also <em>prefer to write explicitly</em> : <code>session.query(Post).join(Post.user).filter(User.name.like(...))</code> , but it happens that you don‚Äôt know in advance which filter field to use, or there are filters so complex that it is obvious to write - there will be a lot of code and figs in it then you will understand.  Try to write <a href="">here such a filter and sorting</a> on pure Alchemy.  You write something, but the code will be a lot. <br>  And most importantly, you have to write a bunch of complex code every time.  And so you can declaratively set the necessary filters and sorting </p><br></li><li>  I understand that it is impossible to start up any filters from the front end without validation: <br><ul><li>  in the combat project, we set a list of valid filters of the type <code>['product___price', 'product___user___name']</code> and cut off everything else </li><li>  if the magic filter is incorrect, the packet <a href="https://github.com/absent1706/sqlalchemy-mixins/blob/master/sqlalchemy_mixins/tests/test_smartquery.py">will produce a readable error</a> </li><li>  There is an idea to make a convenient magic string validator. </li></ul></li></ul><br></li></ol></div></div><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324876/">https://habr.com/ru/post/324876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324866/index.html">Introduction to cryptography and encryption, part one. Lecture in Yandex</a></li>
<li><a href="../324868/index.html">Read configuration files without problems</a></li>
<li><a href="../324870/index.html">The digest of interesting materials for the mobile # 196 developer (March 20-26)</a></li>
<li><a href="../324872/index.html">Roads that change us</a></li>
<li><a href="../324874/index.html">The proximity theory: the main rule of design, which helps to move from subjective feelings to specifics</a></li>
<li><a href="../324878/index.html">Automate the search for clones of sites and one-day sites</a></li>
<li><a href="../324880/index.html">Google Maps - customize me completely</a></li>
<li><a href="../324884/index.html">Brutim crackme # 03 from korsader</a></li>
<li><a href="../324886/index.html">Pentestit Security Conference 2017: Announcement</a></li>
<li><a href="../324888/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ255 (March 20 - 26, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>