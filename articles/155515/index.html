<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multimethods in C ++. Library implementation. Introduction to MML</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably, many C ++ programmers have heard about multimethods and know that to this day there is no acceptable implementation for this language: neith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multimethods in C ++. Library implementation. Introduction to MML</h1><div class="post__text post__text-html js-mediator-article">  Probably, many C ++ programmers have heard about multimethods and know that to this day there is no acceptable implementation for this language: neither language support nor external libraries.  There are code generators, frills through virtual methods, a special case of double dispatching aka the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Visitor</a> pattern.  But you want to just implement several functions and specify: this set of functions is a multi-method and a full stop. <br><br>  <a href="">Meyers</a> and <a href="">Alexandrescu</a> have long written about multimethods and some approaches to their library implementation.  For almost 20 years, these ideas have been discussed in various C ++ literature, but so far they have not been developed to a complete solution that could be conveniently used in real projects ... <br><br>  I decided to try my luck, dare, to offer my vision of this problem and the way to solve it.  It turned out a template library on the headers only. <br>  This is an implementation under the C ++ 03 standard, on pure C ++: without any code generators and additions.  The goal is a library with a simple and understandable interface for realizing the ability to overload functions by type (and even by value) at run time (this was a minimum program, eventually many more goodies came out). <br><a name="habracut"></a><br>  For a test drive, you need to download the <a href="https://bitbucket.org/vscherba/mml/">source</a> , and make a couple #include. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I chose the presentation from simple to complex.  Therefore, in this article I will talk about the most simple way to use the library and for now I‚Äôm not talking about implementation techniques. <br><br><h1>  What is a multimethod? </h1>  It has several synonyms: multiple dispatching, multiple switching by type, function overloading at run time.  On this subject there is a lot of information on the Internet and literature, therefore, I will not cross-post the same thing, but I will provide a couple of links: <br>  <a href="http://en.wikipedia.org/wiki/Multimethods">English</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D1%2583%25D0%25BB%25D1%258C%25D1%2582%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">Russian</a> Wikipedia. <br><br><h1>  Why multimethods in C ++? </h1>  This question also will not disclose. <br>  Immediately I will inform you that the goal was an attempt to implement multimethods, and not abstract reasoning with the rationale of whether they are needed in C ++.  Some people need, but some do not.  If there is an idiom, then the implementation has the right to exist, whether someone likes it or not.  Since other languages ‚Äã‚Äãhave such implementations, from the language or library side, is C ++ worse? <br>  By the way, C ++ may someday support multimethods from the language side.  Here is Bj√∂rn Straustrup's <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1529.html">offer</a> .  Previously, everyone expected them to appear in C ++ 0x, but so far the proposal has not been properly worked out. <br><br>  From myself I can add.  Stroustrup recommends, if possible, to give preference to free functions, instead of internal member methods, if such a function is sufficiently a public class interface.  But what if the function should process a polymorphic argument?  Every time you have to add a new virtual method that permeates the entire hierarchy (or part of it).  This is a feature of tight coupling of data and methods.  Multimethods allow to avoid this dependence, allow to expand the functionality without interfering with the class hierarchy.  That is, without using internal virtual methods, you can create an external virtual method, and not from one, but from several polymorphic arguments.  In general, the application part is quite wide. <br><br><h1>  A bit of history </h1>  I first learned about the multimethod in 2009 in the process of learning C ++ and the design techniques from the book ‚ÄúGangs of four‚Äù <a href="http://ru.wikipedia.org/wiki/Design_Patterns">‚ÄúObject-oriented design techniques.</a>  <a href="http://ru.wikipedia.org/wiki/Design_Patterns">Design patterns. ‚Äù</a> In the‚Äú Visitor ‚Äùsection.  At that time it seemed to me strange that there is no sane and simple from the point of view of using the multimethod implementation for C ++.  I sketched a prototype, and developed it (several times rewriting almost completely) in my spare time as a hobby, as I study and dive into the language.  When I grew to read Alexandrescu, I learned that he implemented a multimethod in several ways.  But they were very limited, difficult to use, and in some cases do not work at all, this is just an example of metaprogramming to his <a href="">book</a> .  Yes, and the prefix "multi" is useless here: its implementation works only for functions of 2 arguments.  I found several other types of implementations, but they needed either a code generator, or writing a manual code and making significant changes in my hierarchy to support dispatching.  All this is so difficult that there is no desire to use multimethods in C ++.  I managed to find a way to get rid of these difficulties by presenting the interface in a very simple form and an acceptable performance implementation.  Looking ahead, one of the easiest ways to create a multimethod (and the library provides a lot of ways, from simple to fine manual tuning with ready-made or own policies of the algorithm's behavior): <br><br><pre><code class="cpp hljs">mml::make_multimethod(f1, f2,..., fn)</code> </pre> <br>  f1, f2, ..., fn are the names of functions or callable objects that need to be dynamically overloaded (that is, to collect a multimethod from them).  There are no additional requirements for the arguments; make_multimethod returns a functional object representing the multimethod (dynamically overloaded function), configured by default parameters.  This is a low threshold for a library user to enter; it does not require additional knowledge. <br>  As a result, a library was formed, probably, even a decent one, I called it trite: <a href="https://bitbucket.org/vscherba/mml/">MML - MultiMethod Library</a> .  It's time for her to see the light, most likely, it will be useful to someone.  Considering that during these almost 3 years the situation with multi methods in C ++ has not moved anywhere (IMHO, maybe I just don‚Äôt know something). <br><br><h1>  Formulation of the problem </h1>  What a multimethod should do is understandable.  But how should he do it, and, importantly, what will it look like?  I will build on the main purpose - <i>overload at run time</i> .  And what is overloading in object oriented style?  In general, what does function overloading look like at compile time in C ++?  Let's analyze. <br>  Without going into all the subtleties of the rules for overloading (including inheritance, using-declarations, Konig search, etc.), consider a simple example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>{}</code> </pre><br>  It shows that the name of the function f is overloaded 3 times by the types of arguments and their number.  Despite the fact that functions overload appeared in C ++ as an advantage of OOP (there is no overload in C), its form does not smell of object orientation.  These 3 functions are implicitly related: by coincidence of names, moreover, the term ‚Äúoverloaded function‚Äù as a whole is not applicable to this example.  Try, for example, to save the entire set to a variable or transfer it to a certain function and somewhere later make a call with overload: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> of = f; <span class="hljs-comment"><span class="hljs-comment">//      f</span></span></code> </pre><br>  A language has no means of combining a set of overloaded functions into a single object.  This form of overload refuses to encapsulate. <br>  Consider an object-oriented alternative: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> of = f(); <span class="hljs-comment"><span class="hljs-comment">//  , of  ,      </span></span></code> </pre><br>  You might think that all functions are now better designed as a functor (functional object).  There is a common sense in this if it is justified, for example, to obtain the benefits of embedding in the transfer of predicates to standard algorithms, etc., but not for all problems.  Unreasonable writing of a functor instead of the usual good old function will be inconvenient, time consuming, and also for some problems an unacceptable solution. <br><br>  So, in an object-oriented style, an overloaded function is a functor (a functional object) with an overloaded operator ().  The MML library has a ready-made useful template that wraps many individual callable entities (these are functors, lambdas, and pointers to ordinary functions) and represents an overloaded operator () for each of them.  This is the object overloaded_function &lt;F1, ... Fn&gt; and the function make_overloaded_function (f1, ..., fn), which creates an object by displaying the parameters of its template through the types of its arguments. <br><br>  overloaded_function is an entity representing an overloaded function at compile time that can be called using operator ().  From the same considerations you need to proceed when designing a multimethod interface.  Those.  it should be some callable entity, look externally also like an overloaded functor, but perform an overload at run time depending on the actual dynamic type of parameters that is unknown at compile time.  The multimethod should be an object-value, contain all the necessary data within itself, i.e.  support the concept of assignable.  Such an interface and behavior will allow a multimethod to look like a regular callable entity and interact with STL, boost, as well as with many STL like-libraries and custom code without special adaptation. <br><br>  Total  we get the following problem statement: develop a callable entity, which will include a set of statically (at compile time) overloaded functions, provide a callable interface, while dispatching incoming calls to the desired target static function from the set at run time. <br><br><h1>  Proposed Solution </h1>  It was possible to obtain a set of classes, strategies, classes of characteristics, facades, adapters, and so on. Utilities for the most general solution of the problem besides the multimethod itself.  But, since  The article is introductory, I‚Äôll talk about the simplest variant of using multimethod, the so-called low threshold.  To do this, I prepared a <i>multimethod</i> facade and a function to create it based on the set of target callable entities <i>make_multimethod</i> .  The core of the library is the template dispatcher class, which I will discuss in the following articles as it goes deeper, it is maximally generalized and not limited to the implementation of a multimethod, multimethod is a facade to simplify the use of a dispatcher. <br><br>  Perhaps enough of reasoning, it is better to use examples with comments to understand how everything is really simple. <br><br>  For example, we need a simple hierarchy.  I will use the classic example: a game in which we will collide spaceships, asteroids and space stations: <br><br><div class="spoiler">  <b class="spoiler_title">Hierarchy</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game_object</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~game_object() { } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">space_ship</span></span></span><span class="hljs-class"> :</span></span> game_object { }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">space_station</span></span></span><span class="hljs-class"> :</span></span> game_object { }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">asteroid</span></span></span><span class="hljs-class"> :</span></span> game_object { };</code> </pre></div></div><br>  For convenience, a function that returns an array of polymorphic pointers to game objects: <br><br><div class="spoiler">  <b class="spoiler_title">get_obj_pointers ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;game_object*&gt;&amp; get_obj_pointers() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> space_ship ship; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> asteroid ast; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> space_station station; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;game_object*&gt; objs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objs.empty()) { objs.push_back(&amp;ship); objs.push_back(&amp;ast); objs.push_back(&amp;station); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objs; }</code> </pre></div></div><br>  A set of target statically overloaded functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_go_go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(game_object*, game_object*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unsupported colliding!"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_sh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, space_ship*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with space ship"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, asteroid*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with asteroid"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_as_sh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asteroid*, space_ship*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Asteroid collides with space ship"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_as_as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asteroid*, asteroid*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Asteroid collides with asteroid"</span></span>; }</code> </pre><br>  What are they overloaded, you ask, they have different names.  Yes, different, for the convenience of taking the address.  If someone strongly needs, you can give the same name, just have to resolve the ambiguity when you take the address of functions. <br><br>  The first important point.  Create a multimethod (you need to connect the header &lt;mml / generation / make_multimethod.hpp&gt;): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mml/generation/make_multimethod.hpp&gt; auto collide = make_multimethod( collide_go_go , collide_sh_sh , collide_sh_as , collide_as_sh , collide_as_as );</span></span></span></span></code> </pre><br>  Done!  collide - there is a multimethod.  You can do without auto, immediately transfer the result to a template function, assign boost :: function &lt;const char * (game_object *, game_object *)&gt; collide = ... or explicitly specify the type of multimethod &lt;...&gt;.  Explicitly specifying the type is quite difficult, it is best to use automatic breeding.  By encapsulating in (boost | std | std :: tr1) :: function, you lose some of the functionality and performance in some specific cases (below is an explanatory example), but, in general, in most cases the behavior will be the same. <br><br>  The second important point.  We use multimethod.  Push all game objects in pairs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; objs = get_obj_pointers(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; objs.size(); ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; objs.size(); ++j) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[i], objs[j]) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with space ship Space ship collides with asteroid Asteroid collides with space ship Asteroid collides with asteroid</code> </pre></div></div><br>  The output in the console shows who actually encountered.  As you can see, the hierarchy does not require any special support for dispatching.  In multimethod, by default, dynamic_cast is used to find out the actual dynamic type of an object.  Therefore, you need to compile the code with RTTI enabled. <br>  To assess the effectiveness, I give pseudocode, which when compiled will give the same machine code as the call collide (objs [i], objs [j]): <br><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(game_object* obj1, game_object* obj2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space_ship* sh1 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;space_ship*&gt;(obj1)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space_ship* sh2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;space_ship*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_sh_sh(sh1, sh2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid* as2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_sh_as(sh1, as2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_go_go(sh1, obj2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid* as1 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid*&gt;(obj1)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space_ship* sh2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;space_ship*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_as_sh(as1, sh2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid* as2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_as_as(as1, as2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_go_go(as1, obj2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space_ship* sh2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;space_ship*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_go_go(obj1, sh2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asteroid* as2 = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;asteroid*&gt;(obj2)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_go_go(obj1, as2); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collide_go_go(obj1, obj2); }</code> </pre></div></div><br>  As you can see, the overhead during runtime is represented at best by 2 dynamic_cast, at worst - by 4. <br><br>  The library works with pointers to polymorphic objects: both with embedded, and with smart and even user-defined.  To work with links, I wrote the facade ref_multimethod (implemented in &lt;mml / generation / make_ref_multimethod.hpp&gt;): <br><br>  Utility function for the convenience of creating an array of links to polymorphic objects: <br><br><div class="spoiler">  <b class="spoiler_title">get_objs_refs ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs">boost::ptr_vector&lt;game_object&gt;&amp; get_objs_refs() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> boost::ptr_vector&lt;game_object&gt; objs; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objs.empty()) { objs.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> space_ship); objs.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> asteroid); objs.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> space_station); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objs; }</code> </pre></div></div><br>  Target functions that accept links: <br><br><div class="spoiler">  <b class="spoiler_title">Same set as with pointers, only accept links</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_ref_go_go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(game_object&amp;, game_object&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unsupported colliding!"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_ref_sh_sh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship&amp;, space_ship&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with space ship"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_ref_sh_as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship&amp;, asteroid&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with asteroid"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_ref_as_sh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asteroid&amp;, space_ship&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Asteroid collides with space ship"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_ref_as_as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asteroid&amp;, asteroid&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Asteroid collides with asteroid"</span></span>; }</code> </pre></div></div><br>  In order not to repeat the same cycle of pushing objects, I wrapped it in a template function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Objs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_tester</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F collide, Objs&amp; objs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++j) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[i], objs[j]) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Create and use reference multimethod: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mml/generation/make_ref_multimethod.hpp&gt; collide_tester( make_ref_multimethod( collide_ref_go_go , collide_ref_sh_sh , collide_ref_sh_as , collide_ref_as_sh , collide_ref_as_as ) , get_objs_refs() );</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with space ship Space ship collides with asteroid Asteroid collides with space ship Asteroid collides with asteroid</code> </pre></div></div><br>  The runtime equivalent in pseudocode will be the same as in the previous pointer example. <br><br>  I have already said that functional objects compare favorably with pointers to a built-in function in that they are easy to embed.  Moreover, the majority of such objects have no data members, therefore they allow not to store them at all in the memory of the container using the clever technology ‚ÄúEmpty Base Optimization‚Äù, which is used in the depths of the library.  Here is an example of multimethod interaction with a functor: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collider_sh_as</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, asteroid*)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with asteroid"</span></span>; } }; collide_tester( make_multimethod( collide_go_go , collide_sh_sh , collider_sh_as() , collide_as_sh , collide_as_as ) , get_obj_pointers() );</code> </pre><br>  As you can see, using functors is as simple as inline functions.  But at the same time, the size of the multimethod will be less than the width of one pointer, and any compiler will be able to easily embed the body collider_sh_as :: operator () into the place of the call. <br><br>  The types of parameters and the return value of the call-operator library define through BOOST_TYPEOF (&amp; collider_sh_as :: operator ()).  Do not be discouraged if your compiler does not support BOOST_TYPEOF, or you do not want to register custom types to support BOOST_TYPEOF, or do not want to know what it is.  You can explicitly specify the types of parameters, for this there are several convenient ways.  The library implements the following protocol for determining the types of parameters and the return value of the functor (F): <br><ol><li>  Attempts to get a functional type from a functor type via F :: signature.  You must define it as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collider_sh_as</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, asteroid*)</span></span></span></span>; ... }</code> </pre><br></li><li>  If the previous typedef is missing, it tries to find the types inside the functor through F :: result_type, F :: arg1_type, F :: arg2_type, ..., F :: arg <i>n</i> _type: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collider_sh_as</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* result_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> space_ship* arg1_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> asteroid* arg2_type; ... }</code> </pre><br>  Thus, boost :: function is automatically supported, which exports such typedefs. <br><br></li><li>  If they are missing, it tries to find types through F :: result_type, F :: argument_type (for a unary function), F :: first_argument_type, F :: second_argument_type (for a binary function). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collider_sh_as</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* result_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> space_ship* first_argument_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> asteroid* second_argument_type; ... }</code> </pre><br>  or, which is much more convenient: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collider_sh_as</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_function&lt;space_ship*, asteroid*, result_type&gt; { ... }</code> </pre><br>  Thus, std :: unary_function, std :: binary_function is automatically supported. <br><br></li><li>  If the previous 3 steps failed, then BOOST_TYPEOF is used.  Any functor with one non-template operator () is supported.  Thus, std :: function and C ++ 11 lambda are supported.  Some compilers will have to register custom types.  I still do not understand how BOOST_TYPEOF works, I have not registered user types, but it perfectly displays the types of parameters on MSVC 7.1 and higher. </li></ol><br>  In the previous examples, the multimethod was built from functions of the same arity.  This is not a library limitation. <br>  In general, the library supports arity from 0 to MML_MAX_ARITY.  MML_MAX_ARITY defaults to 5. The default value can be changed.  To do this, before connecting the header you need to define a macro: <br><br>  #define MML_MAX_ARITY <i>n</i> <br>  <i>n</i> is the maximum arity. <br><br>  Add for example nullar, unary and ternary functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   , ,     const char* collide_void() { return "Nothing collides?!"; } //     ,   const char* collide_go(game_object*) { return "Unsupported colliding!"; } const char* collide_sh(space_ship*) { return "Space ship collides with what?!"; } const char* collide_as(asteroid*) { return "Asteroid collides with what?!"; } const char* collide_go_go_go(game_object*, game_object*, game_object*) { return "Unsupported colliding!"; } const char* collide_sh_as_as(space_ship*, asteroid*, asteroid*) { return "Space ship collides with two asteroids"; } const char* collide_sh_as_st(space_ship*, asteroid*, space_station*) { return "Space ship collides with asteroid and space_station"; }</span></span></code> </pre><br>  We need a new tester that will collide a different number of objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Objs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_tester_var_arg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F collide, Objs&amp; objs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   cout &lt;&lt; '\t' &lt;&lt; collide() &lt;&lt; endl; // 1  cout &lt;&lt; '\t' &lt;&lt; collide(objs[0]) &lt;&lt; endl; cout &lt;&lt; '\t' &lt;&lt; collide(objs[1]) &lt;&lt; endl; // 2  cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], objs[0]) &lt;&lt; endl; cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], objs[1]) &lt;&lt; endl; // 3  cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], objs[1], objs[1]) &lt;&lt; endl; cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], objs[1], objs[2]) &lt;&lt; endl; }</span></span></code> </pre><br>  Create and use multimethod: <br><br><pre> <code class="cpp hljs">collide_tester_var_arg( make_multimethod( collide_go_go , collide_sh_sh , collide_sh_as , collide_void , collide_go , collide_sh , collide_as , collide_go_go_go , collide_sh_as_as , collide_sh_as_st ) , get_obj_pointers() );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Nothing collides Space ship collides with what?! Asteroid collides with what?! Space ship collides with space ship Space ship collides with asteroid Space ship collides with two asteroids Space ship collides with asteroid and space_station</code> </pre></div></div><br>  Thus, the multimethod behaves like a statically overloaded function by the number of arguments. <br>  The rantaim equivalent in pseudocode here will be more interesting, it strongly depends on the number of arguments: <br><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// collide() inline const char* collide() { return collide_void(); } //     ! // collide(objs[0]) // collide(objs[1]) inline const char* collide(game_object* obj) { if (space_ship* sh = dynamic_cast&lt;space_ship*&gt;(obj)) return collide_sh(sh); else if (asteroid* as = dynamic_cast&lt;asteroid*&gt;(obj)) return collide_as(as); else return collide_go(obj); } //    : // min 1 cast // max 2 casts // collide(objs[0], objs[0]) // collide(objs[0], objs[1]) //  ,      : inline const char* collide(game_object* obj1, game_object* obj2) {...} // collide(objs[0], objs[1], objs[1]) // collide(objs[0], objs[1], objs[2]) inline const char* collide(game_object* obj1, game_object* obj2, game_object* obj3) { if (space_ship* sh1 = dynamic_cast&lt;space_ship*&gt;(obj1)) if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(sh1, sh2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(sh1, sh2, st3); else return collide_go_go_go(sh1, sh2, obj3); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_sh_as_as(sh1, as2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_sh_as_st(sh1, as2, st3); else return collide_go_go_go(sh1, as2, obj3); else if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(sh1, obj2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(sh1, obj2, st3); else return collide_go_go_go(sh1, obj2, obj3); else if (asteroid* as1 = dynamic_cast&lt;asteroid*&gt;(obj1)) if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(as1, sh2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(as1, sh2, st3); else return collide_go_go_go(as1, sh2, obj3); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(as1, as2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(as1, as2, st3); else return collide_go_go_go(as1, as2, obj3); else if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(as1, obj2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(as1, obj2, st3); else return collide_go_go_go(as1, obj2, obj3); else if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(obj1, sh2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(obj1, sh2, st3); else return collide_go_go_go(obj1, sh2, obj3); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(obj1, as2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(obj1, as2, st3); else return collide_go_go_go(obj1, as2, obj3); else if (asteroid* as3 = dynamic_cast&lt;asteroid*&gt;(obj3)) return collide_go_go_go(obj1, obj2, as3); else if (space_station* st3 = dynamic_cast&lt;space_station*&gt;(obj3)) return collide_go_go_go(obj1, obj2, st3); else return collide_go_go_go(obj1, obj2, obj3); } //    : // min 3 casts // max 6 casts</span></span></code> </pre></div></div><br>  You can mix polymorphic types and value types.  Value types will simply be passed as is. <br>  We introduce a couple of additional objective functions that can take the 3rd parameter of the int type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_go_go_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(game_object*, game_object*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unsupported colliding with extra int parameter!"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_as_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, asteroid*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with asteroid with extra int parameter"</span></span>; }</code> </pre><br>  Tester for clarity will pass to the multimethod: <br>  2 polymorphic types; <br>  3 polymorphic types; <br>  2 polymorphic with one non-polymorphic type: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Objs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_tester_non_polymorphic_arg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F collide, Objs&amp; objs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], objs[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], objs[<span class="hljs-number"><span class="hljs-number">1</span></span>], objs[<span class="hljs-number"><span class="hljs-number">2</span></span>]) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], objs[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  We create a multimethod based on previous and new objective functions and use: <br><br><pre> <code class="cpp hljs">collide_tester_non_polymorphic_arg( make_multimethod( collide_go_go , collide_sh_sh , collide_sh_as , collide_as_sh , collide_as_as , collide_go_go_go , collide_sh_as_st , collide_sh_as_as , collide_go_go_int , collide_sh_as_int ) , get_obj_pointers() );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with asteroid Space ship collides with asteroid and space_station Space ship collides with asteroid with extra int parameter</code> </pre></div></div><br>  I gave the rantaim equivalent for the first and second calls, consider the third: <br><br><div class="spoiler">  <b class="spoiler_title">Pseudocode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// collide(objs[0], objs[1], 1) inline const char* collide(game_object* obj1, game_object* obj2, int n) { if (space_ship* sh1 = dynamic_cast&lt;space_ship*&gt;(obj1)) if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) return collide_go_go_int(sh1, sh2, n); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) return collide_sh_as_int(sh1, as2, n); else return collide_go_go_int(sh1, obj2, n); else if (asteroid* as1 = dynamic_cast&lt;asteroid*&gt;(obj1)) if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) return collide_go_go_int(as1, sh2, n); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) return collide_go_go_int(as1, as2, n); else return collide_go_go_int(as1, obj2, n); else if (space_ship* sh2 = dynamic_cast&lt;space_ship*&gt;(obj2)) return collide_go_go_int(obj1, sh2, n); else if (asteroid* as2 = dynamic_cast&lt;asteroid*&gt;(obj2)) return collide_go_go_int(obj1, as2, n); else return collide_go_go_int(obj1, obj2, n); } //    : // min 2 casts // max 4 casts</span></span></code> </pre></div></div><br>  As you can see non-polymorphic arguments do not lead to additional overhead. <br><br>  Overloading by const and volatile qualifiers is also supported: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_go_cvgo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(game_object*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> game_object*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Unsupported colliding!"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_cas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> asteroid*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with const asteroid"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_vas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> asteroid*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with volatile asteroid"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_sh_cvas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(space_ship*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> asteroid*)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Space ship collides with const volatile asteroid"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Objs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_tester_cv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F collide, Objs&amp; objs)</span></span></span><span class="hljs-function"> </span></span>{ game_object* object = objs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> game_object* c_object = objs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> game_object* cv_object = objs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], object) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], c_object) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], cv_object) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } collide_tester_cv( make_multimethod( collide_sh_as , collide_go_cvgo , collide_sh_cas , collide_sh_vas , collide_sh_cvas ) , get_obj_pointers() ); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with asteroid Space ship collides with const asteroid Space ship collides with const volatile asteroid</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important feature of the multimethod is the ability to optimize scheduling, if the exact type of polymorphic argument is already known at the compilation stage. </font><font style="vertical-align: inherit;">In other words, the search for a real type of argument begins with the node of the hierarchy, which is the actual type of the argument passed. </font><font style="vertical-align: inherit;">It would be easier to explain ... Here is a better example:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Objs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collide_tester_compile_time_optim</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F collide, Objs&amp; objs)</span></span></span><span class="hljs-function"> </span></span>{ space_ship ship; asteroid ast; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(objs[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;ast) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\t'</span></span> &lt;&lt; collide(&amp;ship, &amp;ast) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } collide_tester_compile_time_optim( make_multimethod( collide_go_go , collide_sh_sh , collide_sh_as , collide_as_sh , collide_as_as ) , get_obj_pointers() );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with asteroid Space ship collides with asteroid</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now carefully consider the runtime equivalent: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// collide(objs[0], &amp;ast) inline const char* collide(game_object* obj1, asteroid* as2) { if (space_ship* sh1 = dynamic_cast&lt;space_ship*&gt;(obj1)) return collide_sh_as(sh1, as2); else if (asteroid* as1 = dynamic_cast&lt;asteroid*&gt;(obj1)) return collide_as_as(as1, as2); else return collide_go_go(obj1, as2); } //    : // min 1 cast // max 2 casts // collide(&amp;ship, &amp;ast) inline const char* collide(space_ship* sh1, asteroid* as2) { return collide_sh_as(sh1, as2); } //   !</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first call is dispatched only by the first argument, the second argument is passed as is, because its type is known exactly at compile time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second call generally just forwards, the types of both arguments are known at compile time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is why, in order to support such optimization, the multimethod should, if possible, be stored and transmitted in a pure form, and not be hidden behind boost :: function / * std :: function * /. A call with upcasting - collide ((game_object *) &amp; ship, (game_object *) &amp; ast) - will deprive the library of the possibility of optimization.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The multimethod supports not only bare pointers, but also boost :: shared_ptr, as well as custom pointer types, with the correct specialization of a pair of templates (about them in the following articles). </font><font style="vertical-align: inherit;">To support boost :: shared_ptr, you need to include the header file &lt;mml / casting / sp_dynamic_caster.hpp&gt;.</font></font><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mml/casting/sp_dynamic_caster.hpp&gt; const char* sp_collide_go_go(game_object*, boost::shared_ptr&lt;game_object&gt;) { return "Unsupported colliding!"; } const char* sp_collide_sh_sh(space_ship*, boost::shared_ptr&lt;space_ship&gt;) { return "Space ship collides with smart_ptr space ship"; } struct sp_collider_sh_as { const char* operator()(space_ship*, boost::shared_ptr&lt;asteroid&gt;) const { return "Space ship collides with smart_ptr asteroid"; } }; template &lt;typename F, typename Objs&gt; void sp_collide_tester(F collide, Objs&amp; objs) { boost::shared_ptr&lt;game_object&gt; obj1(new space_ship); boost::shared_ptr&lt;game_object&gt; obj2(new asteroid); cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], obj1) &lt;&lt; endl; cout &lt;&lt; '\t' &lt;&lt; collide(objs[0], obj2) &lt;&lt; endl; } sp_collide_tester( make_multimethod( sp_collide_go_go , sp_collide_sh_sh , sp_collider_sh_as() ) , get_obj_pointers() );</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Conclusion</b> <div class="spoiler_text"><pre> <code class="dos hljs"> Space ship collides with smart_ptr space ship Space ship collides with smart_ptr asteroid</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rantaim equivalent: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pseudocode</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// collide(objs[0], obj1) // collide(objs[0], obj2) inline const char* collide(game_object* obj1, const boost::shared_ptr&lt;game_object&gt;&amp; sp_obj2) { if (space_ship* sh1 = dynamic_cast&lt;space_ship*&gt;(obj1)) if (boost::shared_ptr&lt;space_ship&gt; sp_sh2 = boost::shared_dynamic_cast&lt;space_ship&gt;(sp_obj2)) return sp_collide_sh_sh(sh1, sp_sh2); else if (boost::shared_ptr&lt;asteroid&gt; sp_as2 = boost::shared_dynamic_cast&lt;asteroid&gt;(sp_obj2)) return sp_collider_sh_as()(sh1, sp_as2); else return sp_collide_go_go(obj1, sp_obj2); else if (boost::shared_ptr&lt;space_ship&gt; sp_sh2 = boost::shared_dynamic_cast&lt;space_ship&gt;(sp_obj2)) return sp_collide_go_go(obj1, sp_sh2); else if (boost::shared_ptr&lt;asteroid&gt; sp_as2 = boost::shared_dynamic_cast&lt;asteroid&gt;(sp_obj2)) return sp_collide_go_go(obj1, sp_as2); else return sp_collide_go_go(obj1, sp_obj2); } //    : // min 2 casts // max 3 casts</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources of examples are </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  Benefits </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ease of use. Canonicity of expression. You do not need to initialize anything, to describe your hierarchy of classes, you do not need to interfere with the hierarchy. Meta information is not required for normal use. The multimethod will receive all the necessary meta-information from your code itself. At first glance it may seem incredible, but it is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no limit on the number of arguments (maybe even 0). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main part of the code is compile time, so most of the misuse errors of the multimethod will be detected by the compiler.</font></font><br><br><h1>  disadvantages </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High load on the compiler can manifest itself in the case of instantiating a set of multimethods of different types (as in the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the article). It is different, because the compiler instantiates each pattern with a specific set of parameters only once. The number of single-type multimethods is not important. I suppose that in a real project such diversity will rarely occur. By the way, when using the mechanism of precompiled headings, the compile time of the example almost halves. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When used improperly, vague compiler error messages with sheets of boilerplate code.</font></font><br><br><h1>  Performance </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance is a weak point in the examples given due to the use of dynamic_cast. But dynamic_cast is not part of the library core. This is the method defined by the default strategy for highlighting the real type of object. In the next article I will show you how to set your own type conversion strategy using the example of ‚Äúfast_cast‚Äù, which breaks dynamic_cast by orders of magnitude in efficiency. On the other hand, even such efficiency will be acceptable for most applications. You are not going to implement streaming video processing, causing a multimethod for each byte? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For application or GUI tasks, this option is very acceptable. After embedding (inlining) for release build there are no other overhead costs in runtime.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was necessary to suffer with optimization of sample code so as to minimize side effects on runtime. </font><font style="vertical-align: inherit;">By the way, the performance of the multimethod is comparable to the implementation of the </font></font><a href="http://www.cpptips.com/acyclic_visitor"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acyclyc Visitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pattern </font><font style="vertical-align: inherit;">proposed by Robert Martin. </font><font style="vertical-align: inherit;">It is also implemented via dynamic_cast. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The multimethod does not use a heap, it stores the state inside, if it exists. </font><font style="vertical-align: inherit;">Ideally, when using functors rather than function pointers, the state is not stored at all - the object is empty and all calls are easily embedded.</font></font><br><br><h1>  Dependencies </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It requires </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a C ++ compiler that supports standard 03 or higher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><a href="http://www.boost.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BOOST</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (headers only) version 1.45.0 or higher</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Important!</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There must be a ‚Äúboost‚Äù and ‚Äúmml‚Äù directory inside the compiler's include-directory. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specify the ‚Äúboost‚Äù and ‚Äúmml‚Äù directories themselves as include directories, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but the directory containing them</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library with examples was tested on compilers (currently only under Windows): </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC 3.4.2; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visual C ++ 7.1, 8.0, 9.0, 10.0. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD:</font></font></b> <i>       ,  ,   .  ,     . ,          (    57    ~190 ).       ,        . ,   ,      if-else,      .</i> <br><br> <b>UPD 2:</b> <i>    :   ,      C++  .          ,        .  ,       .  <a href="http://habrahabr.ru/users/mejedi/" class="user_link">mejedi</a>  .</i> <br><br> <i> . , .</i> </div><p>Source: <a href="https://habr.com/ru/post/155515/">https://habr.com/ru/post/155515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155503/index.html">Failures of a three-year crowdsourcing project or why I almost stopped believing in myself and people</a></li>
<li><a href="../155505/index.html">Java application debugging with JDI</a></li>
<li><a href="../155507/index.html">Demonstration of program crashes in the absence of memory barriers</a></li>
<li><a href="../155509/index.html">Timer Architecture in node.js</a></li>
<li><a href="../155511/index.html">My bike for snippets</a></li>
<li><a href="../155517/index.html">Linux memory access barriers</a></li>
<li><a href="../155519/index.html">The next era of NASA's Remote Space Network (DSN) lies in the field of X-rays and lasers.</a></li>
<li><a href="../155523/index.html">The continuation of a series of crash tests waterproof phones Sonim, Samsung and Sony. Part 2</a></li>
<li><a href="../155525/index.html">Organic Groups in Drupal 7</a></li>
<li><a href="../155527/index.html">Canonical tries to transfer Ubuntu Linux to tablet PCs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>