<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python memory management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever wondered how the data you work with looks in the depths of Python? How variables are created and stored in memory? How and when are they...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python memory management</h1><div class="post__text post__text-html js-mediator-article">  Have you ever wondered how the data you work with looks in the depths of Python?  How variables are created and stored in memory?  How and when are they removed?  The material, the translation of which we publish, is devoted to researching the depths of Python, in the course of which we will try to find out the features of memory management in this language.  After studying this article, you will understand how the low-level mechanisms of computers, especially those related to memory, work.  You will understand how Python abstracts low-level operations and learn how it manages memory. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/441568/"><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Knowing what is happening in Python will allow you to better understand some of the behaviors of this language.  Hopefully, this will give you the opportunity to appreciate the tremendous work that is being done within the implementation of this language that you use so that your programs work exactly as you need. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Memory is an empty book</font> </h2><br>  Computer memory, at the very beginning of work with it, can be represented as an empty book intended for short stories.  So far there is nothing on its pages, but very soon authors of stories will appear, each of whom will want to write down his story in this book. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since one story cannot be written on top of another, authors should be attentive to what pages of the book they are writing on.  Before writing anything down, they consult with the chief editor.  He decides where exactly the authors can write stories. <br><br>  Since the book we are talking about has been around for quite some time, many of the stories in it are already outdated.  If no one reads a certain story or mentions it in their works, this story is removed from the book, freeing up space for new stories. <br><br>  In general, it can be said that computer memory is very similar to such a book.  In fact, continuous memory blocks of fixed length are even called pages, so we believe that the comparison of memory with a book is very successful. <br><br>  Authors who write their stories in a book are different applications or processes that need to store data in memory.  The chief editor, who decides on which particular pages of the book authors can write on, is the mechanism that manages memory.  And the one who removes old stories from the book, making room for new ones, can be compared with the garbage collection mechanism. <br><br><h2>  <font color="#3AC1EF">Memory management: the path from hardware to software</font> </h2><br>  Memory management is a process during the implementation of which programs write data to memory and read them from it.  A memory manager is an entity that determines where exactly an application can place its data in memory.  Since the number of fragments of memory that can be allocated to applications is not infinite, just as the number of pages in any book is not infinite, the memory manager servicing applications needs to find free fragments of memory and provide them to applications.  This process, in which applications "give out" memory, is called memory allocation. <br><br>  On the other hand, when certain data is no longer needed, you can delete it, or, in other words, free the memory it occupies.  But what exactly is "isolated" and "free" when it comes to memory? <br><br>  Somewhere in your computer there is a physical device that stores data used by Python programs while they are running.  Before a certain Python object is in physical memory, the code has to go through many layers of abstraction. <br><br>  One of the main such layers, which is located on top of the hardware (such as RAM or hard disk), is the operating system (OS).  It executes (or refuses to execute) requests to read data from memory and to write data to memory. <br><br>  On top of the OS is the application, in our case, one of the implementations of Python (this could be a software package included with your OS or downloaded from <a href="https://www.python.org/">python.org</a> ).  It is this software package that handles memory management, ensuring the operation of your Python code.  The focus of this article is on the algorithms and data structures that Python uses to manage memory. <br><br><h2>  <font color="#3AC1EF">Python reference implementation</font> </h2><br>  The reference Python implementation is called CPython.  It is written in C. When I first heard about it, it literally took me out of the rut.  A programming language that is written in another language?  Well, actually, this is not quite the case. <br><br>  The Python specification is described in <a href="https://docs.python.org/3/reference/index.html">this document</a> in plain English.  However, by itself, this specification code written in Python, of course, cannot.  For this you need something that, following the rules of this specification, will be able to interpret code written in Python. <br><br>  In addition, you need something that can execute the interpreted code on the computer.  The Python reference implementation solves both of these problems.  It converts the code into instructions, which are then executed on the virtual machine. <br><br>  Virtual machines are like ordinary computers created from silicon, metal, and other materials, but they are implemented by software.  They are usually busy processing basic instructions, similar to commands written in <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembler</a> . <br><br>  Python is an interpreted language.  Code written in Python is compiled into a set of instructions with which it is convenient to work with a computer, into a so-called <a href="https://docs.python.org/3/glossary.html">byte code</a> .  These instructions are interpreted by the virtual machine when you run your program. <br><br>  Have you ever seen files with the extension <code>.pyc</code> or folder <code>__pycache__</code> ?  In them is the same byte code, which is interpreted by the virtual machine. <br><br>  It is important to note that, in addition to CPython, there are other implementations of Python.  For example, when using <a href="http://ironpython.net/">IronPython,</a> Python code is compiled into Microsoft CLR instructions.  In <a href="http://www.jython.org/">Jython,</a> code is compiled into Java bytecode and executed on a Java virtual machine.  In the world of Python, there is such a thing as <a href="https://pypy.org/">PyPy</a> , but it is worthy of a separate article, so here we just mention it. <br><br>  For the purposes of this article, I will focus on how memory management mechanisms work in the Python reference implementation, CPython. <br><br>  It should be noted that although most of what we are going to talk about here will be valid for new versions of Python, this may change in the future.  So pay attention to the fact that in this article I am guided by the most recent version of Python at the time of its writing - <a href="https://realpython.com/python37-new-features/">Python 3.7</a> . <br><br>  So CPython is written in C, it interprets Python bytecode.  What does this have to do with memory management?  The fact is that the algorithms and data structures used for memory management exist in CPython code, written, as already mentioned, in C. In order to understand how memory management works in Python, you first need to understand CPython a little. <br><br>  The C language in which CPython is written does not have built-in support for object-oriented programming.  Because of this, a lot of interesting architectural solutions are used in the CPython code. <br><br>  You may have heard that everything in Python is an object, even primitive data types like <code>int</code> and <code>str</code> .  And this is true at the level of language implementation in CPython.  There is a structure called <code>PyObject</code> , which is used by objects created in CPython. <br><br>  A structure is a composite data type that can group data of different types.  If we compare this with object-oriented programming, the structure is similar to a class that has attributes but no methods. <br><br>  <code>PyObject</code> is the ancestor of all Python objects.  This structure contains only two fields: <br><br><ul><li>  <code>ob_refcnt</code> - reference count. </li><li>  <code>ob_type</code> is a pointer to another type. </li></ul><br>  The reference counter is used to implement the garbage collection mechanism.  Another <code>PyObject</code> field is a pointer to a specific type of object.  This type is represented by another structure that describes a Python object (for example, it can be a <code>dict</code> or <code>int</code> ). <br><br>  Each object has its own, unique for such an object, memory allocation mechanism, which knows how to get the memory necessary to store this object.  In addition, each object has its own memory freeing mechanism, which also ‚Äúfrees‚Äù memory after it is no longer needed. <br><br>  However, it should be noted that in all these conversations about the allocation and release of memory there is one important factor.  The fact is that computer memory is a shared resource.  If, at the same time, two different processes try to write something in the same memory area, something bad can happen. <br><br><h2>  <font color="#3AC1EF">Global interpreter lock</font> </h2><br>  Global Interpreter Lock (GIL) is a solution to a common problem that occurs when working with shared computer resources like memory.  When two threads try to simultaneously modify the same resource, they can ‚Äúcollide‚Äù with each other.  The result will be a mess and none of the streams will reach what they aspired to. <br><br>  Let's go back to the book analogy again.  Imagine that two authors decided without permission that it was their turn to take notes.  But they also decided to take notes at the same time and on the same page. <br><br>  Each of them does not pay attention to what the other is trying to write his own story.  Together they begin to write the text on the page.  As a result, two stories will be recorded there, one on top of the other, which will make the page completely unreadable. <br><br>  One solution to this problem is a single global interpreter mechanism that blocks shared resources that a thread is working with.  In our example, this is a ‚Äúmechanism‚Äù that ‚Äúblocks‚Äù a book page.  Such a mechanism eliminates the situation described above, in which two authors simultaneously write text on the same page. <br><br>  The GIL mechanism in Python accomplishes this by blocking the entire interpreter.  As a result, nothing can interfere with the operation of the current thread.  And when CPython is working with memory, it uses GIL to ensure that this work is done safely and efficiently. <br><br>  This approach has strengths and weaknesses, and GIL is the subject of fierce debate in the Python community.  To learn more about GIL you can take a look at <a href="https://realpython.com/python-gil/">this material</a> . <br><br><h2>  <font color="#3AC1EF">Garbage collection</font> </h2><br>  Let us again return to the book analogy and imagine that some of the stories recorded in this book are hopelessly outdated.  Nobody reads them, no one mentions them anywhere.  And if no one reads any material and does not refer to it in his works, then you can get rid of this material by freeing up space for new texts. <br><br>  These old, forgotten stories, can be compared with Python objects, whose reference counts are zero.  These are the very counters that we talked about when discussing the structure of <code>PyObject</code> . <br><br>  Increasing the reference count is done for several reasons.  For example, the counter is incremented in the event that an object stored in one variable was written into another variable: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  It increases even when the object is passed to some function as an argument: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  And here is another example of a situation in which the number in the link counter increases.  This happens if the object is included in the list: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Python allows the programmer to find out the current value of the reference count of an object using the <code>sys</code> module.  To do this, use the following structure: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  Using it, you need to remember that passing an object to the <code>getfefcount()</code> method increases the value of the counter by 1. <br><br>  In any case, if the object is still used somewhere in the code, its reference count will be greater than 0. When the value of the counter drops to 0, a special function will come in, which ‚Äúfrees‚Äù the memory occupied by the object.  This memory can then be used by other objects. <br><br>  Let us now ask ourselves questions about what ‚Äúfreeing memory‚Äù is, and how other objects can use this memory.  To answer these questions, let's talk about the memory management mechanisms in CPython. <br><br><h2>  <font color="#3AC1EF">CPython memory management mechanisms</font> </h2><br>  Now we will talk about how the memory architecture is organized in CPython and how the memory management is performed there. <br><br>  As already mentioned, there are several layers of abstraction between CPython and physical memory.  The operating system abstracts the physical memory and creates a virtual memory layer with which applications can work (this also applies to Python). <br><br>  The virtual memory manager of a specific operating system allocates a fragment of memory for the Python process.  The dark gray areas in the next image are those fragments of memory that belong to the Python process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Memory areas used by CPython</font></i> <br><br>  Python uses some memory for internal use and for purposes not related to the allocation of memory for objects.  Another piece of memory is used to store objects (these are values ‚Äã‚Äãof <code>int</code> , <code>dict</code> , and other types).  Please note that this is a simplified scheme.  If you want to see the full picture - take a look at the source code of <a href="">CPython</a> , where everything that we are talking about is happening. <br><br>  In CPython, there is a facility for allocating memory for objects, which is responsible for allocating memory in the area intended for storing objects.  The most interesting thing happens exactly when this mechanism works.  It is called when the object needs memory, or in cases when the memory needs to be freed. <br><br>  Usually adding or deleting data in Python objects like <code>list</code> and <code>int</code> does not allow for one-time processing of very large amounts of information.  Therefore, the memory allocator architecture is built with an eye to processing small amounts of data.  In addition, this tool tends to not allocate memory until it becomes clear that it is absolutely necessary. <br><br>  Comments in the <a href="">source code</a> describe the memory allocation tool as a ‚Äúfast, specialized memory allocation tool for small blocks that is designed to be used over generic malloc‚Äù.  In this case, <code>malloc</code> is a C library function for allocating memory. <br><br>  Let's discuss the memory allocation strategy used by CPython.  First we will talk about the three entities - the so-called blocks (blocks), pools (pool) and arenas (arena), and how they are related to each other. <br><br>  Arenas are the largest fragments of memory.  They are aligned on the edges of the memory pages.  The page border is the place where a continuous block of fixed-length memory used by the operating system ends.  Python, when working with memory, assumes that the size of the system memory page is 256 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenas, pools and blocks</font></i> <br><br>  On the arenas there are pools, which are virtual memory pages of 4 KB in size.  They resemble the pages of a book from our example.  Pools are divided into small blocks of memory. <br><br>  All blocks in the same pool belong to the same size class.  The size class to which the block belongs determines the size of this block, which is selected based on the requested amount of memory.  Here is a table taken from the source code, in which the data volumes are shown, the system's requests for saving in the system, the size of the allocated blocks and the identifiers of the size classes. <br><table><tbody><tr><td>  The amount of data in bytes <br></td><td>  The volume of the selected block <br></td><td>  idx size class <br></td></tr><tr><td>  1-8 <br></td><td>  eight <br></td><td>  0 <br></td></tr><tr><td>  9-16 <br></td><td>  sixteen <br></td><td>  one <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  four <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  five <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  eight <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  For example, if a save of 42 bytes is requested, the data will be placed in a 48-byte block. <br><br><h2>  <font color="#3AC1EF">Pula</font> </h2><br>  Pools are made up of blocks belonging to the same size class.  Each pool is associated with other pools containing blocks of the same size class with the use of a doubly linked list mechanism.  With this approach, the memory allocation algorithm can easily find free space for a block of a given size, even if we are talking about finding free space in different pools. <br><br>  The <code>usedpools</code> list allows you to keep track of all pools that have space for data belonging to a particular size class.  When a block of a certain size is requested to be saved, the algorithm checks this list to find a list of pools storing blocks of the required size. <br><br>  The pools themselves must be in one of three states.  Namely, they can be used ( <code>used</code> state), they can be filled ( <code>full</code> ) or empty ( <code>empty</code> ).  There are free blocks in the pool used, in which data of a suitable size can be stored.  All blocks of the filled pool are allocated for the data.  An empty pool contains no data, and, if necessary, it can be assigned to store blocks belonging to any size class. <br><br>  The <code>freepools</code> list stores information about all pools in the <code>empty</code> state.  For example, if there are no <code>usedpools</code> records in the <code>usedpools</code> list that store blocks of 8 bytes in size (class with idx 0), then a new pool is initialized in the <code>empty</code> state, intended for storing such blocks.  This new pool is added to the <code>usedpools</code> list, and it can be used to fulfill requests to save data received after its creation. <br><br>  Suppose that in a pool in the <code>full</code> state, some blocks are released.  This happens because the data stored in them is no longer needed.  This pool will again be in the <code>usedpools</code> list and can be used for data of the corresponding size class. <br><br>  Knowledge of this algorithm allows us to understand how the state of the pools changes during operation (and how the size classes change, the blocks belonging to which can be stored in them). <br><br><h2>  <font color="#3AC1EF">Blocks</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Used, full and empty pools</font></i> <br><br>  As can be understood from the previous illustration, pools contain pointers to the ‚Äúfree‚Äù blocks of memory that they contain.  With regard to working with blocks, you need to note one small feature, which is indicated in the source code.  The memory management system used in CPython, at all levels (arenas, pools, blocks), seeks to allocate memory only when absolutely necessary. <br><br>  This means that pools can contain blocks that are in one of three states: <br><br><ul><li>  <code>untouched</code> is a part of memory that has not yet been allocated. </li><li>  <code>free</code> is a part of memory that has already been allocated, but was later made ‚Äúfree‚Äù by CPython and no longer contains any valuable data. </li><li>  <code>allocated</code> is the part of memory that contains valuable data. </li></ul><br>  The <code>freeblock</code> pointer points to a <code>freeblock</code> -linked list of free blocks of memory.  In other words, this is a list of places where you can put data.  If more than one free block is needed for data placement, the memory allocator will take several blocks from the pool in the <code>untouched</code> state. <br><br>  As the memory management tool makes the blocks ‚Äúfree‚Äù, they, acquiring the <code>free</code> state, get to the top of the <code>freeblock</code> list.  The blocks contained in this list do not necessarily represent a contiguous area of ‚Äã‚Äãmemory, similar to the one shown in the previous figure.  They may, in fact, look like the one below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Freeblock single link list</font></i> <br><br><h2>  <font color="#3AC1EF">Arenas</font> </h2><br>  Arenas contain pools.  These pools, as already mentioned, can be in <code>used</code> , <code>full</code> or <code>empty</code> states.  It should be noted that arenas do not have states similar to those that pools have. <br><br>  Arenas are organized into a doubly linked list called <code>usable_arenas</code> .  This list is sorted by the number of free pools available.  The smaller in the arena of free pools - the closer arena to the top of the list. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">List usable_arenas</font></i> <br><br>  This means that the arena, which is stronger than the others filled with data, will be selected for placing new data in it.  Why not the other way around?  Why not post new data in the arena where the most free space is? <br><br>  In fact, this feature leads us to the idea of ‚Äã‚Äãa real liberation of memory.  You may have noticed that quite often we used the concept of ‚Äúfreeing memory‚Äù here, enclosing it in quotes.  The reason this was done is that, although the block can be considered ‚Äúfree‚Äù, the memory that it represents is not actually returned to the operating system.  The Python process holds this chunk of memory and later uses it to store new data.  The real release of memory is the return of its operating system, which can use it. <br><br>  The arenas are the only entity in the scheme discussed here, the memory represented by which can be truly released.  Common sense dictates that the above scheme of working with arenas is designed to allow those arenas that are almost empty to completely empty.  With this approach, the fragment of memory that is represented by a completely empty arena can be truly freed, which will reduce the amount of memory consumed by Python. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Here is what you learned by reading this material: <br><br><ul><li>  What is memory management and why is it important. </li><li>  How does the reference implementation of Python, Cpython, written in the programming language C. </li><li>  What data structures and algorithms are used in CPython for memory management. </li></ul><br>  Memory management is an integral part of the work of computer programs.  Python solves almost all memory management tasks imperceptibly for a programmer.  Python allows the person who writes in this language, to abstract from a set of the fine details concerning work with computers.  This gives the programmer the opportunity to work at a higher level, to create his own code, without worrying about where his data is stored. <br><br>  <b>Dear readers!</b>  If you have experience in Python development, please tell us about how you approach the use of memory in your programs.  For example, do you want to save it? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/441568/">https://habr.com/ru/post/441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441548/index.html">Huawei showed a folding phone for $ 2600</a></li>
<li><a href="../441550/index.html">Hard and unsightly life of a simple programmer</a></li>
<li><a href="../441554/index.html">The whole story of Linux. Part I: how it all began</a></li>
<li><a href="../441560/index.html">Digital events in Moscow from February 25 to March 3</a></li>
<li><a href="../441566/index.html">12 JavaScript Concepts to Know</a></li>
<li><a href="../441570/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ353 (February 17 - 24, 2019)</a></li>
<li><a href="../441582/index.html">LQR control system optimization</a></li>
<li><a href="../441584/index.html">PHP Digest 150 (February 11 - 25, 2019)</a></li>
<li><a href="../441586/index.html">How to recommend music that almost no one listened to. Yandex report</a></li>
<li><a href="../441590/index.html">The evolution of cluster interaction. How we implemented ActiveMQ and Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>