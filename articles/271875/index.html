<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pagination of lists in Android with RxJava. Part II</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone! 
 About a month ago, I wrote an article about organizing list pagination (RecyclerView) using RxJava. What is pagination in a simpl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pagination of lists in Android with RxJava. Part II</h1><div class="post__text post__text-html js-mediator-article">  Good day everyone! <br>  About a month ago, I wrote <a href="http://habrahabr.ru/post/268991/">an article</a> about organizing list pagination (RecyclerView) using RxJava.  What is pagination in a simple way?  This is an automatic upload of data to the list when it is scrolled. <br>  The solution that I presented in that article was quite working, resistant to errors in answering requests for loading data, and resistant to screen reorientation (correct state preservation). <br>  But thanks to the comments of habrovchan, their comments and suggestions, I realized that the solution has a number of shortcomings that can be completely eliminated. <br>  Many thanks to <a href="http://habrahabr.ru/users/lNevermore/">Matthew Malkov</a> for detailed comments and great ideas.  Without it, refactoring of the past solution would not take place. <br>  All interested in asking under the cat. <br><a name="habracut"></a><br>  <b>And so, what were the disadvantages of the first option:</b> <br><ol><li> The appearance of custom <code>AutoLoadingRecyclerView</code> and <code>AutoLoadingRecyclerViewAdapter</code> .  That is, just like this, this solution cannot be inserted into already written code.  We'll have to work a little.  And this, of course, somewhat ties hands in the future. </li><li>  When initializing <code>AutoLoadingRecyclerView</code> you must explicitly call the methods <code>setLimit</code> , <code>setLoadingObservable</code> , <code>startLoading</code> .  And this is in addition to the standard methods for <code>RecyclerView</code> , such as <code>setAdapter</code> , <code>setLayoutManager</code> and others.  Also in my head you need to keep that the <code>startLoading</code> method must be called last.  Yes, all these methods are marked with comments, how and in what order they should be called, but this is not very intuitive, and you can easily get confused. </li><li>  The pagination mechanism was implemented in the <code>AutoLoadingRecyclerView</code> .  <b>A brief summary of it is as follows:</b> <br><ul><li>  There is a <code>PublishSubject</code> with a <code>RecyclerView.OnScrollListener</code> , and which accordingly "emit" certain elements when an event occurs (when the user has twisted to a certain position). </li><li>  There is a <code>Subscriber</code> that listens on the above-mentioned <code>PublishSubject</code> , and when an item arrives to it from the <code>PublishSubject</code> , it unsubscribes from it and calls the special <code>Observable</code> responsible for uploading new items. </li><li>  And there is an <code>Observable</code> that loads new items, updates the list, and then reconnects <code>Subscriber</code> to the <code>PublishSubject</code> to <code>PublishSubject</code> for the scrolling list. </li></ul><br>  The biggest disadvantage of this algorithm is the use of <code>PublishSubject</code> , which is generally recommended for use in exceptional situations and which somewhat breaks the whole concept of RxJava.  As a result, we obtain several ‚Äúcrutch reactivity‚Äù. <br></li></ol><br>  <b>Refactoring</b> <br>  And now, using the above disadvantages, we will try to develop a more convenient and beautiful solution. <br><br>  <b>First of all, we will get rid of <code>PublishSubject</code></b> , and for the place of it we will create <code>Observable</code> , which will ‚Äúemit‚Äù when a given condition occurs, that is, when the user scrolls to a certain position. <br>  The method for obtaining such an <code>Observable</code> (for simplicity, we will call it <code>scrollObservable</code> ) will be as follows: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScrollObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> emptyListCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(subscriber -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RecyclerView.OnScrollListener sl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecyclerView.OnScrollListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrolled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (limit / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); }</code> </pre><br>  Go through the parameters: <br><ol><li>  <code>RecyclerView recyclerView</code> is our search list :) </li><li>  <code>int limit</code> - the number of loaded items at a time.  I added this parameter here for the convenience of determining the "position X", after which the <code>Observable</code> begins to "emit".  Position is determined by this expression: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (limit / <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  As I said in the last article, it was revealed in a purely empirical way, and you can change it yourself depending on the task you are solving. <br></li><li>  <code>int emptyListCount</code> is a more interesting parameter.  Remember, I said that in the previous version, after the most recent initialization, you need to call the <code>startLoading</code> method for the initial load.  So now, if the list is empty and it is not scrolled, then <code>scrollObservable</code> will automatically ‚Äúemit‚Äù the first element, which is the starting point for the start of pagination: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); }</code> </pre><br>  But what if the list already has some elements "by default" (for example, one element).  And pagination must somehow begin.  This is precisely <code>emptyListCount</code> parameter helps <code>emptyListCount</code> . <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> emptyListCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); }</code> </pre><br></li></ol><br>  The resulting <code>scrollObservable</code> "emit" number equal to the number of items in the list.  This number is also a shift (or ‚Äúoffset‚Äù). <br><pre> <code class="java hljs">subscriber.onNext(recyclerView.getAdapter().getItemCount());</code> </pre><br>  When scrolling after reaching a certain position, <code>scrollObservable</code> starts to "emit" elements en masse.  We need only one ‚Äúemit‚Äù with the changed ‚Äúoffset‚Äù.  Therefore, we add the <code>distinctUntilChanged()</code> operator, which cuts off all repeating elements. <br>  Code: <br><pre> <code class="java hljs">getScrollObservable(recyclerView, limit, emptyListCount) .distinctUntilChanged();</code> </pre><br>  It is also necessary to remember that we work with the UI element and monitor changes in its state.  Therefore, all the work on ‚Äútapping‚Äù the scrolling of the list should occur in the UI stream: <br><pre> <code class="java hljs">getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged();</code> </pre><br><br>  <b>Now it is necessary to properly load this data.</b> <br>  To do this, create the <code>PagingListener</code> interface, implementing which, the developer sets the <code>Observable</code> , which is responsible for loading data: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PagingListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset); }</code> </pre><br>  Switching to the ‚Äúloading‚Äù <code>Observable</code> accomplished using the <code>switchMap</code> operator.  Also remember that it is desirable to load data in a non-UI stream. <br>  Attention to the code: <br><pre> <code class="java hljs">getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(pagingListener::onNextPage);</code> </pre><br>  We subscribe to this <code>Observable</code> already in the fragment or activation, where the developer decides how to deal with newly uploaded data.  Or they are immediately in the list, or filtered, and only then the list.  The great thing is that we can easily upgrade the <code>Observable</code> way we want.  In this, of course, RxJava is wonderful, and the <code>Subject</code> that was in the last article is not an assistant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Error processing</b> <br>  But what if there was a short-term error when loading data, such as ‚Äúnetwork lost‚Äù, etc.?  We must be able to re-try to query the data.  Of course, the <code>retry(long count)</code> operator <code>retry()</code> I avoid the <code>retry()</code> operator because of the possibility of a hangup if the error is not short-lived).  Then: <br><pre> <code class="java hljs">getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(pagingListener::onNextPage) .retry(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  But that's the problem.  If an error occurs and the user reaches the end of the list, nothing will happen, the second request will not be sent.  The thing is that the operator <code>retry(long count)</code> in case of an error re-subscribes <code>Subscriber</code> to the <code>Observable</code> , and we again "listen" to the scrolling list.  And the list has reached the end, so a second request does not occur.  It is treated only by ‚Äútwitching‚Äù the list to make scrolling work.  But this, of course, is not correct. <br><br>  Therefore, we had to dodge so that in case of an error the request would still be sent again regardless of scrolling the list and no more than the number of times that the developer would ask. <br>  The solution is: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numberOfAttemptToRetry, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { <span class="hljs-comment"><span class="hljs-comment">// retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); }</span></span></code> </pre><br>  The <code>retryCount</code> parameter <code>retryCount</code> set by the developer.  This is the maximum number of repeated requests in case of an error.  That is, this is not the maximum number of attempts for all requests, but the maximum - only for a specific request. <br>  How does this code work, or rather the <code>getPagingObservable</code> method? <br>  We <code><code>Observable&lt;List&gt; observable   onErrorResumeNext ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code></code> to the <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <pre> <code class="hljs pgsql"><code class="java"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code></code> </pre> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <pre> <code class="hljs pgsql"><code class="java"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code></code> </pre> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <pre> <code class="hljs pgsql"><code class="java"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code></code> </pre> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <pre> <code class="hljs pgsql"><code class="java"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code></code> </pre> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> <div class="spoiler"> <code><b class="spoiler_title"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> PaginationTool <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</b></code> <div class="spoiler_text"> <pre> <code class="hljs pgsql"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code> </pre></div></div><div class="spoiler"> <code><b class="spoiler_title"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> PagingException <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</b></code> <div class="spoiler_text"> <pre> <code class="hljs pgsql"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code> </pre></div></div><div class="spoiler"> <code><b class="spoiler_title"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> PagingListener <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</b></code> <div class="spoiler_text"> <pre> <code class="hljs pgsql"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code> </pre></div></div><div class="spoiler"> <code><b class="spoiler_title"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> PaginationFragment <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</b></code> <div class="spoiler_text"> <pre> <code class="hljs pgsql"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code> </pre></div></div><div class="spoiler"> <code><b class="spoiler_title"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> PagingRecyclerViewAdapter <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</b></code> <div class="spoiler_text"> <pre> <code class="hljs pgsql"><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java"><span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> <br> ,          ,        <code>listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>)</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationTool { // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> items loading <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> RecyclerView there are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> scrolling private static final <span class="hljs-type"><span class="hljs-type">int</span></span> EMPTY_LIST_ITEMS_COUNT = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> requests private static final <span class="hljs-type"><span class="hljs-type">int</span></span> DEFAULT_LIMIT = <span class="hljs-number"><span class="hljs-number">50</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> max attempts <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> retry loading request private static final <span class="hljs-type"><span class="hljs-type">int</span></span> MAX_ATTEMPTS_TO_RETRY_LOADING = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> paging(recyclerView, pagingListener, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("null recyclerView adapter"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("limit must be greater then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (emptyListCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("emptyListCount must be not less then 0"); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retryCount &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("retryCount must be not less then 0"); } <span class="hljs-type"><span class="hljs-type">int</span></span> startNumberOfRetryAttempt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getScrollObservable(recyclerView, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), startNumberOfRetryAttempt, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount)); } private static Observable&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; getScrollObservable(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> emptyListCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(subscriber -&gt; { final RecyclerView.OnScrollListener sl = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RecyclerView.OnScrollListener() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onScrolled(RecyclerView recyclerView, <span class="hljs-type"><span class="hljs-type">int</span></span> dx, <span class="hljs-type"><span class="hljs-type">int</span></span> dy) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { <span class="hljs-type"><span class="hljs-type">int</span></span> position = getLastVisibleItemPosition(recyclerView); <span class="hljs-type"><span class="hljs-type">int</span></span> updatePosition = recyclerView.getAdapter().getItemCount() - <span class="hljs-number"><span class="hljs-number">1</span></span> - (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Subscriptions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(() -&gt; recyclerView.removeOnScrollListener(sl))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static <span class="hljs-type"><span class="hljs-type">int</span></span> getLastVisibleItemPosition(RecyclerView recyclerView) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || LinearLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearLayoutManager.findLastVisibleItemPosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (recyclerViewLMClass == StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> || StaggeredGridLayoutManager.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); <span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> = staggeredGridLayoutManager.findLastVisibleItemPositions(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); List&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; intoList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i : <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>) { intoList.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.max(intoList); } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, <span class="hljs-type"><span class="hljs-type">int</span></span> numberOfAttemptToRetry, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> retryCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.onErrorResumeNext(throwable -&gt; { // retry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> data portion <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error occurred <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numberOfAttemptToRetry &lt; retryCount) { <span class="hljs-type"><span class="hljs-type">int</span></span> attemptToRetryInc = numberOfAttemptToRetry + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPagingObservable(listener, listener.onNextPage(<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>), attemptToRetryInc, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>, retryCount); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagingException extends RuntimeException { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * @author e.matsyuk */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java"><span class="hljs-comment"><span class="hljs-comment">/** * A placeholder fragment containing a simple view. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaginationFragment extends Fragment { private final static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> = <span class="hljs-number"><span class="hljs-number">50</span></span>; private PagingRecyclerViewAdapter recyclerViewAdapter; private <span class="hljs-keyword"><span class="hljs-keyword">Subscription</span></span> pagingSubscription; @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> rootView = inflater.inflate(R.layout.fmt_pagination, container, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); setRetainInstance(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); init(rootView, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootView; } @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> onResume() { super.onResume(); } private <span class="hljs-type"><span class="hljs-type">void</span></span> init(<span class="hljs-keyword"><span class="hljs-keyword">View</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GridLayoutManager(getActivity(), <span class="hljs-number"><span class="hljs-number">1</span></span>); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { recyclerViewAdapter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> items was loaded we don<span class="hljs-string"><span class="hljs-string">'t need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><b class="spoiler_title"><span class="hljs-string"><span class="hljs-string">PagingRecyclerViewAdapter</span></span></b><span class="hljs-string"><span class="hljs-string"> </span></span><code class="java"><span class="hljs-string"><span class="hljs-string">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">           </span></span><a href="https://github.com/matzuk/PaginationSample"><span class="hljs-string"><span class="hljs-string">GitHub</span></span></a><span class="hljs-string"><span class="hljs-string"> . </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">   !   ,  ,  , .</span></span></code> </pre></div></div> <code><code>Observable&lt;List&gt; observable   onErrorResumeNext</code> ,       <code>Observable</code> .          .     <code>retryCount</code> : <br> <code class="java">if (numberOfAttemptToRetry &lt; retryCount) {</code> <br> ,      : <br> <code class="java">int attemptToRetryInc = numberOfAttemptToRetry + 1;</code> <br> ,          ,        <code>listener.onNextPage(offset)</code> : <br> <code class="java">return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount);</code> <br>      ,     <code>Observable</code> : <br> <code class="java">return Observable.empty();</code> <br> <br> <b></b> <br>        <code>PaginationTool</code> . <br> <b class="spoiler_title">PaginationTool</b> <code class="java">/** * @author e.matsyuk */ public class PaginationTool { // for first start of items loading then on RecyclerView there are not items and no scrolling private static final int EMPTY_LIST_ITEMS_COUNT = 0; // default limit for requests private static final int DEFAULT_LIMIT = 50; // default max attempts to retry loading request private static final int MAX_ATTEMPTS_TO_RETRY_LOADING = 3; public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener) { return paging(recyclerView, pagingListener, DEFAULT_LIMIT, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit) { return paging(recyclerView, pagingListener, limit, EMPTY_LIST_ITEMS_COUNT, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount) { return paging(recyclerView, pagingListener, limit, emptyListCount, MAX_ATTEMPTS_TO_RETRY_LOADING); } public static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; paging(RecyclerView recyclerView, PagingListener&lt;T&gt; pagingListener, int limit, int emptyListCount, int retryCount) { if (recyclerView == null) { throw new PagingException("null recyclerView"); } if (recyclerView.getAdapter() == null) { throw new PagingException("null recyclerView adapter"); } if (limit &lt;= 0) { throw new PagingException("limit must be greater then 0"); } if (emptyListCount &lt; 0) { throw new PagingException("emptyListCount must be not less then 0"); } if (retryCount &lt; 0) { throw new PagingException("retryCount must be not less then 0"); } int startNumberOfRetryAttempt = 0; return getScrollObservable(recyclerView, limit, emptyListCount) .subscribeOn(AndroidSchedulers.mainThread()) .distinctUntilChanged() .observeOn(Schedulers.from(BackgroundExecutor.getSafeBackgroundExecutor())) .switchMap(offset -&gt; getPagingObservable(pagingListener, pagingListener.onNextPage(offset), startNumberOfRetryAttempt, offset, retryCount)); } private static Observable&lt;Integer&gt; getScrollObservable(RecyclerView recyclerView, int limit, int emptyListCount) { return Observable.create(subscriber -&gt; { final RecyclerView.OnScrollListener sl = new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { if (!subscriber.isUnsubscribed()) { int position = getLastVisibleItemPosition(recyclerView); int updatePosition = recyclerView.getAdapter().getItemCount() - 1 - (limit / 2); if (position &gt;= updatePosition) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } } } }; recyclerView.addOnScrollListener(sl); subscriber.add(Subscriptions.create(() -&gt; recyclerView.removeOnScrollListener(sl))); if (recyclerView.getAdapter().getItemCount() == emptyListCount) { subscriber.onNext(recyclerView.getAdapter().getItemCount()); } }); } private static int getLastVisibleItemPosition(RecyclerView recyclerView) { Class recyclerViewLMClass = recyclerView.getLayoutManager().getClass(); if (recyclerViewLMClass == LinearLayoutManager.class || LinearLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { LinearLayoutManager linearLayoutManager = (LinearLayoutManager)recyclerView.getLayoutManager(); return linearLayoutManager.findLastVisibleItemPosition(); } else if (recyclerViewLMClass == StaggeredGridLayoutManager.class || StaggeredGridLayoutManager.class.isAssignableFrom(recyclerViewLMClass)) { StaggeredGridLayoutManager staggeredGridLayoutManager = (StaggeredGridLayoutManager)recyclerView.getLayoutManager(); int[] into = staggeredGridLayoutManager.findLastVisibleItemPositions(null); List&lt;Integer&gt; intoList = new ArrayList&lt;&gt;(); for (int i : into) { intoList.add(i); } return Collections.max(intoList); } throw new PagingException("Unknown LayoutManager class: " + recyclerViewLMClass.toString()); } private static &lt;T&gt; Observable&lt;List&lt;T&gt;&gt; getPagingObservable(PagingListener&lt;T&gt; listener, Observable&lt;List&lt;T&gt;&gt; observable, int numberOfAttemptToRetry, int offset, int retryCount) { return observable.onErrorResumeNext(throwable -&gt; { // retry to load new data portion if error occurred if (numberOfAttemptToRetry &lt; retryCount) { int attemptToRetryInc = numberOfAttemptToRetry + 1; return getPagingObservable(listener, listener.onNextPage(offset), attemptToRetryInc, offset, retryCount); } else { return Observable.empty(); } }); } }</code> <b class="spoiler_title">PagingException</b> <code class="java">/** * @author e.matsyuk */ public class PagingException extends RuntimeException { public PagingException(String detailMessage) { super(detailMessage); } }</code> <b class="spoiler_title">PagingListener</b> <code class="java">/** * @author e.matsyuk */ public interface PagingListener&lt;T&gt; { Observable&lt;List&lt;T&gt;&gt; onNextPage(int offset); }</code> <b class="spoiler_title">PaginationFragment</b> <code class="java">/** * A placeholder fragment containing a simple view. */ public class PaginationFragment extends Fragment { private final static int LIMIT = 50; private PagingRecyclerViewAdapter recyclerViewAdapter; private Subscription pagingSubscription; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fmt_pagination, container, false); setRetainInstance(true); init(rootView, savedInstanceState); return rootView; } @Override public void onResume() { super.onResume(); } private void init(View view, Bundle savedInstanceState) { RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.RecyclerView); GridLayoutManager recyclerViewLayoutManager = new GridLayoutManager(getActivity(), 1); recyclerViewLayoutManager.supportsPredictiveItemAnimations(); // init adapter for the first time if (savedInstanceState == null) { recyclerViewAdapter = new PagingRecyclerViewAdapter(); recyclerViewAdapter.setHasStableIds(true); } recyclerView.setLayoutManager(recyclerViewLayoutManager); recyclerView.setAdapter(recyclerViewAdapter); // if all items was loaded we don't need Pagination if (recyclerViewAdapter.isAllItemsLoaded()) { return; } // RecyclerView pagination pagingSubscription = PaginationTool .paging(recyclerView, offset -&gt; EmulateResponseManager.getInstance().getEmulateResponse(offset, LIMIT), LIMIT) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;List&lt;Item&gt;&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { } @Override public void onNext(List&lt;Item&gt; items) { recyclerViewAdapter.addNewItems(items); recyclerViewAdapter.notifyItemInserted(recyclerViewAdapter.getItemCount() - items.size()); } }); } @Override public void onDestroyView() { if (pagingSubscription != null &amp;&amp; !pagingSubscription.isUnsubscribed()) { pagingSubscription.unsubscribe(); } super.onDestroyView(); } }</code> <b class="spoiler_title">PagingRecyclerViewAdapter</b> <code class="java">/** * @author e.matsyuk */ public class PagingRecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private static final int MAIN_VIEW = 0; private List&lt;Item&gt; listElements = new ArrayList&lt;&gt;(); // after reorientation test this member // or one extra request will be sent after each reorientation private boolean allItemsLoaded; static class MainViewHolder extends RecyclerView.ViewHolder { TextView textView; public MainViewHolder(View itemView) { super(itemView); textView = (TextView) itemView.findViewById(R.id.text); } } public void addNewItems(List&lt;Item&gt; items) { if (items.size() == 0) { allItemsLoaded = true; return; } listElements.addAll(items); } public boolean isAllItemsLoaded() { return allItemsLoaded; } @Override public long getItemId(int position) { return getItem(position).getId(); } public Item getItem(int position) { return listElements.get(position); } @Override public int getItemCount() { return listElements.size(); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == MAIN_VIEW) { View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.recycler_item, parent, false); return new MainViewHolder(v); } return null; } @Override public int getItemViewType(int position) { return MAIN_VIEW; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case MAIN_VIEW: onBindTextHolder(holder, position); break; } } private void onBindTextHolder(RecyclerView.ViewHolder holder, int position) { MainViewHolder mainHolder = (MainViewHolder) holder; mainHolder.textView.setText(getItem(position).getItemStr()); } }</code> <br>           <a href="https://github.com/matzuk/PaginationSample">GitHub</a> . <br> <br>   !   ,  ,  , .</code> </div><p>Source: <a href="https://habr.com/ru/post/271875/">https://habr.com/ru/post/271875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271863/index.html">Implementation of CRM on production: samples, errors, results</a></li>
<li><a href="../271867/index.html">Convenient viewing of MAC addresses on ports of switches huawei, linksys, dlink, extreme using expect</a></li>
<li><a href="../271869/index.html">Customize voice messages in 3CX</a></li>
<li><a href="../271871/index.html">The story of one problem with disabling Ejabberd users after update 2.1.13-> 15.07</a></li>
<li><a href="../271873/index.html">The practice of reducing the cost of electricity data center</a></li>
<li><a href="../271877/index.html">RDMA: a view from the inside</a></li>
<li><a href="../271881/index.html">How to create a round Progress Button</a></li>
<li><a href="../271883/index.html">Palantir 101. What is allowed to ordinary mortals to know about the second most abrupt private company in Silicon Valley</a></li>
<li><a href="../271885/index.html">ARM today 25</a></li>
<li><a href="../271887/index.html">‚ÄúIT is a rather poor industry‚Äù - an interview with Dmitry Nesteruk from JetBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>