<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gravitational field on the surface of bodies of irregular shape on the example of the comet Churyumov-Gerasimenko</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is known from the law of world wideness that on the surface of spherical bodies the acceleration of free fall is constant in magnitude and is direc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gravitational field on the surface of bodies of irregular shape on the example of the comet Churyumov-Gerasimenko</h1><div class="post__text post__text-html js-mediator-article">  It is known from the law of world wideness that on the surface of spherical bodies the acceleration of free fall is constant in magnitude and is directed to the center of the ball.  For bodies of irregular shape, this rule is obviously not satisfied.  In this article I will show the method of calculating and visualizing the acceleration of free fall for such bodies.  The calculation will be done in JavaScript, visualized - in WebGL using the library <a href="http://threejs.org/">three.js</a> . <br><br>  As a result, we get the following (in red, areas with high acceleration of gravity are marked, blue - with small): <br><br><img src="https://habrastorage.org/files/2eb/f0b/258/2ebf0b258ec644a792a1f9295b22d5bb.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4e6/a20/839/4e6a208396eb4e4488064d5298b2cb02.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The axis of rotation on the gif is conditional.  It does not coincide with the axis of rotation of the comet. <br></div></div><br>  To calculate the gravitational potential of the planets, the following <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB">formula is used</a> : <br><br><img src="https://habrastorage.org/files/e43/d09/aec/e43d09aece6e49d2a06e26ec2ea46973.png"><br><br>  But, unfortunately, at small r, this series converges slowly, and at very small r, it generally diverges.  Therefore, this formula is not suitable for calculating the gravitational potential on the surface of celestial bodies.  In general, it is necessary to integrate over the entire volume of the body. <br>  A three-dimensional body can be represented as a set of triangular faces, with given coordinates of the vertices.  Further we will assume that the density of the body is constant (for a comet, this approximately corresponds to the truth).  The gravitational potential at a given point will be equal to the sum of the potentials of all tetrahedra, with a base in these faces and with a vertex at a given point (we are not looking for the gravitational potential, but the gravitational acceleration, which is the potential gradient, but the reasoning remains the same). <br><br>  First we need to find the acceleration that the mass of the tetrahedron produces to the point at its top.  To do this, integrate over the entire volume of the tetrahedron.  Unfortunately, this integral is not taken in elementary functions, so you have to go for a trick. <br><br><img src="https://habrastorage.org/files/25e/add/63a/25eadd63a1f34b56a4f9d6149fcfd557.png"><br><br>  The force acting on a point at the top of a tetrahedron is approximately three times greater than the force caused by the gravity of a ball placed in the middle of the base of the tetrahedron (the mass of the ball is equal to the mass of the tetrahedron).  That is, F <sub>1</sub> ‚âà3 * F <sub>2</sub> .  This equality is better fulfilled with a small angle of the tetrahedron solution.  To estimate the value of the deviation of equality from the strict one, I generated several thousand random tetrahedra and calculated this value for them. <br><br><img src="https://habrastorage.org/files/e75/714/a4f/e75714a4f46f4e72bd4a5d5d2ed4b2de.png"><br><br>  The graph on the abscissa axis shows the ratio of the perimeter of the triangular base to the distance from the top to the center of the base.  The ordinate is the magnitude of the error.  As you can see, the magnitude of the error can be represented by a quadratic function.  With rare exceptions, all points are below the parabola (exceptions will not spoil the weather for us). <br><br>  The magnitude of the gravitational acceleration will be calculated with a given relative error.  If the calculation error exceeds this error, then we divide our tetrahedron into four parts along the base and calculate the acceleration for these parts separately, then sum it up. <br><br><img src="https://habrastorage.org/files/835/f97/48a/835f9748a67c425d9bba0c6b7dab64ae.png"><br><br>  Acceleration we find up to a certain constant, for a given body, a coefficient depending on the mass (or density) of the body, the gravitational constant, and some other parameters.  We will take this factor into account later. <br><br><div class="spoiler">  <b class="spoiler_title">The time has come for the code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">force_pyramide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2, p3, rel</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    (0, 0, 0) // rel -   var volume = (1/6) * triple_product(p1, p2, p3); //   if (volume == 0) return new vector3(0, 0, 0); if (!rel) rel = 0.01; var p0 = middleVector(p1, p2, p3); //    var len = p0.length(); var per = perimeter(p1, p2, p3); //   var tan_per = per / len; var error = 0.015 * sqr(tan_per); //      if (error &gt; rel) { var p12 = middleVector(p1, p2); var p13 = middleVector(p1, p3); var p23 = middleVector(p2, p3); return sumVector( force_pyramide(p1, p12, p13, rel), force_pyramide(p2, p23, p12, rel), force_pyramide(p3, p13, p23, rel), force_pyramide(p12, p23, p13, rel) ); } var ratio = 3 * volume * Math.pow(len, -3); return new vector3(p0.x, p0.y, p0.z).multiplyScalar(ratio); }</span></span></code> </pre> <br></div></div><br>  We calculate the acceleration from a three-dimensional body by summing over all tetrahedra formed by the edges of the body and a given point (which I wrote earlier). <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">force_object</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p0, obj, rel</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; obj.faces.length; i++) { p1 = subVectors(obj.vertices[obj.faces[i][<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span>], p0); p2 = subVectors(obj.vertices[obj.faces[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span>], p0); p3 = subVectors(obj.vertices[obj.faces[i][<span class="hljs-number"><span class="hljs-number">2</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span>], p0); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = force_pyramide(p1, p2, p3, rel); result = addVectors(result, f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br>  We calculate the gravitational and centrifugal accelerations on the comet (the rotation of the comet causes an acceleration of about 25% of the gravitational acceleration, therefore, it cannot be neglected).  I set the relative error to 0.01.  It would seem a lot, but in fact, the error is calculated three times less and the difference is not noticeable when visualizing (since the minimum difference in the color of the pixels is 1 / 256‚âà0.004).  And if you set the error less, the calculation time increases. <br><br>  With an error of 0.01, the calculation is performed for 1-2 seconds, so we make it through setInterval, in order to avoid browser hangs. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rel = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var scale = 1000; //    ,    var grav_ratio = 6.672e-11 * 1.0e+13 / (sqr(scale) * volume); //   1+13  var omega2 = sqr(2 * Math.PI / (12.4 * 3600)); //    12,4  function computeGrav() { info.innerHTML = ': ' + (100 * item / object3d.vertices.length).toFixed() + '%'; for (var i = 0; i &lt; 50; i++) { var p0 = object3d.vertices[item]; grav_force[item] = force_object(p0, object3d, rel).multiplyScalar(grav_ratio); //   circular_force[item] = new vector3(omega2 * p0.x * scale, omega2 * p0.y * scale, 0); //  ,      z abs_grav_force[item] = grav_force[item].length(); abs_circular_force[item] = circular_force[item].length(); item++; if (item &gt;= object3d.vertices.length) { console.timeEnd('gravity calculate'); clearInterval(timerId); accelSelect(); init(); animate(); break; } } } var item = 0; console.time('gravity calculate'); var timerId = setInterval(computeGrav, 1);</span></span></code> </pre><br></div></div><br>  Now it's worth talking about the format of working with a 3D body.  It's simple.  This is an object consisting of three arrays: vertices, normals, and triangular faces. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">vertices</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">normals</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">faces</span></span>: [] };</code> </pre><br>  A vertex array stores vertex coordinate objects.  The array of normals is the vertex normal vectors.  An array of faces is an array of three numbers that store vertex numbers. <br><br>  I downloaded the model of comet Churyumov-Gerasimenko from <a href="http://blogs.esa.int/rosetta/2014/10/03/measuring-comet-67pc-g/">the</a> ESA <a href="http://blogs.esa.int/rosetta/2014/10/03/measuring-comet-67pc-g/">website</a> and simplified it in 3Ds Max.  In the original model there were several tens of thousands of vertices and faces, but for our task this is too much, because the computational complexity of the algorithm depends on the product of the number of vertices and the number of faces.  The model is saved in <a href="https://ru.wikipedia.org/wiki/Obj">obj</a> format. <br><br>  In the library three.js there is an OBJLoader function for loading this format, but only the information about the vertices remains at loading, and the information about the faces is lost, which is not suitable for our task.  Therefore, I modified it somewhat. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objLoad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState != <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.status != <span class="hljs-number"><span class="hljs-number">200</span></span>) { result = xhr.status + <span class="hljs-string"><span class="hljs-string">': '</span></span> + xhr.statusText + <span class="hljs-string"><span class="hljs-string">': '</span></span> + xhr.responseText; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = xhr; } } xhr.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objParse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> txt = objLoad(url).responseText; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = txt.split(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result; <span class="hljs-comment"><span class="hljs-comment">// v float float float var vertex_pattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/; // f vertex vertex vertex ... var face_pattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/; // f vertex/uv vertex/uv vertex/uv ... var face_pattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/; // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ... var face_pattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/; // f vertex//normal vertex//normal vertex//normal ... var face_pattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/; var obj = { vertices: [], normals: [], faces: [] }; for (var i = 0; i &lt; lines.length; i++) { var line = lines[i].trim(); if ((result = vertex_pattern.exec(line)) !== null) { obj.vertices.push(new vector3( parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]) )); }else if ((result = face_pattern1.exec(line)) !== null) { obj.faces.push([ parseInt(result[1]), parseInt(result[2]), parseInt(result[3]) ]); if (result[4]) obj.faces.push([ parseInt(result[1]), parseInt(result[3]), parseInt(result[4]) ]); }else if ((result = face_pattern2.exec(line)) !== null) { obj.faces.push([ parseInt(result[2]), parseInt(result[5]), parseInt(result[8]) ]); if (result[11]) obj.faces.push([ parseInt(result[2]), parseInt(result[8]), parseInt(result[11]) ]); }else if ((result = face_pattern3.exec(line)) !== null) { obj.faces.push([ parseInt(result[2]), parseInt(result[6]), parseInt(result[10]) ]); if (result[14]) obj.faces.push([ parseInt(result[2]), parseInt(result[10]), parseInt(result[14]) ]); }else if ((result = face_pattern4.exec(line)) !== null) { obj.faces.push([ parseInt(result[2]), parseInt(result[5]), parseInt(result[8]) ]); if (result[11]) obj.faces.push([ parseInt(result[2]), parseInt(result[8]), parseInt(result[11]) ]); } } obj.normals = computeNormalizeNormals(obj); return obj; }</span></span></code> </pre><br></div></div><br>  So, we loaded the object from the file, then we calculated the acceleration vector at each of its vertices, now we need to visualize it.  To do this, you need to create a scene, adjust the camera and the light, add and color our model. <br><br>  The scene is created simply. <br><br><pre> <code class="javascript hljs">scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene();</code> </pre><br>  There are no problems with the camera either. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldWidth = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     var fieldHeight = 500; camera = new THREE.PerspectiveCamera(50, fieldWidth / fieldHeight, 0.01, 10000); scene.add(camera); cameraZ = 3 * boundingSphereRadius; // boundingSphereRadius -  ,     camera.position.x = 0; camera.position.y = 0; camera.position.z = cameraZ; camera.lookAt(new THREE.Vector3(0, 0, 0)); //     </span></span></code> </pre><br>  To create a camera, we used the THREE.PerspectiveCamera function (fov, aspect, near, far), where: <br><br>  fov is the height of the field of view of the camera in degrees; <br>  aspect - the ratio of the horizontal angle of view of the camera to the vertical; <br>  near - distance to the near plane (the one that is closer will not be rendered); <br>  far - distance to the far plan. <br><br>  We put the light. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ambientLight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.AmbientLight(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>); scene.add(ambientLight);</code> </pre><br>  Create a visualizer. <br><br><pre> <code class="javascript hljs">renderer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.WebGLRenderer({<span class="hljs-attr"><span class="hljs-attr">antialias</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); renderer.setClearColor(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(fieldWidth, fieldHeight); //    container.appendChild(renderer.domElement); //   </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Together</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera, scene, renderer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> axis; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mesh; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boundingSphereRadius, cameraZ; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> angleGeneral = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ container = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'container'</span></span>); scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldWidth = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fieldHeight = <span class="hljs-number"><span class="hljs-number">500</span></span>; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(<span class="hljs-number"><span class="hljs-number">50</span></span>, fieldWidth / fieldHeight, <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); scene.add(camera); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ambientLight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.AmbientLight(<span class="hljs-number"><span class="hljs-number">0xffffff</span></span>); scene.add(ambientLight); loadModel(); cameraZ = <span class="hljs-number"><span class="hljs-number">3</span></span> * boundingSphereRadius; camera.position.x = <span class="hljs-number"><span class="hljs-number">0</span></span>; camera.position.y = <span class="hljs-number"><span class="hljs-number">0</span></span>; camera.position.z = cameraZ; camera.lookAt(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); axis = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector3(<span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// renderer = new THREE.WebGLRenderer({antialias: true}); renderer.setClearColor(0xffffff); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(fieldWidth, fieldHeight); container.appendChild(renderer.domElement); }</span></span></code> </pre><br></div></div><br>  For working with models in three.js it is convenient to use the BufferGeometry class. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BufferGeometry();</code> </pre><br>  We set the material. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshLambertMaterial( { <span class="hljs-attr"><span class="hljs-attr">side</span></span>: THREE.FrontSide, <span class="hljs-comment"><span class="hljs-comment">//       vertexColors: THREE.VertexColors //        });</span></span></code> </pre><br>  Load the vertex coordinates. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span> * object3d.faces.length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; object3d.faces.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { vertices[<span class="hljs-number"><span class="hljs-number">9</span></span>*i + <span class="hljs-number"><span class="hljs-number">3</span></span>*j ] = object3d.vertices[object3d.faces[i][j] - <span class="hljs-number"><span class="hljs-number">1</span></span>].x; vertices[<span class="hljs-number"><span class="hljs-number">9</span></span>*i + <span class="hljs-number"><span class="hljs-number">3</span></span>*j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = object3d.vertices[object3d.faces[i][j] - <span class="hljs-number"><span class="hljs-number">1</span></span>].y; vertices[<span class="hljs-number"><span class="hljs-number">9</span></span>*i + <span class="hljs-number"><span class="hljs-number">3</span></span>*j + <span class="hljs-number"><span class="hljs-number">2</span></span>] = object3d.vertices[object3d.faces[i][j] - <span class="hljs-number"><span class="hljs-number">1</span></span>].z; } } geometry.addAttribute(<span class="hljs-string"><span class="hljs-string">'position'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BufferAttribute(vertices, <span class="hljs-number"><span class="hljs-number">3</span></span>));</code> </pre><br>  Calculate the color of the vertices. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = addColor(); geometry.addAttribute(<span class="hljs-string"><span class="hljs-string">'color'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BufferAttribute(colors, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addColor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colorMin = [<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      var colorMax = [1.0, 0.0, 0.0]; //     var colors = new Float32Array(9 * object3d.faces.length); for (var i = 0; i &lt; object3d.faces.length; i++) { for (var j = 0; j &lt; 3; j++) { var intensity = (abs_force[object3d.faces[i][j] - 1] - forceMin) / (forceMax - forceMin); colors[9*i + 3*j ] = colorMin[0] + (colorMax[0] - colorMin[0]) * intensity; colors[9*i + 3*j + 1] = colorMin[1] + (colorMax[1] - colorMin[1]) * intensity; colors[9*i + 3*j + 2] = colorMin[2] + (colorMax[2] - colorMin[2]) * intensity; } } return colors; }</span></span></code> </pre><br>  We will also need to display the directions of the acceleration of free fall at each vertex. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lines; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addLines</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ lines = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; object3d.vertices.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ratio; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle_force[i] &lt; <span class="hljs-number"><span class="hljs-number">90</span></span>) { color = <span class="hljs-number"><span class="hljs-number">0x000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       ratio = -0.2 * boundingSphereRadius / forceMax; } else { color = 0xdddddd; //     ratio = 0.2 * boundingSphereRadius / forceMax; } var material = new THREE.LineBasicMaterial({ color: color }); var geometry = new THREE.Geometry(); var point1 = object3d.vertices[i]; var point2 = new THREE.Vector3(); point2.copy(force[i]); point2.addVectors(point1, point2.multiplyScalar(ratio)); geometry.vertices.push( new THREE.Vector3(point1.x, point1.y, point1.z), new THREE.Vector3(point2.x, point2.y, point2.z) ); var line = new THREE.Line(geometry, material); rotateAroundWorldAxis(line, axis, angleGeneral); if (hair.checked) scene.add(line); lines.push(line); } }</span></span></code> </pre><br></div></div><br>  With visualization finished.  We look what happened. <br><br>  <a href="http://www.anthelion.ru/gravitybodies/comet.html">Demo 1</a> . <br><br>  As we see, the acceleration of free fall on a comet is from 40 to 80 thousand times less than on Earth.  The maximum deviation of the acceleration vector from the normal is about 60-70 degrees.  Small and large stones in these areas probably do not linger and slowly roll into areas where the angle is not so large. <br><br>  You can play with the bodies of another form.  <a href="http://www.anthelion.ru/gravitybodies/bodies.html">Demo 2</a> . <br><br>  We see that for a cube the maximum acceleration (in the center of the face) is 1.002 acceleration for a ball of the same mass, but in fact this value is slightly less than one (what we considered with a relative error of 0.01 played a role).  For a cube, unlike a tetrahedron, there are exact formulas for calculating accelerations and the exact value for the center of the face is (for a cube with a side equal to 1): <br><br><img src="https://habrastorage.org/files/0ec/426/ab3/0ec426ab3d214bc493c18f9d6f036815.png"><br><br>  For a ball of the same volume: <br><br><img src="https://habrastorage.org/files/86a/48d/47e/86a48d47e0f14e1dadf9fe3cb8c35911.png"><br><br>  Their ratio is 0.999376 and only slightly less than one. <br><br>  In conclusion, the question.  Are there any bodies that have at least one point the ratio of the absolute value of the gravitational acceleration to the acceleration on the surface of the ball of the same mass and volume greater than one?  If so, for which body is this relationship maximal?  How many times is this ratio greater than one, at times or by percent? </div><p>Source: <a href="https://habr.com/ru/post/271451/">https://habr.com/ru/post/271451/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271437/index.html">Announced the end date of support for Yii 1.1</a></li>
<li><a href="../271439/index.html">About using Visual Studio Code in Unity under OS X</a></li>
<li><a href="../271445/index.html">The digest of interesting materials from the world of Drupal # 15</a></li>
<li><a href="../271447/index.html">Webinar Databoom at Microsoft Webinar Week</a></li>
<li><a href="../271449/index.html">Automation: how we, 10 people, manage an asset worth billions of dollars - IT protection from people and operational risks</a></li>
<li><a href="../271453/index.html">Traditional non-alcoholic hackathon in Sibiriks: we write free HelpDesk</a></li>
<li><a href="../271455/index.html">How to keep secret correspondence. Part 2</a></li>
<li><a href="../271457/index.html">The game "Life" on the logical elements</a></li>
<li><a href="../271459/index.html">Localization of mobile applications on the example of iOS. Implementation, support and development in the next versions</a></li>
<li><a href="../271461/index.html">Codesign.io - architecture that works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>