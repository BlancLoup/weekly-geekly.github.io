<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Audit of system events in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the tools to improve the security level in Linux is the audit subsystem. With its help you can get detailed information about all system events...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Audit of system events in Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/166/4bd/4c1/1664bd4c1719b674a520a68d133a0193.png" alt="Linux audit" width="100%" height="100%"><br><br>  One of the tools to improve the security level in Linux is the audit subsystem.  With its help you can get detailed information about all system events. <br>  It does not provide any additional protection, but provides detailed information on security breaches, based on which specific measures can be taken.  The features of working with the audit subsystem will be discussed in this article. <br><a name="habracut"></a><br><h2>  Audit subsystem: architecture and operation </h2><br>  The audit subsystem has been added to the Linux kernel since version 2.6.  It is designed to keep track of security-critical system events.  Examples of such events include the following (the list is far from complete): <br><br><ul><li>  system startup and shutdown; </li><li>  reading, writing and changing file permissions; </li><li>  initiating network connections; </li><li>  attempts of unsuccessful authorization in the system; </li><li>  change network settings; </li><li>  changing user and group information; </li><li>  start and stop applications; </li><li>  make system calls. </li></ul><br>  None of the named events can occur without the use of kernel system calls.  To track them, simply intercept the corresponding system calls.  This is what the audit subsystem does: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/00c/0a2/dc2/00c0a2dc2ce9add68219858fa1f88e9c.png" alt="Linux audit" width="100%" height="100%"><br><br>  Having received a call from an application in user space, the audit subsystem passes it through one of the following filters: user, task, or exit (for more details, see below).  After that, the call is passed through the exclude filter, which, based on the audit rules, passes it to the auditd daemon for further processing. <br><br>  Such a simple scheme makes it possible to effectively monitor any aspect of the OS, and in the event of a compromise of the system, identify suspicious actions and determine their cause. <br><br><h2>  Installation </h2><br>  To start working with the audit subsystem, you need to install the auditd package (hereinafter, examples of commands for OC Ubuntu 14.04 are provided): <br><br><pre> $ sudo apt-get install auditd
</pre><br>  This package includes the auditd daemon and several auxiliary utilities: <br><br><ul><li>  auditctl - utility to control the auditd daemon;  allows you to receive information about the current state of the audit subsystem, as well as add and delete rules; </li><li>  autrace - a utility for auditing events generated by processes (works on the same principle as strace); </li><li>  ausearch is a utility for searching events in log files; </li><li>  aureport is a utility for generating reports on the operation of the audit system. </li></ul><br><br><h2>  Configuration </h2><br>  Audit settings are stored in the configuration file etc / audit / auditd.conf.  It contains, among others, the following parameters: <br><br><ul><li>  log_file - the file in which the logs of the audit subsystem will be stored; </li><li>  log_format - the format in which logs will be saved; </li><li>  freq is the maximum number of protocol records that can be stored in the buffer; </li><li>  flush - buffer synchronization with disk (none - do nothing, incremental - transfer data from buffer to disk at the frequency specified in the value of the freq parameter; data - synchronize immediately, sync - synchronize both data and file metadata when writing to disk ); </li><li>  max_log_file - maximum log file size in megabytes; </li><li>  max_log_file_action - action when the maximum size of the log file is exceeded; </li><li>  space_left - minimum free space in megabytes, after which the action specified in the following parameter should be implemented; </li><li>  space_left_admin - indicates what to do when there is not enough free space on the disk (ignore - do nothing; syslog - send to syslog, email - send notification by mail; suspend - stop writing logs to disk; single - go to single-user mode; halt - turn off the car) </li><li>  disk_full_action is the action to be taken when the disk is full (this parameter can take the same values ‚Äã‚Äãas space_left_admin). </li></ul><br><h2>  Creating rules </h2><br>  To add and configure rules, use the auditctl command.  Here is a list of its options: <br><br><ul><li>  -l - list the existing rules; </li><li>  -a - add a new rule; </li><li>  -d - remove the rule from the list; </li><li>  -D - delete all existing rules. </li></ul><br>  To create a new rule, you need to run a command like: <br><br><pre>	
 $ auditctl -a &lt;list&gt;, &lt;action&gt; -S &lt;name of system call&gt; -F &lt;filters&gt;
</pre><br>  First, after the -a option, the list is added to which the rule should be added.  There are 5 such lists in total: <br><br><ul><li>  task - events related to the creation of new processes; </li><li>  entry - events that occur when entering a system call; </li><li>  exit - events that occur when leaving the system call; </li><li>  user - events using user space parameters; </li><li>  exclude - used to exclude events. </li></ul><br>  It then indicates what to do after the event.  There are two possible options: always (events will be recorded in the log) and never (will not). <br><br>  After the -S option comes the name of the system call, at which the event needs to be intercepted (open, close, etc.). <br><br>  After the -F option, additional filtering options are specified.  For example, if we need to audit the access to files from the / etc directory, the rule would look like this: <br><br><pre> $ auditctl -a exit, always -S open -F path = / etc /
</pre><br>  You can install an additional filter: <br><br><pre> $ auditctl -a exit, always -S open -F path = / etc / -F perm = aw
</pre><br>  The abbreviation aw means the following: a - attribute change (attribute change), w - write (write).  The wording perm = aw indicates that for the / etc directory you need to keep track of all facts of attribute changes (a - attribute change) and w (w - write). <br><br>  When setting up tracking for individual files, you can omit the -S option, for example: <br><br><pre> $ auditctl -a exit, always -F path = / etc / -F perm = aw
</pre><br><h2>  Rule files </h2><br>  The rules can not only be set via the command line, but also written in the file etc / audit / audit.rules. <br>  This file begins with the so-called meta-rules, in which general logging settings are specified: <br><br><pre> # delete all previously created rules
 -D

 # set the number of buffers in which messages will be stored
 -b 320

 # specify what to do in a critical situation (for example, when buffers overflow): 
 0 - do nothing;  1 - send the message to dmesg, 2 - send the kernel to panic
 -f 1 
</pre><br>  This is followed by custom rules.  Their syntax is very simple: just list the corresponding options of the auditctl command.  Consider an example of a type rule file: <br><br><pre> # track unlink () and rmdir () system calls
 -a exit, always -S unlink -S rmdir

 # track open () system calls from user with UID 1001
 -a exit, always -S open -F loginuid = 1001

 # track access to password and group files and attempt to change them:
 -w / etc / group -p wa
 -w / etc / passwd -p wa
 -w / etc / shadow -p wa
 -w / etc / sudoers -p wa

 # track access to the following directory:
 -w / etc / my_directory -pr

 # close access to configuration file to prevent changes
 -e 2
</pre><br>  Configuration changes will take effect after restarting the auditd daemon: <br><br><pre> $ sudo service auditd restart
</pre><br><h2>  Log file analysis: aureport utility </h2><br>  All log files are stored in the / var / log / audit directory in machine-readable format.  They can be made intelligible with the aureport utility. <br><br>  If you enter the aureport command without arguments, we will see general system statistics (number of system users, total number of system calls, number of open terminals, etc.): <br><br><pre> $ sudo aureport

 Summary Report
 ======================
 Range of time in logs: 07/31/2015 14: 04: 23.870 - 08/04/2015 09: 37: 13.200
 Selected time for report: 07/31/2015 14:04:23 - 08/04/2015 09: 37: 13.200
 Number of changes in configuration: 0
 Number of changes to accounts, groups, or roles: 3
 Number of logins: 0
 Number of failed logins: 0
 Number of authentications: 0
 Number of failed authentications: 61205
 Number of users: 2
 Number of terminals: 5
 Number of host names: 73
 Number of executables: 6
 Number of files: 0
 Number of AVC's: 0
 Number of MAC events: 0
 Number of failed syscalls: 0
 Number of anomaly events: 0
 Anomaly events: 0
 Number of crypto events: 0
 Number of keys: 0
 Number of process IDs: 17858
 Number of events: 61870
</pre><br>  It does not have much practical value.  The specialized reports are of much greater interest.  So, for example, you can view information about all system calls: <br><br><pre> $ sudo aureport -s

 Syscall report
 =======================================
 # date time syscall pid comm auid event
 =======================================
 1. 08/03/2015 15:45:03 313 10285 modprobe -1 52501
 2. 03/08/2015 15:45:03 313 10290 modprobe -1 52502
 3. 08/03/2015 15:45:03 54 10296 iptables -1 52503
 4. 08/03/2015 15:45:03 54 10302 iptables -1 52504
 5. 08/03/2015 15:45:03 54 10305 iptables -1 52505
 6. 03/08/2015 15:45:03 54 10313 iptables -1 52506
 7. 03/08/2015 15:45:03 54 10325 iptables -1 52507
 8. 03/08/2015 15:45:03 54 10329 iptables -1 52508
 9. 03/08/2015 15:45:03 54 10343 iptables -1 52509
 10.08 / 03/2015 15:45:03 54 10345 iptables -1 52510
 11.08 / 03/2015 15:45:03 54 10349 iptables -1 52511
</pre><br>  Using the -au (or ‚àí‚àíauth) option, you can view information on all login attempts: <br><br><pre> $ sudo aureport -au 

 Authentication Report
 ============================================
 # date time acct host term exe success event
 ============================================
 1. 08/31/2015 18:00:19 ubnt static-166-6-249-80.stalowa.pilicka.pl ssh / usr / sbin / sshd no 333
 2. 08/31/2015 18:01:38 root 59.63.188.31 ssh / usr / sbin / sshd no 334
 3. 08/31/2015 18:01:41 root 59.63.188.31 ssh / usr / sbin / sshd no 335
 4. 08/31/2015 18:01:45 root 59.63.188.31 ssh / usr / sbin / sshd no 336
 5. 08/31/2015 18:01:53 root 59.63.188.31 ssh / usr / sbin / sshd no 337
 6. 08/31/2015 18:01:57 root 59.63.188.31 ssh / usr / sbin / sshd no 338
 7. 08/31/2015 18:01:59 root 59.63.188.31 ssh / usr / sbin / sshd no 339
</pre><br>  Aureport supports filtering by date and time: <br><br><pre> $ sudo aureport -s --start 07/31/15 12:00 --end 07/31/15 13:00
</pre><br>  You can specify both a specific time and date, and special human-readable constructions: <br><br><ul><li>  now - the current time; </li><li>  yesterday is the day before; </li><li>  recent - 10 minutes ago; </li><li>  this-week (or this-month, this-year) is the current week (month, year). </li></ul><br>  With aureport, you can view information about the actions of any user of the system.  To do this, you must first find out the id of this user: <br><br><pre> $ id user
 uid = 1000 (user) gid = 1000 (andrei) groups = 1000 (andrei), 27 (sudo)
</pre><br>  and then run the following command: <br><br><pre> $ sudo ausearch -ui 1000 --interpret
</pre><br><h2>  Ausearch: search and analysis of events </h2><br><br>  To view detailed information about the event, use the ausearch utility: <br><br><pre> $ sudo ausearch -a &lt;event number&gt; 
</pre><br>  The output from the above command looks like this: <br><br> <code>type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500 fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm="cat" exe="/bin/cat" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="sshd_config" <br></code> <br>  Consider its structure in more detail.  The type field indicates the type of the record;  type = syscall means that the entry was made after the system call was made.  The msg field shows the time of the event in the Unix Timestamp format and its unique identification number. <br><br>  The arch field contains information about the system architecture used (c000003e means x86_84), presented in a coded hexadecimal format.  To display it in a human-readable form, you can use the -i or ‚Äì‚àíinterpret option. <br><br>  In the syscall field, the type of system call is specified - in our case it is 2, that is, the call to open.  The success parameter indicates whether the call was processed successfully or not.  In our example, the call was not processed successfully (success = no). <br><br>  For each call, the report also lists individual parameters;  You can read more about them in the <a href="http://linux.die.net/man/8/ausearch" rel="nofollow">official manual</a> .  Information on any parameter in human-readable form can be output to the console using the -i or ‚àí‚àíinterpret option mentioned above, for example: <br><br><pre> $ sudo ausearch --interpet --exit -13
</pre><br>  The -sc option allows listing events related to the specified system call, for example: <br><br><pre> $ sudo ausearch -sc ptrace
</pre><br>  The option -ui is used to search for events by user ID: <br><br><pre> $ ausearch -ui 33
</pre><br>  Search for daemon names using the -tm option: <br><br><pre> $ ausearch -x -tm cron
</pre><br>  You can also use keys to search for desired events, for example: <br><br><pre> $ sudo auditctl -k root-actions
</pre><br>  The above command will list all actions performed on behalf of the root user.  Filtering by date and time is also supported, similar to the one described above.  You can display a list of failed events using the ‚Äì‚àífailed option. <br><br><h2>  Analyzing processes using the autrace utility </h2><br>  In some cases, it may be useful to obtain information about events related to one particular process.  For this purpose you can use the autrace utility.  Suppose we need to track the date process and find out which system calls and files it uses.  Run the command: <br><br><pre> $ sudo autrace / bin / date
</pre><br>  The following text will appear on the console: <br><br><pre> Waiting to execute: / bin / date
 Mon Aug 31 17:06:32 MSK 2015
 Cleaning up ...
 Trace complete.  You can locate the records with 'ausearch -i -p 29234'
</pre><br>  Let's pay attention to the last line of the output: it contains a command with which you can get more detailed information.  Run this command and pass the output to the aureport utility, which converts it into a human-readable format: <br><br><pre> $ sudo ausearch -p 29215 --raw |  aureport -f -i
</pre><br>  As a result, we get this report: <br><br><pre> File report
 ===============================================
 # date time file syscall success exe auid event
 ===============================================
 1. 08/31/2015 16:52:16 / bin / date execve yes / bin / date root 25
 2. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no / bin / date root 27
 3. 08/31/2015 16:52:16 /etc/ld.so.preload access no / bin / date root 29
 4. 08/31/2015 16:52:16 /etc/ld.so.cache open yes / bin / date root 30
 5. 08/31/2015 16:52:16 /etc/ld.so.nohwcap access no / bin / date root 34
 6. 08/31/2015 16:52:16 /lib/x86_64-linux-gnu/libc.so.6 open yes / bin / date root 35
 7. 08/31/2015 16:52:16 / usr / lib / locale / locale-archive open yes / bin / date root 52
 8. 08/31/2015 16:52:16 / etc / localtime open yes / bin / date root 56
</pre><br><h2>  Central storage of logs </h2><br>  To send the audit subsystem logs to the centralized repository, use the audisp-remote plugin.  It is included in the audisp-plugins package, which must be additionally installed: <br><br><pre> $ sudo apt-get install audisp-plugins
</pre><br>  The configuration files for all plugins are stored in the /etc/audisp/plugins.d directory. <br><br>  Remote logging settings are specified in the /etc/audisp/plugins.d/audisp-remote.conf configuration file.  By default, this file looks like this: <br><br><pre> active = no
 direction = out
 path = / sbin / audisp-remote
 type = always
 #args =
 format = string
</pre><br>  To activate sending logs to the remote storage, replace the value of the active parameter with yes.  Then open the file etc / audisp / audisp-remote.conf and as the value of the remote_server parameter specify the letter or IP address of the server where the logs will be stored. <br><br>  To receive logs from remote hosts and store them on the server, the following parameters need to be written in the /etc/audit/auditd.conf file: <br><br> <code>tcp_listen_port = 60 <br> tcp_listen_queue = 5 <br> tcp_max_per_addr = 1 <br> ##tcp_client_ports = 1024-65535 #optional <br> tcp_client_max_idle = 0 <br></code> <br><br><h2>  Conclusion </h2><br>  In this article, we outlined the basics of working with the Linux audit subsystem.  We reviewed the principle of the audit system, learned how to formulate rules, read logs and use auxiliary utilities. <br><br>  For those who want to explore the topic in more detail here are some useful links: <br><br><ul><li>  <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/sec-Audit_Record_Types.html" rel="nofollow">full list of types of audit records</a> ; </li><li>  <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Security_Guide/app-Audit_Reference.html" rel="nofollow">full list of possible events</a> ; </li><li>  <a href="http://magazine.hackinthebox.org/issues/HITB-Ezine-Issue-005.pdf" rel="nofollow">article on the use of audit capabilities in the investigation of attacks on the kernel</a> . </li></ul><br>  Readers who are not able to leave comments here are invited <a href="https://blog.selectel.ru/audit-sistemnyx-sobytij-v-linux/">to our blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/267833/">https://habr.com/ru/post/267833/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267823/index.html">Who has not connected to the web? We connect remote regions with balloons, drones and an armada of satellites</a></li>
<li><a href="../267825/index.html">Unix shell: absolutely first steps</a></li>
<li><a href="../267827/index.html">Big Data vs Data Mining</a></li>
<li><a href="../267829/index.html">Practical use of Desired State Configuration for Windows Server 2012 R2</a></li>
<li><a href="../267831/index.html">About the features of geolocation technology in MDK</a></li>
<li><a href="../267837/index.html">Todoist transition to Material Design</a></li>
<li><a href="../267839/index.html">Ready assembly of the news portal NewsModxBox</a></li>
<li><a href="../267841/index.html">Deploying your own OpenVPN</a></li>
<li><a href="../267843/index.html">Using NSOperation and NSOperationQueue in Swift</a></li>
<li><a href="../267845/index.html">Automation of development in ZeptoLab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>