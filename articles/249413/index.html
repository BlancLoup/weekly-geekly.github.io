<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Non-von Neumann computer based on combinatorial logic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. In this article I will talk about my non-von Neumann computer hobby project. The architecture corresponds to the functional paradigm: the progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Non-von Neumann computer based on combinatorial logic</h1><div class="post__text post__text-html js-mediator-article">  Hello.  In this article I will talk about my <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2580%25D1%2585%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D1%2584%25D0%25BE%25D0%25BD_%25D0%259D%25D0%25B5%25D0%25B9%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">non-von Neumann</a> computer hobby project.  The architecture corresponds to the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">functional paradigm: the</a> program is a tree of applications of elementary functions to each other.  Iron is a homogeneous static network of primitive nodes, onto which the dynamic tree of the program is projected, and over which the program ‚Äúcreeps‚Äù by computing. <br><br><img src="https://habrastorage.org/files/a46/835/1e5/a468351e5b2d4e92b45f3a48ce300aaa.png" width="400"><br>  <i>This is how a tree works, only here an arithmetic expression is calculated for clarity, not a combinatorial one;</i>  <i>The step in the figure is one machine cycle.</i> <br><br>  Now ready for an early prototype, existing in the form of a tactical software simulator, and in the form of implementation on the FPGA. <br><a name="habracut"></a><br><h1>  Ideology </h1><br>  Traditional architecture computers have changed the world, but a period of incredible, intoxicating growth has apparently ended.  One of the main limiting factors is the bottleneck between the processor and memory, which prevents parallelization.  Functional programming is an attractive direction for avoiding the limitations of the Neumann, centralized architecture, but attempts to create a computer architecture based on a functional approach have <a href="http://habrahabr.ru/post/190082/">not been successful</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But as time goes on, microelectronics technology is improving and becoming more democratic.  I try to make my computer based on <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0">combinatorial logic</a> .  The computational problem is formulated as an expression - a tree of applications of combinator functions to each other: <br><br><pre><code class="hljs perl">//       (  ) <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span> = + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> = + ( +<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) ( +<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) = + ( +<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) ( +<span class="hljs-number"><span class="hljs-number">1</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-string"><span class="hljs-string">``</span></span> <span class="hljs-string"><span class="hljs-string">``</span></span>si<span class="hljs-string"><span class="hljs-string">`k`</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span><span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span><span class="hljs-string"><span class="hljs-string">`ksk `</span></span><span class="hljs-string"><span class="hljs-string">`s`</span></span><span class="hljs-string"><span class="hljs-string">`s`</span></span>ksk i <span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span><span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span><span class="hljs-string"><span class="hljs-string">`ksk `</span></span><span class="hljs-string"><span class="hljs-string">`s`</span></span><span class="hljs-string"><span class="hljs-string">`s`</span></span>ksk i</code> </pre> <br>  Program execution is understood as the transformation of this expression into some simple form that gives an answer.  The system is Turing-complete, which has a downside: not every expression can be calculated.  For more information on how to calculate something using combinatorial logic, see <a href="https://habr.com/ru/post/249413/">here</a> and <a href="https://habr.com/ru/post/249413/">here</a> . <br><br><h1>  Architecture </h1><br>  The main idea is to place the program tree on a hardware tree of cells capable of applying combinators. <br>  Why hardware tree?  The fact is that when we project a program tree onto a one-dimensional address space we are used to, non-local, ‚Äúlong‚Äù connections inevitably arise.  Here is an example of a flat tree entry: "(A * B) + (C * D) - E" Here "+" is the source of the data for "-", but they are separated in the formula. <br><br><img src="https://habrastorage.org/files/115/48f/7f0/11548f7f08fb4f54ac3806040c7f30fe.png"><br><br>  Non-intersecting subtrees can be calculated independently and simultaneously, hence natural concurrency.  There is no shared memory: the data is stored locally, which means there is no throat ‚Äúprocessor - bus - memory‚Äù.  All operations, except copying subtrees, are performed quickly.  In my <a href="http://habrahabr.ru/post/222287/">previous article,</a> I showed how you can use a tree of such a structure to sort numbers. <br>  So, we have a tree of applications of some functions to others, <br><img src="https://habrastorage.org/files/5a6/321/f71/5a6321f719d94485957f1fa942795705.png"><br>  where leaves are elementary functions, in the case of combinatorial logic these are basic combinators, for example, the set S, K, I: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Ix</span></span> = Ix = x -   Kxy = (Kx)y = x -   Sxyz = ((Sx)y)z = (xz)(yz) - </code> </pre><br><div class="spoiler">  <b class="spoiler_title">SKI on hardware tree</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/7ad/931/c30/7ad931c300a74c2d8186d23ac5348680.png"><img align="right" src="https://habrastorage.org/files/a86/e9b/ccb/a86e9bccbe1d46ba9442daa5962fb814.png"><br><img src="https://habrastorage.org/files/d17/f55/bef/d17f55bef03748d087f3e55d800ac62a.png"><br></div></div><br><br>  The syntax for the assembler will be borrowed from the <a href="https://ru.wikipedia.org/wiki/Unlambda">unlambda</a> esoteric functional programming <a href="https://ru.wikipedia.org/wiki/Unlambda">language</a> (as promised <a href="http://habrahabr.ru/post/203018/">in this publication, at the very end</a> ): <br><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">`ix = Ix `</span></span><span class="hljs-string"><span class="hljs-string">`kxy = (Kx)y `</span></span><span class="hljs-string"><span class="hljs-string">``</span></span>sxyz = ((Sx)<span class="hljs-keyword"><span class="hljs-keyword">y</span></span>)z</code> </pre><br>  This solution allows the use of <a href="https://habr.com/ru/post/249413/">the unlambda interpreter</a> to verify the correctness of the calculations. <br>  Here is a stroke (`) symbol of the function application.  A prefix notation is used, that is, `fx = f (x). <br>  F (G (X, Y), H (Z, V)) = `` F``GXY``HZV <br>  In this form, the expression is fed to the input of the machine.  The download takes place through the root of the tree, the external device symbolically transfers the program to the root node, which the first character picks up for itself, and transfers the rest to its descendants, each of which performs the loading procedure recursively.  Having received the subtree completely, the node reports this to the ancestor and begins to execute its part of the program. <br><br><h2>  Work examples </h2><br>  For example, let's calculate the Boolean expression, <b>"(1 | 0) &amp; (0 | 1)"</b> .  In the combinatorial basis, this can be represented as <b>`` `` ssk````siik`ki````sii`kik</b> Yes, such expressions are impossible to read, but they can be written, see the <a href="https://habr.com/ru/post/249413/">textbook</a> .  As a result of executing a program of this type, the state of the machine will evolve from the original formula to a single boolean value, either <b>‚Äú1‚Äù</b> , encoded as <b>‚Äúk‚Äù</b> , or the value <b>‚Äú0‚Äù</b> in the form of <b>`` ki '</b> .  For this particular formula, we get exactly <b>‚Äúk‚Äù</b> . <br>  The calculation takes 116 cycles.  Of these, the first 67 bars continue to load the program.  From the point of view of practical utility, the figures are not encouraging, but there is potential for optimization, for example, using a richer set of combinators will reduce the size and runtime of the program. <br><br><h3>  Simulator and FPGA version </h3><br>  The described results were obtained on a software simulator.  Sources and executable file for win <a href="https://bitbucket.org/leshabirukov/mock/downloads">here</a> .  The simulator is a console application, does not require installation, the combinatorial expression is passed as a command line parameter. <br><div class="spoiler">  <b class="spoiler_title">A brief description of the simulator window in interactive mode.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/3e9/fd1/657/3e9fd165705445968c5d8b30b5b34060.png"><br><br>  1) Program at the entrance <br>  2) The current state of the program as text <br>  3) Full state of hardware tree <br>  4) Deciphering the status of the current node <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Here is a small video demonstration</b> <div class="spoiler_text"><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/3QLKp18Sj58%3Ffeature%3Doembed&amp;xid=25657,15700002,15700022,15700186,15700191,15700253&amp;usg=ALkJrhj7JD95ScA5Tqvp5Wtwu7ZsatNNzQ" frameborder="0" allowfullscreen=""></iframe><br></div></div><br>  The simulator exactly corresponds to the FPGA version implemented in the verilog, but with one fundamental difference - it is not limited in physical resources.  That is, the simulator has a potentially infinite tree, and on FPGA the tree is limited.  A tree of 63 knots, that is, a depth of 6, occupies 16,000 Altera LE, which is a lot;  if the program grows more in the course of the calculation, the calculations end in failure.  The only benefit from the hardware version is to show the principle realizability in hardware. <br><br>  Let's return to the calculations.  Now we calculate the arithmetic expression, <b>(2 + 1)</b> .  To translate this into the language of combinatorial logic, we use the Church numerals.  We <b>get the</b> expression <b>`` `` si`k`s``s`kski``````</b>  To get something meaningful, we substitute this expression like this: <b>`` (2 + 1) ki</b> .  Calculating this we get <b>`k`k`ki</b> , the number of letters <b>k</b> symbolizes the answer received.  The calculation takes 124 clocks.  But the calculation of <b>`` (1 + 2) ki</b> takes already 243 clocks, <b>`` (3 + 3) ki</b> 380 clocks.  Alas, while everything is very slow, below I have marked the path to acceleration. <br>  The examples given are simple, unconditionally ‚Äúcollapsing‚Äù expressions, in practice such tasks are better performed by a traditional machine.  However, combinatorial logic being a Turing complete system, allows solving problems of greater computational complexity, the corresponding expressions can grow in the course of calculation.  True, this property brings the risk of unrestrained growth or even a never-ending program, but the advantage the proposed architecture can only show on such tasks.  Here in the description there are cycles and recursion, the classic construction for their organization, the fixed point combinator: <br><br>  <b>`Yx =` x`Yx = `x`x`Yx =` x`x`x`x ...</b> <b><br></b>  <b>Y (x) = x (Y (x)) = x (x (x (x (...))))</b> <br><br><h1>  Hypothetical use of the combinatorial machine in practice </h1><br><h2>  Logical conclusion </h2><br>  The above two simple examples show that Boolean calculations look more interesting than arithmetic, the machine is very sensitive to the size of objects.  But the calculation of Boolean expressions in itself is not very promising: the task, even on a sequential machine, is performed in O (1), that is, the program will load longer than it is executed. <br>  This ‚Äúflaw‚Äù is devoid of the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25B2%25D1%258B%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D0%25B1%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B2%25D1%258B%25D1%2585_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D1%2583%25D0%25BB">SAT</a> task.  Here we have a boolean expression complemented by variables, and it is necessary to determine whether the formula holds;  This is an NP-complete problem.  You can achieve significant acceleration by simultaneously checking several sets of variable values.  It is to this type of tasks I now look at.  Interesting problems with unpredictable branches and without large numbers, such as symbolic calculations and automatic proof of theorems. <br>  The ideal task should be formulated with a small expression that first grows like a tree from a seed, forming as many parallel branches as possible and then roll back, combining the results from the branches, something like micro MapReduce: <br><br><img src="https://habrastorage.org/files/f40/63d/33e/f4063d33ef5d4636b1216d1c873b355d.png" width="600"><br><br><h2>  Reconfigurable computations </h2><br>  There is one more direction of possible applications: <a href="https://en.wikipedia.org/wiki/Reconfigurable_computing">reconfigurable calculations</a> .  The idea is this: to supplement the alphabet of the machine with special blocks that are not combinators, but carry a special meaning external to the language.  Work in two phases, the combinatorial machine works in the first phase.  During the execution of the program, all the combinators must calculate, and only the special blocks remain, which form some desired structure, which (in the second phase) will perform the target work. <br><br>  For example, if we take logical elements as special blocks, we can obtain a dynamic FPGA, which, on request, will generate, on the fly, say, a multiplier by the required constant or adder of the calculated width from the parameterized adder circuit. <br><br><img src="https://habrastorage.org/files/72e/d22/a7e/72ed22a7e8b44150942f51b45e04c985.png"><br><br>  We did almost the same thing above, when we applied the Churchill number <b>(3 + 3)</b> to the combinators <b>k</b> and <b>i</b> , which were not executed (as functions) in the calculation process, but served to visualize the result.  Replacing <b>k</b> with a one-bit adder, we would get a conditional digit adder 6 by the time the calculations were completed. <br><br>  This potential application is not so demanding on performance, provided that reconfiguration is required not too often. <br><br><h1>  Directions of development, problems and their possible solutions </h1><br><h2>  Efficient use of nodes </h2><br>  Since the functional program tree is rather sparse, laying it on a balanced static binary tree is very disadvantageous.  Therefore, in the near future, the transition to a hardware dynamic tree that will live on a regular graph, working on the principle of a <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B5%25D1%2582%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">cellular automaton</a> . <br><div class="spoiler">  <b class="spoiler_title">Something like that, on the left, an expression, on the right, its laying on a hypothetical apparatus</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/1dd/a1f/725/1dda1f72593747689f06983660004c30.png"><br></div></div><br>  But any graph is finite, and many functional expressions tend to grow indefinitely, especially with <a href="http://en.wikipedia.org/wiki/Eager_evaluation">vigorous execution</a> ;  This is another problem that needs to be addressed in the future.  Now, rather, an energetic rather than lazy computation strategy is used, it will probably have to be modified, but in order to do this, you need to find a model problem that is close to practical one. <br><br><h2>  Command system expansion </h2><br>  A certain benefit in terms of optimization can be obtained by expanding the set of hardware-implemented combinators, the basic set of SKI is now used, other combinators may be useful, including <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Bxyz</span></span> = x(yz) -    y Cxyz = xzy - , Wxy = xyy - , Yx = x(Yx) -   . (+<span class="hljs-number"><span class="hljs-number">1</span></span>)nfx = f(nfx) -   </code> </pre><br><br>  There is no input-output per se, the answer is given by the program body itself, transformed during execution.  Thoughts as it was possible to realize IO is, but for now this task is not my priority. <br><br>  Now the machine uses the transfer of parameters by value, which leads to the need to copy the arguments, in fact, most of the time the machine is engaged in copying.  It would be tempting to implement the transfer by reference, the program interpreter takes the efficiency of such a transition by several orders of magnitude!  How to implement this on the hardware network of nodes, I still have little idea, but when there is an indicative practical task, I intend to seriously deal with this. <br><br>  Another function that potentially extends the capabilities of the machine is hardware pattern matching, in particular, testing subtrees for equality. <br>  Increasing the level of programming is also in the list of priorities, while all forces are going to improve the simulator. <br><br><h2>  About lambdas </h2><br>  The more successful sister of combinatorial logic is lambda calculus.  Is it possible to modify the computational tree for this version of functional programming?  I guess, yes.  The main trouble is that we have a potentially infinite number of variable names, which means that a variable call cannot be placed on one hardware node (final).  But it can be solved;  in principle, it is possible to switch to lambda calculus, as a more popular model.  I stopped at combinatorial logic, as combinators are more elegantly projected on operations with subtrees. <br><br><h1>  Prehistory </h1><br>  I adopted the idea of ‚Äã‚Äãcreating a specialized calculator of functional programs from my supervisor, Vadim Nikolaevich Falk, when I studied at the MIREA postgraduate a dozen years ago.  The scientific work of the team focused on theoretical studies in the field of functional and functional logic programming.  In particular, Falk developed the Falgol language, a kind of functional assembler.  It was positioned for theoretical and computational purposes, such as proving the correctness of programs, but there were also attempts to build a computer based on it. <br><br>  I did a little bit different and didn‚Äôt really succeed, to be honest, but the idea to create a functional-logical calculator sown and after 10 years did sprout.  All this time, I worked as a system programmer in a <a href="http://www.module.ru/">company</a> developing iron, including microcircuits, which allowed me to master the basics of digital circuitry, and bring it to a hardware prototype. <br><br><h1>  Conclusion </h1><br>  The project is progressing.  It was possible to create a prototype not the background of the Neumann computer combining the features of several interesting paradigms: functional programming, cellular automata;  analogues are not known to me.  The FPGA-variant is so far not very useful due to the limitations in capacity, but a software simulator that exactly corresponds to the hardware model makes it possible to study the execution of programs.  There is no talk about practical use in the current form, but I'm already looking for a model task that will be taken as a goal for the future use of the machine. <br>  Finally, I note once again that modern development of electronics makes it possible to implement very non-trivial ideas, although this is a laborious task.  Thanks for attention. <br><br><h1>  Links </h1><br><a name="ref_darkus"></a>  RV Dushkin aka <a href="http://habrahabr.ru/users/darkus/" class="user_link">darkus</a> <a href="http://ru.wikibooks.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25E2%2580%2594_%25D1%258D%25D1%2582%25D0%25BE_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE!">"Combinators are easy"</a> <br><a name="ref_madore"></a>  David Madore <a href="http://www.madore.org/~david/programs/unlambda/">"The Unlambda Programming Language"</a> <br><a name="ref_interpreter"></a>  <a href="http://inazz.jp/unlambda/">Unlambda language interpreter</a> </div><p>Source: <a href="https://habr.com/ru/post/249413/">https://habr.com/ru/post/249413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249403/index.html">We write the load tester on Node.js</a></li>
<li><a href="../249405/index.html">Forensic system administration</a></li>
<li><a href="../249407/index.html">Browser Vivaldi - the latest news and announcements</a></li>
<li><a href="../249409/index.html">Reverse engineering of Parktronic protocol. Dance of little bits</a></li>
<li><a href="../249411/index.html">The digest of interesting materials for the mobile developer # 88 (January 26 - February 1)</a></li>
<li><a href="../249415/index.html">Overview of the most interesting materials on data analysis and machine learning ‚Ññ33 (January 26 - February 1, 2015)</a></li>
<li><a href="../249417/index.html">Breeze Server - we delimit access to objects using attributes</a></li>
<li><a href="../249419/index.html">Methods for modifying machine code: "selection" vs. "Genetic Engineering"</a></li>
<li><a href="../249421/index.html">Robot on RaspberryPi, Arduino and RaspiCam + OpenCV. Part 1 Review</a></li>
<li><a href="../249423/index.html">Find typos in ** kwargs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>