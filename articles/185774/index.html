<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UEFI BIOS File Device Part Two: UEFI Firmware Volume and its contents</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Behind one and a half (the first , one and a half ) parts of this article, now finally the time has come to talk about the structure of the UEFI Firmw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UEFI BIOS File Device Part Two: UEFI Firmware Volume and its contents</h1><div class="post__text post__text-html js-mediator-article">  Behind one and a half (the <a href="http://habrahabr.ru/post/185704/">first</a> , <a href="http://habrahabr.ru/post/185764/">one and a half</a> ) parts of this article, now finally the time has come to talk about the structure of the UEFI Firmware Volume and the format of the UEFI File System. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  I‚Äôll say right away that in this part of the article I will describe the file formats of version 2, since  they are used in all existing BIOSes.  In the latest versions of the <abbr title="UEFI Platform Initialization">PI</abbr> standard, a description of the formats of version 3 has been added, but they are needed for files larger than 16 MB, which are not on any motherboard yet, although Gigabyte has already come close to this line on its Z87 boards.  The Descriptor region on all modern Intel motherboards supports no more than 2 chips with a capacity of no more than 16 MB, so the use of version 3 formats is postponed until the next generation of Intel chipsets at least. <br><br>  As an example, take the BIOS region from <a href="">the version 229 file</a> for the Zotac Z77-ITX WiFi. <br>  We will need the following programs: <br><ul><li>  Hex editor to your taste, I will use HxD </li><li>  Utility PhoenixTool v2.xx, which can be downloaded from the <a href="http://forums.mydigitallife.info/threads/13194-Tool-to-Insert-Replace-SLIC-in-Phoenix-Insyde-Dell-EFI-BIOSes">topic on the forum MDL</a> </li></ul><br><h4>  Firmware Volume </h4><br>  The structure of the Firmware Volume and the PI <abbr title="Firmware File System">FFS</abbr> format are described in Volume 3 of the UEFI Platform Initializaton documentation. <br>  Firmware Volume is a logical representation of flash content, with the following attributes: <br><ol><li>  Name: FID and all its parts are their GUIDs </li><li>  Size: includes all data, headers and free space </li><li>  Format: file system type inside FV, different types have different GUIDs </li><li> Allignment: requires that the first byte of FV be aligned to the specified boundary, a multiple of degree 2. The alignment of FV should not be weaker than the alignment of all files within it, unless the <code>EFI_FVB_WEAK_ALIGNMENT</code> flag is set in the header.  In this case, alignment can be done on any power of 2, but this FV can no longer be moved. </li><li>  Attributes of protection from reading, writing, self-deactivating protection from reading or writing </li><li>  OEM attributes at manufacturer‚Äôs discretion </li></ol><br>  Regardless of the file system used inside the FV, the FV header is standardized and looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT8 ZeroVector[<span class="hljs-number"><span class="hljs-number">16</span></span>]; UINT8 FileSystemGuid[<span class="hljs-number"><span class="hljs-number">16</span></span>]; UINT64 FvLength; UINT32 Signature; UINT32 Attributes; UINT16 HeaderLength; UINT16 Checksum; UINT16 ExtHeaderOffset; UINT8 Reserved[<span class="hljs-number"><span class="hljs-number">1</span></span>]; UINT8 Revision; EFI_FV_BLOCK_MAP BlockMap[]; } EFI_FIRMWARE_VOLUME_HEADER; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT32 NumBlocks; UINT32 Length; } EFI_FV_BLOCK_MAP</code> </pre><br>  <b>ZeroVector</b> : At the beginning of the FV, 16 bytes are reserved for compatibility with processors whose reset vector is at the zero address.  By the presence of something other than zeros in this block, you can unmistakably distinguish the Boot Firmware Volume among the rest. <br>  <b>FileSystemGuid</b> : defines the file system used in this FV. <br>  <b>FvLength</b> : FV size including all headers. <br>  <b>Signature</b> : used to search for FV and by standard is always 0x4856465F, i.e.  <code>{'_','F','V','H'}</code> . <br>  <b>Attributes</b> : the very attributes that we talked about above.  They are there quite a lot, but the most important thing for us is above <code>EFI_FVB_WEAK_ALIGNMENT</code> , making FV unmovable, if not installed, one of a set <code>EFI_FVB_ALIGNMENT</code> from <code>EFI_FVB_ALIGNMENT_1</code> to <code>EFI_FVB_ALIGNMENT_2G</code> and <code>EFI_FVB_ERASE_POLARITY</code> , indicating how it is a bit flash chip erase is performed.  The rest are needed by the code that works with FV as a memory area, and are useless for us, so we will not list them. <br>  <b>HeaderLength</b> : Header size excluding the extended header, about which below. <br>  <b>Checksum</b> : 16-bit header checksum.  A valid header should be summed at 0x0000. <br>  <b>ExtHeaderOffset</b> : the start offset of the extended header.  It can contain the GUID of the described FV, a list of OEM file types along with their GUIDs, as well as an electronic signature.  At the moment I have not met a single FV with a filled extended header, so we will not consider it.  If there is no additional header for FV - in this field 0x0000. <br>  <b>Reserved</b> : reserved field, always 0x00. <br>  <b>Revision</b> : The PI standard describes the structure of only one revision ‚Äî the second, so this field is always 0x02. <br>  <b>BlockMap</b> : block map stored as a list of <code>EFI_FV_BLOCK_MAP</code> structures, ending in the same structure with zeros in both fields.  Since  Since all modern flash chips are homogeneous (i.e. have blocks of the same size), the entire list usually consists of only two entries. <br><br>  Let's check our example for compliance with the above. <br>  Open our BIOS file in a hex editor and move to offset 0x500000, to the beginning of the BIOS region. <br><img src="https://habrastorage.org/storage2/d5f/4c9/4ab/d5f4c94abd1b747da96cd6a0f50381e1.png"><br>  We see that there are 16 zeros at the beginning, the file system GUID is available, the size of this FV is 0x020000, the signature is in place, the attributes are set, the header is 0x48 bytes, the checksum is calculated, there is no extended header, the reserved fields are in place, and inside this FV has 20 blocks of 0x1000, which in total gives the size specified in the FvLength field. <br>  Most often, the BIOS has several different FVs designed for different purposes, although this is not necessary and you can pack everything into one.  The champion in the degree of nesting of FV and files into each other among all manufacturers of UEFI BIOSes is Intel, where nesting up to 12 levels is encountered. <br>  Although theoretically for FV different file systems can be used, in practice only one is used - PI FFS, which we will talk about now. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Firmware File System </h4><br>  This is a flat file system without directories and hierarchies, all files of which are in the horse directory.  Getting a list of files requires a pass through the file system from beginning to end.  All files must have a standard-defined header.  Files must be aligned along an eight-byte boundary relative to the beginning of the file system; a special filler file is provided for alignment along large boundaries. <br>  Also, the standard describes a special <abbr title="Volume Top File">VTF</abbr> file that must be present at the end of each FV, but in practice it is present only at the end of the last FV in the BIOS image and is located so that its last byte is also the last in the entire chip.  It contains the boot code needed for the SEC phase. <br><br><h5>  File header </h5><br>  The header of the FFS file is as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT8 Name[<span class="hljs-number"><span class="hljs-number">16</span></span>]; UINT8 HeaderChecksum; UINT8 DataChecksum; UINT8 Type; UINT8 Attributes; UINT8 Size[<span class="hljs-number"><span class="hljs-number">3</span></span>]; UINT8 State; } EFI_FFS_FILE_HEADER;</code> </pre> <br>  <b>Name</b> : The GUID of the file acting as the name.  In one FV can not be two files with the same GUID, if it is not PAD-files, about which below. <br>  <b>HeaderChecksum</b> : eight-bit header checksum, excluding the DataChecksum field.  A valid header should be summed at 0x00. <br>  <b>DataChecksum</b> : an eight-bit checksum of the contents of the file, excluding the header.  Its calculation is not always required, but only if the <code>FFS_ATTRIB_CHECKSUM</code> attribute is <code>FFS_ATTRIB_CHECKSUM</code> , otherwise this field is set to 0xAA. <br>  <b>Type</b> : file type.  The standard defines 13 standard file types (0x01 - 0x0D), 32 custom types for OEM files (0xC0 - 0xDF), 16 custom types for debugging (0xE0 - 0xEF) and 16 types specific to the current version of FFS (0xF0 - 0xFF) of which only 0xF0 is currently used - <code>EFI_FV_FILETYPE_FFS_PAD</code> for the placeholder file. <br>  This special file can have any, including null GUID, null attributes, standard state and any size.  According to the standard, the file must be empty, i.e.  all its bits, except the header bits, must be set to <code>EFI_FVB_ERASE_POLARITY</code> .  It is used to align the file following it on the border, more than the standard 8 bytes.  The minimum size of the PAD-file is equal to the size of the header - 24 bytes. <br>  We will return to the standard file types. <br>  <b>Attributes</b> : important attributes for us are <code>FFS_ATTRIB_FIXED</code> , indicating that the file is not <code>FFS_ATTRIB_FIXED</code> inside FV and set FFS_ATTRIB_DATA_ALIGNMENT, indicating that the data (not the header) of the file is aligned along any boundary. <br>  <b>Size</b> : The size of the file, along with the header, is stored as 24-bit UINT. <br>  <b>State</b> : file state.  This field is used after FV is loaded into memory and during file operations inside FV.  The state of all valid files within the BIOS image is 0xF8. <br><br>  We now return to the file types.  I recommend that those who have not read the one-and-a-half of this article <a href="http://habrahabr.ru/post/185764/">go and read</a> , otherwise you risk not understanding anything. <br>  As we already know, 13 standard file types are defined, here they are: <table><tbody><tr><th>  <nobr>Title</nobr> </th><th>  <nobr>Type of</nobr> </th><th>  <nobr>Description</nobr> </th></tr><tr><td>  <nobr>RAW</nobr> </td><td>  <nobr>0x01</nobr> </td><td>  The structure of such a file is completely determined by its user, and nothing is known about it in advance. </td></tr><tr><td>  <nobr>Freeform</nobr> </td><td>  <nobr>0x02</nobr> </td><td>  Such a file has a sectional structure, but nothing is known in advance about the contents of the sections. </td></tr><tr><td>  <nobr>SECURITY_CORE</nobr> </td><td>  <nobr>0x03</nobr> </td><td>  Security kernel executing code in SEC phase </td></tr><tr><td>  <nobr>PEI_CORE</nobr> </td><td>  <nobr>0x04</nobr> </td><td>  PEI core, it‚Äôs the PEI Foundation </td></tr><tr><td>  <nobr>DXE_CORE</nobr> </td><td>  <nobr>0x05</nobr> </td><td>  DXE core, it‚Äôs also the DXE Foundation </td></tr><tr><td>  <nobr>PEIM</nobr> </td><td>  <nobr>0x06</nobr> </td><td>  PEI module </td></tr><tr><td>  <nobr>DRIVER</nobr> </td><td>  <nobr>0x07</nobr> </td><td>  DXE driver </td></tr><tr><td>  <nobr>COMBINED_PEIM_DRIVER</nobr> </td><td>  <nobr>0x08</nobr> </td><td>  PEI / DXE Hybrid Module </td></tr><tr><td>  <nobr>APPLICATION</nobr> </td><td>  <nobr>0x09</nobr> </td><td>  Application.  It differs from the DXE driver in that it is not the DXE dispatcher that launches it, but the user.  Applications are UEFI Setup, UEFI Shell, BIOS Update, etc. </td></tr><tr><td>  <nobr>SMM</nobr> </td><td>  <nobr>0x0A</nobr> </td><td>  SMM module </td></tr><tr><td>  <nobr>FIRMWARE_VOLUME_IMAGE</nobr> </td><td>  <nobr>0x0B</nobr> </td><td>  FV image.  This is a special file that allows you to put one FV into another. </td></tr><tr><td>  <nobr>COMBINED_SMM_DXE</nobr> </td><td>  <nobr>0x0C</nobr> </td><td>  SMM / DXE Hybrid Module </td></tr><tr><td>  <nobr>SMM_CORE</nobr> </td><td>  <nobr>0x0D</nobr> </td><td>  SMM core, it is SMM Init </td></tr></tbody></table><br>  Check the above on our file: <br><img src="https://habrastorage.org/storage2/d85/79b/fcc/d8579bfccaa6daf5764c9dc0a96071ac.png"><br>  The first 0x48 bytes of the FV header no longer interest us, but what is right behind them.  It can be seen that there is a file with a GUID CEF5B9A3-476D-497F-9FDC-E98143E0422CN, a checksum of the header 0x36, a checksum of the data 0xAA, which indicates the removed attribute <code>FFS_ATTRIB_CHECKSUM</code> , type RAW (0x01), without attributes, 0x1FFa size, 0xFFa, without attributes, of size 0xFF, <code>FFS_ATTRIB_CHECKSUM</code> , <code>FFS_ATTRIB_CHECKSUM</code> , type RAW (0x01), without attributes, size 0x1KBFF, CHFKSKSUM; .  It looks like the truth. <br><br>  Now about the sections.  All FFS files, except RAW, must be divided into sections, aligned at the border of 4 bytes from the beginning of the file data area.  Each standard file type has its own requirements for the number and type of sections, but the list of requirements in this article will not be - it is too long and too boring.  But the section headings, their purpose and types, we now consider. <br><br><h5>  Section Header </h5><br>  The minimum section header is: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT8 Size[<span class="hljs-number"><span class="hljs-number">3</span></span>]; UINT8 Type; } EFI_COMMON_SECTION_HEADER;</code> </pre><br>  <b>Size</b> : the size of the section in the same format as in the file header. <br>  <b>Type</b> : section type. <br>  Sections are divided into two subclasses - encapsulation and leaf.  The first may contain sections of other types, and the second directly contain data.  Sections of some types have extended headers, but the beginning always coincides with the general one. <br>  For encapsulation sections, 3 types of content are defined: <br>  0x01 - <code>EFI_SECTION_COMPRESSION</code> , indicates that the section is compressed by any algorithm. <br>  The full EFI_COMPRESSION_SECTION header (the words in the title are not mixed up, just like that) looks like this: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> UINT8 Size[<span class="hljs-number"><span class="hljs-number">3</span></span>]; UINT8 Type; UINT32 UncompressedSize; UINT8 CompressionType; } EFI_COMPRESSION_SECTION;</code> </pre> <br>  <b>UncompressedSize</b> : the size of the unpacked data. <br>  <b>CompressionType</b> : the compression algorithm used. <br>  At the moment, there are 2 compression algorithms - Tiano (0x01) and LZMA (0x02).  If the section was unpacked without changing the structure, then the compression type is set to 0x00, and the section size coincides with the size of the packed data.  The Tiano algorithm is a combination of LZ77 and Huffman code by Intel, compression and unpacking code can be taken from the TianoCore project files under BSDL.  The LZMA algorithm is too well known to tell about it again, the compression and decompression code is in the LZMA SDK. <br><br>  Let's continue about the types of encapsulation sections: <br>  0x02 - <code>EFI_SECTION_GUID_DEFINED</code> , indicates that the contents of the section should be viewed by the user of the file in accordance with the GUID recorded in it.  It is in this section that various OEM data can be stored, as well as electronic signature of the section or the entire file. <br>  0x03 - <code>EFI_SECTION_DISPOSABLE</code> , indicates a section in which data is not important for the operation of the file and can be deleted when reassembling to save space.  In real files, the BIOS is not found. <br>  For leaf sections 12 content types are defined: <br><table><tbody><tr><th>  <nobr>Title</nobr> </th><th>  <nobr>Type of</nobr> </th><th>  <nobr>Description</nobr> </th></tr><tr><td>  <nobr>PE32</nobr> </td><td>  <nobr>0x10</nobr> </td><td>  64-bit executable code in PE32 + format with all its headers.  The main format of executable code in UEFI. </td></tr><tr><td>  <nobr>Pic</nobr> </td><td>  <nobr>0x11</nobr> </td><td>  64-bit executable code that does not depend on position.  Used only by some PEI modules, the format is the same as PE32 +, only relocation information is truncated. </td></tr><tr><td>  <nobr>TE</nobr> </td><td>  <nobr>0x12</nobr> </td><td>  64-bit executable code used by modules and core PEI.  It differs from PE32 + in the header, which is reduced to save space in the processor cache.  Read the description in the half part of this article. </td></tr><tr><td>  <nobr>DXE_DEPEX</nobr> </td><td>  <nobr>0x13</nobr> </td><td>  A section describing the dependencies of the DXE driver in which it is located.  The format of this section is described in Volume 2. </td></tr><tr><td>  <nobr>VERSION</nobr> </td><td>  <nobr>0x14</nobr> </td><td>  Contains file version and optionally Unicode string with full version.  It is quite rare. </td></tr><tr><td>  <nobr>USER_INTERFACE</nobr> </td><td>  <nobr>0x15</nobr> </td><td>  Contains a unicode-term file name.  It is very convenient to search for files by the contents of this section.  It is used frequently, but there are also BIOSes without a single file with such a section. </td></tr><tr><td>  <nobr>COMPATIBILITY16</nobr> </td><td>  <nobr>0x16</nobr> </td><td>  16-bit executable code for compatibility with older systems. </td></tr><tr><td>  <nobr>FIRMWARE_VOLUME_IMAGE</nobr> </td><td>  <nobr>0x17</nobr> </td><td>  FV image section.  Inside this FV there may be another file with such a section, and so on, until the space in the chip ends. </td></tr><tr><td>  <nobr>FREEFORM_SUBTYPE_GUID</nobr> </td><td>  <nobr>0x18</nobr> </td><td>  The section contains data whose interpretation depends on the recorded GUID of its beginning.  Used rarely. </td></tr><tr><td>  <nobr>RAW</nobr> </td><td>  <nobr>0x19</nobr> </td><td>  Raw data section.  What to do with them is determined by the one who opened this file. </td></tr><tr><td>  <nobr>PEI_DEPEX</nobr> </td><td>  <nobr>0x1B</nobr> </td><td>  Section describing the dependencies of the PEI module in which it is located.  The format of this section is described in Volume 1. </td></tr><tr><td>  <nobr>SMM_DEPEX</nobr> </td><td>  <nobr>0x1C</nobr> </td><td>  The section describing the dependencies of the SMM driver in which it is located matches the format of DXE_DEPEX. </td></tr></tbody></table><br>  Let's check the above with our example.  The file of the RAW type considered last time does not contain any sections, so we take another file, namely, the PEI module named PchUsb, located at offset 0x7AD210: <br><img src="https://habrastorage.org/storage2/3c9/565/6f8/3c95656f83004070ce1b4380dbdb7678.png"><br>  It can be seen that this is really PEIM (file type - 0x06), which contains two sections.  The first section of size 0x3A and type PEI_DEPEX (0x1B) contains information about its dependencies.  The second section (aligned on the border of 4 bytes) has a size of 0x31A and a type COMPRESSED_SECTION (0x01), and the data in it are packed with the LZMA algorithm (0x02) and after unpacking they have a size of 0x558.  If you can unpack LZMA in your mind, you have already guessed what is inside this section, but if not, I will tell you.  There are 2 more sections: PE32 with the executable code of the module and USER_INTERFACE with the file name.  You ask, how do I know this, if I can not unpack LZMA in my mind?  There's an app for that! <br><br><h4>  PhoenixTool and Conclusion </h4><br>  This application is called PhoenixTool and its main task is to add SLIC to the UEFI BIOS files, but we are not law-abiding people and we will not add SLIC to our BIOS.  Of all the functions of the program, we will be interested in the Structure button, available after specifying the BIOS, with which we will work.  The structure opens in a separate window and presents the UEFI BIOS image as a tree.  For each component on the right displays information about it and the available actions.  The above file in this window looks like this: <br><img src="https://habrastorage.org/storage2/df4/061/f7a/df4061f7a918cb299a36404fcf59d82c.png"><br>  The program allows limited editing of the file structure, but it is best not to change it, to avoid. <br><br>  How exactly it is better to edit the executable modules of UEFI and what it can give in the next article. <br>  Thanks for attention. <br><br><h4>  Literature </h4><br>  <a href="">UEFI Platform Initialization Specification 1.2.1 Errata A, Documents by UEFI Forum</a> </div><p>Source: <a href="https://habr.com/ru/post/185774/">https://habr.com/ru/post/185774/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185764/index.html">Device file UEFI BIOS, part and a half: UEFI Platform Initialization</a></li>
<li><a href="../185766/index.html">Vkontakte iOS SDK v2</a></li>
<li><a href="../185768/index.html">Oracle 12c Data Redaction. Hiding information from unprivileged users</a></li>
<li><a href="../185770/index.html">QLiveBittorrent - console bittorrent client for viewing files before downloading</a></li>
<li><a href="../185772/index.html">Technology companies recognize sarcasm</a></li>
<li><a href="../185778/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ64 (June 30 - July 6, 2013)</a></li>
<li><a href="../185782/index.html">VDS in the Netherlands Intel Xeon X3440 / 2-3 GB RAM / 220 GB HDD RAID1 / 25Mbps Unmetered - $ 29 / month</a></li>
<li><a href="../185784/index.html">Yandex employees warn about the incorrect operation of the odnaknopka.ru service</a></li>
<li><a href="../185786/index.html">Google pays Adblock Plus developers to skip their ads.</a></li>
<li><a href="../185788/index.html">Nginx boilerplate: Quick and elegant nginx setup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>