<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Numerical solution of mathematical models of objects given by systems of differential equations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction: 
 In mathematical modeling of a number of technical devices, systems of differential nonlinear equations are used. Such models are used ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Numerical solution of mathematical models of objects given by systems of differential equations</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction: </h3><br>  In mathematical modeling of a number of technical devices, systems of differential nonlinear equations are used.  Such models are used not only in technology, they are used in economics, chemistry, biology, medicine, management. <br><br>  The study of the functioning of such devices requires the solution of these systems of equations.  Since the main part of such equations are nonlinear and non-stationary, it is often impossible to obtain their analytical solution. <br><br>  There is a need to use numerical methods, the most famous of which is the Runge ‚Äì Kutta method [1].  As for Python, in publications on numerical methods, for example [2,3], there are very few data on the use of Runge - Kutta, and on its modification - in general there is no Runge-Kutta-Fellberg method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Currently, thanks to a simple interface, the most popular in Python is the odeint function from the scipy.integrate module.  The second ode function from this module implements several methods, including the mentioned five-rank Runge-Kutta-Fellberg method, but due to its universality, it has limited speed. <br><br>  The purpose of this publication is a comparative analysis of the listed tools for the numerical solution of systems of differential equations with a modified author under the Python method of Runge-Kutta-Fellberg.  The publication also provides solutions for boundary value problems for systems of differential equations (SDEs). <br><a name="habracut"></a><br><h3>  Brief theoretical and actual data on the considered methods and software for the numerical solution of the CDS </h3><br>  <b>Cauchy problem</b> <br><br>  For a single differential equation of the nth order, the Cauchy problem is to find a function that satisfies the equality: <br><br><img src="https://habrastorage.org/webt/lt/b1/2t/ltb12ttbaok7cykpov2wr1ll2d8.png"><br><br>  and initial conditions <br><br><img src="https://habrastorage.org/webt/wu/hv/h6/wuhvh6vc6lvhbtjv9cpdt2ngwpk.png"><br><br>  Before solving this problem should be rewritten in the form of the next CDS <br><br><img src="https://habrastorage.org/webt/of/ae/6d/ofae6da97foimjlsgplerdbgmw4.png">  (one) <br><br>  with initial conditions <br><br><img src="https://habrastorage.org/webt/5h/yr/dx/5hyrdxv0rgrvdlb_wfqcx-xu8yc.png"><br><br>  <b>Module scipy.integrate</b> <br><br>  The module has two functions ode () and odeint (), designed to solve systems of ordinary differential equations (ODE) of the first order with initial conditions at one point (the Cauchy problem).  The ode () function is more versatile, and the odeint () function (ODE integrator) has a simpler interface and solves most problems well. <br><br>  <b>Odeint () function</b> <br><br>  The odeint () function has three required arguments and many options.  It has the following format: odeint (func, y0, t [, args = (), ...]) The argument func is the name of the Python function of two variables, the first of which is the list y = [y1, y2, ..., yn ], and the second is the name of the independent variable. <br><br>  The func function should return a list of n function values. <img src="https://habrastorage.org/webt/px/uq/ut/pxuqutrevt661xvfc3wxjldgvem.png">  for a given value of the independent argument t.  In fact, the function func (y, t) implements the calculation of the right-hand sides of the system (1). <br><br>  The second argument y0 of the odeint () function is an array (or list) of initial values. <img src="https://habrastorage.org/webt/el/kx/j9/elkxj9mf1tffldehq2mqdvbl0mi.png">  at t = t0. <br><br>  The third argument is an array of points in time at which you want a solution to the problem.  In this case, the first element of this array is considered as t0. <br><br>  The odeint () function returns an array of size len (t) x len (y0).  The odeint () function has many options that control its operation.  The options rtol (relative error) and atol (absolute error) determine the calculation error ei for each value of yi using the formula <br><br><img src="https://habrastorage.org/webt/qq/3a/pp/qq3appk_s2ck4bvifmd7mozxqyi.png"><br><br>  They can be vectors or scalars.  Default <br><br><img src="https://habrastorage.org/webt/ha/lb/jo/halbjokez-c-a9ur0xeyp8pifew.png"><br><br>  <b>Ode () function</b> <br><br>  The second function of the scipy.integrate module, which is designed to solve differential equations and systems, is called ode ().  It creates an ODU object (type scipy.integrate._ode.ode).  Having reference to such an object, its methods should be used to solve differential equations.  Similar to the odeint () function, the ode (func) function assumes the reduction of a problem to a system of differential equations of the form (1) and the use of its function on the right-hand sides. <br><br>  The only difference is that the function of the right-hand sides func (t, y) takes the independent variable as the first argument, and the second as the list of values ‚Äã‚Äãof the desired functions.  For example, the following sequence of instructions creates an ODE object representing the Cauchy task. <br><br>  <b>Runge ‚Äî Kutta Method</b> <br><br>  When constructing numerical algorithms, we assume that the solution to this differential problem exists, it is unique and has the necessary smoothness properties. <br><br>  In the numerical solution of the Cauchy problem <br><br><img src="https://habrastorage.org/webt/z6/sc/ag/z6scagau6_z8yjjazels3cibdlc.png">  (2) <br><br><img src="https://habrastorage.org/webt/cf/hp/p4/cfhpp4rxk8vhqnexgl3bgsaapeg.png">  (3) <br><br>  According to the well-known solution at the point t = 0, it is necessary to find a solution from equation (3) for other t.  In the numerical solution of problem (2), (3), we will use a uniform, for simplicity, grid in the variable t with step m&gt; 0. <br><br>  Approximate solution of problem (2), (3) at point <img src="https://habrastorage.org/webt/j-/lc/cf/j-lccfwyp5vjoipcxlykp3dgbik.png">  denote <img src="https://habrastorage.org/webt/8s/g0/sj/8sg0sjhebyokeq5wuc7a8if2bqm.png">  .  The method converges at <img src="https://habrastorage.org/webt/b-/x8/0p/b-x80p4onflflxhl2lk1vadl3sg.png">  if a <img src="https://habrastorage.org/webt/ia/vi/8k/iavi8k482dcl150a2yxsd0gq-d0.png">  at <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  The method has the pth order of accuracy if <img src="https://habrastorage.org/webt/jv/xz/j1/jvxzj1hz0rgs3key_wcinzror84.png">  , p&gt; 0 when <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  The simplest difference scheme for the approximate solution of problem (2), (3) is <br><br><img src="https://habrastorage.org/webt/ao/-x/nx/ao-xnxhl01dfeg2znuupnwjqci8.png">  (four) <br><br>  With <img src="https://habrastorage.org/webt/wn/xq/qq/wnxqqqiwt6jm375mk9jf2v0c_zs.png">  we have an explicit method and in this case the difference scheme approximates equation (2) with the first order.  Symmetric scheme <img src="https://habrastorage.org/webt/-t/sm/4h/-tsm4hzq9-agctksj5eahivdimq.png">  in (4) has the second order of approximation.  This scheme belongs to the class of implicit ones ‚Äî to determine an approximate solution on a new layer, it is necessary to solve a nonlinear problem. <br><br>  Explicit schemes of the second and higher order approximations can be conveniently constructed based on the predictor-corrector method.  At the stage of predictor (prediction), an explicit scheme is used. <br><br><img src="https://habrastorage.org/webt/yw/lf/an/ywlfancnmqu4smvvqozydtuw6qw.png">  (five) <br><br>  and at the stage of the corrector (clarification) - the scheme <br><br><img src="https://habrastorage.org/webt/vk/kx/sg/vkkxsg0mkht41hmefqo3krhkohw.png"><br><br>  In the one-step Runge ‚Äì Kutta methods, the ideas of the predictor-corrector are implemented most fully.  This method is written in general: <br><br><img src="https://habrastorage.org/webt/ou/dj/vf/oudjvfblha8fbsfvflq3qucylb0.png">  (6), <br><br>  Where <br><br><img src="https://habrastorage.org/webt/of/gn/qh/ofgnqhxv2vlykcughxkzvvnzfm0.png"><br><br>  Formula (6) is based on s calculations of the function f and is called s-stage.  If a <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  at <img src="https://habrastorage.org/webt/ya/jx/d7/yajxd73qu-icfbj3_qte0sxoamk.png">  we have an explicit Runge ‚Äì Kutta method.  If a <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  with j&gt; 1 and <img src="https://habrastorage.org/webt/sp/y9/l3/spy9l3eri4ug3bf4ec31kcqgjca.png">  that <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  determined implicitly from the equation: <br><br><img src="https://habrastorage.org/webt/md/2l/xs/md2lxstmkruwswxkb4hwqk3ejrm.png">  (7) <br><br>  This Runge ‚Äì Kutta method is referred to as being diagonally implicit.  Options <img src="https://habrastorage.org/webt/yo/ud/im/youdimr4t898rol5a4naafrjbrk.png">  determine the variant of the Runge ‚Äì Kutta method.  The following method representation is used (Butcher table) <br><br><img src="https://habrastorage.org/webt/qc/es/cx/qcescxh_lpjsra_3jqxghis4hz0.png"><br><br>  One of the most common is the explicit fourth-order Runge ‚Äì Kutta method. <br><br><img src="https://habrastorage.org/webt/b_/xb/6b/b_xb6bte_wppykllazhykapnppu.png">  (eight) <br><br>  <b>Runge ‚Äì Kutta ‚Äì Felberg method</b> <br><br>  I give the value of the calculated coefficients <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  method <br><br><img src="https://habrastorage.org/webt/y6/v7/yk/y6v7yk2b6dabo8cfcz86kcbys2o.png">  (9) <br><br>  In view of (9), the general solution is: <br><br><img src="https://habrastorage.org/webt/8w/dk/av/8wdkavmydgbm1e94gfcjnm_kavm.png">  (ten) <br><br>  This solution provides the fifth order of accuracy, it remains to adapt it to Python. <br><br><h4>  Computational experiment to determine the absolute error of the numerical solution of a nonlinear differential equation <img src="https://habrastorage.org/webt/ws/sh/r4/wsshr4edsklounxpocg4hd_mf70.png">  using both the def odein (), def oden () functions of the scipy.integrate module and the Pyunge-adapted Runge ‚Äî Kutta and Runge ‚Äî Kutta ‚Äî Fellberg methods </h4><br><br><div class="spoiler">  <b class="spoiler_title">Program listing</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odein</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#dy1/dt=y2 #dy2/dt=y1**2+1: def f(y,t): return y**2+1 t =arange(0,1,0.01) y0 =0.0 y=odeint(f, y0,t) y = array(y).flatten() return y,t def oden(): f = lambda t, y: y**2+1 ODE=ode(f) ODE.set_integrator('dopri5') ODE.set_initial_value(0, 0) t=arange(0,1,0.01) z=[] t=arange(0,1,0.01) for i in arange(0,1,0.01): ODE.integrate(i) q=ODE.y z.append(q[0]) return z,t def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): if z==1: k0 =tau* f(t,y) k1 =tau* f(t+tau/2.,y+k0/2.) k2 =tau* f(t+tau/2.,y+k1/2.) k3 =tau* f(t+tau, y + k2) return (k0 + 2.*k1 + 2.*k2 + k3) / 6. elif z==0: k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): f = zeros([1]) f[0] = y[0]**2+1 return f to = 0. tEnd = 1 yo = array([0.]) tau = 0.01 z=1 t, yn = rungeKutta(f, to, yo, tEnd, tau) y1n=[i[0] for i in yn] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1n)-array(tan(t))),label=' ‚Äî \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) z=0 t, ym = rungeKutta(f, to, yo, tEnd, tau) y1m=[i[0] for i in ym] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1m)-array(tan(t))),label=' ‚Äî‚Äî  \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") y,t=odein() plt.plot(t,abs(array(tan(t))-array(y)),label=' odein') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") z,t=oden() plt.plot(t,abs(tan(t)-z),label=' ode  ‚Äî‚Äî  \n\  ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  We get: <br><br><img src="https://habrastorage.org/webt/rb/l6/-2/rbl6-2ookhhbihd9xnftqqknrc4.png"><br><br><img src="https://habrastorage.org/webt/od/pn/mp/odpnmp3qsgjttpzjikbu4ry34bk.png"><br><br><img src="https://habrastorage.org/webt/nt/vw/dv/ntvwdvd0hnwbgnfdgoox71in9pk.png"><br><br><img src="https://habrastorage.org/webt/-a/gl/os/-agloshtg1bvovezwdjex4ri2ac.png"><br><br>  <b>Conclusion:</b> <br><br>  Python-adapted Runge ‚Äî Kutta and Runge ‚Äî Kutta ‚Äî Feelberg methods have a smaller absolute solution than using the odeint function, but more than using the edu function.  It is necessary to conduct a performance study. <br><br><h4>  A numerical experiment comparing the speed of a CDS numerical solution using the ode function with the dopri5 attribute (Runge ‚Äì Kutta method of the 5th order) and using the Runge ‚Äî Kutta ‚Äì Felberg method adapted to Python </h4><br><br>  Comparative analysis will be conducted on the example of the model problem given in [2].  In order not to repeat the source, I will give the formulation and solution of the model problem from [2]. <br><br>  We solve the Cauchy problem, which describes the motion of a body thrown with an initial velocity v0 at an angle Œ± to the horizon under the assumption that air resistance is proportional to the square of the velocity.  In the vector form, the equation of motion is <br><br><img src="https://habrastorage.org/webt/2a/9w/f5/2a9wf5a2_ckuhlu2mypbya1euow.png"><br><br>  Where <img src="https://habrastorage.org/webt/zi/gy/z5/zigyz50cgbqvfeos6rozby0xais.png">  - the radius of the vector of the moving body, <img src="https://habrastorage.org/webt/v_/7w/rm/v_7wrmvexfdj_3j7kfyobvy0omi.png">  - the velocity vector of the body, <img src="https://habrastorage.org/webt/_-/jq/rq/_-jqrqt-dvbznpe_4l8htdsfybw.png">  - resistance coefficient, vector <img src="https://habrastorage.org/webt/px/au/zt/pxauztg_p8ldqkk3vuuzxgkzzhe.png">  force of body weight of mass m, g - acceleration of free fall. <br><br><img src="https://habrastorage.org/webt/ux/fy/xy/uxfyxyowu7xnhy-fvigwoeh436m.png"><br><br>  The peculiarity of this task is that the movement ends at an unknown moment of time when the body falls to the ground.  If to designate <img src="https://habrastorage.org/webt/ud/6h/hh/ud6hhhzd7lyf71noe8hpdlyrexi.png">  then in the coordinate form we have the system of equations: <br><br><img src="https://habrastorage.org/webt/jh/dd/rr/jhddrrguuy07d9hw9x5gvcylo2u.png"><br><br>  Initial conditions should be added to the system: <img src="https://habrastorage.org/webt/tr/de/l-/trdel-vxwgw3oy1ryv0k1nafch0.png">  (h initial height), <img src="https://habrastorage.org/webt/-g/zd/ft/-gzdft1d38m6x4f6vryof4jlwuu.png">  .  Set <img src="https://habrastorage.org/webt/l0/1r/cm/l01rcm17euagfjzj8gcet4xfhge.png">  .  Then the corresponding first order ODE system will take the form: <br><br><img src="https://habrastorage.org/webt/nh/zg/r5/nhzgr5att8_fao3l-majsjgcm7k.png"><br><br>  For the model problem we set <img src="https://habrastorage.org/webt/2s/20/ov/2s20ovmvcahufaxyhihjev7rm8g.png">  .  Omitting a rather extensive description of the program, I will give only a listing from the comments to which, I think, the principle of its operation will be clear.  The program added countdown time for comparative analysis. <br><br><div class="spoiler">  <b class="spoiler_title">Program listing</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ode ts = [ ] ys = [ ] FlightTime, Distance, Height =<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> y4old=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, y)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#   global FlightTime, Distance, Height,y4old ts.append(t) ys.append(list(y.copy())) y1, y2, y3, y4 = y if y4*y4old&lt;=0: #    Height=y3 if y4&lt;0 and y3&lt;=0.0: #    FlightTime=t Distance=y1 return -1 y4old=y4 #      def f(t, y, k): #    k g=9.81 y1, y2, y3, y4 = y return [y2,-k*y2*np.sqrt(y2**2+y4**2), y4,-k*y4*np.sqrt(y2**2+y4**2)-g] tmax=1.41 #     alph=np.pi/4 #    v0=10.0 #   K=[0.1,0.2,0.3,0.5] #    y0,t0=[0, v0*np.cos(alph), 0, v0*np.sin(alph)], 0 #   ODE=ode(f) ODE.set_integrator('dopri5', max_step=0.01) ODE.set_solout(fout) fig, ax = plt.subplots() fig.set_facecolor('white') for k in K: #     ts, ys = [ ],[ ] ODE.set_initial_value(y0, t0) #    ODE.set_f_params(k) #    k #   f(t,y,k)     ODE.integrate(tmax) #   print('Flight time = %.4f Distance = %.4f Height =%.4f '% (FlightTime,Distance,Height)) Y=np.array(ys) plt.plot(Y[:,0],Y[:,2],linewidth=3,label='k=%.1f'% k) stop = time.time() plt.title("      \n    ode   dopri5 ") print ("   : %f"%(stop-start)) plt.grid(True) plt.xlim(0,8) plt.ylim(-0.1,2) plt.legend(loc='best') plt.show()</span></span></code> </pre> <br></div></div><br><br>  We get: <br><br>  Flight time = 1.2316 Distance = 5.9829 Height = 1.8542 <br>  Flight time = 1.1016 Distance = 4.3830 Height = 1.5088 <br>  Flight time = 1.0197 Distance = 3.5265 Height = 1.2912 <br>  Flight time = 0.9068 Distance = 2.5842 Height = 1.0240 <br>  Time to model problem: 0.454787 <br><br><img src="https://habrastorage.org/webt/z5/u5/xc/z5u5xc04tbd-_2idovqqosevlwi.png"><br><br>  To implement the Python tools using the numerical solution of the CDS without using special modules, I have proposed and investigated the following function: <br><br> <code>def increment(f, t, y, tau <br> k1=tau*f(t,y) <br> k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) <br> k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) <br> k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) <br> k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) <br> k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) <br> return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6</code> <br> <br>  The increment function (f, t, y, tau) provides the fifth order of the numerical solution method.  The remaining features of the program can be found in the following listing: <br><br><div class="spoiler">  <b class="spoiler_title">Program listing</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rungeKutta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, to, yo, tEnd, tau)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, t, y, tau)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#     ‚Äî‚Äî. k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = []#   t y= []#   y t.append(to)#   t   to y.append(yo)#   y   yo while to &lt; tEnd:#     t,y tau = min(tau, tEnd - to)#   tau yo = yo + increment(f, to, yo, tau) #     t0,y0    to = to + tau #   t.append(to) #   t y.append(yo) #   y return array(t), array(y) def f(t, y): #      f = zeros([4]) f[0]=y[1] f[1]=-k*y[1]*sqrt(y[1]**2+y[3]**2) f[2]=y[3] f[3]=-k*y[3]*sqrt(y[1]**2+y[3]**2) -g if y[3]&lt;0 and y[2]&lt;=0.0: #    return -1 return f to = 0#     tEnd = 1.41#     alph=pi/4#    v0=10.0 #   K=[0.1,0.2,0.3,0.5]#     g=9.81 yo = array([0.,v0*cos(alph),0.,v0*sin(alph)]) #   tau =0.01#  for i in K: #      k=i t, y = rungeKutta(f, to, yo, tEnd, tau) y1=array([i[0] for i in y]) #     y y3=array([i[2] for i in y]) #    ""     s,h,t plt.plot(y1,y3,linewidth=2,label='k=%.1f h=%.3f s=%.2f t=%s' % (k,max(y3),max(y1),round(t[list(y1).index(max(y1))],3))) stop = time.time() plt.title("      \n     Python\n  ‚Äî‚Äî ") print ("   : %f"%(stop-start)) plt.xlabel(' h') plt.ylabel(' s') plt.legend(loc='best') plt.xlim(0,8) plt.ylim(-0.1,2) plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  We get: <br><br>  Time to model problem: 0.259927 <br><br><img src="https://habrastorage.org/webt/_i/c1/ta/_ic1ta5623kjqb1qazfpt3ut1ns.png"><br><br>  <b>Conclusion</b> <br><br>  The proposed software implementation of the model problem without the use of special modules is almost twice as fast as with the ode function, but we must not forget that ode has a higher accuracy of the numerical solution and the possibility of choosing a solution method. <br><br><h3>  Solution of a boundary value problem with continuously separated boundary conditions </h3><br>  Let us give an example of some concrete boundary value problem with streamlined separated boundary conditions: <br><br><img src="https://habrastorage.org/webt/i4/x0/jt/i4x0jtfxfy57053vvu31tpyyvo4.png">  (eleven) <br><br>  To solve problem (11), we use the following algorithm: <br><br>  1. Solve the first three inhomogeneous equations of system (11) with initial conditions <br><img src="https://habrastorage.org/webt/0w/b-/qj/0wb-qjfvaodszu5xyov9mqgddmi.png"><br>  We introduce the notation for solving the Cauchy problem: <br><img src="https://habrastorage.org/webt/h1/am/zo/h1amzogvuzkyz3a6wpp95gd9rua.png"><br><br>  2. Solve the first three homogeneous equations of system (11) with initial conditions <br><img src="https://habrastorage.org/webt/ia/d6/yn/iad6ynerbilksk3kcjwudksg4ta.png"><br>  We introduce the notation for solving the Cauchy problem: <br><img src="https://habrastorage.org/webt/3t/ib/ze/3tibzeyvnv-bsodoaivbfnycscc.png"><br><br>  3. Solve the first three homogeneous equations of system (11) with initial conditions <br><br><img src="https://habrastorage.org/webt/rl/vd/pc/rlvdpcnayrhhfasr9s4jpjpffja.png"><br><br>  We introduce the notation for solving the Cauchy problem: <br><br><img src="https://habrastorage.org/webt/pq/dl/os/pqdlosn5xi7yxhoeg0yafuybtdy.png"><br><br>  4. The general solution of the boundary value problem (11) with the help of solutions of Cauchy problems is written in the form of a linear combination of solutions: <br><img src="https://habrastorage.org/webt/8n/_t/17/8n_t1751ck0jmg6oiv3cgaluskm.png"><br>  where p2, p3 are some unknown parameters. <br><br>  5. To determine the parameters p2 and p3, we use the boundary conditions of the last two equations (11), that is, the conditions for x = b.  Substituting, we obtain a system of linear equations for the unknowns p2, p3: <br><img src="https://habrastorage.org/webt/0_/xe/_p/0_xe_pgiynf0ufquqah-k7llh18.png">  (12) <br>  Solving (12), we obtain the relations for p2, p3. <br><br>  Using the above algorithm, using the Runge ‚Äì Kutt ‚Äì Felberg method, we obtain the following program: <br><br><div class="spoiler">  <b class="spoiler_title">Program listing</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   from numpy import* import matplotlib.pyplot as plt import matplotlib.font_manager as fm,os import matplotlib.patches as mpatches import matplotlib.lines as mlines from scipy.integrate import odeint from scipy import linalg import time start = time.time() c1 = 1.0 c2 = 0.8 c3 = 0.5 a =0.0 b = 1.0 nn =100 initial_state_0 =array( [a, c1, 0.0, 0.0]) initial_state_I =array( [a, 0.0, 1.0, 0.0]) initial_state_II =array( [a, 0.0, 0.0, 1.0]) to = a tEnd =b N = int(nn) tau=(ba)/N def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): global theta f = zeros([4]) f[0] = 1 f[1] = -y [1]-y[2] +theta* sin(y[0]) f[2] = -y[2]+y[3] f[3] = -y[2] return f #    -- theta = 1 theta = 1.0 yo =initial_state_0 t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y20 = Y2(b), Y30 = Y3(b) Y20 = y2[N-1] Y30 = y3[N-1] #    -- theta = 0,  I theta = 0.0 yo= initial_state_I t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y21= Y2(b), Y31 = Y3(b) Y21= y2[N-1] Y31 = y3[N-1] #    -- theta = 0,  II theta = 0.0 yo =initial_state_II t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y211= Y2(b), Y311 = Y3(b) Y211= y2[N-1] Y311 = y3[N-1] #    #     p2, p3 b1 = c2 - Y20 b2 = c3 - Y30 A = array([[Y21, Y211], [Y31, Y311]]) bb = array([[b1], [b2]]) #   p2, p3 = linalg.solve(A, bb) #    #  , theta = 1 theta = 1.0 yo = array([a, c1, p2, p3]) t, y = rungeKutta(f, to, yo, tEnd, tau) y0=[i[0] for i in y] y1=[i[1] for i in y] y2=[i[2] for i in y] y3=[i[3] for i in y] #  print('y0[0]=', y0[0]) print('y1[0]=', y1[0]) print('y2[0]=', y2[0]) print('y3[0]=', y3[0]) print('y0[N-1]=', y0[N-1]) print('y1[N-1]=', y1[N-1]) print('y2[N-1]=', y2[N-1]) print('y3[N-1]=', y3[N-1]) j = N xx = y0[:j] yy1 = y1[:j] yy2 = y2[:j] yy3 = y3[:j] stop = time.time() print ("   : %f"%(stop-start)) plt.subplot(2, 1, 1) plt.plot([a], [c1], 'ro') plt.plot([b], [c2], 'go') plt.plot([b], [c3], 'bo') plt.plot(xx, yy1, color='r') #  plt.plot(xx, yy2, color='g') #  plt.plot(xx, yy3, color='b') #  plt.xlabel(r'$x$') #   x   TeX plt.ylabel(r'$y_k(x)$') #   y   TeX plt.title(r'  ', color='blue') plt.grid(True) # patch_y1 = mpatches.Patch(color='red', label='$y_1$') patch_y2 = mpatches.Patch(color='green', label='$y_2$') patch_y3 = mpatches.Patch(color='blue', label='$y_3$') plt.legend(handles=[patch_y1, patch_y2, patch_y3]) ymin, ymax = plt.ylim() xmin, xmax = plt.xlim() plt.subplot(2, 1, 2) font = {'family': 'serif', 'color': 'blue', 'weight': 'normal', 'size': 12, } plt.text(0.2, 0.8, r'$\frac{dy_1}{dx}= - y_1 - y_2 + \sin(x),$', fontdict=font) plt.text(0.2, 0.6,r'$\frac{dy_2}{dx}= - y_1 + y_3,$', fontdict=font) plt.text(0.2, 0.4, r'$\frac{dy_3}{dx}= - y_2 - y_2,$', fontdict=font) plt.text(0.2, 0.2, r'$y_1(a)=c_1, ' r'\quad y_2(b)=c_2, \quad y_3(b)=c_3.$', fontdict=font) plt.subplots_adjust(left=0.15) plt.show()</span></span></code> </pre><br></div></div><br>  We get: <br><br>  y0 [0] = 0.0 <br>  y1 [0] = 1.0 <br>  y2 [0] = 0.7156448588231397 <br>  y3 [0] = 1.324566562303714 <br>  y0 [N-1] = 0.9900000000000007 <br>  y1 [N-1] = 0.1747719838716767 <br>  y2 [N-1] = 0.8 <br>  y3 [N-1] = 0.50000000000001 <br>  Time to model problem: 0.070878 <br><br><img src="https://habrastorage.org/webt/kj/g1/0c/kjg10co-rqc-pwbedzo56s4b3wy.png"><br><br><h3>  Conclusion </h3><br><br>  The program I developed differs from the smaller error given in [3], which confirms the comparative analysis of the odeint function given at the beginning of the article with the Runge ‚Äì Kutt ‚Äì Feelberg method implemented in Python. <br><br>  References: <br><br>  1. <a href="http://www.science-education.ru/ru/article/view%3Fid%3D5196">Numerical solution of mathematical models of objects defined by composite systems of differential equations.</a> <br><br>  2. <a href="http://geometry.karazin.ua/resources/documents/20161211134615_988a1d6a.pdf">Introduction to Scientific Python.</a> <br><br>  3. N.M.  Polyakova, E.V.  Shiryaeva Python 3. Creating a graphical user interface (by the example of solving the boundary-value problem for linear ordinary differential equations using the method of adjustment).  Rostov-on-Don 2017. </div><p>Source: <a href="https://habr.com/ru/post/418139/">https://habr.com/ru/post/418139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418127/index.html">True and False Face Recognition Systems</a></li>
<li><a href="../418131/index.html">Cross-Cloud Programming with Go Cloud</a></li>
<li><a href="../418133/index.html">In defense of OOP. 7 untenable arguments of his opponents</a></li>
<li><a href="../418135/index.html">How to organize your own repository of Node.js modules with blackjack and versioning</a></li>
<li><a href="../418137/index.html">Bloodlust: an interview with the founder of DonorSearch</a></li>
<li><a href="../418141/index.html">RE: Gata / AFR Beginner Skipper Race</a></li>
<li><a href="../418143/index.html">PVS-Studio as SAST solution</a></li>
<li><a href="../418145/index.html">The first lawsuit against Roskomnadzor from the company that suffered while blocking Telegram</a></li>
<li><a href="../418147/index.html">Silent Ruby Exposures: Transactional Rails / PostgreSQL Thriller</a></li>
<li><a href="../418149/index.html">Phishing with the title tag</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>