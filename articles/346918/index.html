<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OAuth authentication in the Flask application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a bonus to the new cycle of articles Flask Mega-Tutorial (2018) . 
 The author is the same Miguel Greenberg. The article is not new, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OAuth authentication in the Flask application</h1><div class="post__text post__text-html js-mediator-article"><p>  This article is a bonus to the new cycle of articles <a href="https://habrahabr.ru/post/346346/">Flask Mega-Tutorial (2018)</a> . <br>  The author is the same Miguel Greenberg.  The article is not new, but has not lost its relevance. </p><br><p>  <a href="http://blog.miguelgrinberg.com/" title="blog.miguelgrinberg.com">blog.miguelgrinberg.com</a> </p><br><p>  OAuth technologies are more than 10 years old, and 99% of Internet users have an account with at least one of the OAuth-enabled resources.  Is the "Login through" button on almost every resource?  We will understand how this is done using the Flask microform. <br></p><br><img src="https://habrastorage.org/webt/kr/s9/vf/krs9vfybluzgbsolq4vy091xgf0.png"><br><a name="habracut"></a><br><p>  Many websites provide users with the option of simplified registration in "one click" using a third-party authentication service, using a user account, in any of the known social services.  In my old <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-v-user-logins-legacy">Flask Mega-Tutorial</a> course, I showed you how to use one of these protocols, called <em>OpenID</em> (which has now rested with the world of the <em>translator</em> ). <br></p><br><img src="https://habrastorage.org/webt/yf/rp/02/yfrp028vv-mcsmzwftlqz0cvjje.png"><br><br>  In this article, I want to give you an introduction to <a href="http://oauth.net/">OAuth</a> , which has replaced <em>OpenID</em> as the preferred third-party authentication mechanism these days.  I will also show you the complete <em>Flask</em> app, which implements the <em>Sign In with Facebook</em> and <em>Sign In with Twitter</em> functions.  With these two implementations as an example, it will be easy for you to add any other <em>OAuth</em> providers you may need. <br><blockquote>  <em>Note</em>  <em>of the translator:</em> A couple more links about how OAuth works <a href="https://habrahabr.ru/post/145988/">here</a> , <a href="https://habrahabr.ru/company/mailru/blog/115163/">here</a> </blockquote><br><h2 id="kratkoe-vvedenie-v-oauth">  Brief introduction to OAuth </h2><br><p>  The best way to present <em>OAuth</em> is to list the events that occur during login: </p><br><ul><li>  <strong>Processing form submission.</strong>  The user goes to the home page of the application, for example <em><a href="http://www.example.com/">http://www.example.com</a></em> , and clicks the <em>"Sign In with Facebook"</em> button that refers to the route of the application, for example <em><a href="http://www.example.com/authorize/facebook">http://www.example.com/authorize/facebook</a></em> . </li><li>  <strong>Fetch Request Token (internal request).</strong>  The server receives the request and responds with a redirect to the <em>OAuth Facebook</em> authorization URL.  All OAuth providers must document the URL to redirect the user. <br><ul><li>  The request sends the <em>Consumer key</em> , the ‚Äúapplication login,‚Äù and the request itself is signed using the <em>Consumer secret</em> , the ‚Äúapplication password,‚Äù which protects it from counterfeit. </li><li>  In response, the Provider generates and returns a token-filled token called Request Token. </li></ul></li><li>  <strong>Redirect to Authorization (via redirect in the browser).</strong>  Now the user is prompted to log in to Facebook (if not already logged in).  A request for information sharing is then provided when the user needs to grant Facebook permission to share the requested information with the source application.  Everything is done on the Facebook website and is a private transaction between Facebook and the user, the application is not involved. </li><li>  <strong>Fetch Access Token (internal request).</strong>  After the user accepts the request to share information, Facebook redirects back to the application to the pre-configured callback URL, for example <em><a href="http://www.example.com/callback/facebook">http://www.example.com/callback/facebook</a></em> .  The redirect URL request string includes an authorization code that the application can use to access the Facebook API on behalf of the user. </li><li>  <strong>Call API (internal request).</strong>  The application uses the Facebook API to retrieve user information.  Of particular interest is the unique user ID ( <em>Shared Secret</em> ), which can be used to register a user in the application database after a user has registered for logging into the system. </li></ul><br><p>  The exchange between the application and the third-party service is not trivial, but for the user it is extremely simple, since all that the user needs is to enter a third party site and give permission to exchange information using the application. </p><br><p>  Currently, two versions of the OAuth protocol are used, both in accordance with the general process described above, and with some differences in implementation.  Twitter's <em>OAuth 1.0a</em> is the most difficult of the two.  <em>OAuth 2</em> , used by Facebook, is an incompatible revised version of the protocol that eliminates much of the complexity of version 1.0a, relying on secure HTTP for encryption. </p><br><h2 id="registraciya-u-provayderov-oauth">  Registration with OAuth providers </h2><br><p>  Before an application can use a third-party OAuth provider, it must be registered.  For Facebook and Twitter, this is done on their respective developer sites with the creation of an ‚Äúapp‚Äù that represents the app for users of these sites. </p><br><p>  Create an app for Facebook here. <a href="https://developer.facebook.com/"></a>  <a href="https://developer.facebook.com/">https://developer.facebook.com</a> . </p><br><p>  Click "START" and NEXT.  Along the way, fill in various information about yourself. <br></p><br><img src="https://habrastorage.org/webt/vd/kk/ry/vdkkrytlp3lu11zodu7buxs9y3q.png"><br><br><img src="https://habrastorage.org/webt/q5/or/ed/q5oredyovzvbdl5ogjotzavjxy0.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Choose "Sign in with Facebook" <br><br><img src="https://habrastorage.org/webt/6z/ku/tg/6zkutgt_jszixhm6cu33s91jki8.png"><br><br>  From the list of possible applications, select the type "WWW / Website". <br><br><img src="https://habrastorage.org/webt/w6/-k/8n/w6-k8nnqtpdqte-xs9jp835e8fu.png"><br><br>  Specify the URL of the application, which, if it is launched on your computer, will be <code>http://localhost:5000</code> . <br><br><img src="https://habrastorage.org/webt/el/5i/ai/el5iainvbxe1bs6-fhqqer4u_gm.png"><br><br><h2 id="primer-autentifikacii-oauth">  OAuth Authentication Example </h2><br><p>  In the following sections, I am going to describe a relatively simple Flask application that implements Facebook and Twitter authentication. </p><br><p>  I'll show you the important parts of the application in the article, but the full application is available in this <strong>GitHub</strong> repository: <a href="https://github.com/miguelgrinberg/flask-oauth-example"></a>  <a href="https://github.com/miguelgrinberg/flask-oauth-example">https://github.com/miguelgrinberg/flask-oauth-example</a> .  At the end of this article, I will show you instructions for launching it. </p><br><h2 id="user-model">  User Model </h2><br><p>  Users in the sample application are stored in a SQLAlchemy database.  The application uses the <a href="https://pythonhosted.org/Flask-SQLAlchemy/">Flask-SQLAlchemy</a> extension to work with the database and the <a href="https://flask-login.readthedocs.org/en/latest/">Flask-Login</a> extension to track registered users. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.sqlalchemy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SQLAlchemy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.<span class="hljs-keyword"><span class="hljs-keyword">login</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LoginManager, UserMixin db = SQLAlchemy(app) lm = LoginManager(app) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(UserMixin, db.Model): __tablename__ = <span class="hljs-string"><span class="hljs-string">'users'</span></span> id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.Integer, primary_key=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) social_id = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), nullable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) nickname = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), nullable=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) email = db.<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), nullable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) @lm.user_loader def load_user(id): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.query.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span>(id))</code> </pre> <br><p>  The database has a separate table for users <em>users</em> , which in addition to <code>id</code> , which is the main key, contains three columns: </p><br><ul><li><p>  <code>social_id</code> : a string that identifies a unique identifier from a third-party authentication service used to log in to the system. </p><br></li><li><p>  <code>nickname</code> : alias for user.  Must be defined for all users and does not have to be unique. </p><br></li><li>  <code>email</code> : the user's email address.  This column is optional. </li></ul><br><p>  The User class is inherited from <code>UserMixin</code> from Flask-Login, which gives it the methods required by this extension.  The <code>user_loader</code> callback function, also <code>user_loader</code> Flask-Login, loads the user by its primary key. </p><br><h2 id="realizaciya-oauth">  OAuth implementation </h2><br><p>  For Python, there are several OAuth client packages.  In this example, I decided to use <a href="https://rauth.readthedocs.io/en/latest/">Rauth</a> .  However, even when using the OAuth package, there are many aspects of authentication by providers, which makes the task more difficult. </p><br><p>  First of all, there are two versions of the OAuth protocol that are widely used.  But even among providers that use the same version of OAuth, there are many details that are not part of the specification and must be performed according to their own documentation. </p><br><p>  For this reason, I decided to implement an abstraction layer on top of Rauth, so the Flask application can be written in general form.  Below is a simple base class in which specific provider implementations will be written: </p><br><pre> <code class="hljs python"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuthSignIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> providers = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, provider_name)</span></span></span><span class="hljs-function">:</span></span> self.provider_name = provider_name credentials = current_app.config[<span class="hljs-string"><span class="hljs-string">'OAUTH_CREDENTIALS'</span></span>][provider_name] self.consumer_id = credentials[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] self.consumer_secret = credentials[<span class="hljs-string"><span class="hljs-string">'secret'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_callback_url</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url_for(<span class="hljs-string"><span class="hljs-string">'oauth_callback'</span></span>, provider=self.provider_name, _external=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_provider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, provider_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.providers <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: self.providers = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> provider_class <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__subclasses__(): provider = provider_class() self.providers[provider.provider_name] = provider <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.providers[provider_name] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FacebookSignIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OAuthSignIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwitterSignIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OAuthSignIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><p>  The base class <code>OAuthSignIn</code> defines the structure that should be followed by subclasses that implement the services of each provider.  The constructor initializes the name of the provider, as well as the application identifier and secret code assigned to them, and obtained from the configuration.  Below is an example of the application configuration (of course, you will need to replace these codes with your own): </p><br><pre> <code class="hljs lua">app.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>[<span class="hljs-string"><span class="hljs-string">'OAUTH_CREDENTIALS'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'facebook'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: <span class="hljs-string"><span class="hljs-string">'470154729788964'</span></span>, <span class="hljs-string"><span class="hljs-string">'secret'</span></span>: <span class="hljs-string"><span class="hljs-string">'010cc08bd4f51e34f3f3e684fbdea8a7'</span></span> }, <span class="hljs-string"><span class="hljs-string">'twitter'</span></span>: { <span class="hljs-string"><span class="hljs-string">'id'</span></span>: <span class="hljs-string"><span class="hljs-string">'3RzWQclolxWZIMq5LJqzRZPTl'</span></span>, <span class="hljs-string"><span class="hljs-string">'secret'</span></span>: <span class="hljs-string"><span class="hljs-string">'m9TEd58DSEtRrZHpz2EjrV9AhsBRxKMo8m3kuIZj3zLwzwIimt'</span></span> } }</code> </pre> <br><p>  At the top level, there are two important events supported by this class that are common to all OAuth providers: </p><br><ul><li>  Initiating the authentication process.  To do this, the application must redirect to the provider's website to allow the user to authenticate there.  This is represented by the <code>authorize()</code> method. </li><li>  Once authentication is complete, the provider forwards the application back.  This is handled by the <code>callback()</code> method.  Since the provider does not have direct access to the internal methods of the application, it will be redirected to the URL that will call it.  The URL that the provider must redirect is returned by the <code>get_callback_url()</code> method and is created using the provider name, so that each provider`` gets its own dedicated route. </li></ul><br><p>  The <code>get_provider()</code> method is used to find the correct <code>OAuthSignIn</code> instance with the name of the provider.  This method uses introspection to search for all <code>OAuthSignIn</code> subclasses, and then saves an instance of each in the dictionary. </p><br><h2 id="autentifikaciya-oauth-s-pomoschyu-rauth">  OAuth Authentication with Rauth </h2><br><p>  Rauth represents OAuth providers with an object of class <code>OAuth1Service</code> or <code>OAuth2Service</code> , depending on the version of the protocol used.  I create an object of this class in a subclass of <code>OAuthSignIn</code> each provider.  Implementations for Facebook and Twitter are shown below: </p><br><pre> <code class="hljs smalltalk">class <span class="hljs-type"><span class="hljs-type">FacebookSignIn</span></span>(<span class="hljs-type"><span class="hljs-type">OAuthSignIn</span></span>): def __init__(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-type"><span class="hljs-type">FacebookSignIn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>).__init__(<span class="hljs-string"><span class="hljs-string">'facebook'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service = <span class="hljs-type"><span class="hljs-type">OAuth2Service</span></span>( name=<span class="hljs-string"><span class="hljs-string">'facebook'</span></span>, client_id=<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.consumer_id, client_secret=<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.consumer_secret, authorize_url=<span class="hljs-string"><span class="hljs-string">'https://graph.facebook.com/oauth/authorize'</span></span>, access_token_url=<span class="hljs-string"><span class="hljs-string">'https://graph.facebook.com/oauth/access_token'</span></span>, base_url=<span class="hljs-string"><span class="hljs-string">'https://graph.facebook.com/'</span></span> ) class <span class="hljs-type"><span class="hljs-type">TwitterSignIn</span></span>(<span class="hljs-type"><span class="hljs-type">OAuthSignIn</span></span>): def __init__(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-type"><span class="hljs-type">TwitterSignIn</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>).__init__(<span class="hljs-string"><span class="hljs-string">'twitter'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service = <span class="hljs-type"><span class="hljs-type">OAuth1Service</span></span>( name=<span class="hljs-string"><span class="hljs-string">'twitter'</span></span>, consumer_key=<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.consumer_id, consumer_secret=<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.consumer_secret, request_token_url=<span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/oauth/request_token'</span></span>, authorize_url=<span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/oauth/authorize'</span></span>, access_token_url=<span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/oauth/access_token'</span></span>, base_url=<span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1.1/'</span></span> )</code> </pre> <br><p>  For Facebook, which implements OAuth 2, the <code>OAuth2Service</code> class is <code>OAuth2Service</code> .  The service object is initialized by the service name and several arguments specific to OAuth.  Arguments <code>client_id</code> and <code>client_secret</code> are those that are assigned to the application on the Facebook developer site.  <code>Authorize_url</code> and <code>access_token_url</code> are URLs defined by Facebook for applications to which you need to connect during the authentication process.  Finally, <code>base_url</code> sets the prefix URL for any Facebook API calls after authentication is complete. </p><br><p>  Twitter implements OAuth 1.0a, so the <code>OAuth1Service</code> class is <code>OAuth1Service</code> .  In OAuth 1.0a, the identification and secret codes are called <code>consumer_key</code> and <code>consumer_secret</code> , but are otherwise identical in functionality to OAuth 2 analogues. OAuth 1 protocol requires providers to display three URLs instead of two, there is an additional request <code>request_token_url</code> .  The <code>name</code> and <code>base_url</code> arguments are identical to those used in OAuth 2 services. It should be noted that Twitter offers two parameters for the parameter <code>authorize_url</code> .  The URL shown above, <code>https://api.twitter.com/oauth/authorize</code> , is the safest, as it presents the user with a window in which he needs to allow the application to access Twitter every time.  Changing this URL to <code>https://api.twitter.com/oauth/authenticate</code> will cause Twitter to request permission only for the first time, and then silently allow access until the user logs out of Twitter. </p><br><p>  Note that there is no standardization for URL entry points, OAuth providers define them as they see fit.  To add a new OAuth provider, you will need to get these URLs from its documentation. </p><br><h2 id="faza-avtorizacii-oauth">  OAuth authorization phase </h2><br><p>  When a user clicks the ‚ÄúLogin with ...‚Äù link to initiate OAuth authentication, the call follows this route: </p><br><pre> <code class="hljs ruby">@app.route(<span class="hljs-string"><span class="hljs-string">'/authorize/&lt;provider&gt;'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oauth_authorize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(provider)</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> current_user.is_anonymous(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(url_for(<span class="hljs-string"><span class="hljs-string">'index'</span></span>)) oauth = OAuthSignIn.get_provider(provider) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> oauth.authorize()</code> </pre> <br><p>  This route first ensures that the user is not logged in, and then simply receives the <code>OAuthSignIn</code> subclass corresponding to the given provider, and calls its <code>authorize()</code> method to initiate the process.  The following is the <code>authorize()</code> implementation for Facebook and Twitter: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FacebookSignIn</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">OAuthSignIn</span></span></span></span></span><span class="hljs-class">)</span></span>: # ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorize</span></span></span></span>(self): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(self.service.get_authorize_url( scope=<span class="hljs-symbol"><span class="hljs-symbol">'emai</span></span>l', response_type=<span class="hljs-symbol"><span class="hljs-symbol">'cod</span></span>e', redirect_uri=self.get_callback_url()) ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwitterSignIn</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">OAuthSignIn</span></span></span></span></span><span class="hljs-class">)</span></span>: # ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorize</span></span></span></span>(self): request_token = self.service.get_request_token( params={<span class="hljs-symbol"><span class="hljs-symbol">'oauth_callbac</span></span>k': self.get_callback_url()} ) session[<span class="hljs-symbol"><span class="hljs-symbol">'request_toke</span></span>n'] = request_token <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(self.service.get_authorize_url(request_token[<span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre> <br><p>  For OAuth 2 providers, such as Facebook, the implementation simply redirects to the URL created by the <code>rauth</code> service <code>rauth</code> .  The scope depends on the Supplier, in this particular case, I ask Facebook to provide the user's email.  In response_type = 'code', the argument tells the oauth provider that the application is a web application (there are other possible values ‚Äã‚Äãfor different authentication processes).  Finally, the redirect_uri argument designates the route for the application, which the provider must call after authentication is completed. </p><br><p>  OAuth 1.0 a providers use a slightly more complex process that involves receiving a request token from a provider, which is a list of two elements, the first of which is then used as an argument in the redirection.  The entire request token is stored in the user session, as it will be needed again in the callback. </p><br><h2 id="faza-obratnogo-vyzova-callback-oauth">  Callback OAuth Callback Phase </h2><br><p>  The OAuth provider redirects back to the application after authenticating the user and grants permission to exchange information.  The route that handles this callback is shown below: </p><br><pre> <code class="hljs pgsql">@app.route(<span class="hljs-string"><span class="hljs-string">'/callback/&lt;provider&gt;'</span></span>) def oauth_callback(provider): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span>.is_anonymous(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(url_for(<span class="hljs-string"><span class="hljs-string">'index'</span></span>)) oauth = OAuthSignIn.get_provider(provider) social_id, username, email = oauth.callback() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> social_id <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: flash(<span class="hljs-string"><span class="hljs-string">'Authentication failed.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(url_for(<span class="hljs-string"><span class="hljs-string">'index'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.query.filter_by(social_id=social_id).first() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(social_id=social_id, nickname=username, email=email) db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() login_user(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> redirect(url_for(<span class="hljs-string"><span class="hljs-string">'index'</span></span>))</code> </pre> <br><p>  This route creates an instance of the <code>OAuthSignIn</code> provider <code>OAuthSignIn</code> and calls its <code>callback()</code> method.  This method has the function of completing authentication with the provider and receiving information about the user.  The return value is a three-value tuple, a unique identifier (called <code>social_id</code> to distinguish it from the <code>id</code> primary key), a username and a user email address.  The ID and alias are required, but in this sample application I made the email optional, because Twitter never shares this information with the applications. </p><br><p>  The user is viewed in the database by the <code>social_id</code> field, and if not found, the new user is added to the database with information received from the provider, effectively registering new users automatically.  The user is then registered using the <code>login_user()</code> function in Flask-Login and, finally, redirected to the home page. </p><br><p>  The implementation of the <code>callback()</code> method for OAuth providers for Facebook and Twitter is shown below: </p><br><pre> <code class="hljs rust">class FacebookSignIn(OAuthSignIn): # ... def callback(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>): def decode_json(payload): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.loads(payload.decode(<span class="hljs-symbol"><span class="hljs-symbol">'utf</span></span>-<span class="hljs-number"><span class="hljs-number">8</span></span>')) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'code</span></span>' not <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.args: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">None</span></span> oauth_session = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service.get_auth_session( data={<span class="hljs-symbol"><span class="hljs-symbol">'code</span></span>': request.args[<span class="hljs-symbol"><span class="hljs-symbol">'code</span></span>'], <span class="hljs-symbol"><span class="hljs-symbol">'grant_type</span></span>': <span class="hljs-symbol"><span class="hljs-symbol">'authorization_code</span></span>', <span class="hljs-symbol"><span class="hljs-symbol">'redirect_uri</span></span>': <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_callback_url()}, decoder=decode_json ) me = oauth_session.get(<span class="hljs-symbol"><span class="hljs-symbol">'me</span></span>').json() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-symbol"><span class="hljs-symbol">'facebook</span></span>$' + me[<span class="hljs-symbol"><span class="hljs-symbol">'id</span></span>'], me.get(<span class="hljs-symbol"><span class="hljs-symbol">'email</span></span>').split(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>], # Facebook does not provide # username, so the email<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> user # is used instead me.get(<span class="hljs-symbol"><span class="hljs-symbol">'email</span></span>') ) class TwitterSignIn(OAuthSignIn): # ... def callback(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>): request_token = session.pop(<span class="hljs-symbol"><span class="hljs-symbol">'request_token</span></span>') <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'oauth_verifier</span></span>' not <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.args: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">None</span></span> oauth_session = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service.get_auth_session( request_token[<span class="hljs-number"><span class="hljs-number">0</span></span>], request_token[<span class="hljs-number"><span class="hljs-number">1</span></span>], data={<span class="hljs-symbol"><span class="hljs-symbol">'oauth_verifier</span></span>': request.args[<span class="hljs-symbol"><span class="hljs-symbol">'oauth_verifier</span></span>']} ) me = oauth_session.get(<span class="hljs-symbol"><span class="hljs-symbol">'account</span></span>/verify_credentials.json').json() social_id = <span class="hljs-symbol"><span class="hljs-symbol">'twitter</span></span>$' + <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>(me.get(<span class="hljs-symbol"><span class="hljs-symbol">'id</span></span>')) username = me.get(<span class="hljs-symbol"><span class="hljs-symbol">'screen_name</span></span>') <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> social_id, username, <span class="hljs-literal"><span class="hljs-literal">None</span></span> # Twitter does not provide email</code> </pre> <br><p>  In the <code>callback()</code> method, a verification token is transmitted, which the application can use to communicate with the provider API.  In the case of OAuth 2, this occurs as a <code>code</code> argument, whereas for OAuth 1.0a it is <code>oauth_verifier</code> , both specified in the query string. <br>  This code is used to get <code>oauth_session</code> from the <em>rauth</em> service <em>object</em> . </p><br><p>  Note that in the latest versions of the Facebook API, the session token is returned in JSON format.  The default format expected by rauth for this token should be specified in the query string.  For this reason, you need to add a <code>decoder</code> argument that decodes the contents of the JSON.  In Python 2, it's enough to pass <code>json.loads</code> , but in Python 3 we need an extra step, because the payload is returned as <em>bytes</em> that the json parser does not understand.  Conversion from bytes to a string is performed in the internal function decode_json. </p><br><p>  The <code>oauth_session</code> object can be used to provide API requests to the provider.  Here it is used to request information about the user, which must be provided by a particular provider.  Facebook provides the user ID and email address, but does not provide user names, so the username for the application is created from the left side of the email address.  Twitter provides the user ID and username, but does not support email, so the email is returned as <code>None</code> . </p><br><p>  The data received from the provider is finally returned as a three-element tuple for the view function.  Please note that in both cases the <code>id</code> value from the provider is added with <code>¬´facebook $¬ª</code> or <code>¬´twitter $¬ª</code> before returning it, in order to make it unique for all providers.  Since this is what the application will store as <code>social_id</code> in the database, it is necessary to do this so that the two providers who have assigned the same <code>id</code> two different users do not conflict in the application database. </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  As I mentioned above, the sample application allows any user to register and log in with a Facebook or Twitter account.  The application demonstrates how to register users without having to enter any information, all they need to do is to log in with the provider and allow information sharing. <br>  If you want to try this example, you need to complete some preparatory steps: </p><br><p>  Clone or download the project repository: <a href="https://github.com/miguelgrinberg/flask-oauth-example"></a>  <a href="https://github.com/miguelgrinberg/flask-oauth-example">https://github.com/miguelgrinberg/flask-oauth-example</a> <br>  Create a virtual environment and install the packages on the list in the <em>requirements.txt</em> file (you can use Python 2.7 or 3.4). <br>  Register your ‚Äúapp‚Äù using Facebook and Twitter. <br>  as described above. <br>  Edit <em>app.py</em> with the ID and secret codes of your Facebook and Twitter apps. <br>  After following these instructions, you can start the application using <em>python app.py</em> , and then run <a href="http://localhost/">http: // localhost</a> : 5000 in your browser. </p><br><p>  Hope this article is helpful in demisting OAuth. <br>  If you have questions, write them below. </p><br><p>  Miguel </p></div><p>Source: <a href="https://habr.com/ru/post/346918/">https://habr.com/ru/post/346918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346904/index.html">Agile communication in distributed teams that do not intersect at work time</a></li>
<li><a href="../346906/index.html">How to recover a stolen domain through WIPO arbitration. Step-by-step instruction</a></li>
<li><a href="../346908/index.html">State Machines and Web Application Development</a></li>
<li><a href="../346910/index.html">A selection of free computer forensic tools (forsensics)</a></li>
<li><a href="../346914/index.html">Advantages and fatal flaws in php typing</a></li>
<li><a href="../346920/index.html">Ten startups from 1298: the story of the first global IKEA Bootcamp</a></li>
<li><a href="../346922/index.html">Interview with Oren Kaniel (CEO Appsflyer) about the mobile ecosystem, investments in technology and corporate culture</a></li>
<li><a href="../346924/index.html">How many participants can be in a WebRTC call?</a></li>
<li><a href="../346926/index.html">Design Template Projects or the complexity of managing large projects</a></li>
<li><a href="../346928/index.html">Past, present and future speech recognition technology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>