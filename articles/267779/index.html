<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a REST service on Rust. Part 3: update the database from the console</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous section, we analyzed the database configuration file to read the connection parameters from it. 

 Now let's implement directly the da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a REST service on Rust. Part 3: update the database from the console</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/267661/">previous section,</a> we analyzed the database configuration file to read the connection parameters from it. <br><br>  Now let's implement directly the database update operations: creating, updating, deleting our records and the corresponding command line interface. <br><a name="habracut"></a><br>  First, let's look at the arguments of the program.  Its interface will look like this: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HELP: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Usage: phonebook COMMAND [ARG]... Commands: add NAME PHONE - create new record; del ID1 ID2... - delete record; edit ID - edit record; show - display all records; show STRING - display records which contain a given substring in the name; help - display this help."</span></span>;</code> </pre> <br>  There are already a couple of interesting points here.  <a href="http://kgv.github.io/rust_book_ru/src/const-and-static.html">const</a> declares a constant, and such that it is simply built into the place of use.  Thus, it does not have its own address in memory - it looks like #define in C. The type of constant must always be specified - and in this case it may look a little scary.  &amp; 'static str?  What is it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If my memory serves me, we have not yet seen the clearly indicated lifetimes.  So, this is a link, &amp; str, and it can be written differently as &amp; 'foo str.  Usually we do not have to explicitly specify the time of life, because  the compiler itself can output it - i.e.  'foo just goes down. <br><br>  I also note that 'foo could be' bar or anything else ‚Äî it's just the name of a variable.  In our case, you can think of it like this: link HELP: &amp; str has a lifetime called 'foo, and it is equal to' static. <br><br>  Now about 'static.  This is a lifetime equal to the lifetime of the program.  Our line is directly embedded in the image of the program, and it does not require any initialization or explicit destruction.  Therefore, it is always available while the program is running.  You can read more about 'static <a href="http://kgv.github.io/rust_book_ru/src/lifetimes.html">here</a> . <br><br>  Thus, we declared a string constant, which is always available. <br><br>  But the code for parsing the arguments - as always, first of all.  Then we take a closer look at it. <br><br><div class="spoiler">  <b class="spoiler_title">Command line parsing code</b> <div class="spoiler_text"><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = std::env::args().collect(); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(text) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> text.as_ref() { <span class="hljs-string"><span class="hljs-string">"add"</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() != <span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: phonebook add NAME PHONE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r = db::insert(db, &amp;args[<span class="hljs-number"><span class="hljs-number">2</span></span>], &amp;args[<span class="hljs-number"><span class="hljs-number">3</span></span>]) .unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} rows affected"</span></span>, r); }, <span class="hljs-string"><span class="hljs-string">"del"</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: phonebook del ID..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ids: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = args[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .map(|s| s.parse().unwrap()) .collect(); db::remove(db, &amp;ids) .unwrap(); }, <span class="hljs-string"><span class="hljs-string">"edit"</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() != <span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: phonebook edit ID NAME PHONE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = args[<span class="hljs-number"><span class="hljs-number">2</span></span>].parse().unwrap(); db::update(db, id, &amp;args[<span class="hljs-number"><span class="hljs-number">3</span></span>], &amp;args[<span class="hljs-number"><span class="hljs-number">4</span></span>]) .unwrap(); }, <span class="hljs-string"><span class="hljs-string">"show"</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: phonebook show [SUBSTRING]"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() == <span class="hljs-number"><span class="hljs-number">3</span></span> { s = args.get(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { s = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r = db::show(db, s.as_ref().map(|s| &amp;s[..])).unwrap(); db::format(&amp;r); }, <span class="hljs-string"><span class="hljs-string">"help"</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, HELP); }, command @ _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid command: {}"</span></span>, command)) } } <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"No command supplied"</span></span>), }</code> </pre><br></div></div><br>  Let's look at the first line: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = std::env::args().collect();</code> </pre><br>  std :: env :: args () simply returns an iterator over the command line arguments.  Why is this an iterator and not some kind of static array?  Because we may not need all the arguments, and potentially there may be a lot of them.  Therefore, an iterator is used - it is "lazy."  This is in the spirit of Rust - you do not pay for what you do not need. <br><br>  So, here we obviously have few arguments and it will be easier for us to have a normal vector from which the arguments can be taken by indices.  We do .collect () to bypass all the elements and collect them into a specific collection. <br><br>  What kind of collection?  Here is a subtle point.  In fact, <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html">.collect ()</a> calls the <a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html">from_iter ()</a> method of the collection in which the elements are put.  So, we need to know its type.  That is why we cannot omit the args type and write this: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args = std::env::args().collect();</code> </pre><br>  Here is what the compiler will say to this: <br><br><pre> <code class="hljs vhdl">main.rs:<span class="hljs-number"><span class="hljs-number">61</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-number"><span class="hljs-number">61</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span>: unable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> infer enough <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> information about `_`; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> annotations <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> binding required [E0282] main.rs:<span class="hljs-number"><span class="hljs-number">61</span></span> let args = std::env::args().collect(); ^~~~ main.rs:<span class="hljs-number"><span class="hljs-number">61</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-number"><span class="hljs-number">61</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> help: run `rustc <span class="hljs-comment"><span class="hljs-comment">--explain E0282` to see a detailed explanation</span></span></code> </pre><br>  However, notice that type inference does its job: we only need to specify Vec &lt;_&gt; as the type: what type lies in the vector, the compiler already knows.  It is only necessary to clarify which collection we want. <br><br>  Well, why all these difficulties?  So that we can, for example, collect arguments into a linked list (or some other collection), if we want: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> args: std::collections::LinkedList&lt;_&gt; = std::env::args().collect();</code> </pre><br>  A list of collections that implement from_iter is on the <a href="https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html">type</a> documentation page. <br><br>  Next we see: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>) {</code> </pre><br>  <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html">.get ()</a> returns Ok (element) if an element of the vector exists, and None otherwise.  We use this to detect a situation where the user does not specify a command: <br><br><pre> <code class="rust hljs"> } <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"No command supplied"</span></span>), }</code> </pre><br>  If the command does not match any of the predefined ones, we output an error: <br><br><pre> <code class="rust hljs"> command @ _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid command: {}"</span></span>, command))</code> </pre><br>  We want to get into this branch for any value of text ‚Äî therefore, _, ‚Äúany value‚Äù is used as the value of this branch.  However, we want to output this very wrong command, so we associate the match expression with the name command with the command @ _ construct.  Read more about this syntax <a href="http://kgv.github.io/rust_book_ru/src/patterns.html">here</a> and <a href="http://kgv.github.io/rust_book_ru/src/patterns.html">here</a> . <br><br>  Further analysis looks like this: <br><br><pre> <code class="rust hljs"> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(text) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> text.as_ref() { <span class="hljs-string"><span class="hljs-string">"add"</span></span> =&gt; { <span class="hljs-comment"><span class="hljs-comment">// handle add },</span></span></code> </pre><br>  If we have a command, we will get into the Some (text) branch.  Next, we use match again to match the name of the team - as you can see, match is quite universal. <br><br>  The teams understand quite the same way, so let's consider the most interesting: delete.  It accepts a list of record identifiers that must be deleted. <br><br><pre> <code class="rust hljs"> <span class="hljs-string"><span class="hljs-string">"del"</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.len() &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"Usage: phonebook del ID..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ids: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = args[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .map(|s| s.parse().unwrap()) .collect(); db::remove(db, &amp;ids) .unwrap(); },</code> </pre><br>  First we need identifiers: we get them from the command line arguments as follows: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ids: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = args[<span class="hljs-number"><span class="hljs-number">2</span></span>..].iter() .map(|s| s.parse().unwrap()) .collect();</code> </pre><br>  With let foo: Vec &lt;_&gt; = ... .collect (), we are already familiar.  It remains to understand what is happening inside this line. <br><br>  args [2 ..] gets a slice of the vector - starting from the third element to the end of the vector.  Looks like slices in python. <br><br>  .iter () gets an iterator over this slice, to which we apply an anonymous function using .map (): <br><br><pre> <code class="rust hljs"> .map(|s| s.parse().unwrap())</code> </pre><br>  Our anonymous function takes a single argument, s, and parses it as an integer.  How does she know that it must be a whole?  From here: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ids: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; =</code> </pre><br>  (Hehe, in fact, not even from here, but from the signature of the db :: remove function - it accepts the &amp; [i32] slice. Type output uses this information to understand that <a href="https://doc.rust-lang.org/stable/std/str/trait.FromStr.html">FromStr</a> :: from_str should be called from i32. Therefore we could also use Vec &lt;_&gt; here, but for documenting the code, we explicitly indicated the type. About db :: remove itself - below.) <br><br>  In general, using iterator adapters like .map () is a common pattern in Rust code.  It allows you to get controlled laziness of execution where it is most often needed - when streaming reading some data. <br><br>  Great, we coped with all the preparatory work.  It remains to update the base itself.  insert looks <a href="">quite boring</a> .  Let's look at remove. <br><br>  By the way, why is it written as db :: remove?  Because it is in a separate module.  At the file level, this means that it is in a separate source: src / db.rs.  How is this module included in our main file?  Like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> db;</code> </pre><br>  Simply!  This instruction is equivalent to inserting the entire source code of a module in the place where it is written.  (But in fact this does not happen, it‚Äôs not a preprocessor. The entire container is compiled here at once, so the compiler can read the modules into memory and establish connections at the intermediate presentation level, and not stupidly copy the source code as text.) That the compiler will look for the module in the src / db.rs and src / db / mod.rs files - this allows you to accurately organize the hierarchy of modules. <br><br>  Now the code of our function: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span></span>(db: Connection, ids: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>]) -&gt; ::postgres::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stmt = db.prepare(<span class="hljs-string"><span class="hljs-string">"DELETE FROM phonebook WHERE id=$1"</span></span>).unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ids { <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(stmt.execute(&amp;[id])); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  So, here we know almost everything.  In order. <br><br>  pub means that the function is available outside the module.  Otherwise, we would not be able to call it from main, since  By default, all functions inside modules are hidden: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:81</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:21</span></span>: 81<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:31</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">function</span></span> `<span class="hljs-selector-tag"><span class="hljs-selector-tag">remove</span></span>` <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:81</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">db</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::remove(db</span></span>, &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">ids</span></span>) ^~~~~~~~~~</code> </pre><br>  The return type looks weird.  :: postgres :: Result? <br><br>  Two colons mean that the postgres module needs to be searched from the root of our container, and not from the current module.  This module is automatically declared in main.rs when we do extern crate postgres.  But it does not become visible in db.rs automatically!  Therefore, we climb into the root of the namespace with :: postgres.  We could also re-request the binding of the postgres container in db.rs, but this is not considered good practice - it‚Äôs better if all the binding requests are in the same place and the other modules use what is available in the main. <br><br>  Well, we figured out a bit with the modules.  See <a href="http://kgv.github.io/rust_book_ru/src/crates-and-modules.html">here for</a> more details. <br><br>  Next, we see an unprecedented macro: <code>try!</code>  . <br><br>  He, as his name suggests, is trying to perform an operation.  If it succeeds, the value of try! () Will be the value nested in Ok (_).  If not, it performs something similar to return Err (error).  This is an alternative to our constant .unwrap () - now the program does not panic in case of an error, but returns an error to the top for processing by the calling function. <br><br>  This macro can be used in functions that return Result themselves - otherwise the macro will not be able to return Err, since  return type and value type in return do not match. <br><br>  With the removal of everything.  Next, I selectively go through the rest of the operations, describing what we do not yet know. <br><br>  Here, for example, how to work with transactions: <br><br><pre> <code class="rust hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx: ::postgres::Transaction = db.transaction().unwrap(); tx.execute( <span class="hljs-string"><span class="hljs-string">"UPDATE phonebook SET name = $1, phone = $2 WHERE id = $3"</span></span>, &amp;[&amp;name, &amp;phone, &amp;id]).unwrap(); tx.set_commit(); }</code> </pre><br>  As you can see, this is a typical application of RAII.  We simply don‚Äôt pass tx anywhere, and it is destroyed upon exiting the block.  The implementation of its destructor saves or rolls back the transaction depending on the success flag.  If we had not done tx.set_commit (), the tx destructor <a href="http://sfackler.github.io/rust-postgres/doc/v0.10.0/postgres/struct.Transaction.html">would have rolled it back</a> . <br><br>  And here is how you can format a string without printing it on the screen: <br><br><pre> <code class="rust hljs"> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"WHERE name LIKE '%{}%'"</span></span>, s),</code> </pre><br>  When we create a vector, you can immediately specify how many elements it should allocate memory: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> results = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size);</code> </pre><br>  And finally, another functional code example: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max = rs.iter().fold( <span class="hljs-number"><span class="hljs-number">0</span></span>, |acc, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> item| <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.name.len() &gt; acc { item.name.len() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { acc });</code> </pre><br>  This code could be written easier if we compared the types for which the <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html">Ord</a> type is implemented: <br><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max = rs.iter().max();</code> </pre><br>  Or, we can implement this <a href="http://kgv.github.io/rust_book_ru/src/traits.html">type</a> for Record.  It requires the implementation of PartialOrd and Eq, and Eq, in turn, is PartialEq.  Therefore, in fact, have to implement 4 types.  Fortunately, the implementation is trivial. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation of types</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp::Ordering; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Ord</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Record { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmp</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; Ordering { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name.len().cmp(&amp;other.name.len()) } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Record { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_cmp</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Ordering&gt; { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name.len().cmp(&amp;other.name.len())) } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Record { } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Record { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id == other.id &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name == other.name &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.phone == other.phone } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format</span></span></span></span>(rs: &amp;[Record]) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> max = rs.iter().max().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rs { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{:3} {:.*} {}"</span></span>, v.id, max.name.len(), v.name, v.phone); } }</code> </pre><br></div></div><br>  It is worth noting that the meaningfulness of such an implementation is questionable - it is hardly worth comparing database records along the length of one of the fields. <br><br>  By the way, the Eq type is one of the examples of marker types: it does not require the implementation of any methods, but simply tells the compiler that some type has a certain property.  Other examples of such types are Send and Sync, about which we will talk more. <br><br>  For today everything is a post, and so it turned out to be the longest of the series. <br><br>  Now our application really works, but it does not have a REST interface yet.  The web part we will do next time. </div><p>Source: <a href="https://habr.com/ru/post/267779/">https://habr.com/ru/post/267779/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267769/index.html">Attach files to comments</a></li>
<li><a href="../267771/index.html">Nothing is easier than calling a function; I myself have done this repeatedly.</a></li>
<li><a href="../267773/index.html">Modification of the system call. Part 2</a></li>
<li><a href="../267775/index.html">"Front-end Bookshelf" - like google, only better</a></li>
<li><a href="../267777/index.html">Candy Challenge</a></li>
<li><a href="../267781/index.html">C ++ module support in Visual Studio 2015 Update 1</a></li>
<li><a href="../267785/index.html">Go, practice asynchronous interaction</a></li>
<li><a href="../267789/index.html">Flying panels flew away from us ... About navigation and the "Back" button in C # / XAML applications in Windows 10</a></li>
<li><a href="../267791/index.html">Virtual quadrocopter on Unity + OpenCV (Part 1)</a></li>
<li><a href="../267795/index.html">The digest of interesting materials for the mobile # 122 developer (September 21-27)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>