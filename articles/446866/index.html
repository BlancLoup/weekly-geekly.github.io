<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating Systems: Three Easy Pieces. Part 2: Abstraction: The Process (Translation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction to operating systems 
 Hi, Habr! I want to bring to your attention a series of articles-translations of one interesting in my opinion lit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating Systems: Three Easy Pieces. Part 2: Abstraction: The Process (Translation)</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction to operating systems </h1><br>  Hi, Habr!  I want to bring to your attention a series of articles-translations of one interesting in my opinion literature - OSTEP.  This material takes a rather in-depth look at the work of unix-like operating systems, namely, working with processes, various schedulers, memory, and other similar components that make up a modern OS.  The original of all materials you can see <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/">here</a> .  Please note that the translation was made unprofessionally (fairly freely), but I hope I saved the general meaning. <br><br>  Laboratory work on this subject can be found here: <br><ul><li>  original: <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html</a> </li><li>  original: <a href="https://github.com/remzi-arpacidusseau/ostep-code">github.com/remzi-arpacidusseau/ostep-code</a> </li><li>  my personal adaptation: <a href="https://github.com/bykvaadm/OS/tree/master/ostep">github.com/bykvaadm/OS/tree/master/ostep</a> </li><li>  <a href="https://habr.com/en/post/449026/">Part 3: Scheduler Introduction</a> </li></ul><br>  Other parts: <br><ul><li>  <a href="https://habr.com/en/post/446340/">Part 1: Intro</a> </li><li>  <a href="https://habr.com/en/post/446866/">Part 2: Abstraction: the process</a> </li><li>  <a href="https://habr.com/en/post/447182/">Part 3: Introduction to the Process API</a> </li><li>  <a href="https://habr.com/en/post/449026/">Part 4: Scheduler Introduction</a> </li></ul><br>  And you can also look to me on the channel in the <a href="https://t.me/bykvaadm">telegram</a> =) <br><a name="habracut"></a><br><br>  Consider the most fundamental abstraction that the OS provides to users: the process.  The process definition is quite simple - it is a <b>working program</b> .  The program itself is a lifeless thing, located on the disk is a set of instructions and perhaps some static data waiting for the launch moment.  It is the OS that takes these bytes and runs them, converting the program into something useful. <br>  Most often, users want to run more than one program at a time, for example, you can run a browser, game, media player, text editor, and the like on your laptop.  In fact, a typical system can run tens and hundreds of processes simultaneously.  This fact makes the system easier to use, you never have to worry about whether the CPU is free, you just run the programs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Hence the problem: how to ensure the illusion of multiple CPUs?</i>  <i>How does the OS create the illusion of a virtually infinite number of CPUs, even if you have only one physical CPU?</i> <br><br>  The OS creates this illusion through CPU virtualization.  By starting one process, then stopping it, starting another process, and so on, the OS can maintain the illusion that there are many virtual CPUs, although in fact it will be one or more physical processors.  Such a technique is called time <b>sharing of CPU resources</b> .  This technique allows users to run as many simultaneous processes as they wish.  The cost of this solution is performance - because if the CPUs share several processes, each process will be processed more slowly. <br>  To implement CPU virtualization, and especially to do this well, the OS needs both low-level and high-level support.  Low-level support is called <b>mechanisms</b> - these are low-level methods or protocols that implement the necessary part of the functionality.  An example of such functionality is context-sensitive switching, which allows the OS to stop one program and start another program on the processor.  This time division is implemented in all modern operating systems. <br>  At the top of these mechanisms is some logic embedded in the OS, in the form of a ‚Äúpolitician‚Äù.  <b>A policy</b> is a decision-making algorithm by the operating system.  Such politicians, for example, decide which program to run (from the list of commands) first.  So, for example, this task will be solved by a policy called <b>scheduling policy</b> and when choosing a solution it will be guided by such data as: launch history (which program was running the longest in the last minutes), what load this process carries out (what types of programs were running performance metrics (whether the system is optimized for interactive or bandwidth), and so on. <br><br><h3>  Abstraction: the process </h3><br>  The abstraction of a running program performed by the operating system is what we call a <b>process</b> .  As it was said before, the process is just a working program, at any instant.  A program with the help of which we can obtain summary information from various system resources and which are accessed or affected by this program during its execution. <br>  To understand the components of the process you need to understand the state of the system: what the program can read or change during its work.  At any time you need to understand what elements of the system are important for the execution of the program. <br>  One of the obvious elements of the state of a system that a process involves is <b>memory</b> .  Instructions are located in memory.  The data that the program reads or writes is also stored in memory.  Thus, the memory that a process can address (the so-called address space) is part of the process. <br>  Registers are also part of the system state.  Many instructions are intended to change the value of registers or read their meaning and thus registers also become an important part of the process. <br>  It should be noted that the state of the machine is also formed from some special registers.  For example, <b>IP - instruction pointer</b> - a pointer to the instruction that the program is currently executing.  There is also a <b>stack pointer</b> and a <b>frame pointer</b> associated with it, which are used to control: function parameters, local variables, and return addresses. <br>  Finally, programs often access a ROM (Read Only Memory).  Such information about ‚ÄúI / O‚Äù (I / O) should include a list of files currently open by the process. <br><br><h3>  Process API </h3><br>  In order to improve the understanding of the work process, we study examples of system calls that should be included in any interface of the operating system.  These APIs are available in one form or another on any OS. <br><br>  ‚óè <b>Create</b> : The OS must include some method that allows you to create new processes.  When you enter a command into the terminal or launch an application by double-clicking on the icon, a call is sent to the OS to create a new process and then launch the specified program. <br>  ‚óè <b>Delete</b> : Once there is an interface for creating a process, the OS must also provide the option to force the removal of a process.  Most programs will naturally run and complete on their own as they are executed.  Otherwise, the user would like to be able to kill them and thus the interface for stopping the process will not be superfluous. <br>  ‚óè <b>Wait</b> : Sometimes it is useful to wait for the process to complete, so some interfaces are provided that provide the ability to wait. <br>  ‚óè <b>Misc Control</b> (miscellaneous control): In addition to killing and waiting for the process, there are other various controlling methods.  For example, most operating systems provide the opportunity to freeze the process (stopping its execution for a certain period) and the subsequent resumption (continued execution) <br>  ‚óè <b>Status</b> : There are various interfaces for getting some information about the status of the process, such as the duration of its work or what state it is in now. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/f4a/5b6/110f4a5b66b1fb12132dd97488dbe035.jpg" alt="image"><br><br><h3>  Process creation: details </h3><br><br>  One of the interesting things is how exactly programs transform into processes.  Especially as the OS picks up and launches the program.  How exactly is the process created? <br>  First of all, the OS must load the program code and static data into memory (into the process address space).  Programs are usually located on a disk or solid-state drive in some executable format.  Thus, the process of loading a program and static data into memory requires the OS to read these bytes from the disk and place them somewhere in memory. <br><br>  In early OSs, the boot process was performed impatiently (eagerly), which means that the code was loaded into memory entirely before the program was started.  Modern OSs do this lazily, that is, downloading pieces of code or data only when they are required by the program during its execution. <br><br>  After the code and static data are loaded into the OS memory, you need to perform several more things before starting the process.  A certain amount of memory must be allocated for the stack.  <b>Programs use a stack for local variables, function parameters, and return addresses</b> .  The OS allocates this memory and gives it to the process.  The stack can also be allocated with some arguments, specifically it fills the parameters of the main () function, for example, with the argc and argv array. <br><br>  The operating system may also allocate some amount of memory for a heap of the program.  <b>The heap is used by programs for explicitly requested dynamically allocated data</b> .  Programs request this space by calling the <b>malloc ()</b> function and explicitly clear by calling the <b>free ()</b> function.  A heap is needed for data structures such as: linked sheets, hash tables, trees, and others.  At first, a small amount of memory is allocated for the heap, but over time, as the program runs, the heap can request a larger amount of memory, through the library API call malloc ().  The operating system is involved in allocating more memory to help meet these challenges. <br><br>  The operating system will also perform initialization tasks, in particular those related to I / O.  For example, on UNIX systems, by default each process has 3 open file descriptors for standard input, output, and error streams.  These descriptors allow programs to read input from the terminal, as well as display information on the screen. <br><br>  Thus, by loading code and static data into memory, creating and initializing the stack, and also performing other work related to performing I / O tasks, the OS prepares a platform for the process.  In the end, the last task remains: to launch the program through its entry point, called the main () function.  Turning to the execution of the function main (), the OS transfers control of the CPU to the newly created process, so the program starts to run. <br><br><h3>  Process state </h3><br>  Now that we have some understanding of what a process is and how it is created, we list the states of the process in which it can be.  In its simplest form, a process can be in one of these states: <br>  ‚óè <b>Running</b> .  In the running state, the process is performed on the processor.  This means that instructions are being executed. <br>  ‚óè <b>Ready</b> .  In the ready state, the process is ready to start, but for some reason the OS is not executing it at a given point in time. <br>  ‚óè <b>Blocked</b> .  In the locked state, the process performs some operations that prevent it from being ready for execution until an event occurs.  One common example is when a process initializes an IO operation, it becomes blocked, and thus some other process may use the processor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a81/461/aff/a81461aff131813d47fff8756e574ec5.jpg" alt="image"><br><br>  Imagine these states can be in the form of a graph.  As we can see in the picture, the state of the process can vary between RUNNING and READY at the discretion of the OS.  When a process state changes from READY to RUNNING, this means that the process has been scheduled.  In the opposite direction - removed from the layout.  At the moment when the process becomes BLOCKED, for example, I initialize the IO operation, the OS will keep it in this state until a certain event occurs, for example, the completion of IO.  at this point, the transition to the READY state and possibly instantly to the RUNNING state, if the OS so decides. <br>  Let's take a look at an example of how the two processes go through these states.  To begin with, imagine that both processes are running, and each uses only the CPU.  In this case, their states will look like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/a55/b88/444a55b8805289a03818225bd8366e25.jpg" alt="image"><br><br>  In the following example, the first process, after a while, requests IO and goes into the BLOCKED state, allowing the other process to start (RIS 1.4).  The OS sees that process 0 does not use the CPU and starts process 1. During the execution of process 1 - IO terminates and the status of process 0 changes to READY.  Finally, process 1 is completed, and when it ends, process 0 starts, runs, and ends its work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/561/07c/ccf/56107cccfd8d68267534cefe161694ff.jpg" alt="image"><br><br><h3>  Data structure </h3><br>  The OS itself is a program, and like any other program it has some key data structures that track a variety of relevant pieces of information.  To track the status of each process in the OS, some <b>process list</b> will be maintained for all processes in the READY state and some additional information to track the processes that are currently running.  Also, the OS should monitor and blocked processes.  After completing the IO, the OS must wake up the desired process and put it into a state of readiness for launch. <br><br>  For example, the OS must maintain the state of the processor registers.  At the time of stopping the process, the state of the registers is stored in the address space of the process, and at the time of its continuation, to restore the values ‚Äã‚Äãof the registers and thus continue the execution of this process. <br><br>  In addition to the states ready, blocked, running, there are some other states.  Sometimes at the time of creation a process may have an INIT state.  Finally, the process can be placed in the FINAL state when it has already completed, but information about it has not yet been cleared.  On UNIX systems, this state is called <b>a zombie process</b> .  This state is useful for cases where the parent process wants to know the return code of the child, for example, usually 0 indicates a successful completion, and 1 erroneous, however programmers can make additional output codes, signaling various problems.  Upon completion, the parent process makes the last system call, such as wait (), to wait for the child process to finish and signal the OS that any data associated with the completed process can be cleared. <br><br><img src="https://habrastorage.org/webt/xr/d3/wl/xrd3wlzbk6w6l_dpfflo-fj536a.png"><br><br><h3>  Key points of the lecture: </h3><br>  ‚óè <b>Process</b> - the main abstraction of a running program in the OS.  At any time, a process can be described by its state: the contents of the memory in its address space, the contents of the processor registers, including the instruction pointer and stack pointer, are also information about IO, for example, open files that are read or written. <br>  ‚óè The <b>Process API</b> consists of calls that programs can make to processes.  These are usually creation, delete, or other calls. <br>  ‚óè The process is in one of many states, including running, ready, blocked.  Various events, such as planning, de-planning or waiting, can translate the state of a process from one to another. <br>  ‚óè The <b>process list</b> contains information about all the processes in the system.  Each entry in it is called a process control block, which in reality is a structure that contains all the necessary information about a particular process. </div><p>Source: <a href="https://habr.com/ru/post/446866/">https://habr.com/ru/post/446866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446854/index.html">Azure tech lab, April 11 in Moscow</a></li>
<li><a href="../446858/index.html">How to deploy SAP HANA: parse different methods</a></li>
<li><a href="../446860/index.html">History 3dfx Voodoo1</a></li>
<li><a href="../446862/index.html">What designers are waiting for at DUMP-2019: a review of the Design section</a></li>
<li><a href="../446864/index.html">Energy, heat and water</a></li>
<li><a href="../446876/index.html">Moscow, April 18 - QIWI SERVER PARTY 4.0</a></li>
<li><a href="../446880/index.html">Incorrect charts: our experience</a></li>
<li><a href="../446882/index.html">MIPT won the right to host the ICPC World Programming Championship in 2020 in Moscow</a></li>
<li><a href="../446884/index.html">What to read and see from fresh fiction: Mars, cyborg and the insurgent AI</a></li>
<li><a href="../446886/index.html">Experts Top 3D Expo: Sunny Wong. Over 25 million sprains can be prevented</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>