<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity: infinite procedurally generated city, obtained using the WFC algorithm (wave function collapse)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 As trendsetters on Unity on the Russian market, we suggest you read an interesting study on the practical use of the WFC (Wave Function C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity: infinite procedurally generated city, obtained using the WFC algorithm (wave function collapse)</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  As <a href="https://www.piter.com/product_by_id/129958293">trendsetters</a> on <a href="https://www.piter.com/product_by_id/103057273">Unity</a> on the Russian market, we suggest you read an interesting study on the practical use of the WFC (Wave Function Collapse) algorithm, built in the image and likeness of the well-known principle of quantum mechanics and very convenient for procedural generation of levels in games.  Earlier on Habr√© already published a <a href="https://habr.com/ru/post/437604/">detailed account</a> of this algorithm.  The author of today's article, Marian Kleineberg, considers the algorithm in the context of three-dimensional graphics and the generation of an infinite city.  Enjoy reading! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/e7/af/4be7afzttmmd9g8y2snj_pnxpns.jpeg"></div><a name="habracut"></a><br>  We'll talk about the game, where you walk through an endless city that is procedurally generated as you move.  A city is built from a set of blocks using the WFC algorithm (wave function collapse). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Playable build is available for download on <a href="https://marian42.itch.io/wfc">itch.io.</a>  You can also get the <a href="https://github.com/marian42/wavefunctioncollapse">source code on github</a> .  Finally, I propose a <a href="http://www.youtube.com/embed/-W7zt8181Zo">video</a> in which I am walking on a city generated in this way. <br><br><h3>  Algorithm </h3><br>  I will call the word ‚Äúcell‚Äù such an element of a 3D voxel grid, which may contain a block or be empty.  The word "module" I will call a block that can occupy such a cell. <br><br>  The algorithm decides which modules to select in each cell of the game world.  A cell array is considered to be a wave function in its unobservable form.  Thus, each cell corresponds to a set of modules that may be in it.  In terms of quantum mechanics one could say, "the cell is in the superposition of all modules."  The existence of the world begins in a completely unobservable form, where in each cell there can be any module.  Further, all the cells collapse, one after another.  This means that for each cell, one module is randomly selected from among all possible. <br><br>  The next step is the propagation of constraints (constraint propagation).  For each module, a subset of modules is selected that are allowed to be adjacent to it.  Each time the module collapses, the subsets of other modules are updated, which are still allowed as adjacent ones.  The stage of propagation of constraints is the most resource-intensive part of the algorithm in terms of computing power. <br><br>  An important aspect of the algorithm is determining which cell to collapse.  The algorithm always collapses the cell with the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%258D%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BF%25D0%25B8%25D1%258F">lowest entropy</a> .  This is a cell that allows the minimum number of choices (that is, the cell with the least randomness).  If all modules have the same collapse probability, then the smallest entropy will be in that cell, which corresponds to the minimum number of possible modules.  As a rule, the probabilities of being chosen for different modules are different.  A cell with two possible modules that have the same probability provides for a wider choice (greater entropy) than the one in which there are two modules, and for one of them the probability to fall under the choice is very large, and for the other - very small. <br><br><img src="https://habrastorage.org/webt/dp/kw/z-/dpkwz-w1fr5-xxrw_flqyt_mtou.gif"><br><br>  (Gifka ExUtumno placed on Github) <br><br>  More information about the wave function collapse algorithm, as well as a number of beautiful examples can be found here.  Initially, this algorithm was proposed for generating 2D textures based on a single sample.  In this case, the probabilistic indicators of the modules and the adjacency rules are determined depending on their occurrence in the example.  This article provides this information manually. <br><br>  Here is a <a href="">video</a> demonstrating this algorithm in action. <br><br><h3>  About blocks, prototypes and modules </h3><br>  The world is generated from a set in which there are about 100 blocks.  I created them with Blender.  At first I had very few blocks, and I gradually added them when I considered it necessary. <br><br><img src="https://habrastorage.org/webt/yj/26/sn/yj26snwykmonhpvoy9mvv_bnsq8.png"><br><br>  The algorithm needs to know which modules can be located next to each other.  For each module there are 6 lists of possible neighbors, one in each of the directions.  However, I wanted to avoid having to create such a list manually.  In addition, I wanted to automatically generate rotated variants for each of my blocks. <br><br>  Both of these tasks are solved with the help of the so-called prototype modules.  In essence, this is <code>MonoBehaviour</code> , which is convenient to work with in the Unity editor.  Modules, along with lists of valid neighboring elements and rotated variants, are automatically created based on such prototypes. <br><br>  A difficult problem has arisen with modeling information about adjacency, so that this automatic process works.  Here's what I got: <br><br><img src="https://habrastorage.org/webt/ym/cj/ke/ymcjkeehpahvovwxbpl7kma28bs.png"><br><br>  Each block has 6 contacts, one for each face.  The contact has a number.  In addition, horizontal contacts can be flipped, non-flipped, or symmetrical.  Vertical contacts either have a rotation index in the range from 0 to 3, or are marked as <i>rotationally invariant</i> . <br><br>  Based on this, I can automatically check which modules are allowed to adjoin each other.  Adjacent modules must have the same pin numbers.  Their symmetry must also coincide (the same index of rotation along the vertical, a pair of inverted and non-inverted contact horizontally), or the modules must be symmetrical / invariant. <br><br><img src="https://habrastorage.org/webt/zk/-3/lo/zk-3looqprzz5upxpuavvmkccbu.png"><br><br>  There are exclusion rules with which I can prohibit neighborhood options that would be allowed by default.  Some blocks with matching contacts to each other simply look ugly side by side.  Here is an example of a map generated without applying exclusion rules: <br><br><img src="https://habrastorage.org/webt/md/od/0f/mdod0f_xkotiz9sc7tigjres6ia.jpeg"><br><br><h3>  Way to infinity </h3><br>  The original wave function collapse algorithm generates maps of finite size.  I wanted to build a world that will expand and expand as you move along it. <br><br>  At first I tried to generate fragments of finite size and use the contacts of adjacent fragments as constraints.  If the fragment is generated, and the adjacent fragment is also generated, then only such modules are allowed, which are placed next to the existing modules.  With this approach, the following problem arises: each time a cell collapses, the propagation of constraints will cut capabilities even at a distance of several cells.  The following image shows the effects of collapsing a single cell: <br><br><img src="https://habrastorage.org/webt/ex/yj/rv/exyjrvgb7tciaf1skkzgndnvpd0.png"><br><br>  If at each step of the algorithm to generate only one fragment, then the restrictions do not apply to adjacent fragments.  In this case, such modules were selected inside the fragment that would be unacceptable if other fragments were taken into account.  As a result, when the algorithm tried to generate the next fragment, it could not find a single solution. <br><br>  Now I no longer use fragments, but I store the map in a dictionary that displays the position of a cell on a cell.  The cell is filled only if necessary.  Some elements of the algorithm should be adjusted to reflect this point.  When choosing a cell that should collapse, it is impossible to take into account all the cells if their number is infinite.  Instead, we simultaneously generate only a small portion of the map as soon as the player reaches it.  Outside this area, restrictions continue to spread. <br><br>  In some cases, this approach does not work.  Consider a set of modules for a straight section of the tunnel from the figure shown above - there is no entrance to the tunnel.  If the algorithm chooses such a tunnel module, then the tunnel by definition will be infinite.  At the stage of propagation of restrictions, the program will try to allocate an infinite number of cells.  I developed a special set of modules to get around this problem. <br><br><h3>  Border conditions </h3><br>  Here there are two important boundary conditions.  All faces on the top level of the map must have "air" contacts.  All faces on the basis of the card must have "solid" contacts.  If these conditions are not met, then there will be holes in the ground on the map, and some buildings will be roofless. <br><br>  On a map of finite size, this problem would be solved easily.  For all cells at the highest and lowest levels, it would be necessary to remove all modules with inappropriate contacts.  Then run the distribution of restrictions and remove the remaining modules that are no longer suitable for us. <br><br>  On a map of infinite size, this does not work, since we have an infinite number of cells both at the highest level and at the lowest level.  The most naive solution is to delete all inappropriate cells as they arise.  However, when the module is removed at the top level, the limitations affect those cells that adjoin it.  An avalanche-like effect occurs, again leading to an infinite selection of cells. <br><br>  I solved this problem by creating a 1 √ó n √ó 1 map, where n is the height.  This card uses world wrapping to propagate restrictions.  The mechanism works as in the game Pacman: leaving the right edge of the card, the character returns to it from the left edge.  Now I can apply any restrictions to my map.  Whenever a new cell is created on an infinite map, this cell is initialized with a set of modules corresponding to a specific position on the map. <br><br><h3>  Error states and search with return </h3><br>  Sometimes the WFC algorithm reaches a state in which no possible module matches the cell.  In applications where we are dealing with a world of finite size, you can simply reset the result and start over.  In an infinite world, this will not work, as part of the world is already shown to the player.  At first I settled on a solution in which the places of occurrence of errors were filled with white blocks. <br><br>  I am currently using a return search.  The cell collapse order and some information on the propagation of constraints is stored as history.  If the WFC algorithm fails, then part of the history is canceled.  As a rule, it works, but sometimes it is possible to recognize errors too late, and a return search covers a lot of steps.  In rare cases, the cell in which the player is located is regenerated. <br><br>  In my opinion, due to this limitation, the use of the WFC algorithm with infinite worlds is not suitable for commercial games. <br><br><h3>  Prehistory </h3><br>  I took up the study of this problem after watching a <a href="https://www.youtube.com/watch%3Fv%3D0bcZb-SsnrA">lecture by Oscar Stelberg</a> , telling how he uses the algorithm to generate levels in the game Bad North.  In general, my algorithm was implemented during the <a href="http://www.procjam.com/">procjam</a> week. <br><br>  I have some ideas for further refinement of this algorithm, but I‚Äôm not sure that I‚Äôm ever going to add gameplay to it.  And if I get together, it will most likely not be such an epic strategy that you have already imagined.  However, if you want to check how your favorite game mechanic works with this algorithm - just try it yourself!  In the end, the source code is publicly available and licensed by MIT. </div><p>Source: <a href="https://habr.com/ru/post/455004/">https://habr.com/ru/post/455004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455/index.html">WordPress MultiUser</a></li>
<li><a href="../4550/index.html">Iran reduces speed</a></li>
<li><a href="../45500/index.html">Regime day President</a></li>
<li><a href="../455000/index.html">Careful transfer to the Netherlands with his wife. Part 3: work, colleagues and other life</a></li>
<li><a href="../455002/index.html">Welcome to Top 3D Expo in September</a></li>
<li><a href="../455006/index.html">Three-command remote control with a program of 290 16-bit words</a></li>
<li><a href="../455010/index.html">Asynchronous user scripts on pure Rust without frameworks and SMS</a></li>
<li><a href="../455012/index.html">Cellular interception FAQ: what are IMSI interceptors / SCATs, and is it possible to protect against them</a></li>
<li><a href="../455014/index.html">Israeli Techsomed, who developed an image analysis system for cancer treatment, received $ 2.6 million in venture capital investment</a></li>
<li><a href="../455016/index.html">We create the most inaccessible website with the perfect Lighthouse rating.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>