<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protothread and cooperative multitasking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to study the planning of small streams. I already told you about two tools in the Linux kernel that are often used for deferred interrupt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protothread and cooperative multitasking</h1><div class="post__text post__text-html js-mediator-article">  We continue to study the planning of small streams.  I already told you about two tools in the Linux kernel that are often used for deferred interrupt handling.  Today we will talk about a completely different entity - <a href="http://dunkels.com/adam/pt/">protothread</a> Adam Dunkels, which, although out of line, are not at all superfluous in the context of the topic under consideration. <br><br>  And: <br><ol><li>  <a href="http://habrahabr.ru/post/244071/">Multitasking in the Linux kernel: interrupts and tasklets</a> </li><li>  <a href="http://habrahabr.ru/post/244155/">Multitasking in the Linux kernel: workqueue</a> </li><li>  <b>Protothread and cooperative multitasking</b> </li></ol><br><a name="habracut"></a><br><h3>  What is it and why is all this necessary? </h3><br>  I decided to combine deferred interrupt handling and cooperative multitasking in one cycle of articles not by chance.  Those entities that I consider in the cycle, and the ideas that they implement, are of great importance not only in the context of the designated tasks, but also in general for real-time systems. <br><br>  Mostly they are united by the question of planning.  Tasklets discussed in the first article, for example, work according to the rules of non-preemptive multitasking.  By the way, about cooperative multitasking, I have already described in some detail in <a href="http://habrahabr.ru/post/219431/">a previous article</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Cooperative multitasking and protothread </h3><br>  Protothreads are lightweight chainless streams implemented on pure C. One of the possible applications is the implementation of cooperative multitasking, which does not require large overheads.  For example, they can be used in embedded systems with severe memory constraints or in nodes of a wireless sensor network. <br><br>  On habrahabr there is already a good <a href="http://habrahabr.ru/users/ldir/" class="user_link">ldir</a> <a href="http://habrahabr.ru/post/143318/">article</a> about multitasking based on protothreads, it addresses the practical side of the question: the ability of the library, how to use it.  The article is accompanied by interesting and illustrative examples. <br><br>  There will also be more about how it works.  Later in this section, I will provide a free and somewhat revised translation of information from the <a href="http://dunkels.com/adam/pt/">site of Adam Dunkels</a> , the creator of protothreads, which describes in detail both the library itself and implementation details, so that anyone can enjoy the original and go on to the next section. <br><br>  The main features and benefits of protothreads: <br><ul><li>  Implementing sequentially control flow without using complex state machines and full multithreading, </li><li>  Using conditional locking inside functions on C, </li><li>  The protothreads are very light, since they have no stack, </li><li>  Protothreads can call other functions, but cannot be locked inside the called function, so you need to wrap each function that uses the lock into a child protothread.  Thus, only explicit blocking is used. </li></ul><br>  Protothreads are implemented using continuations, which represent the current state of execution in a particular place in a program, but it does not support call history and local variables.  Here you need to be especially careful - you need to use local variables very carefully!  There is no allocated stack for protothreads, there is no place to store local variables.  If the stream is used only once, the variables can be declared as static.  Otherwise, you can, for example, wrap the protothread in your structure, and store the variables right there.  In general, I want to say that you need to be aware that improper use of local variables can lead to unpredictable results. <br><br>  In this implementation, the role of the state is played by a positive integer - the current line number of the program.  Control takes place with the help of switch (), similar to how it happens in the <a href="http://en.wikipedia.org/wiki/Duff%2527s_device">Duff method</a> and <a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">with the co-programs of the Simon Tatham implementation</a> .  Protothreads are similar to generators in Python, they are only intended for different purposes: protothreads provide a lock inside a function in C, while Python provides multiple output from a generator. <br><br>  An important limitation of the implementation: the code inside the protothread itself cannot fully use the switch () operator.  However, this limitation is possible using the capabilities of some compilers, for example, gcc. <br><br>  The entire library is implemented on macros, since macros, unlike simple functions, can change the control flow only by means of standard C constructs. <br><br>  The main API includes the following macros: <br><ul><li>  Initialization macro PT_INIT, </li><li>  PT_BEGIN and PT_END macros declaring the beginning and end of the protothread, </li><li>  The macros to wait for the condition PT_WAIT_UNTIL and PT_WAIT_WHILE, </li><li>  Wait execution macros for child protothreads PT_WAIT_THREAD and PT_SPAWN, </li><li>  PT_RESTART restart and PT_EXIT exit macros, </li><li>  Planning macro (essentially launch) PT_SCHEDULE, </li><li>  Macro of the product of the PT_YIELD value, </li><li>  Macros for using the semaphores PT_SEM_INIT, PT_SEM_WAIT and PT_SEM_SIGNAL. </li></ul><br>  We will understand now how macros work.  To begin, consider a program that uses protothreads.  Protothread example performs an eternal loop, where it first waits until the counter reaches a certain value, then displays a message and resets the counter. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pt.h"</span></span></span><span class="hljs-meta"> static int counter; static struct pt example_pt; static PT_THREAD(example(struct pt *pt)) { PT_BEGIN(pt); while(1) { PT_WAIT_UNTIL(pt, counter == 1000); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Threshold reached\n"</span></span></span><span class="hljs-meta">); counter = 0; } PT_END(pt); } int main(void) { counter = 0; PT_INIT(&amp;example_pt); while(1) { example(&amp;example_pt); counter++; } return 0; }</span></span></code> </pre> <br>  Now let's take a look at the simplified version of the macros used in the example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pt</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> lc; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_THREAD(name_args) char name_args #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_BEGIN(pt) switch(pt-&gt;lc) { case 0: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_WAIT_UNTIL(pt, c) pt-&gt;lc = __LINE__; case __LINE__: \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(!(c)) return 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_END(pt) } pt-&gt;lc = 0; return 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PT_INIT(pt) pt-&gt;lc = 0</span></span></code> </pre><br>  The pt structure consists of a single lc field (abbreviated from local continuation).  Note the PT_BEGIN and PT_END, which respectively open and close the switch statement, as well as the slightly more complex macro PT_WAIT_UNTIL.  It uses the embedded macro __LINE__, which returns the current line number of the program file. <br><br>  Let's compare the source and the expanded version of example by the preprocessor: <br><table><tbody><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PT_THREAD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(example(struct pt *pt))</span></span></span><span class="hljs-function"> </span></span>{ PT_BEGIN(pt); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { PT_WAIT_UNTIL(pt, counter == <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Threshold reached\n"</span></span>); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } PT_END(pt); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pt *pt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(pt-&gt;lc) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { pt-&gt;lc = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(counter == <span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Threshold reached\n"</span></span>); counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } pt-&gt;lc = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre></td></tr></tbody></table><br>  The Protothread example now looks like a normal C function. The return value is used to determine the status of the protothread: whether it is blocked waiting for something, completed, exited, or generated the next value.  The PT_BEGIN macro contains a case 0 instruction, so the code that goes right after this macro will be executed first, because the initial value pt-&gt; lc is 0. <br><br>  See what the PT_WAIT_UNTIL macro is deployed to.  The pt-&gt; lc field is now assigned 12, this is the line number, and then case 12 appears - thanks to this switch knows exactly where to jump.  If the condition is not fulfilled, the function returns 0, which means that the thread is waiting (in the library itself, all these constants are stored).  The next time, when example () is called in main, the execution will proceed accordingly with case 12, that is, from checking whether the waiting condition is met.  As soon as the counter reaches 1000, the condition will become true, and example () will now not return 0, but will print a message and reset the counter.  Further, as expected, go to the beginning of the body of the cycle. <br><br>  In <a href="http://habrahabr.ru/post/219431/">one of the previous articles,</a> I gave the code of a primitive cooperative scheduler (section ‚ÄúNon-displacing scheduler with preserving the order of calls‚Äù).  By making minor changes, you can adapt it for protothreads.  It's pretty simple, so I will not give the code.  But wishing to propose to play. <br><br><h3>  Comparison </h3><br>  Finally, I propose to compare the tasklet, workqueue and protothread.  In fact, of course, on the one hand, it is not very correct to compare protothread with the bottom-half interrupt handling tools ‚Äî after all, they are designed for different tasks, you cannot just replace one with another.  On the other hand, the workqueue is also somewhat knocked out of the troika: unlike the others, it works according to the rules of repressive planning, its scope is much broader. <br><br>  Comparison I give more likely to extract useful ideas. <br><br>  Here is the comparative table: <br><table><tbody><tr><th></th><th>  Tasklet </th><th>  Workqueue </th><th>  Protothreads </th></tr><tr><td>  <nobr>Having</nobr> <nobr>your</nobr> <nobr>stack</nobr> </td><td>  No - are processed as softirq (on a specially allocated stack shared by all handlers, at least in Linux on x86) </td><td>  Yes - are executed on the stack of worker-threads, the number of which is much less than the number of tasks </td><td>  Not </td></tr><tr><td>  <nobr>Speed</nobr> </td><td>  Fast - minimal additional processing </td><td>  Fast, but not like tasklets, context switching is required when workers replace each other </td><td>  Very fast - almost no additional processing, more room for optimization by the compiler </td></tr><tr><td>  <nobr>Synchronization</nobr> <nobr>primitives</nobr> </td><td>  None (except spinlock) </td><td>  Present in full </td><td>  Pseudo-semaphores;  primitive waiting for events </td></tr><tr><td>  <nobr>Planning</nobr> <nobr>concept</nobr> </td><td>  Cooperative scheduler like softirq;  tasklets are only supplanted by hardware interrupts </td><td>  Workers play the role of scheduler for work, managed by the main scheduler themselves. </td><td>  Cooperative scheduler, implemented by the user </td></tr></tbody></table><br>  Each of these approaches has its own pros and cons, they are used for different tasks, in the context of which they respond to user requests. <br><br>  For example, in <a href="https://github.com/embox/embox">Embox</a> , we had an idea to implement our light threads that do not have their own stack, like protothread and tasklet, and will be managed by the main schedulers, as implemented in workqueue, and will also support the waiting mechanism in some form. events (even more so - use a subset of the same API that uses full-fledged threads).  This approach has several attractive applications for us: <br><ul><li>  Replacement delayed interrupt handling mechanism; </li><li>  Using only light streams in the scheduler will allow the use of almost full-fledged multitasking, even for resource-constrained embedded systems; </li><li>  The previous scenario is good for something else: when porting a system to a new processor architecture, you first want to get at least some workable system.  Implementing a full context_switch on a new assembler at this moment is an extra headache.  For the use of lightweight threads only, this is not required. </li></ul><br>  About how we did it, what results we have achieved, I will tell you next time, after a while. </div><p>Source: <a href="https://habr.com/ru/post/244361/">https://habr.com/ru/post/244361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244349/index.html">Relay with IR remote control at ATtiny13A</a></li>
<li><a href="../244353/index.html">Stanford Courses "iOS Application Development" - unauthorized lecture notes in Russian and 2015?</a></li>
<li><a href="../244355/index.html">Free programs for remote control of computers</a></li>
<li><a href="../244357/index.html">10 universal tips for visitors to any IT conference</a></li>
<li><a href="../244359/index.html">How we did the polar graph in DevExtreme</a></li>
<li><a href="../244363/index.html">Wind of Change: ARM Server Expansion Continues</a></li>
<li><a href="../244365/index.html">Integration of a computer information system into a business</a></li>
<li><a href="../244367/index.html">SSLR: Screen Space Local Reflections in AAA Games</a></li>
<li><a href="../244371/index.html">Unsuccessful experience in restoring pre-installed Windows 8.1 on an HP Pavilion laptop</a></li>
<li><a href="../244373/index.html">Raising the ‚Äúvirtualka‚Äù chroot with ubuntu to build packages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>