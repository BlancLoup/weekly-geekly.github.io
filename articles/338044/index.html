<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development for Sailfish OS: Using Sensors (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! This article is a continuation of a series of articles devoted to the development of applications for the Sailfish OS mobile platform. This art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development for Sailfish OS: Using Sensors (Part 1)</h1><div class="post__text post__text-html js-mediator-article">  Hello!  This article is a continuation of a series of articles devoted to the development of applications for the Sailfish OS mobile platform.  This article will discuss the use of sensor devices running Sailfish OS. <br><a name="habracut"></a><br>  This topic is quite extensive and we got a lot of material, so we decided to divide it into two parts for readability.  The second part is available <a href="https://habrahabr.ru/post/343530/">here</a> . <br><br><h2>  Foreword </h2><br>  Built-in sensors - this is the filling of the smartphone, which makes it smart.  Each smartphone is equipped with any sensors.  Moreover, the larger the sensor set of a smartphone, the wider its capabilities.  Naturally, smartphones running Sailfish OS are no exception. <br><br>  For most smartphone users, sensors only add convenience to everyday use, whether it is turning the screen while tilting the device or lowering the brightness while lowering the room illumination.  However, the sensors allow you to implement more serious ideas, including the creation of augmented and virtual reality.  We will not consider the use of sensors on such scales, of course, but we can give a fairly complete picture of their capabilities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Qt Sensors API Review </h2><br>  The toolkit for working with sensors on Sailfish OS is presented in the form of the Qt Sensors API, which provides both the native C ++ library and the interface for working directly from QML code. <br><br>  In order to use QML types from the Qt Sensors API, you need to add a dependency on the <i>qt5-qtdeclarative-import-sensors</i> plugin to the application project under Sailfish OS.  This is done by adding the name of the plug-in to the <i>Requires</i> section of the <i>project's</i> YAML file: <br><br><pre><code class="hljs python"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-comment"><span class="hljs-comment"># Runtime dependencies which are not automatically detected Requires: - sailfishsilica-qt5 &gt;= 0.10.9 - qt5-qtdeclarative-import-sensors ...</span></span></code> </pre> <br>  After plugging in, you need to import the <i>QtSensors</i> module version 5 and higher into the QML code.  At the time of writing, the most current version available on Sailfish OS is version 5.2.  It will be used in the examples: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtSensors 5.2</code> </pre><br>  If you plan to use the Sensors API directly in C ++ code, then you do not need to add dependency on the plugin.  Instead, you will need to specify the layout in the <i>.pro</i> file of the project using the <i>QtSensors</i> library.  This is done by adding a line to it: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">QT</span></span> += sensors</code> </pre><br>  After that, all API classes will be available for inclusion in the project, and it will be possible to import or the entire library at once: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtSensors&gt;</span></span></span></span></code> </pre><br>  Or only the necessary classes, for example, an accelerometer: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtSensors/QAccelerometer&gt;</span></span></span></span></code> </pre><br>  The set of available sensors primarily depends on the filling of the device.  For example, the INOI R7 smartphone has sensors for orientation, lighting, rotation, tilt, proximity, magnetic field strength, and an accelerometer. <br><br>  For Sailfish OS, working with sensors helps build the Qt Sensors API.  The set of sensors covered by this API is much broader than what is covered in this article. <br><br>  Each sensor is represented in Qt Sensors by two interfaces: the C ++ class and the QML type wrapping the corresponding C ++ class.  Both interfaces provide full access to the sensor functions, so which one will be used depends only on the desires and capabilities of the developer. <br><br>  First you should get a list of all sensors available on the device.  For this there is an element <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-sensorglobal.html">SensorGlobal</a></i> and its three methods: <br><br><ul><li>  <i>string defaultSensorForType (type)</i> ; </li><li>  <i>list &lt;string&gt; sensorTypes ()</i> ; </li><li>  <i>list &lt;string&gt; sensorsForType (type)</i> . </li></ul><br>  <i>sensorTypes</i> returns a list of all sensor types present on the device, while <i>sensorsForType</i> returns the registered identifiers for the specified sensor type.  <i>defaultSensorForType</i> , as the name implies, returns the identifier of the standard sensor for the specified type, that is, the one that will be used by the QML component, unless you explicitly specify the identifier. <br><br>  Analogs of the methods described above are also present in C ++.  They are the static functions of the <i><a href="http://doc.qt.io/qt-5/qsensor.html">QSensors</a></i> class: <br><br><ul><li>  <i>static QByteArray defaultSensorForType (const QByteArray &amp; type)</i> ; </li><li>  <i>static QList &lt;QByteArray&gt; sensorTypes ()</i> ; </li><li>  <i>static QList &lt;QByteArray&gt; sensorsForType (const QByteArray &amp; type)</i> . </li></ul><br>  Their purpose is fully consistent with the purpose of QML-methods with the appropriate names. <br><br>  Create a small application that displays a list of all the sensors of the device: <br><br><pre> <code class="hljs mel">Page { SilicaListView { header: PageHeader { title: <span class="hljs-string"><span class="hljs-string">"Available sensor types"</span></span> } anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> delegate: ListItem { Label { <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: modelData anchors.verticalCenter: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.verticalCenter x: Theme.horizontalPageMargin } } <span class="hljs-comment"><span class="hljs-comment">//       model: QmlSensors.sensorTypes() } }</span></span></code> </pre><br>  On the Jolla C, the <i>QmlSensors.sensorTypes ()</i> method returns the following list of sensors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9b/wq/jt/9bwqjt2d6gx-2ka29dldf8dnuk8.png"></div><br>  This means that the following set of sensors is available on the device: a light sensor, a proximity sensor, a tilt angle sensor, and an accelerometer. <br><br>  All classes that work with sensors are inherited from one common parent class <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-sensor.html">Sensor</a></i> .  This class is an abstract sensor, the properties and methods of which are applicable to all of its child classes: <br><br><ul><li>  <i>active</i> - a property that determines the activity of the sensor at the moment.  Assigning <i>true</i> to it is similar to calling the <i>start ()</i> method ‚Äî it starts reading values ‚Äã‚Äãfrom the sensor, if possible.  Assigning <i>false, on the</i> contrary, stops reading. </li><li>  <i>alwaysOn</i> is a property that determines the sensor activity when the screen is off. </li><li>  <i>axesOrientationMode</i> - determines how the position of the device affects the axis of measurement values.  By default, the axes are arranged as shown in the image: <div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/4e/17/qr4e17wrsw67ytzaxt_skk7axzy.jpeg"></div><br>  Three modes are available: <br><br><ul><li>  <i>FixedOrientation</i> - the axes always maintain their position relative to the device.  This value is standard and will be used if the device does not support changing the orientation mode of the axes. </li><li>  <i>AutomaticOrientation</i> - axes retain their position in space, changing position relative to the device.  In other words, the position of the device does not affect the values ‚Äã‚Äãof the sensors. </li><li>  <i>UserOrientation</i> - the position of the axes is set by the user. </li></ul></li><li>  <i>busy</i> is a property containing the busy state of the sensor.  If he is busy with another process, then it is impossible to use it. </li><li>  <i>dataRate</i> - contains the frequency of data exchange with the sensor, expressed in the number of operations per second. </li><li>  <i>error</i> - the code of the last error that occurred.  The property value is set automatically when an error occurs and cannot be changed manually. </li><li>  <i>reading</i> is a property containing <i>SensorReading</i> is a component that reads values ‚Äã‚Äãfrom sensors.  It is with its use that information is obtained from the sensors.  The value of this property is updated in accordance with the set exchange frequency; it cannot be recorded manually. </li><li>  <i>type</i> - string name of the sensor.  Set at the time the object is defined, cannot be changed. </li><li>  <i>description</i> - contains a string describing the sensor.  As <i>type</i> , it is set at the moment of definition of object, cannot be changed. </li><li>  <i>start ()</i> - starts reading values ‚Äã‚Äãfrom the sensor, equivalent to assigning the <i>true</i> value to the <i>active</i> property. </li><li>  <i>stop ()</i> - stops reading values ‚Äã‚Äãfrom the sensor, equivalent to assigning the <i>false</i> value to the <i>active</i> property. </li></ul><br>  Since <i>Sensor</i> is only an abstract type, it cannot be declared directly.  Instead, components inherited from it must be created that correspond to a specific type of sensor. <br><br>  An object of type <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-sensorreading.html">SensorReading</a></i> contained in the <i>reading</i> property deserves special attention, because it serves as the base type for all components that read values ‚Äã‚Äãfrom sensors.  The <i>value of the reading</i> property changes in accordance with the update frequency specified in the <i>dataRates</i> property, but only during those moments while the sensor is in active state.  If the sensor is not active, the <i>reading</i> contains the last measurements received, and on devices without the support of the corresponding sensor - <i>null</i> . <br><br>  By itself, <i>SensorReading</i> has only the <i>timestamp</i> property, which contains the time of the last receipt of information from the sensor, but its subclasses implement properties that directly provide values ‚Äã‚Äãfrom device sensors.  <i>SensorReading</i> , as well as its successors, cannot be declared directly.  The only way to obtain them is to access the reading property of the object that represents the corresponding sensor. <br><br><h2>  Accelerometer </h2><br>  Sailfish OS sensors can be started using the example of working with probably the most common sensor - an accelerometer.  The accelerometer, sometimes called the G-sensor, is found in almost all modern models of mobile devices.  A typical application for an accelerometer is to register the change in acceleration when the position of the smartphone changes, which is used to change the orientation of the image on the screen of the smartphone. <br><br>  So, to get measurements from the accelerometer, the first thing to do is to declare on the desired page and put the <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-accelerometer.html">Accelerometer</a></i> component into the active state, the hallmark of which from <i>Sensor</i> is the presence in the <i>type</i> property of the value <i><a href="http://doc.qt.io/qt-5/qaccelerometer.html">QAccelerometer</a></i> . <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Accelerometer</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: accelerometer active: true }</code> </pre><br>  Everything, the component is created and already makes reading of indications from the device accelerometer.  But now how can a developer get these same measurements?  Here we need to recall the <i>reading</i> property mentioned above.  This time it contains the AcrelerometerReading QML type - the successor to <i>SensorReading</i> , which, among other things, has acquired new properties: <i>x</i> , <i>y</i> and <i>z</i> .  They contain the linear acceleration of the device along the X, Y and Z axes, respectively.  Since we did not change the value of the <i>axesOrientationMode</i> , the position of the axes will remain standard, namely the one shown in the image below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/wo/0k/j_wo0kmual_vsa9ulgrumeryhxc.jpeg"></div><br>  We associate the acceleration values ‚Äã‚Äãalong the X and Y axes with the horizontal and vertical position of the image on the screen.  To do this, apply a transformation to the image that horizontally shifts it to the acceleration value along the X axis and vertically to the acceleration value along the Y axis. We also add a restriction on the permissible image position so that it does not go beyond the screen. <br><br><pre> <code class="hljs objectivec">Image { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: fruct source: <span class="hljs-string"><span class="hljs-string">"http://social.fruct.org/content/img/fruct.png"</span></span> transform: Translate { property <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> horizontalPosition: x - accelerometer.reading.x property <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> verticalPosititon: y + accelerometer.reading.y x: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontalPosition &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontalPosition &gt; page.width - fruct.width) { page.width - fruct.width } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { horizontalPosition } y: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (verticalPosititon &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (verticalPosititon &gt; page.height - fruct.height) { page.height - fruct.height } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { verticalPosititon } } }</code> </pre><br>  As a result, the FRUCT logo will move around the screen when the smartphone is tilted: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/vj/jm/gcvjjm_oetgljora-618ha54kmu.png"></div><br>  Another feature of the <i>Accelerometer</i> component that distinguishes it from the <i>Sensor</i> is the presence of the <i>accelerationMode</i> property, which controls how the acceleration sensor calculates its values.  In total there are three modes of calculation of acceleration: <br><br><ul><li>  <i>Accelerometer.Combined</i> - together taken into account the values ‚Äã‚Äãof acceleration caused by both gravity and the movement of the device by the user. </li><li>  <i>Accelerometer.Gravity</i> - only the acceleration value caused by gravity is taken into account.  The movement of the device by the user does not affect the values ‚Äã‚Äãreturned by the sensor, however, the angle of inclination of the device is taken into account. </li><li>  <i>Acceleration.User</i> - only the acceleration caused by the movement of the device by the user is taken into account, the acceleration values ‚Äã‚Äãcaused by gravity are not taken into account.  In this mode, when the device is stationary, the sensor value will be close to 0. </li></ul><br>  It is worth noting that not all devices and sensors support the ability to change the mode of calculation.  For devices that do not have this capability, the combined mode will be applied, and changing the value of the <i>accelerationMode</i> property will have no effect on the measurement. <br><br><h2>  Proximity sensor </h2><br>  The proximity sensor reacts to objects in close proximity without physical contact with them.  For example, the proximity sensor installed on a mobile phone allows you to turn off the touch screen sensor when the phone approaches the user's ear during a call or to put the device into sleep mode when you move it into your pocket.  From this it follows that the main task of the sensor is to block the screen of the device, thereby preventing the user from accidentally pressing a button or performing an unplanned action.  Typically, such a sensor is located on the front of the device on top.  Svid he looks a bit like a hole under the front camera. <br><br>  The proximity sensor in QML is represented by the <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-proximitysensor.html">ProximitySensor</a></i> component.  There is not much to write about it, because its only difference from the parent component is the presence of the <i>near</i> property of the corresponding <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-proximityreading.html">ProximityReading</a></i> QML type.  This property is <i>true</i> if any object is located close enough to the sensor. <br><br>  Having determined the required component, you can add a signal handler to change the value of the near property, and in it you can perform the required actions.  For example, when an object approaches a sensor, it is possible to minimize applications or do something really useful - this already depends on the developer‚Äôs imagination: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ProximitySensor</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: proximitySensor active: true } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Connections</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">target</span></span>: proximitySensor.reading onNearChanged: proximitySensor.reading.near ? appWindow.<span class="hljs-built_in"><span class="hljs-built_in">deactivate</span></span>() : appWindow.<span class="hljs-built_in"><span class="hljs-built_in">activate</span></span>() }</code> </pre><br><h2>  Light sensor </h2><br>  The light sensor is one of the oldest sensors in the world of mobile devices.  His task is to measure the level of illumination of the situation in which the smartphone is used.  These measurements are used by the smartphone software to adjust the screen brightness: in low light, the brightness decreases, thereby reducing the user's eye load and keeping the battery charge, and on a clear day, it turns out to the maximum so that the text on the screen can be at least somehow to distinguish. <br><br>  QML-type <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-lightsensor.html">LightSensor</a></i> provides an API to get the level of illumination in lux, which can be used to adjust the parameters of the application, including the screen brightness.  And although Sailfish OS already has built-in software to automatically adjust the screen backlight level, this does not prevent developers from adjusting it to their applications. <br><br>  The component for obtaining sensor readings can also be obtained from the <i>reading</i> property.  This time it contains a <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-lightreading.html">LightReading</a></i> object, which has the <i>illuminance</i> property ‚Äî it contains the luminance values.  Using the light sensor in conjunction with the <i><a href="https://github.com/nemomobile/nemo-qml-plugin-systemsettings">nemo-qml-plugin-systemsettings plugin, you</a></i> can achieve an automatically controlled brightness level that is appropriate for your application.  Simply link the <i>LightSensor</i> readings to the <i>brightness</i> property of the <i>DisplaySettings</i> component, set limits on the values ‚Äã‚Äãtaken, and the brightness level will adapt to your desired limits.  Also, you should first set the <i>autoBrightnessEnabled</i> property to <i>false</i> to disable the automatic adjustment of the brightness level by the operating system. <br><br><pre> <code class="hljs objectivec">import org.nemomobile.systemsettings <span class="hljs-number"><span class="hljs-number">1.0</span></span> Page { LightSensor { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: lightSensor active: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } DisplaySettings { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: display autoBrightnessEnabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span> brightness: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lightSensor.reading.illuminance &lt; <span class="hljs-number"><span class="hljs-number">50</span></span> ) { <span class="hljs-number"><span class="hljs-number">50</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lightSensor.reading.illuminance &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lightSensor.reading.illuminance } } }</code> </pre><br>  In addition, <i>LightSensor</i> provides information about the angle of view of the sensor.  You can get it by accessing the <i>fieldOfView</i> property.  This functionality is available though not on all devices, and if the <i>fieldOfView</i> contains 0, then, alas, the sensor used does not support this function. <br><br>  Sailfish OS also has another component for measuring the level of illumination - <i><a href="http://doc.qt.io/qt-5/qml-qtsensors-ambientlightsensor.html">AmbientLightSensor</a></i> .  Its functionality is almost completely similar to the previous sensor, but instead of the luminance value in lux, it returns the previously designated constants from the following list: <br><br><ul><li>  <i>AmbientLightReading.Undefined</i> - the light level cannot be recognized, </li><li>  <i>AmbientLightReading.Dark</i> - dark, </li><li>  <i>AmbientLightReading.Twilight</i> - moderately dark </li><li>  <i>AmbientLightReading.Light</i> - in a lit room, </li><li>  <i>AmbientLightReading.Bright</i> - in the shade on a clear day, </li><li>  <i>AmbientLightReading.Sunny</i> - under direct sunlight. </li></ul><br>  Thus, this component is advisable to use when the exact values ‚Äã‚Äãof the level of illumination are redundant, and the approximate will be enough.  For example, you can create a reader that goes into the ‚Äúnight‚Äù mode in low light. <br><br>  First, as usual, the component of the sensor is determined: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">AmbientLightSensor</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: ambientLightSensor active: true }</code> </pre><br>  Creates a background and text with the original color settings: <br><br><pre> <code class="hljs mel">Rectangle { id: background anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> Label { id: <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">"     ,   "</span></span> anchors { fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> leftMargin: Theme.horizontalPageMargin rightMargin: Theme.horizontalPageMargin } wrapMode: Text.WordWrap <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> } }</code> </pre><br>  Well, at the end is set a set of states and transitions that will be applied to objects on the screen.  The condition for the change of states is just the low value of the light sensor: <br><br><pre> <code class="hljs mel">states: State { name: <span class="hljs-string"><span class="hljs-string">"dark"</span></span> PropertyChanges { target: <span class="hljs-keyword"><span class="hljs-keyword">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> } PropertyChanges { target: background <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> } when: ambientLightSensor.reading.lightLevel === AmbientLightReading.Dark } transitions: Transition { to: <span class="hljs-string"><span class="hljs-string">"dark"</span></span> reversible: true ColorAnimation { duration: <span class="hljs-number"><span class="hljs-number">200</span></span> } }</code> </pre><br>  In low light, the screen on the left will smoothly switch to the ‚Äúnight‚Äù version on the right: <br><table><tbody><tr><td align="center"><img src="https://habrastorage.org/webt/mv/sr/tm/mvsrtmp4gjgmv4wiu1xuc6bljss.png"><br></td><td align="center"><img src="https://habrastorage.org/webt/a1/dz/cl/a1dzclo7cidr_eygrfcmjuc4utc.png"><br></td></tr></tbody></table><br><h2>  Conclusion </h2><br>  This article is only the first part, in the <a href="https://habrahabr.ru/post/343530/">second part</a> we continue to consider the main sensors available on the Sailfish OS operating system. <br><br>  Technical issues can also be discussed on <a href="https://telegram.me/joinchat/CXsImAqrzbAnSZXtAaf-0g">the Sailfish OS Russian-speaking community channel in a Telegram</a> or <a href="https://vk.com/merproject">VKontakte group</a> . <br><br>  Posted by: Maxim Kosterin </div><p>Source: <a href="https://habr.com/ru/post/338044/">https://habr.com/ru/post/338044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338028/index.html">New series of webinars on the SAP Cloud Platform: development, integration, mobile applications and much more for the month</a></li>
<li><a href="../338032/index.html">Jenkins Pipeline Shared Libraries</a></li>
<li><a href="../338036/index.html">A good designer copies other people's logos, great - steals.</a></li>
<li><a href="../338038/index.html">Farm management for Android devices. Lecture in Yandex</a></li>
<li><a href="../338040/index.html">The evolution of cross-platform development: the pros and cons of Xamarin</a></li>
<li><a href="../338046/index.html">Analysis of the article ‚ÄúChief, I want to work from home‚Äù</a></li>
<li><a href="../338048/index.html">Welcome to Android Devs Meetup September 22</a></li>
<li><a href="../338050/index.html">Security Week 37: Together we turn off Bluetooth, a hole in Tor for a million, botnets on Elasticsearch servers</a></li>
<li><a href="../338052/index.html">Magento updates, Protection against harmful administrators, data leaks, code execution</a></li>
<li><a href="../338054/index.html">Nobody needs your software. Or why software development requires a fresh approach.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>