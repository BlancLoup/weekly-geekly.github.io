<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making multiplayer games on Go and WebSocket</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing familiarity with the programming language Go (golang). Last time we looked at the basic constructs of the language. In this article I want ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making multiplayer games on Go and WebSocket</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/ff0/239/e8dff023919e1671b1910ce50dbb29c8.jpg" width="200" alt="golang gopher" align="left"><br>  Continuing <a href="http://habrahabr.ru/post/219459/">familiarity</a> with the programming language Go (golang).  Last time we looked at the basic constructs of the language.  In this article I want to show the use of gorutin and channels.  And, of course, to demonstrate all of this on a real application, in this case a multiplayer game.  We will not consider the whole game, but only that part of the backend, which is responsible for the network interaction between players through the WebSoket. <br><br>  Turn-based game for two players.  However, the techniques described below can be used to create other games, from poker to strategies. <br><a name="habracut"></a><br>  By the way, this is my first game and the first work with WebSoket, so do not judge strictly.  If you have comments and reasonable criticism, I will listen with pleasure. <br><br>  The algorithm is as follows.  Players connect to the game room (room).  Upon receipt of a new move from the player, the room is notified of this (via the channel) and will trigger a special method ‚Äúupdate game state‚Äù on all players registered in the room.  It's pretty simple. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Schematically, this can be represented as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/4f6/b2f/59c4f6b2f6eac2f5c076e830b9067daf.jpg" width="300"></div><br><br>  Communication with the player takes place through the ‚Äúconnection‚Äù layer object (in Fig. PConn1, pConn2), which expands the Player type (by embedding it in itself) and adds methods for communication. <br><br>  By the way, I will sometimes use the word ‚Äúobject‚Äù as a designation of a certain entity, and not in the sense of the object OOP (since they differ slightly in go). <br><br>  Consider the project structure: <br><br><pre><code class="go hljs">/wsgame/ /game/ game.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> /templates/ /utils/ utils.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> conn.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> room.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre> <br><br>  In the root files (main package) our network interaction is implemented. <br>  In the package / game / is the game engine itself.  We will not consider it, here I will give only a few methods, in the form of mocks, which are needed to control the game. <br><br><h4>  A game </h4><br>  <b>/game/game.go</b> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> game <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Player <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Enemy *Player } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewPlayer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player</span></span></span></span> { player := &amp;Player{Name: name} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> player } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PairPlayers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1 *Player, p2 *Player)</span></span></span></span> { p1.Enemy, p2.Enemy = p2, p1 } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Player)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(command </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { log.Print(<span class="hljs-string"><span class="hljs-string">"Command: '"</span></span>, command, <span class="hljs-string"><span class="hljs-string">"' received by player: "</span></span>, p.Name) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Player)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Game state for Player: "</span></span> + p.Name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *Player)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GiveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Print(<span class="hljs-string"><span class="hljs-string">"Player gave up: "</span></span>, p.Name) }</code> </pre><br><br>  The player (Player) has an enemy, the same player (in our structure this is the * Player pointer).  To connect players is the function PairPlayers.  Further, here are some of the features needed to control the game.  Here they do nothing, just display a message in the console.  Command - send a command (make a move);  GetState - get the current state of the game for this player;  GiveUp - surrender and assign the victory to the enemy. <br><br>  UPD: It later turned out that having only one Player structure for the game is not very convenient.  It is better to make the structure of the Game to which to connect players.  But that's another story. <br><br><h4>  Main </h4><br>  <b>main.go</b> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/alehano/wsgame/game"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/websocket"</span></span> <span class="hljs-string"><span class="hljs-string">"html/template"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/url"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( ADDR <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">":8080"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">homeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> homeTempl = template.Must(template.ParseFiles(<span class="hljs-string"><span class="hljs-string">"templates/home.html"</span></span>)) data := <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Host <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> RoomsCount <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }{r.Host, roomsCount} homeTempl.Execute(c, data) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wsHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { ws, err := websocket.Upgrade(w, r, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, ok := err.(websocket.HandshakeError); ok { http.Error(w, <span class="hljs-string"><span class="hljs-string">"Not a websocket handshake"</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } playerName := <span class="hljs-string"><span class="hljs-string">"Player"</span></span> params, _ := url.ParseQuery(r.URL.RawQuery) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(params[<span class="hljs-string"><span class="hljs-string">"name"</span></span>]) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { playerName = params[<span class="hljs-string"><span class="hljs-string">"name"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] } <span class="hljs-comment"><span class="hljs-comment">// Get or create a room var room *room if len(freeRooms) &gt; 0 { for _, r := range freeRooms { room = r break } } else { room = NewRoom("") } // Create Player and Conn player := game.NewPlayer(playerName) pConn := NewPlayerConn(ws, player, room) // Join Player to room room.join &lt;- pConn log.Printf("Player: %s has joined to room: %s", pConn.Name, room.name) } func main() { http.HandleFunc("/", homeHandler) http.HandleFunc("/ws", wsHandler) http.HandleFunc("/static/", func(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, r.URL.Path[1:]) }) if err := http.ListenAndServe(ADDR, nil); err != nil { log.Fatal("ListenAndServe:", err) } }</span></span></code> </pre><br><br>  This entry point into the program.  The main () function starts the server and registers two handlers: the homeHandler for the main page, which only displays the home.html template and the more interesting wsHandler, which establishes the WebSocket connection and registers the player. <br><br>  For WebSocket, we use a package from the Gorilla Toolkit ("github.com/gorilla/websocket").  In the beginning we create a new connection (ws).  Next, we get the player name from the URL parameter.  Then, look for a free room (with one player).  If there is no room, then create it.  After that, we create a player and a connection object for the player (pConn).  We transfer our web socket, player and room to the connection.  More precisely, we transfer pointers to these objects.  And the last step is connecting our connection to the room.  This is done by sending our object to the channel join room. <br><br><h5>  Gorutiny and channels </h5><br>  A small educational program about Gorutin and channels.  Gorutinas are something like threads, they are executed in parallel.  It is enough to put the go operator before calling the function and the program will not wait until the function is completed, but will immediately go on to the next instruction.  Gorutin are very lightweight, not demanding of memory.  Communication with gorutiny occurs through the channels - a special type of data.  Channels are like pipe in Unix.  You can think of channels as a pipe: we put something at one end, we get something from the other.  Channel type can be any.  For example, you can create a string channel and send messages to it.  It is even possible to create a channel of channels.  We need to go deeper. <br><br>  A small example.  You can run here <a href="http://play.golang.org/p/QUc458nBJY">http://play.golang.org/p/QUc458nBJY</a> <br>  Imagine that you want to send the same request to multiple servers and get an answer from someone who responds faster.  And do not want to wait for the rest.  You can do it like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resultCh </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, serverName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { resultCh &lt;- <span class="hljs-string"><span class="hljs-string">"Data from server: "</span></span> + serverName } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { res := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> getDataFromServer(res, <span class="hljs-string"><span class="hljs-string">"Server1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> getDataFromServer(res, <span class="hljs-string"><span class="hljs-string">"Server2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> getDataFromServer(res, <span class="hljs-string"><span class="hljs-string">"Server3"</span></span>) data := &lt;- res fmt.Println(data) }</code> </pre><br>  We create a res channel, where we will receive a response.  And then, in separate gorutinakh, we start requests to servers.  The operation is not blocking, so after the line with the go operator the program goes to the next line.  Dalle, the program is blocked on the line <code>data := &lt;- res</code> , waiting for a response from the channel.  As soon as the answer is received, we display it on the screen and the program ends.  In this synthetic example, the response from Server1 will be returned.  But in life, when the execution of the request may take different times, the response from the fastest server will be returned. <br><br>  UPD: The number 3 in the creation of the channel, indicates that the channel is buffered, size 3. This means that when you send to the channel (if there are free places), you do not have to wait until someone receives the data.  In this case, this could not be done, because  the program ends anyway.  But, if it was, for example, a website that runs all the time, and the channel would not be buffered, two of the three Gorutin would hang, waiting for reception at the other end. <br><br>  So back to our sheep. <br><br><h4>  Compound </h4><br>  <b>conn.go</b> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/alehano/wsgame/game"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/websocket"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> playerConn <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ws *websocket.Conn *game.Player room *room } <span class="hljs-comment"><span class="hljs-comment">// Receive msg from ws in goroutine func (pc *playerConn) receiver() { for { _, command, err := pc.ws.ReadMessage() if err != nil { break } // execute a command pc.Command(string(command)) // update all conn pc.room.updateAll &lt;- true } pc.room.leave &lt;- pc pc.ws.Close() } func (pc *playerConn) sendState() { go func() { msg := pc.GetState() err := pc.ws.WriteMessage(websocket.TextMessage, []byte(msg)) if err != nil { pc.room.leave &lt;- pc pc.ws.Close() } }() } func NewPlayerConn(ws *websocket.Conn, player *game.Player, room *room) *playerConn { pc := &amp;playerConn{ws, player, room} go pc.receiver() return pc }</span></span></code> </pre><br><br>  What is the interlayer connection?  This is a playerConn object that contains pointers: to the web socket, to the player, and to the room.  In the case of a player, we wrote just * game.Player.  This means that we ‚Äúembed‚Äù Player and can call its methods directly on playerConn.  Something like inheritance.  When creating a new connection (NewPlayerConn), the receiver method is launched in a separate gorutin (go operator), i.e.  in parallel (not blocking manner) and in an infinite loop, listens to a web socket for messages.  When received, it is passed to the player in the Command method (make a move).  And then he sends a signal to the room to ‚Äúupdate the state of the game for all players.‚Äù  When an error occurs (for example, breaking a web socket), the gorutin exits the loop, sends a ‚Äúgive up‚Äù signal to the room‚Äôs channel, closes the web socket and ends. <br>  With the sendState () method we send the current state of the game to this player. <br><br><h4>  Room </h4><br>  <b>room.go</b> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/alehano/wsgame/game"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/alehano/wsgame/utils"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> allRooms = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*room) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> freeRooms = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*room) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> roomsCount <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> room <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">// Registered connections. playerConns map[*playerConn]bool // Update state for all conn. updateAll chan bool // Register requests from the connections. join chan *playerConn // Unregister requests from connections. leave chan *playerConn } // Run the room in goroutine func (r *room) run() { for { select { case c := &lt;-r.join: r.playerConns[c] = true r.updateAllPlayers() // if room is full - delete from freeRooms if len(r.playerConns) == 2 { delete(freeRooms, r.name) // pair players var p []*game.Player for k, _ := range r.playerConns { p = append(p, k.Player) } game.PairPlayers(p[0], p[1]) } case c := &lt;-r.leave: c.GiveUp() r.updateAllPlayers() delete(r.playerConns, c) if len(r.playerConns) == 0 { goto Exit } case &lt;-r.updateAll: r.updateAllPlayers() } } Exit: // delete room delete(allRooms, r.name) delete(freeRooms, r.name) roomsCount -= 1 log.Print("Room closed:", r.name) } func (r *room) updateAllPlayers() { for c := range r.playerConns { c.sendState() } } func NewRoom(name string) *room { if name == "" { name = utils.RandString(16) } room := &amp;room{ name: name, playerConns: make(map[*playerConn]bool), updateAll: make(chan bool), join: make(chan *playerConn), leave: make(chan *playerConn), } allRooms[name] = room freeRooms[name] = room // run room go room.run() roomsCount += 1 return room }</span></span></code> </pre><br><br>  The last part is the room.  We create several global variables: allRooms - a list of all created rooms, freeRooms - rooms with one player (in theory, there should not be more than one), roomsCount - a counter of working rooms. <br><br>  The room object contains the name of the room, playerConns - a list of connected connections (players) and several channels to control.  Channels can have a different type, this is something that can be sent to a channel and received from it.  For example, the updateAll channel contains a boolean value and serves only to indicate whether the game state should be updated.  It doesn‚Äôt matter to us that it is transmitted to us, we only react to its activation.  True, it is considered good practice to use an empty struct {} structure in this case.  But a specific connection is transmitted to the join channel (more precisely, a pointer to it).  We save it in our room in playerConns as the key of the map structure. <br><br>  When creating a new room with NewRoom (), we initialize the channels and run the run () method in the mountain (go room.run ()).  It performs an infinite loop that listens to several channels at the same time and, upon receiving a message in any of them, performs certain actions.  Listening to several channels is implemented using the select-case construct.  In this case, the operation is blocking.  Those.  we will wait until there is a message from any channel, then we move on to the next iteration of the cycle and wait again.  But, if the default: section had the select: construct, then the operation would be non-blocking, and if there were no messages, the default block would be executed, and then exit from the select.  In this case, it is meaningless, but there is such a possibility. <br><br>  If the join channel works, we register the connection (player) in the room.  If the second player connects, we ‚Äúpair‚Äù the players and remove the room from the free list.  When leave is triggered, we delete the connection, and execute the ‚Äúsurrender‚Äù method of the player.  And if there are no len (r.playerConns) == 0 players left in the room, then we generally close the room by exiting the loop (goto Exit).  Yes, the go language has a goto instruction.  But do not worry, it is used very rarely, and only to exit from structures of type for or select.  For example, to exit a nested loop.  In this case, if you set a break, it will interrupt the select construct, not the for loop. <br><br>  And finally, when the updateAll channel triggers (the transmitted value is not important to us, so we do not save it anywhere: case &lt;-r.updateAll), all players registered in the room are called ‚Äúupdate game state‚Äù. <br><br>  That's the whole network part.  In a real project, it became a bit more complicated.  The channels responsible for the chat and the timer were added, as well as a certain structure of the request-response (on the basis of JSON). <br><br>  Having such a backend, it is quite simple to make clients on different devices.  I decided to make a client on HTML5 for cross-platform.  Although, in iOS, the game constantly crashes.  It can be seen that websocket support is not fully implemented. <br><br>  Thanks for attention.  Program on Go, it's fun. <br><br>  <b>References:</b> <br><ul><li>  Files on GitHub and game demos: <a href="https://github.com/alehano/wsgame">https://github.com/alehano/wsgame</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/226469/">https://habr.com/ru/post/226469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226455/index.html">Thank you cards darudar - our way of monetization</a></li>
<li><a href="../226459/index.html">Welcome to the digital detox camp! No phones!</a></li>
<li><a href="../226461/index.html">How to become a good programmer?</a></li>
<li><a href="../226465/index.html">10 main conclusions that I made during the Year of Productivity Studies</a></li>
<li><a href="../226467/index.html">Stories that taught you a lot - habra competition</a></li>
<li><a href="../226471/index.html">How to reduce critical system downtime</a></li>
<li><a href="../226473/index.html">Self-Service with Cisco UCS Director: How to enable users to independently create virtual servers</a></li>
<li><a href="../226477/index.html">The price of 3D printing, and how to independently calculate the cost of 3D printing</a></li>
<li><a href="../226479/index.html">Blackphone, protected from listening to the smartphone, will go on sale in July</a></li>
<li><a href="../226481/index.html">Restoring a PostgreSQL database from a WAL backup with skipping part of records</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>