<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a procedural puzzle generator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post describes the level generator for my Linjat puzzle game . Fasting can be read without preparation, but it is easier to learn if you play in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a procedural puzzle generator</h1><div class="post__text post__text-html js-mediator-article"> This post describes the level generator for my <a href="https://linjat.snellman.net/">Linjat</a> puzzle <a href="https://linjat.snellman.net/">game</a> .  Fasting can be read without preparation, but it is easier to learn if you play in several levels.  I <a href="https://github.com/jsnell/linjat/">posted the</a> source code <a href="https://github.com/jsnell/linjat/">on github</a> ;  Everything discussed in the article is in the <code>src/main.cc</code> . <br><br>  Approximate plan of the post: <br><br><ul><li>  Linjat is a logic game in which you need to close all the numbers and points in the grid with lines. </li><li>  Puzzles are procedurally generated using a combination of solver, generator and optimizer. </li><li>  Solver tries to solve the puzzles the way a person would do it, and assigns an interesting score to each puzzle. </li><li>  The puzzle generator is created in such a way that it is easy to change one part of the puzzle (number) and at the same time all other parts (points) change so that the puzzle remains solvable. </li><li>  The puzzle optimizer repeatedly solves levels and generates new variations from the most interesting ones found so far. </li></ul><br><h3>  rules </h3><br>  To understand how the level generator works, you need to, unfortunately, deal with the rules of the game.  Fortunately, they are very simple.  A puzzle consists of a grid containing empty squares, numbers and points.  Example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  The goal of the player is to draw a vertical or horizontal line through each of the numbers, subject to three conditions: <br><br><ul><li>  The line through the number must be the same length as the number. </li><li>  Lines can not intersect. </li><li>  All points must be closed lines. </li></ul><br>  Solution example: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Hooray!  The game design is ready, the UI is implemented, and now the only thing left is to find a few hundred good puzzles.  And for such games, it usually does not make sense to try to create such puzzles manually.  This is a job for the computer. <br><a name="habracut"></a><br><h3>  Requirements </h3><br>  What makes the puzzle for this game good?  I am inclined to believe that puzzle games can be divided into two categories.  There are games in which you explore a complex state space from start to finish (for example, <a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban</a> or <a href="https://en.wikipedia.org/wiki/Rush_Hour_(puzzle)">Rush Hour</a> ), and in which it may not be obvious what conditions exist in the game.  And there are games in which all the states are known from the very beginning, and we gradually sculpt the state space using the process of eliminating the excess (for example, <a href="https://en.wikipedia.org/wiki/Sudoku">Sudoku</a> or <a href="https://en.wikipedia.org/wiki/Nonogram">Picross</a> ).  My game definitely belongs to the second category. <br><br>  Players have very different requirements for these different types of puzzles.  In the second case, they expect that the puzzle can only be solved by deduction, and that they will never need to go back / guess the trial and error process <sup>[0]</sup> <sup>[1]</sup> . <br><br>  It is not enough to know whether the puzzle can be solved only by logic.  In addition, we need to somehow understand how good the puzzles are.  Otherwise, most levels will be just a trivial slag.  In an ideal situation, this principle could also be used to create a smooth progress curve so that when a player passes the game, the levels gradually become more difficult. <br><br><h3>  Solver </h3><br>  The first step to meeting these requirements is to create a game solver optimized for this purpose.  Solver rough backtracking allows you to quickly and accurately determine whether a puzzle is solvable;  in addition, it can be modified to determine whether a solution is unique.  But he cannot give an idea of ‚Äã‚Äãhow difficult the puzzle really is, because people solve them differently.  Solver should imitate human behavior. <br><br>  How does a person solve this puzzle?  Here are a couple of obvious moves that the in-game tutorial teaches: <br><br><ul><li>  If a point can be reached with only one number, then to close the point you need to draw a line out of this number.  In this example, the point can be reached only from the triple, but not from the four: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  And this leads to this situation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  If the line does not fit in one direction, then it must be placed in another.  In the example shown above, the four can no longer be placed vertically, so we know that it will be horizontal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  If it is known that a line of length X must be in a certain position (vertical / horizontal) and not enough empty space to place a line of X empty cells on both sides, then it is necessary to cover several squares in the middle.  If in the example shown above, the four were a troika, we would not know whether it stretches all the way to the right or left.  But we would know that the line should cover two middle squares: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Such reasoning is the very basis of the game.  The player looks for ways to stretch a little one line, and then studies the field again, because it can give him the information to make another logical conclusion.  Creating a solver following these rules will be enough to determine <i>if a</i> person can solve a puzzle without going back. <br><br>  However, this does not tell us anything about the complexity or interestingness of the level.  In addition to deciding, we somehow need to numerically estimate the complexity. <br><br>  An obvious first idea for the evaluation function: the more moves you need to solve a puzzle, the more difficult it is.  This is probably a good metric in other games, but my most likely more important is the number of permissible moves that the player has.  If a player can make 10 logical conclusions, he will most likely find one of them very quickly.  If the right move is only one, then it will take more time. <br><br>  That is, as a first approximation, we need the decision tree to be deep and narrow: there is a long dependence of the moves from beginning to end, and at each point in time there are only a small number of ways to move up the chain <sup>[2]</sup> . <br><br>  How do we determine the width and depth of a tree?  A one-time solution of the puzzle and evaluation of the created tree will not give an exact answer.  The exact order of the moves made affects the shape of the tree.  We need to consider all possible solutions and do something like optimization for them in the best and worst cases.  I am familiar with the technique of <a href="https://www.snellman.net/blog/archive/2018-07-23-optimizing-breadth-first-search/">rough search of search graphs in puzzle games</a> , but for this project I wanted to create a one-pass solver, and not some kind of exhaustive search.  Due to the optimization phase, I tried to ensure that the execution time of the solver was measured not in seconds, but in milliseconds. <br><br>  I decided not to.  Instead, my solver doesn‚Äôt actually make one move at a time, but solves the puzzle in layers: by taking a state, it finds all valid moves that can be made.  Then he applies all these moves at the same time and starts anew in the new state.  The number of layers and the maximum number of moves found on one layer are then used as approximate values ‚Äã‚Äãof the depth and width of the search tree as a whole. <br><br>  Here is how with this model the solution to one of the difficult puzzles looks.  Dotted lines are lines stretched on this layer of the solver, solid lines are those that have not changed.  The green lines are the correct length, the red lines are not yet complete. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  The next problem is that all the moves made by the player are created equal.  What we listed at the beginning of this section is just common sense.  Here is an example of a more complex deduction rule, the search for which will require a little more thought.  Consider this field: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Points in C and D can only be covered with a top five and a middle four (and no number can cover both points at the same time).  This means that the four in the middle must cover one point of two, and therefore cannot be used to cover A. Therefore, point A must close the four in the lower left corner. <br><br>  Obviously, it would be foolish to consider this chain of reasoning as equal to the simple conclusion "this point can be reached only from this number."  Is it possible in the evaluation function to give these more complex rules more weight?  Unfortunately, in the layer-based solver this is impossible, because it does not guarantee finding a solution with the lowest cost.  This is not only a theoretical problem - in practice it is often the case that a part of a field is solved either by a single complicated argument or by a chain of much simpler moves.  In fact, a layer-based solver finds the shortest, and not the least costly way, and this cannot be reflected in the evaluation function. <br><br>  As a result, I came to this decision: I changed the solver so that each layer consisted of only one type of reasoning.  The algorithm bypasses the rules of reasoning in an approximate order of complexity.  If a rule finds any moves, they are applied, and this completes the iteration, and the next iteration starts the list from the very beginning. <br><br>  Then the assessment is assigned to the decision: each layer is assigned costs based on one rule that was used in it.  It still does not guarantee that the solution will be the most low-cost, but with the correct selection of weights, the algorithm will at least not find a costly solution if there is a cheap one. <br><br>  In addition, it is very much like how people solve puzzles.  They first try to find easy solutions, and begin to actively move their brains only if there are no simple moves. <br><br><h3>  Generator </h3><br>  The previous section determined whether a particular level was good or bad.  But this is not enough, we still need to somehow generate levels so that the solver can evaluate them.  It is very unlikely that a randomly generated world will be solvable, let alone interesting. <br><br>  The basic idea (it is by no means new) is the alternate use of a solver and a generator.  Let's start with a puzzle, which is probably unsolvable: we just place in the random squares of the cell the number from two to five: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  Solver works until he can further develop: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Then the generator adds more information in the puzzle in the form of a dot, after which the execution of the solver continues. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  In this case, the added point of the solver is not enough for further development.  Then the generator will continue to add new points until it satisfies the solver: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  And then the solver continues his usual work: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  This process continues either until the puzzle is solved, or until there is more information to add (for example, when each cell that can be reached from a number already contains a point). <br><br>  This method only works if the added new information cannot invalidate any of the previously made conclusions.  This would be difficult to do when adding numbers to the grid <sup>[3]</sup> .  But adding new points to the field has this property;  at least for the reasoning rules that I use in this program. <br><br>  Where should the algorithm add points?  In the end, I decided to add them to the empty space, which can be closed in the initial state with the greatest number of lines, so that each point would try to provide as little information as possible.  I did not specifically try to place a point in the place where it would be useful to advance in solving the puzzle at the time when the solver gets stuck.  This creates a very convenient effect: most of the points seem to be completely useless at the beginning of the puzzle, which makes the puzzle more difficult than it actually is.  If all this is a set of obvious moves that a player can make, but for some reason not one of them fails to work properly.  The result is that the puzzle generator behaves a bit piggy. <br><br>  This process does not always create a solution, but it is quite fast (about 50-100 milliseconds), so to generate a level, you can simply repeat it several times.  Unfortunately, he usually creates mediocre puzzles.  From the very beginning, there are too many obvious moves, the field fills up very quickly and the decision tree turns out to be rather shallow. <br><br><h3>  Optimizer </h3><br>  The process described above created mediocre puzzles.  In the final step, I use these levels as the basis for the optimization process.  It works as follows. <br><br>  The optimizer creates a pool that contains up to 10 puzzle options.  The pool is initialized by a newly generated random puzzle.  At each iteration, the optimizer selects one puzzle from the pool and performs its mutation. <br><br>  A mutation removes all points, and then slightly changes the numbers (ie, decreases / increases the value of a randomly selected number or moves the number to another cell of the grid).  You can apply multiple mutations to a field at the same time.  Then we run the solver in the special level generation mode described in the previous section.  He adds a sufficient number of points to the puzzle so that it becomes solvable again. <br><br>  After that, we start the solver again, this time in normal mode.  During this run, the solver tracks a) the depth of the decision tree, b) the frequency of the need for different kinds of rules, c) the width of the decision tree at different points in time.  The puzzle is evaluated based on the criteria described above.  The evaluation function prefers deep and narrow solutions, and levels of increased complexity also give more weight to puzzles that require the use of more complex reasoning rules. <br><br>  Then a new puzzle is added to the pool.  If the pool contains more than 10 puzzles, the worst is discarded. <br><br>  This process is repeated several times (I was satisfied with approximately 10,000-50000 iterations).  After that, the version of the puzzle with the highest score is saved to the database of puzzle levels.  Here is how the progress of the best puzzle looks during one optimization run: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  I tried using other ways to structure optimization.  In one version, annealing imitation was used; others were genetic algorithms with various crossover operations.  None of the solutions proved to be as good as a naive algorithm with a pool of options going to the top. <br><br><h3>  Unique unique solution </h3><br>  When a puzzle has a unique unique solution, an interesting difficulty arises.  Is it possible to allow the player to assume that the decision is one and draw conclusions based on this?  Will it be fair if the puzzle generator assumes that the player will do just that? <br><br>  In a post on HackerNews, I said that there are four possible approaches to this situation: <br><br><ul><li>  Declare the uniqueness of the solution from the very beginning and force the generator to create levels that require this type of reasoning.  This is a bad decision, because it complicates the understanding of the rules.  And usually these are the details people forget. </li><li>  Do not guarantee the uniqueness of the decision: potentially have a lot of decisions and make them all.  In fact, it does not solve the problem, but pushes it away. </li><li>  Just assume that this is a very rare event that is not important in practice.  (This is the solution that was used in the initial implementation.) </li><li>  Modify the puzzle generator so that it does not generate puzzles in which knowledge of the uniqueness of the solution would help.  (Probably the right decision, but requiring additional work.) </li></ul><br>  Initially, I chose the latter option, and it was a terrible mistake.  It turned out that I took into account only one way in which the uniqueness of the solution led to information leakage, and it is actually quite rare.  But there are others;  one of them was essentially present in every level that I generated and often led to the decision becoming trivial.  Therefore, in May 2019, I changed the Hard and Expert modes using the third option. <br><br>  The most annoying case is the deuce with a dotted line in this field: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Why can a sly player make such a conclusion?  Deuce can cover any of the four adjacent squares.  There are no dots in any of them, so they do not have to be closed by a line.  And the square below has no overlaps with any other numbers.  If there is a unique solution, then this should be the case when other numbers cover the remaining three squares, and the two close the square under it. <br><br>  The solution is to add a few more points when recognizing such cases: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Another common case is the two with a dotted line in this field: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  The squares on the left and on top of the two are no different.  None of them has a point, and none can be reached from any other number.  Any solution in which the mark of two closes the upper square will have a corresponding solution in which it covers the left square, and vice versa.  If there was a unique unique solution, then this could not be, and the two should have covered the bottom square. <br><br>  I decided to use this type of cases in the way ‚Äúif it hurts, then don't touch‚Äù.  Solver applied this rule at an early stage in the list of priorities and assigned a large negative weight to such moves.  Puzzles with this feature are usually discarded by the optimizer, and the few remaining ones are discarded during the final selection of levels for the published game. <br><br>  This is not a complete list, during the testing with a deliberate search for errors, I found many other rules for unique solutions.  But most of them seemed rare and were quite detectable, so they didn‚Äôt simplify the game very much.  If someone solves the puzzle, using similar reasoning, then I will not blame them for it. <br><br><h3>  Conclusion </h3><br>  Initially, the game was developed as an experiment on procedural generation of puzzles.  The design of the game and the generator went hand in hand, so the techniques themselves are difficult to apply directly in other games. <br><br>  A question to which I have no answer: did investing of such efforts in procedural generation justify itself?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player feedback on level design was very controversial. </font><font style="vertical-align: inherit;">In positive comments, it was usually said that there is always a tricky trick in the puzzles. </font><font style="vertical-align: inherit;">In most of the negative reviews they wrote to me that the game lacks a gradient of complexity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have a couple more puzzles in the embryonic stage, and I liked the generator so much that most likely for them I use a similar procedural approach. </font><font style="vertical-align: inherit;">I will change only one thing: from the very beginning I will conduct active playtesting with the search for errors.</font></font><br><br><h3>  Notes </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] Or at least it seemed so to me. </font><font style="vertical-align: inherit;">But when I watched the players live, almost half of them just made guesses, and then worked them out iteratively.</font></font> Anyway. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] The readers of my article are also worth reading the article by </font></font><a href="https://magnushoff.com/minesweeper/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solving Minesweeper and making it better than</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] I‚Äôll clarify that the depth / narrowness of the tree is a metric that I considered significant for my game, and not for all other puzzles. </font><font style="vertical-align: inherit;">For example, there is a </font></font><a href="http://www.thinkfun.com/microsite/rushhour/creating2500challenges"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">good argument</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that the Rush Hour puzzle is interesting if it has several ways to solve almost, but not quite the same length. </font><font style="vertical-align: inherit;">But it happened because Rush Hour is a game for finding the shortest solution, and not just any solution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] With the exception of adding units. </font><font style="vertical-align: inherit;">In the first version of the puzzle there were no points, and the plan was to add units to the generator if necessary. </font><font style="vertical-align: inherit;">But it seemed too restrictive.</font></font></div><p>Source: <a href="https://habr.com/ru/post/452090/">https://habr.com/ru/post/452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452074/index.html">The first game on unity or what took me six months</a></li>
<li><a href="../452078/index.html">Reservations at Kubernetes: it exists</a></li>
<li><a href="../45208/index.html">Down with the language barrier - 2</a></li>
<li><a href="../452086/index.html">What's in a pixel for you my: the creation of nanopixels using plasmon meta-surfaces</a></li>
<li><a href="../45209/index.html">The first test of the interplanetary Internet</a></li>
<li><a href="../452092/index.html">In-App Updates: we accelerate the process of updating the application on Android</a></li>
<li><a href="../452098/index.html">Logs frontend developer Habr: refactor and reflex</a></li>
<li><a href="../4521/index.html">How are the meetings at google</a></li>
<li><a href="../452106/index.html">We invite speakers to the summer DIY-mitap June 16, 2019</a></li>
<li><a href="../452108/index.html">Docker: Harmless Tips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>