<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scala Collection: Secrets and Tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to your attention the translation of the article by Pavel Fatin Scala Collections Tips and Tricks . Pavel works at JetBrains and is developi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scala Collection: Secrets and Tricks</h1><div class="post__text post__text-html js-mediator-article"><p>  I present to your attention the translation of the article by <a href="https://pavelfatin.com/about">Pavel Fatin</a> <a href="https://pavelfatin.com/scala-collections-tips-and-tricks/">Scala Collections Tips and Tricks</a> .  Pavel works at <a href="https://www.jetbrains.com/">JetBrains</a> and is developing a <a href="https://confluence.jetbrains.com/display/SCA/Scala%2BPlugin%2Bfor%2BIntelliJ%2BIDEA">Scala plugin</a> for IntelliJ IDEA.  Further, the story goes on behalf of the author. </p><br><p>  In this article, you will find the simplifications and optimizations characteristic of the daily use of <a href="https://www.scala-lang.org/docu/files/collections-api/collections.html">the Scala API collections</a> . </p><br><p>  Some tips are based on the intricacies of library collection implementations, but most recipes are reasonable transformations that are often overlooked in practice. </p><br><p>  This list is inspired by my attempts to develop practical <a href="https://youtrack.jetbrains.com/oauth%3Fstate%3D%252Fissues%252FSCL%253Fq%253Dby%25253A%252BPavel.Fatin%252Bcollection%252Border%252Bby%25253A%252Bcreated">inspections for the Scala collections</a> , for <a href="https://confluence.jetbrains.com/display/SCA/Scala%2BPlugin%2Bfor%2BIntelliJ%2BIDEA">the IntelliJ Scala plugin</a> .  We are now implementing these inspections, so using the Scala plugin in IDEA you automatically benefit from static code analysis. </p><br><p>  However, these recipes are valuable in their own right.  They can help you deepen your understanding of the standard library of Scala collections and make your code faster and more expressive. </p><br><p>  <strong>Update:</strong> <br>  If you are experiencing adventure, <br>  You can <a href="https://blog.jetbrains.com/scala/2016/04/21/how-to-contribute-to-intellij-scala-plugin/">learn how to help develop IntelliJ plug-in for Scala</a> and try your hand at implementation by <a href="https://youtrack.jetbrains.com/issues/SCL%3Fq%3Dsummary:%2520collection%2520tag:%2520%257BUp%2520For%2520Grabs%257D">selecting the appropriate inspection</a> . </p><a name="habracut"></a><br><p>  <strong>Content:</strong> </p><br><pre><code class="hljs css">1.  2.  3.   4.  (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Sequences</span></span>) 4<span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.2</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.4</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.6</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.7</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.8</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.9</span></span>.  4<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>.  5.  (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Sets</span></span>) 6. <span class="hljs-selector-tag"><span class="hljs-selector-tag">Option-</span></span> 6<span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>.  6<span class="hljs-selector-class"><span class="hljs-selector-class">.2</span></span>. <span class="hljs-selector-tag"><span class="hljs-selector-tag">Null</span></span> 6<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span>.  6<span class="hljs-selector-class"><span class="hljs-selector-class">.4</span></span>.  7.  8. </code> </pre> <br><p>  All code samples are available in <a href="https://github.com/pavelfatin/scala-collections-tips-and-tricks">the GitHub repository</a> . </p><br><h2 id="1-legenda">  1. Legend </h2><br><p>  To make the code examples clearer, I used the following notation: </p><br><ul><li>  <code>seq</code> - an instance of a collection based on <code>Seq</code> , like <code>Seq(1, 2, 3)</code> </li><li>  <code>set</code> is an instance of <code>Set</code> , for example <code>Set(1, 2, 3)</code> </li><li>  <code>array</code> - an array such as <code>Array(1, 2, 3)</code> </li><li>  <code>option</code> - an instance of <code>Option</code> , for example, <code>Some(1)</code> </li><li>  <code>map</code> is a <code>Map</code> instance, similar to <code>Map(1 -&gt; "foo", 2 -&gt; "bar")</code> </li><li> <code>???</code>  - arbitrary expression </li><li>  <code>p</code> - predicate function of type <code>T =&gt; Boolean</code> , for example <code>_ &gt; 2</code> </li><li>  <code>n</code> is an integer value </li><li>  <code>i</code> - integer index </li><li>  <code>f</code> , <code>g</code> - simple functions, <code>A =&gt; B</code> </li><li>  <code>x</code> , <code>y</code> - some arbitrary values </li><li>  <code>z</code> - initial or default value </li><li>  <code>P</code> - pattern </li></ul><br><h2 id="2-kompoziciya">  2. Composition </h2><br><p>  Remember, despite the fact that recipes are isolated and self-sufficient, they can be put together for the subsequent gradual transformation into more advanced expressions: </p><br><pre> <code class="hljs pgsql">seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(_ == x).headOption != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> //  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).headOption  seq.find(p) seq.find(_ == x) != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined seq.find(_ == x).isDefined //  seq.find(p).isDefined  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p) seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(_ == x) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(_ == x)  seq.contains(x) seq.contains(x)</code> </pre> <br><p>  So, we can rely on a ‚Äúreplacement recipe application model‚Äù (similar to <a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node10.html">SICP</a> ), and use it to simplify complex expressions. </p><br><h2 id="3-pobochnye-effekty">  3. Side effects </h2><br><p>  "Side effect" (Side effect) is a basic concept that should be considered before we list the main transformations. </p><br><p>  In fact, a side effect is any action that is observed outside of a function or expression besides returning a value, for example: </p><br><ul><li>  I / O operation </li><li>  variable modification (available outside of scope), </li><li>  change in the state of the object (observed outside the scope), </li><li>  excitation of exclusion (which is also not processed inside the scope). </li></ul><br><p>  Functions or expressions containing any of the above actions are said to have side effects, otherwise they are called ‚Äúclean.‚Äù </p><br><p>  Why are side effects so important?  Because with them the order of execution matters.  For example, two "pure" expressions (associated with the corresponding values): </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Since they do not contain side effects (i.e., effects observed outside expressions), we can calculate these expressions in an arbitrary order ‚Äî first <code>x</code> and then <code>y</code> or first <code>y</code> , and then <code>x</code> ‚Äî this will not affect the correctness of the results ( we can even cache the resulting values ‚Äã‚Äãif we want one).  Now consider the following modification: </p><br><pre> <code class="hljs swift">val x = { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> } val y = { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><p>  And this is another story - we cannot change the order of execution, because in our terminal there will be printed "barfoo" instead of "foobar" (and this is clearly not what we wanted). </p><br><p>  So, the presence of side effects <strong>reduces the number of possible transformations</strong> (both simplifications and optimizations) that we can apply to the code. </p><br><p>  Similar reasoning applies to related collections, expressions.  Imagine that somewhere outside the scope, we have a certain <code>builder</code> : </p><br><pre> <code class="hljs javascript">seq.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> { builder.append(x); x &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> }).headOption</code> </pre> <br><p>  In principle, the <code>seq.filter(p).headOption</code> simplified to <code>seq.find(p)</code> , however, the presence of a side effect <code>seq.find(p)</code> us from doing this: </p><br><pre> <code class="hljs dos">seq.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>( x =&gt; {builder.<span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(x); x &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> })</code> </pre> <br><p>  Although these expressions are equivalent from the standpoint of the final value, they are not equivalent regarding side effects.  The first expression will add all elements, and the last will drop all elements as soon as it finds the first value that matches the predicate.  Therefore, such a simplification can not be done. </p><br><p>  What can be done to make automatic simplification possible?  The answer is the <strong>golden rule</strong> , which should be followed in relation to all side effects in our code (including the one where there are no collections in principle): </p><br><ul><li>  Avoid side effects when possible. </li><li>  Otherwise, isolate the side effects from clean code. </li></ul><br><p>  Therefore, we need to either get rid of <code>builder</code> a (along with its API, which has side effects), or separate the call of <code>builder</code> a from the pure expression.  Suppose that this <code>builder</code> is a kind of third-party object, which we cannot get rid of, so we can only isolate the call: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.foreach</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">builder</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.append</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.filter</span></span>(_ &gt; 3)<span class="hljs-selector-class"><span class="hljs-selector-class">.headOption</span></span></code> </pre> <br><p>  Now we can safely complete the conversion: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.foreach</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">builder</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.append</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.find</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> &gt; 3)</code> </pre> <br><p>  Clean and beautiful!  Isolation of side effects made automatic conversion possible.  An additional benefit is that due to the presence of a clear separation, it is easier for a person to understand the resulting code. </p><br><p>  The least obvious and the most important advantage of isolating side effects will be improving the reliability of our code, regardless of other possible optimizations.  Regarding the example: the initial expression can produce various side effects depending on the current implementation of <code>Seq</code> .  For <code>Vector</code> , for example, it will add all elements, for <code>Stream</code> it will skip all elements after the first successful match with the predicate (because the streams are ‚Äúlazy‚Äù - the elements are calculated only when necessary).  Separating the side effects allows us to avoid these uncertainties. </p><br><h2 id="4-posledovatelnosti-sequences">  4. Sequences (Sequences) </h2><br><p>  Although the tips in this section apply to the <code>Seq</code> heirs, some conversions are valid for other types of collections (and not collections), for example: <code>Set</code> , <code>Option</code> , <code>Map</code> and even <code>Iterator</code> (because they all provide similar interfaces with monadic methods). </p><br><h3 id="41-sozdanie">  4.1 Creating </h3><br><h4 id="yavno-sozdavayte-pustye-kollekcii">  Explicitly create empty collections </h4><br><pre> <code class="hljs markdown">//  Seq[<span class="hljs-string"><span class="hljs-string">T</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) //  Seq.empty[T]</code> </pre> <br><p>  Some immutable collection classes have a singleton implementation of the <code>empty</code> method.  However, not all factory methods check the length of the created collections.  So, by designating emptiness at compile time, you can save either space on the heap (by reusing the instance), or processor ticks (which could be spent on dimension checks at runtime). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h3 id="42-dliny">  4.2 Lengths </h3><br><h4 id="dlya-massivov-ispolzuyte-length-vmesto-size">  For arrays, use <code>length</code> instead of <code>size</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.size //  <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length</code> </pre> <br><p>  Although <code>size</code> and <code>length</code> are essentially synonyms, in Scala 2.11, <code>Array.size</code> calls <code>Array.size</code> still executed via implicit conversion, thus creating intermediate wrapper objects for each method call.  If you, of course, do not enable <a href="https://en.wikipedia.org/wiki/Escape_analysis">escaping analysis</a> for the JVM, temporary objects will become a burden for the garbage collector and will degrade the performance of the code (especially inside loops). </p><br><h4 id="ne-otricayte-isempty">  Do not deny isEmpty </h4><br><pre> <code class="hljs erlang-repl">//  !seq.isEmpty !seq.nonEmpty //  seq.nonEmpty seq.isEmpty</code> </pre> <br><p>  Simple properties contain less visual noise than compound expressions. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="ne-vychislyayte-dlinu-pri-proverke-na-pustotu">  Do not calculate the length when checking for emptiness. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.length &gt; 0 seq.length != 0 seq.length == 0 //  seq.nonEmpty seq.nonEmpty seq.isEmpty</span></span></code> </pre> <br><p>  On the one hand, a simple property is perceived much easier than a compound expression.  On the other hand, heirs of <code>LinearSeq</code> (such as <code>List</code> ) may need <code>O(n)</code> time to calculate the length of the list (instead of <code>O(1)</code> for <code>IndexedSeq</code> ), so we can speed up our code by avoiding the length calculation when we, in general, This value is not very necessary. <br>  Also <code>.length</code> in mind that the <code>.length</code> challenge for endless streams may never end, so always check the stream for emptiness explicitly. <br>  Also applicable to: <code>Set</code> , <code>Map</code> . </p><br><h3 id="vo-vremya-sravneniya-ne-vychislyayte-polnyy-razmer-kollekcii">  During the comparison, do not calculate the full size of the collection. </h3><br><pre> <code class="hljs xml">//  seq.length &gt; n seq.length <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">seq.length</span></span></span><span class="hljs-tag"> == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">n</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">seq.length</span></span></span><span class="hljs-tag"> != </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">n</span></span></span><span class="hljs-tag"> //  </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">seq.lengthCompare</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag">) &gt;</span></span> 0 seq.lengthCompare(n) <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">seq.lengthCompare</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag">) == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">seq.lengthCompare</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span><span class="hljs-tag">) != </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">0</span></span></span></span></code> </pre> <br><p>  Since the calculation of the size of the collection can be quite ‚Äúexpensive‚Äù calculation for some types of collections, we can reduce the comparison time from <code>O(length)</code> to <code>O(length min n)</code> for the heirs of <code>LinearSeq</code> (which can be hidden under <code>Seq</code> -like values).  In addition, this approach is indispensable when dealing with endless streams. </p><br><h3 id="ne-ispolzuyte-exists-dlya-proverki-na-pustotu">  Do not use <code>exists</code> to check for emptiness. </h3><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(_ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(const(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)) //  seq.nonEmpty</code> </pre> <br><p>  Of course, such a trick would be completely superfluous. <br>  Also applicable to: Set, Option, Map, Iterator. </p><br><h3 id="43-ravenstvo">  4.3 Equality </h3><br><h4 id="ne-polagaytes-na--dlya-sravneniya-soderzhimogo-massivov">  Do not rely on <code>==</code> to compare the contents of arrays </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  array1 == array2 //  array1.sameElements(array2)</span></span></code> </pre> <br><p>  The equality test will always return <code>false</code> for different instances of arrays. <br>  Also applicable to: <code>Iterator</code> . </p><br><h4 id="ne-proveryayte-na-ravenstvo-kollekcii-razlichnyh-kategoriy">  Do not check for equality of the collection of different categories. </h4><br><pre> <code class="hljs pgsql">//  seq == <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> //  seq.toSet == <span class="hljs-keyword"><span class="hljs-keyword">set</span></span></code> </pre> <br><p>  Equality checks can be used to compare collections and different categories (for example <code>List</code> and <code>Set</code> ). <br>  I ask you to think twice about the meaning of this test (regarding the example above - how to treat duplicates in sequence). </p><br><h4 id="ne-ispolzuyte-sameelements-dlya-sravneniya-obyknovennyh-kollekciy">  Do not use the <code>sameElements</code> to compare ordinary collections. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq1.sameElements(seq2) //  seq1 == seq2</span></span></code> </pre> <br><p>  Equality testing is the way to compare collections of the same category.  In theory, this can improve performance due to the presence of possible underlying instance checks ( <code>eq</code> , usually much faster). </p><br><h4 id="ne-ispolzuyte-corresponds-yavno">  Do not use the correspond explicitly. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq1.corresponds(seq2)(_ == _) //  seq1 == seq2</span></span></code> </pre> <br><p>  We already have a built-in method that does the same.  Both expressions take into account the order of the elements.  And again, we can benefit from increased productivity. </p><br><h2 id="44-indeksaciya">  4.4 Indexing </h2><br><h4 id="ne-poluchayte-pervyy-element-po-indeksu">  Do not get the first item by index </h4><br><pre> <code class="hljs perl">//  se<span class="hljs-string"><span class="hljs-string">q(0)</span></span> //  seq.head</code> </pre> <br><p>  For some classes of collections, the updated approach may be a little faster (see the <code>List.apply</code> code, for example).  Moreover, accessing a property is much easier (both syntactically and semantically) than calling a method with an argument. </p><br><h4 id="ne-poluchayte-posledniy-element-po-indeksu">  Don't get the last item by index </h4><br><pre> <code class="hljs perl">//  se<span class="hljs-string"><span class="hljs-string">q(seq.length - 1)</span></span> //  seq.last</code> </pre> <br><p>  The last expression will be clearer and will avoid unnecessary calculations of the length of the collection (and for linear sequences it may take a lot of time).  Moreover, some collection classes can retrieve the last element more efficiently than index access. </p><br><h4 id="ne-proveryayte-nahozhdenie-indeksa-v-granicah-kollekcii-yavno">  Do not check whether the index is within the boundaries of the collection explicitly. </h4><br><pre> <code class="hljs perl">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; seq.length) Some(se<span class="hljs-string"><span class="hljs-string">q(i)</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> None //  seq.lift(i)</code> </pre> <br><p>  Semantically, the second expression is equivalent, but more expressive. </p><br><h4 id="ne-emuliruyte-headoption">  Do not emulate headOption </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(seq.head) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> seq.lift(<span class="hljs-number"><span class="hljs-number">0</span></span>) //  seq.headOption</code> </pre> <br><p>  Simplified expression is more succinct. </p><br><h4 id="ne-emuliruyte-lastoption">  Do not emulate <code>lastOption</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(seq.last) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> seq.lift(seq.length - <span class="hljs-number"><span class="hljs-number">1</span></span>) //  seq.lastOption</code> </pre> <br><p>  The last expression is shorter (and potentially faster). </p><br><h4 id="budte-ostorozhny-s-tipami-argumentov-dlya-indexof-i-lastindexof">  Be careful with the argument types for <code>indexOf</code> and <code>lastIndexOf</code> </h4><br><pre> <code class="hljs perl">//  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.indexOf(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) //  //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>) Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.lastIndexOf(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Due to the <code>indexOf</code> <a href="http://stackoverflow.com/questions/2078246/why-does-seq-contains-accept-type-any-rather-than-the-type-parameter-a/2078619">variation</a> , the <code>indexOf</code> and <code>lastIndexOf</code> methods accept arguments of type <code>Any</code> .  In practice, this can lead to hard-to-find bugs that cannot be detected at the compilation stage.  This is where your IDE's subsidiary inspections will be. </p><br><h4 id="ne-sozdavayte-diapazon-indeksov-posledovatelnosti-vruchnuyu">  Do not create a range of sequence indexes manually. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  Range(0, seq.length) //  seq.indices</span></span></code> </pre> <br><p>  We have a built-in method that returns a range of all indexes in a sequence. </p><br><h4 id="ne-ispolzuyte-zip-dlya-svyazyvaniya-kollekcii-s-indeksami-vruchnuyu">  Do not use zip to link the collection with indexes manually. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.zip(seq.indices) //  seq.zipWithIndex</span></span></code> </pre> <br><p>  First, the last expression is shorter.  In addition, we can expect some performance gains due to the fact that we avoid the hidden calculation of the size of the collection (which can be expensive in the case of linear sequences). <br>  An additional advantage of the last expression is that it works well with potentially infinite collections (for example, <code>Stream</code> ). </p><br><h4 id="ispolzuyte-ekzemplyar-indexedseq-kak-obekt-funkciyu">  Use an IndexedSeq instance as a function object: </h4><br><pre> <code class="hljs perl">//  (seq: IndexedSe<span class="hljs-string"><span class="hljs-string">q[T]</span></span>) Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.map(se<span class="hljs-string"><span class="hljs-string">q(_)</span></span>) //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.map(seq)</code> </pre> <br><p>  Since an instance of <code>IndexedSeq[T]</code> also <code>Function1[Int, T]</code> , you can use it as such. </p><br><h3 id="45-suschestvovanie">  4.5 Existence </h3><br><h4 id="ne-ispolzuyte-predikat-sravneniya-dlya-proverki-nalichiya-elementa">  Do not use comparison predicate to check for element </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.exists(_ == x) //  seq.contains(x)</span></span></code> </pre> <br><p>  The second expression is semantically equivalent, more expressive.  When these expressions are applied to <code>Set</code> , performance can be dramatically different, because searching for sets tends to <code>O(1)</code> (due to internal indexing, which is not used when calling <code>exists</code> ). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="budte-ostorozhny-s-tipom-argumenta-contains">  Be careful with the argument type <code>contains</code> </h4><br><pre> <code class="hljs perl">//  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.contains(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) //  //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.contains(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  As well as the <code>indexOf</code> and <code>lastIndexOf</code> methods of the <code>contains</code> accepts arguments of type <code>Any</code> , which can lead to hard-to-find bugs that are not detected at the compilation stage.  Be careful with them. </p><br><h4 id="ne-ispolzuyte-predikat-neravenstva-dlya-proverki-otsutstviya-elementa">  Do not use inequality predicate to check for missing element. </h4><br><pre> <code class="hljs erlang-repl">//  seq.forall(_ != x) //  !seq.contains(x)</code> </pre> <br><p>  Again, the last expression is cleaner and probably faster (especially for sets). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-schitayte-vhozhdeniya-dlya-proverki-suschestvovaniya">  Do not count occurrences to verify existence </h4><br><pre> <code class="hljs pgsql">//  seq.count(p) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> seq.count(p) != <span class="hljs-number"><span class="hljs-number">0</span></span> seq.count(p) == <span class="hljs-number"><span class="hljs-number">0</span></span> //  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p) seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p) !seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p)</code> </pre> <br><p>  Obviously, when we need to know whether a conditionally matching element is in a collection, counting the number of satisfying elements will be redundant.  Simplified expression looks cleaner and faster. </p><br><ul><li>  The predicate <code>p</code> must be a pure function. </li><li>  Also applicable to: <code>Set</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-pribegayte-k-filtracii-dlya-proverki-suschestvovaniya">  Do not use filtering to check for existence. </h4><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).nonEmpty seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).isEmpty //  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p) !seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p)</code> </pre> <br><p>  The <code>filter</code> call creates an intermediate collection that takes up space on the heap and loads the GC.  In addition, the preceding expressions find all entries, while you only need to find the first (which can slow down the code depending on the possible contents of the collection).  Potential performance gains are less significant for lazy collections (such as <code>Stream</code> and, in particular, <code>Iterator</code> ). </p><br><ul><li>  The predicate <code>p</code> must be a pure function. </li><li>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-pribegayte-k-poisku-chtoby-proverit-suschestvovanie">  Do not resort to search to verify the existence of </h4><br><pre> <code class="hljs pgsql">//  seq.find(p).isDefined seq.find(p).isEmpty //  seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p) !seq.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p)</code> </pre> <br><p>  The search is definitely better than filtering, but this is far from the limit (at least in terms of clarity). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h3 id="46-filtraciya">  4.6 Filtering </h3><br><h4 id="ne-otricayte-predikat-filter">  Do not deny the predicate filter </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.filter(!p) //  seq.filterNot(p)</span></span></code> </pre> <br><p>  The last expression is syntactically simpler (despite the fact that semantically they are equivalent). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="ne-filtruyte-chtoby-poschitat">  Do not filter to count </h4><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).length //  seq.count(p)</code> </pre> <br><p>  The <code>filter</code> call creates an intermediate (and not very necessary) collection that will take up space on the heap and load the GC. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="ne-ispolzuyte-filtraciyu-dlya-togo-chtoby-nayti-pervoe-vhozhdenie">  Do not use filtering to find the first entry. </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.filter(p).headOption //  seq.find(p)</span></span></code> </pre> <br><p>  Of course, if <code>seq</code> not a lazy collection (like, for example, <code>Stream</code> ), filtering will find all entries (and create a temporary collection), with only the first element required. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h3 id="47-sortirovka">  4.7 Sorting </h3><br><h4 id="ne-sortiruyte-po-svoystvu-vruchnuyu">  Do not manually sort by property </h4><br><pre> <code class="hljs vhdl">//  seq.sortWith(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span> &lt; _.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>) //  seq.sortBy(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>)</code> </pre> <br><p>  For this we have our own method, clearer and more expressive. </p><br><h4 id="ne-sortiruyte-po-tozhdestvu-vruchnuyu">  Do not manually sort by identity </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.sortBy(identity) seq.sortWith(_ &lt; _) //  seq.sorted</span></span></code> </pre> <br><p>  And for this, too, there is a method. </p><br><h4 id="vypolnyayte-obratnuyu-sortirovku-v-odin-shag">  Reverse Sort in One Step </h4><br><pre> <code class="hljs pgsql">//  seq.sorted.<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> seq.sortBy(_.property).<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> seq.sortWith(f(_, _)).<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> //  seq.sorted(Ordering[T].<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>) seq.sortBy(_.property)(Ordering[T].<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>) seq.sortWith(!f(_, _))</code> </pre> <br><p>  Thus, we can avoid creating an intermediate collection and eliminate additional conversions (to save heap space and processor cycles). </p><br><h4 id="ne-ispolzuyte-sortirovku-dlya-nahozhdeniya-minimalnogo-elementa">  Do not use sorting to find the minimum item. </h4><br><pre> <code class="hljs vhdl">//  seq.sorted.head seq.sortBy(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>).head //  seq.min seq.minBy(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>)</code> </pre> <br><p>  The latter approach is more expressive.  In addition, due to the fact that an additional collection is not created, it will work faster. </p><br><h4 id="ne-ispolzuyte-sortirovku-dlya-nahozhdeniya-maksimalnogo-elementa">  Do not use sorting to find the maximum element. </h4><br><pre> <code class="hljs vhdl">//  seq.sorted.last seq.sortBy(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>).last //  seq.max seq.maxBy(_.<span class="hljs-keyword"><span class="hljs-keyword">property</span></span>)</code> </pre> <br><p>  The explanation is the same as the previous tip. </p><br><h3 id="48-svertka">  4.8 Convolution </h3><br><h4 id="ne-vychislyayte-summu-vruchnuyu">  Do not calculate the amount manually </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.reduce(_ + _) seq.fold(z)(_ + _) //  seq.sum seq.sum + z</span></span></code> </pre> <br><p>  The advantages of this approach are clarity and expressiveness. </p><br><ul><li>  Other possible methods: <code>reduceLeft</code> , <code>reduceRight</code> , <code>foldLeft</code> , <code>foldRight</code> . </li><li>  The second transformation can be replaced by the first, if <code>z</code> equals <code>0</code> . </li><li>  Also applicable to: <code>Set</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-vychislyayte-proizvedenie-vruchnuyu">  Do not calculate the product manually </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.reduce(_ * _) seq.fold(z)(_ * _) //  seq.product seq.product * z</span></span></code> </pre> <br><p>  The reasons are the same as in the previous case. </p><br><ul><li>  The second transformation can be replaced by the first, if <code>z</code> is <code>1</code> . </li><li>  Also applicable to: <code>Set</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-ischite-minimalnyy-element-vruchnuyu">  Do not search for the minimal element manually. </h4><br><pre> <code class="hljs lua">//  seq.reduce(_ <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> _) seq.fold(z)(_ <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> _) //  seq.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> z <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> seq.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span></code> </pre> <br><p>  The rationale is the same as in the previous case. <br>  Also applicable to: <code>Set</code> , <code>Iterator</code> . </p><br><h4 id="ne-vypolnyayte-poisk-maksimalnogo-elementa-vruchnuyu">  Do not search for the maximum item manually. </h4><br><pre> <code class="hljs lua">//  seq.reduce(_ <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> _) seq.fold(z)(_ <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> _) //  seq.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> z <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> seq.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span></code> </pre> <br><p>  All as in the previous case. <br>  Also applicable to: <code>Set</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-forall">  Do not emulate <code>forall</code> </h4><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.foldLeft(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> x &amp;&amp; p(y)) !seq.map(p).contains(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.forall(p)</code> </pre> <br><p>  The purpose of simplification is clarity and expressiveness. </p><br><ul><li>  The predicate <code>p</code> must be a pure function. </li><li>  Also applicable to: <code>Set</code> , <code>Option</code> (for the second row), <code>Iterator</code> . </li></ul><br><h4 id="ne-emuliruyte-exists">  Don't emulate <code>exists</code> </h4><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.foldLeft(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> x || p(y)) seq.map(p).contains(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.exists(p)</code> </pre> <br><p>  With all the clarity and expressiveness, the last expression can work faster (it stops the subsequent processing of elements as soon as it finds the first suitable element), which can work for infinite sequences. </p><br><ul><li>  The predicate <code>p</code> must be a pure function. </li><li>  Also applicable to: <code>Set</code> , <code>Option</code> (for the second row), <code>Iterator</code> . </li></ul><br><h4 id="ne-emuliruyte-map">  Do not emulate <code>map</code> </h4><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.foldLeft(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, x)</span></span></span><span class="hljs-function"> =&gt;</span></span> acc :+ f(x)) seq.foldRight(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, acc)</span></span></span><span class="hljs-function"> =&gt;</span></span> f(x) +: acc) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.map(f)</code> </pre> <br><p>  This is a ‚Äúclassical‚Äù implementation of mapping (map) through convolution in functional programming.  Undoubtedly, it is instructive, but there is no need to use it.  To do this, we have a built-in and expressive method (which is also faster, since it uses a simple <code>while</code> in its implementation). <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-filter">  Do not emulate <code>filter</code> </h4><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.foldLeft(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, x)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(x)) acc :+ x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> acc) seq.foldRight(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, acc)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(x)) x +: acc <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> acc) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.filter(p)</code> </pre> <br><p>  The reasons are the same as in the previous case. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-reverse">  Do not emulate <code>reverse</code> </h4><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.foldLeft(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, x)</span></span></span><span class="hljs-function"> =&gt;</span></span> x +: acc) seq.foldRight(Seq.empty)(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, acc)</span></span></span><span class="hljs-function"> =&gt;</span></span> acc :+ x) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  seq.reverse</code> </pre> <br><p>  And again, the built-in method is faster and cleaner. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h3 id="49-sopostavlenie">  4.9 Comparison </h3><br><p>  Here are some separate tips on Scala <a href="http://docs.scala-lang.org/tutorials/tour/pattern-matching.html">pattern matching</a> and <a href="https://www.scala-lang.org/api/current/index.html">partial functions</a> . </p><br><h4 id="ispolzuyte-chastichnye-funkcii-vmesto-funkciy-s-pattern-matchingom">  Use partial functions instead of pattern matching functions. </h4><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  seq.map { _ match { case P =&gt; ??? /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ x N } } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  seq.map { case P =&gt; ??? /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ x N }</span></span></code> </pre> <br><p>  The updated expression gives a similar result and looks simpler. </p><br><p>  The transformations described above can be applied to any functions, and not just to the arguments of the <code>map</code> function.  This tip applies not only to collections.  However, in view of the omnipresence <a href="https://en.wikipedia.org/wiki/Higher-order_function">of higher-order functions</a> in the API of the standard library of Scala collections, it will be very useful. </p><br><h4 id="konvertiruyte-flatmap-s-chastichnoy-funkciey-collect">  Convert <code>flatMap</code> with partial <code>collect</code> function </h4><br><pre> <code class="hljs perl">//  seq.flatMap { case <span class="hljs-string"><span class="hljs-string">P =&gt;</span></span> Se<span class="hljs-string"><span class="hljs-string">q(???)</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> N case <span class="hljs-string"><span class="hljs-string">_ =&gt;</span></span> Seq.empty } //  seq.collect { case <span class="hljs-string"><span class="hljs-string">P =&gt;</span></span> ??? <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> N }</code> </pre> <br><p>  The updated expression gives a similar result and looks much simpler. <br>  Also applicable to: <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="preobrazovat-match-k-collect-kogda-rezultatom-yavlyaetsya-kollekciya">  Convert <code>match</code> to <code>collect</code> when the result is a collection. </h4><br><pre> <code class="hljs perl">//  v match { case <span class="hljs-string"><span class="hljs-string">P =&gt;</span></span> Se<span class="hljs-string"><span class="hljs-string">q(???)</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> N case <span class="hljs-string"><span class="hljs-string">_ =&gt;</span></span> Seq.empty } //  Se<span class="hljs-string"><span class="hljs-string">q(v)</span></span> collect { case <span class="hljs-string"><span class="hljs-string">P =&gt;</span></span> ??? <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> N }</code> </pre> <br><p>  Given that all case statements create collections, you can simplify the expression by replacing <code>match</code> with a call to <code>collect</code> .       ,      <code>case</code>   . <br>        <code>Option</code> ,      . <br>   : <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-collectfirst">   <code>collectFirst</code> </h4><br><pre> <code class="hljs pgsql">//  seq.collect{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> P =&gt; ???}.headOption //  seq.collectFirst{<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> P =&gt; ???}</code> </pre> <br><p>        ,      . </p><br><ul><li>     . </li><li>   : <code>Set</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h3 id="410-pererabatyvaem"> 4.10  </h3><br><h4 id="soedinyaem-posledovatelnye-vyzovy-filter">    <code>filter</code> </h4><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p1).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p2) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(x =&gt; p1(x) &amp;&amp; p2(x))</code> </pre> <br><p>        (   <code>filter</code> ),     . <br>       ,     ( ), : <code>seq.view.filter(p1).filter(p2).force</code> . </p><br><ul><li>  <code>p1</code>  <code>p2</code>    . </li><li>   : <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="soedinyaem-posledovatelnye-vyzovy-map">    <code>map</code> </h4><br><pre> <code class="hljs vhdl">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f).<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(g) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f.andThen(g))</code> </pre> <br><p>     ,        . </p><br><p>       ,    view ( ), : <code>seq.view.map(f).map(g).force</code> . </p><br><ul><li>  <code>f</code>  <code>g</code>   . </li><li>   : <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="sortiruyte-posle-filtracii">    </h4><br><pre> <code class="hljs pgsql">//  seq.sorted.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).sorted</code> </pre> <br><p>  ‚Äî  .     ,       . </p><br><ul><li>       ,   <code>sortWith</code>  <code>sortBy</code> . </li><li>  <code>p</code>    . </li></ul><br><h4 id="ne-perevorachivayte-kollekciyu-yavno-pered-vyzovom-map">       <code>map</code> </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.reverse.map(f) //  seq.reverseMap(f)</span></span></code> </pre> <br><p>     ()    ,      (  <code>List</code> ).   ,    ,     ,    . </p><br><h4 id="ne-perevorachivayte-kollekciyu-yavno-dlya-polucheniya-obratnogo-iteratora">         </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.reverse.iterator //  seq.reverseIterator</span></span></code> </pre> <br><p>           . </p><br><h4 id="ne-konvertiruyte-kollekciyu-set-dlya-nahozhdeniya-otdelnyh-elementov">    <code>Set</code>     </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq.toSet.toSeq //  seq.distinct</span></span></code> </pre> <br><p>      (   ),    . </p><br><h4 id="ne-emuliruyte-slice">   <code>slice</code> </h4><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>(x).take(y) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>(x, x + y)</code> </pre> <br><p>   ,          . ,           . <br>   : <code>Set</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-splitat">   <code>splitAt</code> </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  val seq1 = seq.take(n) val seq2 = seq.drop(n) //  val (seq1, seq2) = seq.splitAt(n)</span></span></code> </pre> <br><p>    (  <code>List</code> ,    <code>Stream</code> ),      - ,      . <br>   : <code>Set</code> , <code>Map</code> . </p><br><h4 id="ne-emuliruyte-span">   <code>span</code> </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  val seq1 = seq.takeWhile(p) val seq2 = seq.dropWhile(p) //  val (seq1, seq2) = seq.span(p)</span></span></code> </pre> <br><p>           ,    . </p><br><ul><li>  <code>p</code>     . </li><li>   : <code>Set</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-emuliruyte-partition">   <code>partition</code> </h4><br><pre> <code class="hljs pgsql">//  val seq1 = seq.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p) val seq2 = seq.filterNot(p) //  val (seq1, seq2) = seq.<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>(p)</code> </pre> <br><p> -,       </p><br><ul><li>  <code>p</code>     . </li><li>   : <code>Set</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-emuliruyte-takeright">   <code>takeRight</code> </h4><br><pre> <code class="hljs pgsql">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span>.take(n).<span class="hljs-keyword"><span class="hljs-keyword">reverse</span></span> //  seq.takeRight(n)</code> </pre> <br><p>         (  ,     ). </p><br><h4 id="ne-emuliruyte-flatten">   <code>flatten</code> </h4><br><pre> <code class="hljs perl">//  (seq: Se<span class="hljs-string"><span class="hljs-string">q[Seq[T]</span></span>]) seq.reduce(<span class="hljs-number"><span class="hljs-number">_</span></span> ++ <span class="hljs-number"><span class="hljs-number">_</span></span>) seq.fold(Seq.empty)(<span class="hljs-number"><span class="hljs-number">_</span></span> ++ <span class="hljs-number"><span class="hljs-number">_</span></span>) seq.flatMap(identity) //  seq.flatten</code> </pre> <br><p>     :      . <br>   : <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-emuliruyte-flatmap">   <code>flatMap</code> </h4><br><pre> <code class="hljs perl">//  (f: <span class="hljs-string"><span class="hljs-string">A =&gt;</span></span> Se<span class="hljs-string"><span class="hljs-string">q[B]</span></span>) seq.map(f).flatten //  seq.flatMap(f)</code> </pre> <br><p> -   .    ,      . <br>   : <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="ne-ispolzuyte-map-esli-rezultat-ignoriruetsya">   <code>map</code>    </h4><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  seq.map(???) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  seq.foreach(???)</span></span></code> </pre> <br><p>      ,   <code>map</code> .     ,      . <br>   : <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </p><br><h4 id="ne-ispolzuyte-unzip-dlya-izvlecheniya-edinstvennogo-elementa">   <code>unzip</code>     </h4><br><pre> <code class="hljs perl">//  (seq: Se<span class="hljs-string"><span class="hljs-string">q[(A, B]</span></span>]) seq.unzip._1 //  seq.map(<span class="hljs-number"><span class="hljs-number">_</span></span>._1)</code> </pre> <br><p>    ,   -  . </p><br><ul><li>   : <code>unzip3</code> . </li><li>   : <code>Set</code> , <code>Option</code> , <code>Map</code> , <code>Iterator</code> . </li></ul><br><h4 id="ne-sozdavayte-vremennye-kollekcii">     </h4><br><p>       (     ). </p><br><p> 1)      . </p><br><pre> <code class="hljs pgsql">//  seq.map(f).flatMap(g).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).reduce(???) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.map(f).flatMap(g).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).reduce(???)</code> </pre> <br><p>  <code>reduce</code>    ,      , : <code>reduceLeft</code> , <code>reduceRight</code> , <code>fold</code> , <code>foldLeft</code> , <code>foldRight</code> , <code>sum</code> , <code>product</code> , <code>min</code> , <code>max</code> , <code>head</code> , <code>headOption</code> , <code>last</code> , <code>lastOption</code> , <code>indexOf</code> , <code>lastIndexOf</code> , <code>find</code> , <code>contains</code> , <code>exists</code> , <code>count</code> , <code>length</code> , <code>mkString</code> ,  .. </p><br><p>       ‚Äî  ,    ,        -  ,           GC.   ,       ( <code>map</code> , <code>flatMap</code> , <code>filter</code> , <code>++,</code>  ..)  ¬´¬ª (  <code>Stream</code> ) ,  ,       . </p><br><p>      (view) ‚Äî     ,     ,   : </p><br><ul><li>  "" ‚Äî     . </li><li>        (   <code>Stream</code> ). </li></ul><br><p>       ,   <code>view</code> . </p><br><p> 2) ,     . </p><br><p>     ,     -   ‚Äî  <code>force</code>     (       ): </p><br><pre> <code class="hljs vhdl">//  seq.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f).flatMap(g).filter(p) //  seq.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f).flatMap(g).filter(p).<span class="hljs-keyword"><span class="hljs-keyword">force</span></span></code> </pre> <br><p>   ‚Äî   , ,  ,     <code>withFilter</code> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.withFilter</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.map</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>)</code> </pre> <br><p>    <a href="https://www.scala-lang.org/old/node/3698.html"></a>    "for comprehensions".    ,    ‚Äî   ,       (,      ). ,       ( )    ( <code>veiw</code>  <code>force</code> ) </p><br><p>             , <code>withFilter</code> -     . </p><br><p> 3)     . </p><br><pre> <code class="hljs pgsql">//  seq.map(f).flatMap(g).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).toList //  seq.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.map(f).flatMap(g).<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p).toList</code> </pre> <br><p>       <code>force</code>    -,      . </p><br><p>       ¬´ + ¬ª.      <code>breakOut</code> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">seq</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.map</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">collection</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.breakOut</span></span>): <span class="hljs-selector-tag"><span class="hljs-selector-tag">List</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[T]</span></span></code> </pre> <br><p>     , : </p><br><ul><li>      (, ,    ), </li><li>    (, , <code>map</code> , <code>flatMap</code> , <code>filter</code> , <code>fold</code> ,  ..), </li><li>    (  ,     <a href="https://www.scala-lang.org/api/current/index.html"></a>      Scala). </li></ul><br><p>  ,  ,   <code>breakOut</code>      . </p><br><p>        . </p><br><ul><li>    ( <code>f</code>  <code>g</code> )   ( <code>p</code> )     (    , ,      ). </li><li>   : <code>Set</code> , <code>Map</code> . </li></ul><br><h4 id="ispolzuyte-operatory-dlya-pereprisvanivaniya-posledovatelnostey">      </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  seq = seq :+ x seq = x +: seq seq1 = seq1 ++ seq2 seq1 = seq2 ++ seq1 //  seq :+= x seq +:= x seq1 ++= seq2 seq1 ++:= seq2</span></span></code> </pre> <br><p> Scala  ¬´ ¬ª,   ¬´ ¬ª (‚Äúassignment operators‚Äù) ‚Äî      <code>x &lt;op&gt;= y</code>   <code>x = x &lt;op&gt; y</code> , : <code>&lt;op&gt;</code>    (: <code>+</code> , <code>-</code> ,  .).  ,   <code>&lt;op&gt;</code>   <code>:</code> ,    - (..    ,  ).        : </p><br><pre> <code class="hljs cmake">//  <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = x :: <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> list1 = list2 ::: list1 stream = x <span class="hljs-comment"><span class="hljs-comment">#:: stream stream1 = stream2 #::: stream1 //  list ::= x list1 :::= list2 stream #::= x stream1 #:::= stream2</span></span></code> </pre> <br><p>   . <br>    <code>Set</code> , <code>Map</code> , <code>Iterator</code> (  ). </p><br><h4 id="ne-privodite-kollekcii-k-zadannomu-tipu-vruchnuyu">        </h4><br><pre> <code class="hljs cmake">//  seq.foldLeft(<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>.empty)(_ + _) seq.foldRight(<span class="hljs-keyword"><span class="hljs-keyword">List</span></span>.empty)(_ :: _) //  seq.toSet seq.toList</code> </pre> <br><p>     ,   ,  .           ,      ,  . <br>   : <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </p><br><h4 id="beregites-toseq-dlya-nestrogih-kollekciy">  <code>toSeq</code>   . </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  (seq: TraversableOnce[T]) seq.toSeq //  seq.toStream seq.toVector</span></span></code> </pre> <br><p> - ,  <code>Seq(...)</code>    ( , <a href="https://www.scala-lang.org/api/current/index.html">Vector</a> ),     <code>toSeq</code>     ( <code>Stream</code> , <code>Iterator</code>  <code>view</code> )   .  <code>TraversableOnce.toSeq</code>     <code>Stream</code> ,   ,          .      ,       ,    . </p><br><p>      : </p><br><pre> <code class="hljs lua">val source = Source.fromFile(<span class="hljs-string"><span class="hljs-string">"lines.txt"</span></span>) val <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> = source.getLines.toSeq source.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">foreach</span></span>(println)</code> </pre> <br><p>    <code>IOException</code> ,   ,    . </p><br><p>     ,   <code>toStream</code>  ,       ,  <code>toVector</code>  <code>toSeq</code> . </p><br><h4 id="ne-privodite-k-strokovomu-tipu-vruchnuyu">       </h4><br><pre> <code class="hljs perl">//  (seq: Se<span class="hljs-string"><span class="hljs-string">q[String]</span></span>) seq.reduce(<span class="hljs-number"><span class="hljs-number">_</span></span> + <span class="hljs-number"><span class="hljs-number">_</span></span>) seq.reduce(<span class="hljs-number"><span class="hljs-number">_</span></span> + separator + <span class="hljs-number"><span class="hljs-number">_</span></span>) seq.fold(prefix)(<span class="hljs-number"><span class="hljs-number">_</span></span> + <span class="hljs-number"><span class="hljs-number">_</span></span>) seq.map(<span class="hljs-number"><span class="hljs-number">_</span></span>.toString).reduce(<span class="hljs-number"><span class="hljs-number">_</span></span> + <span class="hljs-number"><span class="hljs-number">_</span></span>) // seq: Se<span class="hljs-string"><span class="hljs-string">q[T]</span></span> seq.foldLeft(new StringBuilder())(<span class="hljs-number"><span class="hljs-number">_</span></span> append <span class="hljs-number"><span class="hljs-number">_</span></span>) //  seq.mkString seq.mkString(prefix, separator, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br><p>      ,       <code>StringBuilder</code> . </p><br><ul><li>   : <code>reduceLeft</code> , <code>reduceRight</code> , <code>foldLeft</code> , <code>foldRight</code> . </li><li>   : <code>Set</code> , <code>Option</code> , <code>Iterator</code> . </li></ul><br><h2 id="5-mnozhesva-sets"> 5.  (Sets) </h2><br><p>           .  ,      . </p><br><h4 id="ne-ispolzuyte-sameelements-dlya-sravneniya-neuporyadochennyh-kollekciy">   <code>sameElements</code>     </h4><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  set1.sameElements(set2) //  set1 == set2</span></span></code> </pre> <br><p>        (  ),       . </p><br><p>  <code>sameElements</code>       ,         ,          . <br>     ,      : , <code>LinkedHashSet</code> . <br>   : <code>Map</code> . </p><br><h4 id="ispolzuyte-ekzemplyar-set-kak-obekt-funkciyu">   Set  - </h4><br><pre> <code class="hljs perl">//  (set: Set[Int]) Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.filter(set(<span class="hljs-number"><span class="hljs-number">_</span></span>)) Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.filter(set.contains) //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.filter(set)</code> </pre> <br><p>   <code>Set[T]</code>    <code>Function1[T, Boolean]</code> ,       . </p><br><h4 id="ne-vychislyayte-peresecheniya-mnozhestv-vruchnuyu">      </h4><br><pre> <code class="hljs pgsql">//  set1.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(set2.contains) set1.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(set2) //  set1.<span class="hljs-keyword"><span class="hljs-keyword">intersect</span></span>(set2) //  set1 &amp; set2</code> </pre> <br><p>   ,      . <br>      ,   ,            . </p><br><h4 id="ne-vychislyayte-raznicu-mnozhestv-vruchnuyu">      </h4><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  set1.filterNot(set2.contains) set1.filterNot(set2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  set1.diff(set2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  set1 &amp;~ set2</span></span></code> </pre> <br><p>  ,   ,      . <br> ,       ,        . </p><br><h2 id="6-options"> 6. Options </h2><br><p>  <code>Option</code>    Scala ,     (    ..)        ,   ,      - . </p><br><p>          Option.  ,   ,   <code>Option</code> API. </p><br><h3 id="61-znachenie"> 6.1  </h3><br><h4 id="ne-sravnivayte-znacheniya-option-s-none">    Option  <code>None</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined</code> </pre> <br><p>  ,     ,    ,      <code>Option</code> . <br>       ,        <code>Option[T]</code>  <code>T</code> , scalac    (   ),       . </p><br><h4 id="ne-sravnivayte-znacheniya-option-s-some">    <code>Option</code>  <code>Some</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(v) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(v) //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.contains(v) !<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.contains(v)</code> </pre> <br><p>    . </p><br><h4 id="ne-polagaytes-isinstanceof-dlya-proverki-nalichiya-elementa">   <code>isInstanceOf</code>     </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>[_]] //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined</code> </pre> <br><p>     . </p><br><h4 id="ne-pribegayte-k-sopostavleniyu-s-obrazcom-dlya-proverki-suschestvovaniya">          </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(_) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(_) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isEmpty</code> </pre> <br><p>  ,      ‚Äî     .  ,     . <br>   : <code>Seq</code> , <code>Set</code> . </p><br><h4 id="ne-otricayte-znacheniya-svoystv-svyazannyh-s-suschestvovaniem">    ,    </h4><br><pre> <code class="hljs pgsql">//  !<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isEmpty !<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined !<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.nonEmpty //  seq.isDefined seq.isEmpty seq.isEmpty</code> </pre> <br><p>   ,     ‚Äî      ,   . <br> ,     : <code>isDefined</code> (  option)  <code>nonEmpty</code> (  ). ,          <code>Option</code>  . </p><br><h3 id="62-null"> 6.2 Null </h3><br><h4 id="ne-vypolnyayte-yavnoe-sravnenie-znacheniy-s-null-chtoby-sozdat-option">       <code>null</code> ,   <code>Option</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(v) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> //  <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>(v)</code> </pre> <br><p>        . </p><br><h4 id="ne-predostavlyayte-null-kak-yavnuyu-alternativu">   <code>null</code>    </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.getOrElse(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.orNull</code> </pre> <br><p>         ,   . </p><br><h3 id="63-obrabotka"> 6.3  </h3><br><p>    ,   ,    <code>Option</code> . </p><br><p>  <a href="https://www.scala-lang.org/api/current/index.html"></a> ,   <code>Option</code> , ,  ¬´     <code>Option</code> ‚Äî             <code>map</code> , <code>flatMap</code> , <code>filter</code>  <code>foreach</code> ¬ª.      ,   "check &amp; get" ( <em>  </em> ) ,      <code>if</code>    . <br>  ‚Äî ,   ¬´¬ª : </p><br><ul><li>    , </li><li>   <code>NoSuchElementException</code>  <code>MatchError</code>     </li></ul><br><p>      . </p><br><h4 id="ne-emuliruyte-getorelse">   <code>getOrElse</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; it <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; z } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.getOrElse(z)</code> </pre> <br><h4 id="ne-emuliruyte-orelse">   <code>orElse</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (option1.isDefined) option1 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> option2 option1 match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; option2 } //  option1.orElse(option2)</code> </pre> <br><h4 id="ne-emuliruyte-exists-1">   <code>exists</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined &amp;&amp; p(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) p(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; p(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p)</code> </pre> <br><h4 id="ne-emuliruyte-forall-1">   <code>forall</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isEmpty || (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined &amp;&amp; p(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) p(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; p(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.forall(p)</code> </pre> <br><h4 id="ne-emuliruyte-contains">   <code>contains</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> == x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> == x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; it == x <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.contains(x)</code> </pre> <br><h4 id="ne-emuliruyte-foreach">   <code>foreach</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) f(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; f(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(f)</code> </pre> <br><h4 id="ne-emuliruyte-filter-1">   <code>filter</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined &amp;&amp; p(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) &amp;&amp; p(it) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(p)</code> </pre> <br><h4 id="ne-emuliruyte-map-1">   <code>map</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(f(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(f(it)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.map(f)</code> </pre> <br><h4 id="ne-emuliruyte-flatmap-1">   <code>flatMap</code> </h4><br><pre> <code class="hljs pgsql">//  (f: A =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[B]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isDefined) f(<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span> match { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(it) =&gt; f(it) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> } //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.flatMap(f)</code> </pre> <br><h3 id="64-pererabatyvaem"> 6.4  </h3><br><h4 id="privodim-cepochku-iz-map-i-getorelse-v-fold">    <code>map</code>  <code>getOrElse</code>  <code>fold</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.map(f).getOrElse(z) //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.fold(z)(f)</code> </pre> <br><p>     (   <code>z</code>    ‚Äî  ),    .       (-      Scala),       . </p><br><p>   ,     <a href="https://www.reddit.com/r/scala/comments/2z411u/scala_collections_tips_and_tricks/cqiip08/"></a> - ,      ,       . </p><br><h4 id="ne-emuliruyte-exists-2">   <code>exists</code> </h4><br><pre> <code class="hljs pgsql">//  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.map(p).getOrElse(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(p)</code> </pre> <br><p>        (    <code>Option</code> ).     <code>getOrElse</code> . </p><br><h4 id="ne-emuliruyte-flatten-1">   <code>flatten</code> </h4><br><pre> <code class="hljs pgsql">//  (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[T]]) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.map(_.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.getOrElse(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) //  <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.flatten</code> </pre> <br><p>    . </p><br><h4 id="ne-konvertiruyte-option-v-seq-vruchnuyu">   <code>Option</code>  <code>Seq</code>  </h4><br><pre> <code class="hljs perl">//  option.map(Se<span class="hljs-string"><span class="hljs-string">q(_)</span></span>).getOrElse(Seq.empty) option.getOrElse(Seq.empty) // option: Option[Se<span class="hljs-string"><span class="hljs-string">q[T]</span></span>] //  option.toSeq</code> </pre> <br><p>     ,       . </p><br><h2 id="7-tablicy"> 7.  </h2><br><p>      ,        ,      . </p><br><h4 id="ne-vypolnyayte-poisk-znacheniy-vruchnuyu">      </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.find(_._1 == k).<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._2) //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.get(k)</code> </pre> <br><p>  ,     ,     - ,  <code>Map</code>      (, ) ‚Äî        .  ,       . </p><br><h4 id="ne-ispolzuyte-get-kogda-neobhodimo-syroe-znachenie">   <code>get</code> ,     </h4><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> map.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k).<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> map(k)</code> </pre> <br><p>     <code>Option</code> ,    <em>(raw)</em> . </p><br><h4 id="ne-ispolzuyte-lift-vmesto-get">   <code>lift</code>  <code>get</code> </h4><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> map.lift(k) // <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> map.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k)</code> </pre> <br><p>    ,        (   ),           .  <code>lift</code>  ,     ( <code>Map</code>  <code>PartialFunction</code> )     . </p><br><h4 id="ne-vyzyvayte-get-i-getorelse-razdelno">   <code>get</code>  <code>getOrElse</code>  </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.get(k).getOrElse(z) //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.getOrElse(k, z)</code> </pre> <br><p>      ,      .    <code>z</code>  ,  . </p><br><h4 id="ispolzuyte-ekzemplyar-map-v-kachestve-obekta-funkcii">   Map   - </h4><br><pre> <code class="hljs perl">//  (<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>: Map[Int, T]) Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.map(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span>)) //  Se<span class="hljs-string"><span class="hljs-string">q(1, 2, 3)</span></span>.map(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>)</code> </pre> <br><p>    Map[K, V]   Function1[K, V],      . </p><br><h4 id="ne-izvlekayte-klyuchi-vruchnuyu">     </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._1) <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._1).toSet <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._1).toIterator //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.keys <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.keySet <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.keysIterator</code> </pre> <br><p>      (   ). </p><br><h4 id="ne-izvlekayte-znacheniya-vruchnuyu">     </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._2) <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(_._2).toIterator //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.values <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.valuesIterator</code> </pre> <br><p>    (  ). </p><br><h4 id="budte-ostorozhny-s-filterkeys">    <code>filterKeys</code> </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.filterKeys(p) //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.filter(p(_._1))</code> </pre> <br><p>  <code>filterKeys</code>      - .     ,       <code>filterKeys</code>  .      ,  ,         , ,  <code>filterKeys(p).groupBy(???)</code> . </p><br><p>      ¬´¬ª ( ,     ) ‚Äì        , -       . </p><br><p>  <code>filterKeys</code> ,  ,    , -  <a href="https://issues.scala-lang.org/browse/SI-4776">  </a> ,    .        <code>withKeyFilter</code> (   <code>withFilter</code> ). </p><br><p>  ,     <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">  </a>    . </p><br><p>   ,      <code>filterKeys</code>   (       ,        ),         . </p><br><p>  ,      ,  ( )  ,      ,   : </p><br><pre> <code class="hljs markdown">type MapView[<span class="hljs-string"><span class="hljs-string">A, +B</span></span>] = Map[<span class="hljs-string"><span class="hljs-string">A, B</span></span>] implicit class MapExt[<span class="hljs-string"><span class="hljs-string">A, +B</span></span>](<span class="hljs-link"><span class="hljs-link">val map: Map[A, B]</span></span>) extends AnyVal { def withKeyFilter(p: A =&gt; Boolean): MapView[A, B] = map.filterKeys(p) }</code> </pre> <br><p>     <code>MapView</code>  ,  ,     view-.       : </p><br><pre> <code class="hljs swift">def <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k: <span class="hljs-type"><span class="hljs-type">T</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(k)) <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span></code> </pre> <br><h4 id="budte-ostorozhny-s-mapvalues">    <code>mapValues</code> </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.mapValues(f) //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(f(_._2))</code> </pre> <br><p>   ,     .       : </p><br><pre> <code class="hljs markdown">type MapView[<span class="hljs-string"><span class="hljs-string">A, +B</span></span>] = Map[<span class="hljs-string"><span class="hljs-string">A, B</span></span>] implicit class MapExt[<span class="hljs-string"><span class="hljs-string">A, +B</span></span>](<span class="hljs-link"><span class="hljs-link">val map: Map[A, B]</span></span>) extends AnyVal { def withValueMapper[<span class="hljs-string"><span class="hljs-string">C</span></span>](<span class="hljs-link"><span class="hljs-link">f: B =&gt; C</span></span>): MapView[A, C] = map.mapValues(f) }</code> </pre> <br><p>     : </p><br><pre> <code class="hljs swift">def <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k: <span class="hljs-type"><span class="hljs-type">T</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(k).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(f)</code> </pre> <br><h4 id="ne-otfiltrovyvayte-klyuchi-vruchnuyu">     </h4><br><pre> <code class="hljs vhdl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>.filterKeys(!seq.contains(_)) //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> <span class="hljs-comment"><span class="hljs-comment">-- seq</span></span></code> </pre> <br><p>      ,   . </p><br><h4 id="ispolzuyte-operatory-pereprisvaivaniya-tablic">     </h4><br><pre> <code class="hljs perl">//  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> map1 = map1 ++ map2 <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> -- seq //  <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> += <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">y</span></span> map1 ++= map2 <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> -= <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> --= seq</code> </pre> <br><p> ,    ,          . </p><br><h2 id="8-dopolnenie"> 8.  </h2><br><p>            <a href="http://docs.scala-lang.org/overviews/collections/introduction.html">   Scala</a> ,     . </p><br><p>  See also: </p><br><ul><li> <a href="https://pavelfatin.com/scala-for-project-euler/">Scala for Project Euler</a> ‚Äî        Scala. </li><li> <a href="https://pavelfatin.com/ninety-nine/">Ninety-nine</a> ‚Äî     Scala, Java, Clojure  Haskell (  ). </li></ul><br><p>             Scala. </p><br><p>      ,     .  , -     ,    .   . </p><br><h3 id="ot-perevodchika">   </h3><br><p>         .       (    ).  <a href="https://habrahabr.ru/users/firegurafiku/" class="user_link">firegurafiku</a>     ,     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333362/">https://habr.com/ru/post/333362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333352/index.html">Applications in the electronic document management system. Part 6: Views</a></li>
<li><a href="../333354/index.html">World Champions - about sports programming</a></li>
<li><a href="../333356/index.html">BFGS method or one of the most effective optimization methods. Python implementation example</a></li>
<li><a href="../333358/index.html">How not to wind rating on Habr√©</a></li>
<li><a href="../333360/index.html">The balance between security devices in proxy mode and the impact on network performance</a></li>
<li><a href="../333364/index.html">Identify numbers with CallKit</a></li>
<li><a href="../333366/index.html">How much is your company worth? Brief on business valuation</a></li>
<li><a href="../333368/index.html">Startup cycle: how (in general) venture investment works</a></li>
<li><a href="../333372/index.html">Reverse engineering one line javascript</a></li>
<li><a href="../333374/index.html">Security Week 28: Petya was difficult to open, the Broadcomm chipset bug was closed in Android, Copycat infected 14 million devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>