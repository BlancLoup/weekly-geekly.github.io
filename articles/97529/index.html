<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Configuring iSCSI initiator on linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abstract: how open-iscsi works (iSCSI initiator in linux), how to configure it and a little bit about the iSCSI protocol itself. 

 Lyrics: There are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Configuring iSCSI initiator on linux</h1><div class="post__text post__text-html js-mediator-article">  Abstract: how open-iscsi works (iSCSI initiator in linux), how to configure it and a little bit about the iSCSI protocol itself. <br><br>  Lyrics: There are many articles on the Internet that explain quite well how to set up an ISCSI target, however, for some reason, there are practically no articles about working with the initiator.  Despite the fact that the target is technically more complicated, the administrative fuss with initiator is more - there are more complicated concepts and not very obvious principles of work. <br><br><img src="http://img825.imageshack.us/img825/8141/iscsisan.gif" align="left"><h1>  ISCSI </h1><br>  Before you talk about iSCSI - a few words about the different types of remote access to information in modern networks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  NAS vs SAN </h2>  There are two methods of accessing data located on another computer: file (when a file is requested from a remote computer, and which file systems do this - no one cares), characteristic representatives of NFS, CIFS (SMB);  and block - when blocks are requested from a remote computer from disk media (in the same way as they are read from a hard disk).  In this case, the requesting party itself does the file system on the block device, and the server giving the block device does not know about the file systems on it.  The first method is called NAS (network attached storage), and the second is SAN (storage area network).  The names generally point to other signs (SAN implies a dedicated network to the storage), but it so happens that the NAS is the file, and the SAN is the block device over the network.  And although everyone (?) Understands that these are wrong names, the further, the more they are fixed. <br><a name="habracut"></a><br><h2>  scsi over tcp </h2>  One of the protocols to access block devices is iscsi.  The letter 'i' in the title does not refer to the production of Apple, but to Internet <s>Explorer</s> .  At its core, it is 'scsi over tcp'.  The SCSI protocol itself (without the letter 'i') is a very complex structure, since it can work through different physical environments (for example, UWSCSI - parallel bus, SAS - serial - but the protocol is the same).  This protocol allows you to do much more than just ‚Äústick disks to a computer‚Äù (as invented in SATA), for example, it supports device names, the presence of several links between the block device and the consumer, switching support (yeah, SAS switch, such in nature), connecting several consumers to one block device, etc.  In other words, this protocol was simply requested as the basis for a network block device. <br><br><h2>  Terminology </h2>  The following terms are used in the SCSI world: <br>  <b>target</b> is the one who provides the block device.  The closest analogue from the ordinary computer world is the server. <br>  <b>initiator</b> - the client, the one who uses the block device.  Analog client. <br>  <b>WWID</b> - unique identifier of the device, its name.  Analog DNS name. <br>  <b>LUN</b> - the number of "piece" of the disk, which is accessed.  The closest analogue is the partition on the hard disk. <br><br>  ISCSI brings the following changes: WWID disappears, the concept of IQN (iSCSI Qualified Name) comes into its place - that is, a pure name that is similar to the extent of mixing with the DNS (with slight differences).  Here is an example of IQN: iqn.2011-09.test: name. <br><br>  IETD and open-iscsi (server and client under Linux) bring another very important concept, which is not often written about in the iscsi tutorials - portal.  Portal is, to put it bluntly, several target'ov, which are announced by one server.  There are no analogies with www, but if the web server could be asked to list all of its virtualhosts, that would be it.  portal indicates the list of target'and available IP, which can be accessed (yes, iscsi supports multiple routes from initiator to target). <br><br><h1>  target </h1><br>  The article is not about target, so I give a very brief description of what target does.  He takes the block device, sends the name and the LUN to it and publishes it on his portal, after which he allows everyone (authorization to taste) to access it. <br><br>  Here is an example of a simple configuration file, I think it will be clear from it what the target is doing (configuration file using the IET example): <br><br><pre> Target iqn.2011-09.example: data
         IncomingUser username Pa $$ w0rd
         Lun 0 Path = / dev / md1
</pre><br><br>  (complex from simple differs only in export options).  Thus, if we have a target, then we want to connect it.  And here begins the difficult, because initiator has its own logic, it is not at all like the trivial mount for nfs. <br><br><h1>  Initiator </h1><br>  Open-iscsi is used as an initiator.  So, the most important thing is that it has <em>modes of operation</em> and <em>state</em> .  If we give the command in the wrong mode or if we do not take into account the state, the result will be extremely discouraging. <br><br>  So, the modes of operation: <ul><li>  Search target'ov (discovery) </li><li>  Connect to target </li><li>  Work with connected target </li></ul><br>  From this list, the life cycle is quite understandable - first find, then connect, then disconnect, then reconnect.  Open-iscsi keeps the session open, even if the block device is not in use.  Moreover, it keeps the session open (up to certain limits, of course), even if the server went into reboot.  An iscsi session is not the same as an open TCP connection, iSCSI can transparently reconnect to the target.  Disconnect / connect - operations that are controlled "outside" (either from other software or by hand). <br><br>  A little about the state.  After discovery, open-iscsi <em>remembers</em> all found target's (they are stored in / etc / iscsi /), in other words, discovery is a constant operation, NOT at all appropriate, for example, dns resolving).  Found targets can be removed by hand (by the way, a common mistake is when in open-iscsi, as a result of experiments and settings, a bunch of target'es found, when trying to login to which many errors creep out due to the fact that half of target'ov are a config that no longer exists on the server, but I remember open-iscsi).  Moreover, open-iscsi allows you to change the settings of the stored target, and this ‚Äúmemory‚Äù influences further work with the targets even after the daemon is rebooted / restarted. <br><br><h1>  Block device </h1><br>  The second question that torments many in the beginning is - where does it go after connecting?  open-iscsi creates a network device, albeit a SCSI class (it‚Äôs not for nothing that I‚Äôm telling me), that is, it gets a letter in the / dev / sd family, for example, / dev / sdc.  The first free letter is used, since  For the rest of the system, this block device is a typical hard disk, no different from that connected via usb-sata or simply directly to sata. <br><br>  This often causes a panic "how can I find out the name of the block device?".  It is output in the detailed output of iscsiadm (# iscsiadm -m session -P 3). <br><br><h1>  Authorization </h1><br>  Unlike SAS / UWSCSI, iSCSI is available for connection to just anyone.  To protect against these, there is a login and password (chap), and their transfer to iscsiadm is another headache for novice users.  It can be done in two ways - by changing the properties of the target that has already been found and writing the login / password in the open-iscsi configuration file. <br>  The reason for such difficulties is that the password and the login process are attributes of the system, not the user.  ISCSI is a cheap version of the FC infrastructure, and the concept of "user" in the context of the person behind the keyboard is not applicable here.  If you have a sql-base on an iscsi block device, then of course, you would like the sql-server to be started by itself, and not after a minute of personal attention of the operator. <br><br><h1>  configuration file </h1><br>  This is a very important file, because in addition to the login / password, it also describes the behavior of open-iscsi when finding errors.  It may give the error "back" not immediately, but with a pause (for example, about five minutes, which is enough to reload the server with data).  Also, the login process is controlled there (how many times to try, how long to wait between attempts) and any fine tuning of the work process itself.  Note, these parameters are quite important for work and you need to understand how your iscsi will lead if you remove the power cord for 10-20s, for example. <br><br><h1>  Quick Reference </h1><br>  I don‚Äôt like to quote easily accessible mana and lines, so I‚Äôll give a typical iscsi usage scenario: <br><br>  first we find the target we need, for this we need to know the IP / dns-name of the initiator: <code>iscsiadm -m discovery -t st -p 192.168.0.1</code> -t st is the send targets command. <br><br>  <code>iscsiadm -m node</code> (list found for login) <br>  <code>iscsiadm -m node -l -T iqn.2011-09.example:data</code> (login, that is, connect and create a block device). <br>  <code>iscsiadm -m session</code> (display a list of what you are connected to) <br>  <code>iscsiadm -m session -P3</code> (output it, but in more detail - at the very end of the output there will be an indication of which block device to which target belongs). <br>  <code>iscsiadm - m session -u -T iqn.2011-09.example:data</code> (log out of a particular) <br>  <code>iscsiadm -m node -l</code> (login to all detected target) <br>  <code>iscsiadm -m node -u</code> (log out of all target) <br>  <code>iscsiadm -m node --op delete -T iqn.2011-09.example:data</code> delete the target from the detected ones. <br><br><h1>  mulitpath </h1><br>  Another important question in serious decisions is the support of several routes to the source.  The beauty of iscsi is in using the usual ip, which can be processed in the usual way, like any other traffic (although in practice it is usually not routed, but only switched - the load is too great there).  So, iscsi supports multipath in the ‚Äúdo not resist‚Äù mode.  By itself, open-iscsi does not know how to connect to several IP of the same target.  If it is connected to several IPs of the same target, this will lead to the appearance of several block devices. <br><br>  However, the solution is - it is multipathd, which finds disks with the same identifier and processes them as expected in multipath, with customizable policies.  This article is not about multipath, so I will not explain in detail the mystery of the process, however, here are some important points: <br><ol><li>  When using multipath, you should set small timeouts - switching between bad paths should happen quickly enough </li><li>  Under more or less fast channel conditions (10G and higher, in many cases gigabit), parallelism of load should be avoided, since the opportunity to use bio coalesing is lost, which in some types of load can unpleasantly hit the target. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/97529/">https://habr.com/ru/post/97529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../97517/index.html">Sausage line for iPhone 4 in Paris</a></li>
<li><a href="../97518/index.html">In the new contextual advertising service, I will first of all be attracted to:</a></li>
<li><a href="../97520/index.html">SanDisk has released a flash card with a hundred year warranty.</a></li>
<li><a href="../97522/index.html">Money for a startup do it yourself</a></li>
<li><a href="../97526/index.html">Tagsrating.com - directory of sites, distributed by tag</a></li>
<li><a href="../97530/index.html">Making the code ‚Üí Separator first</a></li>
<li><a href="../97532/index.html">Promising startup in the field of social networks is looking for a programmer</a></li>
<li><a href="../97534/index.html">Briefly about the competence of employees OpSoSov</a></li>
<li><a href="../97536/index.html">Dance of Nao robots from Aldebaran Robotics at the exhibition Shanghai Expo 2010</a></li>
<li><a href="../97537/index.html">Toshiba Satellite L500-1WP Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>