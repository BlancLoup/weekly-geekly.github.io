<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We protect the mobile application with the help of "CryptoPro": step by step instructions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes work with one of the largest Russian suppliers of cryptographic information protection and electronic digital signature - the co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We protect the mobile application with the help of "CryptoPro": step by step instructions</h1><div class="post__text post__text-html js-mediator-article">  The article describes work with one of the largest Russian suppliers of cryptographic information protection and electronic digital signature - the company CryptoPro, which occupies a leading position in Russia.  Considered importing the framework for iOS and pitfalls during importing, its use for creating and verifying electronic digital signatures, as well as authorization using a private key. <br><img src="https://habrastorage.org/webt/59/e9/a9/59e9a98e76a08555642880.png"><br><a name="habracut"></a><br><h4>  Work with CryptoPro </h4><br>  I would just like to say that the implementation of such a level of protection and functionality in mobile applications, in principle, cannot be as simple as rolling a page or sending a request to a server.  You will have to read and learn anyway, especially if you have never worked with cryptography and secure connection through TLS before. <br><br>  The CryptoPro company provides mobile developers with a powerful tool for implementing such complex functionality into their application for free, but there is also a fly in the ointment.  Unfortunately, for a long time the company's existence has not been made convenient and understandable documentation.  Separately for mobile developers, it is not in principle. <br><br>  Development sooner or later will lead you to the forum, and you will have to shovel it to find the answer.  The greatest difficulty is the lack of information about what and how to do - we will try to fix this in our article.  All links to resources that may be useful will be left at the end of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You will also have to work with C ++ and take care of allocating and clearing the memory yourself. <br>  It is worth noting that the article was written with the current version of CryptoPro CSP 4.0, therefore the packages for developers described below may differ in the future. <br><br><h4>  Import of CryptoPro into a mobile application </h4><br>  The first step to use CryptoPro in your application is to implement the framework downloaded from the company's website.  In addition to the framework, the package for iOS also contains three examples - the creation of an electronic signature (EDS), the creation of an ssl tunnel and an example that allows you to assemble a browser that has the functionality to create and verify digital signature on web pages.  A detailed description is contained within the examples in the Readme files.  On their basis, it is easier to understand the algorithm of actions.  The MacOS package helps a lot: it contains many useful examples with detailed comments.  After its installation, all the examples will be on the disk in the opt / cprocsp / src / doxygen / CSP section. <br><br>  Instructions for importing the framework itself is in CPROCSP.framework in the ReadMe file, we will sort it out by paragraphs. <br><br>  1. You are required to go to the console and set the path to the downloaded framework, then run the utility, as described below: <br><pre><code class="hljs coffeescript">cd <span class="hljs-regexp"><span class="hljs-regexp">/Users/agima/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ios-uni/CPROCSP.framework/</span></span> ./ SetApplicationLicense <span class="hljs-number"><span class="hljs-number">40400</span></span>-W0037-EKVQK<span class="hljs-number"><span class="hljs-number">-9</span></span>YDNG-D3F67 license.enc</code> </pre> <br>  (the specified key is attached in the file, then the license file license.enc will be created in the same directory). <br><br>  2. Before importing the framework, we recommend moving its CPROCSP.framework file to the project folder.  So you protect yourself from accidentally transferring the framework to another folder, which is why the paths in Xcode will ‚Äúfly off‚Äù. <br>  Now to import: open Xcode, select the project in the left sidebar and select the build target in the targets list <br><br><img src="https://habrastorage.org/webt/59/e9/ab/59e9ab0c072ab046075814.jpeg"><br><br>  Next, in the Build Phases tab, select Link Binary With Libraries, click on ‚Äú+‚Äù and then Add other to specify the path to the framework manually.  Find it and choose Open.  The framework is imported, but it will not work yet. <br><br><img src="https://habrastorage.org/webt/59/e9/ab/59e9ab5ea8da7553896634.jpeg"><br><br>  3. Create the Resources folder in the project, open the CPROCSP.framework file, go to the Resources folder and drag all files and folders, except for localization (ru.lroj and en.lproj), to the folder we created with these settings: <br><br><img src="https://habrastorage.org/webt/59/e9/ab/59e9ab9911496979977410.jpeg"><br><br>  4. Drag and drop into the same folder the license file created in the first paragraph, with the settings as in the screenshot above. <br><br>  5. Now we transfer the remaining localization folders also to the Resources of the application, but with different settings: <br><br><img src="https://habrastorage.org/webt/59/e9/ac/59e9ac7e2e1d1549577429.jpeg"><br><br>  If done correctly, the folders will look like this: <br><br><img src="https://habrastorage.org/webt/59/e9/b2/59e9b26d5ab35782802287.jpeg"><br><br>  6. The next item is setting up the project for debugging in the emulator.  If this is not done, the application can only be launched on the device.  In the Build Settings tab of the project, in the Valid Architectures field, leave only armv7.  Work to support 64-bit architecture is already underway, but for now we are using 32-bit.  Also in Architectures we write Optimized (armv7).  You should have the following: <br><br><img src="https://habrastorage.org/webt/59/e9/b2/59e9b29b8664b935658648.jpeg"><br><br>  This is where the attached instruction ends, but you won‚Äôt be able to start the application - you will see something like this when compiling: <br><br><img src="https://habrastorage.org/webt/59/e9/b8/59e9b884ee6ef989763116.jpeg"><br><br>  It is not clear for what reasons the developers did not add a couple of points, but for correct linking you need to add some more libraries and a ‚Äúmagic flag‚Äù.  Now more. <br><br>  Similar to the scheme described in paragraph 2, we get to the CPROCSP.framework file, go to the reader folder and import the library librdrpcsc_empty.o, which has been dusty there.  We add the following library from those laid out in Xcode; to do this, we enter libz in the same window in the search. <br><br><img src="https://habrastorage.org/webt/59/e9/b8/59e9b8bd140db770685723.jpeg"><br><br>  and add it with the Add button. <br><br>  But this will also not be enough, there will be another mistake: <br><br><img src="https://habrastorage.org/webt/59/e9/b8/59e9b8fd02226004874962.jpeg"><br><br>  To solve it, place a flag anywhere in the project. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> USE_CACHE_DIR; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> USE_CACHE_DIR = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><br>  After that, the problem will be solved and the application will be collected successfully.  This flag indicates where you want to store the folder with the keys.  In the case of false (as we used, the reason will be revealed later) the folder is used <br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">private</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/root/<span class="hljs-type"><span class="hljs-type">Documents</span></span>/cprocsp/keys</code> </pre> <br><br>  If you set true, then they will be stored in a closed place: <br><br><pre> <code class="hljs delphi">/<span class="hljs-keyword"><span class="hljs-keyword">private</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/root/<span class="hljs-keyword"><span class="hljs-keyword">Library</span></span>/Caches/cprocsp/keys/</code> </pre> <br><br>  This completes the import of the framework, and you can run the application on the emulator. <br><br><h4>  The container of the private key to work with "CryptoPro" </h4><br>  At the time of writing, CryptoPro CSP 4.0 does not support working with * .pfx certificates, which contain both public and private keys.  It is necessary to use * .000 containers, which can be obtained only with the use of CryptoPro;  their format is not described anywhere, and they are written, as a rule, on key carriers, tokens (flash drives, diskettes).  In the explorer, they look like folders that contain one key, divided into files header.key, masks.key, name.key and primary.key. <br><br>  The company also has a test <a href="https://www.cryptopro.ru/certsrv/">certification center</a> (CA), where you can generate keys and get a CA certificate.  Here it is necessary to add that for the certificate request page to work correctly, you need to use Internet Explorer (or any other browser with the plugin installed that can be downloaded in the test CA), and CSP must be installed on the computer, otherwise The necessary hash algorithms are not available. GOST R 34.10-2012. <br><br><h4>  Installing the private key container in the application </h4><br>  As the CryptoPro employees themselves write, there are three options for installing the container on the device: <br><br>  ‚Ä¢ Via iTunes File Sharing. <br>  ‚Ä¢ Use a separate application to write files on iOS, such as iExplorer. <br>  ‚Ä¢ Write your own key export to blob (PRIVATEKEYBLOB) and import it in the application code.  An example of this is in the above MacOS package called EncryptKey / DecryptKey. <br><br>  We used the first option - as the fastest and satisfying customer requirements.  For its implementation, the flag USE_CACHE_DIR = false was selected during import;  if iTunes File Sharing will not be used by you, or you want to hide from the user the ability to look into the folder with the keys, it is better to hide it by setting the flag to true. <br>  After the first launch with the framework installed, the cprocsp folder will be created in the Documents folder of the application: <br><br><img src="https://habrastorage.org/webt/59/e9/b9/59e9b9750f1ea444730870.jpeg"><br><br>  Inside this folder are all the key containers.  Installed certificates and containers are stored and belong to the application, and not to the key storage device, so after its removal, you will need to install them again. <br><br>  Then there are two ways: write all the functions yourself or use a ready-made controller, and since it is enough for most tasks, let's talk about it. <br>  The framework contains a header file called PaneViewController.h.  If you are not burdened with strict design, you can import the proposed xib files (found in CPROCSP.framework / Resources) and initialize the crypto panel through them - for example, in this way: <br><br><pre> <code class="hljs smalltalk">&lt;code&gt;<span class="hljs-symbol"><span class="hljs-symbol">#import</span></span> ‚Äú<span class="hljs-type"><span class="hljs-type">CPROCSP</span></span>/<span class="hljs-type"><span class="hljs-type">PaneViewControler</span></span>.h‚Äù ‚Ä¶ <span class="hljs-type"><span class="hljs-type">PaneViewController</span></span> *<span class="hljs-type"><span class="hljs-type">CPROPane</span></span>; if(<span class="hljs-type"><span class="hljs-type">UI_USER_INTERFACE_IDIOM</span></span>() == <span class="hljs-type"><span class="hljs-type">UIUserInterfaceIdiomPad</span></span>) <span class="hljs-type"><span class="hljs-type">CPROPane</span></span> = [[<span class="hljs-type"><span class="hljs-type">PaneViewController</span></span> alloc] initWithNibName:@<span class="hljs-comment"><span class="hljs-comment">"PaneViewController"</span></span> bundle:<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>]; else <span class="hljs-type"><span class="hljs-type">CPROPane</span></span> = [[<span class="hljs-type"><span class="hljs-type">PaneViewController</span></span> alloc] initWithNibName:@<span class="hljs-comment"><span class="hljs-comment">"PaneViewControllerIPhone"</span></span> bundle: <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>]; <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span> *navController = [[<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span> alloc] initWithRootViewController:<span class="hljs-type"><span class="hljs-type">CPROPane</span></span>]; [navController setModalPresentationStyle:<span class="hljs-type"><span class="hljs-type">UIModalPresentationFullScreen</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> presentViewController:navController animated:<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> completion:<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>];&lt;/code&gt;</code> </pre> <br><br>  But since all xib files are regular UIViews with a table, you can easily customize them for your design. <br><br><img src="https://habrastorage.org/webt/59/e9/b9/59e9b9a87d222594202387.jpeg"><br><br>  After opening the panel, the first thing that needs to be done is to go to the ‚ÄúInteraction with CA‚Äù tab, install the CA certificate (root certificate of the certification authority), go through the registration procedure, send a certificate request and obtain (install) it. <br><br><img src="https://habrastorage.org/webt/59/e9/b9/59e9b9d799fef762103407.jpeg"><br><br>  After installing the root certificate of the CA, the mobile folder should appear in the cprocsp / keys folder.  It contains * .000 containers.  To install them, go back to the CryptoPro panel and on the main screen select ‚ÄúInstall certificates and containers‚Äù.  The containers contained in the cprocsp / keys / mobile folder must be from the crypto-provider "CryptoPro" (if at least one is not or damaged, then the function will return an error without installing any of them). <br>  This completes the installation. <br><br><h4>  Signature and signature verification with private key </h4><br>  After installing the root CA certificate and the container, you can proceed to sign the documents.  The signature creation and verification features can be found in the aforementioned MacOS package called CryptMsgSign.  They contain comments on each function used.  Similar examples are in the package for iOS, in CreateFile / Classes / SignFie.cpp.  Here, unlike the previous implementation of the signature on the entry, the path to the file to be signed is supplied.  Due to the large number of functions, we will not analyze each separately.  Consider some points that are not so obvious. <br><br>  The signature function begins by opening the certificate store using <br>  CertOpenSystemStore: <br><br><pre> <code class="hljs lua">&lt;code&gt;hCertStore = CertOpenSystemStore(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"My"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!hCertStore) { ret = CSP_GetLastError(); fprintf (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"CertOpenSystemStore failed."</span></span>); }&lt;/code&gt;</code> </pre> <br>  Here it is not the key storage of the device that is meant, but the storage contained in the application in the cprocsp / users / mobile / stores folder.  The function works so that if such storage is not found, it will create it, so you can not take care of it.  When using the PaneViewController panel, the MY.sto storage will be created and used. <br>  After receiving the pointer to the certificate, extracting the private key from it, and other initializations, the signing procedure begins with the CryptMsgOpenToEncode function, which opens the message for encoding and returns a handle to the open message: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hMsg = CryptMsgOpenToEncode(TYPE_DER, // <span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, // Flags CMSG_SIGNED, // Message <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> &amp;SignedMsgEncodeInfo, // Pointer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> structure <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, // <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> content <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ID <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) // Stream information (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> used) { printf("The message to be encoded has been opened. \n"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ret = CSP_GetLastError(); fprintf (stderr, "OpenToEncode failed"); } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hMsg) CryptMsgClose(hMsg);&lt;/code&gt;</code> </pre> <br>  The message remains open until the CryptMsgClose call.  Here you should pay attention to the used flag (second parameter): if you set 0, as in the example, the signature will be attached (attached);  To obtain a detached (detached) signature, you must set the flag CMSG_DETACHED_FLAG.  After that, the signed data is placed in the message and the resulting blob can be output to a separate file. <br><br>  Signature verification is similar to its creation with a few exceptions.  First, a message is opened for decoding, then a certificate attached to the signature is pulled out.  The repository opens and searches for the attached certificate.  After the certificate has been found, the signature is verified by the CryptMsgControl function, which returns true if verification was successful and false if errors occurred: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">if</span></span>(<span class="hljs-type"><span class="hljs-type">CryptMsgControl</span></span>(hMsg, // <span class="hljs-type"><span class="hljs-type">Handle</span></span> to the message <span class="hljs-number"><span class="hljs-number">0</span></span>, // <span class="hljs-type"><span class="hljs-type">Flags</span></span> <span class="hljs-type"><span class="hljs-type">CMSG_CTRL_VERIFY_SIGNATURE</span></span>, // <span class="hljs-type"><span class="hljs-type">Control</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> pSignerCertificateInfo)) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pointer</span></span></span><span class="hljs-class"> to the </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CERT_INFO</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printf</span></span></span><span class="hljs-class">("\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nSignature</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">was</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VERIFIED</span></span></span><span class="hljs-class">.\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">"); } else { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printf</span></span></span><span class="hljs-class">("\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nThe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signature</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">was</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VERIFIED</span></span></span><span class="hljs-class">.\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">"); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ret</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CSP_GetLastError</span></span></span><span class="hljs-class">(); }&lt;/code&gt;</span></span></code> </pre> <br>  The CSP_GetLastError () function returns an error code and a short description. <br><br><h4>  Authorization using a private key </h4><br>  For authorization using a private key, we need the key itself, which is installed in the manner described above, the CA root certificate installed, the server configured with CryptoPro and added to our key trusted.  The server must support TLS version 1.2 for all devices with iOS 9 and higher, as well as have GOST cipher suites from CryptoPro. <br><br>  To connect to the server, we created a separate manager and rewrote the resume function for its NSURLSessionDataTask.  Since our application has the ability to log in both via http and https, we switched between two managers responsible for a different connection.  Creating a separate manager is necessary in order to use cipher suites from CryptoPro.  If during the handshake in Client Hello you do not put them, then when the server ‚Äúgreets you‚Äù, the TLS connection will fail because the wrong cipher suite will be selected. <br><br>  A program such as WireShark can be useful in identifying the causes of errors and obtaining detailed information on the connection.  It has the opportunity to see all the stages of a TLS connection and enough information for analysis.  Also in it, you can see which cipher suites are sent and which are supported by the server. <br><br>  As the manager who will send the necessary cipher suites, UrlRetriever which is a part of a framework is used.  When you open the header, you will see many clear functions for sending a request, but it is not immediately obvious how and what to use, especially since you will not find documentation on this on the site or on the forum.  And in the file itself there are also no comments, except for one // TODO, which the developers left :) <br>  It will not be possible to look inside the class, so we had to test everything manually and see how it works. <br><br>  To begin with, we will create the retriever itself, since for each request we will need to clear the information in it.  First, the resume function will create an instance of the class: <br><br><pre> <code class="hljs scala">#<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;<span class="hljs-type"><span class="hljs-type">CPROCSP</span></span>/<span class="hljs-type"><span class="hljs-type">CPROCSP</span></span>.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> &lt;<span class="hljs-type"><span class="hljs-type">CPROCSP</span></span>/<span class="hljs-type"><span class="hljs-type">UrlRetriever</span></span>.h&gt; <span class="hljs-type"><span class="hljs-type">UrlRetriever</span></span> *retriever = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">UrlRetriever</span></span>();    : retriever-&gt;set_verify_host(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); retriever-&gt;set_verify_server(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);&lt;/code&gt;</code> </pre> <br><br>  After that we will write heders.  Since they are already contained in our NSUrlRequest, we will take them from there and transform it into the necessary form for a retriever: <br><pre> <code class="hljs vbscript">__block UrlHeaders headers; [self.<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.allHTTPHeaderFields enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull key, NSString * _Nonnull obj, BOOL * _Nonnull <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span>) { NSString *result = [NSString stringWithFormat:@<span class="hljs-string"><span class="hljs-string">"%@: %@"</span></span>, key, obj]; std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>([result cStringUsingEncoding:[NSString defaultCStringEncoding]]); headers.push_back(*<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); }]; retriever-&gt;set_headers(headers);    : BYTE *requestBytes = (BYTE *)[self.<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.HTTPBody bytes]; retriever-&gt;set_postmessage(requestBytes, self.<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.HTTPBody.length);&lt;/code&gt;</code> </pre> <br><br>  If we log in without a certificate, then we can already send a request: <br><br><pre> <code class="hljs php">retriever-&gt;retrieve_url([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.request.URL.absoluteString cStringUsingEncoding:[NSString defaultCStringEncoding]]); &lt;/code&gt;</code> </pre> <br>  And return the answer in the completion block: <br><br><pre> <code class="hljs php">NSHTTPURLResponse *response = [[NSHTTPURLResponse alloc] initWithURL:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.request.URL statusCode:retriever-&gt;get_code() HTTPVersion:@<span class="hljs-string"><span class="hljs-string">"HTTP/1.1"</span></span> headerFields:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.request.allHTTPHeaderFields]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestCompletion(response, [NSData dataWithBytes:retriever-&gt;get_data() length:retriever-&gt;get_data_len()], nil); &lt;/code&gt;</code> </pre> <br>  And in case of an error, return error: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestCompletion(response, [[<span class="hljs-type"><span class="hljs-type">NSData</span></span> alloc] <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>], [[<span class="hljs-type"><span class="hljs-type">NSError</span></span> alloc] initWithDomain:<span class="hljs-type"><span class="hljs-type">NSURLErrorDomain</span></span> code:retriever-&gt;get_error() userInfo:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]);&lt;/code&gt;</code> </pre> <br><br>  This scenario is similar for certificate authorization, only before sending a request to the retriever, you need to write a certificate thumbprint.  There are many options for obtaining a print - we will show the most correct (in our opinion). <br>  From the examples for the signature, we take the implementation of some functions, such as CertOpenStore, for opening the repository and CertEnumCertificatesInStore - for obtaining the certificate descriptor PCCERT_CONTEXT.  After that, we write a function to get the printout in NSSting: <br><br><pre> <code class="hljs erlang">- <span class="hljs-params"><span class="hljs-params">(NSString *)</span></span>getCertificateHashFromCert:<span class="hljs-params"><span class="hljs-params">(PCCERT_CONTEXT)</span></span>certContext { BYTE *pvData = NULL; DWORD cbSize = 0; DWORD cbHash = 0; if<span class="hljs-params"><span class="hljs-params">(!CertGetCertificateContextProperty(certContext, CERT_SHA1_HASH_PROP_ID, NULL, &amp;cbSize)</span></span>) NSLog<span class="hljs-params"><span class="hljs-params">(@</span><span class="hljs-string"><span class="hljs-params"><span class="hljs-string">"CertGetCertificateContextProperty error %u"</span></span></span><span class="hljs-params">, CSP_GetLastError()</span></span>); if <span class="hljs-params"><span class="hljs-params">(pvData)</span></span> { free<span class="hljs-params"><span class="hljs-params">(pvData)</span></span>; } pvData = malloc<span class="hljs-params"><span class="hljs-params">(cbSize)</span></span>; cbHash = cbSize; if<span class="hljs-params"><span class="hljs-params">(!CertGetCertificateContextProperty(certContext, CERT_SHA1_HASH_PROP_ID, pvData, &amp;cbSize)</span></span>) NSLog<span class="hljs-params"><span class="hljs-params">(@</span><span class="hljs-string"><span class="hljs-params"><span class="hljs-string">"CertGetCertificateContextProperty error %u"</span></span></span><span class="hljs-params">, CSP_GetLastError()</span></span>); DWORD dest; if <span class="hljs-params"><span class="hljs-params">(!CryptBinaryToString(pvData, cbHash, </span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">0</span></span></span><span class="hljs-params">, NULL, &amp;dest)</span></span>) NSLog<span class="hljs-params"><span class="hljs-params">(@</span><span class="hljs-string"><span class="hljs-params"><span class="hljs-string">"CryptBinaryToString error: %u"</span></span></span><span class="hljs-params">, CSP_GetLastError()</span></span>); LPWSTR buf = malloc<span class="hljs-params"><span class="hljs-params">(dest * sizeof(TCHAR))</span></span>; if <span class="hljs-params"><span class="hljs-params">(!CryptBinaryToString(pvData, cbHash, </span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">0</span></span></span><span class="hljs-params">, buf, &amp;dest)</span></span>) NSLog<span class="hljs-params"><span class="hljs-params">(@</span><span class="hljs-string"><span class="hljs-params"><span class="hljs-string">"CryptBinaryToString error: %u"</span></span></span><span class="hljs-params">, CSP_GetLastError()</span></span>); return [[NSString alloc] initWithData:[NSData dataWithBytes:buf length:dest] encoding:[NSString defaultCStringEncoding]]; } &lt;/code&gt;</code> </pre> <br><br>  The first one is using the CertGetCertificateContextProperty function with the CERT_SHA1_HASH_PROP_ID parameter, which tells the function about the parameter to be obtained from the certificate, in this case SHA1 hash.  The function is called twice, the first one without substituting the buffer, instead it is set to NULL.  This is done to obtain the required amount of memory that needs to be allocated for the buffer.  In the second use, a buffer of the now known size is substituted.  To convert the data from an array of bytes to a string, use the function CryptBinaryToString - also twice (for the same reasons).  After that you will get beautiful view content: <br><br><pre> <code class="hljs ruby">‚Äî----<span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> CERTIFICATE-----  ‚Äî---- <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> CERTIFICATE-----&lt;<span class="hljs-regexp"><span class="hljs-regexp">/code&gt;</span></span></code> </pre> <br><br>  But for a retriever, a different format is needed.  To get the required footprint in the CryptBinaryToString flags (the third parameter) you need to write the CRYPT_STRING_HEX flag.  The resulting string will be the thumbprint, which is then placed in the retriever: <br><br><pre> <code class="hljs lisp">retriever-&gt;set_client_cert([thumbPrint cStringUsingEncoding:[NSString defaultCStringEncoding]])<span class="hljs-comment"><span class="hljs-comment">;&lt;/code&gt;</span></span></code> </pre> <br><br>  If everything is done correctly, the connection will be successfully established using GOST encryption algorithms. <br><br><h4>  useful links </h4><br>  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380252(v%3Dvs.85).aspx">MSDN</a> - a detailed description of all the functions included in their parameters, as well as working examples. <br><br>  <a href="https://www.cryptopro.ru/forum2/default.aspx%3Fg%3Dforum%26c%3D1">Forum</a> - Forum "CryptoPro" where employees answer questions every day.  Many answers to the questions have already been given, and despite their prescription (sometimes around 6 years), they can still help you. <br><br>  <a href="http://cpdn.cryptopro.ru/">Developer's Guide</a> - written by the company, which contains a list of functions included in the crypto-provider with a brief description and examples. <br><br>  <a href="http://www.lifeasbob.com/Code/ErrorCodes.aspx">Error description</a> - a large list of possible errors that occur in C ++ functions, with their code and brief description.  To get the error code, use the CSP_GetLastError function in the application code, which is part of the framework.  It stores the code of the last error received. </div><p>Source: <a href="https://habr.com/ru/post/340580/">https://habr.com/ru/post/340580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340566/index.html">Useful scripts when migrating from Oracle to PostgreSQL</a></li>
<li><a href="../340568/index.html">Creating a sky for 3D games</a></li>
<li><a href="../340574/index.html">NLTK parse</a></li>
<li><a href="../340576/index.html">Why IT and Business Network Factory and Cisco SD-Access</a></li>
<li><a href="../340578/index.html">Release DBMS InterSystems Cach√© 2017.2</a></li>
<li><a href="../340582/index.html">‚ÄúWithout the data engineer, the value of the analyst model tends to zero‚Äù - an interview with the data engineer Nikolai Markov</a></li>
<li><a href="../340584/index.html">Object Oriented Programming in Vanilla JavaScript</a></li>
<li><a href="../340586/index.html">History - one project on "Trust". Or how big the little ones get hurt</a></li>
<li><a href="../340588/index.html">SC and Unity: two boots - a pair</a></li>
<li><a href="../340590/index.html">let's live in peace</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>