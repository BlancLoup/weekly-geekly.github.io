<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interception of video in a browser or TCP sniffer under Windows on the knee (part two)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a promised addition to my previous post , which tells about an alternative technique for setting traps on functions. One of the drawbacks of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interception of video in a browser or TCP sniffer under Windows on the knee (part two)</h1><div class="post__text post__text-html js-mediator-article">  This is a promised addition to <a href="http://habrahabr.ru/post/150655/">my previous post</a> , which tells about an alternative technique for setting traps on functions.  One of the drawbacks of the implementation of traps in the previous post was the constant rewriting of the code at the beginning of the intercepted function.  As an alternative, a solution was mentioned that would not require permanent rewriting.  A schematic diagram of his work is provided here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/858/301/6e6/8583016e6427e7982cf2ee92a19b3de1.jpg" alt="image"><br>  Sources, details and explanations under the cat ... <br><a name="habracut"></a><br>  So, I took the time to finish the implementation of the "so-called.  permanent traps that do not require code rewriting when calling the original function.  The source code <a href="http://www.ziddu.com/download/20279944/Injector2_Src.zip.html">is here</a> , and the compiled version <a href="http://www.ziddu.com/download/20279668/Injector2.zip.html">is here</a> . <br><br>  We did open the can of worms or Pandora‚Äôs box, as you like.  And it's time for me to relinquish my commitment to writing the perfect interceptor, because  the number of branches and checks for its implementation smoothly translates this task into a nondeterministic area. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this regard, I have to immediately warn you that this code works correctly only for WS2_32 functions, and only within the framework of this example.  To intercept other functions, the code must be completed in the direction of a more extensive analysis of instructions at the entry point (for a specific function or for real-time analysis).  And the thing is this. <br><br>  As can be seen from the figure above, the interceptor sets traps by changing the first five bytes at the entry point to an unconditional transition to its own handler.  These bytes, which are overwritten, are stored in our structures.  In the previous example, there were no problems in this regard, since we restored the entry point to its original state each time the original function was called.  But now the conditions have changed - we will no longer rewrite bytes. <br><br>  Therefore, we will execute the first instructions of the original code from the entry point directly from the place where we copied them, and at the end we will go back to those instructions that we did not erase.  And here we come close to the features of the machine code x86 processors. <br><br>  Processor instructions have a different size, which can vary from 1 to 15 bytes.  Thus, it is not known a priori what and how exactly we break after installing the trap using the five-byte patch method.  At the entry point, in theory, there can be anything, so there are two options - either move from the general method to the particular method or complicate the logic. <br><br>  ‚ÄúFrom the general to the particular‚Äù means that we will set our traps for specific functions, having previously studied them all and found the best method for each separately.  This is not very convenient, because for example, for the same WinSock, there are many versions of it such as XP, XPSP1, XPSP2, XPSP3, Vista, VistaSP1, Vista PU, Windows 7, etc.  And there are all sorts of security updates that can also install their own versions of the system libraries.  Therefore, in order for traps to work correctly using a private method, all possible versions of the same library will have to be scanned.  Fortunately, for the most part, different versions of libraries are not so different from each other exactly at the entry point. <br><br>  ‚ÄúComplicated logic‚Äù means writing an instruction analyzer which <br>  a) It will be able to calculate the size of opcodes of the processor in order to always transfer control to the ‚Äúwhole‚Äù instruction, and not somewhere in the middle. <br>  b) Will be able to detect problem areas and correctly process them. <br><br>  The ‚Äúother‚Äù trap will serve as the most obvious example of a problem area.  Suppose we are not the first to infiltrate the process and intercept the function.  In this case, we will see the first instruction in most cases JMP XX XX XX XX, in some cases PUSH XX XX XX XX RETN, and in theory anything at all.  Therefore, in the case of JMP, we will not be able to correctly execute the copied code from another place, because the transition is relative and is considered relative to the address of its execution.  Therefore, this transition will have to be recounted.  But in the case of PUSH-RETN address is not necessary to recalculate.  And in the case of ‚Äúanything,‚Äù there could be such an example of a problem area: <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">00004</span></span>EE1: <span class="hljs-number"><span class="hljs-number">3</span></span>C01 cmp al,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">00004</span></span>EE3: <span class="hljs-number"><span class="hljs-number">7404</span></span> je <span class="hljs-number"><span class="hljs-number">000004</span></span>EE9 <span class="hljs-number"><span class="hljs-number">00004</span></span>EE5: E916010000 jmp <span class="hljs-number"><span class="hljs-number">000005000</span></span></code> </pre> <br>  In this case, we get a complex <s>hemorrhoids</s> case: <br><br><ul><li>  There is a relative conditional transition, which is buried by our 5 bytes and which we cannot correctly execute in our handler due to its relativity.  There are two ways out: either recalculate the transition to the original address and, as a result, it is very likely to change the length of the instruction from two to six bytes, for a two-byte transition is short and runs at plus / minus 128 bytes;  or copy to yourself also the code to which the conditional jump will probably jump.  In the first case, since we will change the size of the instruction, we will have to recalculate all subsequent code to the new addresses.  In the second case, it is obvious that we need to simulate the situation when the transition will occur and when it will not happen and squeeze the return to the place that is guaranteed to receive control.  Again, if we consider that the code that the conditional transition points to may also have its own conditional and unconditional transitions, then we are faced with a very interesting task. </li><li>  Part of the unconditional transition, or rather the JMP instruction itself, is also rubbed with our five bytes.  If we go back to the next intact instruction, then it is obvious that the original code will not work correctly, because we skip the unconditional transition.  In another case, if we copy all the instructions entirely, then the unconditional transition will be made somewhere in the hyperspace, since it is relative.  Therefore, it will be necessary to calculate the correct address from the new place, which, together with the previous item, promises us a dull life. </li></ul><br>  If you are filled with all the subtlety of bullying, then I can give one good advice.  Writing a universal analyzer is possible, but for this it is necessary to prepare a set of solution templates for each such stumbling block.  For example - ‚Äúif unconditional transition is at the beginning‚Äù, ‚Äúif there is a conditional transition‚Äù, ‚Äúif there is a function call‚Äù, ‚Äúif in the middle ...‚Äù, etc.  Next, each template is applied according to the step-by-step analysis of instructions.  But believe me, this requires tangible investments in writing code, for which I am not ready yet. <br><br>  For the reasons given above, in this example, I focused on a particular solution for WS2_32.  So, all the functions that we intercept, start as standard: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">8B</span></span>FF mov edi,edi <span class="hljs-number"><span class="hljs-number">55</span></span> push ebp <span class="hljs-number"><span class="hljs-number">8B</span></span>EC mov ebp,esp <span class="hljs-number"><span class="hljs-number">83</span></span>ECXX sub esp,<span class="hljs-number"><span class="hljs-number">0000000</span></span>XX</code> </pre><br>  I suspect that Microsoft did it specifically to use similar techniques in some Microsoft Detours.  But I personally did not see it and didn‚Äôt feel it, so I‚Äôm not going to fantasize further on this topic.  So, the beginning of all the required WinSock functions is ideally suited to the size of the unconditional transition at the beginning of the function, because: <br>  a) The first three instructions occupy exactly five bytes. <br>  b) The first three instructions are not tied to a specific address and can be executed inside our handler. <br><br>  Behind this, we begin to modify the Interceptor.cpp code ... First of all, we will create a directive that will separate the old <s>chaff</s> from the new <s>chaff</s> and add the installation code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/************************************************************************/</span></span> <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hookInstall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PAPIHOOK thisHook)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PERSISTENT_HOOKS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     thisHook-&gt;oldCodeSize = 0; //   5         //         .    //        (5  ) for (; thisHook-&gt;oldCodeSize &lt; HOOK_CODE_SIZE; ) { //     int opSize = getX86InstructionLength((PBYTE) thisHook-&gt;oldAddr + thisHook-&gt;oldCodeSize); //   thisHook-&gt;oldCodeSize += opSize; } //       +   thisHook-&gt;oldCode = (UCHAR *) xmalloc(thisHook-&gt;oldCodeSize + HOOK_CODE_SIZE); if (NULL == thisHook-&gt;oldCode) { SetLastError(ERROR_NOT_ENOUGH_MEMORY); return FALSE; } DWORD fl; //  EXECUTE     DEP VirtualProtect(thisHook-&gt;oldCode, thisHook-&gt;oldCodeSize + HOOK_CODE_SIZE, PAGE_EXECUTE_READWRITE, &amp;fl); //          memcpy(thisHook-&gt;oldCode, thisHook-&gt;oldAddr, thisHook-&gt;oldCodeSize); //         ... thisHook-&gt;oldCode[thisHook-&gt;oldCodeSize] = asmJMP; // ...      , //    JMP DWORD *d = (DWORD*) ((PBYTE) (thisHook-&gt;oldCode + thisHook-&gt;oldCodeSize + 1)); *d = (DWORD) ((PBYTE) thisHook-&gt;oldAddr + thisHook-&gt;oldCodeSize) - (DWORD) d - sizeof(DWORD); #else //     //       thisHook-&gt;oldCodeSize = HOOK_CODE_SIZE; memcpy(thisHook-&gt;oldCode, thisHook-&gt;oldAddr, HOOK_CODE_SIZE); #endif //     thisHook-&gt;isInstalled = TRUE; //   hookEnable(thisHook); #ifdef PERSISTENT_HOOKS //      VirtualProtect(thisHook-&gt;oldAddr, HOOK_CODE_SIZE, oldFlags, &amp;oldFlags); #endif return TRUE; }</span></span></span></span></code> </pre><br>  Everything should be clear here except for calling the magic function <i>getX86InstructionLength ()</i> .  In order not to suffer with questions, I will answer.  Initially, this function always returned 5. Since we agreed to implement a special case, there is no big demand ‚Äî 5 bytes is the length of the first three instructions at the entry point.  But I went a little further and in the source you will find a real x86 instruction length analyzer.  This is my contribution to someone's future smart interceptor, so to speak ... In this post, I would not want to deviate in that direction because of the vastness of the issue. <br><br>  So, the above described code copies the first 5 bytes from the entry point to itself and after them puts an unconditional transition back to the original function on the instruction with the sequence number 4, which remains intact.  Thus, we ‚Äúforward‚Äù a static call to the original function without using code rewriting tricks at the entry point. <br>  Similarly, we add the removal of traps and restore the original state of the function: <br><br><pre> <code class="hljs markdown">/<span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">**/ /*     */ /**</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span>/ BOOL hookRemove(PAPIHOOK thisHook) { //   ,     if (!thisHook-&gt;isInstalled) return FALSE; #ifdef PERSISTENT<span class="hljs-emphasis"><span class="hljs-emphasis">_HOOKS DWORD oldFlags; if (!VirtualProtect(thisHook-&gt;oldAddr, HOOK_</span></span>CODE<span class="hljs-emphasis"><span class="hljs-emphasis">_SIZE, PAGE_</span></span>EXECUTE<span class="hljs-emphasis"><span class="hljs-emphasis">_READWRITE, &amp;oldFlags) || IsBadWritePtr(thisHook-&gt;oldAddr, HOOK_</span></span>CODE<span class="hljs-emphasis"><span class="hljs-emphasis">_SIZE)) { SetLastError(ERROR_</span></span>WRITE<span class="hljs-emphasis"><span class="hljs-emphasis">_PROTECT); return FALSE; //     } #endif //    hookDisable(thisHook); #ifdef PERSISTENT_</span></span>HOOKS VirtualProtect(thisHook-&gt;oldAddr, HOOK<span class="hljs-emphasis"><span class="hljs-emphasis">_CODE_</span></span>SIZE, oldFlags, &amp;oldFlags); if (thisHook-&gt;oldCode != NULL) xfree(thisHook-&gt;oldCode); #endif //      thisHook-&gt;isInstalled = FALSE; //        thisHook-&gt;newAddr = (LPVOID) NULL; thisHook-&gt;oldAddr = (LPVOID) NULL; return TRUE; }</code> </pre><br>  It is worth noting that in order to work correctly with DEP (Data Execution Prevention) we need to set EXECUTE rights to a piece of memory where a copy of the original code will be stored.  Otherwise, the system simply will not allow this code to execute.  Since now we do not need to rewrite anything, it is worth adding the macros to the declaration of the functions being intercepted: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PERSISTENT_HOOKS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/************************************************************************/</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*        */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   : typedef int (WSAAPI *PF_send) (SOCKET s, char *buf, int len, int flags); int WSAAPI my_send(SOCKET s, char *buf, int len, int flags) { PAPIHOOK thisHook = hookFind(my_send); PF_send p_send = (PF_send) thisHook-&gt;oldProc; if (NULL == thisHook || NULL == p_send) return (int) 0; int rv; ... /************************************************************************/</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFINE_HOOK(RTYPE, CTYPE, NAME, ARGS)\ typedef RTYPE(CTYPE *PF_##NAME) ##ARGS; \ RTYPE CTYPE my_##NAME ##ARGS \ { \ PAPIHOOK thisHook = hookFind(my_##NAME); \ PF_##NAME p_##NAME = (PF_##NAME) thisHook-&gt;oldProc; \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NULL == thisHook || NULL == p_##NAME) \ return (RTYPE) 0; \ RTYPE rv; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEAVE_HOOK() } \ return rv;</span></span></code> </pre><br>  As can be seen from the code, instead of the original imported function, we now call its prototype at thisHook-&gt; oldProc.  This is exactly the place where we saved the original five bytes and added them back to the transition. <br><br>  In general, that's all.  In the source code, the PERSISTENT_HOOKS directive is responsible for switching the old and new interception methods, and by default the new method is used without overwriting. <br><br>  By the way, I deliberately did not mention another method in which interception is carried out deep from the inside of the original code.  This is an even more interesting task, albeit a more difficult one.  Someone asked me, "why is it even necessary?".  I answer with a hint that there are programs that count the checksums of code fragments at the entry point and are sensitive to their changes.  But fortunately, browsers are not one of them yet. <br><br>  Do not forget that I do not pretend to originality and is far from being a pioneer in this field.  So there are people who have in their arsenal more elegant solutions than my attempts in this direction. <br><br>  Respectfully, <br>  // st </div><p>Source: <a href="https://habr.com/ru/post/150933/">https://habr.com/ru/post/150933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150928/index.html">Autumn. It's time to school: a one-day student practical export school on Windows 8</a></li>
<li><a href="../150929/index.html">Reasonable home from IBM and Vodafon. Start</a></li>
<li><a href="../150930/index.html">Unix as IDE: Introduction</a></li>
<li><a href="../150931/index.html">About sorting content based on user ratings: Part 3</a></li>
<li><a href="../150932/index.html">Free groups on C ++ and web programming in Moscow for high school students!</a></li>
<li><a href="../150934/index.html">Mobile editions - is it still future or is it already present? Interview with Vitaliy Dubinin</a></li>
<li><a href="../150935/index.html">Digest of Moscow vacancies</a></li>
<li><a href="../150936/index.html">Games of operators of communication with fire: for what and how does FAS penalize</a></li>
<li><a href="../150940/index.html">Delivery of fresh press using Python directly to the mailbox</a></li>
<li><a href="../150941/index.html">Ruby NoName Podcast S04E17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>