<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the Context package in Golang</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The context package in Go is useful for interactions with APIs and slow processes, especially in production-grade systems that deal with web requests....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the Context package in Golang</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/2f4/49e/54b/2f449e54b5540578a8ead5599e9e7f0e.jpg" alt="image"></p><br><p>  The context package in Go is useful for interactions with APIs and slow processes, especially in production-grade systems that deal with web requests.  With it, you can notify the goroutines of the need to complete their work. </p><br><p>  Below is a small guide to help you use this package in your projects, as well as some of the best practices and pitfalls. </p><br><p>  <em>(Note lane: Context is used in many packages, for example, in working with <a href="http://github.com/docker/docker">Docker</a> ).</em> </p><a name="habracut"></a><br><h2 id="pered-tem-kak-nachat">  Before you start </h2><br><p>  To use contexts, you must understand what goroutine and channels are.  I will try to consider them briefly.  If you are already familiar with them, go directly to the Context section. </p><br><h3 id="gorutina">  Gorutin </h3><br><p>  The official documentation says that ‚ÄúGorutin is a lightweight stream of execution.‚Äù  Goroutines are lighter than threads, so managing them is relatively less resource intensive. </p><br><p>  ‚Üí <a href="https://play.golang.org/p/-TDMgnkJRY6">Sandbox</a> </p><br><pre><code class="plaintext hljs">package main import "fmt" // ,   Hello func printHello() { fmt.Println("Hello from printHello") } func main() { //   //       go func(){fmt.Println("Hello inline")}() //     go printHello() fmt.Println("Hello from main") }</code> </pre> <br><p>  If you run this program, you will see that only <code>Hello from main</code> printed.  In fact, both goroutines start, but <code>main</code> finishes earlier.  So, the Goroutines need a way to inform <code>main</code> about the end of their execution, and so that she waits for this.  Here channels come to our aid. </p><br><h3 id="kanaly-channels">  Channels </h3><br><p>  Channels are a way of communication between goroutines.  They are used when you want to transfer results, errors or other information from one goroutine to another.  Channels are of various types, for example, a channel of type <code>int</code> receives integers, and a channel of type <code>error</code> receives errors, etc. </p><br><p>  Say we have a <code>ch</code> channel of type <code>int</code> .  If you want to send something to the channel, the syntax will be <code>ch &lt;- 1</code> .  You can get something from the channel like this: <code>var := &lt;- ch</code> , i.e.  take the value from the channel and save it in the <code>var</code> variable. </p><br><p>  The following code illustrates how to use the channels to confirm that the goroutines have completed their work and returned their values ‚Äã‚Äãto <code>main</code> . </p><br><p>  <em>Note: <a href="https://golang.org/pkg/sync/">Waiting groups</a> can also be used for synchronization, but in this article I selected channels for code examples, since we will use them later in the section on contexts.</em> </p><br><p>  ‚Üí <a href="https://play.golang.org/p/3zfQMox5mHn">Sandbox</a> </p><br><pre> <code class="plaintext hljs">package main import "fmt" //       int   func printHello(ch chan int) { fmt.Println("Hello from printHello") //     ch &lt;- 2 } func main() { //  .       make //       : // ch := make(chan int, 2),       . ch := make(chan int) //  .  ,    . //       go func(){ fmt.Println("Hello inline") //     ch &lt;- 1 }() //     go printHello(ch) fmt.Println("Hello from main") //      //     ,    i := &lt;- ch fmt.Println("Received ",i) //      //    ,      &lt;- ch }</code> </pre> <br><h2 id="kontekst-context">  Context </h2><br><p>  The context package in go allows you to pass data to your program in some kind of ‚Äúcontext‚Äù.  The context, like a timeout, deadline or channel, signals a shutdown and calls return. </p><br><p>  For example, if you make a web request or execute a system command, it would be a good idea to use a timeout for production-grade systems.  Because if the API you are accessing is slow, you are unlikely to want to accumulate requests on your system, as this can lead to increased load and decreased performance when processing your own requests.  The result is a cascade effect. </p><br><p>  And here the timeout or deadline context may be just right. </p><br><h3 id="sozdanie-konteksta">  Context creation </h3><br><p>  The context package allows you to create and inherit context in the following ways: </p><br><p>  <strong>context.Background () ctx Context</strong> </p><br><p>  This function returns an empty context.  It should be used only at a high level (in the main or top-level request handler).  It can be used to get other contexts, which we will discuss later. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.Background()</code> </pre> <br><p>  <strong>context.TODO () ctx Context</strong> </p><br><p>  This function also creates an empty context.  And it should also be used only at a high level or when you are not sure which context to use, or if the function does not yet receive the desired context.  This means that you (or someone who supports the code) plan to add context to the function later. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.TODO()</code> </pre> <br><p>  Interestingly, take a look at the <a href="">code</a> , it is absolutely the same as background.  The only difference is that in this case, you can use static analysis tools to check the validity of the context transfer, which is an important detail, since these tools help identify potential errors at an early stage and can be included in the CI / CD pipeline. </p><br><p>  <a href="">From here</a> : </p><br><pre> <code class="plaintext hljs">var ( background = new(emptyCtx) todo = new(emptyCtx) )</code> </pre> <br><p>  <strong>context.WithValue (parent Context, key, val interface {}) (ctx Context, cancel CancelFunc)</strong> </p><br><p>  <em>Note</em>  <em>Lane: There is an inaccuracy in the original article, the correct signature for <code>context.WithValue</code> will be as follows:</em> </p><br><pre> <code class="plaintext hljs">context.WithValue(parent Context, key, val interface{}) Context</code> </pre> <br><p>  This function takes a context and returns a context derived from it in which the <code>val</code> value is associated with <code>key</code> and passes through the entire context tree.  That is, as soon as you create a <code>WithValue</code> context, any derived context will receive this value. </p><br><p>  It is not recommended to pass critical parameters using context values; instead, functions should accept them explicitly in the signature. </p><br><pre> <code class="plaintext hljs">ctx := context.WithValue(context.Background(), key, "test")</code> </pre> <br><p>  <strong>context.WithCancel (parent Context) (ctx Context, cancel CancelFunc)</strong> </p><br><p>  It gets a little more interesting here.  This function creates a new context from the parent passed to it.  The parent can be the background context or the context passed as an argument to the function. </p><br><p>  The derived context and undo function are returned.  Only the function that creates it should call the function to cancel the context.  You can pass the undo function to other functions if you want, but this is strongly discouraged.  Typically, this decision is made from a misunderstanding of the context cancellation.  Because of this, contexts generated from this parent can affect the program, which will lead to an unexpected result.  In short, it is better to NEVER pass a cancel function. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>Note</em>  <em>Lane: In the original article, the author, apparently, erroneously for <code>context.WithCancel</code> gave an example with <code>context.WithDeadline</code> .</em>  <em>The correct example for <code>context.WithCancel</code> would be:</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithCancel(context.Background())</code> </pre> <br><p>  <strong>context.WithDeadline (parent Context, d time.Time) (ctx Context, cancel CancelFunc)</strong> </p><br><p>  This function returns a derived context from its parent, which is canceled after a deadline or call to the cancel function.  For example, you can create a context that is automatically canceled at a specific time and passes this on to child functions.  When this context is canceled after the deadline, all functions that have this context should be completed by notification. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <strong>context.WithTimeout (parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)</strong> </p><br><p>  This function is similar to context.WithDeadline.  The difference is that the length of time is used as input.  This function returns a derived context that is canceled when the cancel function is called or after a time. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><h3 id="priyom-i-ispolzovanie-kontekstov-v-vashih-funkciyah">  Reception and use of contexts in your functions </h3><br><p>  Now that we know how to create contexts (Background and TODO) and how to generate contexts (WithValue, WithCancel, Deadline, and Timeout), let's discuss how to use them. </p><br><p>  In the following example, you can see that a function that takes a context starts goroutine and expects it to return or cancel the context.  The select statement helps us determine what happens first and terminate the function. </p><br><p>  After closing the channel Done <code>&lt;-ctx.Done()</code> , the case <code>case &lt;-ctx.Done():</code> is selected.  As soon as this happens, the function should interrupt work and prepare for a return.  This means that you must close any open connections, free up resources, and return from the function.  There are times when the release of resources may delay the return, for example, the cleanup hangs.  You must keep this in mind. </p><br><p>  The example that follows this section is a fully finished go program that illustrates timeouts and undo functions. </p><br><pre> <code class="plaintext hljs">// ,  -      // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } }</code> </pre> <br><h3 id="primer">  Example </h3><br><p>  As we saw, using contexts you can work with deadlines, timeouts, and also call the cancel function, thereby making it clear to all functions using a derived context that you need to complete your work and complete return.  Consider an example: </p><br><p>  <code>main</code> function: </p><br><ul><li>  Creates a cancel function context </li><li>  Calls the cancel function after an arbitrary timeout </li></ul><br><p>  <code>doWorkContext</code> function: </p><br><ul><li>  Creates a timeout derived context </li><li>  This context is canceled when the main function calls cancelFunction, the timeout expires, or doWorkContext calls its cancelFunction. </li><li>  Runs goroutine to perform some slow task, passing the resulting context </li><li>  Waits for goroutines to complete or context to be canceled from main, whichever comes first </li></ul><br><p>  <code>sleepRandomContext</code> function: </p><br><ul><li>  Launches goroutine to perform some kind of slow task </li><li>  Waits for goroutine to finish, or </li><li>  Waits for the context to be canceled by the main function, timeout, or call its own cancelFunction </li></ul><br><p>  <code>sleepRandom</code> function: </p><br><ul><li>  Falls asleep at random time </li></ul><br><p>  This example uses sleep mode to simulate a random processing time, but in reality, you can use channels to signal this function about the start of cleaning and wait for confirmation from the channel that the cleaning is completed. </p><br><p>  <em><a href="https://play.golang.org/p/grQAUN3MBlg">Sandbox</a> (It looks like the random time I use in the sandbox is practically unchanged. Try this on your local computer to see randomness)</em> </p><br><p>  ‚Üí <a href="http:">Github</a> </p><br><pre> <code class="plaintext hljs">package main import ( "context" "fmt" "math/rand" "Time" ) //   func sleepRandom(fromFunction string, ch chan int) { //    defer func() { fmt.Println(fromFunction, "sleepRandom complete") }() //    //   , // ¬´¬ª      seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) randomNumber := r.Intn(100) sleeptime := randomNumber + 100 fmt.Println(fromFunction, "Starting sleep for", sleeptime, "ms") time.Sleep(time.Duration(sleeptime) * time.Millisecond) fmt.Println(fromFunction, "Waking up, slept for ", sleeptime, "ms") //   ,     if ch != nil { ch &lt;- sleeptime } } // ,       // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,    doWorkContext  // doWorkContext  main  cancelFunction //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("sleepRandomContext: Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } } //  ,         //       //   ,      main func doWorkContext(ctx context.Context) { //          - //  150  //  ,   ,   150  ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(150)*time.Millisecond) //         defer func() { fmt.Println("doWorkContext complete") cancelFunction() }() //       //         , //      ,    ch := make(chan bool) go sleepRandomContext(ctxWithTimeout, ch) //  select      select { case &lt;-ctx.Done(): //   ,           //     ,   main   cancelFunction fmt.Println("doWorkContext: Time to return") case &lt;-ch: //   ,       fmt.Println("sleepRandomContext returned") } } func main() { //   background ctx := context.Background() //     ctxWithCancel, cancelFunction := context.WithCancel(ctx) //      //        defer func() { fmt.Println("Main Defer: canceling context") cancelFunction() }() //     - //   ,        go func() { sleepRandom("Main", nil) cancelFunction() fmt.Println("Main Sleep complete. canceling context") }() //   doWorkContext(ctxWithCancel) }</code> </pre> <br><h3 id="podvodnye-kamni">  Underwater rocks </h3><br><p>  If the function uses context, make sure that cancellation notifications are handled properly.  For example, that <code>exec.CommandContext</code> does not close the read channel until the command completes all forks created by the process ( <a href="https://github.com/golang/go/issues/23019">Github</a> ), i.e. that canceling the context does not immediately return from the function if you wait with cmd.Wait (), until all forks of the external command complete processing. </p><br><p>  If you use a timeout or deadline with a maximum runtime, it may not work as expected.  In such cases, it is better to implement timeouts using <code>time.After</code> . </p><br><h3 id="luchshie-praktiki">  Best practics </h3><br><ol><li>  context.Background should only be used at the highest level, as the root of all derived contexts. </li><li>  context.TODO should be used when you are not sure what to use, or if the current function will use context in the future. </li><li>  Context cancellations are recommended, but these functions may take some time to clear and exit. </li><li>  context.Value should be used as sparingly as possible and should not be used to pass optional parameters.  This makes the API incomprehensible and can lead to errors.  Such values ‚Äã‚Äãshould be passed as arguments. </li><li>  Do not store contexts in a structure; pass them explicitly in functions, preferably as the first argument. </li><li>  Never pass a nil context as an argument.  If in doubt, use TODO. </li><li>  The <code>Context</code> structure does not have a cancel method, because only the function that spawns the context should cancel it. </li></ol><br><h3 id="ot-perevodchika">  From translator </h3><br><p>  In our company, we actively use the Context package when developing server applications for internal use.  But such applications for normal functioning, in addition to Context, require additional elements, such as: </p><br><ul><li>  Logging </li><li>  Signal processing for application termination, reload and logrotate </li><li>  Work with pid files </li><li>  Work with configuration files </li><li>  And other </li></ul><br><p>  Therefore, at some point, we decided to summarize all our experience and created auxiliary packages that greatly simplify writing applications (especially applications that have APIs).  We put our developments in the public domain and anyone can use them.  The following are some links to packages useful for solving such problems: </p><br><ul><li>  <a href="https://github.com/nixys/nxs-go-appctx">nxs-go-appctx</a> </li><li>  <a href="https://github.com/nixys/nxs-go-conf">nxs-go-conf</a> </li></ul><br><p>  Also read other articles on our blog: </p><br><ul><li>  <a href="https://habr.com/ru/company/nixys/blog/437372/">Three simple tricks to reduce docker images</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/426543/">Stateful backups in Kubernetes</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/424717/">Backing up a large number of heterogeneous web projects</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/347526/">Telegram bot for Redmine.</a>  <a href="https://habr.com/ru/company/nixys/blog/347526/">How to simplify life for yourself and people</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/461723/">https://habr.com/ru/post/461723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461715/index.html">Fear and Loathing as Techdir</a></li>
<li><a href="../461717/index.html">How to compact up to 90% storage of backups in object storage</a></li>
<li><a href="../461719/index.html">Open source solution for reporting automation</a></li>
<li><a href="../46172/index.html">Vpornacte</a></li>
<li><a href="../461721/index.html">New Cluster Analysis Method</a></li>
<li><a href="../461725/index.html">DataGrip 2019.2: Connection management, data search, filtering in navigation</a></li>
<li><a href="../461727/index.html">Cisco Small Business Solutions: A Good Network Is Not Necessarily Costly</a></li>
<li><a href="../461729/index.html">Using jailbreak to extract data: risks and consequences</a></li>
<li><a href="../46173/index.html">Chinese cybercafes forcibly translate to Linux</a></li>
<li><a href="../461733/index.html">Learning English: 9 American-style idioms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>