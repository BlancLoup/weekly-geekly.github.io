<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ArrayBuffer and SharedArrayBuffer in JavaScript, part 3: race streams and Atomics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üí ArrayBuffer and SharedArrayBuffer in JavaScript, Part 1: Short Memory Management Course 
 ‚Üí ArrayBuffer and SharedArrayBuffer in JavaScript, Part 2:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ArrayBuffer and SharedArrayBuffer in JavaScript, part 3: race streams and Atomics</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  ‚Üí <a href="https://habrahabr.ru/company/ruvds/blog/331344/">ArrayBuffer and SharedArrayBuffer in JavaScript, Part 1: Short Memory Management Course</a> <br>  ‚Üí <a href="https://habrahabr.ru/company/ruvds/blog/331760/">ArrayBuffer and SharedArrayBuffer in JavaScript, Part 2: Introduction to New Language Objects</a> <br>  ‚Üí <b>ArrayBuffer and SharedArrayBuffer in JavaScript, part 3: race streams and Atomics</b> <br></blockquote><br> <a href="https://habrahabr.ru/company/ruvds/blog/332194/"><img src="https://habrastorage.org/web/44b/6da/9d4/44b6da9d4d0a4d4da3269457e34d6c12.jpg"></a> <br><br>  <a href="https://habrahabr.ru/company/ruvds/blog/331760/">Last time</a> , considering SharedArrayBuffer, we said that working with this object can lead to a race condition of threads.  This complicates development, so we expect that this tool will be used by library creators with experience in multi-threaded programming.  They will be able to use the new low-level APIs to create high-level tools that regular programmers will work with, without touching either the SharedArrayBuffer or Atomics. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/1ee/432/bac/1ee432bac5bc804b5f4881eda512c40c.png"><br>  <i><font color="#999999">SharedArrayBuffer and Atomics as the basis for multithreading implementation in JS libraries and WebAssembly</font></i> <br><br>  If you do not belong to the developers of libraries, then, most likely, you should not work directly with Atomics and SharedArrayBuffer.  However, we believe you will be interested to know how it all works.  Therefore, in this article we will talk about the state of race races that can occur with multi-threaded programming, and how the use of the Atomics object will help the libraries based on new JS tools to avoid these states. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with a more detailed discussion of what race is. <br><br><h2>  <font color="#3AC1EF">Race Race: a classic example</font> </h2><br>  A race race condition may occur in a situation where there is a variable that two threads have access to.  Suppose the first thread, based on the value of the <code>fileExists</code> variable, loads a certain file, and the second checks whether the file exists and, if so, sets this variable to <code>true</code> .  We do not go into the details, the code for checking the presence of the file is omitted. <br><br>  Initially, the variable that processes use to exchange data is set to <code>false</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e6/5a0/0a8/4e65a00a8868f8ccf1516b1817e9e5ae.png"><br>  <i><font color="#999999">The first thread, on the left, loads the file, if the fileExists variable is set to true, the second thread, after checking the existence of the file, sets this variable to true</font></i> <br><br>  If the code in the second thread is executed first, sets the variable to true, the first thread will load the file. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a11/82c/51b/a1182c51b2bfb7b483e5448e43998685.png"><br>  <i><font color="#999999">First, the second thread sets the variable to true, then the second thread loads the file.</font></i> <br><br>  However, if the code in the first thread is executed first, it will display an error message containing information that the file does not exist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/db0/c8c/ef2db0c8cb99bc11991514a504f71efc.png"><br>  <i><font color="#999999">If at first, when the variable is still set to false, the code in the first thread is executed, an error message is displayed</font></i> <br><br>  In fact, the problem is not that the file could not be found.  In our very simplified case, the real cause of the error message is the racetrack state. <br><br>  Many JS developers face a race condition of this kind, even in single-threaded code.  And, in fact, you do not need to know anything about multithreading in order to see why such errors occur. <br><br>  However, there are some types of race streams that are not possible in single-threaded code, but can occur when developing multi-threaded programs whose streams use shared memory. <br><br><h2>  <font color="#3AC1EF">Different types of racing streams and Atomics</font> </h2><br>  Let's talk about the different types of race streams that can be encountered in multi-threaded code, and how Atomics can help prevent them.  It should be noted that here we are not trying to consider absolutely all possible states of racing, but this review will help you understand why certain methods are provided for in the Atomics API. <br><br>  Before we begin, I would like to remind again, turning to ordinary developers, that it is not expected that they will directly use the capabilities of Atomics.  Multithreaded development is characterized by increased complexity, we believe that new creators of libraries will mostly use the new JavaScript tools. <br><img src="https://habrastorage.org/getpro/habr/post_images/20f/c25/843/20fc258435122d8dd7ab0235af29d460.png"><br>  <i><font color="#999999">Multithreaded programming carries many dangers</font></i> <br><br>  Now proceed to the story of the states of racing. <br><br><h3>  Race streams when processing a single operation </h3><br>  Suppose there are two threads that increment the same variable.  At first glance it may seem that there is nothing dangerous here, that the result of several similar operations will be the same, regardless of which thread will increase the variable first. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef8/461/b29/ef8461b29bad694903c53dfacd3c1515.png"><br>  <i><font color="#999999">Two threads increment the variable</font></i> <br><br>  Although, in the JS program, incrementing looks like a single operation, if you look at the compiled code, it turns out that we have several operations in front of us.  The processor, to increment a variable, must perform three operations. <br><br>  The point here is that the computer has different types of memory.  In this case, we are talking about the usual RAM, which stores data for a relatively long time, and the processor registers, which are used for short-term data storage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/510/60a/04b/51060a04ba866df4c887f2704a141119.png"><br>  <i><font color="#999999">RAM, processor registers and arithmetic logic unit</font></i> <br><br>  Our two threads have shared RAM, but not processor registers.  Each thread, to perform certain actions with data, you must first transfer them from RAM to registers.  Then - to perform calculations, and after that - to return the data back into RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d38/328/fad/d38328fad1927f9f51fb4d80c1707ef2.png"><br>  <i><font color="#999999">Perform actions with data stored in RAM.</font></i>  <i><font color="#999999">The first step is to load data from memory into the register.</font></i>  <i><font color="#999999">The second is the execution of calculations.</font></i>  <i><font color="#999999">The third is to save the result of calculations in RAM</font></i> <br><br>  If all the necessary low-level operations are first performed by the first thread and then by the second, we will get the expected result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/749/787/d0a/749787d0a8ac2e745678a4a25a4c18cc.png"><br>  <i><font color="#999999">First, all operations on incrementing the variable are performed by the first thread, then - the second</font></i> <br><br>  But what if the operations in which the registers are involved are executed in such a way that one of them starts before the other ends?  This will lead to a violation of the synchronization of the state of the registers and RAM.  For example, it may happen that one of the streams does not take into account the results of the calculations of the other and overwrites with its data what it has written into memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc1/2ff/c77/cc12ffc7704925b8f3923be45f1f5be6.png"><br>  <i><font color="#999999">Race streams and register operations</font></i> <br><br>  Such situations can be avoided by implementing the so-called ‚Äúatomic operations‚Äù.  The point here is that what looks like a single operation to a programmer and a few to a computer looks like a single operation to a computer. <br><br>  Atomic operations allow you to turn certain actions, which can include many processor instructions, into something like a single indivisible instruction.  This atomic "instruction" preserves the integrity even if the execution of the commands of which it is composed is suspended, and, after a while, resumes.  Atomic operations are sometimes compared with atoms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/a3e/7a2/b61a3e7a2920fbd098b9c73c3ce5c595.png"><br>  <i><font color="#999999">A set of instructions that form an atomic operation</font></i> <br><br>  Using atomic operations, the code for incrementing a variable will look different.  Instead of the usual <code>sharedVar++</code> this would be something like <code>Atomics.add(sabView, index, 1)</code> .  The first argument to the <code>add</code> method is the data structure for accessing the <code>SharedArrayBuffer</code> ( <code>Int8Array</code> , for example).  The second is the index by which <code>sharedVar</code> is in the array.  The third argument is a number to add to the <code>sharedVar</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4b/987/5ad/c4b9875adda6e522717893a6ab676a26.png"><br>  <i><font color="#999999">Atomic operation, which allows to increase the variable by 1</font></i> <br><br>  Now, when we use the <code>Atomics.add</code> method, processor actions related to incrementing a variable by a command from one thread are not mixed with operations initiated from another thread.  Instead, first all the necessary actions, within the framework of one atomic operation, are performed by the first thread, after which the operations of the second stream are performed, again, enclosed in an atomic operation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/f88/70d/f9ff8870d921219fb43af4d3a3ae6384.png"><br>  <i><font color="#999999">First, the instructions needed to increment the variable are executed by the first thread, then the second</font></i> <br><br>  Here are Atomics methods that help to avoid racing conditions when performing individual operations. <br><br><ul><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add">Atomics.add</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub">Atomics.sub</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and">Atomics.and</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or">Atomics.or</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor">Atomics.xor</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange">Atomics.exchange</a> <br></li></ul><br>  You may notice that this list is rather limited.  In it, for example, there are no methods for performing division or multiplication.  However, developers of auxiliary libraries can independently implement atomic methods for performing various operations. <br><br>  To implement such things, you can use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange">Atomics.compareExchange</a> method.  Using this method, you can read a certain value from the SharedArrayBuffer, perform some actions with it and write back only if it was not changed by another thread while performing actions with it.  If, when attempting to write, it turned out that the value in the SharedArrayBuffer has changed, the recording is not performed, you can instead take the new value and try the same operation again. <br><br><h3>  Race status when performing multiple operations </h3><br>  Atomic operations, which we talked about above, make it possible to avoid the state of racing when performing single commands.  However, sometimes it is necessary to change several values ‚Äã‚Äãin the object (using several operations) and to be sure that no one else will try to change these values ‚Äã‚Äãat the same time.  In general, this means that, during each session of updating the state of an object, the object must be blocked and inaccessible to other threads. <br><br>  The Atomics object does not provide tools that allow you to directly implement such functionality, but it provides tools that library developers can use to create mechanisms to perform such operations.  This is about creating high-level locking tools. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b1/467/60e/9b146760ea88dda0f1dae4a4c9d3dcc0.png"><br>  <i><font color="#999999">Two threads, shared memory and lock</font></i> <br><br>  If the code wants to use shared data, it must acquire the lock.  In the picture above, none of the threads blocked the common memory area; this is represented as an open lock.  Once captured, a stream can use a lock to protect data from other threads.  Only he can access this data or change it while the lock is active. <br><br>  In order to create a blocking mechanism, library authors can use the methods <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomics.wait</a> , and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake">Atomics.wake</a> , as well as the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange">methods Atomics.compareExchange</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store">Atomics.store</a> .  <a href="https://github.com/lars-t-hansen/js-lock-and-condition">Here</a> you can look at the basic implementation of such a mechanism. <br><br>  With this approach, shown in the following figure, stream # 2 will lock the data lock and set the value of <code>locked</code> to <code>true</code> .  This means that stream # 1 cannot access data until stream # 2 unlocks them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1b/755/48a/e1b75548a38cdca95183c4bd63c2cf46.png"><br>  <i><font color="#999999">Stream # 2 blocks data</font></i> <br><br>  If stream 1 needs access to the data, it will try to lock the lock.  But since the lock is already in use, it cannot do this.  Therefore, the thread will have to wait until the data is unlocked. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a8/6b9/a15/9a86b9a1505e4594f108a134e5745856.png"><br>  <i><font color="#999999">Stream # 1 is waiting for the lock to be released.</font></i> <br><br>  As soon as the flow number 2 is completed, it will remove the lock.  After this, the locking mechanism will notify the pending threads that they can acquire the lock. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/8bd/165/6268bd165e5c1b3e8ab06703884383c2.png"><br>  <i><font color="#999999">Stream # 1 received an alert that the lock was released</font></i> <br><br>  Now stream # 1 can lock and block data for its own use. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/0ac/59d/8b50ac59d319a95046c498b1e3c5da48.png"><br>  <i><font color="#999999">Stream # 1 locks data</font></i> <br><br>  A library that implements the locking mechanism could use various methods of the Atomics object, however, the most important ones are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait">Atomics.wait</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake">Atomics.wake</a> . <br><br><h3>  Race condition caused by changing the order of operations </h3><br>  Here is the third synchronization problem in which the Atomics object can help.  For some, it may be a complete surprise. <br><br>  You may not know this, but there is a great chance that the commands of the program written by you will not be executed in the order in which they go in the code.  Both compilers and processor change the order in which the code is executed in order to use computer resources more efficiently. <br><br>  For example, suppose a certain function was written, the code of which calculates the total amount of a check.  After completing the calculations, we set the appropriate flag. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2a/f4e/9bb/a2af4e9bbce763ee0272e8d654fec38c.png"><br>  <i><font color="#999999">A snippet of code that performs the calculation of the total amount and sets a flag signaling the end of the operation</font></i> <br><br>  In order to compile this, the system must decide which register to use for each variable.  After that, the JS code can be translated into machine instructions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f19/233/fc6/f19233fc6c17c140962ae06b715c6915.png"><br>  <i><font color="#999999">A simplified example of converting JS code to machine instructions</font></i> <br><br>  So far, everything looks as expected. <br><br>  For those who are not very well versed in how the computer works at the hardware level, how the pipelines are used, which are used to execute the code, it may not be entirely obvious that the machine will have to wait a little before executing the second line of our code. <br><br>  Most computers break down the process of executing instructions into several steps.  This allows for the constant loading of all the processor mechanisms, which makes it possible to effectively use the resources of the machine. <br><br>  Here is a description of the steps that make up the instruction. <br><br>  <b>Stage # 1</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/329/1d1/b5f/3291d1b5f808231a34dd6fc6afc11d73.png"><br>  <i><font color="#999999">Sampling instructions from memory</font></i> <br><br>  <b>Stage 2</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8d/bc3/60b/f8dbc360b4a761b35f0b9752f041dcaf.png"><br>  <i><font color="#999999">Decoding instructions, that is, finding out exactly what actions need to be performed to execute this instruction, and loading the necessary data from the registers</font></i> <br><br>  <b>Stage 3</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/3c5/64f/d963c564f1af4548402dc61ab5b88cae.png"><br>  <i><font color="#999999">Execution of instructions</font></i> <br><br>  <b>Stage 4</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84f/b80/ad5/84fb80ad56f8a4ed9dced94799665caf.png"><br>  <i><font color="#999999">Write the results of the execution of instructions in the registers</font></i> <br><br>  Here, very simply, the path that the first instruction follows.  Ideally, we would like the second instruction to follow immediately after the first one.  That is, as soon as the first instruction proceeds to step # 2, step # 1 is performed for the second instruction, and so on. <br>  The problem is that instruction number 2 depends on instruction number 1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f01/398/e36/f01398e36c34767271ea36f272f71733.png"><br>  <i><font color="#999999">Instructions # 2 need to get the value of the variable subTotal from R3, but instruction # 1 has not yet written down the result of the calculations.</font></i> <br><br>  In this situation, you can pause processor processing of instructions until instruction # 1 updates the value of the <code>subTotal</code> variable in the register.  However, with this approach, performance will suffer. <br><br>  In order to use system resources efficiently, many compilers and processors change the order of operations.  Namely, in our case, we search for instructions that do not use the variables <code>subTotal</code> and <code>total</code> , and execute these instructions between instructions No. 1 and No. 2, which follow each other in the code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/378/0ac/165/3780ac165f1caac5e2325395acd5c102.png"><br>  <i><font color="#999999">Changing the order of instructions, instruction number 3 will be executed between instructions number 1 and number 2</font></i> <br><br>  This allows, ideally, not to interrupt the flow of instructions following the pipeline. <br><br>  Since the third line of code does not depend on either the first or the second, the compiler or processor can decide that it is safe to change the order of instructions.  When all this happens in single-threaded mode, inside a function, another code will not access these values ‚Äã‚Äãuntil the entire function completes. <br><br>  However, if there is another thread running in parallel, everything changes.  It is not necessary for another thread to wait until the function terminates, in order to know the state of the variables.  These changes may be noticed by another stream almost immediately after they occur.  As a result, it appears that the <code>isDone</code> flag, visible to another thread, will be set before the completion of the calculations.  <code>codeisDone</code> as a flag indicating that the <code>total</code> calculation is completed, and the resulting value is ready for use in another thread, changing the order of operations will lead to a race condition of the threads. <br><br>  The Atomics object is trying to solve some of these oddities.  In particular, the use of an atomic write operation resembles the installation of a fence between two code fragments.  Separate atomic operations instructions do not mix with other operations.  In particular, here are two operations that are often used to ensure that operations are performed in order: <br><br><ul><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load">Atomics.load</a> <br></li><li>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store">Atomics.store</a> <br></li></ul><br>  If some variable is updated in the JS function code above the <code>Atomics.store</code> , it will be guaranteed to be completed before <code>Atomics.store</code> stores the value of the variable in memory.  Even if the order of execution of non-atomic instructions is changed with respect to each other, none of them will be moved below the <code>Atomics.store</code> call, located at the bottom of the code. <br><br>  Similarly, loading a variable after calling <code>Atomics.load</code> guaranteed to be executed after <code>Atomics.load</code> its value.  Again, even if the order of execution of non-atomic instructions is changed, none of them will be moved in such a way that it will be executed before <code>Atomics.load</code> , which is located in the code above it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b8/e26/6cc/5b8e266ccef8f194db3c9b5c6160ebed.png"><br>  <i><font color="#999999">Updating the variable above Atomics.store is guaranteed to be completed before the completion of Atomics.store.</font></i>  <i><font color="#999999">The variable loading below Atomics.load is guaranteed to be executed after Atomics.load completes</font></i> <br><br>  Notice that the <code>while</code> in this example implements a circular lock; this is a very inefficient construct.  If something like this happens to be in the main application thread, the program may simply hang.  In real code, almost certainly, cyclic locks should not be used. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Multi-threading programming with shared memory is not an easy task.  There are many situations that can cause a race race condition.  They, like dragons, await inexperienced developers in the most unexpected places. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7b/eab/83d/e7beab83d707c248e24624e35bad0e04.png"><br>  <i><font color="#999999">Multi-threaded shared memory programming is full of hazards</font></i> <br><br>  We, in this series of three materials, constantly said that new language tools allow library developers to create simple, convenient and reliable tools designed for ordinary programmers.  The SharedArrayBuffer and Atomics path in the JavaScript universe is just beginning; therefore, libraries based on them have not yet been created.  However, now the JS-community has everything you need to develop such libraries. <br><br>  Dear readers!  If you are one of those highly-skilled programmers who know first-hand about multi-threading, based on which SharedArrayBuffer and Atomics are created, you are sure that many beginners will be interested to know which direction to take in order to become a developer of high-quality libraries implementing parallel computing .  Share, please, experience. </div><p>Source: <a href="https://habr.com/ru/post/332194/">https://habr.com/ru/post/332194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332184/index.html">Six Myths about Big Data</a></li>
<li><a href="../332186/index.html">4 popular mistakes in business card design</a></li>
<li><a href="../332188/index.html">Three days like all ticket offices in the country should become online (in fact, not)</a></li>
<li><a href="../332190/index.html">The tale of how an Android developer spammers, and that came out of it</a></li>
<li><a href="../332192/index.html">Canvas - almost like SVG</a></li>
<li><a href="../332196/index.html">How to organize secure access using VPN</a></li>
<li><a href="../332198/index.html">Introduction to procedural animation: inverse kinematics</a></li>
<li><a href="../332200/index.html">VeeamON 2017: what marketers do not write in blogs</a></li>
<li><a href="../332202/index.html">About analytics and silver bullets or ‚ÄúWhat does Rambler / Top 100 have to do with it?‚Äù</a></li>
<li><a href="../332204/index.html">GitLab 9.3 released: Code Quality and inter-project pipeline schedules</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>