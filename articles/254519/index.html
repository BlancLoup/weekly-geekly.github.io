<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own Flash on HTML5: the union of vector images (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article , we smashed all the available segments by intersection points, thus ensuring that we no longer have intersecting segments. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own Flash on HTML5: the union of vector images (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/476/a24/205/476a242053a14a6689fcfc523f0143e9.png" align="left" width="400">  In the <a href="https://habrahabr.ru/company/nanofl/blog/251073/">previous article</a> , we smashed all the available segments by intersection points, thus ensuring that we no longer have intersecting segments.  In this part, we will join the obtained segments into contours and define their fill. <br><a name="habracut"></a><br><h1>  Contour search </h1><br><img src="https://habrastorage.org/files/913/d23/60d/913d2360da584e42843a02e322bec0d2.png" align="right">  So, we have a set of non-intersecting segments.  Let's look for contours that will be useful to us to identify polygons.  In the figure on the right we see 6 red lines and 3 blue ones.  It would be nice to find the contours of ABFDC, DFE and FGD.  Composite contours (for example, ABFGDC) do not interest us, which means either our algorithm should not stumble upon them in principle, or else we will have to exclude these contours later. <br><br><h2>  Search by search </h2><br><img src="https://habrastorage.org/files/646/a19/831/646a198319544156a2f5618bcfd679be.png" align="left">  The first algorithm that came to my mind initially showed itself well.  Here is what it looks like: <br><ol><li>  For simplicity, we double the number of segments, adding for each segment its backward-directed clone (this will allow us to walk along the segments as along vectors, without having to walk along the ‚Äúback‚Äù segments). </li><li>  Consistently take each segment for the initial for the desired contour, put it in a new array and call the recursive search procedure (below). </li><li>  We look through all the segments looking for one that fits in with the beginning of the last one found and its end point has not yet met among the segment points in the array, and add it to the end of the array. </li><li>  If the end of this segment coincides with the beginning of the first segment of the array, then we have found the contour - add an array of segments to the array of contours found and exit the recursion. </li><li>  If not, recursively call the procedure for finding the next segment. </li></ol><br><img src="https://habrastorage.org/files/4f1/7e5/627/4f17e562713c4939bf2a0adff271405b.png" align="right">  Adding to this algorithm the procedure for elimination of composite contours, you can get something quite workable.  And I thought everything was fine until I was confronted with a real situation (see pictures).  Pay attention to the yellow "star" on the chain of a famous character.  It is drawn by imposing a set of squares turned around its center.  After splitting the segments at the intersection points, the first we have is 112 pieces.  I did not manage to wait until the end of the search for contours on this image.  But indeed, the estimate of the time of such sorting over the number of segments is O (n!), Which, as you understand, is normal for a dozen segments, but completely unacceptable for a hundred.  I had to think about another algorithm. <br><br><h2>  Directed search by the choice of the "extreme" segment </h2><br><img src="https://habrastorage.org/files/185/d81/81d/185d8181d4d64394815c3e6c357db915.png" align="left">  Let's go back to the original picture (it is duplicated on the left).  If we, in search of the next segment for the future contour, came along the vector from point B to point F, then it makes sense to move on either to point D or to point G, since  Moving along the FE vector, we will obviously choose a segment belonging to the composite contour!  Those.  as a minimum, we can already greatly reduce the search (from each point we can go a maximum of two ways).  And that's good, but let's think further.  Note that the above iteration algorithm finds all contours two times (once - moving clockwise, and another time - when it goes in sections counterclockwise).  What if in each branch we choose only the most extreme segment in the sense of moving clockwise?  (In the example: if the last segment vector was BF, then the next one will be FD.) We will find all the necessary contours!  Without recursion!  Miracles! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is worth mentioning here that although we go clockwise, sometimes we will find contours with a left circuit (counterclockwise), if the starting vector segment does not belong to any circuit with a right circuit.  Moreover, these left contours can be composite (In the figure: vector AB belongs to the right contour of ABFDC, and here vector BA is the composite left contour of BACDGF.) So, we will need to exclude all left contours from the resulting array. <br><br>  Here's how to determine whether the contour is right (here (x1, y2) is the starting point of the segment, (x3, y3) is the final one): <br><br><pre><code class="actionscript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isClockwise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (edge <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> edges) { sum += (edge.x3 - edge.x1) * (edge.y3 + edge.y1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  The resulting algorithm is already working at an acceptable speed (of the order of O (n ^ 2), as far as I understand it; correct it if I am mistaken) and it shows itself perfectly on real problems.  And we go further. <br><br><h1>  Detection of polygons by contours found </h1><br><img src="https://habrastorage.org/files/2a8/736/f2e/2a8736f2efe74b5187129befa8ba1abd.png" align="right">  So, we have contours.  It is time to put them into polygons (remember that a polygon is an external contour + a set of internal contours- ‚Äúholes‚Äù).  The task is well solved "in the forehead": <br><br><ol><li>  We take successively each contour for the external contour of the future polygon. </li><li>  Among the remaining contours we look for those that lie inside our external contour. </li><li>  Take a point lying inside the outer contour, but outside its ‚Äúholes‚Äù. </li><li>  On the original image, we take the fill at this point (ie, we are looking for the polygon to which it belongs), and if such a polygon is located, we add the outer contour + ‚Äúholes‚Äù as a new polygon to the array found for the original image. </li><li>  Similarly, for the final image (look for the polygon to which the point belongs and if it is, add a new polygon to the array found for the final image). </li></ol><br>  Thus, we ‚Äúreconstruct‚Äù the original and final image after intersecting all the segments.  And now we are guaranteed to have that each of the polygons of the original image either coincides (in the sense of coordinates) with the same polygon of the overlaid image, or stands out for the limits of all its polygons. <br><br>  I think you should pay special attention to paragraph 3.  How to take a good point inside the contour outside of its internal contours?  To begin with, we need to understand that the point then lies inside the polygon, when the beam emitted from it in any direction intersects with the polygon segments an odd number of times.  And everything is good, except that due to the limited accuracy of calculations, the beam can get to the junction of the segments, which can cause incidents (detection of intersections with both segments, either with one or with one at all).  Most often, to simplify calculations, the beam is released horizontally.  We will also do so.  Here is what we now know about a good point: <br><ul><li>  it should not coincide with any of the ends of the segments that make up the polygon (and the more does not coincide - the better); </li><li>  It is desirable that the point lies far away from the segments of the polygon in order to reduce the likelihood of problems associated with the detection of intersections of a beam emitted from it with these segments. </li></ul><br><img src="https://habrastorage.org/files/7ec/d19/a3c/7ecd19a3cd5f49d0a79d96358380f288.png" align="left">  The following algorithm of searching for the <i>y</i> coordinate for such a point comes to mind: <br><ol><li>  We drive into the array all the <i>y</i> coordinates of the ends of the segments that make up the polygon. </li><li><img src="https://habrastorage.org/files/912/416/c6e/912416c6e19e4967bc267589b2edbf53.png" align="right">  <i>We add</i> to it <i>minY</i> and <i>maxY of</i> our external contour (since these values ‚Äã‚Äãdo not always coincide with the values ‚Äã‚Äãat the ends of the segments - see fig. On the right). </li><li>  Sort the array in ascending order. </li><li>  We are looking for a sequential pair of values ‚Äã‚Äã(y1, y2) in the array for which the difference <i>y2 - y1 is</i> maximal. </li><li>  We take the arithmetic average of these values ‚Äã‚Äãfor the <i>y</i> coordinate of the desired point: <i>y = (y1 + y2) / 2</i> . </li></ol><br>  It remains to find a convenient <i>x</i> value for us.  For this: <br><img src="https://habrastorage.org/files/4f1/cbe/a9c/4f1cbea9ca4b420c8dc9b8a675c00946.png" align="right"><br><ol><li>  <i>Release the</i> horizontal beam from the point <i>(infinity; y)</i> to the right. </li><li>  Find all the coordinates <i>x of the</i> point of intersection of the ray with the segments of the polygon; </li><li>  Sort them ascending. </li><li>  We choose among pairs <i>(x [i], x [i + 1])</i> , where <i>i = 0,2,4 ...</i> such, for which the difference <i>x [i + 1] - x [i] is</i> maximal. </li><li>  We take the arithmetic average of this pair for the value of the <i>x</i> coordinate of the desired point: <i>x = (x [i] + x [i + 1]) / 2</i> . </li></ol><br>  The resulting algorithm is not perfect, but simple enough and, as practice shows, works well on real-world problems. <br><br><h1>  Last steps </h1><br>  Within the article, we will not consider in detail the remaining points of the image combining search algorithm: <br><ul><li>  removal of all edges of the original image, which are completely inside the shaded areas of the overlay image; </li><li>  removal from the original image of all polygons present in the overlay image without taking into account the color; </li><li>  adding to the edges and polygons of the original image of all edges and polygons of the overlay image (in this case, the coinciding edges of the original image are rubbed with the edges of the overlay); </li><li>  the union on the original image of adjacent polygons that have the same fill and do not have a clear separation of the edges. </li></ul><br>  I believe that these subtasks are quite trivial and readers can easily (if necessary) deal with this on their own. <br><br><h1>  Conclusion </h1><br>  In the article I tried to show a number of interesting moments related to the search for the union of vector images.  Some features remained behind the scenes, because  they are either too small, or the author just forgot about them.  I will be glad to any clarifications both on the article and on the described algorithms. </div><p>Source: <a href="https://habr.com/ru/post/254519/">https://habr.com/ru/post/254519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254507/index.html">Creating a universal web application site Habrahabr.ru using the Web App Template</a></li>
<li><a href="../254509/index.html">Unit testing of Yii2 behavior with Codeception</a></li>
<li><a href="../25451/index.html">Right there! (remake)</a></li>
<li><a href="../254513/index.html">Homemade do-it-yourself microcontroller</a></li>
<li><a href="../254517/index.html">Should I continue to use the term Big Data?</a></li>
<li><a href="../25452/index.html">Flash Player 10 released today</a></li>
<li><a href="../254521/index.html">Interesting and utility will no longer be</a></li>
<li><a href="../254523/index.html">Designer interactive exercises for online learning</a></li>
<li><a href="../254525/index.html">I want from API a line, and a point, and a point</a></li>
<li><a href="../254527/index.html">Android - Custom View or ToggleButton 4x4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>