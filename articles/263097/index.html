<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Event-oriented Python backtesting step by step. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier in our blog on Habr√©, we considered various stages of developing trading systems (there are online courses on the topic), among which one of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Event-oriented Python backtesting step by step. Part 1</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/itinvest/blog/263097/"><img src="https://habrastorage.org/files/293/6ac/abf/2936acabf56146e485b01c8b3327a688.jpg"></a> <br><br>  Earlier in our blog on Habr√©, we considered various <a href="http://habrahabr.ru/company/itinvest/blog/224353/">stages of developing</a> trading systems (there are <a href="http://www.itinvest.ru/education/schedule/">online courses</a> on the topic), among which one of the most important is <a href="http://habrahabr.ru/company/itinvest/blog/238839/">testing for historical data</a> (backtesting).  Today we will talk about the practical implementation of an event-oriented backtest module using Python. <a name="habracut"></a><br><br><h4>  Event-oriented software </h4><br>  Before diving into the development of a backtester, you should understand the concept of event-oriented systems.  One of the most obvious examples of such programs are computer games.  In a video game, there are many components that interact with each other in real time with a high frame rate.  To cope with the load helps the implementation of all calculations inside the "infinite" loop, which is also called the <a href="https://en.wikipedia.org/wiki/Event_loop">event loop</a> or <a href="https://en.wikipedia.org/wiki/Game_programming">game loop</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On each loop tick, a function is called to get the last event that was generated by some action in the game.  Depending on the nature of this event (keystroke, mouse click), a follow-up action is taken that either interrupts the loop or creates additional events, and the process continues.  It is possible to illustrate all this with such pseudocode: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    new_event = get_new_event() #    #        if new_event.type == "LEFT_MOUSE_CLICK": open_menu() elif new_event.type == "ESCAPE_KEY_PRESS": quit_game() elif new_event.type == "UP_KEY_PRESS": move_player_north() # ... and many more events redraw_screen() #       tick(50) #  50 </span></span></code> </pre> <br>  The code will again and again check for new events and perform actions based on them.  In particular, this creates an illusion of response in real time.  As will become clear later, this is just what we need to start the simulation of high-frequency trading. <br><br><h4>  Why event-oriented backtester </h4><br>  Event-oriented systems have several advantages over the vectorized approach: <br><br><ul><li>  <b>Reuse code</b> .  Due to its nature, an event-oriented testing module can be used both for working with historical data and for real trading on the stock exchange, if only minimal "refinement" of components is necessary.  In the case of vectorized back-testers, we need to have the entire data set at once for statistical analysis. </li><li>  <b>Prediction of distortion</b> .  Event-oriented backtesters perceive market data as ‚Äúevents‚Äù that need to be reacted to.  Thus, it is possible to ‚Äúfeed‚Äù information to the module, the response to which will most closely correspond to what will be observed later in real trading. </li><li>  <b>Realism</b> .  Event-oriented back testers can significantly customize the process of order execution and optimize transaction costs.  It is important to be able to work with basic order types (market, limit) and more complex ones (market-on-open, MOO and market-on-close, MOC) - this way you can create a "custom" exception handler. </li></ul><br>  However, not everything is so cloudless, and an event-oriented system has its flaws.  First, they are much more difficult to create and test - more ‚Äúmoving parts‚Äù, and therefore more bugs.  Therefore, to create them it is recommended to apply the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">development through testing</a> .  Second, they are slower than vectorized systems. <br><br><h4>  Backster Review </h4><br>  To apply an event-oriented approach, first of all, it is necessary to deal with parts of our system that will be responsible for certain areas of work: <br><br><ul><li>  <b>An <code>event</code></b> is a fundamental unit of a class of event-oriented system.  Contains a type (for example, ‚ÄúMARKET‚Äù, ‚ÄúSIGNAL‚Äù, ‚ÄúORDER‚Äù or ‚ÄúFILL‚Äù), which affects how the event will be handled in a loop. </li><li>  <b>An <code>event queue</code></b> is an in-memory Python object that stores all objects of the <code>Event</code> subclasses generated by the rest of the system. </li><li>  <b><code>DataHandler</code></b> is an abstract base class (ABK), which is an interface for processing historical and current market data.  This increases the flexibility of the system, since the modules of the strategy and portfolio management can be used both for testing on historical data and for working on a ‚Äúlive‚Äù market.  The DataHandler generates a <code>MarketEvent</code> event at each heartbeat of the system. </li><li>  <b>Strategy module ( <code>Strategy</code> )</b> is another ABA, which is an interface for collecting market data and generating signal events ( <code>SignalEvent</code> ), which are used by the <code>Portfolio</code> object.  <code>SignalEvent</code> contains the symbol of the exchange ticker, the direction of the order (Long, Short) and a timestamp. </li><li>  <b><code>Portfolio</code></b> is also ABA, responsible for processing orders related to the current and subsequent positions implied by the <code>Strategy</code> .  This includes risk management portfolio, including control of the size of positions and analysis of market sectors.  In more complex implementations, this part of the work can be transferred to the <code>RiskManagement</code> class.  <code>Portfolio</code> takes <code>SignalEvent</code> from the queue and generates order events ( <code>OrderEvent</code> ), which also get into the queue. </li><li>  <b><code>ExecutionHandler</code></b> - in our case simulates a connection to the brokerage system.  The task of the handler is to take OrderEvent events from the queue, execute them (in simulation mode or through a real connection to the broker).  When the order is executed, the handler generates a <code>FillEvent</code> event that describes the transaction, including broker and exchange fees, and slippage (if it is taken into account in the model). </li><li>  <b>Loop</b> - all described components are included in the event loop, which processes all types of events, directing them to the appropriate module of the system. </li></ul><br>  Above, we described the basic model of the trading layout, which can be complicated and expanded in many areas, for example, in the area of ‚Äã‚Äãoperation of the <code>Portfolio</code> module.  In addition, you can make different models of transaction costs in a separate class hierarchy.  In our case, however, this will only create unnecessary difficulties, so we will only gradually introduce more realism into the system. <br><br>  Below is a piece of Python code that demonstrates the practical work of the backtester.  There are two loops in the code.  The outer loop is used to give the back tester a heartbeat.  In online trading, this means the frequency with which the market data is requested.  For testing strategies on historical data, this is not a required component, since market data is poured into the system in parts - see the <code>bars.update_bars()</code> . <br><br>  An internal loop is needed to handle events from the Queue object.  Specific events are delegated to the respective components in the queue, new events are added sequentially.  When the queue is empty heartbeat loop makes a new round: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      bars = DataHandler(..) strategy = Strategy(..) port = Portfolio(..) broker = ExecutionHandler(..) while True: #   (  ,    ) if bars.continue_backtest == True: bars.update_bars() else: break #   while True: try: event = events.get(False) except Queue.Empty: break else: if event is not None: if event.type == 'MARKET': strategy.calculate_signals(event) port.update_timeindex(event) elif event.type == 'SIGNAL': port.update_signal(event) elif event.type == 'ORDER': broker.execute_order(event) elif event.type == 'FILL': port.update_fill(event) #     10  time.sleep(10*60)</span></span></code> </pre><br><h4>  Event Classes </h4><br>  There are four types of events in the described scheme: <br><br><ul><li>  <b><code>MarketEvent</code></b> - initiated when the outer loop starts a new ‚Äúheart beat‚Äù.  It occurs when a DataHandler object receives a new update of market data for any monitored financial instruments.  It is used to start the generation of trading signals by the object <code>Strategy</code> .  The event object contains the identifier of what is a market event, and no other structure. </li><li>  <b><code>SignalEvent</code></b> - The <code>Strategy</code> object uses market information to create a new <code>SignalEvent</code> signal event.  This event contains a ticker symbol, generation timestamp and order direction (long or short).  Such signaling events are used by the <code>Portfolio</code> object as a kind of hint on how to trade. </li><li>  <b><code>OrderEvent</code></b> ‚Äî When a <code>Portfolio</code> object receives a <code>SignalEvent</code> , it uses such events for a broader portfolio context (calculation of risks and position size).  All this leads to the creation of an <code>OrderEvent</code> , which is then sent to the <code>ExecutionHandler</code> . </li><li>  <b><code>FillEvent</code></b> - when ExecutionHandler receives an <code>OrderEvent</code> , it must execute it.  After a transaction has occurred, a <code>FillEvent</code> event is created that describes the cost of buying or selling and transaction costs (slippage, commissions, etc.) </li></ul><br>  The parent class is called <code>Event</code> - this is a base class that does not provide any functionality or special interface.  In further implementations, the <code>Event</code> class will most likely become more difficult, so it is worthwhile to foresee such an opportunity in advance by creating a class hierarchy: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># event.py class Event(object): """ Event ‚Äî   ,     () ,       . """ pass</span></span></code> </pre><br>  <code>MarketEvent</code> inherits from <code>Event</code> and carries a little more than a simple self-identification like 'MARKET': <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># event.py class MarketEvent(Event): """          . """ def __init__(self): """  MarketEvent. """ self.type = 'MARKET'</span></span></code> </pre><br>  <code>SignalEvent</code> requires a ticker symbol, time stamp and order direction, which the portfolio object can use as a ‚Äútip‚Äù when trading: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># event.py class SignalEvent(Event): """    Signal   Strategy.    Portfolio,    . """ def __init__(self, symbol, datetime, signal_type): """  SignalEvent. : symbol -  ,   Google ‚Äî 'GOOG'. datetime -     . signal_type - 'LONG'  'SHORT'. """ self.type = 'SIGNAL' self.symbol = symbol self.datetime = datetime self.signal_type = signal_type</span></span></code> </pre><br>  <code>OrderEvent</code> more complicated than <code>SignalEvent</code> , and contains an additional field for specifying the number of units of a financial instrument in an order.  The number is determined by the limitations of the <code>Portfolio</code> object.  In addition, <code>OrderEvent</code> contains the <code>print_order()</code> method, which is used to output information to the console if necessary: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># event.py class OrderEvent(Event): """     Order   .    (, GOOG),  (market  limit),   . """ def __init__(self, symbol, order_type, quantity, direction): """    ( MKT   LMT),          (BUY  SELL). : symbol - ,     . order_type - 'MKT'  'LMT'   Market  Limit. quantity - -  (integer)     . direction - 'BUY'  'SELL'     . """ self.type = 'ORDER' self.symbol = symbol self.order_type = order_type self.quantity = quantity self.direction = direction def print_order(self): """  ,    Order. """ print "Order: Symbol=%s, Type=%s, Quantity=%s, Direction=%s" % \ (self.symbol, self.order_type, self.quantity, self.direction)</span></span></code> </pre><br>  <code>FillEvent</code> is an <code>Event</code> increased complexity.  It contains the timestamp of the execution of the order, the ticker and information about the exchange on which it was executed, the number of units of a financial instrument (stocks, futures, etc.), the actual price of the transaction and related fees. <br><br>  Related costs are calculated using the brokerage system API ( <a href="http://www.itinvest.ru/promo/adv/">ITinvest</a> has its own <a href="http://www.itinvest.ru/services/robots/">API</a> ).  In our example, a US broker system is used, the commission of which is at least $ 1.30 per order with a single rate of $ 0.013 or $ 0.08 per share, depending on whether the number of shares exceeds 500 units or not. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># event.py class FillEvent(Event): """     (Filled Order),  .    ,   /   .    . """ def __init__(self, timeindex, symbol, exchange, quantity, direction, fill_cost, commission=None): """   FillEvent.  ,  , , ,   () .     ,   Fill            (  API) : timeindex -      . symbol - ,    . exchange - ,     . quantity -     . direction -   ('BUY'  'SELL') fill_cost -  . commission -  ,   . """ self.type = 'FILL' self.timeindex = timeindex self.symbol = symbol self.exchange = exchange self.quantity = quantity self.direction = direction self.fill_cost = fill_cost # Calculate commission if commission is None: self.commission = self.calculate_ib_commission() else: self.commission = commission def calculate_ib_commission(self): """       API  (  , , ..   ).    . """ full_cost = 1.3 if self.quantity &lt;= 500: full_cost = max(1.3, 0.013 * self.quantity) else: # Greater than 500 full_cost = max(1.3, 0.008 * self.quantity) full_cost = min(full_cost, 0.5 / 100.0 * self.quantity * self.fill_cost) return full_cost</span></span></code> </pre><br>  That's all, thank you for your attention.  In the next part, we will talk about using market information ( <code>DataHandler</code> class) for testing historical data and real trading. <br><br><h5>  All materials cycle: </h5><br><ul><li>  <a href="http://habrahabr.ru/company/itinvest/blog/263097/">Event-oriented Python backtesting step by step.</a>  <a href="http://habrahabr.ru/company/itinvest/blog/263097/">Part 1</a> </li><li>  <a href="http://habrahabr.ru/company/itinvest/blog/264141/">Event-oriented Python backtesting step by step.</a>  <a href="http://habrahabr.ru/company/itinvest/blog/264141/">Part 2</a> </li><li>  <a href="http://habrahabr.ru/company/itinvest/blog/266623/">Event-oriented Python backtesting step by step.</a>  <a href="http://habrahabr.ru/company/itinvest/blog/266623/">Part 3</a> </li><li>  <a href="http://habrahabr.ru/company/itinvest/blog/268929/">Event-oriented Python backtesting step by step.</a>  <a href="http://habrahabr.ru/company/itinvest/blog/268929/">Part 4</a> </li><li>  <a href="http://habrahabr.ru/company/itinvest/blog/270215/">Event-oriented Python backtesting step by step.</a>  <a href="http://habrahabr.ru/company/itinvest/blog/270215/">Part 5 (and last)</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/263097/">https://habr.com/ru/post/263097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263085/index.html">Site security audit through the eyes of the customer</a></li>
<li><a href="../263087/index.html">IOS development testing</a></li>
<li><a href="../263089/index.html">Automatic search for routers with standard passwords</a></li>
<li><a href="../263091/index.html">Pacemaker-based HA-Cluster for LXC and Docker container virtualization</a></li>
<li><a href="../263093/index.html">Crackme Chiwaka1 study</a></li>
<li><a href="../263099/index.html">Skype turned to people?</a></li>
<li><a href="../263101/index.html">Work with passwords: how to protect your accounts (expert opinion)</a></li>
<li><a href="../263103/index.html">Unobvious performance problems in Doctrine related to the hydration of objects</a></li>
<li><a href="../263105/index.html">Getting rid of the ‚Äúhistorical reasons‚Äù in cmd.exe in an easier and standard way.</a></li>
<li><a href="../263109/index.html">User data leakage in QIWI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>