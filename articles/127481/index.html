<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization for the new price</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="App Engine is in full swing towards a bright future and a new method of calculating resources. Panic and chaos moved into the ranks of developers unde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization for the new price</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/427/923/c8c/427923c8cce77df9cb243a415cd80810.jpg" alt="image"><br>  App Engine is in full swing towards a bright future and a new method of calculating resources.  Panic and chaos moved into the ranks of developers under AE - too much is kept in the strictest secret (or they don‚Äôt really know in the company what to do).  But today we will not discuss whether the blobstore will be included in free quotas, or you will have to pay for access to it only.  We will not discuss where to go if the new prices are not affordable at all and we will not talk about $ 50 ‚Äúfreebies‚Äù that Google is trying to soften the transition to new rails (especially since this good news was sent to all application administrators). <br><br>  Today we will talk about application optimization.  You have already optimized your application for minimum CPU and memory consumption?  Forget about it, now it is secondary and your money will be taken by other measures. <a name="habracut"></a><br><br><h3>  Introduction. </h3><br>  As part of the transition to <a href="http://www.google.com/enterprise/cloud/appengine/pricing.html">new pricing</a> , we updated the set of resources included in the application usage report.  We abandon the CPU clock and move to a system that will take into account the number of instances running hours (Frontend and Backend), the number of API calls, the amount of stored data and traffic.  More information in our <a href="http://code.google.com/appengine/kb/postpreviewpricing.html">FAQ</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before launching a new pricing model, we released comparative bills so that you can see how it affects your costs.  You can start optimizing your application before the price changes take effect and see how the optimizations affect your bill. <br><br>  In this article, we will show how to interpret the new usage report and show some strategies that can be used to manage resources, and how they can affect the performance of your application. <br><br><h3>  We study old and new reports. </h3><br>  Daily usage reports are in the control panel on the Billing History page located at <code>_https://appengine.google.com/billing/history?&amp;app_id=$APP_ID</code> .  Clicking the [+] icon next to one of the reports will expand the details of a single day, where you can see new and old resources.  A preview of the usage report for your application looks like this: <br><img src="http://code.google.com/appengine/articles/new_bill.png" alt="image"><br>  We will go through the list of parameters in the invoice and explain what they mean, review some resource management strategies and explain how they will affect the performance of the application. <br><br><h3>  Instance management. </h3><br>  The first two lines of the new account relate to the use of the application instances.  You can read <a href="http://code.google.com/appengine/docs/adminconsole/instances.html">about instances</a> in our documentation.  You can see the number of instances used by the application in the control panel at <code>_https://appengine.google.com/instances?&amp;app_id=$APP_ID</code> or by selecting the Instances graph in the drop-down list at <code>_https://appengine.google.com/dashboard?&amp;app_id=$APP_ID</code> . <br><br><h4>  App Engine Scheduler. </h4><br>  App Engine uses a scheduling algorithm to determine how many instances the application needs to serve its traffic.  With each request received by your application, we decide whether to service it to an available instance (to what is idle or receive parallel hapros), whether to send a request to the waiting queue, or to launch a new instance for this request.  We make decisions based on the available instances, the speed with which the application responds to requests (its latency) and the time it takes to start and initialize a new instance before starting to service requests.  In most cases, when we consider that we can service the request faster by launching a new instance, we launch a new instance. <br><br>  Of course, application traffic is erratic, so the scheduler continues to track the number of idle instances of your application.  These instances can be useful for servicing traffic hops without noticeable user delay.  If the scheduler determines that the application has too many idle instances, then it withdraws resources by stopping one of the instances. <br><br><h4>  Strategies to reduce the number of instances used. </h4><br><h5>  Reduced latency. </h5><br>  The latency of your application has a big impact on the number of instances needed to service the application.  Therefore, reducing the delay can greatly affect the number of required instances.  Here is a list of actions to reduce latency: <br><ul><li>  <b>Cache frequently used shared data more.</b>  In other words: use memcache.  If you also set cache-control headers for an application, you can greatly increase the efficiency of caching by servers and browsers.  Even caching for a few seconds can greatly increase the efficiency of the application.  Python applications should also use <a href="http://code.google.com/appengine/docs/python/runtime.html">runtime</a> caching. </li><li>  <b>Use memcache more efficiently.</b>  Use batch calls instead of a number of single. </li><li>  <b>Use tasks (Tasks) for actions not related to queries.</b>  If your application performs actions that can be performed outside of the serving request user, send it to tasks.  Sending these actions to the Task Queue instead of waiting for execution until the completion of the request will significantly reduce noticeable delays to the user.  A task queue can provide much greater control over execution speed and helps distribute the load more evenly. </li><li>  <b>Use data storage more efficiently.</b>  We delve into the details below. </li><li>  <b>Send URL Fetch requests in parallel.</b> <ul><li>  Use asynchronous API calls ( <a href="http://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/urlfetch/URLFetchService.html">Java</a> , <a href="http://code.google.com/appengine/docs/python/urlfetch/asynchronousrequests.html">Python</a> ) </li><li>  Combine URL Fetch calls into packets (which you can process one at a time during a user request) and process them in an offline task in parallel with the asynchronous URL Fetch. </li></ul></li><li>  <b>Record HTTP sessions in Java asynchronously.</b>  HTTP sessions allow you to configure your application to asynchronously write session data to the datastore by adding <code>&lt;async-session-persistence enabled="true"/&gt;</code> to the appengine-web.xml file.  Session data is always synchronously recorded in memcache, and if the request tries to get data that is not in memcache, then the request is sent to the datastore, which may not even have the latest update.  This means that there is a small risk that the application will receive expired session data, but for most applications, the speed gain far outweighs this risk. </li></ul><br><h5>  Adjust the scheduler manually. </h5><br>  On the Application Settings page in the control panel there are two sliders that will help you set some variables used by the scheduler to control the instances of the application.  Here is a brief explanation of how to use them to find a compromise between performance and resource use: <br><ul><li>  <b>Reduce the maximum number of idle instances.</b>  Setting Max Idle Instances allows you to control the maximum number of idle instances of the application.  Setting this limit tells App Engine to stop any idle instances beyond this limit, so that they do not consume additional quotas or incur additional costs.  However, a smaller number of idle instances also means that the App Engine scheduler will have to launch new instances during a traffic jump, which may increase noticeable delays for users. </li><li>  <b>Increase the minimum latency.</b>  Increasing the Minimum Waiting Delay (Min Pending Latency) tells the App Engine scheduler not to start a new instance until the request is in the queue for more than a specified time.  If all instances are occupied, then the user service request may need to wait in a queue to reach this threshold.  Setting a large value for this parameter will require a smaller number of instances to start, but can result in large delays noticeable to the user during an increased load. </li></ul><br><h5>  Enable concurrent requests in Java. </h5><br>  In release <a href="http://code.google.com/p/googleappengine/wiki/SdkForJavaReleaseNotes">1.4.3,</a> we introduced the ability for your application instances to handle multiple simultaneous requests for Java.  Enabling this option will reduce the number of required instances, but to work with it correctly, your application must be thread-safe.  You can read more about parallel queries <a href="http://code.google.com/appengine/docs/java/config/appconfig.html">in the Java documentation</a> . <br><br>  <b>Note</b> : Multi-threading for Python will not be available until Python 2.7 is launched, which is in <a href="http://code.google.com/intl/en/appengine/docs/roadmap.html">the work plan</a> .  In Python 2.7, multithreaded instances can handle more requests and should not consume quotas of instances running hours while idle while waiting for responses from blocking APIs.  Since Python does not currently support simultaneous servicing of more than one request for one instance, and in order to allow all developers to adapt to simultaneous requests, we will give a 50% discount on opening hours of frontend instances before November 20, 2011. Python 2.7 is now in the closed stage testing. <br><br><h3>  Manage application repository. </h3><br>  App Engine calculates the storage cost based on the size of the objects in the data store, the size of the indices needed to maintain the data, and the amount of data in the blobstore. <br>  Here are some actions you can perform to check if there is more data in the index than necessary: <br><ul><li>  Use the Get Indexes feature ( <a href="http://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/AsyncDatastoreService.html">Java</a> , <a href="http://code.google.com/appengine/docs/python/datastore/functions.html">Python</a> ) to check which indexes are set for your application.  Removing any indexes that are not necessary for the application will save on data storage and reduce the cost of recording the object.  Also, you can see the running application indexes in the control panel at <code>_https://appengine.google.com/datastore/indexes?&amp;app_id=$APP_ID</code> . </li><li>  When designing data models, check whether you can write queries to reduce the total number of indices.  Read our <a href="http://code.google.com/appengine/docs/python/datastore/queries.html">query and index</a> documentation for more information on how App Engine creates indexes. </li></ul><br><br><h3>  Manage the use of datastore. </h3><br>  In the new model, we will take into account the number of operations performed in the datastore (instead of the currently used CPU resources).  Several strategies that can lead to a decrease in datastore resource consumption, as well as lower latency requests to the datastore: <br><ul><li>  Reconfigure data modeling to replace queries with more efficient and cheaper key-receiving. </li><li>  Use only key requests instead of all object requests when this is possible. </li><li>  To reduce latency, replace multiple single <code>get()</code> requests with one batch <code>get()</code> . </li><li>  For pagination, use datastore pointers instead of offset. </li><li>  Parallelize multiple requests to datastore using the asynchronous datastore API ( <a href="http://code.google.com/appengine/docs/java/datastore/async.html">Java</a> , <a href="http://code.google.com/appengine/docs/python/datastore/async.html">Python</a> ). </li></ul><br><br><h3>  Traffic management </h3><br>  The main way to reduce outgoing traffic is always when it is possible to put the appropriate <code>Cache-Control</code> header in the responses and set a reasonable expiration date for static files ( <a href="http://code.google.com/appengine/docs/java/config/appconfig.html">Java</a> , <a href="http://code.google.com/appengine/docs/python/config/appconfig.html">Python</a> ).  Using the <code>Cache-Control: public</code> header <code>Cache-Control: public</code> will allow proxy servers and user browsers to cache responses for a designated time. <br><br>  Incoming traffic is more difficult to control, as this is the amount of data sent by users to the application.  However, it is a good opportunity to mention the DoS protection service ( <a href="http://code.google.com/appengine/docs/java/config/dos.html">Java</a> , <a href="http://code.google.com/appengine/docs/python/config/dos.html">Python</a> ), which will allow you to block traffic from unwanted IP. <br><br><h3>  Manage other resources. </h3><br>  The last values ‚Äã‚Äãin the report are using the Email, XMPP, and Channel APIs.  For these APIs, it's best to make sure that you use them efficiently.  One of the best ways to test API usage is to use Appstats ( <a href="http://code.google.com/appengine/docs/python/tools/appstats.html">Python</a> , <a href="http://code.google.com/appengine/docs/java/tools/appstats.html">Java</a> ) to make sure that the application does not make unnecessary calls.  It is also always a good idea to make sure that you check the level of errors and look for any possible incorrect calls.  In some cases it is possible to catch such calls in advance. </div><p>Source: <a href="https://habr.com/ru/post/127481/">https://habr.com/ru/post/127481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127472/index.html">Chrome's most important feature</a></li>
<li><a href="../127473/index.html">Proper validation of XML data in java-projects</a></li>
<li><a href="../127474/index.html">Virus without programming</a></li>
<li><a href="../127478/index.html">Jets - Flight & Seat Advisor - an application to select seats in airplanes</a></li>
<li><a href="../127479/index.html">5 reasons why it is worth switching from BTC to SolidCoin</a></li>
<li><a href="../127482/index.html">JavaScript scope and ‚Äúraising‚Äù variables and function declarations</a></li>
<li><a href="../127484/index.html">Sony, Toshiba and Hitachi create a single manufacturer of touchscreen LCD displays for mobile devices.</a></li>
<li><a href="../127485/index.html">Workable systems in IT and car</a></li>
<li><a href="../127486/index.html">Belgians won the best video contest with smart robots</a></li>
<li><a href="../127487/index.html">How to trees on jQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>