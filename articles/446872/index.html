<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study OpenCV on StereoPi: depth map by video</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we want to share a series of examples on Python for OpenCV learners on the Raspberry Pi, namely for the two-chamber StereoPi board. The finished...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study OpenCV on StereoPi: depth map by video</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/hb/xt/po/hbxtpox_r6mswlkshq4w3cpovr4.gif"><br><br>  Today we want to share a series of examples on Python for OpenCV learners on the Raspberry Pi, namely for the two-chamber StereoPi board.  The finished code (plus the Raspbian image) will help you to go through all the steps, starting from capturing a picture and ending with getting a depth map from the captured video. <br><a name="habracut"></a><br><h3>  Introductory </h3><br>  I want to stress right away that these examples are for a comfortable immersion in the topic, and not for a production solution.  If you are an advanced user of OpenCV and dealt with raspberries, then you know that for full-fledged work it is desirable to code on a sishechka, and even use a raspberry GPU.  At the end of the article I will touch upon the "bottlenecks" of the python solution and performance in general in a little more detail. <br><br><h3>  What we work with </h3><br>  As iron we have such a setup here: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/or/pd/9u/orpd9ufeuctr0lbmsk0kfogroao.jpeg"><br><br>  StereoPi board, on board the Raspberry Pi Compute Module 3+.  Two of the simplest cameras for the Raspberry Pi version V1 are connected (on the ov5647 sensor). <br><br>  What is established: <br><br><ul><li>  Raspbian Stretch (kernel 4.14.98-v7 +) </li><li>  Python 3.5.3 </li><li>  OpenCV 3.4.4 (pre-compiled, 'pip' from Python Wheels) </li><li>  Picamera 1.13 </li><li>  StereoVision lib 1.0.3 (https://github.com/erget/StereoVision) </li></ul><br>  The process of installing all the software is beyond the scope of this article, and we simply suggest downloading a ready-made Raspbian image (links to the githab at the end of the article). <br><br><h3>  Step One: Capturing a Picture </h3><br>  To do this, use the script 1_test.py <br><br>  Open the console, go from the home folder to the folder with examples: <br><br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> stereopi-tutorial</code> </pre> <br>  Run the script: <br><br><pre> <code class="bash hljs">python 1_test.py</code> </pre> <br>  After launch, a thumbnail of our stereo image is displayed.  The process can be interrupted by pressing the Q button. This will save the last captured image, which will be used in one of the following scripts to set up a depth map. <br><br>  This script allows you to make sure that all the hardware is working correctly, as well as get the first image for future use. <br><br>  Here is the work of the first script: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wllLrNUw3SE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Step Two: Collect Images for Calibration </h3><br>  If we talk about a spherical horse in vacuum, then to get a good quality depth map we need to have two absolutely identical cameras, the vertical and optical axes of which are ideally parallel, and the horizontal axes coincide.  But in the real world, all the cameras are slightly different, and it‚Äôs impossible to arrange them perfectly.  Therefore, a software calibration trick was invented.  With the help of two cameras from the real world, a large number of pictures of a previously known object are taken (we have this picture with a chessboard), and then a special algorithm calculates all the ‚Äúnonideality‚Äù and tries to correct the pictures so that they are close to the ideal. <br><br>  This script makes the first stage of work, namely it helps to make a series of photos for calibration. <br><br>  Before each photo the script starts a 5-second countdown.  This time, as a rule, is enough to move the board to a new position, make sure that on both cameras it does not crawl over the edges, and fix its position (so that there is no smearing on the photo).  By default, the series size is set to 30 photos. <br><br>  Run: <br><br><pre> <code class="bash hljs">python 2_chess_cycle.py</code> </pre> <br>  Process: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1XCAlU3k-xs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  As a result, we have a series of photos in the folder / scenes. <br><br><h3>  Cut the pictures into pairs </h3><br>  The third script, 3_pairs_cut.py, cuts the photos you have taken into ‚Äúleft‚Äù and ‚Äúright‚Äù pictures and saves them in the / pairs folder.  In fact, we could eliminate this script and do the cutting on the fly, but it is very useful for further experiments.  For example, you can save the thread from different series, use your own scripts to work with these pairs, or even send pictures as pictures of other stereo cameras as pairs. <br><br>  Plus, before each picture is cut, the script displays its image, which often allows seeing the unsuccessful photos before the next calibration stage and simply deleting them. <br><br>  Run the script: <br><br><pre> <code class="bash hljs">python 3_pairs_cut.py</code> </pre> <br>  Short video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/95DWmPECbDc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In the finished image there is a set of photos and chopped pairs that we used for our experiments. <br><br><h3>  Calibration </h3><br>  The 4_calibration.py script draws all pairs with chess boards to itself and calculates the necessary corrections to correct the pictures.  The script made automatic garbage photos, which are not found a chessboard, so that in the case of unsuccessful photos, the work does not stop.  After all 30 pairs of pictures are loaded, the counting begins.  It takes us about a minute and a half.  After completion, the script takes one of the stereo pairs, and, based on the calculated calibration parameters, ‚Äúcorrects‚Äù them, displaying a rectified picture.  At this point, you can evaluate the quality of the calibration. <br><br>  Run the command: <br><br><pre> <code class="bash hljs">python 4_calibration.py</code> </pre> <br>  Calibration script in work: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vtPhu23tKGo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Depth Map Setup </h3><br>  The 5_dm_tune.py script loads the image made by the first script and the calibration results.  Next, an interface is displayed that allows you to change the settings of the depth map and see what is changing.  Tip: before setting the parameters, make a frame in which you will have objects at the same time at different distances: near (30-40 centimeters), at an average distance (meter-two) and in the distance.  This will allow you to choose the parameters for which close objects will be red in color, and distant objects will be dark blue. <br><br>  In the image is a file with our depth map settings.  You can load our settings in the script simply by clicking the ‚ÄúLoad settings‚Äù button. <br><br>  Run: <br><br><pre> <code class="bash hljs">python 5_dm_tune.py</code> </pre> <br>  Here is the setup process: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Z4j3NrMyeGE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Real-Time Depth Map </h3><br>  The last script 6_dm_video.py builds a depth map by video, using the results of previous scripts (calibration and setting of the depth map). <br><br>  Run: <br><br><pre> <code class="bash hljs">python 6_dm_video.py</code> </pre> <br>  Actually the result: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/f29arVstfZA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  We hope that our scripts will be useful in your experiments! <br><br>  Just in case, I‚Äôll add that all scripts have keystroke processing, and you can stop working by pressing the Q button. If you stop roughly, for example, Ctrl + C, the process of interaction between Python and the camera may break and you will need to restart the raspberry. <br><br><h3>  For advanced </h3><br><ul><li>  The first script in the process of work displays the average time between frame captures, and on completion - the average FPS.  This is a simple and convenient tool for selecting such image parameters in which the python is still ‚Äúnot choking‚Äù.  With it, we picked up 1280x480 at 20 FPS, in which the video is given without delay. </li><li>  You can notice that we are capturing a stereo pair at a resolution of 1280x480, and then scaling it up to 640x240. <br><br>  There is a reasonable question: why all this, and why not immediately capture a reduced picture and not load our python by decreasing it? <br><br>  Answer: with direct capture at very low resolutions in the raspberry core, while there are problems (the picture breaks).  Therefore, we take a larger resolution, and then reduce the picture.  Here we use a little trick: the picture does not scale with a python, but with the help of a GPU, so there is no load on the core arm. </li><li>  Why capture video in BGRA format, not BGR? <br>  We use GPU resources to reduce the size of the image, and the BGRA format is native to the resize module.  If instead of BGRA we use BGR, we will have two drawbacks.  The first one is slightly lower than the final FPS (in our tests - 20 percent).  The second one is constant vorning in the PiCameraAlfaStripping console: using alpha-stripping;  you may find equivalent alpha format faster ‚Äù.  Googling thereof led to the Picamera documentation section, which tells about this trick. </li><li>  And where is PiRGBArray? <br><br>  It's like the native Picamera class to work with the camera, but here it is not used.  It already happened that in our tests, working with the ‚Äúmanually prepared‚Äù numpy array is much faster (about one and a half times) than with the use of the PiRGBArray.  This does not mean that PiRGBArray is bad, most likely these are our curved hands. </li><li>  How loaded is the percentage when calculating the depth map? <br>  Let's answer with the picture: <br><br><img src="https://habrastorage.org/webt/nn/ez/ef/nnezefyxuiuxx7difz1xctii16w.jpeg"><br><br>  We see that, of the 4 cores of the processor, only one of them is loaded, and that is 70%.  And this is despite the fact that we work with the GUI, and we are outputting images and maps of the depths to the user.  This means that there is a good performance margin, and fine tuning of OpenCV with OpenMP and other C-based buns, as well as a ‚Äúcombat‚Äù mode without a GUI can give very interesting results. </li><li>  What is the maximum FPS depth map obtained with these settings? <br><br>  The maximum achieved by us was 17 FPS, with 20 frames per second captured from the camera.  The most ‚Äúresponsive‚Äù in terms of speed parameters in the depth map settings are MinDisparity and NumOfDisparities.  This is logical, since they determine the number of ‚Äústeps‚Äù made by the search frame comparison window within the algorithm.  The second most responsive is preFilterCap, it affects, in particular, the ‚Äúsmoothness‚Äù of the depth map. </li><li>  What is the temperature of the processor? <br><br>  On Compute Module 3+ Lite (new series, with an iron ‚Äúcap‚Äù on the process) it shows something like this: <br><br><img src="https://habrastorage.org/webt/ba/p7/kw/bap7kwdbbhd0y2bmvebpqzimqpa.jpeg"></li><li>  How to use the GPU? <br><br>  At a minimum, it can be used for andistorstion and rectification of pictures in real time, for there are examples ( <a href="https://jywarren.github.io/fisheyegl/example/">here at WebGL</a> ), Python <a href="https://pi3d.github.io/">Pi3d</a> , as well as the Processing project ( <a href="https://pi.processing.org/tutorial/camera/">examples for raspberries</a> ). <br><br>  There is another interesting development by Koichi Nakamura, called <a href="https://github.com/nineties/py-videocore">py-videocore</a> .  In our correspondence with him, he expressed the idea that to speed up StereoBM, you can use its core and OpenCV sors <a href="https://docs.opencv.org/3.4/db/d8a/classcv_1_1cuda_1_1StereoBM.html">with Cuda support</a> .  In general, to optimize - nepahany edge, as they say. </li></ul><br>  Thank you for your attention, and here is the <a href="https://github.com/realizator/stereopi-tutorial">promised reference to the source</a> . </div><p>Source: <a href="https://habr.com/ru/post/446872/">https://habr.com/ru/post/446872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446860/index.html">History 3dfx Voodoo1</a></li>
<li><a href="../446862/index.html">What designers are waiting for at DUMP-2019: a review of the Design section</a></li>
<li><a href="../446864/index.html">Energy, heat and water</a></li>
<li><a href="../446866/index.html">Operating Systems: Three Easy Pieces. Part 2: Abstraction: The Process (Translation)</a></li>
<li><a href="../44687/index.html">Exherbo - a new milestone in the development of source-based distributors</a></li>
<li><a href="../446876/index.html">Moscow, April 18 - QIWI SERVER PARTY 4.0</a></li>
<li><a href="../44688/index.html">Selection of employees in the form of the game.</a></li>
<li><a href="../446880/index.html">Incorrect charts: our experience</a></li>
<li><a href="../446882/index.html">MIPT won the right to host the ICPC World Programming Championship in 2020 in Moscow</a></li>
<li><a href="../446884/index.html">What to read and see from fresh fiction: Mars, cyborg and the insurgent AI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>