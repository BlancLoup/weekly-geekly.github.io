<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ exception handling under the hood. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing to translate a series of articles about exception handling in C ++ 

 1 part 
 3 part 

 C ++ exceptions under the hood: cute personality 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ exception handling under the hood. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Continuing to translate a series of articles about exception handling in C ++ <br><br>  <a href="https://habrahabr.ru/post/279111/">1 part</a> <br>  <a href="https://habrahabr.ru/post/279149/">3 part</a> <br><br><h1>  C ++ exceptions under the hood: cute personality </h1><br>  Our trip to the amazing journey of exploring the work of exceptions is far from the end, we still have to learn something called "call frame information" that helps the Unwind library to unfold the stack, and also what the compiler writes in something called LSDA, in which determines which errors the method can handle.  And also we have already learned that the majority of magic occurs in a personal function that we have not yet seen in action.  Let's summarize what we already know about forwarding and catching errors (or, more precisely, what we already know about how the abandoned will be intercepted): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  the compiler translates a throw ad into a pair of <strong><strong>cxa_allocate_exception /</strong> xca_throw</strong> </li><li>  <strong>__cxa_allocate_exception throws</strong> an exception in memory </li><li>  <strong>__cxa_throw</strong> starts the deployment operation and passes an exception to the low-level deployment library, causing <em>_Unwind_RaiseException</em> </li><li>  Stacking stack uses CFI to find out which function is currently on the stack. </li><li>  Each function has LSDA, adding something called <strong>.gcc_except_table</strong> </li><li>  Expanding causes a personal function with the current stack frame and LSDA, which should continue to expand the stack if the current function does not have exception handlers of this type. </li></ul><a name="habracut"></a><br>  As long as we learned all this, it was the right time to write our own personalized function!  Our ABI is used so that when an exception is thrown, print the following: <br><br><pre><code class="hljs pgsql">alloc ex <span class="hljs-number"><span class="hljs-number">1</span></span> __cxa_throw <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> one handled __cxa_throw, terminate!</code> </pre> <br>  Go back to our <code>mycppabi</code> and add something like this: <br><br><pre> <code class="hljs java"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__gxx_personality_v0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ printf(<span class="hljs-string"><span class="hljs-string">"Personality function FTW\n"</span></span>); }</code> </pre> <br>  Let me remind you, you can see the actual code in <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v02">my githab repository</a> . <br><br>  And, of course, when we launch the application, our personal function will be called.  We see that on the right track, as well as we know what we want from it.  Why not use the correct function definition: <br><br><pre> <code class="hljs pgsql">_Unwind_Reason_Code __gxx_personality_v0 ( <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, _Unwind_Action actions, uint64_t exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context);</code> </pre> <br>  If we put it in our <code>mycppabi.cpp</code> , we get: <br><br><pre> <code class="hljs rust">#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; namespace __cxxabiv1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__class_type_info</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void foo() {} } ti; } #define EXCEPTION_BUFF_SIZE <span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> exception_buff[EXCEPTION_BUFF_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { void* __cxa_allocate_exception(size_t thrown_size) { printf(&amp;<span class="hljs-string"><span class="hljs-string">"alloc ex %i\n"</span></span>, thrown_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thrown_size &gt; EXCEPTION_BUFF_SIZE) printf(<span class="hljs-string"><span class="hljs-string">"Exception too big"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;exception_buff; } void __cxa_free_exception(void *thrown_exception); #include &lt;unwind.h&gt; typedef void (*unexpected_handler)(void); typedef void (*terminate_handler)(void); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__cxa_exception</span></span></span></span> { std::type_info * exceptionType; void (*exceptionDestructor) (void *); unexpected_handler unexpectedHandler; terminate_handler terminateHandler; __cxa_exception * nextException; int handlerCount; int handlerSwitchValue; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * actionRecord; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * languageSpecificData; void * catchTemp; void * adjustedPtr; _Unwind_Exception unwindHeader; }; void __cxa_throw(void* thrown_exception, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_info</span></span></span></span> *tinfo, void (*dest)(void*)) { printf(<span class="hljs-string"><span class="hljs-string">"__cxa_throw called\n"</span></span>); __cxa_exception *header = ((__cxa_exception *) thrown_exception - <span class="hljs-number"><span class="hljs-number">1</span></span>); _Unwind_RaiseException(&amp;header-&gt;unwindHeader); <span class="hljs-comment"><span class="hljs-comment">// __cxa_throw     printf("no one handled __cxa_throw, terminate!\n"); exit(0); } void __cxa_begin_catch() { printf("begin FTW\n"); } void __cxa_end_catch() { printf("end FTW\n"); } _Unwind_Reason_Code __gxx_personality_v0 ( int version, _Unwind_Action actions, uint64_t exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context) { printf("Personality function FTW!\n"); } }</span></span></code> </pre> <br>  Compile and link everything, then run and start to analyze each parameter of this function with a little help from gdb: <br><br><pre> <code class="hljs pgsql">Breakpoint <span class="hljs-number"><span class="hljs-number">1</span></span>, __gxx_personality_v0 (version=<span class="hljs-number"><span class="hljs-number">1</span></span>, actions=<span class="hljs-number"><span class="hljs-number">1</span></span>, exceptionClass=<span class="hljs-number"><span class="hljs-number">134514792</span></span>, unwind_exception=<span class="hljs-number"><span class="hljs-number">0x804a060</span></span>, context=<span class="hljs-number"><span class="hljs-number">0xbffff0f0</span></span>)</code> </pre> <br><ul><li>  <strong>version</strong> and <strong>exceptionClass</strong> depends on the language / ABI / compiler, toolchain / native-not native exception, etc.  Do not worry about this for our mini-ABI, we just catch all the exceptions. </li><li>  <strong>actions</strong> : used by <em><em>Unwind</em></em> to tell the personal function what to do (more on that later). </li><li>  <strong>unwind_exception</strong> : exception thrown through <strong>__cxa_allocate_exception</strong> (inherited from ... there is a lot of arithmetic, but using this pointer we can access our original exception) </li><li>  <strong>context</strong> : contains all information regarding the current stack frame, for example, LSDA.  We will use the context to determine that the current stack can handle exceptions (as well as determining whether to call the destructor). </li></ul><br>  Well, we have a working (well, at least, linkable) personal function.  It does not do very much, so we will further fill it with real behavior and try to make it handle exceptions. <br><br><h1>  C ++ exceptions under the hood: two-phase pass </h1><br>  We ended the previous chapter by adding a personal function that <em>Unwind</em> can call.  She, in general, does nothing, for now.  Our ABI already implements half of the work on throwing exceptions and catching them, but the personal function still has to learn how to correctly select the block (landing pad) for error handling.  We start this chapter with an attempt to understand the parameters that the <strong>__gxx_personality_v0</strong> function <strong>accepts</strong> and add real behavior to it: we will output "yes, the current stack unit can handle the exception". <br><br>  We already said that we wanted to spit on the version or class of exception in our mini ABI.  Well, let's score for now the context too: we just handle each exception in the first frame of the stack.  Do not forget to substitute the try / catch block in the function directly above the call to the method that throws exceptions, otherwise everything will break.  It is also worth remembering that the catch block will ignore the exception type.  How do we let the <code>_Unwind_</code> function know that we want to handle an exception? <br><br>  <strong>_Unwind_Reason_Code</strong> is the return value of a personal function that says to the <strong><em>Unwind</em></strong> function: did we find the landing pad to handle the error or not.  Let us return from our personal function * <em>_URC_HANDLER_FOUND</em> and see what happens: <br><br><pre> <code class="hljs pgsql">alloc ex <span class="hljs-number"><span class="hljs-number">1</span></span> __cxa_throw <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> FTW Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> FTW <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> one handled __cxa_throw, terminate!</code> </pre> <br>  See it?  We told the advertiser that we had found the handler, and he called the personal function again!  What the hell is going on here? <br><br>  Remember the action parameter?  This is how <em>Unwind</em> tells us exactly what it wants, because exception handling occurs in two stages: search and cleanup (or _UA_SEARCH_PHASE and _UA_CLEANUP_PHASE).  Let's go back to our recipe for error handling: <br><br><ul><li>  __cxa_throw / __ cxa_allocate_exception throws an exception and passes them to the low-level stack promotion library called _Unwind_RaiseException <br><br></li><li>  Spreader uses CFI to find out which function is currently in the stack (to find out how to start deploying a function) <br><br></li><li>  Each function has an LSDA part added to something called ".gcc_except_table" <br><br></li><li>  The advertiser is trying to determine the landing pad for an exception: <br><br><ul><li>  The extender calls a personal function with the action parameter: <strong>_UA_SEARCH_PHASE</strong> and the contex parameter: a pointer to the current frame of the stack. </li><li>  The personal function checks if the current frame stack can handle this exception by analyzing the LSDA </li><li>  If an exception can be processed, it returns _URC_HANDLER_FOUND </li><li>  If there is no one to handle the exception, _URC_CONTINE_UNWIND will be returned, and the distributor will continue to try to find a handler with the next stack frame. </li></ul><br></li><li>  If no landing pad is found, the default handler will be called (usually std :: terminate). <br><br></li><li>  If landing pad is found: <br><ul><li>  The unwrapper will begin processing the stack again, calling the personal function with the action parameter <strong>_UA_CLEANUP_PHASE</strong> . </li><li>  The personal function checks if the current stack window can handle this exception or not. </li><li>  If it cannot, then it launches the clear functions described in LSDA (and clears the objects placed in the current frame of the stack by calling destructors), and tells the advertiser to continue with the next frame. </li><li>  If it can process, then it does not run any cleanup code, but only tells the advertiser that we want to continue execution on the landing pad. </li></ul></li></ul><br>  Attention should be paid to these two important things: <br><br><ol><li>  Running in a two-phase mode for catching exceptions means that we can get the original and full stack trace exceptions (if we were deployed in one pass along with the deletion, we would not have a stack trace, or we would have to keep a copy of it!). </li><li>  Running _UA_CLEANUP_PHASE and re-calling for each frame, even if we know that the frame can handle an exception, is also very important: a personal function has the ability to call all destructors for objects created in this scope.  This is what makes RAII exceptions (Resource Acquisition Is Initialization, Resource Acquisition Is Initialization) safe idiom. </li></ol><br>  Now we understand how the handler search phase works and we can continue the implementation of our personal function. <br><br><h1>  C ++ exceptions under the hood: catching our first exception </h1><br>  We have completed the previous chapter, having taught the personal function to respond to the advertiser.  It is time to add real behavior <strong>__gxx_personality_v9</strong> : we will teach it to process the passage in two phases. <br><br>  Our personal function will take the form: <br><br><pre> <code class="hljs cpp">_Unwind_Reason_Code __gxx_personality_v0 ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version, _Unwind_Action actions, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp;_UA_SEARCH_PHASE) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, lookup phase\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_HANDLER_FOUND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_CLEANUP_PHASE) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, cleanup\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_INSTALL_CONTEXT; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_FATAL_PHASE1_ERROR; } }</code> </pre> <br>  Let me remind you: the source code can be found on <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v03">my github repository</a> . <br><br>  Run and see what happens: <br><br><pre> <code class="bash hljs">alloc ex 1 __cxa_throw called Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>, lookup phase Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>, cleanup try_but_dont_catch handled the exception catchit handled the exception</code> </pre> <br>  It works, but something goes wrong: the handler inside the catch / try block never starts!  This is due to the fact that the personal function tells the developer to "set context" (i.e. continue execution), but never tells which particular context.  In this case, it is likely to continue execution after the landing pad, but this, I believe, is indefinite behavior.  Next, we will see how to specify a point, where to continue with the execution of the code (landing pad), using the information available in <strong>.gcc_except_table</strong> (our old friend, LSDA). <br><br><h1>  C ++ exceptions under the hood: <em>Unwind</em> information of the current frame </h1><br>  We left our mini-ABI capable of throwing exceptions, and now we are working on catching them.  We have implemented a personal function that can detect and listen to an exception, but it is not yet complete: even if it can notify the advertiser when he should stop, she still cannot run the code inside the error handler block.  This is better than what we started with, but we still have a long way to go before creating a suitable ABI error handling system.  Can we improve our code? <br><br>  How can we tell the advertiser where our landing pad is so that we can continue executing the code inside our catch block?  If we go back to <a href="http://mentorembedded.github.io/cxx-abi/abi-eh.html">the ABI specification</a> , we‚Äôll find there some context management functions that can be useful: <br><br><ul><li>  <strong>_Unwind_GetLanguageSpecificData</strong> to get the LSDA of the current frame.  We should learn to look for landing pads and destrcutors using this feature. </li><li>  <strong>_Unwind_GetRegionStart</strong> to get a pointer to the instruction at the beginning of the current function (pointer to the function corresponding to the current frame) <br><br></li><li>  <strong>_Unwind_GetIP</strong> to get the instruction pointer inside the current stack frame (instruction pointer) (pointer to the place where the function call in the next frame will be completed. It will become clearer with examples below). </li></ul><br>  Let's look at these functions with gdb.  On my car: <br><br><pre> <code class="hljs cpp">Breakpoint <span class="hljs-number"><span class="hljs-number">1</span></span>, __gxx_personality_v0 (version=<span class="hljs-number"><span class="hljs-number">1</span></span>, actions=<span class="hljs-number"><span class="hljs-number">6</span></span>, exceptionClass=<span class="hljs-number"><span class="hljs-number">134515400</span></span>, unwind_exception=<span class="hljs-number"><span class="hljs-number">0x804a060</span></span>, context=<span class="hljs-number"><span class="hljs-number">0xbffff0f0</span></span>) at mycppabi.cpp:<span class="hljs-number"><span class="hljs-number">77</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* lsda = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)_Unwind_GetLanguageSpecificData(context); <span class="hljs-number"><span class="hljs-number">85</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> ip = _Unwind_GetIP(context) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> funcStart = _Unwind_GetRegionStart(context); <span class="hljs-number"><span class="hljs-number">87</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> ipOffset = ip - funcStart;</code> </pre> <br>  If we investigate these variables, we will see that <strong>_Unwind_GetRegionStart</strong> points to the current stack frame (try_but_dont_catch) and that <strong>_Unwind_GetIp</strong> is the IP to the position where the next frame was called.  _Unwind_GetRegionStart points us to the place where the exception was the first time it was passed, this is a bit difficult to explain, let's leave it for later.  We also do not see the LSDA pointer here, but we can assume that it is right behind the function code, while _Unwind_GetLanguageSpecificData refers directly to the line after the end of the function. <br><br><pre> <code class="hljs matlab">_Unwind_GetIP = (void *) <span class="hljs-number"><span class="hljs-number">0x804861d</span></span> _Unwind_GetRegionStart = (void *) <span class="hljs-number"><span class="hljs-number">0x8048612</span></span> _Unwind_GetLanguageSpecificData = (void *) <span class="hljs-number"><span class="hljs-number">0x8048e3c</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointer</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-function"> = 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x8048612</span></span></span><span class="hljs-function"> &amp;&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gdb)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disassemble</span></span></span><span class="hljs-function"> /</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dump</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assembler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">code</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: 10 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...]</span></span></span><span class="hljs-function"> 11 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-function"> { 12 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048619</span></span></span><span class="hljs-function"> &lt;+7&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x80485e8</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">&gt; 13 } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Fake_Exception&amp;)</span></span></span><span class="hljs-function"> { 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048651</span></span></span><span class="hljs-function"> &lt;+63&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x804874a</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__cxa_begin_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">&gt; 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048665</span></span></span><span class="hljs-function"> &lt;+83&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x804875e</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__cxa_end_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">&gt; 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0804866a</span></span></span><span class="hljs-function"> &lt;+88&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jmp</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x804861e</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_but_dont_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">+12&gt; 14 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">("Caught a Fake_Exception!\n")</span></span></span><span class="hljs-function">; 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048659</span></span></span><span class="hljs-function"> &lt;+71&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movl</span></span></span><span class="hljs-function"> $0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x8048971</span></span></span><span class="hljs-function">,</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%esp)</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048660</span></span></span><span class="hljs-function"> &lt;+78&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x80484c0</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function">@</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt</span></span></span><span class="hljs-function">&gt; 15 } 16 17 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">("try_but_dont_catch handled the exception\n")</span></span></span><span class="hljs-function">; 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0804861e</span></span></span><span class="hljs-function"> &lt;+12&gt;;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movl</span></span></span><span class="hljs-function"> $0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x8048948</span></span></span><span class="hljs-function">,</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%esp)</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x08048625</span></span></span><span class="hljs-function"> &lt;+19&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x80484c0</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function">@</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt</span></span></span><span class="hljs-function">&gt; 18 } 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x0804862a</span></span></span><span class="hljs-function"> &lt;+24&gt;: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> $0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x24</span></span></span><span class="hljs-function">,%</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">esp</span></span></span></span></code> </pre><br>  With <em>Unwind,</em> we can now get enough information about the current frame of the stack to determine whether we can handle the exception or not, as well as how we should handle it.  The last step we need before we can determine whether we can determine the landing pad or not is that we need to interpret the CFI information at the end of the function.  This is part of the DWARF specification and its implementation is somewhat complicated.  As in our ABI, we will use the required minimum. <br><br><h1>  C ++ exceptions under the hood: reading the CFI table </h1><br>  In order to properly handle exceptions, our personal function, which we implement in our ABI, must read LSDA to find out which frame (that is, which function) can handle the exception, and which exception, and also to find out where the landing pad (catch- block) can be found.  The LSDA table is specified in the CFI format, and in this chapter we will learn how to read it. <br><br>  CFI data can be read quite simply, but there are a few pitfalls that need to be taken into account.  Two, in fact: <br><br><ol><li>  There is very little documentation about .gcc_except_table (in fact, I found only a couple of letters about it), so we will have to watch a lot of source codes, as well as understand the disassembled code. </li><li>  Although the format itself is not hellishly complex, it uses LEB (Little Endian Base), which makes reading this table not so simple. </li></ol><br>  As far as I know, most of the DWARF data is encoded in LEB, which is a great idea to confuse programmers, and also to reduce the space for code for encoding ints of arbitrary length.  Fortunately, we can count a little here: mostly, the LEB-encoded numbers are read by uint8_t, because we will not deal with large exception tables or something like that. <br><br>  As always, the current version of the code for this chapter is <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v04">in the repository</a> . <br><br>  Let's start analyzing CFI directly with disassembling and see if we can build something to read this data in our personal function.  I reassigned the tags to make them more human-friendly.  LSDA has three sections, try to define them below: <br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.local_frame_entry</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">gxx_personality_v0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.gcc_except_table</span></span>,"<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>",@<span class="hljs-keyword"><span class="hljs-keyword">progbits</span></span> .align <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  It's very simple: just a header saying that we are going to use <strong>__gxx_personality_v0</strong> as a global one, and also lets the linker know that we are going to define the <strong>.gcc_except_table</strong> section. <br><br>  Moving on: <br><br><pre> <code class="hljs go">.local_lsda_1: #   .     .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xff</span></span> #    landing pads;  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptr</span></span></span><span class="hljs-function"> #   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_Unwind_GetRegionStart)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span><span class="hljs-function"> 0 #   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LSDA</span></span></span><span class="hljs-function">:   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLSDATT1</span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLSDATTD1</span></span></span><span class="hljs-function">  #    </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LSDA</span></span></span><span class="hljs-function">,  .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uleb128</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_lsda_end</span></span></span><span class="hljs-function"> - .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_lsda_call_site_table_header</span></span></span></span></code> </pre><br>  There is already much more information.  These tags are very vague, but they follow the pattern.  LSDA means a language-specific data zone, L at the beginning means "local", so it is local (for the translated module, .o file).  data zone number one.  Other labels follow the same pattern, but I did not take up their description.  And they, in general, we do not need. <br><br><pre> <code class="hljs sql">.local_lsda_call_site_table_header: <span class="hljs-comment"><span class="hljs-comment"># Encoding of items in the landing pad table. Again, we don't care. .byte 0x1. # The length of the call site table (ie the landing pads) .uleb128 .local_lsda_call_site_table_end - .local_lsda_call_site_table</span></span></code> </pre> <br>  Another boring headline, we go further: <br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.local_lsda_call_site_table</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB0-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE0-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L8-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB1-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE1-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB2-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE2-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB2</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L9-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.local_lsda_call_site_table_end</span></span>:</code> </pre> <br>  This is much more interesting, here we see the call table with our own eyes.  Somehow, in all these records, we have to find our landing pad.  In accordance with some random page on the Internet, the format of each link should correspond to the structure: <br><br><pre> <code class="hljs ruby">struct lsda_call_site_entry { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  IP  size_t cs_start; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  IP  size_t cs_len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Landing pad  size_t cs_lp; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     size_t cs_action; };</code> </pre> <br>  Well, it looks like we are on the right track, however, we still do not know why there are 3 entry points here, when we defined only one langing pad.  In any case, we can read a bit: considering the disassembled code, we can determine all CFI values ‚Äã‚Äãwill be less than 128, which means that LEB-coding can be read as uchars.  This makes our CFI read code much easier, and now we can see how to use it in our personal function further. <br><br><h1>  C ++ exceptions under the hood: and suddenly, reflection in C ++ </h1><br>  Recall what we have already done: we learned how to forward errors, we wrote a personal function __gxx_personality_v0, which can identify and handle errors, also telling the stack stack when it should stop, but it still does not know how to determine the necessary catch block.  We also learned how to read LSDA, now it‚Äôs all left to combine! <br><br>  Let's do something like this and see if we are on the right path (note that this code can only work with uint8, and also probably not portable): <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSDA_Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lsda_start_encoding; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lsda_type_encoding; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lsda_call_site_table_length; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSDA_Call_Site_Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> encoding; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSDA_Call_Site</span></span></span><span class="hljs-class"> {</span></span> LSDA_Call_Site(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ptr) { cs_start = ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; cs_len = ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; cs_lp = ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>]; cs_action = ptr[<span class="hljs-number"><span class="hljs-number">3</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cs_start; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cs_len; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cs_lp; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cs_action; }; _Unwind_Reason_Code __gxx_personality_v0 ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version, _Unwind_Action actions, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_SEARCH_PHASE) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, lookup phase\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_HANDLER_FOUND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_CLEANUP_PHASE) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, cleanup\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* lsda = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*) _Unwind_GetLanguageSpecificData(context); LSDA_Header *header = (LSDA_Header*)(lsda); LSDA_Call_Site_Header *cs_header = (LSDA_Call_Site_Header*) (lsda + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(LSDA_Header)); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cs_in_table = cs_header-&gt;length / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(LSDA_Call_Site); <span class="hljs-comment"><span class="hljs-comment">//    cs_table_base  uint8,    //    const uint8_t *cs_table_base = lsda + sizeof(LSDA_Header) + sizeof(LSDA_Call_Site_Header); //    call site  for (size_t i=0; i &lt; cs_in_table; ++i) { const uint8_t *offset = &amp;cs_table_base[i * sizeof(LSDA_Call_Site)]; LSDA_Call_Site cs(offset); printf("Found a CS:\n"); printf("\tcs_start: %i\n", cs.cs_start); printf("\tcs_len: %i\n", cs.cs_len); printf("\tcs_lp: %i\n", cs.cs_lp); printf("\tcs_action: %i\n", cs.cs_action); } uintptr_t ip = _Unwind_GetIP(context); uintptr_t funcStart = _Unwind_GetRegionStart(context); uintptr_t ipOffset = ip - funcStart; return _URC_INSTALL_CONTEXT; } else { printf("Personality function, error\n"); return _URC_FATAL_PHASE1_ERROR; } } }</span></span></code> </pre> <br>  <a href="">Current Code</a> <br><br>  As you can see (if you run this code) all points in the call table are relative.  Relative of what?  Start function, of course.  This means that if we want to get an EIP (instruction pointer) for a particular landing pad, all we need to do is add: _Unwind_GetRegionStart + LSDA_Call_Site.cs_Ip! <br><br>  Finally, now we are able to solve our problem: let's change our personal function so that it performs the correct landing pad.  Now we need to use another <em>Unwind</em> function to indicate where we want to continue execution from: <strong>_Unwind_SetIP</strong> .  Change our personalized function again to launch the first landing pad. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *cs_table_base = lsda + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(LSDA_Header) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(LSDA_Call_Site_Header); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cs_in_table; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *offset = &amp;cs_table_base[i * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(LSDA_Call_Site)]; <span class="hljs-function"><span class="hljs-function">LSDA_Call_Site </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(offset)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cs.cs_lp) { <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> func_start = _Unwind_GetRegionStart(context); _Unwind_SetIP(context, func_start + cs.cs_lp); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_INSTALL_CONTEXT;</code> </pre> <br>  Try running this code and watch the wonderful eternal loop.  Can you guess what went wrong?  The answer is in the next chapter! <br><br><h1>  C ++ exceptions under the hood: setting context for the landing pad </h1><br>  In the last chapter, we finally wrote an almost working personal function.  We can define each frame stack with available landing pads, and then tell <em>Unwind</em> exactly what we want to run.  However, we got a small problem: to set the <em>Unwind</em> context to continue execution on the correct landing pad, we must set the current exception to the register.  This, in general, means that the landing pad does not want to know which exception should be handled, so he will only say "I can't handle it." <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unwind</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will then say "please try the next landing pad", but our ABI is so simple that he doesn't even have any idea how he should find another landing pad, and just tries to slip the same one. </font><font style="vertical-align: inherit;">Again and again. </font><font style="vertical-align: inherit;">We seem to have come up with the most contrived example for while (true)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fix the context for the landing pad and slightly improve our ABI:</font></font><br><br><pre> <code class="hljs rust">#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; namespace __cxxabiv1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__class_type_info</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> void foo() {} } ti; } #define EXCEPTION_BUFF_SIZE <span class="hljs-number"><span class="hljs-number">255</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> exception_buff[EXCEPTION_BUFF_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { void* __cxa_allocate_exception(size_t thrown_size) { printf(<span class="hljs-string"><span class="hljs-string">"alloc ex %i\n"</span></span>, thrown_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thrown_size &gt; EXCEPTION_BUFF_SIZE) printf(<span class="hljs-string"><span class="hljs-string">"Exception too big"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;exception_buff; } void __cxa_free_exception(void *thrown_exception); #include &lt;unwind.h&gt; typedef void (*unexpected_handler)(void); typedef void (*terminate_handler)(void); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__cxa_exception</span></span></span></span> { std::type_info * exceptionType; void (*exceptionDestructor) (void *); unexpected_handler unexpectedHandler; terminate_handler terminateHandler; __cxa_exception * nextException; int handlerCount; int handlerSwitchValue; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * actionRecord; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * languageSpecificData; void * catchTemp; void * adjustedPtr; _Unwind_Exception unwindHeader; }; void __cxa_throw(void* thrown_exception, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_info</span></span></span></span> *tinfo, void (*dest)(void*)) { printf(<span class="hljs-string"><span class="hljs-string">"__cxa_throw called\n"</span></span>); __cxa_exception *header = ((__cxa_exception *) thrown_exception - <span class="hljs-number"><span class="hljs-number">1</span></span>); _Unwind_RaiseException(&amp;header-&gt;unwindHeader); <span class="hljs-comment"><span class="hljs-comment">// __cxa_throw never returns printf("no one handled __cxa_throw, terminate!\n"); exit(0); } void __cxa_begin_catch() { printf("begin FTW\n"); } void __cxa_end_catch() { printf("end FTW\n"); } /**********************************************/ /** * The LSDA is a read only place in memory; we'll create a typedef for * this to avoid a const mess later on; LSDA_ptr refers to readonly and * &amp;LSDA_ptr will be a non-const pointer to a const place in memory */ typedef const uint8_t* LSDA_ptr; struct LSDA_Header { /** * Read the LSDA table into a struct; advances the lsda pointer * as many bytes as read */ LSDA_Header(LSDA_ptr *lsda) { LSDA_ptr read_ptr = *lsda; // Copy the LSDA fields start_encoding = read_ptr[0]; type_encoding = read_ptr[1]; ttype = read_ptr[2]; // Advance the lsda pointer *lsda = read_ptr + sizeof(LSDA_Header); } uint8_t start_encoding; uint8_t type_encoding; uint8_t ttype; }; struct LSDA_CS_Header { // Same as other LSDA constructors LSDA_CS_Header(LSDA_ptr *lsda) { LSDA_ptr read_ptr = *lsda; encoding = read_ptr[0]; length = read_ptr[1]; *lsda = read_ptr + sizeof(LSDA_CS_Header); } uint8_t encoding; uint8_t length; }; struct LSDA_CS { // Same as other LSDA constructors LSDA_CS(LSDA_ptr *lsda) { LSDA_ptr read_ptr = *lsda; start = read_ptr[0]; len = read_ptr[1]; lp = read_ptr[2]; action = read_ptr[3]; *lsda = read_ptr + sizeof(LSDA_CS); } // Note start, len and lp would be void*'s, but they are actually relative // addresses: start and lp are relative to the start of the function, len // is relative to start // Offset into function from which we could handle a throw uint8_t start; // Length of the block that might throw uint8_t len; // Landing pad uint8_t lp; // Offset into action table + 1 (0 means no action) // Used to run destructors uint8_t action; }; /**********************************************/ _Unwind_Reason_Code __gxx_personality_v0 ( int version, _Unwind_Action actions, uint64_t exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context) { if (actions &amp; _UA_SEARCH_PHASE) { printf("Personality function, lookup phase\n"); return _URC_HANDLER_FOUND; } else if (actions &amp; _UA_CLEANUP_PHASE) { printf("Personality function, cleanup\n"); // Pointer to the beginning of the raw LSDA LSDA_ptr lsda = (uint8_t*)_Unwind_GetLanguageSpecificData(context); // Read LSDA headerfor the LSDA LSDA_Header header(&amp;lsda); // Read the LSDA CS header LSDA_CS_Header cs_header(&amp;lsda); // Calculate where the end of the LSDA CS table is const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length; // Loop through each entry in the CS table while (lsda &lt; lsda_cs_table_end) { LSDA_CS cs(&amp;lsda); if (cs.lp) { int r0 = __builtin_eh_return_data_regno(0); int r1 = __builtin_eh_return_data_regno(1); _Unwind_SetGR(context, r0, (uintptr_t)(unwind_exception)); // Note the following code hardcodes the exception type; // we'll fix that later on _Unwind_SetGR(context, r1, (uintptr_t)(1)); uintptr_t func_start = _Unwind_GetRegionStart(context); _Unwind_SetIP(context, func_start + cs.lp); break; } } return _URC_INSTALL_CONTEXT; } else { printf("Personality function, error\n"); return _URC_FATAL_PHASE1_ERROR; } } }</span></span></code> </pre> <br> <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v06"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current version of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code and a much more detailed </font></font><a href="http://mentorembedded.github.io/cxx-abi/exceptions.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">description of LSDA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally it works! </font><font style="vertical-align: inherit;">We should get something like this:</font></font><br><br><pre> <code class="hljs pgsql">./app alloc ex <span class="hljs-number"><span class="hljs-number">1</span></span> __cxa_throw <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>, lookup phase Personality <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>, cleanup <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FTW Caught a Fake_Exception! <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> FTW try_but_dont_catch handled the <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> catchit handled the <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we deceived </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unwind a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit </font><font style="vertical-align: inherit;">: we told him that he should handle all successive exceptions on the very first catch block. This turns catch (Exception &amp;) into catch (...) and all hell will crush on us if the first function in the frame does not have a catch block. However, we went through the first stage in creating a very simple ABI! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can we improve our code and make it handle exceptions correctly in the correct frame? Of course! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ exceptions under the hood: several landing pads &amp; gurus' teachings</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a hard road, we finally made a working personal function that allows us to handle errors without the help of lbstdc ++. </font><font style="vertical-align: inherit;">It randomly handles all errors, but it works! </font><font style="vertical-align: inherit;">Correct exception handling is a big question that we haven‚Äôt answered yet, but if we go back to LSDA, we will see something like this:</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-class"><span class="hljs-selector-class">.local_lsda_call_site_table</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB0-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE0-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB0</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L8-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB1-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE1-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB2-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LEHE2-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LEHB2</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.L9-</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LFB1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.uleb128</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.local_lsda_call_site_table_end</span></span>:</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are three landing pads, even if we write a single try / catch block. </font><font style="vertical-align: inherit;">What's going on here? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look closely at the previous chapter, you will notice that I added some comments in the definition of the LSDA_CS structure:</font></font><br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSDA_CS</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// len  lp   void*'s,   // : start and lp   , len //   //   ,     uint8_t start; //   uint8_t len; // Landing pad uint8_t lp; //  action table + 1 (0  " ") //     uint8_t action; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are many interesting things here, but first we will look at the structure field by field for this example: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { L0: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { do_something(); L1: } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception1&amp; ex) { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception2&amp; ex) { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExceptionN&amp; ex) { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { } L2: }</code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ip: the offset from the beginning of the function where the landing pad begins. </font><font style="vertical-align: inherit;">The value in this example should be L1 - addr_of (foo)</font></font></li><li> action:    .        .      ,    . </li><li> start:      try- .       L0 ‚Äî addr_of(foo) </li><li> len:  try-.      L1-L0 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fields we are interested in are start and len: in functions with a lot of try / catch blocks, we can determine whether we should handle exceptions, checking whether the instruction pointer (IP) is worth between the current frame and start and start + len. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This destroys the myth of how a function with several try / catch blocks can handle several exceptions, but we still do not know the answer to the question: why are three objects generated for a single landing pad? </font><font style="vertical-align: inherit;">Other objects are placed as a likely place for cleaning actions or a landing pad that can be thrown.</font></font><br><br>  <a href="https://habrahabr.ru/post/279149/">Continuation</a> <br></div><p>Source: <a href="https://habr.com/ru/post/279151/">https://habr.com/ru/post/279151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279139/index.html">We invite everyone to the first hackathon in the history of the Stavropol Territory</a></li>
<li><a href="../279143/index.html">A brief course of computer graphics: setting normal maps in a tangent space</a></li>
<li><a href="../279145/index.html">VKontakte launches the third VK Cup championship</a></li>
<li><a href="../279147/index.html">1.4 SFML and Xcode (Mac OS X)</a></li>
<li><a href="../279149/index.html">C ++ exception handling under the hood. Part 3</a></li>
<li><a href="../279155/index.html">MySQL JSON data type decoding</a></li>
<li><a href="../279157/index.html">Analysis of the election results to the State Duma. Getting ready for the 2016 vote</a></li>
<li><a href="../279159/index.html">3CX call center management</a></li>
<li><a href="../279163/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ202 (March 6 - 13, 2016)</a></li>
<li><a href="../279167/index.html">PHP Digest number 81 - interesting news, materials and tools (March 1 - 13, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>