<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arrow functions in ECMAScript 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most interesting parts of the new ECMAScript 6 standard is the arrow functions. Arrow functions, as the name implies, are defined by the ne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arrow functions in ECMAScript 6</h1><div class="post__text post__text-html js-mediator-article"><img align="right" alt="Arrow functions madness" src="https://habrastorage.org/getpro/habr/post_images/c6a/644/231/c6a644231399b029d0c201d2d83d4c45.png" title="Arrow functions madness"><br>  One of the most interesting parts of the new ECMAScript 6 standard is the arrow functions.  Arrow functions, as the name implies, are defined by the new syntax that uses the arrow <code>=&gt;</code> .  However, besides the excellent syntax, the arrow functions differ from the traditional functions in other points: <br><ul><li>  Lexical binding.  The values ‚Äã‚Äãof the <em>special variables</em> <strong>this</strong> , <strong>super</strong> and <strong>arguments</strong> are not determined by how the arrow functions were called, but by how they were created. </li><li>  Unchangeable <strong>this</strong> , <strong>super</strong> and <strong>arguments</strong> .  The values ‚Äã‚Äãof these variables inside the switch functions remain unchanged throughout the life cycle of the function. </li><li>  Arrow functions cannot be used as a constructor and throw an error when used with the <strong>new</strong> operator. </li><li>  Unavailability of the "own" value of the <strong>arguments</strong> variable. </li></ul><br>  There were several reasons for introducing these differences.  The primary priority is that binding is used quite often in JavaScript.  It is very easy to lose this desired value when using traditional functions, which can lead to unpredictable consequences.  Another reason is that JS engines can easily optimize the execution of switch functions due to these limitations (as opposed to traditional functions that can be used as a constructor and that are free to modify <em>special variables</em> ). <br><br><a name="habracut"></a><br>  <em>Note: This article is a compilation of a free translation of the article <a href="http://www.nczonline.net/blog/2013/09/10/understanding-ecmascript-6-arrow-functions/">Understanding ECMAScript 6 arrow functions</a> and readings of the latest draft <a href="http://people.mozilla.org/~jorendorff/es6-draft.html">specification</a> (January 20, 2014 Draft Rev 22).</em> <br><br>  <strong>Table of contents</strong> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Syntax</a> <ul><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">One parameter</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Several parameters</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">No parameters</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Traditional function body syntax</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Object literal</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Variable number of parameters</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Pattern restructuring as parameter</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Using arrow functions</a> <ul><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Context setting</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Prokidyvanie context between multiple calls</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Use as argument</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Other features of the switch functions</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/213455/">Total</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="_1"></a><h2>  Syntax </h2><hr><br>  In general, the syntax of the switch functions looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fun = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> x;</code> </pre><br>  It is very similar to similar syntax in languages ‚Äã‚Äãsuch as Scala, CoffeeScript, and the syntax of lambda expressions from C #. <br><br>  The syntax of the switch functions may be different, depending on how you declare the function.  A declaration always starts with a list of arguments, followed by an arrow and the function body.  Both the argument list and the function body can have a different form, depending on what you are writing. <br><br><a name="_2"></a><h3>  One parameter </h3><br>  Declaring a switch function that takes one argument and simply returns it looks very simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reflect = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> value; <span class="hljs-comment"><span class="hljs-comment">//  var reflect = function(value) { return value; }</span></span></code> </pre><br>  When the arrow function has only one argument, it can be declared without parentheses.  The body of the function following the arrow may also be without curly brackets and may not contain the keyword <strong>return</strong> . <br><br><a name="_3"></a><h3>  Several parameters </h3><br>  But if you want to declare more than one parameter, you must frame the parameter list in parentheses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num1, num2</span></span></span><span class="hljs-function">) =&gt;</span></span> num1 + num2; <span class="hljs-comment"><span class="hljs-comment">//  var sum = function(num1, num2) { return num1 + num2; };</span></span></code> </pre><br>  The <code>sum</code> function simply sums two arguments.  The only difference from the previous example is the presence of parentheses and a comma (just like in traditional functions). <br><br><a name="_4"></a><h3>  No parameters </h3><br>  Similarly, a function without any arguments must have an empty parameter list enclosed in parentheses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  var sum = function() { return 1 + 2; };</span></span></code> </pre><br><br><a name="_5"></a><h3>  Traditional function body syntax </h3><br>  You can use the syntax of traditional functions for the body of the arrow function when it contains more than one expression.  That is, wrap the function in braces and add the <strong>return</strong> keyword: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num1, num2</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num1 + num2; } <span class="hljs-comment"><span class="hljs-comment">//  var sum = function(num1, num2) { return num1 + num2; };</span></span></code> </pre><br>  The body of the function will be processed in the same way as in the case of classical functions, except that the values ‚Äã‚Äãof the <em>special variables</em> <strong>this</strong> , <strong>super</strong> and <strong>arguments</strong> will be calculated differently. <br><br><a name="_6"></a><h3>  Object literal </h3><br>  Separately, it should be mentioned that the body of the function which does not contain curly brackets and simply returns the object literal must be put into parentheses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getTempItem = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: id, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Temp"</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//  var getTempItem = function(id) { return { id: id, name: "Temp" } };</span></span></code> </pre><br>  Placing a literal object in parentheses indicates to the parser that curly braces are not the beginning of the traditional syntax for the function body, but the beginning of a literal. <br><br><a name="_7"></a><h3>  Variable number of parameters </h3><br>  Since the ‚Äúown‚Äù object of <strong>arguments is</strong> not available inside the switch function (the value of <strong>arguments is</strong> lexically related to the value of the <strong>arguments of the</strong> traditional function within which the switch function was declared), then for switch functions with a variable number of parameters, use the <strong>rest</strong> pattern from the restructuring <em>patterns</em> .  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getTempItems = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...rest</span></span></span><span class="hljs-function">) =&gt;</span></span> rest; <span class="hljs-comment"><span class="hljs-comment">//  var getTempItems = function() { return [].slice.apply(arguments) };</span></span></code> </pre><br><a name="_8"></a><h3>  Pattern restructuring as parameter </h3><br>  <em>In this article, we are not looking at restructuring patterns ‚Äî you can read about them in the article <a href="http://habrahabr.ru/post/175371/">Review of ECMAScript 6, the next version of JavaScript</a> , although this information is partially outdated.</em> <br><br>  As can be seen from the previous example, despite the fact that the switch function has only one argument, it is still necessary to use parentheses when using the <em>destructuring patterns</em> as the only parameter of the function.  Examples with other <em>templates</em> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{a}</span></span></span><span class="hljs-function">) =&gt;</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[b]</span></span></span><span class="hljs-function">) =&gt;</span></span> b;</code> </pre><br><br><a name="_9"></a><h2>  Using arrow functions </h2><hr><br><a name="_10"></a><h3>  Context setting </h3><br>  One of the common scripts in JavaScript is setting the correct value of <strong>this</strong> inside a function (binding).  Since the value of <strong>this</strong> can be changed, then, depending on the context of the execution of the function, it is possible to mistakenly act on one object when you meant a completely different one.  Look at the following example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageHandler = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"123456"</span></span> , <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(event.type); <span class="hljs-comment"><span class="hljs-comment">//  }); } , doSomething: function(type) { console.log("Handling " + type + " for " + this.id) } };</span></span></code> </pre><br>  In the above code, the <code>pageHandler</code> object must handle clicks on the page.  The <code>init()</code> method hangs the handler on the desired event, which internally causes <code>this.doSomething()</code> .  However, the code will not work properly.  The reference to <code>this.doSomething()</code> not valid, since <strong>this</strong> points to a <code>document</code> object inside an event handler instead of the intended <code>pageHandler</code> .  When you try to execute this code, you will get an error, because the <code>document</code> object does not have a <code>doSomething</code> method. <br><br>  You can set <strong>this</strong> value on the <code>pageHandler</code> object using <code>handleEvent</code> or by calling the standard <code>bind()</code> method of the function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageHandler = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"123456"</span></span> , <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(event.type); <span class="hljs-comment"><span class="hljs-comment">// error }).bind(this)); } , doSomething: function(type) { console.log("Handling " + type + " for " + this.id) } };</span></span></code> </pre><br>  Now the code works as intended, but it looks more cumbersome.  In addition, calling <code>bind(this)</code> every time you create a new function, the value of which is tied to the <code>pageHandler</code> value, but the code works as you intended. <br><br>  Arrow functions solve the problem in a more elegant way because they use the lexical binding of the value of <strong>this</strong> (as well as <strong>super</strong> and <strong>arguments</strong> ) and its value is determined by the value of <strong>this</strong> in the place where the arrow function was created.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageHandler = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"123456"</span></span> , <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, event =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(event.type)); } , <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Handling "</span></span> + type + <span class="hljs-string"><span class="hljs-string">" for "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id) } };</code> </pre><br>  In this example, the handler is a pointer function in which <code>this.doSomething()</code> called.  The value of <strong>this</strong> will be the same as in the function <code>init()</code> , and the code in this example will work correctly, similar to the one used by <code>bind()</code> .  Regardless of whether the call to <code>this.doSomething()</code> returns a value or not, the expression inside the body of the switch function does not need to be enclosed in braces. <br><br>  In addition, the example above is also more efficient than calling <code>bind()</code> , because for the browser it is similar to the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageHandler = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"123456"</span></span> , <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.doSomething(event.type) }); } , <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Handling "</span></span> + type + <span class="hljs-string"><span class="hljs-string">" for "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id) } };</code> </pre><br>  That is, the creation of a new function does not occur, as is the case with the <code>bind()</code> call. <br><br><a name="_11"></a><h3>  Prokidyvanie context between multiple calls </h3><br>  Obviously, you can put one switch function into another, thereby ‚Äúpushing‚Äù the value of <strong>this</strong> through them: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">arr1</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] , <span class="hljs-attr"><span class="hljs-attr">arr2</span></span>: [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>] , <span class="hljs-attr"><span class="hljs-attr">concatenate</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-string"><span class="hljs-string">"|"</span></span> + b } , <span class="hljs-attr"><span class="hljs-attr">intersection</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arr1.reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, v1</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// arrow function 1 this.arr2.reduce( (sum, v2) =&gt; { // arrow function 2 sum.push( this.concatenate( v1, v2 ) ) return sum; } , sum ) , [] ) } }; var arrSum = obj.intersection();//['1|a', '1|b', '1|c', '2|a', '2|b', '2|c', '3|a', '3|b', '3|c']</span></span></code> </pre><br><br><a name="_12"></a><h3>  Use as argument </h3><br>  The short syntax of the switch functions makes them ideal candidates for passing as arguments to a call to other functions.  For example, if you want to sort an array, you usually write something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = values.sort(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b });</code> </pre><br>  Pretty verbose for a simple operation.  Compare with a short recording of the switch function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = values.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b);</code> </pre><br>  Using methods such as massive <code>sort()</code> , <code>map()</code> , <code>reduce()</code> and so on can be simplified using the short syntax of the arrow function. <br><br><a name="_13"></a><h2>  Other features of the switch functions </h2><hr><br>  Although the switch functions are different from the traditional functions, they have common features: <br><ul><li>  The <code>typeof</code> operator returns <code>"function"</code> for the arrow function </li><li>  The arrow function is also an instance of the Function "class", so the <code>instanceof</code> will work the same way as with the traditional function </li><li>  You can still use the <code>call()</code> , <code>apply()</code> , and <code>bind()</code> methods, but remember that they will not affect the value of <strong>this</strong> </li><li>  You can use the <code>toMethod()</code> method, but it will not change the value of <strong>super</strong> ( <em>the <code>toMethod()</code> method is introduced in es6 and is not considered in this article</em> ). </li></ul><br>  The essential difference from traditional functions is that an attempt to call an arrow function with an indication of the operator <strong>new</strong> will cause an execution error. <br><br><a name="_14"></a><h2>  Total </h2><hr><br>  Arrow functions are one of the most interesting innovations in ECMAScript 6, which, having a short definition syntax, will simplify the transfer of functions as a parameter value to another function. <br><br>  Laconic syntax allows you to write complex things. <del>  even harder </del>  simpler.  For example, the identifier generator will look like this (which looks <a href="http://google.github.io/traceur-compiler/demo/repl.html">much more verbose</a> on es5): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> idGen = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, id = start, reset = (newId = start</span></span></span><span class="hljs-function">) =&gt;</span></span> id = newId, next = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> id++) =&gt; ({reset, next}); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = idGen(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(gen.next(), gen.next(), gen.reset(<span class="hljs-number"><span class="hljs-number">10</span></span>), gen.next());<span class="hljs-comment"><span class="hljs-comment">//100 101 10 10</span></span></code> </pre><br>  A lexical binding will close one of the biggest sources of pain and frustration for developers, as well as improve performance by optimizing at the level of the js-engine. <br><img align="right" alt="Madness in FF" src="https://habrastorage.org/getpro/habr/post_images/e8a/cf7/2d8/e8acf72d8d88d8985f22289a3744c381.png" title="Madness in FF"><br>  If you want to try the arrow functions, you can run the above examples in the Firefox console, which at the moment (02.2014 FF28) almost fully supports the arrow functions (FF28 doesn‚Äôt calculate the <strong>arguments</strong> value correctly). <br><br>  You can also try the switch functions and other es6 features in the Traceur <a href="http://google.github.io/traceur-compiler/demo/repl.html">online translator</a> . </div><p>Source: <a href="https://habr.com/ru/post/213455/">https://habr.com/ru/post/213455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213445/index.html">Clone of the game JezzBall / KBounce / "Restless Balls" on html5</a></li>
<li><a href="../213447/index.html">3D printer MATAERIAL learned how to print with metal</a></li>
<li><a href="../213449/index.html">Brain Marketing. We make a site map through SWOT-analysis, marketing message and UTP</a></li>
<li><a href="../213451/index.html">Space robot Robonaut will make a nurse</a></li>
<li><a href="../213453/index.html">In Ubuntu 14.04 it will be possible to return the main menu of the application to the window.</a></li>
<li><a href="../213459/index.html">Display programming on ST7920 controller</a></li>
<li><a href="../213461/index.html">What you may not have known about dictionaries in the lecture ‚ÄúDictionaries: Myths and Reality‚Äù</a></li>
<li><a href="../213465/index.html">Why Google Glass will fail and why it will not stop the success of smart glasses</a></li>
<li><a href="../213467/index.html">Why we do not have VKontakte support</a></li>
<li><a href="../213471/index.html">Development of a static site on Meteor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>