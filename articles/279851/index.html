<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stream-safe signals that are really convenient to use.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many libraries in the world that implement signals in C ++. Unfortunately, all the implementations I have encountered have several problems ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stream-safe signals that are really convenient to use.</h1><div class="post__text post__text-html js-mediator-article">  There are many libraries in the world that implement signals in C ++.  Unfortunately, all the implementations I have encountered have several problems that do not allow writing simple multithreaded code using these libraries.  Here I will talk about these problems and how they can be solved. <br><a name="habracut"></a><br><h2>  What are signals? </h2><br>  I think many are already familiar with this concept, but just in case, I will still write. <br><br>  A signal is a way to send a notification of an arbitrary event to recipients who can be registered independently of each other.  Callback with multiple recipients, if you like.  Or, for those who worked with .NET, multicast delegate. <br><br><div class="spoiler">  <b class="spoiler_title">A couple of examples with boost :: signals2</b> <div class="spoiler_text">  Signal Announcement: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> boost::signals2::signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; OnClick; };</code> </pre> <br>  Connect to the signal and disconnect from it: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClickHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ‚ÄúButton clicked‚Äù &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// ... boost::signals2::connection c = button-&gt;OnClick.connect(&amp;ClickHandler); // ... c.disconnect();</span></span></code> </pre><br>  Call signal: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> {</span></span> boost::signals2::signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; OnClick; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MouseDownHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ OnClick(); } };</code> </pre><br></div></div><br><h2>  Now about the problems </h2><br>  In a single-threaded code, everything looks great and works well, but what about multi-threaded? <br><br>  Here, unfortunately, there are three common problems for different implementations: <br><br><ol><li>  There is no way to atomically connect to a signal and get a connected state. </li><li>  Non-blocking signal trip </li><li>  Disabling an asynchronous handler does not cancel calls that are already in the queue of its thread. </li></ol><br>  Consider each of them in detail.  To do this, we will write a part of the firmware of an imaginary media set-top box, namely, three classes: <br><br><ul><li>  <b>StorageManager</b> - a class that responds to flash drives, DVDs, and other media that the user has inserted into the console </li><li>  <b>MediaScanner</b> - a class that searches for media files on each of these devices. </li><li>  <b>MediaUiModel</b> - a model for displaying these media files in an imaginary Model-View-framework </li></ul><br>  At once I will say that the code that you see here is extremely simplified, and does not contain anything superfluous, so that we can concentrate on these problems.  You will also see type types like <i>TypePtr</i> .  This is just <i>std :: shared_ptr &lt;Type&gt;</i> , don't be alarmed. <br><br><h2>  There is no way to atomically connect to a signal and get a connected state. </h2><br>  So, <i>StorageManager</i> .  You need a getter for those carriers that are already inserted in the console, and a signal to notify you of new ones. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StoragePtr&gt; GetStorages() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; boost::signals2::signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp;)&gt; OnStorageAdded; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br>  Alas, such an interface cannot be used without getting race condition. <br><br>  Does not work in this order ... <br><br><pre> <code class="cpp hljs">storageManager-&gt;OnStorageAdded.connect(&amp;StorageHandler); <span class="hljs-comment"><span class="hljs-comment">//      ,     for (auto&amp;&amp; storage : storageManager-&gt;GetStorages()) StorageHandler(storage);</span></span></code> </pre><br>  ... and does not work in that order. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; storage : storageManager-&gt;GetStorages()) StorageHandler(storage); <span class="hljs-comment"><span class="hljs-comment">//        ,      storageManager-&gt;OnStorageAdded.connect(&amp;StorageHandler);</span></span></code> </pre><br><h3>  Common solution </h3><br>  Obviously, since we got the race condition, we need a mutex. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex _mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StoragePtr&gt; _storages; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StorageManager() { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } boost::signals2::signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp;)&gt; OnStorageAdded; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">recursive_mutex&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mutex; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StoragePtr&gt; GetStorages() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; l(_mutex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storages; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReportNewStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> StoragePtr&amp; storage)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; l(_mutex); _storages.push_back(storage); OnStorageAdded(storage); } }; <span class="hljs-comment"><span class="hljs-comment">// ... { std::lock_guard&lt;std::recursive_mutex&gt; l(storageManager-&gt;GetMutex()); storageManager-&gt;OnStorageAdded.connect(&amp;StorageHandler); for (auto&amp;&amp; storage : storageManager-&gt;GetStorages()) StorageHandler(storage); }</span></span></code> </pre><br>  This code will work, but it has several flaws: <br><br><ul><li>  If you want to use <i>std :: mutex</i> instead of <i>std :: recursive_mutex</i> , you lose the ability to capture it inside the <i>GetStorages</i> method, which makes the <i>StorageManager</i> class <i>non-</i> safe. </li><li>  You cannot get rid of copying a collection inside <i>GetStorages</i> without losing <i>StorageManager</i> 's thread safety </li><li>  You have to show out the type <i>std :: vector &lt;StoragePtr&gt;</i> , although in reality these are just implementation details. </li><li>  A fairly voluminous code for connecting to a signal and receiving the current state, which is almost no different for different signals. </li></ul><br><h3>  How to do better? </h3><br>  Let's take everything we do around the call to <i>connect</i> (capturing a mutex and traversing the collection) inside. <br><br>  It is important to understand that the algorithm for obtaining the current state depends on the nature of this state itself.  If this is a collection, you need to call the handler for each element, if it is, for example, enum, then you need to call the handler exactly once.  Accordingly, we need some kind of abstraction. <br><br>  Add a <b>populator</b> to the signal ‚Äî a function that accepts a handler that is currently connected, and let the signal owner (StorageManager, in our case) determine how the current state will be sent to this handler. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Signature &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> populator_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature&gt;&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature&gt; &gt; _handlers; populator_type _populator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: signal(populator_type populator) : _populator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(populator)) { } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">mutex&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mutex; } <span class="hljs-function"><span class="hljs-function">signal_connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;Signature&gt; handler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l(_mutex); _populator(handler); <span class="hljs-comment"><span class="hljs-comment">//        _handlers.push_back(std::move(handler)); return signal_connection([&amp;]() { /*    _handlers */ } ); } // ... };</span></span></code> </pre><br>  The <i>signal_connection</i> class <i>currently</i> accepts a lambda function that will remove the handler from the list in the signal.  Slightly updated code I will bring later. <br><br>  <i>Rewrite StorageManager</i> using this new concept: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StoragePtr&gt; _storages; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StorageManager() : _storages([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp;)&gt;&amp; h) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; s : _storages) h(s); }) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp;)&gt; OnStorageAdded; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReportNewStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> StoragePtr&amp; storage)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,     , //          _storages std::lock_guard&lt;std::mutex&gt; l(OnStorageAdded.get_mutex()); _storages.push_back(storage); OnStorageAdded(storage); } };</span></span></code> </pre><br>  If you are using C ++ 14, the populator may be quite short: <br><br><pre> <code class="cpp hljs">StorageManager() : _storages([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; h) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; s : _storages) h(s); }) { }</code> </pre><br>  Note that when calling the populator, the mutex is captured in the <i>signal :: connect</i> method, so you don‚Äôt need to do this in the body of the populator itself. <br><br>  The client code becomes quite short: <br><br><pre> <code class="cpp hljs">storageManager-&gt;OnStorageAdded.connect(&amp;StorageHandler);</code> </pre><br>  One line we simultaneously connect to the signal and get the current state of the object.  Fine! <br><br><h2>  Non-blocking signal trip </h2><br>  Now it's time to write <i>MediaScanner</i> .  In the constructor, we connect to the signal <i>StorageManager :: OnStorageAdded</i> , and in the destructor we disconnect. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::signals2::connection _connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MediaScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StorageManagerPtr&amp; storageManager) { _connection = storageManager-&gt;OnStorageAdded.connect([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;StorageHandler(s); }); } ~MediaScanner() { _connection.disconnect(); <span class="hljs-comment"><span class="hljs-comment">//        ,  . //   ,        MediaScanner. } private: void StorageHandler(const StoragePtr&amp; storage) { /*  -  */ } };</span></span></code> </pre><br>  Alas, this code will fall from time to time.  The reason is how the <i>disconnect</i> method works in all the implementations I know.  It guarantees that the next time the signal is called, the corresponding handler will not work.  At the same time, if the handler is executed at that time in another stream, it will not be interrupted, and will continue to work with the destroyed <i>MediaScanner</i> object. <br><br><h3>  Qt Solution </h3><br>  In Qt, each object belongs to a specific thread, and its handlers are called exclusively on this thread.  To safely disconnect from a signal, you should call the <i>QObject :: deleteLater method</i> , which guarantees that the real deletion will be made from the desired stream, and that no handler will be called after the deletion. <br><br><pre> <code class="cpp hljs">mediaScanner-&gt;deleteLater();</code> </pre><br>  This is a good option if you are ready to fully integrate with Qt (abandon std :: thread at the core of your program in favor of QObject, QThread, and others). <br><br><h3>  Solution in boost :: signals2 </h3><br>  Boost to solve this problem suggests using the <i>track</i> / <i>track_foreign methods</i> in the slot (i.e., handler).  These methods accept the <i>weak_ptr</i> to an arbitrary object, and the connection of the handler with the signal exists as long as each of the objects is alive, for which the slot ‚Äúmonitors‚Äù. <br><br>  It works quite simply: in each slot there is a collection of <i>weak_ptr</i> 's for monitored objects that ‚Äúcrash‚Äù (excuse me) for the duration of the execution of the handler.  Thus, these objects are guaranteed not to be destroyed while the handler code has access to them.  If any of the objects have already been destroyed, the connection is broken. <br><br>  The problem is that we need to have a <i>weak_ptr</i> for the object to be signed for this.  In my opinion, the most adequate way to achieve this is to make the factory method in the <i>MediaScanner</i> class, where to sign the created object with all the signals that it is interested in: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MediaScanner&gt; Create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StorageManagerPtr&amp; storageManager) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; l(storageManager-&gt;GetMutex()); <span class="hljs-function"><span class="hljs-function">MediaScannerPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MediaScanner)</span></span></span></span>; boost::signals2::signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp;)&gt;::<span class="hljs-function"><span class="hljs-function">slot_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bind(&amp;MediaScanner::StorageHandler, result.get(), _1))</span></span></span></span>; slot.track_foreign(result); storageManager-&gt;OnStorageAdded.connect(slot); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; storage : storageManager-&gt;GetStorages()) result-&gt;StorageHandler(storage); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MediaScanner() <span class="hljs-comment"><span class="hljs-comment">//  ! { /*  ,    */ } void StorageHandler(const StoragePtr&amp; storage); { /*  -  */ } };</span></span></code> </pre><br>  So, the disadvantages: <br><br><ul><li>  Oh, a lot of code that you copy-paste every time </li><li>  <i>MediaScanner's</i> initialization broke up into two parts: subscribing to signals in the <i>Create</i> method, and everything else in the constructor </li><li>  You <b>must</b> use <i>shared_ptr</i> to store <i>MediaScanner</i> </li><li>  You are not sure that <i>MediaScanner is</i> deleted when you release the last external link to it.  This can be a problem if he uses any limited resource that you want to reuse after releasing <i>MediaScanner</i> </li></ul><br><h3>  How to do better? </h3><br>  Let's make the <i>disconnect</i> method block, so that it guarantees that after it returns control, you can destroy everything the signal handler has access to.  Something like the <i>std :: thread :: join</i> method. <br><br>  Looking ahead, I will say that we need three classes for this: <br><br><ul><li>  <b>life_token</b> - controls the lifetime of the handler, allows you to mark it as "dying", and wait for the execution to finish if necessary </li><li>  <b>life_token :: checker</b> - stored inside the signal next to the processor, refers to its <i>life_token</i> </li><li>  <b>life_token :: checker :: execution_guard</b> - created on the stack at the time of execution of the handler, blocks the corresponding <i>life_token</i> and allows you to check if the handler has not ‚Äúdied‚Äù </li></ul><br>  The class code <i>signal_connection</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signal_connection</span></span></span><span class="hljs-class"> {</span></span> life_token _token; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; _eraseHandlerFunc; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: signal_connection(life_token token, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; eraseHandlerFunc) : _token(token), _eraseHandlerFunc(eraseHandlerFunc) { } ~signal_connection(); { disconnect(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_token.released()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _token.release(); <span class="hljs-comment"><span class="hljs-comment">//   ,     (. . ) _eraseHandler(); //   -,      } };</span></span></code> </pre><br>  Here I must say that I am a supporter of the RAII-shnogo object connection.  I will not dwell on this in detail; I will only say that it is irrelevant in this context. <br><br>  The <i>signal</i> class will also change a bit here: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Signature &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> populator_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature&gt;&amp;)&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature&gt; handler_func; life_token::checker life_checker; }; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;handler&gt; _handlers; populator_type _populator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... signal_connection connect(std::function&lt;Signature&gt; handler) { std::lock_guard&lt;std::mutex&gt; l(_mutex); life_token token; _populator(handler); _handlers.push_back(Handler{std::move(handler), life_token::checker(token)}); return signal_connection(token, [&amp;]() { /*    _handlers */ } ); } template &lt; typename... Args &gt; void operator() (Args&amp;&amp;... args) const { for (auto&amp;&amp; handler : _handlers) { life_token::checker::execution_guard g(handler.life_checker); if (g.is_alive()) handler.handler_func(forward&lt;Args&gt;(args)...); } } };</span></span></code> </pre><br>  Now, next to each handler, we have a <i>life_token :: checker</i> object that refers to <i>life_token</i> , which is in <i>signal_connection</i> .  We capture it for the execution time of the handler using the <i>life_token :: checker :: execution_guard</i> object <br><br><div class="spoiler">  <b class="spoiler_title">I will hide the implementation of these objects under the spoiler.</b>  <b class="spoiler_title">If you are tired, you can skip it.</b> <div class="spoiler_text">  Inside <i>life_token</i> we need the following things: <br><br><ul><li>  Some operating system primitive for waiting in <i>life_token :: release</i> (here, for simplicity, let's take a mutex) </li><li>  Flag "alive / dead" </li><li>  Lock counter via <i>execution_guard</i> (omitted here for simplicity) </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">life_token</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> alive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;impl&gt; _impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: life_token() : _impl(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;impl&gt;()) { } ~life_token() { release(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">released</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !_impl; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (released()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l(_impl-&gt;mutex); _impl-&gt;alive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _impl.reset(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checker</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;impl&gt; _impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: checker(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> life_token&amp; t) : _impl(t._impl) { } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_guard</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Impl&gt; _impl; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: execution_guard(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checker&amp; c) : _impl(c._impl) { _impl-&gt;mutex.lock(); } ~execution_guard() { _impl-&gt;mutex.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_alive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _impl-&gt;alive; } }; }; };</code> </pre><br>  Mutex is captured for the lifetime of <i>execution_guard</i> .  Accordingly, if the <i>life_token :: release</i> method is called in another thread at this time, it will block on capturing the same mutex and wait until the end of the signal handler execution.  After that, it will reset the <i>alive</i> flag, and all subsequent calls to the signal will not lead to a call to the handler. <br></div></div><br>  What is the <i>MediaScanner</i> code <i>now</i> ?  Exactly the way we wanted to write it at the very beginning: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: signals_connection _connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MediaScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StorageManagerPtr&amp; storageManager) { _connection = storageManager-&gt;OnStorageAdded.connect([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StoragePtr&amp; s) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;StorageHandler(s); }); } ~MediaScanner() { _connection.disconnect(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StorageHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> StoragePtr&amp; storage)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  -  */</span></span> } };</code> </pre><br><h2>  Disabling an asynchronous handler does not cancel calls that are already in the queue of its thread. </h2><br>  We write <i>MediaUiModel</i> , which will respond to the found media files and add lines to display them. <br><br>  To do this, add the following signal to <i>MediaScanner</i> : <br><br><pre> <code class="cpp hljs">signal&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MediaPtr&amp;)&gt; OnMediaFound;</code> </pre><br>  There are two important things here: <br><br><ul><li>  A model is an object of a UI library, so all actions on it must be performed from the UI thread. </li><li>  Often UI libraries use their own ownership hierarchy, so we cannot use <i>shared_ptr</i> to store the model.  Accordingly, the focus from <i>track</i> / <i>track_foreign</i> will not <i>work</i> here, but this is not the main thing now, so let's pretend that everything is fine </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaUiModel</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UiModel&lt;MediaUiModelRow&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::io_service&amp; _uiThread; boost::signals2::connection _connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MediaUiModel(boost::io_service&amp; uiThread, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MediaScanner&amp; scanner) : _uiThread(uiThread) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; l(scanner.GetMutex()); scanner.OnMediaFound.connect([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MediaPtr&amp; m) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;MediaHandler(m); }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; m : scanner.GetMedia()) AppendRow(MediaUiModelRow(m)) } ~MediaUiModel() { _connection.disconnect(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      MediaScanner',        UI. void MediaHandler(const MediaPtr&amp; m) { _uiThread.post([&amp;]() { this-&gt;AppendRow(MediaUiModelRow(m)); }); } };</span></span></code> </pre><br>  In addition to the previous problem, there is one more.  Every time the signal is triggered, we shift the handler to the UI thread.  If at some point we delete the model (for example, we left the Gallery application), all these handlers come later to the dead object.  And fall again. <br><br><h3>  Qt Solution </h3><br>  All the same <i>deleteLater</i> , with the same features. <br><br><h3>  Solution in boost :: signals2 </h3><br>  If you're lucky, and your UI framework lets you say <i>deleteLater</i> , you are saved.  You just need to make a public method that will first disconnect the model from the signals, and then call <i>deleteLater</i> , and you will get about the same behavior as in Qt.  True, the previous problem you still have to solve.  To do this, you will most likely do inside the <i>shared_ptr</i> model for a certain class, which you will sign on signals.  Code is not very small, but it is a matter of technology. <br><br>  If you are unlucky, and your UI framework requires removing the model exactly when it wants, you will invent your <i>life_token</i> . <br><br><div class="spoiler">  <b class="spoiler_title">For example, something like this (also better not to read if you are tired).</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Signature_ &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncToUiHandlerWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::io_service&amp; _uiThread; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature_&gt; _realHandler; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _released; <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _mutex; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AsyncToUiHandlerWrapper(boost::io_service&amp; uiThread, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;Signature_&gt; realHandler) : _uiThread(uiThread), _realHandler(realHandler), _released(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l(_mutex); _released = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args_ &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::weak_ptr&lt;AsyncToUiHandlerWrapper&gt;&amp; selfWeak, Args_&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self = selfWeak.lock(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l(self-&gt;_mutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!self-&gt;_released) <span class="hljs-comment"><span class="hljs-comment">// AsyncToUiHandlerWrapper   ,  _uiThread       self-&gt;_uiThread.post(std::bind(&amp;AsyncToUiHandlerWrapper::UiThreadHandler&lt;Args_&amp;...&gt;, selfWeak, std::forward&lt;Args_&gt;(args)...))); } private: template &lt; typename... Args_ &gt; static void UiThreadHandler(const std::weak_ptr&lt;AsyncToUiHandlerWrapper&gt;&amp; selfWeak, Args_&amp;&amp;... args) { auto self = selfWeak.lock(); if (!self) return; if (!self-&gt;_released) // AsyncToUiHandlerWrapper   , , ,  _realHandler,   self-&gt;_realHandler(std::forward&lt;Args_&gt;(args)...); } }; class MediaUiModel : public UiModel&lt;MediaUiModelRow&gt; { private: using AsyncMediaHandler = AsyncToUiHandlerWrapper&lt;void(const MediaPtr&amp;)&gt;; private: std::shared_ptr&lt;AsyncMediaHandler&gt; _asyncHandler; public: MediaUiModel(boost::io_service&amp; uiThread, const MediaScanner&amp; scanner) { try { _asyncHandler = std::make_shared&lt;AsyncMediaHandler&gt;(std::ref(uiThread), [&amp;](const MediaPtr&amp; m) { this-&gt;AppendRow(MediaUiModelRow(m)); }); std::lock_guard&lt;std::recursive_mutex&gt; l(scanner.GetMutex()); boost::signals2::signal&lt;void(const MediaPtr&amp;)&gt;::slot_type slot(std::bind(&amp;AsyncMediaHandler::AsyncHandler&lt;const MediaPtr&amp;&gt;, std::weak_ptr&lt;AsyncMediaHandler&gt;(_asyncHandler), std::placeholders::_1)); slot.track_foreign(_asyncHandler); scanner.OnMediaFound.connect(slot); for (auto&amp;&amp; m : scanner.GetMedia()) AppendRow(MediaUiModelRow(m)); } catch (...) { Destroy(); throw; } } ~MediaUiModel() { Destroy(); } private: void Destroy() { if (_asyncHandler) _asyncHandler-&gt;Release(); //      MediaUiModel   ,       _asyncHandler.reset(); } };</span></span></code> </pre><br>  I will not even comment on this code, let's just get a little sad. <br></div></div><br><h3>  How to do better? </h3><br>  Very simple.  First, make the interface for the thread as a task queue: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_executor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~task_executor() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt;&amp; task)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Second, make the <i>connect</i> method overloaded in the signal, which accepts the flow: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">signal_connection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;task_executor&gt;&amp; worker, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;Signature&gt; handler)</span></span></span></span>;</code> </pre><br>  In this method, in the <i>_handlers</i> collection <i>,</i> put a wrapper over the handler, which, when called, <i>puts the</i> pair from the handler and the corresponding <i>life_token :: checker</i> into the required stream.  To call the real handler in the final thread, we will use <i>execution_guard</i> in the same way as before. <br><br>  Thus, the <i>disconnect</i> method will guarantee that the asynchronous handlers will not be called after we disconnect from the signal either. <br><br>  I will not give the code for the wrapper and overloaded method <i>connect</i> here.  I think the idea is clear and so. <br><br>  The model code becomes quite simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaUiModel</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UiModel&lt;MediaUiModelRow&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: signal_connection _connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MediaUiModel(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;task_executor&gt;&amp; uiThread, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MediaScanner&amp; scanner) { _connection = scanner.OnMediaFound.connect(uiThread, [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MediaPtr&amp; m) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;AppendRow(MediaUiModelRow(m)); }); } ~MediaUiModel() { _connection.reset(); } };</code> </pre><br>  Here, the <i>AppendRow</i> method will be called strictly in the UI thread, and only until we disconnect. <br><br><h1>  Summing up </h1><br>  So there are three key things that allow you to write much simpler code using signals: <br><br><ol><li>  Populators allow you to conveniently get the current state during connection to the signal </li><li>  The blocking <i>disconnect</i> method allows you to unsubscribe an object in its own destructor. </li><li>  In order for the previous item to be true for asynchronous handlers, <i>disconnect</i> must also mark those calls that are already in the queue of the thread as "irrelevant" </li></ol><br>  Of course, the code of the signals that I gave here is very simple and primitive, and does not work very quickly.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My goal was to talk about an alternative approach, which seems to me more attractive than the dominant today. </font><font style="vertical-align: inherit;">In reality, all these things can be written much more efficiently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use this approach in our project for about five years and are very happy.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ready implementation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I rewrote with C ++ 11 from scratch the signals that we had, improved those parts of the implementation that had long been worth improving. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use on health: </font></font><a href="https://github.com/koplyarov/wigwag"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/koplyarov/wigwag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mini FAQ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Judging by the reaction of people to Reddit and Twitter, basically everyone is concerned with three questions: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Immediately you need to block life_token to call each handler. Would it be slow? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oddly enough, no. You can use atomic variables instead of a mutex, and if we hit the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disconnect</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> call </font><font style="vertical-align: inherit;">at the moment the handler was executed, wait for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: condition_variable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then the result is absolutely the opposite: due to the missing overhead project in the form of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">track</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">track_foreign</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (which require working with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weak_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collections </font><font style="vertical-align: inherit;">), this implementation leaves memory and speed far behind boost :: signals2, and even outperforms Qt.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmarks can be found </font></font><a href="https://github.com/koplyarov/wigwag/wiki/Benchmarks"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Will there be deadlocks due to the blocking disconnect method? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, here deadlock is really a bit easier to get than in boost and Qt. In my opinion, this pays off with a simpler code for using signals and a higher speed of their work. In addition, if you carefully monitor who is subscribed to whom, then such situations are more likely an exception. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, naturally deadlock'i ‚Äã‚Äãneed to catch and repair. On Linux, I recommend </font></font><a href="http://valgrind.org/docs/manual/hg-manual.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helgrind</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For Windows, a two-minute Google search gives </font></font><a href="https://software.intel.com/en-us/intel-inspector-xe"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel Inspector</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://research.microsoft.com/en-us/projects/chess/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHESS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If for some reason you cannot afford any of the above (for example, there is not enough memory on your platform to run helgrind or some kind of marginal operating system), there is a solution to this (again, simplified) mutex :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::timed_mutex _m; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_m.try_lock()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!_m.try_lock_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">10</span></span>))) Logger::Warning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not lock mutex "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" for a long time:\n"</span></span> &lt;&lt; get_backtrace_string(); } <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both in Visual Studio and GCC there are means for getting backtrace in code. </font><font style="vertical-align: inherit;">In addition, there is a good libunwind. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this approach, most of your deadlocks will catch QA, and at one glance at the logs you will understand where everything is blocked. </font><font style="vertical-align: inherit;">It will only repair. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Can I use one mutex for several signals? </font><font style="vertical-align: inherit;">Can I handle exceptions the way I want? </font><font style="vertical-align: inherit;">Is it possible not to use synchronization and get fast single-threaded signals? </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Can, can, can be. </font><font style="vertical-align: inherit;">For all of this there are template strategies. </font><font style="vertical-align: inherit;">Read more in the documentation.</font></font></div><p>Source: <a href="https://habr.com/ru/post/279851/">https://habr.com/ru/post/279851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279841/index.html">How to detect overflow of 32-bit variable in long cycles in a 64-bit program</a></li>
<li><a href="../279843/index.html">Laravel TestTools - recording tests for Laravel directly from the Chrome browser</a></li>
<li><a href="../279845/index.html">The open Tarantool database from Mail.ru is certified and placed in the Azure Marketplace</a></li>
<li><a href="../279847/index.html">Less than 2 months, GoPro, a cool idea and team - everything you need to make a first-person game</a></li>
<li><a href="../279849/index.html">NetApp AltaVault: Backup and Archive Data in the Cloud</a></li>
<li><a href="../279853/index.html">Emacs Mysterious: Journey to Calculator</a></li>
<li><a href="../279855/index.html">Hackathon: Rapid Prototyping of the Internet of Things</a></li>
<li><a href="../279857/index.html">What to put on the perimeter of the network: Cisco router or Cisco ASA?</a></li>
<li><a href="../279859/index.html">Review of design books</a></li>
<li><a href="../279861/index.html">We suggest the details of the companies according to the Federal Tax Service of the Russian Federation and are looking for a double</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>