<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architecture of modular React + Redux applications 2. Core</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, I paid attention only to the general concept: reducers, components and actions often change at the same time, rather than separatel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architecture of modular React + Redux applications 2. Core</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/326484/">In the first part,</a> I paid attention only to the general concept: reducers, components and actions often change at the same time, rather than separately, therefore it is more expedient to group them and by modules, rather than by separate folders <i>actions</i> , <i>components</i> , <i>reducers</i> .  Also the following requirements were made to the modules: <br><br><ol><li>  be independent of each other </li><li>  interact with the application through the kernel API </li></ol><br>  In this part, I will talk about the structure of the core, suitable for developing data-driven systems. <a name="habracut"></a><br>  Let's start with the definition of the module.  Working with a simple object is not very convenient.  Add a bit of OOP: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _base = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'base'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ref = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'ref'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleBase</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(base){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[_base] = base <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[_ref] = getRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * unique module id * @returns {string} */</span></span> get id(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor.name } <span class="hljs-comment"><span class="hljs-comment">/** * full module ref including all parents * @returns {string} */</span></span> get ref(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[_ref] } <span class="hljs-comment"><span class="hljs-comment">/** * module title in navigation * @returns {string} */</span></span> get title(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id } <span class="hljs-comment"><span class="hljs-comment">/** * module group in navigation * @returns {string} */</span></span> get group(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-comment"><span class="hljs-comment">/** * react component * @returns {function} */</span></span> get component() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-comment"><span class="hljs-comment">/** * router route * @return {object} */</span></span> get route(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRoute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * router path * @return {string} */</span></span> get path(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id } <span class="hljs-comment"><span class="hljs-comment">/** * children modules * @return {Array} */</span></span> get children(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] } <span class="hljs-comment"><span class="hljs-comment">/** * @type {function} */</span></span> reduce <span class="hljs-comment"><span class="hljs-comment">//.... }</span></span></code> </pre> <blockquote>  The code above <a href="http://2ality.com/2016/01/private-data-classes.html">uses symbols</a> to implement encapsulation. <br></blockquote>  Now the declaration of the module is more familiar - it is necessary to inherit the <code>ModuleBase</code> class, redefine the necessary getters, and optionally add a define to <code>reduce</code> , which will be the reducer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Last time, we limited the nesting of modules to the second level.  In real applications, this is not enough.  In addition, we had to choose between the reducer of the parent module and the combination of the reducer subsidiaries.  This "breaks" the composition. <br><br>  For example, if we want to create a standard CRUD above an entity in a database, it is logical to organize modules like this: <br><br><pre> <code class="hljs pgsql">/SomeEntity /components /Master.js /children /<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js /<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>.js /<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>.js /<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js</code> </pre><br>  We assume that the standard form component is used for <i>create</i> and <i>update</i> , and the standard <code>Grid</code> component from the system kernel is used for data output; therefore, it suffices to define only the modules for these operations. <br><br>  The parent module is responsible for the output of the layout, the ‚Äúcreate‚Äù, ‚Äúback to the list‚Äù links and messages about the success or failure of requests to the server.  <code>Index</code> - for filtering, pagination and links.  <code>Create</code> and <code>Update</code> take the form to create and edit. <br><br>  Thus, the reducer of the parent module must have access to the entire subgraph of the module status, and the children - each to its part.  Implement two layout functions. <br><br><h3>  For routes </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getRoute = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> route = { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.path, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.title, <span class="hljs-attr"><span class="hljs-attr">component</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.component } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> children = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.children <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children) { ModuleBase.check(children) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> index = children.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.id.endsWith(INDEX)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(index.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// share title with parent module route.indexRoute = { component: index[0].component } } route.childRoutes = module.children .filter(x =&gt; !x.id.endsWith(INDEX)) .map(getRoute) } return route }</span></span></code> </pre> <br><h3>  And for reusers </h3><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleBase</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//.... combineReducers(){ const childrenMap = {} let children = Array.isArray(this.children) ? this.children : [] ModuleBase.check(children) const withReducers = children.filter(x =&gt; typeof(x.reduce) === 'function' || x.children.length &gt; 0) for (let i = 0; i &lt; withReducers.length; i++) { childrenMap[children[i].id] = children[i] } if(withReducers.length == 0){ return reducerOrDefault(this.reduce) } const reducers = {} for(let i in childrenMap){ reducers[i] = childrenMap[i].combineReducers() } const parent = this const reducer = typeof(this.reduce) === 'function' ? (state, action) =&gt; { if(!state){ state = parent.initialState } const nextState = parent.reduce(state, action) if(typeof(nextState) !== 'object'){ throw Error(parent.id + '.reduce returned wrong value. Reducers must return plain objects') } for(let i in childrenMap){ if(!nextState[i]){ nextState[i] = childrenMap[i].initialState } nextState[i] = {...reducers[i](nextState[i], action)} if(typeof(nextState[i]) !== 'object'){ throw Error(childrenMap[i].id + '.reduce returned wrong value. Reducers must return plain objects') } } return {...nextState} } : combineReducers(reducers) return reducer }</span></span></code> </pre> <br><blockquote>  This is not the most effective implementation of such a reducer.  Unfortunately, even she took me quite a lot of time.  I would be grateful if someone in the comments tells you how to do better. </blockquote><br><h3>  Matching Routes and State </h3><br>  This modular system implementation relies on the one-to-one state and route correspondence, with a few exceptions: <br><br><ol><li>  <code>/Update</code> is replaced by <code>/:id</code> </li><li>  <code>/Index</code> omitted ( <code>indexRoute</code> used) </li><li>  There is no route for <code>Delete</code> .  Removal is done from the <code>Index</code> module. </li></ol><br>  The path method can be redefined and then the route will be distinguished from the module name.  You can construct a chain of modules of any nesting.  Moreover, if your application has only one root route <code>/</code> , then it is advisable to make the <code>App</code> module and put all the others into it in order to use one approach everywhere. <br><blockquote>  This will allow the App (if needed) to handle any application events and modify the state of any child module.  Perhaps it is too cool for anyone, even the coolest reducer.  I do not recommend overriding reduce at all for the parent module of the application.  However, such a reducer can be useful for system operations. </blockquote><br>  With the routing done, it remains to " <a href="https://maxfarseer.gitbooks.io/redux-course-ru/content/prisoedinenie_dannih_connect.html">connect</a> " the components to the state.  Since the receivers are arranged recursively in accordance with the embedding of the child modules, we will also connect.  Everything is simple here.  The implementation of <code>mapDispatchToProps</code> will <code>mapDispatchToProps</code> discussed below. <br><br><h3>  Kernel components </h3><br>  So, <code>ModuleBase</code> is the first and integral part of the kernel.  Without it, your code to the application does not pick up.  <code>ModuleBase</code> provides the following API: <br><br><ol><li>  Register component in the router </li><li>  Registration of the module's reducer </li><li>  Connect components to redux state </li></ol><br>  Not bad, but not enough.  <code>CRUD</code> should be easy to do.  Add a <code>DataGridModuleBase</code> and <code>FormModuleBase</code> .  Until now we have not specified which components are used in the modules. <br><br><h3>  Components and containers </h3><br>  <a href="https://medium.com/%40learnreact/container-components-c0e67432e005">Containers</a> are one of the most common patterns in React.  In short, the difference between components and containers is as follows: <br><br><ol><li>  Components (or presentation components) do not contain external dependencies and logic </li><li>  Containers (as the name implies) wrap the components, realizing the binding between the outside world and the components </li></ol><br>  Such an organization improves code reuse, helps in sharing work among different specialists and simplifies testing. <br><br><blockquote>  The <a href="https://maxfarseer.gitbooks.io/redux-course-ru/content/prisoedinenie_dannih_connect.html">connect</a> (react-redux) function is essentially a container factory. </blockquote><br>  To develop a <code>DataGridModule</code> we need: <br><br><ol><li>  <code>DataGrid</code> <i>component</i> </li><li>  its <code>DataGridContainer</code> <i>container</i> </li><li>  reducer for communication between container and application state in redux </li></ol><br>  I omit the implementation of the presentation component.  To connect to the state, we have the <code>ModuleBase.connect</code> function.  It remains to receive data from the server.  You can create a new class for each grid and override <code>componentDidMount</code> or other methods of the component life cycle.  The approach, in general, is working, but has two significant drawbacks: <br><br><ol><li>  a huge amount of boilerplate and copy-paste.  A copy-paste, as you know, always leads to errors </li><li>  low development speed of modules: the kernel does not yet provide any API to speed up development, this is wrong </li></ol><br><h3>  Impurities (mixin) </h3><br><blockquote>  I recommend to familiarize with the <a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html">documentation of react</a> concerning impurity.  Use them with caution, otherwise you can step on a variety of rakes. </blockquote><br>  Extend the layout of components and containers using mixins.  <code>class</code> and <code>extends</code> are first class objects in ES6.  In other words, the <code>const Enhanced = superclass =&gt; class extends superclass</code> valid.  This is possible thanks to the JavaScript prototype inheritance system. <br><br>  Add the <a href="http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/">mix</a> function and the <code>Preloader</code> and <code>ServerData</code> impurities to the <code>ServerData</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Preloader = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Component</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propsToCheck = subset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor.initialState) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isInitialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isFetching = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propsToCheck){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(propsToCheck[i][IS_FETCHING]) === <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isFetching &amp;&amp; propsToCheck[i][IS_FETCHING]){ isFetching = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-comment"><span class="hljs-comment">// if something except "isFetching" presents it's initialized if(isInitialized &amp;&amp; Object.keys(propsToCheck[i]).length === 1){ isInitialized = false } } } return isInitialized ? (&lt;Dimmer.Dimmable dimmed={isFetching}&gt; &lt;Dimmer active={isFetching} inverted&gt; &lt;Loader /&gt; &lt;/Dimmer&gt; {super.render()} &lt;/Dimmer.Dimmable&gt;) : (&lt;Dimmer.Dimmable dimmed={true}&gt; &lt;Dimmer active={true} inverted&gt; &lt;Loader /&gt; &lt;/Dimmer&gt; &lt;div style={divStyle}&gt;&lt;/div&gt; &lt;/Dimmer.Dimmable&gt;) } } const ServerData = superclass =&gt; class extends mix(superclass).with(Preloader) { componentDidMount() { this.props.queryFor( this.props.params, subset(this.props, this.constructor.initialState)) }</span></span></code> </pre> <br>  The first one checks all keys in the stack and if it finds at least one with a certain property <code>isFetching: true</code> displays the dimmer on top of the component.  If, apart from <code>isFetching</code> , there are no properties in the object, we consider that they should come from the server and do not display the component at all (we assume it is not initialized). <br><br>  Mix <code>ServerData</code> automatically mixes the preloader and overrides the <code>componentDidMount</code> . <br><br><h3>  queryFor </h3><br>  Let us consider in more detail the implementation of queryFor.  It was passed to <code>Module.connect</code> via <code>mapDispatchToProps</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> queryFactory = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (dispatch) != <span class="hljs-string"><span class="hljs-string">'function'</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'dispatch is not a function'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleId, url, params = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">undefined</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: combinePath(moduleId, GET), params }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ get(url, params).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-string"><span class="hljs-string">'ok'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response &amp;&amp; !response.ok <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = error ? {<span class="hljs-attr"><span class="hljs-attr">ok</span></span>: response.ok, <span class="hljs-attr"><span class="hljs-attr">status</span></span>: response.status} : response dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: combinePath(moduleId, GET + <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error ? FAILED : SUCCEEDED</span></span></span><span class="hljs-function">)), ...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> }) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) }) }) }) } } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">export</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">queryAll</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, moduleRef, params, ...keys</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> query = queryFactory(dispatch) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!keys.length){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'keys array must be not empty'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = combinePath(moduleRef, keys[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> promise = query(action, fixPath(action), params) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; keys.length; i++){ promise.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> act = combinePath(moduleRef, keys[i]) query(act, fixPath(act), params) }) } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> queryFor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, moduleRef, params, state</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keys = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> state) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state[i].isFetching !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { keys.push(toUpperCamelCase(i)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queryAll(dispatch, moduleRef, params, ...keys)</code> </pre><br>  Using <code>queryFactory</code> we create a <code>query</code> function, which makes a request to the server, dispatches the corresponding events in the <code>store</code> and returns a <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a> , so that we can build a query chain of the function in the <code>queryAll</code> , which the <code>queryFor</code> function, which is oriented to the presence of <s>the house that Jack built</s> . <br><br>  We add an ‚Äúobhoshchalka‚Äù for a state that requires server data: <br><br><pre> <code class="javascript hljs">ServerData.fromServer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialState, ...keys</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; keys.length; i++){ initialState[keys[i]].isFetching = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initialState }</code> </pre> <br>  Now it‚Äôs enough to know the rules of using mixin to make any component working with client data on the server one.  It is enough to properly configure initialState and connect mixin. <br><br>  It remains to process the events of the start of receiving data, successful receipt and errors and change the state of the container accordingly.  To do this, we add a reducer in the module. <br><br><h3>  ServerData.reducerFor </h3><br><pre> <code class="javascript hljs">ServerData.reducerFor = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleRef, initialState, next = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, method = GET</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!moduleRef){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'You must provide valid module name'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!initialState){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'You must provide valid initialState'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reducer = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> initialState) { reducer[i] = hasFetching(initialState, i) ? ServerData.serverRequestReducerFactory(combinePath(moduleRef, i), initialState[i], next, method) : passThrough(initialState[i]) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(reducer) &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'No "isFetching" found. Cannot build reducer'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combined = combineReducers(reducer) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combined } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataGridModuleBase</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(base){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(base) <span class="hljs-comment"><span class="hljs-comment">// Create is required due to children module this.reduce = ServerData.reducerFor(this.ref, DataGridContainer.initialState) } get component () { return this.connect(DataGridContainer) } }</span></span></code> </pre><br><h3>  Add a module with a grid to the application </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeEntityGrid</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataGridModuleBase</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//.. const _children= Symbol('children') export default class App extends ModuleBase{ constructor(base){ super(base) this[_children] = [new SomeEntityGrid(this)] } get path (){ return '/' } get component () { return AppComponent } get children(){ return this[_children] }</span></span></code> </pre> <br><blockquote>  If you have read to the end, you can implement FromModuleBase by analogy. </blockquote><br><h3>  The final structure of the nucleus </h3><br><pre> <code class="hljs">/core /ModuleBase.js /api.js /components /containers /modules /mixins</code> </pre> <br><ol><li>  Base modules contain reusable logic and sets of standard components that are often used together (for example, <code>CRUD</code> ). </li><li>  The <code>components</code> and <code>containers</code> folders contain frequently used components and containers, respectively. </li><li>  With the help of impurities, components and containers can be arranged: a grid with server data, a grid with inline input, a grid with server data and inline input, etc. </li><li>  api.js contains functions for working with the server: fetch, get, post, put, del, ... </li></ol><br><h3>  Division of responsibility </h3><br><ol><li>  Modules: routing, container creation, transfer of necessary functions to the container, reducer for the component, provision of meta-information. </li><li>  Components: reusable UI parts.  Go well with <a href="https://habrahabr.ru/post/246143/">BEM</a> .  Can be developed independently of the main application by a separate command. </li><li>  Containers: displaying the status of an application and API set on presentation components. </li><li>  Additional middleware: not used.  Instead, only <a href="https://github.com/gaearon/redux-thunk">redux-thunk</a> .  Additional middleware is not used because it complicates the system.  Using <a href="https://github.com/redux-saga/redux-saga">redux-saga</a> makes the learning curve much <a href="https://github.com/redux-saga/redux-saga">worse</a> and increases the size of the bundle, so thunk is preferred. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/327196/">https://habr.com/ru/post/327196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327184/index.html">Selenium in 60 seconds</a></li>
<li><a href="../327186/index.html">How it works in the java world. Concurrentmap</a></li>
<li><a href="../327190/index.html">Ways to debug JS on client</a></li>
<li><a href="../327192/index.html">The story of the creation and launch of a fun mobile game about breaking bottles on the head</a></li>
<li><a href="../327194/index.html">10 mini life hacks in Bash</a></li>
<li><a href="../327198/index.html">PHP Digest number 107 - the latest news, materials and tools (April 9 - 23, 2017)</a></li>
<li><a href="../327200/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ259 (April 17 - 24, 2017)</a></li>
<li><a href="../327202/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 23</a></li>
<li><a href="../327204/index.html">Web analytics. How the numbers lie to us</a></li>
<li><a href="../327206/index.html">GoTo Data Science Challenge 2: Summer School Grants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>