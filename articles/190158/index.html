<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Morphology. Tasks and approaches to their solution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The contents of a series of articles about morphology  ‚Ä¢ Morphology and computational linguistics for the smallest 
 ‚Ä¢ The role of morphology in compu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Morphology. Tasks and approaches to their solution</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/e0d/d58/118/e0dd581182453080c3a0c27d581d86f9.jpg" align="right"><div class="spoiler">  <b class="spoiler_title">The contents of a series of articles about morphology</b> <div class="spoiler_text">  ‚Ä¢ <a href="http://habrahabr.ru/company/abbyy/blog/188026/">Morphology and computational linguistics for the smallest</a> <br>  ‚Ä¢ <a href="http://habrahabr.ru/company/abbyy/blog/189020/">The role of morphology in computational linguistics</a> <br>  ‚Ä¢ <b>Morphology.</b>  <b>Tasks and approaches to their solution</b> <br>  ‚Ä¢ <a href="http://habrahabr.ru/company/abbyy/blog/190872/">Pseudo-lemmatization, composites and other strange words</a> </div></div><br>  In the last article, we came close to solving the problem of lemmatization and found out whether we want it or not, but we will have to keep a dictionary with all the words of the described language in one form or another. <br><br>  For the Russian language is a few hundred thousand words.  Maybe it is not economical, but it gives us a lot of bonuses. <br><br>  First, we can check <b>if there is a word in the dictionary</b> .  With the help of rules based on regular expressions, we won‚Äôt find out if there is a word ‚Äúby name‚Äù in Russian.  The end is completely subject to the rules of the Russian language, the repetition of syllables is also not an exceptional case.  This word will miss the regular expression, but in fact there is no ‚Äúname‚Äù in Russian. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another task that is solved by a dictionary stored in morphology is the <b>correction of errors</b> .  As soon as we do not find any word in the dictionary, but we find another word there at a short <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">distance from Levenshtein</a> to the desired one, we make a decision to correct it. <a name="habracut"></a><br><br>  To solve these problems, we need to store not only all the words, but all their forms.  All the rules for the formation of forms for a group of words similar to each other are called <b>the inflection paradigm</b> .  Take the verb "budlanut": budlanul, budlanesh, budlanet, budlanul, budlanula, budlanuli.  You can find a mass of verbs that will be changed by the same rules;  on the other hand, a huge number of verbs will vary according to different rules.  This means that these verbs belong to different paradigms. <br><br>  In order for us to answer syntax questions, we also store its <b>grammatical meaning</b> with each form. <br><br><h5>  Dictionary storage </h5><br>  Thus, the dictionary stored in the system solves a lot of problems, which is good news.  But how to store this dictionary?  There are several hundred thousand words in Russian.  On average, there are 15 forms per word.  Where do we get this number from?  Consider the cases: there are 6 for the singular and 6 for the plural - already 12. And this is not to say that in Russian there are not 6 cases, as taught in school, but 8. <br><br>  First, the prepositional case hides the case, which is called the locative.  If we put the word ‚Äúforest‚Äù in the prepositional case, we will have two options: ‚Äúabout the forest‚Äù and ‚Äúin the forest‚Äù.  In the forest, it is a locative case, not a prepositional one.  For many nouns, the forms of these cases coincide because we do not distinguish ‚Äúin the table‚Äù, ‚Äúabout the table‚Äù, and ‚Äúon the table‚Äù.  This is because there are no ‚Äúin the table‚Äù locations, but there is a ‚Äúin the forest‚Äù location. <br><br>  The eighth case is called partitiv.  This case shows a part of the whole.  If we run out of tea, get up too lazy, and someone unoccupied walks alongside, we tell him: "Pour me, please, tea."  As a rule, the form of words in a partitive coincides with the genitive or accusative case.  Wikipedia gives us an excellent example of a word that has no other forms than the partitive of the plural - ‚Äúcheek‚Äù (‚ÄúDo you want a cheek?‚Äù; ‚ÄúPour me a cheek!‚Äù) <br><br><img src="https://habrastorage.org/storage2/669/034/102/669034102548080eef347934f800d901.jpg" align="right">  Total, 8 cases multiplied by 2 forms (singular and plural) - already 16. Verbs have time, number and gender.  By simple arithmetic calculations, we obtain that 15 forms are a rather modest estimate from below. <br><br>  The average empirical number of characters in a Russian word is 9. We multiply the obtained results, not forgetting to take into account that there are 2 bytes per character, and it turns out that 50 megabytes is necessary for a dictionary of all forms of the Russian language.  In practice, our ideal 50 megabytes is increased by one and a half times: as a result, a text file with all forms of Russian words takes up more than 75 megabytes. <br><br>  In addition, even if we write all these words to a file, we will need to search for it (otherwise why is it needed?).  That is, we must sort the words alphabetically and in addition to each word add a pointer to the initial form of the word.  Pointers, though not heavy one by one, still add significant weight to our dictionary.  The search speed will be <br><br><img src="https://habrastorage.org/storage2/37b/e0b/8d0/37be0b8d09dc5cb7cca0cc54cfaf2538.png"><br><br>  And this is only in Russian, and there are still English, French, Spanish, Italian, and many other beautiful and rich languages.  If we want, for example, FineReader to recognize and support many languages, we need only morphological dictionaries to fit into a gigabyte.  What to say about recognition patterns and other dlls?  A user with such heavy technology will not understand us - and he will be right.  You have to be more modest and keep better. <br><br><h5>  Prefix tree </h5><br>  A prefix tree comes to the rescue.  How does it work?  It all starts from the top - an empty symbol in which the alphabet is stored.  For the first letter, the entire alphabet is stored there, more precisely, an array of 33 pointers.  Each pointer corresponds to its character.  The first pointer is to symbol A, the second is to symbol B, a certain K-th pointer is to symbol K and a certain F-th one is to symbol P. By the signs we can get the following nodes of this tree, which correspond to the letters of the Russian alphabet. <br><br>  The following nodes again store arrays.  And for the speed of the search, we neglect the fact that the letters for which we need pointers will be less than 33 (we are unlikely to need a combination of ‚Äúay‚Äù, for example).  We leave the dimension of the array unchanged, inserting null pointers for missing characters. <br><img src="https://habrastorage.org/storage2/0b9/7de/b7a/0b97deb7a02cb8382ba096094351d792.png"><br><br>  The figure shows an example of a prefix tree for four words: ‚Äúcat‚Äù, ‚Äúcat‚Äù, ‚Äúwhale‚Äù and ‚Äúdog‚Äù.  Pink painted final vertices. <br><br>  The advantage of this approach is that we do not store huge chains of repetitive characters for the same word, standing in different forms.  Thus, we reduce the file size with a dictionary.  For example, for the Russian language, this tree, along with additional data, takes about 2 megabytes.  First, compared to 75 megabytes, this is certainly a success.  Secondly, the search speed for such a tree is much higher than for a sorted file.  Now it does not depend on the size of the entire dictionary, but only on what we are looking for.  If we are looking for the union "a", we will find it in one step, and if we are looking for a long word, for example, "helicopter-building", we will have to search a little longer. <br><br>  Of course, if we put all forms of all words without grammatical meanings into a tree, then we cannot talk about any computer linguistics: we cannot rise to the level of syntax, not to mention semantics, and without them automatic translation is impossible.  Consequently, the data structure still needs some work. <br><br><h5>  What to store in the dictionary </h5><br><img src="https://habrastorage.org/storage2/0b4/46c/4e4/0b446c4e43e7b78f0da9566e90d9192c.png"><br><br>  Theoretically, we can actually store all the forms of words in the tree, while keeping pointers to the initial form (the blue lines in the figure).  However, pay attention: in spite of the fact that ‚Äúcat‚Äù and ‚Äúcat‚Äù belong to different word-formation paradigms, some of the inflections (as we call endings) coincide.  What if these tails of words are stored separately, and in the tree leave the initial forms of cats, cats and whales?  So it will be more effective. <br><br><h5>  Thorough approach </h5><img src="https://habrastorage.org/storage2/038/7f1/7f9/0387f17f9419340b88dc750ae28c7216.png" align="right"><br>  At school, the word is divided into its component parts as follows: prefix, root, several suffixes, and ending.  We will go the other way.  First, we will not separate the prefix from the root.  This is due to the fact that often the prefix together with the root form a completely new meaning.  Take for example the words "prefix" and "bet."  ‚ÄúPri-‚Äù is just a prefix of the word ‚Äúbet‚Äù, but ‚Äúprefix‚Äù and ‚Äúbet‚Äù are completely different things. <br><br>  In addition, the prefix does not express any grammatical category.  When we add the prefix "re-" ("remake" or "perekurdyachit"), we change the lexical meaning of the word, not the grammatical.  Therefore, we consider the prefix and the root as a whole and call it the basis of the word. <br><br>  Another difference from school: we almost never separate the suffixes from endings, since in most cases they express the grammatical category.  In our example, ‚Äú-l-" and "-a" express the past tense, the feminine gender, and we combine them into flexion.  With this division, we get the variable part of the word - flexion and unchangeable - the base. <br><br><h5>  Convenient assumptions </h5><br><img src="https://habrastorage.org/storage2/e31/299/6fe/e312996feedbbcc86cbeb783b029dba4.png"><br>  You, probably, have already got used to the fact that nothing in computer linguistics just happens.  Here it is: even a part of the root can change in different forms of the word.  Of course, it can be tedious to argue that this is just a changeable consonant in the root of "friend-g" and "friend-z," but for solving practical problems it is more convenient for us to accept that these words have the same basis as "friend-" inflections are different. <br><br>  So, we have determined that lexemes (word bases) and flexions will be stored separately.  Finally, we come close to how our morphological module in ABBYY solves the problems of lemmatization. <br><br><h5>  Final lemmatization </h5><br><img src="https://habrastorage.org/storage2/f6d/3bd/b70/f6d3bdb702bd9aef82fe65fa83eef27b.png"><br>  In the picture on the left, in the form of a prefix tree already familiar to you, one hundred thousandth part of the dictionary of the Russian language is shown.  On the right is a dictionary of endings that is stored in the same way. <br><br>  If you look closely at the endings, you will notice that they can be attributed to both the ‚Äúcat‚Äù and the ‚Äúwhale‚Äù.  If we add "a", we get a genitive case, if "y" is dative and so on.  All these are different forms of two words that belong to the same paradigm and therefore change in the same way. <br><br><h5>  Whale analysis </h5><br>  When we get the form of a word, we begin to analyze it not at first, but from the end.  First, we assume that there is a zero ending, which is marked in pink and shows that the nominative case is in front of us, the only number.  Then we follow the word "whales" given to us and meet the letter "and."  We find the letter ‚Äúand‚Äù in the prefix tree.  The next letter is ‚Äúm‚Äù.  These letters are not the last, so we continue to move deep into the tree.  The next letter "a", which is marked pink, is the final node in the tree.  Hence, ‚Äú-ami‚Äù from left to right, or ‚Äú-im‚Äù from right to left, is one of the ending options with which the word can end. <br><br>  So, we found two endings: empty and "-ami".  Now we need to look for the basis in the prefix dictionary tree.  This search is carried out from left to right.  We consistently find the letters ‚Äúk‚Äù, ‚Äúi‚Äù and ‚Äút‚Äù, and on the letter ‚Äút‚Äù the tree ends.  That is, ‚Äúwhale‚Äù is one of the words stored in this tree.  If we try to search further, we will see that the next letter is ‚Äúa‚Äù, but there are no pointers to the next vertex, which means that we stop the search. <br><br>  We see that the three letters on the left and the three letters on the right have grown into a word, but the empty ending did not come in handy.  We decide that "whales" is a plural form, the instrumental case, a lexeme with the initial form "whale". <br><br>  On the not yet illuminated problems solved by the morphology subsystem, read the next post. </div><p>Source: <a href="https://habr.com/ru/post/190158/">https://habr.com/ru/post/190158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190146/index.html">Tessel - JavaScript Programmable Microcontroller</a></li>
<li><a href="../190148/index.html">Scrambls - protection of your intellectual property and encryption in social networks</a></li>
<li><a href="../190150/index.html">Storage Systems: Savings and Optimization</a></li>
<li><a href="../190154/index.html">SIP URI and URL. Part 1 (URI, URL and URN)</a></li>
<li><a href="../190156/index.html">Not quite a standard approach to organizing access to a WiFi network (Cisco WLC -> FreeRadius -> PHP -> web page)</a></li>
<li><a href="../190168/index.html">Design Integration with Blend</a></li>
<li><a href="../190170/index.html">Why it is worth taking loans</a></li>
<li><a href="../190176/index.html">Data Structures, PHP</a></li>
<li><a href="../190180/index.html">Acceleration Arduino. Under liquid nitrogen. 20 ‚áí 65.3Mhz @ -196 ¬∞ C</a></li>
<li><a href="../190186/index.html">Perl6 - Operator Overloading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>