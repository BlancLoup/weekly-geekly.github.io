<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Icy Rocks Test for Android: it's time for a real test</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android OS, if you compare it with Windows, Linux or OSX, the system is young. However, it is used by more than a billion people. How exactly do they ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Icy Rocks Test for Android: it's time for a real test</h1><div class="post__text post__text-html js-mediator-article">  Android OS, if you compare it with Windows, Linux or OSX, the system is young.  However, it is used by more than a billion people.  How exactly do they work with Android?  How to make the system faster and more convenient?  The novelty of the platform does not allow to give clear answers to these questions.  Moreover, user interaction scenarios with Android devices and applications are constantly changing, often quite strongly and unexpectedly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b1a/e4d/6eb/b1ae4d6eb7ab42e584201ca30c68b816.jpg"></div><br>  To study the peculiarities of user interaction with various software and hardware complexes, special tests are created, the so-called options or scenarios for using systems (use cases).  They are also called ‚Äúworkloads‚Äù (workloads).  All this is a model of real-life work scenarios, they are not real applications.  When applied to Android, such tests can be used to measure and improve performance. <br><a name="habracut"></a><br>  Unfortunately, for Android, there are only a few applications that plausibly mimic the real workload.  The tests used today, like CaffeineMark, either have nothing to do with these scenarios, or are too simple.  These tests simply do not contain tests aimed at exploring how the devices are actually used.  However, they, by virtue of prevalence, strongly influence public opinion, on how the general public perceives certain devices. <br><br>  As a result, developers, in terms of the results of such tests, are not able to figure out what sensations the work with this or that device will cause from a real user.  If you optimize the system, relying on such tests, you can achieve impressive performance, which is called ‚Äúon paper‚Äù and leave open the main question: ‚ÄúWhat will it give to users?‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0071c5">Review Icy Rocks</font> </h2><br>  Most of the tests for Android explore the system in one of two main areas.  Some focus on a limited set of hardware features of the devices.  They are designed to get some data on specific components or sets of components of SoC-platforms.  Others are not tied to hardware.  They focus on the Java environment level, in fact, using a limited number of functions.  Both are synthetic workloads, they do not do the same thing that happens in the code of a typical real application. <br><br>  The application execution stack in Android is complex, so when analyzing the performance of this system, it is worthwhile to move away from outdated, narrowly focused methods and switch to new ones.  For those that more accurately reflect the behavior of people.  If our goal is to significantly improve the perception of applications by humans, we need tests that implement realistic scenarios for working with the system.  Namely, it is necessary to take into account how the user works with the application, and how the application interacts with the operating system, and, ultimately, with the hardware. <br><br>  Icy Rocks Workload is a graphical application developed by Intel that simulates a real game on the Android platform.  The project uses a physical open source library <a href="http://jbox2d.org/">JBox2D</a> and graphics engine <a href="https://code.google.com/p/cocos2d-android-1/">Cocos2D</a> .  OpenGL is responsible for displaying graphics in Cocos2D.  JBox2D deals with the simulation of moving objects.  It built the physics of the game world, he is responsible for updating the positions of objects and their interaction. <br><br>  The test measures several indicators.  The first is the average number of frames per second (Frames Per Second, FPS).  FPS is usually used to evaluate the smoothness of graphics output.  The average number of animations per second (Animation Per Second, APS) allows you to evaluate the performance of the physical engine.  Other indicators are the average frame update time (Frame Update Time), the number of frames dropped per second (Janks Per Second, JPS).  The total data collected by the program are displayed on the screen and recorded in a log file on the device. <br><br><h2>  <font color="#0071c5">Game simulation</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/727/431/490727431d538685947a35a72e043661.png"></div><br>  <i><font color="#999999">Icy Rocks in action</font></i> <br><br>  The main screen of Icy Rocks is full of sprites.  Here are ice floes, snow flakes, snowman and catapult.  Catapult throws chunks of ice into a snowman.  They are separated by a gorge, snowflakes and ice floes roll there.  In the lower part of the gorge there is a rotating agitator, which does not allow to miss all that got to the bottom.  The load that the game creates on the system during the simulation gradually increases.  This is achieved by adding pieces of ice and snowflakes. <br><br>  Icy Rocks can be performed in two modes.  The first is the demo mode, the second is for testing.  In the demo mode, the user can add to the screen floes and snow flakes by touching the screen.  In test mode, everything is done automatically.  Chunks of ice and snowflakes are added every 20 seconds with a 2: 5 ratio, the program does not respond to touching the screen.  A total of five passes of the test are performed, after which the final results are displayed. <br><br><h2>  <font color="#0071c5">Three options for Icy Rocks</font> </h2><br>  Icy Rocks exists in three versions.  The first is for the Android platform, the second is for Oracle Java (JDK 8), the third is represented by the native C ++ application.  Appearance and animation in all three options are similar. <br><br>  As already mentioned, there are two modes of the program - demo and test.  In demo mode, the runtime is unlimited, in test mode it is about 11 minutes. <br><br>  Icy Rocs for the Android platform is a reference implementation.  Icy Rocks for Java can be run on any PC running Linux with Java 8 installed. Icy Rocks uses native C ++ version of <a href="http://box2d.org/">Box2D</a> and <a href="http://cocos2d-x.org/">Cocos2D-X</a> . <br><br>  Icy Rocks for Android and Java can be run both in graphics mode and in CPU mode (non-GL).  The last option is also called Icy Rocks Workload for Kernel.  Its use allows us to estimate the autonomous performance of the physics engine. <br><br><h2>  <font color="#0071c5">Launch of Icy Rocks</font> </h2><br>  Icy Rocks for Android comes as a single GameWorkload.apk package.  After installing and running the application, you can select the test mode (benchmark) or demo (demo).  In test mode, everything is done automatically, at the end of the work the results are reported.  In demo mode, the user can interact with the program. <br><br><h2>  <font color="#0071c5">Automatic load distribution over time</font> </h2><br>  In a typical real Android game, computational complexity increases when the user reaches a higher level and scores more points.  At Icy Rocks, we easily increase the load by adding more ice and snow ‚Äî this is shown in the illustration below. <br><br>  Icy Rocks measures the average number of frames output per second (FPS) under a load of varying intensity, then calculates the geometric average of the indicator at different load levels.  The test also measures the number of frames dropped per second (Jank Per Second, JPS) at various points in the animation.  The term ‚ÄúJank‚Äù in the Java environment is used to denote ‚Äúragged‚Äù, ‚Äúhopping‚Äù animation. <br><br>  The typical duration of one session of the game on Android is about 10 minutes, so the test is designed to run for about 11 minutes.  This includes 10-second pauses between test passes.  Within one pass, the load on the system, due to the addition of pieces of ice and snowflakes, increases.  In the beginning on the screen there is neither one nor the other.  Then add 20 ice and 50 snowflakes - and so on.  When the load increases to a predetermined limit, a 10-second break is taken and everything repeats.  There are five passes of the test, each takes about two minutes.  Here is how it looks in the diagram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63e/013/38f/63e01338f566b9f4db8b675bb8de07e5.png"></div><br>  <i><font color="#999999">Testing scheme</font></i> <br><br>  When performing each of the test passes, the above mentioned indicators are calculated.  Namely: <br><br>  The main indicators (primary metrics). <br>  - The number of animations per second. <br>  - Frame frequency. <br><br>  Additional indicators (secondary metrics). <br>  - Screen refresh time in seconds per frame. <br>  - The number of frames dropped. <br><br>  After the test is completed, the geometric average is calculated from the measurements made in each of the five passes.  The final result is as shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/585/e8e/794/585e8e79457fcf91a69e72e0514fb010.png"></div><br>  <i><font color="#999999">Test results</font></i> <br><br><h2>  <font color="#0071c5">The mechanism of Cocos2D for Android (Java)</font> </h2><br>  When using Cocos2D for the Android platform, the game sets in motion the main loop in which the user actions are processed, the game logic is implemented (moving objects, for example), animation and GL commands are prepared, and finally a new frame is drawn. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b4/8b2/69a/4b48b269aee1c89c8d8cddbd2b3d702b.png"></div><br>  <i><font color="#999999">The scheme of the typical game</font></i> <br><br><h2>  <font color="#0071c5">The mechanism of JBox2D</font> </h2><br>  JBox2D is a library of simulating the interaction of solids.  With its help, you can simulate realistic behavior of game objects.  JBox2D is used as a subsystem for the implementation of game logic in Cocos2D. <br><br>  In games, as a step of the game world, usually use 1/60 of a second.  JBox2D is responsible for modeling the physical interactions in the game world. <br><br>  It all starts with defining all the objects in the game world and installing event listeners.  It then initializes the scene from the point of view of the physics engine and prepares callback functions.  At each step of the game, when the main loop calls JBox2D to update the world, the positions and speeds of the objects are updated. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e9/c48/b57/5e9c48b5769be7a452c7a2f973700597.png"></div><br>  <i><font color="#999999">The scheme of the physics engine</font></i> <br><br><h2>  <font color="#0071c5">Game streams</font> </h2><br>  A typical gaming application has two threads: main (main thread) and graphics output stream (renderer thread).  The main thread initializes the application and the game screen, and then starts the main loop.  The graphics output stream is called every time a scene is drawn, and it is also responsible for invoking event handlers.  Here is some information on these two streams: <br><br>  <b>Main thread</b> <br>  - Initialization of the application (MainActivity.java). <br>  - Initialization of the game screen (GameLayer.java). <br>  - Initialization of physical objects in JBox2D and sprites in Cocos2D. <br>  - Installation of object collision event listeners. <br><br>  <b>Graphics output stream</b> <br>  - Standard update function of the game world (update () in GameLayer.java). <br>  - Perform a pitch of the game world. <br>  - Passing through all physically objects and setting the position and angle of rotation for the corresponding sprites. <br>  - The collision event listener (postSolve in GameLayer.java) is used to implement special effects. <br>  - An ice floe breaks into small parts when it collides with massive objects. <br>  - Animated display of points when hit by ice in a snowman. <br>  - Screen touch handler (ccToucherEnded in GameLayer.java) is used to add snowflakes and ice to the screen. <br>  - Function to display statistics (showFPS in CCDirector.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/6d9/075/ab66d9075521dfcf53aaaf16c5ef7737.png"></div><br>  <i><font color="#999999">Icy Rocks Job Scheme</font></i> <br><br>  Above is a diagram of the work cycle drawing.  It resembles the main cycle, which we considered above, talking about Cocos2D, but our cycle is a bit more complicated.  Each time the scheduler timer is triggered, the next frame is calculated and updated.  At this time, callback functions and game logic are processed.  For example, JBox2D is called to implement game physics.  After that, you can start displaying the image. <br><br>  When the output is complete, a small waiting period is possible - until the FrameTime time comes.  This waiting is necessary in order to ensure a stable frame rate.  For example, if an application is capable of issuing 100 FPS, it will, thanks to this approach, slow itself down to the required 60 FPS.  And the remaining time can be spent on the implementation of more advanced game logic, data preparation and other similar tasks. <br><br><h2>  <font color="#0071c5">Icy Rocks Performance Review</font> </h2><br>  Icy Rocks can be viewed as a single-threaded Android test running on the Android GLTHread stream.  During the test, most of the time is spent on executing code from Android Runtime (ART) and working in low-level OpenGL libraries.  Some time passes in the machine code of Android, called via the Java Native Interface (JNI) and System.arraycopy. <br><br>  In the course of the test, in fact, the possibilities of Android Runtime, the graphics capabilities of the Android stack, and the hardware capabilities of the SoC platform are explored. <br><br>  The Icy Rocks test for Java is demanding for arithmetic logic operations (ALU), the branch prediction subsystem (floating-point comparison), the performance of the associative data translation buffer (DTLB) and the second-level cache (L2). <br><br>  As already mentioned, the test contains five identical passes.  Each of them is divided into 20-second intervals, during which the number of snowflakes and ice floats remains constant.  When moving to the next interval, their number increases.  Most of these configurations have identical performance characteristics (for example, a similar number of instructions per cycle, the same Java code that is executed most often, and so on).  During the test, 32-bit floating point calculations are intensively used - this is the accuracy of collision detection in a physical engine. <br><br><h2>  <font color="#0071c5">What we learned and did thanks to Icy Rocks</font> </h2><br>  During the experiments with Icy Rocks, we found that the physics engine JBox2D uses its own implementation of the methods of the standard library java.lang.Math.  It involves huge data structures to support the operation of the Math.sin () and Math.cos () functions.  We recommend making changes to the JBox2D code, using the standard java.lang.Math methods for optimal performance. <br><br>  In addition, it was found that JBox2D joins objects into a pool so that during program execution you do not waste time allocating memory for them and garbage collection.  This approach can degrade the performance of the garbage collector, cause heap fragmentation, worsen the locality of references to objects.  Our recommendation is to use the standard garbage collector, and not to pool objects.  We look forward to further improving the locality of the links and the garbage collector through the use of a memory allocation facility for objects, which is based on the Thread-Local Allocation Buffer (TLAB) in the near future. <br><br>  Thanks to Android research using Icy Rocks, Intel has contributed to the Android Open Source Project (AOSP) with several enhancements.  There have also been many optimizations in the Intel ART code. <br><br><h2>  <font color="#0071c5">Results: it's time for new tests</font> </h2><br>  We opened the <a href="https://android-review.googlesource.com/">code Icy Rocks</a> .  This is part of Intel's strategy to change the approach to measuring the performance of Android devices.  Existing synthetic performance tests, for the most part, have nothing to do with reality, do not reflect the features of these applications.  The data they give out may be distorted even more by optimization.  We, for example, recently "improved" in this way CFBench and Quadrant. <br><br>  We want to convince the Android community to abandon synthetic tests, far from reality and subject to manipulation, and replace them with more believable workloads.  Such as Icy Rocks. </div><p>Source: <a href="https://habr.com/ru/post/279061/">https://habr.com/ru/post/279061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279049/index.html">Checking the status of antivirus in the corporate network using VBScript</a></li>
<li><a href="../279051/index.html">Sieve called Adobe Flash</a></li>
<li><a href="../279053/index.html">PUE celebrates its 10th anniversary. What a sad gift has the IT community prepared for him?</a></li>
<li><a href="../279055/index.html">West Game Development Forum: Create, Share, Improve</a></li>
<li><a href="../279059/index.html">Svezhak for iOS developers - Digest MBLTdev</a></li>
<li><a href="../279063/index.html">Automatically update Firefox extensions</a></li>
<li><a href="../279067/index.html">How to create animations and transitions using Motion UI</a></li>
<li><a href="../279069/index.html">1.2 SFML and Code :: Blocks (MinGW)</a></li>
<li><a href="../279071/index.html">AlphaGo on the fingers</a></li>
<li><a href="../279073/index.html">Security Week 10: extortionist for OS X, iPhone passcode bypass, Facebook vulnerability and bug bounty benefits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>