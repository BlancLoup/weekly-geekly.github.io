<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Daily releases are not so scary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My name is Oksana Kharchuk, I work as a QA-engineer in DataArt for a little over a year. I'll tell you how the work process is organized in our projec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Daily releases are not so scary</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ae6/462/fb8/ae6462fb88d64cb48231da93e2f006f7.png"><br><br>  My name is Oksana Kharchuk, I work as a QA-engineer in DataArt for a little over a year.  I'll tell you how the work process is organized in our project, and how to be if the release is every day. <br><br>  At first, when I first came to DataArt, I associated the word ‚Äúrelease‚Äù with something scary.  But, as it turned out, if the work process is built correctly, releases even every day are not at all scary, but very convenient. To achieve this, the development process in our project is built on the principles of continuous delivery and continuous integration. . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <b>What is Continuous Delivery and Continuous Integration?</b> </h5><br><br>  Continuous delivery or continuous software delivery - a set of practices and principles aimed at building, testing and delivering software faster and more often.  Continuous delivery of quality code relies, in turn, on continuous integration. <br><br>  Continuous integration, or continuous integration, is the practice of software development, which is to perform frequent automated project builds to quickly identify and solve integration problems.  After all, it is clear: if several programmers work on different parts of the code, many difficulties arise when integrating these parts.  Continuous integration helps to cope with them. <br><a name="habracut"></a><br>  How does continuous integration work? <br><br><img src="https://habrastorage.org/files/7c7/49c/35e/7c749c35e3094cfabfb10ee9d3d23648.png"><br><br>  Developers download the source code from the repository, make any changes, and then send their changes back to the repository.  After that, the project builds automatically, tests are run and a report is sent that everything in the modified code is good, and it is saved. <br><br>  And here it is shown in detail what happens at the testing stage after saving the modified code: <br><br><img src="https://habrastorage.org/files/917/5d8/358/9175d8358792447ba9a7daac8ff35359.png"><br><br>  The first thing that runs is jar files, then <b>in parallel</b> : <br><ul><li>  war files; </li><li>  external services, </li><li>  integration tests; </li><li>  JS tests; </li><li>  static code analysis; </li><li>  tests with a database. </li></ul><br>  Then, <b>one after another</b> , the following actions are performed: validation build, build installation, deployment on a test environment and, finally, Selenium tests. <br><br>  I want to make a reservation that this is not happening in every project - this is just what the developers decided to do for themselves, to be sure that their changes did not break anything. <br><br>  This is how the process of continuous delivery is built.  It is also worth saying that the practice of continuous delivery should not be confused with the practice of continuous deployment.  The difference is that with continuous delivery, manual testing is present at a certain stage, and continuous deployment is performed fully automatically: <br><br><img src="https://habrastorage.org/files/a4c/fbd/dc4/a4cfbddc40784b1f890d8794ef640c5b.jpg"><br><br>  Here I am talking about the continuous delivery - further I will explain the essence of manual intervention in testing. <br><br><h5>  <b>Flexible development methodology</b> </h5><br><img src="https://habrastorage.org/files/939/83b/917/93983b917e274520b5b0910f8a393f75.png"><br><br>  In the project we use a flexible development methodology - Agile.  Flexible methodology involves the development of software cycles.  Each cycle represents a smaller version of the IT project: requirements analysis, planning, development, assembly, testing, deployment.  At the end of the iteration, the customer receives a ready-made version of the IT system, and, if necessary, further project priorities are revised.  Then the development cycle starts again.  The result is a solution that meets the requirements of the customer. <br><br><img src="https://habrastorage.org/files/e31/5cb/762/e315cb762310441c8040d8e71050312b.png"><br><br>  Although releases occur every day, this, of course, does not mean that we add new functionality every day.  When the development of new functionality occurs, we go through all the above mentioned stages.  At the same time, we have no time limit: if we develop a new functionality, it will not necessarily be done for two days, two weeks or a month - how much time is postponed for this project, so much time and the development process can last, and we need to take into account that does not immediately go to the finished version of the product. <br><br>  However, the following question arises: if the code is stored in the repository permanently and if we have continuous integration, how to hide the code that will implement the new not yet ready functionality?  This is done using the configuration flag, with which the developers hide the code that is responsible for the unprepared functionality (although, of course, there are also changes that cannot be hidden under the configuration flag). <br><br>  <b>The process of developing a new functional:</b> <br><br>  So, how do we develop new features?  First we get the requirements, after which the QA-team, having analyzed and clarified the requirements, begins to write test cases.  <b>At the same time</b> , the development process is underway.  After the developers, having given the go-ahead for testing, turn on the configuration flag on the test environment, QA-engineers begin functional testing.  While QA-engineers are testing and finding errors that developers fix, automators or the Selenium-team (as we call them), begin the process of automating test cases.  After functional testing, regression testing is performed. <br><br><img src="https://habrastorage.org/files/8d1/f52/883/8d1f52883b384e3bbaa0f703703d9ccd.png"><br><br><h5>  <b>Release process</b> </h5><br><br>  If all is well, the decision is made that the new functionality will go into production.  How it's done?  It's very simple: the developer commits the inclusion of the configuration flag, under which the new functionality was hidden.  After the commit, a new version of the product is deployed on a test environment with new functionality already available.  The developer makes the inclusion of the configuration flag just before the day when the release is assigned, so that the change is included in the new version of the application, the one that will be released to the production. <br><br>  So, after the flag is turned on, and our functionality is available on the test environment, acceptance tests are run.  The process of acceptance testing runs every night, regardless of whether we release new features or fixed bugs.  The test suite is run overnight twice to minimize random drops.  These acceptance tests cover all high-priority cases.  When the QA-team arrives in the morning, it looks at the night testing reports, and it happens that everything did not go smoothly: 1 - 2% of tests dropped or were not passed.  In order to make sure that these were just random drops or, conversely, that automated test cases revealed an error, the QA-team will manually go through these test cases. <br><br>  Then, if all is well, we report it to the customer, and we can release changes to the finished version of the product. <br><br>  After customer approval, our application is deployed on an intermediate environment, which is very similar to Prodovskiy, and acceptance testing is carried out here.  It is carried out by the QA-team, as well as by Selenium-tests - manual and automated testing takes place in parallel.  If everything went well, we inform the customer about it and release our version in production, where smoke testing is conducted.  This is the perfect scenario. <br><br>  What if there is a significant bug in the morning?  In this case, the release process stops until the error is corrected.  If it is possible to correct the error quickly (until the end of the day, for example), a new tag is cut off in this branch, and the same branch, but with a new tag, is released to the intermediate environment, and the release process is repeated again. <br><br>  Every night if the release is successful, the branch is cut off from the branch, i.e., our application branch, which is sent to production.  Until the cut is released, the new branch will not be released.  Of course, it happens that we do not have a release for three days - when a bug interferes or there are failures in the process of cutting a branch. <br><br>  Minor bugs are fixed for the next release.  This is the advantage of daily releases: if today you find a small mistake, you will quickly fix it, and tomorrow it will not be. <br><br>  In general, the release process is as follows: <br><br><ul><li>  View a report on the passage of automatic acceptance tests on the test environment. </li><li>  Run fallen and missed tests manually. </li><li>  Acceptance testing in the intermediate environment, which is most similar to Prodovskim. </li><li>  Smoke testing prodovskom environment. </li></ul><br><br>  Please note that the new functionality is not released on production every day, but this does not mean that there will be no release.  Will be!  The machine is running, the release process is debugged and happens every day.  If there is no new functionality, there are always fixes of existing bugs. <br><br>  <b>Role and Responsibilities of a QA Engineer</b> <br><br>  You might get the impression that everything is so automated in us that the QA engineer has nothing more to do.  But in fact, work is enough. <br><br><ul><li>  First, the clarification and analysis requirements.  This is done by QA-engineers - after all, when a project manager makes demands, a lot of things are often missed. </li><li>  Secondly, the assessment of the time spent on working with the project.  When a project manager asks how much time is needed to write test cases, functional testing, etc., you need to calculate all this. </li><li>  Thirdly, work with test documentation, writing test cases, compiling checklists and report bugs. </li><li>  Fourthly, functional, regression and cross-browser testing is carried out in our project (since we have a web application, and each browser has its own mistakes). </li><li>  Fifthly, QA-engineers are engaged in the support of the release: every morning the passing of the fallen night tests, as well as acceptance and smoke testing.  But this does not mean that the whole team is busy release.  The release is occupied by people who have less priority tasks - our team is self-organizing. </li></ul><br><br>  There is also a release coordinator - the person who is responsible for the release.  He prepares an error report for the customer and conducts negotiations with him.  From the customer‚Äôs side there is also a special person who communicates with our team. <br><br>  It is also worth telling what exactly the automators are doing in our project. <br><br>  <b>Role and responsibilities of the automator:</b> <br><br><ul><li>  Development of automated tests. </li><li>  Support existing automated tests so that they are relevant. </li><li>  Release support.  From the Selenium-team we also have a release coordinator who is directly responsible for the night tests and their support.  Thus, he is responsible for the release and can also communicate directly with the customer. </li><li>  Support regression testing. </li></ul><br><br><h5>  <b>Principles of continuous delivery</b> </h5><br><br>  Finally, I would like to talk about the main principles on which, in my opinion, the practice of continuous supply is based. <br><br><img src="https://habrastorage.org/files/2bd/7ed/c04/2bd7edc0404e41f48dad2c31e0504c16.png"><br><br>  1. The process of release and deployment should be repeatable and reliable.  Once a process is running, it can no longer be stopped - even if you do not release anything new. <br>  2. Automated tests should cover 80 - 90% of the functional - without this process will not work. <br>  3. It is necessary to take frequent tests on vulnerabilities.  If you see that in some place you often have tests or a lot of mistakes, you need to test this place more often and make sure that improvements occur and something is being corrected. <br>  4. Quality needs to be built right away.  This applies not only to developers, but also to testers.  It happens that QA-engineers check the bug reports on the local developers' machines in order to prevent non-fixed bugs from entering the common repository.  Then the developer fixes the error locally, it is much cheaper and faster. <br>  5. Everyone is responsible for the release.  Because of this, we have a well-established communication.  If QA-engineers have questions, we can calmly write to the developer, and the developer can also ask us about something. <br><br>  Despite the advantages, the concept of continuous supply has, of course, disadvantages.  This practice is not suitable for all projects - whether it will be possible to implement it depends on the project and on the team that deals with the project.  And for me the main disadvantage is the routine of the process.  Coming every day, we see the same application, we run tests and, naturally, we can miss something, because the vigilance is lost.  Therefore, we in the team try to break everything apart, and one person doesn‚Äôt do one thing for a long time - on different days a person can perform different tasks.  It brings variety to the process. <br><br>  The main advantage of continuous delivery is a satisfied customer, because he can get what he wants very quickly and have an income from it. </div><p>Source: <a href="https://habr.com/ru/post/276901/">https://habr.com/ru/post/276901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276891/index.html">Online course "Introduction to theoretical computer science" by Alexander Hanievich Shen</a></li>
<li><a href="../276893/index.html">Rocker Gestures and other new items in the weekly assembly Vivaldi 1.0.390.3</a></li>
<li><a href="../276895/index.html">Schizoid programming language of self-learning algorithms "Author"</a></li>
<li><a href="../276897/index.html">Remote debugging javascript with VS2015. Part 2</a></li>
<li><a href="../276899/index.html">Ryo CDR: another asterisk CDR viewer</a></li>
<li><a href="../276905/index.html">Go and Protocol Buffers, acceleration</a></li>
<li><a href="../276909/index.html">Microsoft will share information about Windows 10 updates</a></li>
<li><a href="../276913/index.html">Fallback actions in ES6 Promise</a></li>
<li><a href="../276915/index.html">Bypassing the DPI provider on the OpenWrt router using only busybox</a></li>
<li><a href="../276917/index.html">The court recognized "Mail.Ru" blogger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>