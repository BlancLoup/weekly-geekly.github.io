<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Maximum XOR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr. And immediately to the point. 
 Task: 
 There are two integers: L and R. It is necessary to find the maximum value of A xor B on the inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Maximum XOR</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr.  And immediately to the point. <br>  Task: <br>  <i>There are two integers: <b>L</b> and <b>R.</b></i>  <i>It is necessary to find the maximum value of <b>A</b> <a href="http://en.wikipedia.org/wiki/Exclusive_or">xor</a> <b>B</b> on the interval <b>[L;</b></i>  <i><b>R]</b> , where <b>L ‚â§ A ‚â§ B ‚â§ R.</b></i> <br>  It would seem nothing complicated.  Immediately begs the decision by simple brute force. <br><div class="spoiler">  <b class="spoiler_title">Expand</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BruteForce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> two</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxXor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (one &lt; two) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oneTemp = one + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (oneTemp &lt;= two) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curXor = one ^ oneTemp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxXor &lt; curXor) maxXor = curXor; oneTemp++; } one++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxXor; }</code> </pre> <br></div></div>  The complexity of this solution is O (n <sup>2</sup> ). <br>  And what if there are 1,000,000 numbers in the range.  Take L = 1, and R = 1000001. How long will the average computer take to calculate the maximum value of xor on this interval?  My laptop took 1699914 milliseconds. <br>  There is a solution that works much faster, it is about him that will be discussed in this article. <br><img src="https://habrastorage.org/files/8c1/1c9/dde/8c11c9dde9b94df598c4ddd300a34ca7.png" alt="image"><a name="habracut"></a><br><br><h5>  Main idea. </h5><br>  In order for the resulting number to be the largest, you need to get one from the function xor in the highest possible bit of this number.  And so on, in the direction of the youngest bat.  In other words, we will consistently work with each bit of the resulting number in the direction from the high bits to the low bits.  For this, it is very convenient to use a data structure called a <a href="http://en.wikipedia.org/wiki/Trie">trie-tree</a> ( <i>I like the way this data structure is described in R. Sagewick's book "Algorithms in Java"</i> ). <br><br>  Trie-trees are data structures that consist of nodes that contain references ‚Äî either null, or references to other nodes.  Only one other node points to each node (no node points to the root node).  Each node contains R references, where R is the size of the alphabet (in our case, R = 2, since the alphabet is 0 and 1).  As a rule, trie-trees contain a significant number of zero references, so they will be omitted from the pictures.  Each link corresponds to the next bit of the number.  Each integer is encoded as a path from the root to the leaf. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An example of an empty trie-tree. <br><img src="https://habrastorage.org/files/479/991/ef9/479991ef9e1a4b5dbcebd5fc10aa39f9.png" alt="image"><br>  This is how a trie-tree looks after adding 0, 1, 2, 3, 4, 5, 6, 7. <br><img src="https://habrastorage.org/files/2e1/096/34d/2e109634ddff47a08d47d6340c380362.png" alt="image"><br>  In the figure, the path consisting of 3 references is highlighted - <i>0 -&gt; 1-&gt; 1</i> (011 is the binary representation of the number 3). <br><br>  I just want to clarify that we will work only with 32-bit numbers, and the high-order bits will be filled with zeros if necessary.  With this we achieve that the numbers will be stored in arrays with the same length.  I decided to store the binary representation of integers in an array of type bool. <br><img src="https://habrastorage.org/files/f85/3f3/a87/f853f3a87e8c4b10b2278e65f5229b9e.png" alt="image"><br>  Each node stores an array of links to other nodes in the tree (2 links, one for each possible value of a bit number). <br><img src="https://habrastorage.org/files/1b4/8a7/8a7/1b48a78a74dc4f00aaa7e09d343afc7f.png" alt="image"><br>  In general, a trie-tree is a data structure built from characters of string keys that allows you to use characters from the search key to control the search.  String keys can be of different lengths; therefore, each node of the tree additionally stores a value, which can be a zero or real value associated with one of the string keys.  In our case, we don‚Äôt have to store the value, since the keys are whole 32-bit numbers stored in binary form in arrays of the same length.  So, trie-tree: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MaxXor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Trie</span></span> { <span class="hljs-comment"><span class="hljs-comment">//for integer representation in binary system 2^32 public static readonly int MaxLengthOfBits = 32; //size of alphabet public static readonly int N = 2; class Node { public Node[] next = new Node[Trie.N]; } private Node _root; } }</span></span></code> </pre><br><br>  First, we need the functions of converting numbers from decimal to binary and vice versa.  It's all very clear and simple.  If you need to refresh your memory, you can peep. <br><br><div class="spoiler">  <b class="spoiler_title">ConvertDecimalToBInary</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertDecimalToBInary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = Trie.MaxLengthOfBits; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[counter]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (number &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { result[--counter] = Convert.ToBoolean(number % <span class="hljs-number"><span class="hljs-number">2</span></span>); number /= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">ConvertBinaryToDecimal</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertBinaryToDecimal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] bits</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> base_val = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = bits.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { result += Convert.ToInt32(bits[i]) * base_val; base_val *= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br>  Secondly, we need the function of adding an integer to a trie-tree.  Here we will stop in more detail.  To insert into a trie-tree, you first need to search for the desired node.  The search starts with the root, and then follows the link associated with the zero (most significant) bit of the number;  from this node follows the link associated with the first bit of the number;  from there - by the link associated with the second bit of the number;  etc., that is, you just need to view the nodes along the path from the root to some node in the trie-tree.  The number bits are used to descend the tree until the last bit or zero reference is reached.  If a zero reference is found before sampling the last bit of a number, i.e.  in the trie-tree there is no node corresponding to the last bit of the number, it is necessary to create nodes for each of the missing bits. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] binaryNumber</span></span></span><span class="hljs-function">)</span></span> { _root = AddValue(_root, binaryNumber, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Node node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(); <span class="hljs-comment"><span class="hljs-comment">//if least sagnificient bit has been added //need return if (d == val.Length) { return node; } // get 0 or 1 index of next array(length 2) int index = Convert.ToInt32(val[d]); node.next[index] = AddValue(node.next[index], val, ++d); return node; }</span></span></code> </pre> <br>  Now we will build a trie-tree, adding all the numbers from the given interval. <br><br>  Update: As <a href="http://habrahabr.ru/users/freopen/" class="user_link">freopen has</a> rightly noticed, <blockquote>  it is enough to find the very first bit, which is different, nothing can be done with the bits above; </blockquote>  So, we find the very first bit, which is different, for this we will move from the root of the links until we meet a node that has both links.  Then all the bits below are made in units.  As a result, we get the result. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMaxXor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[Trie.MaxLengthOfBits]; Node cur = _root; <span class="hljs-comment"><span class="hljs-comment">//find index the most significant bit, which is different int index; for (index = 0; index &lt; Trie.MaxLengthOfBits; index++) { //are bits differ? if (cur.next[0] != null &amp;&amp; cur.next[1] != null) { //the most significant bit, which is different result[index] = true; break; } //descent down the tree cur = cur.next[0] ?? cur.next[1]; } //all the bits below do 1 while (index &lt; Trie.MaxLengthOfBits) { result[index] = true; index++; } return result; }</span></span></code> </pre><br>  Significant simplification of the code, but the complexity remains the same!  The archive with the updated project solution can be downloaded <a href="">here</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Old version</b> <div class="spoiler_text"><br>  We turn to the most important thing.  To find the maximum value of xor, we will move along the trie-tree from the root of the links, that is, we will work with bits in the direction from older to younger ones.  And we can be both in one node, and in different.  During each pass, we will try to get a unit, if possible, from the xor of the next bits of numbers, and so on, until we get all 32 bits.  The resulting 32 bits - this is the maximum value of xor in our gap. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMaxXor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[Trie.MaxLengthOfBits]; Node oneNode = _root, twoNode = _root; <span class="hljs-comment"><span class="hljs-comment">//for each bit from most significant bit to least significant bit for (int i = 0; i &lt; Trie.MaxLengthOfBits; i++) { //getting current bit result[i] = GetBit(oneNode, twoNode); //go to next nodes UpdateNodes(ref oneNode, ref twoNode); } return result; } //we need update nodes after each iteration //we can stay on single node or split on two nodes private void UpdateNodes(ref Node one, ref Node two) { if (one.Equals(two)) { if (one.next[1] != null &amp;&amp; one.next[0] != null) { two = one.next[1]; one = one.next[0]; } else { one = two = ((one.next[1] != null) ? one.next[1] : one.next[0]); } } else { if (one.next[1] != null &amp;&amp; two.next[0] != null) { one = one.next[1]; two = two.next[0]; } else if (one.next[0] != null &amp;&amp; one.next[1] == null) { one = one.next[0]; two = two.next[1]; } else { one = one.next[1] ?? one.next[0]; two = two.next[1] ?? two.next[0]; } } } //if it's possible, we will try to get one. private bool GetBit(Node one, Node two) { if (one.Equals(two)) { // 0 xor 1 == 1; 1 xor 0 == 1 if (one.next[0] != null &amp;&amp; one.next[1] != null) return true; // 0 xor 0 == 0; 1 xor 1 == 0 else return false; } else { if ((one.next[1] != null &amp;&amp; two.next[0] != null) || // 1 xor 0 == 1 (one.next[0] != null &amp;&amp; one.next[1] == null)) // 0 xor 1 == 1 { return true; } else {// 0 xor 0 == 0; 1 xor 1 == 0 return false; } } }</span></span></code> </pre><br>  Example for 3-bit numbers <br><img src="http://habrastorage.org/files/759/d4a/1f3/759d4a1f3f3843d5bb0259ec38a3117e.png" alt="image"><br>  The archive with the project solution can be downloaded <a href="">here</a> . <br></div></div><br>  Now, we can compare the time of each of the approaches for intervals of different lengths. <br><br><img src="http://habrastorage.org/files/de0/a63/cc6/de0a63cc62774e148c753ca418372c65.png" alt="image"><br>  As can be seen from the table, the calculation of the maximum value of xor using a trie-tree works much faster.  Estimate of the complexity of the algorithm O (nlogn). <br><br>  PS To solve this problem, and in general for storing integers in binary form, you can slightly simplify our trie-tree.  Since the alphabet consists of only 2 characters, you can get rid of the array and store just two links, for example <i>Node left</i> and <i>Node right</i> , which are representations of 0 and 1, respectively. </div><p>Source: <a href="https://habr.com/ru/post/245801/">https://habr.com/ru/post/245801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245787/index.html">DigitalOcean announced data center in Germany</a></li>
<li><a href="../245789/index.html">The digest of interesting materials for mobile developer # 83 (December 8-14)</a></li>
<li><a href="../245791/index.html">Step by step instructions: a pledge for transactions in bitcoin</a></li>
<li><a href="../245795/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ26 (December 8 - 14, 2014)</a></li>
<li><a href="../245797/index.html">Category Theory for Programmers: Preface</a></li>
<li><a href="../245805/index.html">Free SMS sending from Arduino without GSM module</a></li>
<li><a href="../245807/index.html">C ++ Russia Conference in Moscow</a></li>
<li><a href="../245809/index.html">Experience creating a home Wi-Fi router. Part 2. Installing and configuring software</a></li>
<li><a href="../245811/index.html">New release and features: 3CX Phone System 12.5 Release Candidate</a></li>
<li><a href="../245817/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ138 (December 8 - 14, 2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>