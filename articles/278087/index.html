<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DIY: SQL JOIN in Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I often interview the developers and often ask them a simple, like a sledgehammer, question - how does the JOIN work in SQL inside? In response, I usu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DIY: SQL JOIN in Java</h1><div class="post__text post__text-html js-mediator-article">  I often interview the developers and often ask them a simple, like a sledgehammer, question - how does the JOIN work in SQL inside?  In response, I usually hear an <a href="http://feldgendler.livejournal.com/155234.html">incoherent moo</a> about magic trees and indexes that are faster.  Once it seemed to me that every specialist <s>programmer</s> should know what he is working with.  Subsequently, life explained to me that this is not so.  But I still don‚Äôt understand how I can pull the <abbr title="small database">bazonok for</abbr> years <abbr title="small database">without</abbr> even realizing, but what is there under her hood? <br><br>  Let's spend an educational program and together we will look, how these <abbr title="in Russian correct 'connection', but I deliberately use jargon">joins work</abbr> , and even we realize a couple of algorithms. <br><br><img src="https://habrastorage.org/files/7ff/b2c/3a2/7ffb2c3a25b74dcf9eec013282b9cfb4.png" alt="SQL JOIN"><br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br>  For people who claim that they worked a lot with SQL, I ask this kind of task during interviews. <br>  There is a SQL command <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> left.K, left.V1, right.V2 <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> left.K = right.K;</code> </pre> <br>  You need to do the same in Java, i.e.  implement method <br><pre> <code class="java hljs">&lt;K, V1, V2&gt; List&lt;Triple&lt;K, V1, V2&gt;&gt; join(List&lt;Pair&lt;K, V1&gt;&gt; left, List&lt;Pair&lt;K, V2&gt;&gt; right);</code> </pre><br>  I am not asking you to directly code the implementation, but I am waiting for at least a verbal explanation of the algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Additionally, I ask what needs to be changed in the signature and implementation to pretend that we are working with indexes. <br><br>  Let's first understand, why should we even think about joining devices? <br><ol><li>  Knowing the theory is useful for purely cognitive reasons. </li><li>  If you distinguish between types of joins, then the query execution plan, which is obtained by the EXPLAIN command, no longer looks to you as a collection of incomprehensible English words.  You can see potentially slow spots in the plan and optimize the query by rewriting or hinting. </li><li>  In modern analytic tools on top of Hadoop, the query scheduler is a bit stupid (see Cloudera Impala), or there is none at all (see Twitter Scalding, Spark RDD).  In the latter case, you have to collect the request manually from primitive operations. </li><li>  <s>Finally, there is a risk that one day you will get an interview with me or another bore.</s>  But in fact, the article is not about interviews, but about the JOIN operation. </li></ol><br><br><h2>  Nested loops join </h2><br>  The most basic algorithm for combining two lists is now taking place in schools.  The point is very simple - for each element of the first list, go through all the elements of the second list;  if the keys of the elements suddenly turned out to be equal, we write the coincidence in the resulting table.  To implement this algorithm, two nested loops are sufficient, which is why it is called this. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;K, V1, V2&gt; List&lt;Triple&lt;K, V1, V2&gt;&gt; nestedLoopsJoin(List&lt;Pair&lt;K, V1&gt;&gt; left, List&lt;Pair&lt;K, V2&gt;&gt; right) { List&lt;Triple&lt;K, V1, V2&gt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Pair&lt;K, V1&gt; leftPair: left) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Pair&lt;K, V2&gt; rightPair: right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Objects.equals(leftPair.k, rightPair.k)) { result.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triple&lt;&gt;(leftPair.k, leftPair.v, rightPair.v)); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  The main advantage of this method is complete indifference to the input data.  The algorithm works for any two tables, does not require any indexes and data shifting in memory, and is also simple to implement.  In practice, this means that it is enough just to run on the disk with two cursors and periodically spit out matches in the socket. <br><br>  However, the fatal minus of the algorithm is the high time complexity of O (N * M) (quadratic asymptotics, if you know what I mean).  For example, for a pair of small tables with 100k and 500k records, you need to do as many as 100.000 * 500.000 = 50.000.000.000 (50 billion) comparison operations.  Requests with such a joyno will be performed impolitely for a long time, often they are the cause of the merciless brakes of self-signed CMS logs. <br><br>  Modern RDBMS use nested loops join in the most hopeless cases when it is not possible to apply any optimization. <br><br>  UPD.  <a href="https://habrahabr.ru/users/zhekappp/" class="user_link">zhekappp</a> and <a href="https://habrahabr.ru/users/potapuff/" class="user_link">potapuff</a> correct that nested loops are effective for a small number of lines, when deploying any optimization is more expensive than just running through a nested loop.  There is a class of systems for which this is relevant. <br><br><h2>  Hash join </h2><br>  If the size of one of the tables allows you to shove it entirely into memory, then you can make a <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">hash table</a> based on it and quickly search for the necessary keys in it.  Let's talk a little more. <br><br>  Check the size of both lists.  Take the smaller of the lists, read it fully and load it into memory by building a HashMap.  Now back to the larger list and move the cursor over it from the beginning.  For each key, check to see if it is the same in the hash table.  If there is - write a match in the resulting table. <br><br>  The time complexity of this algorithm falls to linear O (N + M), but additional memory is required. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;K, V1, V2&gt; List&lt;Triple&lt;K, V1, V2&gt;&gt; hashJoin(List&lt;Pair&lt;K, V1&gt;&gt; left, List&lt;Pair&lt;K, V2&gt;&gt; right) { Map&lt;K, V2&gt; hash = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(right.size()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Pair&lt;K, V2&gt; rightPair: right) { hash.put(rightPair.k, rightPair.v); } List&lt;Triple&lt;K, V1, V2&gt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Pair&lt;K, V1&gt; leftPair: left) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.containsKey(leftPair.k)) { result.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triple&lt;&gt;(leftPair.k, leftPair.v, hash.get(leftPair.k))); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  What is important, at the time of dinosaurs, it was believed that the right table should be loaded into memory, and iterated on the left.  Normal RDBMS now has cardinality statistics, and they themselves determine the join order, but if for some reason the statistics is not available, then the right table is loaded into memory.  This is important to remember when working with young clumsy tools like Cloudera Impala. <br><br><h2>  Merge join </h2><br>  Now imagine that the data in both lists are pre-sorted, for example, in ascending order.  This happens if we had indexes on these tables, or if we sorted the data in the previous stages of the query.  As you probably remember, two sorted lists can be glued together into one sorted for linear time - this is the basis of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC">merge sort</a> algorithm.  Here we have a similar task, but instead of sticking lists, we will look for common elements in them. <br><br>  So, put the cursor on the top of both lists.  If the keys under the cursors are equal, write the match in the resulting table.  If not, we look under which of the cursors the key is smaller.  Move the cursor over the smaller key one forward, thereby ‚Äúcatching up‚Äù with another cursor. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;K extends Comparable&lt;K&gt;, V1, V2&gt; List&lt;Triple&lt;K, V1, V2&gt;&gt; mergeJoin( List&lt;Pair&lt;K, V1&gt;&gt; left, List&lt;Pair&lt;K, V2&gt;&gt; right ) { List&lt;Triple&lt;K, V1, V2&gt;&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Iterator&lt;Pair&lt;K, V1&gt;&gt; leftIter = left.listIterator(); Iterator&lt;Pair&lt;K, V2&gt;&gt; rightIter = right.listIterator(); Pair&lt;K, V1&gt; leftPair = leftIter.next(); Pair&lt;K, V2&gt; rightPair = rightIter.next(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare = leftPair.k.compareTo(rightPair.k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftIter.hasNext()) { leftPair = leftIter.next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightIter.hasNext()) { rightPair = rightIter.next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triple&lt;&gt;(leftPair.k, leftPair.v, rightPair.v)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftIter.hasNext() &amp;&amp; rightIter.hasNext()) { leftPair = leftIter.next(); rightPair = rightIter.next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  If the data is sorted, then the time complexity of the algorithm is linear O (M + N) and no additional memory is required.  If the data is not sorted, you must first sort it.  Because of this, the time complexity increases to O (M log M + N log N), plus additional memory requirements appear. <br><br><h2>  Outer joins </h2><br>  You may have noticed that the code written above simulates only INNER JOIN, and it counts that all the keys in both lists are unique, i.e.  occur no more than once.  I did so specifically for two reasons.  Firstly, it is more obvious - the code contains only the logic of the joins themselves and nothing superfluous.  And secondly, I really wanted to sleep.  But nevertheless, let's at least discuss what needs to be changed in the code to support different types of joins and non-unique key values. <br><br>  The first problem is non-unique, i.e.  duplicate keys  For duplicate keys, you need to generate a Cartesian product of all the corresponding values. <br>  In Nested Loops Join for some reason it works right away. <br>  In Hash Join you have to replace HashMap with MultiHashMap. <br>  For Merge Join, the situation is much more sad - you have to remember how many elements with the same key we saw. <br><br>  Working with non-unique keys increases the asymptotics to O (N * m + M * n), where n and m is the average of records per key in the tables.  In the degenerate case, when n = N and m = M, the operation turns into a CROSS JOIN. <br><br>  The second problem - you need to keep track of the keys for which there was no pair. <br>  For Merge Join, a key without a pair is visible at once for all JOIN directions. <br>  For Hash Join, you can immediately see the lack of corresponding keys with the join on the left.  In order to fix unpaired keys on the right, you will have to set up a separate ‚Äúthere is a pair!‚Äù Flag for each element of the hash table.  After the main join is complete, you will have to go through the entire hash table and add keys without the pair flag to the result. <br><br>  For Nested Loops Join, the situation is similar, and everything is so simple that I even mastered this code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static &lt;K, V1, V2&gt; List&lt;Triple&lt;K, V1, V2&gt;&gt; nestedLoopsJoin( List&lt;Pair&lt;K, V1&gt;&gt; left, List&lt;Pair&lt;K, V2&gt;&gt; right, JoinType joinType ) { //       ,       BitSet rightMatches = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> BitSet(right.size()); List&lt;Triple&lt;K, V1, V2&gt;&gt; result = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Pair&lt;K, V1&gt; leftPair: left) { //       ,       <span class="hljs-type"><span class="hljs-type">boolean</span></span> match = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ListIterator&lt;Pair&lt;K, V2&gt;&gt; iterator = right.listIterator(); iterator.hasNext(); ) { Pair&lt;K, V2&gt; rightPair = iterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Objects.equals(leftPair.k, rightPair.k)) { result.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Triple&lt;&gt;(leftPair.k, leftPair.v, rightPair.v)); //   match = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; rightMatches.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(iterator.previousIndex(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } } //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((joinType == JoinType.LEFT || joinType == JoinType.<span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span>) &amp;&amp; !match) { result.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Triple&lt;&gt;(leftPair.k, leftPair.v, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); } } //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (joinType == JoinType.RIGHT || joinType == JoinType.<span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; right.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rightMatches.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) { Pair&lt;K, V2&gt; rightPair = right.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i); result.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Triple&lt;&gt;(rightPair.k, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, rightPair.v)); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br><h2>  Moralizing afterword </h2><br>  If you read this far, it means that the article seemed interesting to you.  So, you forgive me a small portion of moralizing. <br><br>  I really believe that knowledge of the RDBMS at the SQL level is absolutely not enough to consider myself a professional software developer.  A professional should know not only his code, but also an exemplary arrangement of stack neighbors, i.e.  3rd-party systems he uses - databases, frameworks, network protocols, file systems.  Without this, the developer degenerates to a coder or computer operator, and in truly complex, large-scale tasks, it becomes useless. <br><br>  UPD.  Despite this afterword, the article is, in fact, about JOINs. <br><br><h2>  Additional materials </h2><br><ul><li>  Luxurious article about <a href="https://habrahabr.ru/company/mailru/blog/266811/">device RDBMS</a> </li><li>  Luxury book about <a href="https://www.ozon.ru/context/detail/id/33769775/">algorithms</a> .  It is useful to look through before the interview. </li></ul><br><br>  Disclaimer: Actually, I promised another article about Scalding, but the <a href="https://habrahabr.ru/post/273611/">previous one</a> did not arouse much interest from the public.  Because of this, the topic was decided to change. </div><p>Source: <a href="https://habr.com/ru/post/278087/">https://habr.com/ru/post/278087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278071/index.html">Citrix Tech Exchange Moscow 2016: how it changed my attitude to Xen</a></li>
<li><a href="../278073/index.html">[ScanDoc] preprocessing scans</a></li>
<li><a href="../278075/index.html">How I reinvented dictionaries in Python</a></li>
<li><a href="../278083/index.html">Docker-compose switch to version 2</a></li>
<li><a href="../278085/index.html">Consul.io Part 1</a></li>
<li><a href="../278089/index.html">How does split-testing in Badoo work?</a></li>
<li><a href="../278091/index.html">Funny tabs on MAC OS X or a story about that Tab View</a></li>
<li><a href="../278095/index.html">How board and various other games are balanced - a brief overview of the ways</a></li>
<li><a href="../278099/index.html">The digest of interesting materials for the mobile developer # 142 (February 24-28)</a></li>
<li><a href="../278101/index.html">Consul.io Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>