<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive JavaScript: Higher Order Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive JavaScript: Higher Order Functions</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>Tsu-li and Tsu-su boasted the size of their new programs.</i>  <i>"Two hundred thousand lines," said Tsu-li, "not counting the comments!" Tsu-su answered: "Pf-f, mine is almost a million lines."</i>  <i>Master Yun-Ma said: "My best program takes five hundred lines."</i>  <i>Hearing this, Tsu-li and Tsu-su experienced enlightenment.</i> <i><br><br></i>  <i>Master Yun-Ma, Programming Book</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>There are two ways to build programs: make them so simple that there will obviously be no errors, or so complex that there will not be obvious errors.</i> <i><br><br></i>  <i>Anthony Hoare, 1980 lecture at the Turing Award</i> <i><br></i> <br><br>  A large program is an expensive program, and not only because of the time it was written.  Large size usually means complexity, and complexity confuses programmers.  Confused programmers make program errors.  A large program means that bugs have a place to hide and they are harder to find. <br><a name="habracut"></a><br>  Let us briefly return to the two examples from the introduction.  The first is self-sufficient, and takes six lines. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>) { total += count; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(total);</code> </pre> <br><br>  The second is based on two external functions and occupies one line. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)));</code> </pre><br><br>  Which one of them will most likely encounter an error? <br><br>  If we add the size of the sum and range definitions, the second program will also be large ‚Äî more than the first.  But I still say that it is likely to be correct. <br><br>  This will be because the decision expression is directly related to the problem being solved.  The summation of a numeric gap is not cycles and counters.  These are sums and gaps. <br><br>  The definitions of this dictionary (functions sum and range) will include cycles, counters, and other random details.  But because they express simpler concepts than the entire program, they are easier to do correctly. <br><br><h4>  Abstractions </h4><br>  In the software context, these ‚Äúdictionary‚Äù definitions are often called abstractions.  Abstractions hide the details and give us the opportunity to talk about tasks at a higher or more abstract level. <br><br>  Compare two pea soup recipes: <br><br>  <i>Add one cup of dry peas per serving to the container.</i>  <i>Add water so that it covers the peas.</i>  <i>Leave it that way for at least 12 hours.</i>  <i>Remove the peas from the water and place them in the pan.</i>  <i>Add 4 cups of water per serving.</i>  <i>Close the pan and simmer the peas for two hours.</i>  <i>Take half a bulb per serving.</i>  <i>Cut into pieces with a knife, add to peas.</i>  <i>Take one stalk of celery one by one.</i>  <i>Cut into pieces with a knife, add to peas.</i>  <i>Take a carrot for a portion.</i>  <i>Cut into pieces with a knife, add to peas.</i>  <i>Cook for another 10 minutes.</i> <br><br>  Second recipe: <br><br>  <i>Per serving: 1 cup of dry peas, half an onion, celery stalk, carrot.</i> <i><br></i>  <i>Soak peas for 12 hours.</i>  <i>Stew 2 hours in 4 cups of water per serving.</i>  <i>Cut and add vegetables.</i>  <i>Cook for another 10 minutes.</i> <br><br>  The second is shorter and simpler.  But you need to know a little more concepts related to cooking - soaking, stewing, cutting (and vegetables). <br><br>  Programming, we can not expect that all the necessary words will be in our dictionary.  Because of this, you can slide down to the first-recipe template: dictating the computer all the small steps one after another, without noticing the higher-level concepts that they express. <br><br>  The second kind of programmer should be the ability to notice when a concept begs for a new word for it and brought into abstraction. <br><br><h4>  Abstracting array traversal </h4><br>  Simple functions that we used before are good for building abstractions.  But sometimes they are not enough. <br><br>  In the previous chapter, we encountered the following cycle several times: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = array[i]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(current); }</code> </pre><br><br>  The code tries to say: ‚Äúfor each element in the array, output it to the console‚Äù.  But it uses a workaround ‚Äî with a variable to calculate i, checking the length of the array, and declaring the additional variable current.  Not only is he not very handsome, he is also the ground for potential mistakes.  We can accidentally reuse the variable i, instead of length write lenght, confuse the variables i and current, etc. <br><br>  Let's abstract it into a function.  Can you think of a way to do this? <br><br>  It's pretty easy to write a function, traversing an array and calling for each console.log element. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logEach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(array[i]); }</code> </pre><br><br>  But what if we need to do something different than output elements to the console?  Since ‚Äúdoing something‚Äù can be represented as a function, and functions are just variables, we can pass this action as an argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) action(array[i]); } forEach([<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  // ‚Üí  // ‚Üí </span></span></code> </pre><br><br>  Often you can not transfer a predefined function in forEach, but create a function on the spot. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; forEach(numbers, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function">) </span></span>{ sum += number; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 15</span></span></code> </pre><br><br>  It looks like a classic for loop, with the body of a loop written in a block.  However, the body is now inside the function, and also inside the forEach call brackets.  Therefore, it must be closed with both curly and parentheses. <br><br>  Using this template, we can set the variable name for the current element of the array (number), without having to manually select it from the array. <br><br>  In general, we do not even need to write forEach.  This is the standard array method.  Since the array is already passed as a variable on which we are working, forEach takes only one argument ‚Äî a function that needs to be executed for each element. <br><br>  To demonstrate the convenience of this approach, let us return to the function from the previous chapter.  It contains two loops running through the arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gatherCorrelations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">journal</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phis = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entry = <span class="hljs-number"><span class="hljs-number">0</span></span>; entry &lt; journal.length; entry++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events = journal[entry].events; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; events.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> event = events[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> phis)) phis[event] = phi(tableFor(event, journal)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phis; }</code> </pre><br><br>  Using forEach we record slightly shorter and much cleaner. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gatherCorrelations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">journal</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phis = {}; journal.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">entry</span></span></span><span class="hljs-function">) </span></span>{ entry.events.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> phis)) phis[event] = phi(tableFor(event, journal)); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> phis; }</code> </pre><br><br><h4>  Higher order functions </h4><br>  Functions that operate on other functions ‚Äî either taking them as arguments or returning them ‚Äî are called <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B2%25D1%258B%25D1%2581%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D0%25BF%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BA%25D0%25B0">higher order functions</a> .  If you already understand that functions are just variables, there is nothing special about the existence of such functions.  The term originates from mathematics, where differences between functions and other meanings are perceived more strictly. <br><br>  Higher-order functions allow us to abstract actions, not just values.  They are different.  For example, you can make a function that creates new functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greaterThan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt; n; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greaterThan10 = greaterThan(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greaterThan10(<span class="hljs-number"><span class="hljs-number">11</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true</span></span></code> </pre><br><br>  You can make a function that changes other functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noisy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"calling with"</span></span>, arg); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = f(arg); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"called with"</span></span>, arg, <span class="hljs-string"><span class="hljs-string">"- got"</span></span>, val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }; } noisy(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>)(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí calling with 0 // ‚Üí called with 0 - got false</span></span></code> </pre><br><br>  You can even make functions that create new types of flow control. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unless</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">test, then</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!test) then(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">times, body</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; times; i++) body(i); } repeat(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ unless(n % <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(n, <span class="hljs-string"><span class="hljs-string">"is even"</span></span>); }); }); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 0 is even // ‚Üí 2 is even</span></span></code> </pre><br><br>  The rules of lexical scopes that we discussed in Chapter 3 work for our benefit in such cases.  In the last example, the variable n is the argument of the external function.  Since the inner function lives in the outer environment, it can use n.  The bodies of such internal functions have access to the variables surrounding them.  They can play the role of {} blocks used in ordinary cycles and conditional expressions.  An important difference is that variables declared inside internal functions do not fall into the external environment.  And usually this is only for the better. <br><br><h4>  Passing arguments </h4><br>  The noisy function, previously declared, which passes its argument to another function, is not quite convenient. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noisy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"calling with"</span></span>, arg); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = f(arg); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"called with"</span></span>, arg, <span class="hljs-string"><span class="hljs-string">"- got"</span></span>, val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }; }</code> </pre><br><br>  If f takes more than one parameter, it only gets the first one.  It would be possible to add a bunch of arguments to the inner function (arg1, arg2, etc.) and pass all of them to f, but you don‚Äôt know how much is enough for us.  In addition, the f function could not work correctly with arguments.length.  Since we would always pass the same number of arguments, it would not be known how many arguments we were given initially. <br><br>  For such cases, functions in JavaScript have a apply method.  An array is passed to it (or an object in the form of an array) from the arguments, and it calls a function with these arguments. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transparentWrapping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; }</code> </pre><br><br>  This function is useless, but it demonstrates the pattern of interest to us ‚Äî the function it returns returns to f all its arguments, but nothing more.  This happens by passing its own arguments, which are stored in the arguments object, to the apply method.  The first argument of the apply method, which we assign null to in this case, can be used to emulate a method call.  We will return to this issue in the next chapter. <br><br><h4>  Json </h4><br>  Higher-order functions that somehow apply a function to array elements are widely distributed in JavaScript.  The forEach method is one of the most primitive similar functions.  As array methods, we have many other functions available.  To get to know them, let's play with a different set of data. <br><br>  Several years ago, someone examined a lot of archives and made a whole book on the history of my last name.  I opened it, hoping to find there knights, pirates and alchemists ... But it turned out that it was filled mainly with Flemish farmers.  For fun, I extracted information on my immediate ancestors and designed it in a format suitable for reading by a computer. <br><br>  The file looks like this: <br><br><pre> <code class="javascript hljs">[ {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Emma de Milliano"</span></span>, <span class="hljs-string"><span class="hljs-string">"sex"</span></span>: <span class="hljs-string"><span class="hljs-string">"f"</span></span>, <span class="hljs-string"><span class="hljs-string">"born"</span></span>: <span class="hljs-number"><span class="hljs-number">1876</span></span>, <span class="hljs-string"><span class="hljs-string">"died"</span></span>: <span class="hljs-number"><span class="hljs-number">1956</span></span>, <span class="hljs-string"><span class="hljs-string">"father"</span></span>: <span class="hljs-string"><span class="hljs-string">"Petrus de Milliano"</span></span>, <span class="hljs-string"><span class="hljs-string">"mother"</span></span>: <span class="hljs-string"><span class="hljs-string">"Sophia van Damme"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Carolus Haverbeke"</span></span>, <span class="hljs-string"><span class="hljs-string">"sex"</span></span>: <span class="hljs-string"><span class="hljs-string">"m"</span></span>, <span class="hljs-string"><span class="hljs-string">"born"</span></span>: <span class="hljs-number"><span class="hljs-number">1832</span></span>, <span class="hljs-string"><span class="hljs-string">"died"</span></span>: <span class="hljs-number"><span class="hljs-number">1905</span></span>, <span class="hljs-string"><span class="hljs-string">"father"</span></span>: <span class="hljs-string"><span class="hljs-string">"Carel Haverbeke"</span></span>, <span class="hljs-string"><span class="hljs-string">"mother"</span></span>: <span class="hljs-string"><span class="hljs-string">"Maria van Brussel"</span></span>}, ‚Ä¶    ]</code> </pre><br><br>  This format is called JSON, which means JavaScript Object Notation (markup of JavaScript objects).  It is widely used in data storage and network communications. <br><br>  JSON is similar to JavaScript in its way of writing arrays and objects ‚Äî with some limitations.  All property names must be enclosed in double quotes, and only simple values ‚Äã‚Äãare allowed - no function calls, variables, nothing that would include calculations.  Also comments are not allowed. <br><br>  JavaScript provides JSON.stringify and JSON.parse functions that convert data from and to this format.  The first one takes a value and returns a string with JSON.  The second accepts such line and returns value. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> string = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"X"</span></span>, <span class="hljs-attr"><span class="hljs-attr">born</span></span>: <span class="hljs-number"><span class="hljs-number">1980</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(string); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {"name":"X","born":1980} console.log(JSON.parse(string).born); // ‚Üí 1980</span></span></code> </pre><br><br>  The variable ANCESTRY_FILE <a href="">is available here</a> .  It contains the JSON file as a string.  Let's decode it and count the number of people mentioned. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ancestry = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(ANCESTRY_FILE); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ancestry.length); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 39</span></span></code> </pre><br><br><h4>  We filter an array </h4><br>  To find people who were young in 1924, the following function may be useful.  It filters out the elements of the array that are not tested. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, test</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passed = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (test(array[i])) passed.push(array[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> passed; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filter(ancestry, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person.born &gt; <span class="hljs-number"><span class="hljs-number">1900</span></span> &amp;&amp; person.born &lt; <span class="hljs-number"><span class="hljs-number">1925</span></span>; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [{name: "Philibert Haverbeke", ‚Ä¶}, ‚Ä¶]</span></span></code> </pre><br><br>  An argument named test is used - this is a function that performs computation checks.  It is called for each element, and the value returned by it determines whether the element is in the returned array. <br><br>  The file turned out to be three people who were young in 1924 ‚Äî a grandfather, grandmother, and great-aunt. <br><br>  Please note - the filter function does not remove elements from an existing array, but builds a new one that contains only validated elements.  This is a pure function, because it does not spoil the array passed to it. <br><br>  Like forEach, filter is one of the standard array methods.  In the example we described such a function, only to show what it does inside.  From now on we will use it simply: <br><br><pre> <code class="javascript hljs">onsole.log(ancestry.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person.father == <span class="hljs-string"><span class="hljs-string">"Carel Haverbeke"</span></span>; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [{name: "Carolus Haverbeke", ‚Ä¶}]</span></span></code> </pre><br><br><h4>  Transformations with map </h4><br>  Suppose we have an archive of objects representing people, which was obtained by filtering an array of ancestors.  But we need an array of names that would be easier to read. <br><br>  The map method converts an array by applying a function to all its elements and constructing a new array of return values.  The new array will have the same length as the input, but its contents will be converted to the new format. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, transform</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mapped = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) mapped.push(transform(array[i])); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapped; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overNinety = ancestry.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person.died - person.born &gt; <span class="hljs-number"><span class="hljs-number">90</span></span>; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map(overNinety, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person.name; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["Clara Aernoudts", "Emile Haverbeke", // "Maria Haverbeke"]</span></span></code> </pre><br><br>  Interestingly, people who have lived to at least 90 years old are the very ones that we saw earlier that were young in the 1920s.  This is the newest generation in my notes.  Apparently, medicine has seriously improved. <br><br>  Like forEach and filter, map is also a standard method for arrays. <br><br><h4>  Summation with reduce </h4><br>  Another popular example of working with arrays is to get a single value based on the data in the array.  One example is the familiar summation of the list of numbers.  Another is the search for a person born before everyone else. <br><br>  A higher order operation of this type is called reduce (shrinking; or sometimes fold, folding).  You can think of it as a folding array, one element at a time.  When summing the numbers, we started from zero, and for each element we combined it with the current sum using addition. <br><br>  The parameters of the reduce function, except for the array, are a combining function and an initial value.  This function is a little less clear than filter or map, so pay close attention to it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array, combine, start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) current = combine(current, array[i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre><br><br>  The standard method of reduce arrays, which of course works the same way, is even more convenient.  If the array contains at least one element, you can omit the start argument.  The method will take the first element of the array as the starting value and start working with the second one. <br><br>  To find the oldest of my known ancestors with reduce, we can write something like: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ancestry.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, cur</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.born &lt; min.born) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min; })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Pauwels van Haverbeke", born: 1535, ‚Ä¶}</span></span></code> </pre><br><br><h4>  Composability </h4><br>  How could we write the previous example (searching for a person with the earliest date of birth) without higher order functions?  In fact, the code is not so terrible: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = ancestry[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; ancestry.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cur = ancestry[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.born &lt; min.born) min = cur; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(min); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Pauwels van Haverbeke", born: 1535, ‚Ä¶}</span></span></code> </pre><br><br>  Slightly more variables, two lines longer - but so far quite clear code. <br><br>  Higher-order functions reveal their true potential when you have to combine functions.  For example, let's write a code that finds the average age of men and women in the set. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(plus) / array.length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.died - p.born; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">male</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.sex == <span class="hljs-string"><span class="hljs-string">"m"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">female</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.sex == <span class="hljs-string"><span class="hljs-string">"f"</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(average(ancestry.filter(male).map(age))); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 61.67 console.log(average(ancestry.filter(female).map(age))); // ‚Üí 54.56</span></span></code> </pre><br><br>  (It‚Äôs foolish that we have to define addition as a function of plus, but operators in JavaScript are not values, so you don‚Äôt pass them as arguments). <br><br>  Instead of entangling the algorithm in a large cycle, everything is distributed according to the concepts that interest us - the definition of gender, the calculation of age and the averaging of numbers.  We use them in turn to get the result. <br><br>  For writing clear code, this is a really fabulous opportunity.  Of course, clarity does not come for free. <br><br><h4>  Price </h4><br>  In the happy edge of an elegant code and beautiful rainbows lives gadsky monster named Inefficiency. <br><br>  The program that processes the array is most beautifully represented as a sequence of clearly separated steps, each of which does something with the array and returns a new array.  But the layering of all these intermediate arrays is expensive. <br><br>  Similarly, the transfer function in forEach, so that she went through the array for us, convenient and easy to understand.  But calling functions in JavaScript is more expensive than cycles. <br><br>  The same is true of many techniques that improve the readability of programs.  Abstractions add layers between clean computer work and the concepts we work with ‚Äî and as a result, the computer does more work.  This is not an irony rule - there are languages ‚Äã‚Äãthat allow you to add abstractions without degrading performance, and even in JavaScript an experienced programmer can find ways to write abstract and fast code.  But this problem is common. <br><br>  Fortunately, most computers are insanely fast.  If your data set is not too large, or the work time should be just fast enough from the point of view of a person (for example, to do something every time the user presses a button) - then it doesn't matter if you wrote a beautiful solution that works half a millisecond, or very optimized, which runs one tenth of a millisecond. <br><br>  It is convenient to calculate approximately how often this piece of code will be called.  If you have a loop in the loop (directly, or through a call in the loop of a function that also works with the loop inside), the code will be executed N * M times, where N is the number of repetitions of the outer loop, and M is the inner one.  If there is another cycle in the inner loop, repeated P times, then we will get N * M * P - and so on.  This can lead to large numbers, and when the program slows down, the problem can often be reduced to a small piece of code inside the innermost loop. <br><br><h4>  Great-great-great-great-great ... </h4><br>  My grandfather, Philibert Haverbeke, is mentioned in the data file.  Starting with him, I can track my race in search of the oldest of ancestors, Pauvels van Haverbeke, my direct ancestor.  Now I want to calculate what percentage of the DNA I have from him (in theory). <br><br>  To go from the name of the ancestor to the object that represents it, we build an object that matches names and people. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byName = {}; ancestry.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ byName[person.name] = person; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(byName[<span class="hljs-string"><span class="hljs-string">"Philibert Haverbeke"</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {name: "Philibert Haverbeke", ‚Ä¶}</span></span></code> </pre><br><br>  The task is not just to find a father for each of the records and calculate how many steps it takes to Pauvels.  In the history of the family, there were several marriages between cousins ‚Äã‚Äã(well, small villages, etc.).  In this regard, the branches of the family tree in some places are connected with others, so I get more genes than 1 / 2G (G is the number of generations between Pauvels and me).  This formula is based on the assumption that each generation splits the genetic foundation in two. <br><br>  It is reasonable to draw an analogy to reduce, where the array is reduced to a single value by sequentially combining the data from left to right.  Here we also need to get a single number, but at the same time it is necessary to follow the lines of heredity.  And they form not a simple list, but a tree. <br><br>  We consider this value for a particular person by combining these values ‚Äã‚Äãof his ancestors.  This can be done recursively.  If we need a person, we need to calculate the required value for his parents, which in turn requires calculating it for its ancestors, etc.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In theory, we will have to go around an infinite number of tree nodes, but since our data set is finite, we will need to stop somewhere. We will simply assign a default value to all people who are not on our list. It would be logical to assign them a zero value - people who are not on the list do not carry the DNA of the ancestor we need. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By accepting a person, a function to combine values ‚Äã‚Äãfrom two ancestors and a default value, the reduceAncestors function ‚Äúcondenses‚Äù the value from the family tree.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceAncestors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person, f, defaultValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueFor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(person, valueFor(byName[person.mother]), valueFor(byName[person.father])); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valueFor(person); }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The internal function valueFor works with one person. Thanks to recursive magic, she can summon herself for the treatment of the father and mother of this person. The results along with the person object are passed to f, which calculates the desired value for this person. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can use this to calculate the percentage of DNA that my grandfather shared with Pauwels van Haverbeke, and divide it into four.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sharedDNA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person, fromMother, fromFather</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person.name == <span class="hljs-string"><span class="hljs-string">"Pauwels van Haverbeke"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (fromMother + fromFather) / <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ph = byName[<span class="hljs-string"><span class="hljs-string">"Philibert Haverbeke"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduceAncestors(ph, sharedDNA, <span class="hljs-number"><span class="hljs-number">0</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 0.00049</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A man named Pouvels van Haverbeke apparently shares 100% of the DNA with Pauvels van Haverbeke (there are no complete names in the list), so the function returns 1 for him. All others share the average percentage of their parents. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistically, about 0.05% of my DNA coincides with my ancestor from the 16th century. This, of course, is an approximate number. This is quite small, but since our genetic material is about 3 billion base pairs, there is something in me from my ancestor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One could count this number without using reduceAncestors. But the separation of the general approach (bypassing the tree) and the specific case (DNA counting) allows us to write more understandable code and use parts of the code again for other tasks. For example, the following code finds out the percentage of the known ancestors of this person who lived to 70 years.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countAncestors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person, test</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person, fromMother, fromFather</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thisOneCounts = test(person); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromMother + fromFather + (thisOneCounts ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reduceAncestors(person, combine, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">longLivingPercentage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all = countAncestors(person, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> longLiving = countAncestors(person, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (person.died - person.born) &gt;= <span class="hljs-number"><span class="hljs-number">70</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> longLiving / all; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(longLivingPercentage(byName[<span class="hljs-string"><span class="hljs-string">"Emile Haverbeke"</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 0.145</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No need to treat such calculations too seriously, since our set contains an arbitrary sample of people. </font><font style="vertical-align: inherit;">But the code demonstrates that reduceAncestors is a useful part of a common vocabulary for working with a family tree type data structure.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Binding </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bind method, which all functions have, creates a new function that will call the original one, but with some fixed arguments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following example shows how this works. </font><font style="vertical-align: inherit;">In it, we define the function isInSet, which tells whether there is a name for a person in a given set. </font><font style="vertical-align: inherit;">To call filter, we can either write an expression with a function that calls isInSet, passing it a rowset as the first argument, or use the isInSet function partially.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> theSet = [<span class="hljs-string"><span class="hljs-string">"Carel Haverbeke"</span></span>, <span class="hljs-string"><span class="hljs-string">"Maria van Brussel"</span></span>, <span class="hljs-string"><span class="hljs-string">"Donald Duck"</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isInSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set, person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set.indexOf(person.name) &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ancestry.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isInSet(theSet, person); })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [{name: "Maria van Brussel", ‚Ä¶}, // {name: "Carel Haverbeke", ‚Ä¶}] console.log(ancestry.filter(isInSet.bind(null, theSet))); // ‚Üí ‚Ä¶ same result</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bind call returns a function that calls isInSet with the first argument of theSet, and subsequent arguments are the same as were passed to bind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first argument, which is now set to null, is used for method calls - just as it was in apply. We will talk about it later.</font></font><br><br><h4>  Total </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to transfer function calls to other functions is not just a toy, but a very useful feature of JavaScript. </font><font style="vertical-align: inherit;">We can write expressions ‚Äúwith spaces‚Äù in them, which will then be filled with the values ‚Äã‚Äãreturned by the functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays have several useful higher-order methods ‚Äî forEach to do something with each element, filter ‚Äî to build a new array, where some values ‚Äã‚Äãare filtered, map ‚Äî to build a new array, each element of which is passed through a function, reduce - for a combination all array elements in one value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functions have a apply method to pass arguments to them as an array. </font><font style="vertical-align: inherit;">They also have a bind method for creating a copy of a function with partial arguments.</font></font><br><br><h4>  Exercises </h4><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convolution </font></font></h5><br>   reduce    concat       ,       . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrays = [[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], [<span class="hljs-number"><span class="hljs-number">6</span></span>]]; <span class="hljs-comment"><span class="hljs-comment">//    // ‚Üí [1, 2, 3, 4, 5, 6]</span></span></code> </pre><br><br><h5>        </h5><br>     ,           (      ).    average,   . <br><br>   ‚Äì   ,   ,   .     byName,        . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(plus) / array.length; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byName = {}; ancestry.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ byName[person.name] = person; }); <span class="hljs-comment"><span class="hljs-comment">//    // ‚Üí 31.2</span></span></code> </pre><br><br><h5>     </h5><br>  ,        90 .     .        .   ,    ,    100  : Math.ceil(person.died / 100). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.reduce(plus) / array.length; } <span class="hljs-comment"><span class="hljs-comment">//    // ‚Üí 16: 43.5 // 17: 51.2 // 18: 52.8 // 19: 54.8 // 20: 84.7 // 21: 94</span></span></code> </pre><br><br>       groupBy,   .      ,      ,   ,        . <br><br><h5> Every  some </h5><br>       every  some.      , ,        ,  true  false.  ,  &amp;&amp;  true,         true,  every  true,    true    . , some  true,     true       .     ,   ‚Äì ,  some  true   ,    . <br><br>   every  some,    ,   ,      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    console.log(every([NaN, NaN, NaN], isNaN)); // ‚Üí true console.log(every([NaN, NaN, 4], isNaN)); // ‚Üí false console.log(some([NaN, 3, 4], isNaN)); // ‚Üí true console.log(some([2, 3, 4], isNaN)); // ‚Üí false</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/241155/">https://habr.com/ru/post/241155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241143/index.html">What accelerates forced overtime</a></li>
<li><a href="../241145/index.html">Rushim Captcha SilkRoad</a></li>
<li><a href="../241149/index.html">SPB Frontend: October meeting</a></li>
<li><a href="../241151/index.html">Dnipropetrovsk Ciklum Speakers' Corner "Google Guava: make your code easier and faster", October 23</a></li>
<li><a href="../241153/index.html">Portal to search for like-minded people when creating projects</a></li>
<li><a href="../241157/index.html">About the VeeamON First-Hand Conference - Not Everything That Was in Vegas Remains in Vegas</a></li>
<li><a href="../241161/index.html">How I made friends with asynchronous JavaScript</a></li>
<li><a href="../241163/index.html">7 effective A / B testing with welcome letters</a></li>
<li><a href="../241165/index.html">Work with information partners of the hackathon. HackDay Experience</a></li>
<li><a href="../241167/index.html">Trial period for SaaS: requesting a credit card is a short-sighted undertaking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>