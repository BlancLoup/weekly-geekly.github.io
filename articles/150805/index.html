<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LISP interpreter on pure C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I love C for its simplicity and efficiency. However, it cannot be called flexible and extensible. There is another simple language with unprecedented ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LISP interpreter on pure C</h1><div class="post__text post__text-html js-mediator-article">  I love C for its simplicity and efficiency.  However, it cannot be called flexible and extensible.  There is another simple language with unprecedented flexibility and extensibility, but losing C in resource efficiency.  I mean LISP.  Both languages ‚Äã‚Äãwere used for system programming and have a long and glorious history. <br><br>  For quite a long time I have been pondering the idea of ‚Äã‚Äãuniting the approaches of both these languages.  Its essence lies in the implementation of a programming language based on LISP, which solves the same tasks as C: ensuring a high degree of control over the equipment (including low-level memory access).  In practice, this will be a LISP macro system that generates a binary code.  The possibilities of LISP for preprocessing source code, it seems to me, will provide unprecedented flexibility in comparison with C preprocessor or C ++ templates, while maintaining the original simplicity of the language.  This will give the opportunity on the basis of such DSL to build on new extensions that increase the speed and convenience of development.  In particular, the LISP system itself can be implemented in this language. <br><br>  Writing a compiler requires a code generator, and ultimately an assembler.  Therefore, practical research should begin with the implementation of the assembler (for a subset of instructions of the target processor).  I was interested in minimizing any dependencies on specific technologies, programming languages ‚Äã‚Äãand operating system.  Therefore, I decided to implement from scratch on C the simplest interpreter of an improvised LISP dialect, and also write to it a system of macro extensions, which make it convenient to code on a subset of the x86 assembler.  The culmination of my efforts should be the resulting boot image that displays "Hello world!" In real processor mode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the moment, I have implemented a working interpreter (file int.c, about 900 lines of C code), as well as a set of basic functions and macros (file lib.l, about 100 lines of LISP code).  Those who are interested in the principles of LISP-code execution, as well as the details of the implementation of the interpreter, please under the cat. <br><a name="habracut"></a><br>  The basic unit of LISP computing is a dotted pair.  In a classic McCarthy lisp, the point pair and the symbol are the only two data types.  In practical implementations, this set has to be expanded at least by numbers.  In addition, strings and arrays are also added to the base types (the first is a variation of the second).  In the pursuit of simplification, there is the temptation to view strings as a list of numbers, but I deliberately abandoned this idea as a dramatically restricting language in the real world.  I decided to use double as a container for numbers. <br><br>  So, we have the following basic data types: dotted pair, character, number, string (pascal style, since this will allow storing arbitrary binary data in an unchanged form).  Since I am working on an interpreter (and not on a compiler), I could restrict myself to this set (functions and macros can be represented by ordinary s-expressions), but for convenience of implementation 4 additional types were added: function, macro, built-in function and built-in macro.  So, we have the following structure for the s-expression: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> *(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">built_in</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class">*, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class">*, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_pos</span></span></span><span class="hljs-class">*);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { DOTTED_PAIR, STRING, SYMBOL, NUMBER, FUNCTION, MACRO, BUILT_IN_FUNCTION, BUILT_IN_MACRO } type; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rest</span></span></span><span class="hljs-class">;</span></span> } pair; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">;</span></span> } function; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *symbol; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> number; built_in built_in; } u; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *symbol; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br>  This structure is not optimal in terms of saving resources and performance, but I did not set myself the goal of building an effective implementation.  First of all, the simplicity and conciseness of the code was important.  I even had to give up memory management: all memory is allocated without being freed.  In fact, for my practical problem this solution is valid: the interpreter will not work for a long time: its task is only to translate the code into binary form. <br><br>  As you can see from the above code, the function (and macro) refers to the l_env structure.  It is a basic element of the lexical environment, stored in a list.  Of course, this is inefficient, since it involves sequential access to the characters.  But this is a very simple and convenient structure for supporting local variables: they are added to the head of the list, while global ones are added to the tail.  It is very easy to get rid of local variables (when exiting a function or from a let block), simply ignoring the front part of this list.  The function‚Äôs own lexical environment allows the implementation of closures. <br><br>  On the basis of the above structure of the s-expression, it is easy to build a function to calculate it: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct s_expr *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_s_expr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct s_expr *expr, struct l_env *env, struct file_pos *pos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s_expr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l_env</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">benv</span></span></span><span class="hljs-class">;</span></span> trace_put(<span class="hljs-string"><span class="hljs-string">"%s -&gt; ..."</span></span>, in, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr-&gt;type == SYMBOL) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (find_symbol(expr-&gt;u.symbol, &amp;env)) expr = env-&gt;expr; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr-&gt;type == DOTTED_PAIR) { first = eval_s_expr(expr-&gt;u.pair.first, env, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL || first-&gt;type == STRING || first-&gt;type == NUMBER) error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env)); expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ? map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;type == FUNCTION || first-&gt;type == MACRO) { assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR); benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr, first-&gt;u.function.env, pos); expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;type == MACRO) { trace_put(<span class="hljs-string"><span class="hljs-string">"%s ~&gt; %s"</span></span>, in, expr, env); expr = eval_s_expr(expr, env, pos); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> expr = first-&gt;u.built_in(expr, env, pos); } trace_put(<span class="hljs-string"><span class="hljs-string">"%s -&gt; %s"</span></span>, in, expr, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expr; }</code> </pre><br>  If the computable expression is a symbol, we simply look for its value in the current lexical environment (find_symbol).  If the function call: we first calculate the actual parameters using the current lexical environment (map_eval), then bind them to the symbols of formal parameters (apply_args) already in the lexical environment of the function itself.  Then we sequentially calculate the elements of the body based on the resulting lexical environment, returning the value of the last expression (eval_list).  To call a macro, the calculation order is somewhat different.  Actual parameters are not calculated, but transmitted in unchanged form.  In addition, the resulting macro expression (macro substitution) is subjected to additional calculation.  Numbers, strings, functions, and macros are computed into themselves. <br><br><div class="spoiler">  <b class="spoiler_title">The full text of the int.c file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;assert.h&gt; #include &lt;ctype.h&gt; #include &lt;float.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define LINE_COMMENT_CHAR ';' #define BLOCK_COMMENT_CHAR1 ';' #define BLOCK_COMMENT_CHAR2 '|' #define LIST_OPEN_BRACE_CHAR '(' #define LIST_CLOSE_BRACE_CHAR ')' #define LIST_DOT_CHAR '.' #define STRING_DELIMITER_CHAR '"' #define STRING_ESCAPE_CHAR '\\' #define NUMBER_PREFIX_CHAR '$' #define NUMBER_FORMAT_HEX_CHAR 'h' #define NUMBER_FORMAT_OCT_CHAR 'o' #define NIL_SYMBOL_STR "_" #define TRUE_SYMBOL_STR "t" #define TRACE_SYMBOL_STR "trace" #define CAR_SYMBOL_STR "@" #define CDR_SYMBOL_STR "%" #define CONS_SYMBOL_STR "^" #define IF_SYMBOL_STR "?" #define LAMBDA_SYMBOL_STR "!" #define MACRO_SYMBOL_STR "#" #define SETQ_SYMBOL_STR "=" #define QUOTE_SYMBOL_STR "'" #define PLUS_SYMBOL_STR "+" #define GREATER_SYMBOL_STR "&gt;" #define FUNCTION_STR_FORMAT "&lt;!%s&gt;" #define MACRO_STR_FORMAT "&lt;#%s&gt;" #define OUT_OF_MEMORY_MSG "out of memory" #define UNEXPECTED_EOF_MSG "unexpected end of file" #define BAD_SYNTAX_MSG "bad syntax" #define NON_FUNC_MACRO_MSG "expression %s is neither a function nor a macro" #define NON_NONEMPTY_LIST_MSG "expression %s is not a nonempty list" #define NON_LIST_MSG "expression %s is not a proper list" #define UNBOUND_SYMBOL_MSG "unbound symbol %s" #define BAD_FORMAL_ARGS_MSG "bad formal arguments %s" #define BAD_ACTUAL_ARGS_MSG "bad actual arguments %s" #define STRING_OVERFLOW_MSG "string size overflow" #define NUMBER_LENGTH_MAX 32 #define SYMBOL_LENGTH_MAX 32 #define STRING_LENGTH_MAX 256 #define S_EXPR_LENGTH_MAX 1024 struct file_pos { char *filename; int line, chr; }; struct l_env; typedef struct s_expr *(*built_in) (struct s_expr*, struct l_env*, struct file_pos*); struct s_expr { enum { DOTTED_PAIR, STRING, SYMBOL, NUMBER, FUNCTION, MACRO, BUILT_IN_FUNCTION, BUILT_IN_MACRO } type; union { struct { struct s_expr *first, *rest; } pair; struct { char *ptr; size_t size; } string; struct { struct s_expr *expr; struct l_env *env; } function; char *symbol; double number; built_in built_in; } u; }; void error(char *message, struct file_pos *pos, char *expr) { if (pos) printf("Error at %s:%d:%d: ", pos-&gt;filename, pos-&gt;line, pos-&gt;chr); else printf("Error: "); if (expr) printf(message, expr); else printf("%s", message); puts(""); exit(1); } void *alloc_mem(size_t size) { void *ptr = malloc(size); if (!ptr) error(OUT_OF_MEMORY_MSG, NULL, NULL); return ptr; } struct s_expr *true_ () { static struct s_expr *expr = NULL; if (!expr) { expr = alloc_mem(sizeof(*expr)); expr-&gt;type = SYMBOL; expr-&gt;u.symbol = TRUE_SYMBOL_STR; } return expr; } int get_char(FILE *file, struct file_pos *pos) { int chr = getc(file); if (chr == '\n') pos-&gt;line++, pos-&gt;chr = 1; else if (chr != EOF) pos-&gt;chr++; return chr; } int next_char(FILE *file) { int chr = getc(file); ungetc(chr, file); return chr; } int get_significant_char (FILE *file, struct file_pos *pos) { enum { NO_COMMENT, LINE_COMMENT, BLOCK_COMMENT } state = NO_COMMENT; int chr; while (1) { chr = get_char(file, pos); if (state == NO_COMMENT) { if (chr == BLOCK_COMMENT_CHAR1 &amp;&amp; next_char(file) == BLOCK_COMMENT_CHAR2) { get_char(file, pos); state = BLOCK_COMMENT; continue; } if (chr == LINE_COMMENT_CHAR) state = LINE_COMMENT; else if (chr != ' ' &amp;&amp; chr != '\t' &amp;&amp; chr != '\r' &amp;&amp; chr != '\n') return chr; } else if (state == BLOCK_COMMENT) { if (chr == BLOCK_COMMENT_CHAR2 &amp;&amp; next_char(file) == BLOCK_COMMENT_CHAR1) { get_char(file, pos); state = NO_COMMENT; } else if (chr == EOF) error(UNEXPECTED_EOF_MSG, pos, NULL); } else if (state == LINE_COMMENT) { if (chr == '\n') state = NO_COMMENT; else if (chr == EOF) return EOF; } } } struct s_expr *parse_s_expr (FILE*, struct file_pos*); struct s_expr *parse_list (FILE *file, struct file_pos *pos) { struct s_expr *expr, *rest; int chr; chr = get_significant_char(file, pos); if (chr == LIST_CLOSE_BRACE_CHAR) return NULL; ungetc(chr, file); pos-&gt;chr--; expr = alloc_mem(sizeof(*expr)); expr-&gt;type = DOTTED_PAIR; expr-&gt;u.pair.first = parse_s_expr(file, pos); rest = expr; while (1) { chr = get_significant_char(file, pos); if (chr == LIST_DOT_CHAR) { rest-&gt;u.pair.rest = parse_s_expr(file, pos); if (get_significant_char(file, pos) != LIST_CLOSE_BRACE_CHAR) error(BAD_SYNTAX_MSG, pos, NULL); break; } else if (chr == LIST_CLOSE_BRACE_CHAR) { rest-&gt;u.pair.rest = NULL; break; } else if (chr == EOF) error(UNEXPECTED_EOF_MSG, pos, NULL); else { ungetc(chr, file); pos-&gt;chr--; rest-&gt;u.pair.rest = alloc_mem(sizeof(*expr)); rest-&gt;u.pair.rest-&gt;type = DOTTED_PAIR; rest-&gt;u.pair.rest-&gt;u.pair.first = parse_s_expr(file, pos); rest = rest-&gt;u.pair.rest; } } return expr; } void read_escape_seq (FILE *file, struct file_pos *pos, char *buf) { /* TODO: add support for escape sequences */ } struct s_expr *parse_string (FILE *file, struct file_pos *pos) { char buf[STRING_LENGTH_MAX]; struct s_expr *expr; int chr, i = 0; while (i &lt; STRING_LENGTH_MAX) { chr = get_char(file, pos); if (chr == STRING_ESCAPE_CHAR) read_escape_seq(file, pos, buf); else if (chr == STRING_DELIMITER_CHAR) break; else if (chr == EOF) error(UNEXPECTED_EOF_MSG, pos, NULL); else buf[i++] = chr; } expr = alloc_mem(sizeof(*expr)); expr-&gt;type = STRING; expr-&gt;u.string.ptr = i ? alloc_mem(i) : NULL; memcpy(expr-&gt;u.string.ptr, buf, i); expr-&gt;u.string.size = i; return expr; } void read_double (FILE *file, struct file_pos *pos, char *buf) { int chr, i = 0, point = -1; chr = next_char(file); if (chr == '+' || chr == '-') { get_char(file, pos); buf[i++] = chr; } while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file))) buf[i++] = get_char(file, pos); if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; next_char(file) == '.') buf[point = i++] = get_char(file, pos); while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file))) buf[i++] = get_char(file, pos); chr = next_char(file); if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == 'e' || chr == 'E') &amp;&amp; i &gt; point + 1) { get_char(file, pos); buf[i++] = chr; chr = next_char(file); if (i &lt; NUMBER_LENGTH_MAX &amp;&amp; (chr == '+' || chr == '-')) { get_char(file, pos); buf[i++] = chr; } while (i &lt; NUMBER_LENGTH_MAX &amp;&amp; isdigit(next_char(file))) buf[i++] = get_char(file, pos); } if (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX) buf[i] = 0; else error(BAD_SYNTAX_MSG, pos, NULL); } void read_int (FILE *file, struct file_pos *pos, int base, char *buf) { int chr, i = 0; assert(base == 8 || base == 16); for (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) { chr = next_char(file); if ((base == 16 &amp;&amp; isxdigit(chr)) || (chr &gt;= '0' &amp;&amp; chr &lt;= '7')) buf[i++] = chr; else break; } if (i &amp;&amp; i &lt; NUMBER_LENGTH_MAX) buf[i] = 0; else error(BAD_SYNTAX_MSG, pos, NULL); } struct s_expr *parse_number (FILE *file, struct file_pos *pos) { char buf[NUMBER_LENGTH_MAX + 1]; struct s_expr *expr; int inum; expr = alloc_mem(sizeof(*expr)); expr-&gt;type = NUMBER; switch (next_char(file)) { case NUMBER_FORMAT_HEX_CHAR: get_char(file, pos); read_int(file, pos, 16, buf); sscanf(buf, "%x", &amp;inum); expr-&gt;u.number = inum; break; case NUMBER_FORMAT_OCT_CHAR: get_char(file, pos); read_int(file, pos, 8, buf); sscanf(buf, "%o", &amp;inum); expr-&gt;u.number = inum; break; default: read_double(file, pos, buf); sscanf(buf, "%lf", &amp;expr-&gt;u.number); break; } return expr; } struct s_expr *parse_symbol (FILE *file, struct file_pos *pos) { char buf[NUMBER_LENGTH_MAX + 1]; struct s_expr *expr; int chr, chr2, i = 0; for (; i &lt; NUMBER_LENGTH_MAX; get_char(file, pos)) { chr = next_char(file); if (chr == BLOCK_COMMENT_CHAR1) { get_char(file, pos); chr2 = next_char(file); ungetc(chr2, file); pos-&gt;chr--; if (chr2 == BLOCK_COMMENT_CHAR2) break; } if (chr &gt;= '!' &amp;&amp; chr &lt;= '~' &amp;&amp; chr != LINE_COMMENT_CHAR &amp;&amp; chr != LIST_OPEN_BRACE_CHAR &amp;&amp; chr != LIST_CLOSE_BRACE_CHAR &amp;&amp; chr != LIST_DOT_CHAR &amp;&amp; chr != STRING_DELIMITER_CHAR &amp;&amp; chr != NUMBER_PREFIX_CHAR) buf[i++] = chr; else break; } if (i &amp;&amp; i &lt; SYMBOL_LENGTH_MAX) buf[i] = 0; else error(BAD_SYNTAX_MSG, pos, NULL); if(!strcmp(buf, NIL_SYMBOL_STR)) return NULL; if(!strcmp(buf, TRUE_SYMBOL_STR)) return true_(); expr = alloc_mem(sizeof(*expr)); expr-&gt;type = SYMBOL; expr-&gt;u.symbol = alloc_mem(i + 1); strcpy(expr-&gt;u.symbol, buf); return expr; } struct s_expr *parse_s_expr (FILE *file, struct file_pos *pos) { struct s_expr *expr; int chr; chr = get_significant_char(file, pos); switch (chr) { case EOF: return NULL; case LIST_OPEN_BRACE_CHAR: expr = parse_list(file, pos); break; case STRING_DELIMITER_CHAR: expr = parse_string(file, pos); break; case NUMBER_PREFIX_CHAR: expr = parse_number(file, pos); break; default: ungetc(chr, file); pos-&gt;chr--; expr = parse_symbol(file, pos); break; } return expr; } struct l_env { char *symbol; struct s_expr *expr; struct l_env *next; }; static int do_trace = 0; char *s_expr_string (struct s_expr*, struct l_env*); void trace_put (char *format, struct s_expr *expr1, struct s_expr *expr2, struct l_env *env) { if (do_trace) { printf("Trace: "); printf(format, s_expr_string(expr1, env), s_expr_string(expr2, env)); puts(""); } } struct l_env *add_symbol (char *symbol, struct s_expr *expr, struct l_env *env, int append) { struct l_env *new_env; new_env = alloc_mem(sizeof(*new_env)); new_env-&gt;symbol = symbol, new_env-&gt;expr = expr; if (append) env-&gt;next = new_env, new_env-&gt;next = NULL; else new_env-&gt;next = env; return new_env; } struct l_env * add_built_in (int macro, char *symbol, built_in bi, struct l_env *env) { struct s_expr *expr = alloc_mem(sizeof(*expr)); expr-&gt;type = macro ? BUILT_IN_MACRO : BUILT_IN_FUNCTION; expr-&gt;u.built_in = bi; return add_symbol(symbol, expr, env, 0); } int find_symbol (char *symbol, struct l_env **env) { struct l_env *next = *env; for (; next; *env = next, next = next-&gt;next) if (!strcmp(symbol, next-&gt;symbol)) { *env = next; return 1; } return 0; } char *str_cat (char *dest, size_t dest_size, char *src) { if (strlen(src) &gt; dest_size - 1 - strlen(dest)) error(STRING_OVERFLOW_MSG, NULL, NULL); return strcat(dest, src); } char *list_string (struct s_expr *list, struct l_env *env) { char buf[S_EXPR_LENGTH_MAX + 1] = { LIST_OPEN_BRACE_CHAR, 0 }; char psep[] = { ' ', LIST_DOT_CHAR, ' ', 0 }; char cbrc[] = { LIST_CLOSE_BRACE_CHAR, 0 }; for (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) { if (buf[1]) str_cat(buf, S_EXPR_LENGTH_MAX + 1, " "); str_cat(buf, S_EXPR_LENGTH_MAX + 1, s_expr_string(list-&gt;u.pair.first, env)); } if (list) str_cat(str_cat(buf, S_EXPR_LENGTH_MAX + 1, psep), S_EXPR_LENGTH_MAX + 1, s_expr_string(list, env)); str_cat(buf, S_EXPR_LENGTH_MAX + 1, cbrc); return strcpy(alloc_mem(strlen(buf) + 1), buf); } char *string_string (char *ptr, size_t size) { char *str = alloc_mem(size + 3); str[0] = str[size + 1] = '"'; memcpy(str + 1, ptr, size); str[size + 2] = 0; return str; } char *number_string (double number) { char *str = alloc_mem(NUMBER_LENGTH_MAX + 2); str[0] = NUMBER_PREFIX_CHAR; sprintf(str + 1, "%g", number); return str; } char *function_string (struct s_expr *expr, int macro, struct l_env *env) { char *str; for (; env; env = env-&gt;next) if (env-&gt;expr == expr) break; str = alloc_mem((macro ? sizeof(MACRO_STR_FORMAT) : sizeof(FUNCTION_STR_FORMAT)) + (env ? strlen(env-&gt;symbol) : 0) - 1); sprintf(str, macro ? MACRO_STR_FORMAT : FUNCTION_STR_FORMAT, env ? env-&gt;symbol : ""); return str; } char *s_expr_string (struct s_expr *expr, struct l_env *env) { if (!expr) return NIL_SYMBOL_STR; switch (expr-&gt;type) { case DOTTED_PAIR: return list_string(expr, env); case STRING: return string_string(expr-&gt;u.string.ptr, expr-&gt;u.string.size); case SYMBOL: return expr-&gt;u.symbol; case NUMBER: return number_string(expr-&gt;u.number); case FUNCTION: case BUILT_IN_FUNCTION: return function_string(expr, 0, env); case MACRO: case BUILT_IN_MACRO: return function_string(expr, 1, env); default: assert(0); return NULL; } } int proper_listp (struct s_expr *expr) { while (expr &amp;&amp; expr-&gt;type == DOTTED_PAIR) expr = expr-&gt;u.pair.rest; return expr == NULL; } struct s_expr *search_symbol(struct s_expr *list, char *symbol) { for (; list &amp;&amp; list-&gt;type == DOTTED_PAIR; list = list-&gt;u.pair.rest) { assert(list-&gt;u.pair.first-&gt;type == SYMBOL); if (!strcmp(list-&gt;u.pair.first-&gt;u.symbol, symbol)) return list; } return NULL; } void check_fargs (struct s_expr *fargs, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = fargs; if (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp; !rest-&gt;u.pair.first &amp;&amp; rest-&gt;u.pair.rest-&gt;type == SYMBOL) return; for (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest) if (!rest-&gt;u.pair.first || rest-&gt;u.pair.first-&gt;type != SYMBOL || search_symbol(fargs, rest-&gt;u.pair.first-&gt;u.symbol) != rest) error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env)); if (rest &amp;&amp; (rest-&gt;type != SYMBOL || search_symbol(fargs, rest-&gt;u.symbol))) error(BAD_FORMAL_ARGS_MSG, pos, s_expr_string(fargs, env)); } void check_aargs (struct s_expr *args, int count, int va, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = args; for (; count &amp;&amp; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; count--) rest = rest-&gt;u.pair.rest; if (count || (!va &amp;&amp; rest) || !proper_listp(rest)) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); } struct s_expr *eval_list (struct s_expr*, struct l_env*, struct file_pos*); struct s_expr *eval_s_expr (struct s_expr*, struct l_env*, struct file_pos*); #define ARG1(args) args-&gt;u.pair.first #define ARG2(args) args-&gt;u.pair.rest-&gt;u.pair.first #define ARG3(args) args-&gt;u.pair.rest-&gt;u.pair.rest-&gt;u.pair.first struct s_expr *trace (struct s_expr *args, struct l_env *env, struct file_pos *pos) { struct s_expr *expr; do_trace = 1; expr = eval_list(args, env, pos); do_trace = 0; return expr; } struct s_expr *quote (struct s_expr *args, struct l_env *env, struct file_pos *pos) { check_aargs(args, 1, 0, env, pos); return ARG1(args); } struct s_expr *car (struct s_expr *args, struct l_env *env, struct file_pos *pos) { check_aargs(args, 1, 0, env, pos); if (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR) error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env)); return ARG1(args) ? ARG1(args)-&gt;u.pair.first : NULL; } struct s_expr *cdr (struct s_expr *args, struct l_env *env, struct file_pos *pos) { check_aargs(args, 1, 0, env, pos); if (ARG1(args) &amp;&amp; ARG1(args)-&gt;type != DOTTED_PAIR) error(NON_LIST_MSG, pos, s_expr_string(ARG1(args), env)); return ARG1(args) ? ARG1(args)-&gt;u.pair.rest : NULL; } struct s_expr *cons (struct s_expr *args, struct l_env *env, struct file_pos *pos) { struct s_expr *expr; check_aargs(args, 2, 0, env, pos); expr = alloc_mem(sizeof(*expr)); expr-&gt;type = DOTTED_PAIR; expr-&gt;u.pair.first = ARG1(args); expr-&gt;u.pair.rest = ARG2(args); return expr; } struct s_expr *if_ (struct s_expr *args, struct l_env *env, struct file_pos *pos) { check_aargs(args, 3, 0, env, pos); return eval_s_expr(ARG1(args), env, pos) ? eval_s_expr(ARG2(args), env, pos) : eval_s_expr(ARG3(args), env, pos); } struct s_expr *function (struct s_expr *args, struct l_env *env, struct file_pos *pos, int macro) { struct s_expr *expr; check_aargs(args, 1, 1, env, pos); check_fargs(ARG1(args), env, pos); expr = alloc_mem(sizeof(*expr)); expr-&gt;type = macro ? MACRO : FUNCTION; expr-&gt;u.function.expr = args; expr-&gt;u.function.env = env; return expr; } struct s_expr *lambda (struct s_expr *args, struct l_env *env, struct file_pos *pos) { return function(args, env, pos, 0); } struct s_expr *macro (struct s_expr *args, struct l_env *env, struct file_pos *pos) { return function(args, env, pos, 1); } struct s_expr *setq (struct s_expr *args, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = args, *expr = NULL; struct l_env *senv; while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) { if (ARG1(rest) &amp;&amp; ARG1(rest)-&gt;type == SYMBOL &amp;&amp; rest-&gt;u.pair.rest &amp;&amp; rest-&gt;u.pair.rest-&gt;type == DOTTED_PAIR) { expr = eval_s_expr(ARG2(rest), env, pos), senv = env; if (find_symbol(ARG1(rest)-&gt;u.symbol, &amp;senv)) { trace_put("%s =&gt; %s [assign]", expr, ARG1(rest), env); senv-&gt;expr = expr; } else { trace_put("%s =&gt; %s [global]", expr, ARG1(rest), env); add_symbol(ARG1(rest)-&gt;u.symbol, expr, senv, 1); } } else error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); rest = rest-&gt;u.pair.rest-&gt;u.pair.rest; } if (rest) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); return expr; } struct s_expr *plus (struct s_expr *args, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = args; double sum = 0; while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR &amp;&amp; ARG1(rest)-&gt;type == NUMBER) sum += ARG1(rest)-&gt;u.number, rest = rest-&gt;u.pair.rest; if (rest) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); rest = alloc_mem(sizeof(*rest)); rest-&gt;type = NUMBER; rest-&gt;u.number = sum; return rest; } struct s_expr *greater (struct s_expr *args, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = args, *num; double prev = DBL_MAX; while (rest &amp;&amp; rest-&gt;type == DOTTED_PAIR) { num = eval_s_expr(ARG1(rest), env, pos); if (!num || num-&gt;type != NUMBER) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); if (prev - num-&gt;u.number &lt; DBL_EPSILON) return NULL; prev = num-&gt;u.number, rest = rest-&gt;u.pair.rest; } if (rest) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(args, env)); return true_(); } struct l_env *create_env () { struct l_env *env = NULL; env = add_built_in(1, TRACE_SYMBOL_STR, trace, env); env = add_built_in(1, QUOTE_SYMBOL_STR, quote, env); env = add_built_in(0, CAR_SYMBOL_STR, car, env); env = add_built_in(0, CDR_SYMBOL_STR, cdr, env); env = add_built_in(0, CONS_SYMBOL_STR, cons, env); env = add_built_in(1, IF_SYMBOL_STR, if_, env); env = add_built_in(1, LAMBDA_SYMBOL_STR, lambda, env); env = add_built_in(1, MACRO_SYMBOL_STR, macro, env); env = add_built_in(1, SETQ_SYMBOL_STR, setq, env); env = add_built_in(0, PLUS_SYMBOL_STR, plus, env); env = add_built_in(1, GREATER_SYMBOL_STR, greater, env); return env; } struct s_expr *map_eval (struct s_expr *list, struct l_env *env, struct file_pos *pos) { struct s_expr *expr = NULL, *rest; while (list) { if (list-&gt;type != DOTTED_PAIR) error(NON_LIST_MSG, pos, s_expr_string(list, env)); if (expr) { rest-&gt;u.pair.rest = alloc_mem(sizeof(*expr)); rest = rest-&gt;u.pair.rest; } else expr = rest = alloc_mem(sizeof(*expr)); rest-&gt;type = DOTTED_PAIR; rest-&gt;u.pair.first = eval_s_expr(list-&gt;u.pair.first, env, pos); list = list-&gt;u.pair.rest; } if (expr) rest-&gt;u.pair.rest = NULL; return expr; } struct l_env *apply_args (struct s_expr *fargs, struct s_expr *aargs, struct l_env *env, struct file_pos *pos) { struct s_expr *rest = aargs; if (!fargs || fargs-&gt;u.pair.first) while (fargs &amp;&amp; fargs-&gt;type == DOTTED_PAIR) { if (!rest || rest-&gt;type != DOTTED_PAIR) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env)); assert(fargs-&gt;u.pair.first-&gt;type == SYMBOL); trace_put("%s =&gt; %s [local]", rest-&gt;u.pair.first, fargs-&gt;u.pair.first, env); env = add_symbol(fargs-&gt;u.pair.first-&gt;u.symbol, rest-&gt;u.pair.first, env, 0); fargs = fargs-&gt;u.pair.rest, rest = rest-&gt;u.pair.rest; } else fargs = fargs-&gt;u.pair.rest; if (fargs) { assert(fargs-&gt;type == SYMBOL); if (rest &amp;&amp; !proper_listp(rest)) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env)); trace_put("%s =&gt; %s [local]", rest, fargs, env); env = add_symbol(fargs-&gt;u.symbol, rest, env, 0); } else if (rest) error(BAD_ACTUAL_ARGS_MSG, pos, s_expr_string(aargs, env)); return env; } struct s_expr *eval_list (struct s_expr *list, struct l_env *env, struct file_pos *pos) { struct s_expr *expr = NULL, *rest = list; for (; rest &amp;&amp; rest-&gt;type == DOTTED_PAIR; rest = rest-&gt;u.pair.rest) expr = eval_s_expr(rest-&gt;u.pair.first, env, pos); if (rest) error(NON_LIST_MSG, pos, s_expr_string(list, env)); return expr; } struct s_expr *eval_s_expr (struct s_expr *expr, struct l_env *env, struct file_pos *pos) { struct s_expr *first, *in = expr; struct l_env *benv; trace_put("%s -&gt; ...", in, NULL, env); if (expr) if (expr-&gt;type == SYMBOL) if (find_symbol(expr-&gt;u.symbol, &amp;env)) expr = env-&gt;expr; else error(UNBOUND_SYMBOL_MSG, pos, expr-&gt;u.symbol); else if (expr-&gt;type == DOTTED_PAIR) { first = eval_s_expr(expr-&gt;u.pair.first, env, pos); if (!first || first-&gt;type == DOTTED_PAIR || first-&gt;type == SYMBOL || first-&gt;type == STRING || first-&gt;type == NUMBER) error(NON_FUNC_MACRO_MSG, pos, s_expr_string(first, env)); expr = first-&gt;type == FUNCTION || first-&gt;type == BUILT_IN_FUNCTION ? map_eval(expr-&gt;u.pair.rest, env, pos) : expr-&gt;u.pair.rest; if (first-&gt;type == FUNCTION || first-&gt;type == MACRO) { assert(first-&gt;u.function.expr-&gt;type == DOTTED_PAIR); benv = apply_args(first-&gt;u.function.expr-&gt;u.pair.first, expr, first-&gt;u.function.env, pos); expr = eval_list(first-&gt;u.function.expr-&gt;u.pair.rest, benv, pos); if (first-&gt;type == MACRO) { trace_put("%s ~&gt; %s", in, expr, env); expr = eval_s_expr(expr, env, pos); } } else expr = first-&gt;u.built_in(expr, env, pos); } trace_put("%s -&gt; %s", in, expr, env); return expr; } struct s_expr *eval_file (char *filename, struct l_env *env) { struct file_pos pos, prev_pos; struct s_expr *expr; FILE *file; int chr; file = fopen(filename, "r"); if (!file) { printf("Failed to open file '%s'\n", filename); exit(1); } pos.filename = filename, pos.line = pos.chr = 1; expr = NULL; while (1) { chr = get_significant_char(file, &amp;pos); if (chr == EOF) break; ungetc(chr, file); pos.chr--, prev_pos = pos; expr = eval_s_expr(parse_s_expr(file, &amp;pos), env, &amp;prev_pos); } fclose(file); return expr; } int main (int argc, char *argv[]) { struct l_env *env; if (argc != 2) { puts("Usage: int source"); exit(1); } env = create_env(); puts(s_expr_string(eval_file(argv[1], env), env)); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  I decided to introduce more concise names for basic and arbitrary functions and macros.  In the classic LISP (and, especially, in Common Lisp), the verbosity of the basic primitives strains me a little.  On the one hand, I did not want to complicate the parser, because quote and backquote syntax is not supported by it, only the bracket notation.  On the other hand, he sought to compensate for excessive stabilities by the wide use of special characters for conciseness.  To some, this will seem like a very controversial decision. <br><br>  I tried to select names according to their associative line: <br><ul><li>  <b>_</b> - replaces <b>nil</b> </li><li>  <b>!</b>  - replaces <b>lambda</b> </li><li>  <b>#</b> - likewise <b>!</b>  but declares a nameless macro </li><li>  <b>?</b>  - replaces <b>if</b> with the obligatory third parameter </li><li>  <b>^</b> - replace <b>cons</b> </li><li>  <b>@</b> - replaces <b>car</b> </li><li>  <b>%</b> - replaces <b>cdr</b> </li><li>  <b>=</b> - replace <b>setq</b> </li></ul><br>  Accordingly, the names of the derived functions and macros largely became derived from the base names: <br><ul><li>  <b>!!</b>  - replaces <b>defun</b> </li><li>  <b>##</b> - replaces <b>defmacro</b> </li><li>  <b>^^</b> - replace <b>list</b> </li><li>  <b>@%</b> - replaces <b>cadr</b> </li><li>  <b>%%</b> - replaces <b>cddr</b> </li><li>  <b>:</b> - replaces <b>let</b> for one variable </li><li>  <b>::</b> - replaces <b>let</b> without redundant brackets </li><li>  <b>&amp;</b> - replaces <b>and</b> </li><li>  <b>|</b>  - replaces <b>or</b> </li></ul><br>  Now consider the derived definitions.  We first define the basic abbreviations: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">=</span></span> @% (! (<span class="hljs-name"><span class="hljs-name">list</span></span>) (@ (% list)))) <span class="hljs-comment"><span class="hljs-comment">; cadr (= %% (! (list) (% (% list)))) ; cddr (= ^^ (! (_ . elts) elts)) ; list (= ## (# (name fargs . body) ; defmacro (^^ = name (^ # (^ fargs body))))) (## !! (name fargs . body) ; defun (^^ = name (^ ! (^ fargs body))))</span></span></code> </pre><br>  Pay attention to the dot notation of the list of formal arguments.  The character after the point captures the remaining actual parameters.  The case when all arguments are optional is described by a special notation: (_. Rest-args).  Next, we define a classic map and two paired list splits: <br><br><pre> <code class="lisp hljs">(!! map (<span class="hljs-name"><span class="hljs-name">func</span></span> list) (? list (^ (<span class="hljs-name"><span class="hljs-name">func</span></span> (@ list)) (<span class="hljs-name"><span class="hljs-name">map</span></span> func (% list))) _)) (!! pairs1 (<span class="hljs-name"><span class="hljs-name">list</span></span>) <span class="hljs-comment"><span class="hljs-comment">; (abcd) -&gt; ((ab) (bc) (cd)) (? (% list) (^ (^^ (@ list) (@% list)) (pairs1 (% list))) _)) (!! pairs2 (list) ; (abcd) -&gt; ((ab) (cd)) (? list (^ (^^ (@ list) (@% list)) (pairs2 (%% list))) _))</span></span></code> </pre><br>  We define two options for let: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">##</span></span> : (<span class="hljs-name"><span class="hljs-name">name</span></span> value . body) <span class="hljs-comment"><span class="hljs-comment">; simplified let (^^ (^ ! (^ (^^ name) body)) value)) (## :: (vars . body) ; let without redundant braces (= vars (pairs2 vars)) (^ (^ ! (^ (map @ vars) body)) (map @% vars)))</span></span></code> </pre><br>  Classic reverse and left convolution: <br><pre> <code class="lisp hljs">(!! reverse (<span class="hljs-name"><span class="hljs-name">list</span></span>) (: reverse+ _ (!! reverse+ (<span class="hljs-name"><span class="hljs-name">list</span></span> rlist) (? list (<span class="hljs-name"><span class="hljs-name">reverse+</span></span> (% list) (^ (@ list) rlist)) rlist)) (<span class="hljs-name"><span class="hljs-name">reverse+</span></span> list _))) (!! fold (<span class="hljs-name"><span class="hljs-name">list</span></span> func last) <span class="hljs-comment"><span class="hljs-comment">; (fold (' (ab)) fl) &lt;=&gt; (fa (fbl)) (? list (func (@ list) (fold (% list) func last)) last))</span></span></code> </pre><br>  Now if-based logical operators: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span> (' <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; true constant (!! ~ (bool) (? bool _ t)) ; not (## &amp; (_ . bools) ; and (: and (! (bool1 bool2) (^^ ? bool1 (^^ ? bool2 t _) _)) (fold bools and t))) (## | (_ . bools) ; or (: or (! (bool1 bool2) (^^ ? bool1 t (^^ ? bool2 t _))) (fold bools or _)))</span></span></code> </pre><br>  And, finally, comparison operators based on embedded&gt; (greater): <br><pre> <code class="lisp hljs">(: defcmp (! (<span class="hljs-name"><span class="hljs-name">cmp</span></span>) (<span class="hljs-name"><span class="hljs-name">#</span></span> (<span class="hljs-name"><span class="hljs-name">_</span></span> . nums) (: cmp+ (! (<span class="hljs-name"><span class="hljs-name">pair</span></span> bool) (^^ &amp; (<span class="hljs-name"><span class="hljs-name">cmp</span></span> (@ pair) (@% pair)) bool)) (<span class="hljs-name"><span class="hljs-name">fold</span></span> (<span class="hljs-name"><span class="hljs-name">pairs1</span></span> nums) cmp+ <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">=</span></span> == (<span class="hljs-name"><span class="hljs-name">defcmp</span></span> (! (<span class="hljs-name"><span class="hljs-name">num1</span></span> num2) (^^ &amp; (^^ ~ (^^ &gt; num1 num2)) (^^ ~ (^^ &gt; num2 num1)))))) (<span class="hljs-name"><span class="hljs-name">=</span></span> &gt;= (<span class="hljs-name"><span class="hljs-name">defcmp</span></span> (! (<span class="hljs-name"><span class="hljs-name">num1</span></span> num2) (^^ ~ (^^ &gt; num2 num1)))))) (<span class="hljs-name"><span class="hljs-name">##</span></span> &lt; (<span class="hljs-name"><span class="hljs-name">_</span></span> . nums) (^ &gt; (<span class="hljs-name"><span class="hljs-name">reverse</span></span> nums))) (<span class="hljs-name"><span class="hljs-name">##</span></span> &lt;= (<span class="hljs-name"><span class="hljs-name">_</span></span> . nums) (^ &gt;= (<span class="hljs-name"><span class="hljs-name">reverse</span></span> nums)))</code> </pre><br>  Notice that the last block of definitions explicitly uses a closure. <br><br><div class="spoiler">  <b class="spoiler_title">Full lib.l test</b> <div class="spoiler_text"><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;| Formal argument list notation: ([{arg1 [arg2 [arg3 ...]] | _} [. args]]) Number notation: ${double | ooctal | hhex} ; $4 $-2.2e3 $o376 $h7EF Built-in symbols: _ ; nil Built-in functions: @ (list) ; car % (list) ; cdr ^ (first rest) ; cons + (_ . nums) Built-in macros: trace (_ . body) ' (expr) ? (cond texpr fexpr) ; if with mandatory fexpr ! (args . body) ; lambda # (args . body) ; creates anonymous macro &gt; (_ . nums) |; (= @% (! (list) (@ (% list)))) ; cadr (= %% (! (list) (% (% list)))) ; cddr (= ^^ (! (_ . elts) elts)) ; list (= ## (# (name fargs . body) ; defmacro (^^ = name (^ # (^ fargs body))))) (## !! (name fargs . body) ; defun (^^ = name (^ ! (^ fargs body)))) (!! map (func list) (? list (^ (func (@ list)) (map func (% list))) _)) (!! pairs1 (list) ; (abcd) -&gt; ((ab) (bc) (cd)) (? (% list) (^ (^^ (@ list) (@% list)) (pairs1 (% list))) _)) (!! pairs2 (list) ; (abcd) -&gt; ((ab) (cd)) (? list (^ (^^ (@ list) (@% list)) (pairs2 (%% list))) _)) (## : (name value . body) ; simplified let (^^ (^ ! (^ (^^ name) body)) value)) (## :: (vars . body) ; let without redundant braces (= vars (pairs2 vars)) (^ (^ ! (^ (map @ vars) body)) (map @% vars))) (!! reverse (list) (: reverse+ _ (!! reverse+ (list rlist) (? list (reverse+ (% list) (^ (@ list) rlist)) rlist)) (reverse+ list _))) (!! fold (list func last) ; (fold (' (ab)) fl) &lt;=&gt; (fa (fbl)) (? list (func (@ list) (fold (% list) func last)) last)) (= t (' t)) ; true constant (!! ~ (bool) (? bool _ t)) ; not (## &amp; (_ . bools) ; and (: and (! (bool1 bool2) (^^ ? bool1 (^^ ? bool2 t _) _)) (fold bools and t))) (## | (_ . bools) ; or (: or (! (bool1 bool2) (^^ ? bool1 t (^^ ? bool2 t _))) (fold bools or _))) (: defcmp (! (cmp) (# (_ . nums) (: cmp+ (! (pair bool) (^^ &amp; (cmp (@ pair) (@% pair)) bool)) (fold (pairs1 nums) cmp+ t)))) (= == (defcmp (! (num1 num2) (^^ &amp; (^^ ~ (^^ &gt; num1 num2)) (^^ ~ (^^ &gt; num2 num1)))))) (= &gt;= (defcmp (! (num1 num2) (^^ ~ (^^ &gt; num2 num1)))))) (## &lt; (_ . nums) (^ &gt; (reverse nums))) (## &lt;= (_ . nums) (^ &gt;= (reverse nums)))</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the interpreter and most of the primitives are ready to write DSL assembler. </font><font style="vertical-align: inherit;">I will try‚Ä¶</font></font></div><p>Source: <a href="https://habr.com/ru/post/150805/">https://habr.com/ru/post/150805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150800/index.html">Microsoft Project delenda est</a></li>
<li><a href="../150801/index.html">A little bit about multi-threaded programming. Part 1. Synchronization is evil or not.</a></li>
<li><a href="../150802/index.html">7 lessons learned from creating Reddit</a></li>
<li><a href="../150803/index.html">JSON-RPC 2.0 and PHP</a></li>
<li><a href="../150804/index.html">Researchers uncover the location of the Pirate Bay uploaders</a></li>
<li><a href="../150806/index.html">Yii in phar</a></li>
<li><a href="../150807/index.html">Moscow Air Quality Monitoring System</a></li>
<li><a href="../150808/index.html">About sorting content based on user ratings: Part 2</a></li>
<li><a href="../150809/index.html">Base station 4G LTE on a regular PC</a></li>
<li><a href="../150810/index.html">Note to translators: speeding up ABBYY Lingvo and other tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>