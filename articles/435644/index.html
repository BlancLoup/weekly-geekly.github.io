<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Zoo afl phasers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© already appeared a couple of times the article raising the topic of American Fuzzy Lop (AFL) ( 1 , 2 ). But this article will not focus on cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Zoo afl phasers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/l4/vc/qr/l4vcqrdnz0vgsseyssmztrfrvdg.jpeg" alt="image"><br><br>  On Habr√© already appeared a couple of times the article raising the topic of American Fuzzy Lop (AFL) ( <a href="https://habrahabr.ru/post/259671/">1</a> , <a href="https://habrahabr.ru/post/332076/">2</a> ).  But this article will not focus on classic AFL, but on auxiliary utilities for it and its modifications, which, in our opinion, can significantly improve the quality of fuzzing.  If you are interested in learning how to pump AFL and look for faster and more vulnerabilities, then welcome under the cat! <br><a name="habracut"></a><br><h1>  What is AFL and why is it so good </h1><br>  AFL - Coverage-guided fuzzer or Feedback-based fuzzer.  Learn more about these concepts from a cool paper-like <a href="https://arxiv.org/pdf/1812.00140.pdf">Fuzzing: Art, Science, and Engineering</a> .  If we summarize information about AFL, we can say the following: <br><ul><li>  Tools the executable file to collect coverage information. </li><li>  Mutates the input data so that the coverage is maximum </li><li>  Repeats the previous step to find program crashes. <ul><li>  In practice, proven to be very effective. <ul><li>  Very easy to use </li></ul></li></ul></li></ul><br><br>  Graphically, this can be represented as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/iq/5z/au/iq5zaub6qftefx3x_q5te6d6guo.png" alt="image"><br><br>  If you do not know what AFL is, then we recommend to start: <br><br><ol><li>  <a href="http://lcamtuf.coredump.cx/afl/">Official project page</a> </li><li>  <a href="https://github.com/ThalesIgnite/afl-training">afl-training</a> - a brief excursion into AFL </li><li>  <a href="https://gitlab.com/wolframroesler/afl-demo">afl-demo</a> - a simple demonstration of how to fuzz a C ++ program using AFL </li><li>  <a href="https://github.com/mrash/afl-cve">afl-cve</a> ‚Äî Collection of vulnerabilities discovered using AFL (not updated since 2017) </li><li>  That AFL adds to the program during its assembly, you can read <a href="https://tunnelshade.in/blog/2018/01/afl-internals-compile-time-instrumentation/">here</a> </li><li>  Some useful tips for fuzzing network applications <a href="https://copyninja.info/blog/afl-and-network-programs.html">here.</a> </li></ol><br>  At the time of this writing, the latest version of AFL was version <a href="http://lcamtuf.coredump.cx/afl/">2.52b</a> .  Phazzer is actively developing, and over time, some third-party development included in the main branch of AFL and become in themselves irrelevant.  Currently, there are several useful supporting tools that can be identified - they are listed in the next section. <br><br><div class="spoiler">  <b class="spoiler_title">Rode0day competition</b> <div class="spoiler_text">  We should also mention the monthly competition <a href="https://rode0day.mit.edu/4">Rode0day</a> , where there is a competition between phasers who are faster and more will find vulnerabilities in pre-prepared buildings with access to the source code and without it.  And by and large is the confrontation of various modifications and forks AFL. <br></div></div><br>  However, some AFL users <a href="https://groups.google.com/forum/">note</a> that the author of phaser Michal Zalewski scored a campaign to support his offspring, since the latest changes date back to November 5, 2017.  This is supposedly attributed to his retirement from Google and new projects.  In this regard, people began to independently collect and make <a href="https://github.com/vanhauser-thc/afl-patches">patches of the</a> latest current version 2.52b. <br><br><img src="https://habrastorage.org/webt/fy/00/xa/fy00xat3cumh3iq9a5biou30czi.png" alt="image"><br><br>  There are also various options and derivatives from AFL that allow fuzzing Python, Go, Rust, OCaml, GCJ Java, kernel syscalls, or even entire VMs. <br><br><div class="spoiler">  <b class="spoiler_title">AFL for other PL</b> <div class="spoiler_text"><br>  - <a href="https://github.com/jwilk/python-afl">python-afl</a> - for Python. <br>  - <a href="">afl.rs</a> - for Rust fuzzing program <br>  - <a href="https://github.com/connor4312/js-fuzz">afl-fuzz-js</a> - afl-fuzz for javascript. <br>  - <a href="https://github.com/Barro/java-afl">java-afl</a> - AFL Fuzzing for Java <br>  - <a href="https://github.com/isstac/kelinci">kelinci</a> - another phaser for java with an <a href="https://www.modzero.ch/modlog/archives/2018/09/20/java_bugs_with_and_without_fuzzing/index.html">article</a> on this topic <br>  - <a href="https://github.com/cretz/javan-warty-pig">javan-warty-pig</a> - AFL-like fazzer for JVM. <br>  - <a href="https://github.com/Proteas/afl-swift">afl-swift</a> - for a swift program fuzzing <br>  - <a href="https://github.com/kayceesrk/ocamlopt-afl">ocamlopt-afl</a> - for OCaml. <br>  - <a href="https://github.com/Metalnem/sharpfuzz">sharpfuzz</a> - based on afl for .net fuzzer. <br></div></div><br><h1>  Auxiliary tools </h1><br>  In this section, we picked up various scripts and tools for working with AFL and divided them into several categories: <br><br>  <u>Kreshy</u> <br><br><ul><li>  <a href="https://gitlab.com/rc0r/afl-utils">afl-utils</a> is a set of utilities for automatic processing / analysis of kreshy and minimization of test cases. </li><li>  <a href="https://github.com/floyd-fuh/afl-crash-analyzer">afl-crash-analyzer</a> - Another Klesh analyzer for AFL. </li><li>  <a href="https://github.com/ThePatrickStar/fuzzer-utils">fuzzer-utils</a> - a set of scripts for analyzing the results. </li><li>  <a href="https://github.com/Ayrx/atriage">atriage</a> is a simple triage tool. </li><li>  <a href="https://github.com/kcwu/afl-kit">afl-kit</a> - Copied from afl-cmin. </li><li>  <a href="https://github.com/d33tah/aflize">AFLize</a> is a tool that automatically generates package debian builds suitable for afl. </li><li>  <a href="https://github.com/FoRTE-Research/afl-fid">afl-fid</a> - a set of tools for working with input data. </li></ul><br>  <u>Work with code coverage</u> <br><br><ul><li>  <a href="https://github.com/mrash/afl-cov">afl-cov</a> - provides human readable coverage data. </li><li>  <a href="https://github.com/Barro/count-afl-calls">count-afl-calls</a> ‚Äî rati score.  The script counts the number of instrumented blocks in a binary. </li><li>  <a href="https://github.com/bshastry/afl-sancov">afl-sancov</a> is like afl-cov, but uses a clang sanitizer. </li><li>  <a href="https://github.com/Cisco-Talos/covnavi">covnavi</a> is a script for code coverage and analysis from the Cisco Talos Group. </li><li>  <a href="https://gitlab.com/laf-intel/laf-llvm-pass/tree/master">LAF LLVM Passes</a> - something like a collection of patches for afl, which modify the code so that it is easier for the fuzzer to go through the branches </li></ul><br>  <u>Several scripts to minimize test cases</u> <br><br><ul><li>  <a href="https://github.com/ilsani/afl-pytmin">afl-pytmin</a> is a wrap for afl-tmin that attempts to speed up the process of minimizing the test case by using multiple CPU cores. </li><li>  <a href="https://github.com/MarkusTeufelberger/afl-ddmin-mod">afl-ddmin-mod</a> is a variation of afl-tmin based on the ddmin algorithm. </li><li>  <a href="https://github.com/googleprojectzero/halfempty">halfempty</a> is a fast utility based on parallelization to minimize test cases from Tavis Ormandy. </li></ul><br>  <u>For distributed start</u> <br><br><ul><li>  <a href="https://github.com/MartijnB/disfuzz-afl">disfuzz-afl</a> - distributed fuzzing for afl. </li><li>  <a href="https://github.com/quantumvm/AFLDFF">AFLDFF</a> is a framework for distributed fuzzing with AFL. </li><li>  <a href="https://github.com/bnagy/afl-launch">afl-launch</a> is a tool for launching a set of instances afl. </li><li>  <a href="https://github.com/afl-mothership/afl-mothership">afl-mothership</a> - manage and launch multiple synchronized AFL fuzzers on the AWS cloud. </li><li>  <a href="https://github.com/abhisek/afl-in-the-cloud">afl-in-the-cloud</a> is another script to run afl in AWS. </li><li>  <a href="https://github.com/clvang000/VU_BSc_project">VU_BSc_project</a> - fuzz testing of open source libraries with libFuzzer and AFL. </li></ul><br>  Also very recently a very good article <a href="https://gamozolabs.github.io/fuzzing/2018/09/16/scaling_afl.html">‚ÄúScaling AFL to a 256 thread machine‚Äù</a> was published on this topic, describing the launch of AFL on 256 threads. <br><br>  <u>Deployment, management, monitoring, reporting</u> <br><br><ul><li>  <a href="https://github.com/shellphish/afl-other-arch">afl-other-arch</a> is a set of patches and scripts for simply adding support for various (non-x86) architectures in AFL. </li><li>  <a href="https://github.com/bnagy/afl-trivia">afl-trivia</a> - several small scripts to simplify AFL management. </li><li>  <a href="https://github.com/reflare/afl-monitor">afl-monitor</a> is a script for monitoring AFL operation. </li><li>  <a href="https://github.com/zx1340/afl-manager">afl-manager</a> is a python web server for managing multi-afl. </li><li>  <a href="https://hub.docker.com/r/moflow/afl-tools/">afl-tools</a> is a docker image with afl-latest, afl-dyninst and Triforce-afl. </li><li>  <a href="https://github.com/block8437/afl-remote">afl-remote</a> is a web server for remote instantiation management afl. </li></ul><br><h1>  AFL modifications </h1><br>  The AFL has greatly influenced the vulnerability search community in the fuzzing direction itself.  And not surprisingly, over time, various modifications inspired by the original AFL began to appear on the basis of his ideas.  In this section, we consider them.  Each of these modifications has its own advantages and disadvantages compared to the original AFL version in different situations. <br><br>  We immediately say that if there are problems with the installation or do not want to waste time - almost any modification can be found on <a href="https://hub.docker.com/">hub.docker.com</a> <br><br>  What for? <br><br><ul><li>  Increase speed and / or code coverage <br><ul><li>  Algorithms </li><li>  Environment <br><ul><li>  OS </li><li>  Iron </li></ul><br></li></ul><br></li><li>  Work in conditions without source code <br><ul><li>  Code emulation </li><li>  Code Instrumentation <br><ul><li>  Static </li><li>  Dynamic </li></ul><br></li></ul><br></li></ul><br>  <u>Built-in AFL Modes</u> <br><br>  Before proceeding to the consideration of various modifications and forks AFL it is necessary to talk about two important modes, which were once also modifications, and over time became built-in modes.  This is Syzygy mode and Qemu mode. <br><br>  <a href="https://doar-e.github.io/blog/2017/08/05/binary-rewriting-with-syzygy/">Syzygy</a> mode - is the mode of operation in the instrument.exe tool <pre><code class="bash hljs">instrument.exe --mode=afl --input-image=test.exe --output-image=test.instr.exe</code> </pre>  This mode requires: Statically rewrite PE32 binaries with AFL, symbols are required, Requires additional dev to make WinAFL kernel aware. <br><br>  Qemu mode - How it works under QEMU, you can see here <a href="https://tunnelshade.in/blog/2018/02/afl-internals-qemu-instrumentation/">‚ÄúInternals of AFL fuzzer - QEMU Instrumentation‚Äù</a> .  Support for working with binaries using QEMU appeared in upstream AFL with Version 1.31b.  The afl qemu mode works with the added functionality of binary code instrumentation into the qemu tcg binary translation engine (tiny code generator).  To do this, afl has a qemu build script, which downloads the source code of a specific (2.10.0) version of qemu, imposes several small patches on them and compiles them for a given architecture.  After that, the file afl-qemu-trace, which is in fact a user-mode (emulation of only executable ELF files) emulation of qemu-, is submitted.  Thanks to this, fuzzing can be used with feedback on elf-binaries, and for a heap of different architectures supported by qemu.  In addition, you get all the cool tools afl, starting with a convenient screen with information about the current session and ending with advanced things like afl-analyze.  But we must remember that you also receive qemu restrictions.  Also, for example, if the file is assembled by a toolchain using SoC hardware features, on which the binary is run and which is not supported by qemu, the fuzzing will terminate as soon as a specific instruction is encountered, or, for example, a specific MMIO is used. <br><br>  There is also <a href="https://abiondo.me/2018/09/21/improving-afl-qemu-mode/">such an</a> interesting fork qemu mode, where the speed was increased 3x-4x due to TCG code instrumentation and caching. <br><br>  <u>Forks</u> <br><br>  The appearance of forks AFL is primarily associated with changes, improvements in the algorithms of the classic AFL. <br><br><ul><li>  <a href="https://github.com/arizvisa/afl-cygwin">afl-cygwin</a> is an attempt to port classic AFL to Windows using Cygwin.  Unfortunately, this attempt is quite basic, slow, and development can be said to be abandoned. </li><li>  <a href="https://github.com/mboehme/aflfast">AFLFast</a> (extends AFL with Power Schedules) is one of the first forks of AFL, all kinds of heuristics were added, thanks to which it could go more ways in a short period. </li><li>  <a href="https://github.com/carolemieux/afl-rb">FairFuzz</a> is an extension for AFL, the goal of which is to try to devote more time to rarer branches. </li><li>  <a href="https://github.com/aflgo/aflgo">AFLGo</a> is an extension for AFL, which is primarily intended for the targeted achievement of certain sections of code, rather than the general coverage of program code.  This can be used to test patches or newly added code patches. </li><li>  <a href="https://github.com/carolemieux/perffuzz">PerfFuzz</a> is an extension for AFL that is looking for test cases that could slow down the program as much as possible. </li><li>  <a href="https://github.com/mboehme/pythia">Pythia</a> is an extension for AFL, which is intended to add prediction elements to the phasing process in terms of the difficulty of finding new paths. </li><li>  <a href="https://github.com/AngoraFuzzer/Angora">Angora</a> is one of the most recent released fuzzers, written in rust.  Uses its new strategies for mutation and to increase coverage. </li><li>  <a href="https://github.com/Dongdongshe/neuzz">Neuzz</a> - <a href="https://github.com/Dongdongshe/neuzz">fuzzing</a> attempt using neural networks. </li><li>  <a href="https://github.com/FoRTE-Research/UnTracer-AFL">UnTracer-AFL</a> - afl integration with UnTracer, for efficient tracing. </li><li>  <a href="https://github.com/sslab-gatech/qsym/">Qsym</a> - Practical Concolic Execution Engine Tailored for Hybrid Fuzzing.  In essence, this is a symbolic character engine (the main components are implemented as a plug-in for intel pin), which in combination with afl implements hybrid fuzzing.  This is a further evolution in the feedback based fuzzing topic and deserves a separate discussion.  His main merit is that he can very quickly (relative to the others) perform the concolic execution.  This is due to the native execution of commands without intermediate code presentation, getting rid of the snapshot mechanism and a number of heuristics.  It uses the old Intel pin (due to a number of support problems between libz3 and other DBT), and can currently work with elf x86 and x86_64 architectures. </li></ul><br>  It is worth saying that there are a large number of academic works related to the implementation of new approaches, a fuzzing technician, where AFL is taken and modified.  In addition to whitepaper, nothing else is available, so we did not even mention such implementations.  If you're interested, they are easy to google.  For example, from the latter it is <a href="http://chao.100871.net/papers/oakland18.pdf">CollAFL: Path Sensitive Fuzzing</a> , <a href="https://arxiv.org/pdf/1807.00182.pdf">EnFuzz</a> , <a href="https://arxiv.org/pdf/1811.09447.pdf">Smart Greybox Fuzzing</a> , <a href="https://arxiv.org/pdf/1811.08973.pdf">ML</a> for afl. <br><br>  <u>Modifications based on Qemu</u> <br><br><ul><li>  <a href="https://github.com/nccgroup/TriforceAFL">TriforceAFL</a> - AFL / QEMU fuzzing with full <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2016/june/project-triforce-run-afl-on-everything/">system</a> emulation.  Fork from nccgroup.  Allows in qemu mode to fuzz the entire operating system.  Implemented through a special instruction (aflCall (0f 24)), which was added to QEMU x64 CPU.  Unfortunately, it is no longer supported, the latest version of afl is 2.06b. </li><li>  <a href="https://github.com/nccgroup/TriforceLinuxSyscallFuzzer">TriforceLinuxSyscallFuzzer</a> - fuzzing Linux system calls. </li><li>  <a href="https://github.com/kanglictf/afl-qai">afl-qai</a> is a small demo project with QEMU Augmented Instrumentation (qai). </li></ul><br><br>  <u>Modification based on KLEE</u> <br><br>  <a href="https://github.com/julieeen/kleefl">kleefl</a> - for generating test cases by means of symbolic execution (very slow on large programs). <br><br>  <u>Unicorn based modifications</u> <br><br>  <a href="https://github.com/Battelle/afl-unicorn">afl-unicorn</a> - allows you to fuzz pieces of code by emulating it on the <a href="https://www.unicorn-engine.org/">Unicorn Engine</a> .  We also successfully used this variation of AFL in our practice, namely, in sections of the code of one RTOS that was run on SOC, and it was impossible to use QEMU mode.  It is advisable to use this modification in the case when there are no sources (you cannot build a stand-alone binary for parser analysis) and the program does not accept input data directly (for example, it is encrypted or represents signal samples as in one CGC binary). to reverse and find the expected location-functions, where this data is processed in a convenient format for the fuzzer and which can be iterated.  This is the most common modification of AFL.  In the sense that it allows you to literally fuck everything.  That is, it does not depend on the architecture, the availability of sources, the format of the input data and the format of the binary itself (the most striking example of bare-metal is just pieces of code from the memory of the controller).  The researcher pre-examines this very binary and writes a fuzzer, which emulates the state at the input to the parser procedure, for example.  It can be seen that, unlike AFL, you need to first do some research on binaries.  For bare-metal firmware, such as Wi-Fi or baseband, there are just a number of drawbacks to keep in mind: <br><br><ol><li>  It is necessary to somehow localize the checksum check. </li><li>  It should be borne in mind that the state of a fuzzer is a state of memory that was stored in the memory dump, this may prevent the achievement of certain paths for the fuzzer. </li><li>  There is no sanitization of calls to dynamic memory, but it can be implemented manually (also by spending effort), and it will depend on RTOS (it must also be investigated beforehand). </li><li>  The cross-task interaction of RTOS is not emulated - it is also possible to prevent certain ways from being found by a fuzzer. </li></ol><br>  An example of working with this modification is <a href="https://hackernoon.com/afl-unicorn-fuzzing-arbitrary-binary-code-563ca28936bf">‚Äúafl-unicorn: Fuzzing Arbitrary Binary Code‚Äù</a> and <br>  <a href="https://hackernoon.com/afl-unicorn-part-2-fuzzing-the-unfuzzable-bea8de3540a5">‚ÄúAfl-unicorn: Part 2 - Fuzzing the 'Unfuzzable'‚Äù</a> . <br><br>  Before we proceed to the modifications based on dynamic binary instrumentation (DBI) frameworks, we immediately recall that DynamoRIO shows the highest speed of these frameworks, then DynInst and at the end PIN. <br><br>  <u>PIN based modifications</u> <br><br><ul><li>  <a href="https://github.com/mothran/aflpin">aflpin</a> - AFL with an Intel PIN tool. </li><li>  <a href="https://github.com/spinpx/afl_pin_mode">afl_pin_mode</a> - Another AFL tool implemented via an Intel PIN. </li><li>  <a href="https://github.com/vanhauser-thc/afl-pin">afl-pin</a> - AFL with PINtool. </li><li>  <a href="https://github.com/carlosgprado/NaFl">NaFl</a> - A clone (of the basic core) of AFL fuzzer. </li><li>  <a href="https://github.com/houcy/PinAFL">PinAFL</a> - the author of the tool tried to transfer AFL to Windows for fuzzing already compiled binaries.  Apparently, more was done for fan in one evening, and then the project does not develop.  The repository does not contain source codes, only collected binaries and instructions for launching.  The AFL version on which this tool is based is not listed, and only supports 32-bit applications. </li></ul><br>  As you can see, there are a lot of different modifications, but there is not much use of them in real life. <br><br>  <u>Dyninst based modifications</u> <br><br>  <a href="https://github.com/talos-vulndev/afl-dyninst">afl-dyninst</a> - American Fuzzy Lop + Dyninst == AFL blackbox fuzzing.  The chip of this version is that the program originally examined (without the source code) is statically instrumented (static binary instrumentation, static binary rewriting) using DynInst, and then fuzzing with a classic AFL that thinks the program is built using afl-gcc / afl -g ++ / afl-as;) As a result, it gives us the opportunity to work without source code and with very good performance - It used to be at 0.25x speed compared to a native compile.  At the same time, there is a significant advantage over QEMU, which is the ability to instrument dynamically linked libraries.  At the same time, QEMU is only able to instrument the main executable file statically linked with the libraries.  Unfortunately, now this is only relevant for the Linux operating system.  Windows support requires changes in DynInst itself, and <a href="https://github.com/dyninst/dyninst/issues/120">work</a> is under <a href="https://github.com/dyninst/dyninst/issues/120">way</a> on this. <br><br>  You can also pay attention to such a <a href="https://github.com/vanhauser-thc/afl-dyninst">fork</a> where it is pumped well for various features (support for AARCH64 and PPC architectures) and speed;) <br><br>  <u>Modifications based on DynamoRIO</u> <br><br><ul><li>  <a href="https://github.com/mxmssh/drAFL">drAFL</a> - AFL + DynamoRIO = fuzzing without source on Linux. </li><li>  <a href="https://github.com/atrosinenko/afl-dr">afl-dr</a> is another implementation based on DynamoRIO, which is already described in great detail in the open spaces of Habr. </li><li>  <a href="https://github.com/vanhauser-thc/afl-dynamorio">afl-dynamorio</a> - a modification from vanhauser-thc (amateur pumping and stabilizing AFL).  about this version, he says so: ‚Äúrun AFL with DynamoRIO when normal afl-dyninst is crashing.‚Äù  From pleasant there is added support for ARM and AARCH64.  With regards to performance: DynamoRIO is about ~ 10 slower than Qemu, ~ 25 slower than dyninst - but ~ 10 faster than Pintool. </li><li>  <a href="https://github.com/ivanfratric/winafl">WinAFL</a> is the most famous afl for Windows fork.  (DynamoRIO, there is also syzygy mode).  The appearance of this modification was only a matter of time, since the desire to try out the AFL under Windows on applications for which there are no source codes appeared to many.  At the moment, the tool is being actively developed, and despite the use of a slightly lagging AFL code base, (2.43b at the time of this writing), several vulnerabilities have already been found with it (CVE-2016-7212, CVE-2017-0073, CVE-2017- 0190, CVE-2017-11816).  It should be noted that the main developers are specialists from the Google Zero Project team and MSRC Vulnerabilities and Mitigations Team, which gives reason to hope for further active development of the project.  To implement a fuzzer, developers left compile time instrumentation to use dynamic instrumentation (based on DynamoRIO), which was expected to slow down the execution of the software being studied, but the resulting overhead (two-fold) is comparable to the work of classical AFL in binary mode.  Also, the developers have solved the question of a long start of the process, calling it persistent fuzzing mode, they choose the function that needs to be fuzzed (by offset within the file or by name if the function is presented in the export table) and instruct it so that it can be called in a loop, thereby running multiple input data samples without restarting the process.  Also, an interesting <a href="https://research.checkpoint.com/50-adobe-cves-in-50-days/">article</a> recently appeared in which researchers showed how they found ~ 50 vulnerabilities with winafl in ~ 50 days.  At the same time, almost before the publication of the article in WinAFL, Intel PT mode was also added (more on this a little further) - the details are <a href="">here</a> . </li></ul><br>  The advanced / sophisticated reader may note that there are modifications with all popular instrumentation frameworks, with the exception of <a href="https://www.frida.re/">Frida</a> - indeed it is.  The only mention of using Frida with AFL was found only in <a href="http://wpage.unina.it/roberto.natella/papers/natella_androidfuzzing_issre2017.pdf">Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations</a> .  The AFL version with Frida was really useful since Frida well supports a number of RISC architectures. <br><br>  Many researchers are also eagerly awaiting the release of the DBI framework Scorpio from the creator of Capstone, Unicorne, Keystone.  Based on this framework, the authors themselves have already made a fuzzer (Darko) and, according to them, successfully use it for fuzzing embedded devices.  Read more about this in <a href="https://conference.hitb.org/hitbsecconf2018pek/materials/D2T1%2520-%2520Finding%25200days%2520in%2520Embedded%2520Systems%2520with%2520Code%2520Coverage%2520Guided%2520Fuzzing%2520-%2520Dr%2520Quynh%2520and%2520Kai%2520Jern%2520Lau.pdf">‚ÄúDigging Deep: Finding 0days in Embedded Systems with Code Coverage Guided Fuzzing‚Äù</a> . <br><br>  <u>Modifications based on CPU hardware</u> <br><br>  When it comes to AFL modifications with support for the processor's hardware capabilities, this first of all indicates the possibility of fuzzing kernel code, and secondly, a higher fuzzing rate for applications without source code. <br><br>  And, of course, first of all, we are talking about the hardware capabilities of the processor, like <a href="https://software.intel.com/en-us/node/721535">Intel PT</a> (Processor Tracing).  Which is available starting from the 6th generation of processors (approximately from 2015).  Naturally, in order to use the following fuzzers, you will need hardware with the appropriate support for Intel PT. <br><br><ul><li>  <a href="https://github.com/intelpt/winafl-intelpt">WinAFL-IntelPT</a> is a third-party modification of WinAFL that already uses Intel PT technology instead of DynamoRIO. </li><li>  <a href="https://github.com/RUB-SysSec/kAFL">kAFL</a> is an academic development aimed at solving the problem of coverage-guided for kernel phasing in an OS in an independent manner.  What is solved by using the hypervisor and Intel PT technology.  Learn more from their whitepaper, <a href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-schumilo.pdf">‚ÄúkAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels‚Äù</a> . </li></ul><br><h1>  Conclusion </h1><br>  As you can see, this topic is actively developing.  At the same time there is a large space for creativity to create a new, interesting and useful modification of AFL. <br><br>  Thank you for your attention and successful fuzzing! <br><br>  <b>Coauthor:</b> Nikita Knizhov <br><br>  <i>PS Thanks to the whole team of the research center for their help in preparing this material, without their experience and help to prepare such a thing would be impossible.</i> </div><p>Source: <a href="https://habr.com/ru/post/435644/">https://habr.com/ru/post/435644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435630/index.html">Network security in the cloud: 5 trends in 2019</a></li>
<li><a href="../435636/index.html">How to learn using machine learning from Dota 2 experts</a></li>
<li><a href="../435638/index.html">About the happiness of developers and where to find it</a></li>
<li><a href="../435640/index.html">The event digest for HR-specialists in the field of IT in January 2019</a></li>
<li><a href="../435642/index.html">Pentax Auto 110: ‚Äúin which cam the camera?‚Äù</a></li>
<li><a href="../435646/index.html">NB-IoT, Narrow Band Internet of Things. General information, technology features</a></li>
<li><a href="../435648/index.html">Bot generates textbooks from Wikipedia articles</a></li>
<li><a href="../435650/index.html">How to embed C-library in Swift-framework</a></li>
<li><a href="../435652/index.html">How not to continue passwords in Python scripts</a></li>
<li><a href="../435654/index.html">Pitfalls of custom CSS properties</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>