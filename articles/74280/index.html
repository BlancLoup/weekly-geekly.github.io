<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recursive LISP programming - formula solver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The formula solver is in itself a very interesting workout, and at a certain point this workout can be very useful in another task - designing a new f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recursive LISP programming - formula solver</h1><div class="post__text post__text-html js-mediator-article">  The formula solver is in itself a very interesting workout, and at a certain point this workout can be very useful in another task - designing a new formula, automatically checking it (error, calculating the values ‚Äã‚Äãaccording to the list of coordinates) ... And excel does not help you, and is unsportsmanlike. <br><br><a name="habracut"></a><br>  Immediately make a reservation - the code is made for LISP sample of '87, and the fresh Common LISP will not understand it categorically, which is sad ... But - 2 steps from LISP code to understanding how to write the same thing in a more decent for practical task C # or Delphi, in LISP, a more sweet performance is given to my heart and eye) <br><br>  Entering a formula from the keyboard, against a hard task in the code, has a lot of advantages.  How to implement it, the programmer thought, perhaps, from the school iron chair.  The task is great, and it seems impossible, but the main thing is to start.  Getting &gt;&gt; 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  1. How will the formula be written? </h2><br>  Regular entry for the first step is unnecessarily complicated.  Polish form of record - use it.  And operations on numbers are written in the form of lists, which can be set the most complex mathematical expression: <br>  # <br> <code><b>2+3-&gt;(+ 2 3) <br> 2-3-&gt;(- 2 3) <br> 2*3-&gt;(* 2 3) <br> 2/3-&gt;(/ 2 3) <br> 2+3+5-&gt;(+ 2 3 5) <br> 2+3*5-&gt;(+ 2 (* 3 5)) <br> (2+3)*5-&gt;(* (+ 2 3) 5) <br></b></code> <br><br><h2>  2. How will it work?  (simple formulas) </h2><br><br>  We will write a solver (solver) in the revo ... recursive spirit of LISP: he will grab the first element from the list of the head, and then process the tail in accordance with the head value.  At the input, the solver receives each time the formula (a), the result of the previous action (b), the sign ¬© and, if foreseen in advance, then the values ‚Äã‚Äãof the unknown parameters (xx). <br><br> <code><b>(defun solver (abc xx) <br> ((null a) b) <br> ((equal (searchx a) NIL) (solver (presolver a NIL xx) T c xx)) <br> ((eq (atom a) T) a) <br> ((equal c NIL) (solver (cdr (cdr a)) (car (cdr a)) (car a) xx)) <br> ((equal c ps) (solver (cdr a) (+ b (car a)) c xx)) <br> ((equal c ms) (solver (cdr a) (- b (car a)) c xx)) <br> ((equal c mu) (solver (cdr a) (* b (car a)) c xx)) <br> ((equal c di) (solver (cdr a) (/ b (car a)) c xx)) <br> ) <br></b></code> <br><br>  Unknown parameters specified in the formula with their own names # (+ x 5)) should replace the corresponding function with values.  And to the solver.  We call it a predecessor (presolver), feed the formula, the result (when called from the solver, NIL) and the value of the unknown element for substitution of the element 'x' (I single it out here specifically, for LISP does not distinguish, thank God, data types) <br><br> <code><b>(defun presolver (ab xx) <br> ((null a) (revers b)) <br> ((eq (car a) x) (presolver (cdr a) (cons xx b) xx)) <br> ((eq (equal (car a) x) NIL) (presolver (cdr a) (cons (car a) b) xx)) <br> ) <br></b></code> <br><br>  And - the presence of unknowns still need to be confirmed.  The search function of the unknown is born, searchx, and at the same time the reverse function of the revers list, for the result of presolver, by default, goes backwards. <br><br> <code><b>(defun searchx (a) <br> ((null a) T) <br> ((equal (car a) x) NIL) <br> (searchx (cdr a)) <br> ) <br></b></code> <br><br> <code><b>(defun revers (ab) <br> ((null a) b) <br> (revers (cdr a) (cons (car a) b)) <br> ) <br></b></code> <br><br>  Run-check- <br><br> <code><b>(solver '(ps x 2 3) NIL NIL 5)</b></code> <br> <br>  -ura-works.  But - only on simple formulas, with lists without nested lists, with atom elements. <br><br><h2>  3. How will it work-2?  (complex formulas) </h2><br><br>  You can think for a long time how to turn a simple solver into an interesting way in an interesting way, but we will go in a more rational way - we will not touch the working piece, but let us work on the project solver2 - the solver of complex formulas. <br><br> <code><b>(defun solver2 (a xx) <br> ((eq (iseasy a) T) <br> (solver a NIL NIL xx)) <br> ((eq (atom (car a)) T) <br> (solver (cons (car a) (solver2 (cdr a) xx)) NIL NIL xx)) <br> ((eq (iseasy (car a)) T) <br> (cons (solver (car a) NIL NIL xx) (solver2 (cdr a) xx))) <br> ((eq (iseasy (car a)) NIL) <br> (cons (solver2 (car a) xx) (solver2 (cdr a) xx))) <br> ) <br></b></code> <br><br>  Each complex formula contains at least one list element.  But let's start with the compatibility problem, so that the new function works at least for simple calculations.  To do this, you need to check the input formula for simplicity, and if it's simple, send it to the solver, but if it's difficult, think about it a little more. <br><br>  The iseasy function with a single input parameter, the formula itself, can help you define a simple list or not quite.  Iseasy sees the element non-atom - and falls with the answer NIL <br><br> <code><b>(defun iseasy (a) <br> ((null a) T) <br> ((equal (atom (car a)) Nil) NIL) <br> (iseasy (cdr a)) <br> ) <br></b></code> <br><br>  Then everything is simple, and at the same time elegantly incomprehensible.  The correct operation of the function is obvious, but the algorithm is not obvious.  He is: <br>  - First, solver2 checks the formula entirely for simplicity.  If the formula is simple entirely, it can and should be solved by solver. <br>  - Next, there is a check - ‚Äúis it not the atom's head at the formula 'a'?‚Äù If the head is an atom, then we send the solver constructor from this atom and tail, which requires re-consideration of solver2 <br>  - If the first 2 checks did not pass, something with the formula is definitely wrong (it seems to me 2 years after writing the code), then we should check the formula head for simplicity, and if that is simple (BUT not an atom! - and that means the list ), we will send the construction of the resolved head and the reversed solver2 tail of the formula to the launching solver2 function.  For example, "on the screen" ... Perhaps this is some kind of bugreport? <br>  - If the first 3 checks have not passed (quite a disaster, it means that the formula is not simple, in the head of this formula there is not an atom (that is, not the ¬± / * / :) sign, and not even a list of atoms, we will issue "on the screen "A design from the resurrected solver2 head and tail, also with revision solver2 <br><br>  Run ... <br> <code><b>(solver2 '(mu (ps x 2 3) (ms x 5)) 10)</b></code> <br>  Be surprised <br><br><h2>  4. Why does it work?  (conclusion) </h2><br><br>  Obviously, solver2 in the above code can read simple formulas.  But how, running it, he considers and complex?  Vision in recursive programming is very deceptive. <br><br>  Each correct formula starts with an atom of operation.  Follow the actions of LISP, reader: solver2 begins to solve the correct complex formula, and sends to the solver a construction from the head of this formula (sign), and ... a revised tail in itself.  The tail comes to solver2 and, naturally, does not contain an operation atom in the head.  Therefore, solver2 is deservedly sent to further simplify ... <br><br>  What is his essence, what is he doing, this solver2?  In general, nothing even simpler - he takes the list and replaces it with a number ... In the end, any arbitrarily long formula, even with a 10-fold nesting, will collapse to a simple list, with a sign in his head and a tail consisting of only atoms, with all atoms being numbers.  It is beautiful, and absolutely incomprehensible by the code, incomprehensible and at the first step of writing the function) ... For which the RP I love. </div><p>Source: <a href="https://habr.com/ru/post/74280/">https://habr.com/ru/post/74280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../74273/index.html">MongoDB - make good coffee</a></li>
<li><a href="../74275/index.html">Co-working in Minsk!</a></li>
<li><a href="../74277/index.html">re: sad statistics</a></li>
<li><a href="../74278/index.html">Project Note</a></li>
<li><a href="../74279/index.html">Alltopnews.ru - blog ranking based on the Yandex. Blogs API</a></li>
<li><a href="../74281/index.html">NNcron script for automatic regular downloading of antiviruses and uploading to a USB flash drive</a></li>
<li><a href="../74282/index.html">Remote debugging of pages using Opera Dragonfly</a></li>
<li><a href="../74283/index.html">How I built my data center - part three. The magic of electricity and cold</a></li>
<li><a href="../74284/index.html">A serious vulnerability has been found in the Linux kernel.</a></li>
<li><a href="../74288/index.html">Bookmarks and Javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>