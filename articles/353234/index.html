<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part XIX: Deploying Based on Docker Containers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(edition 2018) 
 Miguel grinberg 



 There 


 This is the nineteenth part of the Flask mega-tutorial series in which I am going to deploy Microblog ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part XIX: Deploying Based on Docker Containers</h1><div class="post__text post__text-html js-mediator-article"><h2 id="izdanie-2018">  (edition 2018) </h2><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/352830/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This is the nineteenth part of the Flask mega-tutorial series in which I am going to deploy Microblog on the Docker platform. </p><a name="habracut"></a><br><p>  Under the spoiler is a list of all articles in this 2018 series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> (This article) </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  Chapter 21: User Notifications (Available April 24, 2018) </li><li>  Chapter 22: Reference Tasks (Available May 1, 2018) </li><li>  Chapter 23: Application Programming Interfaces (APIs) (Available May 8, 2018) </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work, or simply do not have the patience to wait for the article for a week, I (Miguel Greenberg) offer the full version of this manual (in English) in the form of an electronic book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  In <a href="https://habrahabr.ru/post/352266/">Chapter 17,</a> you learned about traditional deployments, in which you should take care of every little aspect of server configuration.  Then, in <a href="https://habrahabr.ru/topic/edit/352830/">Chapter 18,</a> I brought you to another extreme when I introduced you to Heroku, a service that completely controls the configuration and deployment tasks.  In this chapter, it‚Äôs time to learn about the deployment strategy for third-party container-based applications, particularly on the <a href="https://www.docker.com/">Docker</a> container platform.  This third option is the "golden mean" between the other two. </p><br><p>  Containers are built on the basis of a simplified virtualization technology, which allows an application, along with its dependencies and configuration, to work in complete isolation, but without the need for a full-featured virtualization solution, such as virtual machines, that require significantly more resources and can sometimes have a significant decrease in performance. compared to the host.  A system configured as a container node can run multiple containers, all of which share the host core and have direct access to the host hardware.  This is in contrast to virtual machines, which must emulate a complete system, including a processor, disk, other hardware, a kernel, etc. </p><br><p>  Although we do not share the core, the isolation level in the container is quite high.  The container has its own file system and may be based on an operating system other than that used by the container node.  For example, you can run Ubuntu Linux-based containers on a Fedora site or vice versa.  Despite the fact that containers are a technology that is native to the Linux operating system, thanks to virtualization, you can run Linux containers on Windows and Mac OS X hosts.  This allows you to test deployments in the development system, as well as include containers in the development workflow, if you need it. </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="ustanovka-docker-ce">  Install Docker CE </h2><br><p>  Although Docker is not the only container platform, it is by far the most popular, so this will be my choice.  There are two Docker releases, the Free community edition (CE) edition and the Subscription-based Enterprise edition (EE) edition.  For the purposes of this tutorial, Docker CE is quite adequate. </p><br><p>  To work with Docker CE, you first need to install it on your system.  There are installers for Windows, Mac OS X, and several Linux distributions available on <a href="https://www.docker.com/community-edition">the Docker website</a> .  If you are running Microsoft Windows, it is important to note that Docker CE requires Hyper-V.  The installer will enable it for you if necessary, but keep in mind that turning on Hyper-V prevents other virtualization technologies from working, such as VirtualBox. </p><br><p>  After installing Docker CE in the system, you can verify the success of the installation by entering the following command in a terminal window or command line: </p><br><pre><code class="hljs pgsql">$ docker <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> Client: <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">17.09</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-ce API <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-number"><span class="hljs-number">1.32</span></span> Go <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: go1<span class="hljs-number"><span class="hljs-number">.8</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> Git <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>: afdb6d4 Built: Tue Sep <span class="hljs-number"><span class="hljs-number">26</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">40</span></span>:<span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> OS/Arch: darwin/amd64 <span class="hljs-keyword"><span class="hljs-keyword">Server</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">17.09</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>-ce API <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-number"><span class="hljs-number">1.32</span></span> (minimum <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-number"><span class="hljs-number">1.12</span></span>) Go <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: go1<span class="hljs-number"><span class="hljs-number">.8</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> Git <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>: afdb6d4 Built: Tue Sep <span class="hljs-number"><span class="hljs-number">26</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">45</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span> <span class="hljs-number"><span class="hljs-number">2017</span></span> OS/Arch: linux/amd64 Experimental: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><h2 id="postroenie-obraza-konteynera">  Build container image </h2><br><p>  The first step in creating a microblog container is to create an <em>image</em> for it.  A container image is a template that is used to create a container.  It contains a complete view of the container file system, as well as various network-related settings, launch options, etc. </p><br><p>  The easiest way to create a container image for an application is to run the container for the base operating system you want to use (Ubuntu, Fedora, etc.)., Connect to the bash shell process running in it, and then manually install the application, perhaps following the recommendations I presented in <a href="https://habrahabr.ru/post/352266/">chapter 17</a> for traditional deployment.  After installing everything you can take a snapshot of the container, which will become the image.  This type of workflow is supported by the <code>docker</code> team, but I‚Äôm not going to discuss it because it‚Äôs not convenient to manually install the application every time you need to create a new image. </p><br><p>  The best approach is to create a container image using a script.  The team that creates container images with scripts is <code>docker build</code> .  This command reads and executes build instructions from the <em>Dockerfile</em> file, which I have yet to create.  Dockerfile is actually an installation script that performs installation steps to deploy an application, as well as some container parameters. </p><br><p>  Here is the basic <em>Dockerfile</em> for Microblog: </p><br><blockquote>  Dockerfile: Dockerfile for Microblog. </blockquote><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> python:<span class="hljs-number"><span class="hljs-number">3.6</span></span>-alpine RUN adduser -D microblog WORKDIR /home/microblog <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> requirements.txt requirements.txt RUN python -m venv venv RUN venv/bin/pip install -r requirements.txt RUN venv/bin/pip install gunicorn <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> app app <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> migrations migrations <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> microblog.py config.py boot.sh ./ RUN chmod +x boot.sh ENV FLASK_APP microblog.py RUN chown -R microblog:microblog ./ <span class="hljs-keyword"><span class="hljs-keyword">USER</span></span> microblog EXPOSE <span class="hljs-number"><span class="hljs-number">5000</span></span> ENTRYPOINT ["./boot.sh"]</code> </pre> <br><p>  Each line in the Dockerfile is a command.  The <code>FROM</code> command specifies the base image of the container on which the new image will be built.  The idea is that you start with an existing image, add or change some features, and ultimately get a derived image.  The image is referenced by name and tag, separated by a colon.  The tag is used as a version control mechanism, allowing the container image to provide several options.  The name of the selected image is <code>python</code> , which is the official Docker image for Python.  The tags for this image allow you to specify the version of the interpreter and the base operating system.  The <code>3.6-alpine</code> tag selects the Python 3.6 interpreter installed in Alpine Linux.  The Alpine Linux distribution is often used in place of more popular ones, such as Ubuntu due to its small size.  You can see which tags are available for the Python image in the <a href="https://hub.docker.com/r/library/python/tags/">Python image repository</a> . </p><br><p>  The <code>RUN</code> command executes an arbitrary command in the context of the container.  This is similar to typing a command in the shell command line.  The <code>adduser-D microblog</code> command creates a new user called <code>microblog</code> .  Most container images have <code>root</code> as the default user, but it is not recommended to run the application as root, so I create my own user. </p><br><p>  The <code>WORKDIR</code> command sets the default directory where the application will be installed.  When I created the <code>microblog</code> user above, the home directory was created, so now I make this directory the default.  The new default directory will be applied to all remaining commands in the Dockerfile, as well as later when the container is executed. </p><br><p>  The <code>COPY</code> transfers files from the computer to the file system of the container.  This command takes two or more arguments, source and destination files or directories.  The source file (s) must be relative to the directory in which the Dockerfile is located.  The assignment can be an absolute path or a path relative to the directory specified in the previous <code>WORKDIR</code> .  In this first copy command, I copy the <em>requirements.txt</em> file to the home directory of the <code>microblog</code> user in the container file system. </p><br><p>  Now I have the <em>requirements.txt</em> file in the container and I can create a virtual environment using the <code>RUN</code> command.  First I create it, and then I set all the requirements.  Since the requirements file contains only general dependencies, I then explicitly install <em>gunicorn</em> , which I am going to use as a web server.  Alternatively, I could add <em>gunicorn</em> to my files in <em>requirements.txt</em> . </p><br><p>  Three <code>COPY</code> commands that follow the installation of the application into the container, copying the <em>app</em> package, the <em>migrations</em> directory with database migrations, and the <em>microblog.py</em> and <em>config.py</em> scripts from the top-level directory.  In addition, I copy the new boot.sh file, which I will discuss below. </p><br><p>  The <code>RUN chmod</code> ensures that this unknown hitherto unknown <em>boot.sh</em> file <em>is</em> installed correctly, like an executable file.  If you are in a Unix-based file system, and your source file already has the sign of an executable file, then the executable bit will also be set in the copied file.  I added an explicit install, because on Windows it‚Äôs harder to assign executable bits.  If you are running Mac OS X or Linux, this is probably not necessary, but it doesn‚Äôt hurt anyway. </p><br><p>  The <code>ENV</code> command sets the environment variable inside the container.  I need to install <code>FLASK_APP</code> , which is required to use <code>flask</code> . </p><br><p>  The following command <code>RUN chown</code> sets the owner of all directories and files that were stored in <em>/ home / microblog</em> , as a new <code>microblog</code> user.  Despite the fact that I created this user in the root Dockerfile, the default User remained <code>root</code> for all commands, so all these files must be switched to the <code>microblog</code> user so that this user can work with them when the container is started. </p><br><p>  The <code>USER</code> command in the next line makes this new <code>microblog</code> user the default for any subsequent instructions, as well as when the container is started. </p><br><p>  The <code>EXPOSE</code> command sets the port for its server.  This is necessary so that Docker can properly configure the Network in the container.  I chose the standard port 5000, but it can be any port. </p><br><p>  Finally, the <code>ENTRYPOINT</code> command determines the default for the command to be executed when the container is started.  This is the command that will launch the web application server.  For everything to be well organized, I decided to create a separate script for this, and this is the <em>boot.sh</em> file that I copied into the container earlier.  Here are the contents of this script: </p><br><blockquote>  boot.sh: Docker container start-up script. </blockquote><br><pre> <code class="hljs mel">#!/bin/sh <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> venv/bin/activate flask db upgrade flask translate compile <span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> gunicorn -b :<span class="hljs-number"><span class="hljs-number">5000</span></span> --access-logfile - --<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>-logfile - microblog:app</code> </pre> <br><p>  This is a fairly standard startup script, which is quite similar to how the deployments were launched in <a href="https://habrahabr.ru/post/352266/">Chapter 17</a> and <a href="https://habrahabr.ru/topic/edit/352830/">Chapter 18</a> .  I activate the virtual environment, update the database through the migration platform, compile translations of languages, and finally start the server with <em>gunicorn</em> . </p><br><p>  Notice the <code>exec</code> that precedes the gunicorn command.  In a shell script, <code>exec</code> starts a process that executes a script that needs to be replaced by a given command, instead of starting it as a new process.  This is important because Docker connects the life of the container with the first process that runs on it.  In cases like this, when the startup process is not the main container process, you need to make sure that the main process takes the place of this first process to make sure that the container does not complete early Docker. </p><br><p>  An interesting aspect of Docker is that all container output that is written to <code>stdout</code> or <code>stderr</code> will be captured and saved as container logs.  For this reason, the <code>--access-logfile</code> and <code>--error-logfile</code> have a - at the end, which sends the log to standard output and stores it as a Docker log. </p><br><p>  With the help of the created Dockerfile, you can now create an image of the container: </p><br><pre> <code class="hljs ruby">$ docker build -t <span class="hljs-symbol"><span class="hljs-symbol">microblog:</span></span>latest .</code> </pre> <br><p>  The <code>-t</code> argument passed to the <code>docker build</code> sets the name and tag for the new container image. <code>.</code>  specifies the base directory in which the container should be created.  This is the directory where the Docker file is located.  The build process will evaluate all the commands in the Docker file and create an image that will be stored on your own machine. </p><br><p>  You can get a list of images that you use locally using the <code>docker images</code> : </p><br><pre> <code class="hljs vbscript">$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE microblog latest <span class="hljs-number"><span class="hljs-number">54</span></span>a47d0c27cf About a <span class="hljs-built_in"><span class="hljs-built_in">minute</span></span> ago <span class="hljs-number"><span class="hljs-number">216</span></span>MB python <span class="hljs-number"><span class="hljs-number">3.6</span></span>-alpine a6beab4fa70b <span class="hljs-number"><span class="hljs-number">3</span></span> months ago <span class="hljs-number"><span class="hljs-number">88.7</span></span>MB</code> </pre> <br><p>  This list includes your new image, as well as the base on which it was built.  When making changes to the application, you can update the image of the container by running the build command again. </p><br><h2 id="zapusk-konteynera">  Container run </h2><br><p>  With the already created image, you can now launch the version of the application container.  This is done using the <code>docker run</code> , which usually takes a large number of arguments.  First, I'll show you a simple example: </p><br><pre> <code class="hljs pgsql">$ docker run <span class="hljs-comment"><span class="hljs-comment">--name microblog -d -p 8000:5000 --rm microblog:latest 021da2e1e0d390320248abf97dfbbe7b27c70fefed113d5a41bb67a68522e91c</span></span></code> </pre> <br><p>  The <code>--name</code> parameter provides the name for the new container.  The <code>-d</code> tells Docker to start the container in the background.  Without the <code>-d</code> switch, the container runs as a foreground application, blocking the command line.  The <code>-p</code> maps container ports to host ports.  The first port is the port on the host computer, and the port on the right is the port inside the container.  The above example provides port 5000 in a container on port 8000 in a node, so you will access the application on 8000, even though the internal container uses 5000. The <code>--rm</code> parameter removes the container after it completes.  Although this is not required, containers that end or break are usually no longer needed, so they can be automatically removed.  The final argument is the name of the container image and the tag used for the container.  After executing the above command, you can access the application at <em><a href="http://localhost:8000/">http: // localhost: 8000</a></em> . </p><br><p>  The result of the <code>docker run</code> is the identifier assigned to the new container.  This is a long hexadecimal string that you can use when you need to reference the container in subsequent commands.  In fact, only the first few characters are needed to make the identifier unique. </p><br><p>  If you want to see which containers are running, you can use the <code>docker ps</code> : </p><br><pre> <code class="hljs erlang-repl">$ docker ps CONTAINER ID IMAGE COMMAND PORTS NAMES <span class="hljs-number"><span class="hljs-number">021</span></span>da2e1e0d3 microblog:latest <span class="hljs-string"><span class="hljs-string">"./boot.sh"</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">0.0</span></span>:<span class="hljs-number"><span class="hljs-number">8000</span></span>-&gt;<span class="hljs-number"><span class="hljs-number">5000</span></span>/tcp microblog</code> </pre> <br><p>  As you can see, even the <code>docker ps</code> shortens the ids of the containers.  If you now need to stop the container, use <code>docker stop</code> : </p><br><pre> <code class="hljs go">$ docker stop <span class="hljs-number"><span class="hljs-number">021d</span></span>a2e1e0d3 <span class="hljs-number"><span class="hljs-number">021d</span></span>a2e1e0d3</code> </pre> <br><p>  Let me remind you that, in the application configuration, there are several parameters that are derived from environment variables.  For example, the parameters of the Flask secret key, the database URL and the email server are imported from the environment variables.  In the <code>docker run</code> example above, I didn‚Äôt worry about them, so all these configuration parameters will use the default values. </p><br><p>  In a more realistic example, these environment variables will be set inside the container.  You saw in the previous section that setting the environment variables in the <em>Dockerfile</em> is done by the <code>ENV</code> command, and this is a handy option for variables that will be static.  However, for installation-dependent variables, it is not possible to use them as part of the build process, because I would like to have an image of a container that is easy to carry.  If you want to transfer your application to another user as an image of a container, you want this person to use it as is, and not rebuild it using other variables. </p><br><p>  Thus, the build-time environment variables can be useful, but you also need to have run-time environment variables, which can be set using the <code>docker run</code> , and the <code>-e</code> key is used for these variables.  The following example sets the secret-key and email for a Gmail account: </p><br><pre> <code class="hljs pgsql">$ docker run <span class="hljs-comment"><span class="hljs-comment">--name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \ -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \ -e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; \ microblog:latest</span></span></code> </pre> <br><p>  Such a length for a <code>docker run</code> on the command line is not uncommon due to the presence of multiple definitions of environment variables. </p><br><h2 id="ispolzovanie-storonnih-konteynernyh-servisov">  Use of third-party "container" services </h2><br><p>  The container version of Microblog looks good, but I haven't thought much about storage yet.  The problem is that I did not set the <code>DATABASE_URL</code> environment variable, and the application uses the default SQLite database that is supported by the disk file.  What do you think will happen to this SQLite file when you stop and remove the container?  The file will disappear! </p><br><p>  The file system in the container is ephemeral, that is, it disappears along with the stopping of the container.  You can write data to the file system, and the data will be available if the container needs to read it, but if for any reason you need to recycle the container and replace it with a new one, any data saved by the application to disk will be lost forever. </p><br><p>  A good design strategy for a container application is to create <em>stateless</em> application containers.  If you have a container that has application code and no data, you can throw it away and replace it with a new one without any problems, the container becomes really one-time, which is a great achievement in terms of simplifying the deployment of updates. </p><br><p>  But, of course, this means that the data must be placed somewhere outside the application container.  This is where the fantastic Docker ecosystem comes into play.  Docker Container Registry contains a wide variety of container images.  I have already told you about the image of the Python container, which I use as the base image for my Microblog container.  In addition, Docker supports images for many other languages, databases, and other services in the Docker registry, and if this is not enough, the registry also allows companies to publish container images for their products, as well as regular users, such as you or me, to publish their own images.  This means that efforts to install third-party services are reduced to finding the corresponding image in the registry and launching it using the <code>docker run</code> with the appropriate arguments. </p><br><p>  So now I‚Äôll create two additional containers: one for the MySQL database and one for the Elasticsearch service, and then I‚Äôll execute a long command line that will launch the Microblog container with a bunch of parameters that will allow me access to these two new containers. </p><br><h2 id="dobavlenie-konteynera-mysql">  Adding MySQL container </h2><br><p>  Like many other products and services, MySQL has publicly available container images available in the Docker registry.  Like my own Microblog container, MySQL relies on environment variables to be transferred to the <code>docker run</code> .  These are settings such as password, database name, etc.  Despite the fact that there are many MySQL images in the registry, I decided to use the one that is officially supported by the MySQL team.  You can find detailed information about the MySQL container image on its registry page: <em><a href="https://hub.docker.com/r/mysql/mysql-server/">https://hub.docker.com/r/mysql/mysql-server/</a></em> . </p><br><p>  If you remember the time-consuming MySQL setup process in <a href="https://habrahabr.ru/post/352266/">chapter 17</a> , you will appreciate Docker, seeing how easy it is to deploy MySQL.  Here is the <code>docker run</code> that starts the MySQL server: </p><br><pre> <code class="hljs tex"><span class="hljs-formula"><span class="hljs-formula">$ docker run --name mysql -d -e MYSQL_RANDOM_ROOT_PASSWORD=yes </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MYSQL_DATABASE=microblog -e MYSQL_USER=microblog </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MYSQL_PASSWORD=&lt;database-password&gt; </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">mysql/mysql-server:5.7</span></span></code> </pre> <br><p>  That's all!  On any machine on which Docker is installed, you can run the above command and get a fully installed MySQL server with a randomly generated root password, a completely new database called <code>microblog</code> and a user with the same name and full database access settings.  Please note that you will need to enter the correct password as the value for the <code>MYSQL_PASSWORD</code> environment <code>MYSQL_PASSWORD</code> . </p><br><p>  Now, on the application side, as for traditional deployments on Ubuntu, I need to add a MySQL client package.  I will use <code>pymysql</code> , which I can add to the <em>Dockerfile</em> : </p><br><blockquote>  Dockerfile: Add pymysql to Dockerfile. </blockquote><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta"># ... RUN venv/bin/pip install gunicorn pymysql # ...</span></span></code> </pre> <br><p>  Each time the application or Dockerfile file changes, the container image must be rebuilt: </p><br><pre> <code class="hljs ruby">$ docker build -t <span class="hljs-symbol"><span class="hljs-symbol">microblog:</span></span>latest .</code> </pre> <br><p>  Now I can start Microblog again, but this time with a link to the database container, so that both can communicate via the network: </p><br><pre> <code class="hljs tex"><span class="hljs-formula"><span class="hljs-formula">$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">--link mysql:dbserver </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@dbserver/microblog </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">microblog:latest</span></span></code> </pre> <br><p>  The <code>--link</code> parameter tells Docker to make another container available.  The argument contains two names separated by a colon.  The first part is the name or identifier of the link container, in this case <code>mysql</code> , which I created above.  The second part defines the host name that can be used in this container for links (links).  Here I use <code>dbserver</code> as the universal name that the database server represents. </p><br><p>  When the connection between the two containers is established, I can set the <code>DATABASE_URL</code> environment variable to direct SQLAlchemy to use the MySQL database in another container.  The database URL will use <code>dbserver</code> ‚Äî as the host name of the database, <code>microblog</code> the database and user names, and the <code></code> you chose when starting MySQL. </p><br><p>  I noticed one feature when I experimented with the MySQL container, which is that it takes a few seconds to launch this container until it is ready to accept connections to the database.  If you run the MySQL container and the application container right after the <em>boot.sh</em> script <em>attempt</em> to start the <code>flask db migrate</code> may fail because the database is not ready to accept connections.  To make my solution more reliable, I decided to add a repeat loop in <em>boot.sh</em> : </p><br><blockquote>  <em>boot.sh</em> : retry to connect to database. </blockquote><br><pre> <code class="hljs lua">#!/bin/sh source venv/bin/activate <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> flask db upgrade <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">[[ "$?" == "0" ]]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> fi echo Upgrade command failed, retrying <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> secs... sleep <span class="hljs-number"><span class="hljs-number">5</span></span> done flask translate compile exec gunicorn -b :<span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-comment"><span class="hljs-comment">--access-logfile - --error-logfile - microblog:app</span></span></code> </pre> <br><p>  This cycle checks the exit code of the <code>flask db upgrade</code> command, and if it is not zero, it means that something went wrong, so it pauses for five seconds and then retries. </p><br><h2 id="dobavlenie-konteynera-elasticsearch">  Adding Elasticsearch Container </h2><br><p>   <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">Elasticsearch  Docker</a>          ,       (two-node).     docker   single-node    "oss",        .    : </p><br><pre> <code class="hljs ruby">$ docker run --name elasticsearch -d -p <span class="hljs-number"><span class="hljs-number">9200</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">9200</span></span> -p <span class="hljs-number"><span class="hljs-number">9300</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">9300</span></span> --rm \ -e <span class="hljs-string"><span class="hljs-string">"discovery.type=single-node"</span></span> \ docker.elastic.co/elasticsearch/elasticsearch-<span class="hljs-symbol"><span class="hljs-symbol">oss:</span></span><span class="hljs-number"><span class="hljs-number">6.1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   <code>docker run</code>     ,     Microblog  MySQL,     . -,    <code>-p</code> ,   ,         .   9200  9300       -. </p><br><p>         .  ,    ,   <code>&lt;name&gt;:&lt;tag&gt;</code> .  MySQL        <code>&lt;account&gt;/&lt;name&gt;:&lt;tag&gt;</code> ,          Docker.  Elasticsearch,   ,   <code>&lt;registry&gt;/&lt;account&gt;&lt;name&gt;:&lt;tag&gt;</code> ,          .     ,     Docker.    Elasticsearch       <em>docker.elastic.co</em>    ,  Docker. </p><br><p> ,      Elasticsearch,         Microblog,        URL  Elasticsearch: </p><br><pre> <code class="hljs tex"><span class="hljs-formula"><span class="hljs-formula">$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">--link mysql:dbserver </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@dbserver/microblog </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">--link elasticsearch:elasticsearch </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">-e ELASTICSEARCH_URL=http://elasticsearch:9200 </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">microblog:latest</span></span></code> </pre> <br><p>          ,     . , ,            Elasticsearch    . </p><br><p>        <em><a href="http://localhost:8000/">http://localhost:8000</a></em>    .      ,   .  ,       ,       Python: </p><br><pre> <code class="hljs ruby">$ docker logs microblog</code> </pre> <br><h2 id="reestr-konteynerov-docker">   Docker </h2><br><p> ,      ,   Docker,   ,      .            ,        Docker,     . </p><br><p>      Docker,    <em><a href="https://hub.docker.com/">https://hub.docker.com</a></em>      . ,     ,   ,        ,   . </p><br><p>                <code>docker login</code> : </p><br><pre> <code class="hljs pgsql">$ docker <span class="hljs-keyword"><span class="hljs-keyword">login</span></span></code> </pre> <br><p>     ,        <code>microblog:latest</code> ,     .          Docker,    ,    ,    MySQL.      <code>docker tag</code> : </p><br><pre> <code class="hljs xml">$ docker tag microblog:latest <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">your-docker-registry-account</span></span></span><span class="hljs-tag">&gt;</span></span>/microblog:latest</code> </pre> <br><p>          <code>docker images</code> ,         ,    <code>microblog:latest</code>  ,       .         . </p><br><p>      Docker,   <code>docker push</code> : </p><br><pre> <code class="hljs xml">$ docker push <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">your-docker-registry-account</span></span></span><span class="hljs-tag">&gt;</span></span>/microblog:latest</code> </pre> <br><p>     ,     ,        Docker  ,    MySQL  . </p><br><h2 id="razvertyvanie-konteynernyh-prilozheniy">    </h2><br><p>         Docker   ,           ,   Docker. ,      ,     <a href="https://habrahabr.ru/post/352266/"> 17</a>  Digital Ocean, Linode  Amazon Lightsail.           Docker   . </p><br><p> <a href="https://aws.amazon.com/ecs/">Amazon Container Service (ECS)</a>     ,     ,     AWS      ,         . </p><br><p> ,    ,   <a href="https://kubernetes.io/">Kubernetes</a> ,       ,             YAML   , ,           . </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png"> <a href="https://habrahabr.ru/post/352830/"></a> <a href="https://habrahabr.ru/post/353804/"></a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353234/">https://habr.com/ru/post/353234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353220/index.html">Ethical hacking: how to make money, not problems with the law</a></li>
<li><a href="../353226/index.html">Fourth: Redmadrobot developers winter internship</a></li>
<li><a href="../353228/index.html">Startup day (January-March 2018)</a></li>
<li><a href="../353230/index.html">From JavaScript to Rust and back: the story about wasm-bindgen</a></li>
<li><a href="../353232/index.html">Generation of site pages by means of service workers</a></li>
<li><a href="../353236/index.html">The history of gaming analytics platforms</a></li>
<li><a href="../353238/index.html">Docker. Start</a></li>
<li><a href="../353246/index.html">We invite you to a lecture evening on game design on April 18th at VSBI</a></li>
<li><a href="../353248/index.html">Reachability of the lower limit of the execution time of a commit distributed fault-tolerant transactions</a></li>
<li><a href="../353250/index.html">Dofoil Hunt with Windows Defender ATP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>