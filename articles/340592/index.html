<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does mobx work from the inside and compare it with redux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reading the chat of the Russian-speaking community react in a telegram ( https://t.me/react_js ), I see how mobx discussions appear with constant regu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does mobx work from the inside and compare it with redux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/59/e9/d5/59e9d5f2391c9977659956.png"><br><br>  Reading the chat of the Russian-speaking community react in a telegram ( <a href="https://t.me/react_js">https://t.me/react_js</a> ), I see how mobx discussions appear with constant regularity, comparisons with redux with arguments about magic, complexity and "mutability" and many have a big misunderstanding of what mobx is and what tasks it solves.  And I decided to write this article with "debriefing" so that you can collect all the arguments in one post.  We will analyze how mobx works from the inside by implementing its own version of mobx and compare it with redux. <br><a name="habracut"></a><br><p> For a start, mobx, although it is compared with other libraries as a library for managing a state, provides virtually no convenience for working with the state, except for invoking the update of the components of the reactor after the property marked by <code>@observable</code> decorator changes.  We can easily throw away mobx by removing all <code>@observable</code> and <code>@observer</code> decorators and get a working application by adding just one line of <code>update()</code> at the end of all event handlers where we change the state data that is displayed in the components. </p><br><pre> <code class="hljs pgsql">onCommentChange(e){ const {<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>} = this.props; <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.text = e.target.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(); //   }</code> </pre> <br><p>  and the update () function will simply call the "rerender" of the reactive application and, thanks to the virtual thought of the reactor, only diff changes will be applied in the real duma </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReactDOM</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&lt;App&gt;, document.getElementById('root')</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  To say that mobx is a whole state manager because it allows you to save one line of <code>update()</code> in the handlers, somehow too much. <br></p><br>  Unlike it, redux allows you to conveniently organize work with the state through the event-sourcing pattern when we do not update the state on the spot but ‚Äúdispatch‚Äù the object of change (action) and process it in a completely different place - in the so-called pure functions-reducers, and thanks to the unified we can add some convenient work with asynchronous to the event bus by intercepting these actions in the middleware pipeline and simplifying the debugging of the application via the time-travel feature. <br><p>  That is, mobx is not the library that simplifies working with the state - so what is its main task?  Its main task is to pinpoint update of components, namely, to cause an update of only those components that depend on the data that have changed. <br>  In the example above, every time any data in the application is changed, we perform the "rerender" (virtual thought comparison) of the entire application by calling <code>ReactDOM.render(&lt;App&gt;, document.getElementById('root'))</code> in the <code>update()</code> function and, as you can guess, it affects the performance, and on large applications the interface will inevitably slow down. <br></p><br>  Despite the fact that react invented virtual doom with the slogan that real doom is slow, and virtual is fast because it compares only the object trees in memory, and in the real Duma updates only the changed parts, in reality we cannot, in any update of the data in the application, call it comparing virtual thought for the entire application because it is slow. <br><br>  And then the solution to the problem is not to rely on virtual thoughts and update the components manually, calling <code>this.forceUpdate()</code> only those components in which the data that they output has changed. <br><p>  And this problem is exactly solved by the mobx library and part of the redux library. </p><br><p>  But let's try to solve the problem of the point update of components without taking into account these two libraries. <br></p><br>  Here you can come up with two approaches and both of them will impose restrictions on how we work with the state. <br><p>  The first approach is to use Immunity and Binary Search - if each state update returns new data objects that have changed and all parent objects (for the case when the state has a hierarchical structure) then we can achieve almost pinpoint update of the components by comparing references to the previous and new state and skip all the subtrees of the components whose data has not changed (newSubtree === oldSubtree) and as a result we will update our application by calling the rerender only the necessary com  onenta comparing with data only O (log (n)) components where n - is the number of components. <br></p><br>  So for example, an angular works if you set the <code>ChangeDetectionStrategy.OnPush</code> setting to it.  But the top-down solution has a couple of flaws.  First, despite the effectiveness of O (log (n)), if a component displays a list of other components, then we have to run through the entire array of components to compare their props, and if each component of the list renders another list then the number of comparisons increases even more.  Secondly, the component should depend only on its props which often have to be thrown over the nested components through intermediate ones. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Also, the redux library also uses the immutable approach, but only slightly in a modified form, solving the disadvantage with dependence only on props.  In addition to comparing props, redux also compares the additional data that the <code>mapStateToProps()</code> function returned (in <code>connect</code> decorator) in which we specify the dependence on different parts of the state and then they become additional props.  But for this redux is forced to perform a check of all n connected components.  But even this is still faster than doing an update ( <code>ReactDOM.render(&lt;App&gt;, rootEl);</code> ) of the entire application. <br><p>  But the immutable approach has a couple of serious flaws that impose restrictions on working with the condition. </p><br><p>  The first drawback is that we can not now just take and update any property of the data object in the application.  Because of the requirement to return each time a new immutable object of the integer state, we need to return a new object and also re-create all parent objects and arrays.  For example, if a state object stores an array of projects, each project stores an array of tasks, and each task stores an array of comments: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> AppState = { projects: [ {..}, {...}, {name: <span class="hljs-string"><span class="hljs-string">'project3'</span></span>, tasts: [ {...}, {...}, {name: <span class="hljs-string"><span class="hljs-string">'task3'</span></span>, comments: [ {...}, {...}, {text: <span class="hljs-string"><span class="hljs-string">'comment3'</span></span> } ]} ]} ] }</code> </pre> <br><p>  So in order to update the text of the comment object, we cannot simply execute <code>comment.text = 'new text'</code> - we need to first re-create the comment object ( <code>comment = {...comment, text: 'updated text'}</code> ), then we need to recreate the task object and copy links to other comments from there ( <code>task = {...task, tasks: [...task.comments]}</code> ), then recreate the project object and copy references to other tasks there ( <code>project = {...project, tasks: [...project.tasks]}</code> ) and at the end, recreate the state object and also copy links to other projects ( <code>AppStat = {...AppState, projects: [...AppState.projects]}</code> ) . </p><br><p>  The second drawback is the impossibility of storing objects that refer to each other in a state.  If we need somewhere in the component's handler, we need to get the project in which the task is located - then we cannot simply assign a reference to the parent project when creating the object - <code>task.project = project</code> because the need to return a new object not only for the task, but also for project leads to the fact that we need to update all other tasks in the project - after all, the link to the project object has changed, which means that we need to update all the tasks by assigning a new link, and updating as we know needs to be done through re-creating  object, and if the task is stored comments, we need to do to recreate all of the comments, because they store a reference to the object of the problem, and so we come to recursively recreate the entire state and it would be terribly slow. <br><br>  As a result, we have to either change the props of the higher-level components each time to transfer the necessary object, or instead of referring to the object, save the task <code>task.project = '12345';</code>  and then somewhere to store and maintain the hash of projects by their ProjectHash <code>ProjectHash['12345'] = project;</code> </p><br><p>  Since the solution with immunity has a lot of flaws, let's think about whether it is possible to solve the problem of the point update of components in another way?  When we need to change the data in the application, we need to re-render only those components that depend on this data.  What means depend?  For example, there is a simple comment component that renders the comment text. </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render(){ const {comment} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;{comment.text}&lt;/div&gt; } }</code> </pre> <br><p>  This component depends on <code>comment.text</code> and needs to be updated each time <code>comment.text</code> changes.  But also if the component displays <code>&lt;div&gt;{comment.parent.text}&lt;/div&gt;</code> but now you need to update the component each time not only <code>.text</code> but also <code>.parent</code> .  We can solve this problem without using any immetablistic approach, but using the possibilities of javascript getters and setters, and this is the second approach I know to solve the point update ui problem. <br></p><br>  Getters and setters are a pretty old javascript opportunity to put your handler to update a property or get the value of a property: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, <span class="hljs-string"><span class="hljs-string">'text'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(){ console.log(<span class="hljs-string"><span class="hljs-string">'&gt;text getter'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this._text; }, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(val){ console.log(<span class="hljs-string"><span class="hljs-string">'&gt;text setter'</span></span>); this._text = val; } }) <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.text; //    &gt;<span class="hljs-type"><span class="hljs-type">text</span></span> getter <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.text = <span class="hljs-string"><span class="hljs-string">'new text'</span></span> //    &gt;<span class="hljs-type"><span class="hljs-type">text</span></span> setter</code> </pre> <br><p>  So, we can put a function on the setter that will be executed each time a new value is assigned and we will call a re-render of the list of components that depend on this property.  In order to find out which components depend on which properties, you need to assign the current component to a global variable at the beginning of the <code>render()</code> function, and when you call any getter object property, add the current component to the dependency list of this property, which is in the global variable.  And since the components can be ‚Äúrendered‚Äù tree one must still remember to return the previous component back to this global variable. </p><br><pre> <code class="hljs kotlin">let CurrentComponent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prevComponent = CurrentComponent; CurrentComponent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {comment} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = &lt;div&gt;{comment.text}&lt;/div&gt; CurrentComponent = prevComponent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } comment._components = []; Object.defineProperty(comment, <span class="hljs-string"><span class="hljs-string">'text'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._components.push(CurrentComponent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._text }, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._text = <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._components.forEach(component =&gt; component.setState({})) } })</code> </pre> <br><p>  I hope you get the idea.  With this approach, each property will store an array of its dependent components and, if the property changes, will trigger their update. </p><br><p>  Now, in order not to mix the storage of an array of dependent components with data and to simplify the code, we move the logic of such a property to the Cell class, which, as can be seen from the analogy, is very similar to the principle of the cells in excel - if other cells contain formulas on which the current the cell is needed when changing the value to cause updates of all dependent cells. </p><br><pre> <code class="hljs pgsql">let CurrentObserver = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Cell { constructor(val){ this.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = val; this.reactions = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(); //        es6  } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurrentObserver){ this.reactions.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(CurrentObserver); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(val){ this.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = val; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(const reaction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> this.reactions){ reaction.run(); } } unsibscribe(reaction){ this.reactions.<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(reaction); } }</code> </pre> <br><p>  But the role of a cell with the formula will be played by the <code>ComputedCell</code> class which inherits from the <code>Cell</code> class (because other cells may depend on this cell).  The <code>ComputedCell</code> class takes in a constructor a function (formula) for recalculation and also optionally a function for performing side effects (such as calling <code>.forceUpdate()</code> components) </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComputedCell</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ constructor(computedFn, reactionFn, ){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(undefined); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computedFn = computedFn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn = reactionFn; } run(){ const prevObserver = <span class="hljs-type"><span class="hljs-type">CurrentObserver</span></span>; <span class="hljs-type"><span class="hljs-type">CurrentObserver</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; const newValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computedFn(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(newValue !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = newValue; <span class="hljs-type"><span class="hljs-type">CurrentObserver</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.forEach(r=&gt;r.run()); } <span class="hljs-type"><span class="hljs-type">CurrentObserver</span></span> = prevObserver; } }</code> </pre> <br><p>  And now, in order not to perform the installation of getters and setters every time, we will use decorators from typescript or babel.  Yes, this imposes restrictions on the need to use classes and create objects not through the literal <code>const newComment = {text: 'comment1'}</code> but through <code>const comment = new Comment('comment1')</code> but instead of manually installing getters and setters, we can conveniently mark the property as <code>@observable</code> and continue to work with it as with the usual property. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> text; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(text){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.text = text; } } function observable(target, key, descriptor){ descriptor.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = function(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observable) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key] = new Observable() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); } descriptor.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = function(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observable) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key] = new Observable() observable.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> descriptor }</code> </pre> <br><p>  And in order not to work directly with the <code>ComputedCell</code> class inside the component, we can <code>@observer</code> this code to the <code>@observer</code> decorator, which simply wraps the <code>render()</code> method and creates a calculated cell on the first call, passing the <code>render()</code> method as a formula <code>this.forceUpdate()</code> call <code>this.forceUpdate()</code> (in reality, you also need to add a reply in the <code>componentWillUnmount()</code> method and some moments of the correct wrapping of the components of the reactor, but for now we will keep this option for ease of understanding) </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Component)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldRender = Component.prototype.render; Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComputedCell(oldRender.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), ()=&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction.get(); } }</code> </pre> <br><p>  and we will use as </p><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@observer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render(){ const {comment} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;{comment.text}&lt;/div&gt; } }</code> </pre> <br><p>  Link to the <a href="https://codesandbox.io/s/93xzqy77xo">demo</a> </p><br><div class="spoiler">  <b class="spoiler_title">All Code Assembly</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React from <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { render } from <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; let CurrentObserver; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions = new Set(); } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentObserver) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.add(CurrentObserver); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reaction of <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions) { reaction.run(); } } unsubscribe(reaction) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.delete(reaction); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComputedCell</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(computedFn, reactionFn) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computedFn = computedFn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn = reactionFn; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.track(); } track(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prevObserver = CurrentObserver; CurrentObserver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.computedFn(); CurrentObserver = prevObserver; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newValue; } run() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.track(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = newValue; CurrentObserver = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactionFn(); } } } function observable(target, key) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables = {}; let observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observable) observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key] = new Cell(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> observable.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); }, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables = {}; let observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observable) observable = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__observables[key] = new Cell(); observable.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); } } } function observer(Component) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldRender = Component.prototype.render; Component.prototype.render = function(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction = new ComputedCell(oldRender.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), ()=&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@observable</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(text) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppState = new Timer(); <span class="hljs-meta"><span class="hljs-meta">@observer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ onClick=()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.timer.count++ } render(){ console.log(<span class="hljs-string"><span class="hljs-string">'render'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {timer} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; &lt;div&gt;{timer.count}&lt;/div&gt; &lt;button onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onClick}&gt;click&lt;/button&gt; &lt;/div&gt; ) } } render(&lt;App timer={AppState}/&gt;, document.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>));</code> </pre> </div></div><br><p>  In our example, there is one drawback - what if component dependencies can change?  Take a look at the next component. </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render(){ const {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;{user.showFirstName ? user.firstName : user.lastName}&lt;/div&gt; } }</code> </pre> <br><p>  The component depends on the <code>user.showFirstName</code> property and further, depending on the value, it can depend on either <code>user.firstName</code> or <code>user.lastName</code> , that is, if <code>user.showFirstName == true</code> , then we should not react to the change of <code>user.lastName</code> and vice versa if <code>user.showFirstName</code> changed to false then we should not react (and re-render the component) if the <code>user.firstName</code> property <code>user.firstName</code> ; </p><br><p>  This moment is easily solved by adding the dependencies list of <code>this.dependencies = new Set()</code> to the cell class and a small logic to the <code>run()</code> function - so that after calling the render () reagent we compare the previous dependencies list with the new ones and unsubscribe from irrelevant dependencies. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies = new Set(); } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentObserver) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reactions.add(CurrentObserver); CurrentObserver.dependencies.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComputedCell</span></span></span><span class="hljs-class"> </span></span>{ track(){ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prevObserver = CurrentObserver; CurrentObserver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldDependencies = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies; <span class="hljs-comment"><span class="hljs-comment">//    this.dependencies = new Set(); //          const newValue = this.computedFn(); //        for(const dependency of oldDependencies){ if(!this.dependencies.has(dependency)){ dependency.unsubscribe(this); } } CurrentObserver = prevObserver; return newValue; } }</span></span></code> </pre> <br><p>  The second point is that if we immediately change a lot of properties in the object?  Since dependent components will be updated synchronously, we will receive two extra component updates. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.text = <span class="hljs-string"><span class="hljs-string">'edited text'</span></span>; //    <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>.editedCount+=<span class="hljs-number"><span class="hljs-number">1</span></span>; //   </code> </pre> <br><p>  To avoid unnecessary updates, we can set a global flag at the beginning of this function and our <code>@observer</code> decorator will not immediately call <code>this.forceUpdate()</code> but will only call it when we remove this flag.  And for simplicity, we will move this logic to the <code>action</code> decorator and, instead of the flag, we will increase or decrease the counter because decorators can be called inside other decorators. </p><br><pre> <code class="hljs javascript">updatedComment = action(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ comment.text = <span class="hljs-string"><span class="hljs-string">'edited text'</span></span>; comment.editedCount+=<span class="hljs-number"><span class="hljs-number">1</span></span>; }) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TransactionCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> PendingComponents = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Component</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldRender = Component.prototype.render; Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComputedCell(oldRender.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), ()=&gt;{ TransactionCount ?PendingComponents.add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate() }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._reaction.get(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ TransactionCount++ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = fn(); TransactionCount-- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TransactionCount == <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PendingComponents){ component.forceUpdate(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><p>  As a result, such an approach using the very old "observer" pattern (not to be confused with observable RxJS) is much better suited for the implementation of the task of a point update of components than the approach using immunity. </p><br><p>  Among the shortcomings, you can only notice the need to create objects not through literals but through classes, which means that we cannot simply accept some data from the server and transfer to the components - it is necessary to carry out additional data processing by wrapping it in objects of classes with <code>@observable</code> decorators. <br></p><br>  You can also write down the inability to add new properties to objects on the fly (although this is considered antipattern in terms of js performance), the inconvenience of debugging code in chrome devtools is because the data is hidden behind getters, and instead of values ‚Äã‚Äãwe will see three dots and to see the value to click on this property, and also an attempt to step through any change or get the property will take us deep into the setter or getter inside the library. <br><br>  But the advantages far exceed the disadvantages.  First of all, in contrast to the immutable approach, the speed of work does not depend on the number of components, because we immediately know the list of components that need to be updated - which means we have complexity o (1) instead of o (log (n)) or o (n) as noted <a href="https://twitter.com/dan_abramov/status/719973322453348352">Den Abramov</a> and more importantly - the creation of n-objects in the <code>mapStateToProps</code> function does not occur.  Secondly, when we need to update some data, we can just write <code>comment.text = 'new text'</code> and we don‚Äôt have to do much more work on updating the parent state objects, and what's important is that there will be no load on the garbage collector due to permanent re-creation of objects.  Well and most importantly - we can simulate states with the help of objects that link to each other and can comfortably work with the state without having to store an ID for the object instead of it and then pull each time from the hash <code>AppState.folders[AppState.projects[AppState.tasks[comment.taskId].projectId].folderId].name</code> instead of a simple reference to <code>comment.task.project.folder.name</code> <br><br><h3 id="vyvod">  Conclusion </h3><br><p>  If you understand these examples, then congratulations - you now understand how the "magic" of mobx works from within.         mobx <code>@computed</code>                (    )            mobx-                         react-. </p></div><p>Source: <a href="https://habr.com/ru/post/340592/">https://habr.com/ru/post/340592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340582/index.html">‚ÄúWithout the data engineer, the value of the analyst model tends to zero‚Äù - an interview with the data engineer Nikolai Markov</a></li>
<li><a href="../340584/index.html">Object Oriented Programming in Vanilla JavaScript</a></li>
<li><a href="../340586/index.html">History - one project on "Trust". Or how big the little ones get hurt</a></li>
<li><a href="../340588/index.html">SC and Unity: two boots - a pair</a></li>
<li><a href="../340590/index.html">let's live in peace</a></li>
<li><a href="../340600/index.html">In search of perfect architecture</a></li>
<li><a href="../340602/index.html">How I stopped selling food on the street and started working in top technology companies</a></li>
<li><a href="../340604/index.html">Your own std :: code_error</a></li>
<li><a href="../340610/index.html">UI design in games on the example of NieR: Automata</a></li>
<li><a href="../340612/index.html">Classes of matrices and vectors in Delphi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>