<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using ViewController in ExtJS 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ExtJS 5 brings several exciting architecture improvements: we added support for ViewModels, MVVMs, and ViewControllers to enhance MVC applications. Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using ViewController in ExtJS 5</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/c07/b0e/ffec07b0e7c8bc18141d160e33e32ca6.png" align="left">  ExtJS 5 brings several exciting architecture improvements: we added support for ViewModels, MVVMs, and ViewControllers to enhance MVC applications.  Best of all, these functions are not mutually exclusive, so you can enter them step by step or use them simultaneously. <br><a name="habracut"></a><br><br><h4>  About controllers </h4><br>  In ExtJS 4, a controller is a class inherited from <code>Ext.app.Controller</code> .  These controllers use CSS-like selectors (called "Component Queries") to map components and event handlers for their events.  They also use the so-called <code>refs</code> for sampling and obtaining instances of components. <br><br>  These controllers are created when the application is started and run throughout the entire life cycle.  Views are created and deleted, there may be several instances, and controllers serve everyone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Difficulties </h5><br>  For large applications, these techniques may have some difficulties. <br><br>  In such cases, views and controllers can be created by different authors in different development teams, and then integrated into the final application.  And to be sure that the controllers respond only to the representations intended for them is already difficult.  Also, developers usually want to reduce the number of controllers created when the application is started.  And having the opportunity (with some effort) to create controllers is postponed, there is no possibility to remove them, so they remain even if they are no longer needed. <br><br><h4>  Viewcontrollers </h4><br>  Given that Ext JS 5 is backward compatible with current controllers, it offers a new type of controller designed to solve this kind of problem: <code>Ext.app.ViewController</code> .  The solution is achieved as follows: <br><br><ul><li>  The configuration properties of <code>listeners</code> and <code>reference</code> , communication with views is simplified. </li><li>  For the automatic control of the corresponding ViewControllers, the life cycle of the views is used. </li><li>  The complexity of the ViewController is reduced, since  One-to-one relationship is used with the corresponding representation. </li><li>  Encapsulation is provided for the ability to create nested views. </li><li>  It remains possible to select components and track their events at any level below the corresponding view. </li></ul><br><h5>  Listeners </h5><br>  The <code>listeners</code> not new, but in Ext JS 5 it acquired new features.  A more complete analysis of new listeners will be in the upcoming article - ‚ÄúDeclarative Listeners in Ext JS 5‚Äù.  For use in ViewControllers, we can look at a couple of examples.  The first is the usual use of the <code>listeners</code> in the nested view component: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.Foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'textfield'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fieldLabel</span></span>: <span class="hljs-string"><span class="hljs-string">'Bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">change</span></span>: <span class="hljs-string"><span class="hljs-string">'onBarChange'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    (scope) } }] }); Ext.define('MyApp.view.foo.FooController', { extend: 'Ext.app.ViewController', alias: 'controller.foo', onBarChange: function (barTextField) { //     'change' } });</span></span></code> </pre><br>  In this case, the named <code>onBarChange</code> handler <code>onBarChange</code> not have a specific context ( <code>scope</code> ).  The event system for the <code>Bar</code> text field independently makes the default context its own ViewController. <br><br>  Historically, the <code>listeners</code> config has been reserved for use by the parent component, so the question arises: how can the presentation listen to its own events or perhaps even those that were caused by the base class?  The answer is to use an explicit context: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.Foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">collapse</span></span>: <span class="hljs-string"><span class="hljs-string">'onCollapse'</span></span>, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: <span class="hljs-string"><span class="hljs-string">'controller'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ ... }] });</code> </pre><br>  This example uses two new features for ExtJS 5: named contexts and declarative listeners ( <i>named scopes and declarative listeners, - approx. Transl.</i> ).  We will focus on the named context.  For named contexts, two names are valid: <code>"this"</code> and <code>"controller"</code> .  When we write MVC applications, we almost always use a <code>"controller"</code> , which obviously will be its own ViewController (and not a ViewController of a view that is higher in the hierarchy). <br><br>  Since  the view is <code>Ext.Component</code> , we have assigned the <code>xtype</code> this view, which allows other views to create an instance of it just as we did with the <code>textfield</code> .  To see how everything fits together, create a hierarchy: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.bar.Bar'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">collapse</span></span>: <span class="hljs-string"><span class="hljs-string">'onCollapse'</span></span> } }] });</code> </pre><br>  In this case, the <code>Bar</code> view creates an instance of <code>Foo</code> as one of its elements.  Then it listens to the <code>collapse</code> event, just like the <code>Foo</code> view.  In previous versions of Ext JS and Sencha Touch, these definitions would conflict.  However, in Ext JS 5 this is solved: the listeners declared in <code>Foo</code> will work in ViewController'e <code>Foo</code> , and those declared in <code>Bar</code> - in ViewController'e <code>Bar</code> . <br><br><h5>  References </h5><br>  One of the widely used functions in controller logic is getting the necessary component to perform an action.  Something like that: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.Foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-string"><span class="hljs-string">'onAdd'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'grid'</span></span>, ... }] }); Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.FooController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span>, <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: <span class="hljs-string"><span class="hljs-string">'controller.foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">onAdd</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...  grid    ... } });</span></span></code> </pre><br>  But how do we get the table (gird)?  In ExtJS 4, you could use the config <code>refs</code> or some other way to get the component.  All technicians require you to give a recognizable property to a table in order to uniquely identify it.  Older technicians used the <code>id</code> (and <code>Ext.getCmp</code> ) <code>Ext.getCmp</code> or <code>itemId</code> (using <code>refs</code> or another selection method).  The advantage of <code>id</code> is quick sampling, but because  identifiers must be unique in the entire application and in the DOM, this is not always achievable.  Using <code>itemId</code> and different types of queries (query) is more flexible, but you need to perform a search to find the desired component. <br><br>  With the new <code>reference</code> config in Ext JS 5, we simply add it to the table and use the <code>lookupReference</code> to get it: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.Foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-string"><span class="hljs-string">'onAdd'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'grid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">reference</span></span>: <span class="hljs-string"><span class="hljs-string">'fooGrid'</span></span> ... }] }); Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.FooController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span>, <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: <span class="hljs-string"><span class="hljs-string">'controller.foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">onAdd</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookupReference(<span class="hljs-string"><span class="hljs-string">'fooGrid'</span></span>); } });</code> </pre><br>  This is like assigning <code>itemId = 'fooGrid'</code> and further <code>this.down('#fooGrid')</code> .  But "under the hood" the difference is significant.  First, the <code>reference</code> config requires the component to register itself with the owner-view.  Secondly, the <code>lookupReference</code> method asks the cache about the need to update (suppose, due to the addition or removal in the container).  If everything is fine, it simply returns the link from the cache.  In pseudocode: <br><br><pre> <code class="javascript hljs">lookupReference: (reference) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.references; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache) { Ext.fixReferences(); <span class="hljs-comment"><span class="hljs-comment">//   cache = this.references; //    } return cache[reference]; }</span></span></code> </pre><br>  In other words, there is no search, and links corrupted by adding or removing items from the container are corrected on the fly when they are needed.  As we will see below, besides efficiency, this approach provides other advantages. <br><br><h5>  Encapsulation </h5><br>  The use of selectors in the implementation of Ext JS 4 MVC was very flexible, but at the same time carried some risks.  The fact that the selectors "saw" all events at all levels was powerful, but inclined to mistakes.  For example, a controller that works 100% correctly in isolation could create errors as soon as new views appeared with undesirable matching selectors. <br><br>  This could be solved by following some practices, but using listeners and links in ViewControllers, these problems are simply excluded.  And all because the <code>reference</code> and <code>listeners</code> configs connect the view only with its ViewController.  Nested views can use any <code>reference</code> values ‚Äã‚Äãwithin the current one, knowing that these names will not be open to the view that is higher in the hierarchy. <br><br>  In this case, <code>listeners</code> requested from the corresponding ViewController and cannot be processed in other controllers with incorrect selectors.  Considering that listeners are more preferable than selectors, these two mechanisms can work simultaneously in those places when the use of a selector-based approach is justified. <br><br>  To complete this example, consider the case where a view can raise an event that will be processed by a ViewController of a higher level view.  To do this, there is a helper method in <code>fireViewEvent</code> : <code>fireViewEvent</code> .  For example: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.Foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tbar</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'Add'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-string"><span class="hljs-string">'onAdd'</span></span> }], <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'grid'</span></span>, <span class="hljs-attr"><span class="hljs-attr">reference</span></span>: <span class="hljs-string"><span class="hljs-string">'fooGrid'</span></span> ... }] }); Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.FooController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span>, <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: <span class="hljs-string"><span class="hljs-string">'controller.foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">onAdd</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyApp.model.Thing(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookupReference(<span class="hljs-string"><span class="hljs-string">'fooGrid'</span></span>); grid.store.add(record); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireViewEvent(<span class="hljs-string"><span class="hljs-string">'addrecord'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, record); } });</code> </pre><br>  This makes it possible to use a standard listener in a view that is higher in the hierarchy: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.bar.Bar'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.panel.Panel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">items</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">collapse</span></span>: <span class="hljs-string"><span class="hljs-string">'onCollapse'</span></span>, <span class="hljs-attr"><span class="hljs-attr">addrecord</span></span>: <span class="hljs-string"><span class="hljs-string">'onAddRecord'</span></span> } }] });</code> </pre><br>  <i>From the translator: it sounds confusing, but in fact <code>fireViewEvent</code> allows <code>fireViewEvent</code> to raise an event for a view inside a ViewController.</i>  <i>That is, if in this case there were no ViewControllers, it would be equivalent to calling the usual <code>fireEvent</code> in the ‚ÄúFoo‚Äù view code.</i> <br><br><h5>  Listeners and Event Domains (Listeners and Event Domains) </h5><br>  In Ext JS 4.2, event domains have been entered into MVC Event Manager.  These domains intercept events as soon as they are invoked and transfer them to controllers that process them by coincidence of selectors.  The event domain <code>component</code> has full support for component selectors, while others are limited. <br><br>  In Ext JS 5, each ViewController creates an instance of a new event domain type called <code>view</code> .  This event domain allows ViewControllers to use standard methods of <code>listen</code> and <code>control</code> , while implicitly limiting their scope to their own views.  He also adds a new special selector to match his own view: <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'MyApp.view.foo.FooController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span>, <span class="hljs-attr"><span class="hljs-attr">alias</span></span>: <span class="hljs-string"><span class="hljs-string">'controller.foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">control</span></span>: { <span class="hljs-string"><span class="hljs-string">'#'</span></span>: { <span class="hljs-comment"><span class="hljs-comment">//     collapse: 'onCollapse' }, button: { click: 'onAnyButtonClick' } } });</span></span></code> </pre><br>  The key difference between listeners and selectors can be seen in the following example.  The selector <code>button</code> coincides with any button in this view or in any nested, it does not matter, even in the sub-sub-nested.  In other words, handlers based on selectors do not consider inheritance boundaries.  This behavior is the same as the previous <code>Ext.app.Controller</code> behavior and in some situations it can be a useful technique. <br><br>  Finally, these domains take into account nesting and effectively send an event up through the hierarchy of representations ( <i>bubble an event up, - approx. Transl.</i> ).  That is, when an event is triggered, at first it is transmitted to standard listeners.  Then it is passed to the owning ViewController, and then up the hierarchy to the parent ViewController (if there is one).  Ultimately, the event is passed to the standard event domain <code>component</code> for processing in <code>Ext.app.Controller</code> controllers. <br><br><h5>  Life cycle </h5><br>  Standard practice with large applications is to dynamically create controllers as needed.  This can help reduce the time to load an application and improve its performance without affecting other controllers.  The limitation of this approach in previous versions was that, when created, these controllers remain working throughout the life of the application.  It was impossible to destroy them to free up resources.  Also, nothing changed in the sense that the controllers could serve as several instances of representations, and none. <br><br>  Therefore, in the life cycle of a view, the ViewController is created immediately and it is tied to this view throughout its life.  When a view is deleted, the ViewController is also.  This means that you no longer need to work from the ViewController when there are no or few <i>views (apparently, it is compared with the classical controllers; note perev.</i> ). <br><br>  A one-to-one relationship makes it easier to track links and makes it impossible for any components to leak.  The following key events are raised in the ViewController life cycle: <br><br><ul><li>  <b>beforeInit</b> is a method that can be redefined to control the view before it calls the initComponent method.  It is called immediately after the creation of the controller when the component's <code>initConfig</code> or its constructor is <code>initConfig</code> . </li><li>  <b>init</b> - called immediately after the <code>initComponent</code> method has completed in the <code>initComponent</code> .  This is a typical time to perform controller initialization, the view of which has already been initialized. </li><li>  <b>initViewModel</b> - called when the ViewModel of the view is created (if defined). </li><li>  <b>destroy</b> - clean up any resources (don't forget to call <code>callParent</code> ). </li></ul><br><br><h4>  Conclusion </h4><br>  We think that ViewController'y perfectly upgrade your applications.  They also work well with ViewModels, so you can combine the strengths of both approaches.  We welcome the upcoming release and will also be happy to improve your applications. <br><br><h5>  PS </h5><br>  Previous Post: <a href="https://habr.com/post/224535/">Ext JS 5: MVC, MVVM, etc</a> </div><p>Source: <a href="https://habr.com/ru/post/224645/">https://habr.com/ru/post/224645/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224625/index.html">iFixit translate into Russian?</a></li>
<li><a href="../224627/index.html">Checklist for usability of online stores</a></li>
<li><a href="../224629/index.html">Lived: the Bitcoin mining block is sold in the usual Internet supermarket</a></li>
<li><a href="../224635/index.html">MS-DOS is not a question! (video)</a></li>
<li><a href="../224639/index.html">The new version of Unity, the new ‚Äútrivial‚Äù hit, new categories in Google Play - the main mobile news of the week</a></li>
<li><a href="../224647/index.html">250 million international events in one place</a></li>
<li><a href="../224649/index.html">A team of enthusiasts has successfully established a connection with the ISEE-3 space hardware after a 15-year freeze.</a></li>
<li><a href="../224653/index.html">The minimax algorithm on the example of the game "Collect 4 (connect4)"</a></li>
<li><a href="../224655/index.html">An effective approach to non-standard site development</a></li>
<li><a href="../224661/index.html">On the outskirts of Ur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>