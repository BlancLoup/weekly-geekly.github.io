<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does the video analytics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I read an article in which the author, using a simple example, tells how the motion recognition algorithm works. It reminded me of my own re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does the video analytics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b0f/907/65b/b0f90765b3d94e039fe420eb95435bbf.png" align="left" width="320"><br>  Recently, I read <a href="http://habrahabr.ru/post/268445/">an article</a> in which the author, using a simple example, tells how the motion recognition algorithm works.  It reminded me of my own research into video streaming analytics algorithms.  Many people know that there is a great project <a href="http://opencv.org/">OpenCV</a> .  This is an extensive cross-platform library of computer vision, containing many different algorithms.  However, to understand it is not so easy.  You can find many publications and examples of how and where to use machine vision, but not how it works.  Namely, this is often not enough to understand the process, especially when you just start to study this topic. <br><br>  In this article I will talk about the architecture of video analytics. <br><a name="habracut"></a><br>  The general scheme of the video analysis is presented below. <br><br><img src="https://habrastorage.org/files/0f7/f57/0b4/0f7f570b455a457a829a1c73250d16c1.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The process is divided into several successive stages.  At the output of each of them, information about what is happening in the frame is supplemented with more and more details.  There may also be feedback between the stages to more subtly react to changes in the frame. <br>  Consider the scheme in more detail. <br><br><h3>  What are the video stream </h3><br>  First you need to decide what is a video stream.  Although there are many formats of video data, their essence boils down to one thing: a sequence of frames with a certain frequency per second.  A frame is an image characterized by resolution and format (the number of bits per pixel and their interpretation: which bits are responsible for which color component).  Inside a stream, frame compression can be used to reduce the amount of data transferred, but when displayed on the screen, frames are always expanded to their original state.  Directly, analytic algorithms always work with uncompressed frames as well. <br><br>  Thus, the video stream is characterized by frame rates, their format and resolution. <br><br>  It is important to note that the analyst always deals with only one frame at the same time.  That is, they are processed sequentially.  In addition, during the next processing, it is important to know how much time passed after the previous frame.  This value can be calculated from the frequency, but a more practical approach is to support the frame with a timestamp. <br><br><h3>  Changing the size and format of the frame </h3><br>  The first stage is frame preparation.  As a rule, it is significantly reduced in size.  The fact is that in the further processing each pixel of the image will be involved.  Accordingly, the smaller the frame, the faster everything will work.  Naturally, during compression, some of the information in the frame is lost.  But this is not critical, but even useful.  The objects with which the analyst works are basically large enough so as not to disappear from the frame during compression.  But all sorts of "noise" associated with the quality of the camera, light, natural factors will be reduced. <br><br>  Resolution change occurs by combining several pixels of the original image into one.  The part of the information that will be stored depends on the way of combining. <br><br>  For example, a square of 3x3 pixels of the original image must be converted to one pixel of the result.  You can sum up all 9 pixels, you can take the sum of only 4 angular pixels, and you can only one central. <br><br>  4 corner pixels: <br><br><img src="https://habrastorage.org/files/65f/11a/dd2/65f11add289d44f0aaca6c8d5c1a8733.png"><br><br>  The sum of all pixels: <br><br><img src="https://habrastorage.org/files/38d/024/c89/38d024c893e440ac89beebfc63778da6.png"><br><br>  Center pixel: <br><br><img src="https://habrastorage.org/files/5c4/f99/687/5c4f99687a554881830aff11938cf74c.png"><br><br>  The result will be everywhere a little different in speed and quality.  But sometimes it happens that a way that loses more information gives a smoother picture than the one that uses all the pixels. <br><br>  Another action at this stage is to change the image format.  Color images, as a rule, are not used, as this also increases the frame processing time.  For example, RGB24 contains 3 bytes for each pixel.  And only one Y8, while not much inferior to the information content of the first. <br><br>  Y8 = (R + G + B) / 3. <br><br>  The result is the same image, but in grayscale: <br><br><img src="https://habrastorage.org/files/e76/517/8a5/e765178a5b614f8d9fdd51e9e5e9df11.png"><br><br><img src="https://habrastorage.org/files/353/ff5/706/353ff57062a24720b7cec5f50d88ebf2.png"><br><br><h3>  Background patterns </h3><br>  This is the most important stage of processing.  The goal of this stage is to form the background of the scene and get the difference between the background and the new frame.  The quality of the entire circuit will depend on the algorithms of this stage.  If an object is accepted as a background or, on the contrary, a part of the background is selected as an object, then it will be difficult to correct something further. <br><br>  In the simplest case, as a background, you can take a frame with an empty scene: <br><br><img src="https://habrastorage.org/files/b0e/727/ca3/b0e727ca39004313b1a4e6aaa36c603f.png"><br><br>  Select a frame with the object: <br><br><img src="https://habrastorage.org/files/8e2/7c3/951/8e27c3951c424dba9d3033308a55991d.png"><br><br>  If we translate these frames into Y8 and subtract the background from the frame with the object, we get the following: <br><br><img src="https://habrastorage.org/files/17f/e7f/308/17fe7f308a4b47cbb7259225d09a7fa5.png"><br><br>  For convenience, you can make binarization: replace the value of all pixels large 0 by 255. As a result, from the gray gradation, we move on to the black and white image: <br><br><img src="https://habrastorage.org/files/6f7/a1b/634/6f7a1b634b5e455dafd3bfa16db20b9f.png"><br><br>  It seems to be all right, the object is separated from the background, has clear boundaries.  But, first of all, the shadow of the object also stood out.  And secondly, artifacts from image noise are visible at the top of the frame. <br><br>  In practice, this approach is no good.  Any shadow, a highlight of light, a change in camera brightness will spoil the whole result.  This is the whole complexity of the task.  Objects should be separated from the background, while it is necessary to ignore natural factors and image noise: light highlights, shadows from buildings and clouds, fluctuating plant branches, frame compression artifacts, etc.  Moreover, if you look for the left object, then on the contrary, it should not be part of the background. <br><br>  There are many <a href="https://en.wikipedia.org/wiki/Background_subtraction">algorithms</a> that solve these problems with different efficiency.  From simple averaging of the background to using probabilistic models and machine learning.  Many of them are in OpenCV.  And you can combine several approaches, which will give an even better result.  But the more complex the algorithm, the longer it takes to process the next frame.  With live video at least 12.5 frames per second, the system has only 80 ms to process.  Therefore, the choice of the optimal solution will depend on the task and resources allocated for its implementation. <br><br><h3>  Zone formation </h3><br>  Differential frame formed.  We see white objects on it on a black background: <br><br><img src="https://habrastorage.org/files/ec0/9df/2ee/ec09df2eec124cd39153f680deb3397a.png"><br><br><img src="https://habrastorage.org/files/8b7/dc3/132/8b7dc3132de749d9a194fb65f469dbd8.png"><br><br>  Now we need to separate the objects from each other and form zones combining the pixels of the objects: <br><br><img src="https://habrastorage.org/files/bdb/b63/f9c/bdbb63f9c5624d94a95d1b860173a668.png"><br><br>  This can be done using, for example, the <a href="https://en.wikipedia.org/wiki/Connected-component_labeling">connected component labeling</a> . <br><br>  Here all defects of the background model are immediately visible.  The man on top is divided into several parts, many artifacts, shadows from people.  However, some of these shortcomings can be corrected at this stage.  Knowing the area of ‚Äã‚Äãthe object, its height and width, the density of pixels, you can filter out extra objects. <br><br>  On the frame above, blue frames indicate objects that are involved in further processing, and green ones - filtered ones.  There are also errors.  As you can see, the man on the top, divided into several parts, was also filtered because of its size.  This problem can be solved, for example, by using perspective. <br><br>  Other errors are possible.  For example, several objects can be combined into one.  So at this stage there is a big field for experiments. <br><br><h3>  Zone tracking </h3><br>  Finally, at the last stage, zones are transformed into objects.  It uses the result of processing the last few frames.  The main task is to determine that the zone on two adjacent frames is the same object.  Signs can be very diverse: size, pixel density, color characteristics, motion direction prediction, etc.  This is where the frame time stamps are important.  They allow you to calculate the speed of the object and the distance traveled by it. <br><br><img src="https://habrastorage.org/files/7e1/1df/747/7e11df7472824c27b6ddc86679b8abf2.png"><br><br>  At this stage, you can correct one-time errors of the previous one.  For example, glued objects can be divided, given their history of movement.  On the other hand, there may be problems.  The most important of them is the intersection of 2 objects.  A special case of this problem is when a larger object shields a smaller object for a long time. <br><br><h3>  Objects for accounting in the background model </h3><br>  In the architecture there may be feedbacks that improve the work of the previous stages.  The first thing that comes to mind is to use information about objects in the scene when forming the background. <br><br>  For example, it is possible to distinguish the object set aside and not to make it part of the background.  Or fight with ‚Äúghosts‚Äù: if there was a person on the stage when creating the background, then when he leaves, a ‚Äúghost‚Äù object will appear in his place.  Realizing that in this place the trajectory of the movement of the object begins, you can quickly remove the ‚Äúghost‚Äù in the background. <br><br><h3>  Result </h3><br>  The result of the work of all stages is a list of objects in the scene.  Each of them is characterized by size, density, speed, trajectory, direction of movement and other parameters. <br><br>  This list is used in scene analytics.  It is possible to determine the intersection of the object line or movement in the wrong direction.  You can count the number of objects in a given zone, idle reeling, falling and many other events. <br><br><h3>  Conclusion </h3><br>  Modern video analytics systems have achieved very good results, but so far they remain a complex multistage process.  Moreover, knowledge of the theory does not always give a good practical result. <br><br>  In my opinion, creating a good machine vision system is a very complex process.  Tuning algorithms is a very laborious and lengthy business, in which the subtleties of software implementation also interfere.  It requires a lot of experiments.  And, although OpenCV is invaluable in this matter, it is not a guarantee of the result, because the tools it contains must still be able to be properly used. <br>  I hope that this article will help you to understand how it all works and what OpenCV tools you can use at what stages. </div><p>Source: <a href="https://habr.com/ru/post/271207/">https://habr.com/ru/post/271207/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271195/index.html">Flexbox for interfaces in all its glory: Implementing Tracks (Part 1)</a></li>
<li><a href="../271197/index.html">Nim Tutorial (Part 1)</a></li>
<li><a href="../271199/index.html">Main announcements of the Microsoft Connect conference () and the virtual conference Visual Studio Connect 2015 in Russia on December 4</a></li>
<li><a href="../271201/index.html">Why constantly writing code is so important - how not to become a catfish</a></li>
<li><a href="../271203/index.html">Secure TLS connection using Boost.Asio and OpenSSL under Windows</a></li>
<li><a href="../271211/index.html">Hackers invented a new money theft scheme, stealing 250 million rubles</a></li>
<li><a href="../271213/index.html">We invite you to the December Moscow mitap RuHaskell</a></li>
<li><a href="../271215/index.html">Protected social networks - myth or reality?</a></li>
<li><a href="../271217/index.html">Winium: now for Windows Phone</a></li>
<li><a href="../271219/index.html">Dedicated servers in the Netherlands for Habrahabr readers without a pro-rate for November + additional 10% discount</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>