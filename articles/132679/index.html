<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Template Haskell. Part 2. Citation Tools</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This text is a translation of the Template Haskell documentation written by Bulat Ziganshin. Translation of the entire text is divided into several lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Template Haskell. Part 2. Citation Tools</h1><div class="post__text post__text-html js-mediator-article">  <i>This text is a translation of the <a href="http://docs.google.com/uc%3Fid%3D0B4BgTwf_ng_TM2MxZjJjZjctMTQ0OS00YzcwLWE5N2QtMDI0YzE4NGUwZDM3">Template Haskell documentation</a> written by Bulat Ziganshin.</i>  <i>Translation of the entire text is divided into several logical parts to facilitate perception.</i>  <i>Further italics in the text - notes of the translator.</i>  <i>Other parts:</i> <br><ul><li>  <a href="http://habrahabr.ru/blogs/Haskell/131998/">Part 1. Required minimum</a> </li><li>  <a href="http://habrahabr.ru/blogs/Haskell/133009/">Part 3. Other aspects of TH</a> </li></ul><br><br><h2>  Citation monad </h2><br>  Since the templates must return their values ‚Äã‚Äãwrapped in the monad <code>Q</code> , for this there is a set of auxiliary functions that ‚Äúraise‚Äù (wrap in <code>Q</code> ) the constructors of the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html"><code>Exp</code></a> , <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html"><code>Lit</code></a> , <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html"><code>Pat</code></a> types: <code>lamE</code> (respectively <code>LamE</code> ), <code>varE</code> , <code>appE</code> , <code>varP</code> , etc. d.  Their signatures also use renumbered raised types: <code>ExpQ = Q Exp</code> , <code>LitQ = Q Lit</code> , <code>PatQ = Q Pat</code> ... (all of them can be found in the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Lib.html"><code>Language.Haskell.TH.Lib</code></a> module).  Using these functions, you can significantly reduce the code, less often using do-syntax. <br>  In TH, there is also a <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html"><code>lift</code></a> function, which raises to <code>Q Exp</code> value of any type from the <code>Lift</code> class. <br>  In some rare cases, you may not need to generate a unique name, but use the exact name of the identifier from an external <i>(relative to the pattern)</i> code.  For these purposes, there is a (pure) function <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html"><code>mkName</code></a> <code>‚à∑ String ‚Üí Name</code> .  There is also an auxiliary function <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Lib.html"><code>dyn</code></a> <code>s = return (VarE (mkName s))</code> , which returns the <code>Exp</code> value representing the variable with the given name ( <code>dyn ‚à∑ String ‚Üí Q Exp</code> ). <br><br><h2>  Quote brackets </h2><br>  Constructing <code>Exp</code> values ‚Äã‚Äãthat represent an abstract syntax tree is a time consuming and boring job.  But fortunately, Template Haskell has quoting brackets that translate a specific Haskell code into a structure that represents it. <a name="habracut"></a><br>  They are of four types: <br><ul><li> <code>[e| ‚Ä¶ |]</code>  <code>[e| ‚Ä¶ |]</code> or <code>[| ‚Ä¶ |]</code>  <code>[| ‚Ä¶ |]</code> for expressions ( <code>‚à∑ Q Exp</code> ) </li><li> <code>[d| ‚Ä¶ |]</code>  <code>[d| ‚Ä¶ |]</code> for announcements ( <code>‚à∑ Q [Dec]</code> ) </li><li> <code>[t| ‚Ä¶ |]</code>  <code>[t| ‚Ä¶ |]</code> for types ( <code>‚à∑ Q Type</code> ) </li><li> <code>[p| ‚Ä¶ |]</code>  <code>[p| ‚Ä¶ |]</code> for samples (patterns) ( <code>‚à∑ Q Pat</code> ) </li></ul><br>  Accordingly, there should be a syntactically correct expression / declaration / type / pattern inside the brackets. <br>  For example a quote <code>[| Œª _ ‚Üí 0 |]</code>  <code>[| Œª _ ‚Üí 0 |]</code> is a structure <code>(return $ LamE [WildP] (LitE (IntegerL 0)))</code> .  The quotation is of type <code>Q Exp</code> (and not just <code>Exp</code> ), so it must be computed inside the citation monad, which allows Template Haskell to replace all identifiers appearing within the quotation with unique ones generated with <code>newName</code> .  For example, quote <code>[| Œªx ‚Üí x |]</code>  <code>[| Œªx ‚Üí x |]</code> will be converted to this code: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚Üê newName <span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $ LamE [<span class="hljs-keyword"><span class="hljs-keyword">VarP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>] (VarE <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)</code> </pre><br>  Further, inside the citing brackets, we can use inset (splicing), so that it turns out that TH acts as a macro preprocessor, processing part of the code written explicitly and part of the generated one.  For example, quote <code>[| 1 + $(fx) |]</code>  <code>[| 1 + $(fx) |]</code> calculate <code>(fx)</code> , which must be of type <code>Q Exp</code> , the result (structure of type <code>Exp</code> ), the result will be presented in the form of a usual Haskell-code and will insert ( <i>paste</i> ) it in place of <code>$(fx)</code> , and then continue quoting ‚Äî converting the resulting code into a structure that represents it.  Thanks to automatic renaming <i>(actually, for this purpose everything is done inside the monad <code>Q</code> )</i> , inside the quotation there will be no conflicts of local variable names between different inserts of the same code.  The following definition demonstrates this well: <br><pre> <code class="hljs 1c">summ ‚à∑ Int ‚Üí Q <span class="hljs-built_in"><span class="hljs-built_in">Exp</span></span> summ n = summ' n [| 0 |] summ' ‚à∑ Int ‚Üí Q <span class="hljs-built_in"><span class="hljs-built_in">Exp</span></span> ‚Üí Q <span class="hljs-built_in"><span class="hljs-built_in">Exp</span></span> summ' 0 code = code summ' n code = [<span class="hljs-string"><span class="hljs-string">| Œªx ‚Üí $(summ' (n-1) [| $code + x |]) |]</span></span></code> </pre><br>  This pattern generates a lambda expression with <code>n</code> parameters that summarizes them.  For example, <code>$(summ 3)</code> converted to <code>(Œªx1 ‚Üí Œªx2 ‚Üí Œªx3 ‚Üí 0 + x1 + x2 + x3)</code> .  Notice that the generated code uses different identifiers for the arguments of nested lambda expressions, although the pattern has one name: <code>[| Œªx ‚Üí ‚Ä¶ |]</code>  <code>[| Œªx ‚Üí ‚Ä¶ |]</code> .  As can be seen in this example, <strong>nesting of quotes and inserts can be any, but it is important that they alternate</strong> - you cannot quote inside the quotation and paste inside the insert. <br>  Such ‚Äúquasi-quoting‚Äù is a convenient way to represent Haskell programs.  And it has some limitations: each occurrence of a variable is associated with the value that is in the scope that is available before the templates are expanded.  This rule has three cases: <br><ol><li>  Quoting brackets prohibit the ‚Äúcapture‚Äù of local variables used in one quotation from another (just as in a regular Haskell program, you cannot use variable closures outside of it).  This is due, as mentioned above, to automatic unification of identifiers.  Only quote <code>[p| ‚Ä¶ |]</code>  <code>[p| ‚Ä¶ |]</code> does not rename those variables that the generated sample introduces <i>(since these variables will be linked when matching with the sample and if they have new arbitrary names, it is not clear how to access them)</i> . </li><li>  The global identifiers used in the quotation ‚Äúcapture‚Äù all the necessary identifiers available in the environment where the quotation is defined (again, as in ordinary Haskell), so the quotation value can be easily used in other modules that do not have access to all these internal definitions. or even have their own definitions for the same ids.  This rule uses the internal GHC mechanism for references to characters from other modules <i>(that is, qualifies them)</i> .  For example, quote <code>[| map |]</code>  <code>[| map |]</code> will be converted to ‚Äú <code>GHC.Base.map</code> ‚Äù, and a quote like <code>[t| [String] ‚Üí Bool |]</code>  <code>[t| [String] ‚Üí Bool |]</code> converted to ‚Äú <code>[GHC.Base.String] ‚Üí GHC.Bool.Bool</code> ‚Äù.  If you need identifiers precisely from the scope in which the template will be pasted, use the <code>$(dyn "‚Ä¶")</code> wrapper for them.  <i>It should be understood that this way you can accidentally use an identifier defined locally by someone else and a conflict will arise or the template will generate the wrong code, which is why it is written in the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Lib.html"><code>dyn</code></a> documentation that this is not a hygienic function.</i> </li><li>  Also, inside the citing brackets, you can use local variables of the function.  At the compilation stage, these are variables (just related identifiers), but during the execution of the code, these are just constants, so TH simply substitutes the corresponding values ‚Äã‚Äãin their places.  So, the expression <code>let x = 5 in [| ‚Ä¶ x ‚Ä¶ |]</code>  <code>let x = 5 in [| ‚Ä¶ x ‚Ä¶ |]</code> will be converted to <code>let x = 5 in [| ‚Ä¶ $(lift x) ‚Ä¶ |]</code>  <code>let x = 5 in [| ‚Ä¶ $(lift x) ‚Ä¶ |]</code> - <i>that is, you do not need to manually wrap the local variable identifier in type <code>Q Exp</code></i> . </li></ol><br>  Inserting and quoting are mutually inverse operations: one converts the <code>Exp</code> structure into a Haskell code, and the other Haskell code into an <code>Exp</code> structure, so they mutually annihilate: <br><pre> <code class="hljs ruby">$( [<span class="hljs-params"><span class="hljs-params">|  |</span></span>] ) ‚â°  [<span class="hljs-params"><span class="hljs-params">| $(  ) |</span></span>] ‚â° </code> </pre><br>  This allows thinking only in terms of the generated Haskell code, developing TH programs, and not thinking about the internal structures that represent its syntax. <br>  Consider for example the calculation of the ‚Äú <code>$(summ 3)</code> ‚Äù <code>$(summ 3)</code> .  We will simply replace the use of the template with its definition: <br><pre> <code class="hljs ruby"> $(summ <span class="hljs-number"><span class="hljs-number">3</span></span>) $(summ<span class="hljs-string"><span class="hljs-string">' 3 [| 0 |]) $([| Œªx ‚Üí $(summ'</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-params"><span class="hljs-params">| $([|</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">|]) + x |</span></span>]) <span class="hljs-params"><span class="hljs-params">|])</span></span></code> </pre><br>  Now we can remove the extra <code>$([| ‚Ä¶ |])</code> brackets <code>$([| ‚Ä¶ |])</code> , replacing the ‚Äú <code>x</code> ‚Äù along the way with a unique identifier: <br><pre> <code class="hljs mel"> Œªx1 ‚Üí $(summ<span class="hljs-string"><span class="hljs-string">' (3-1) [| 0 + x1 |])</span></span></code> </pre><br>  Again substitute the definition of <code>summ'</code> : <br><pre> <code class="hljs ruby"> Œªx1 ‚Üí $([<span class="hljs-params"><span class="hljs-params">| Œªx ‚Üí $(summ' (2-1) [|</span></span> $([<span class="hljs-params"><span class="hljs-params">| 0 + x1 |</span></span>]) + x <span class="hljs-params"><span class="hljs-params">|]) |</span></span>])</code> </pre><br>  Next, we will repeat the last two steps, while it is possible: <br><pre> <code class="hljs ruby"> Œªx1 ‚Üí Œªx2 ‚Üí $( summ<span class="hljs-string"><span class="hljs-string">' (2-1) [| 0 + x1 + x2 |] ) Œªx1 ‚Üí Œªx2 ‚Üí $([| Œªx ‚Üí $(summ'</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-params"><span class="hljs-params">| $([|</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + x1 + x2 <span class="hljs-params"><span class="hljs-params">|]) + x |</span></span>]) <span class="hljs-params"><span class="hljs-params">|]) Œªx1 ‚Üí Œªx2 ‚Üí Œªx3 ‚Üí $(summ' (1-1) [|</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + x1 + x2 + x3 <span class="hljs-params"><span class="hljs-params">|]) Œªx1 ‚Üí Œªx2 ‚Üí Œªx3 ‚Üí $( [|</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + x1 + x2 + x3 <span class="hljs-params"><span class="hljs-params">|]) Œªx1 ‚Üí Œªx2 ‚Üí Œªx3 ‚Üí 0 + x1 + x2 + x3</span></span></code> </pre><br>  Interestingly, in this definition, the left part of the lambda expression ( <code>Œªx1 ‚Üí Œªx2 ‚Üí ‚Ä¶</code> ) is recursively constructed as the recursion unfolds, and the right part ( <code>0 + x1 + ‚Ä¶</code> ) at the same time accumulates in the remaining part of the pattern.  The same technique is used in the <code>printf</code> sample template. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Example: printf </h2><br>  Now we will analyze the definition of the <code>printf</code> template, which was mentioned in the first part of the article.  The following is a code with explanations, as well as a Main module that uses it.  You can <code>ghc -XTemplateHaskell --make Main.hs</code> it with <code>ghc -XTemplateHaskell --make Main.hs</code> <br><ul><li>  Main.hs <br><pre> <code class="hljs kotlin">{-# LANGUAGE TemplateHaskell #-} module Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> --    printf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Printf (printf) --  $( ‚Ä¶ )      --   Haskell-     --       ‚Äì   putStrLn main = putStrLn ( $(printf <span class="hljs-string"><span class="hljs-string">"Error in file %s line %d: %s"</span></span>) <span class="hljs-string"><span class="hljs-string">"io.cpp"</span></span> <span class="hljs-number"><span class="hljs-number">325</span></span> <span class="hljs-string"><span class="hljs-string">"printer not found"</span></span> )</code> </pre><br><br>  Printf.hs <br><pre> <code class="hljs rust">{-# LANGUAGE TemplateHaskell #-} module Printf <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> --   Template Haskell import Language.Haskell.TH --    data Format = D --  <span class="hljs-string"><span class="hljs-string">"%d"</span></span> ‚Äì   | S --  <span class="hljs-string"><span class="hljs-string">"%s"</span></span> ‚Äì   | L <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> --    (L  Literally) --    ‚Äì     Format parse :: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; [Format] parse <span class="hljs-string"><span class="hljs-string">""</span></span> rest = [L rest] parse (<span class="hljs-string"><span class="hljs-string">'%'</span></span>:<span class="hljs-string"><span class="hljs-string">'d'</span></span>:xs) rest = L rest : D : parse xs <span class="hljs-string"><span class="hljs-string">""</span></span> parse (<span class="hljs-string"><span class="hljs-string">'%'</span></span>:<span class="hljs-string"><span class="hljs-string">'s'</span></span>:xs) rest = L rest : S : parse xs <span class="hljs-string"><span class="hljs-string">""</span></span> parse (x:xs) rest = parse xs (rest++[x]) --  Haskell-,    --   - gen :: [Format] -&gt; ExpQ -&gt; ExpQ gen [] code = code gen (D : xs) code = [| \x -&gt; $(gen xs [| $code ++ show x |]) |] gen (S : xs) code = [| \x -&gt; $(gen xs [| $code ++ x |]) |] gen (L s : xs) code = gen xs [| $code ++ s |] -- ,       --       printf :: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> -&gt; ExpQ printf s = gen (parse s <span class="hljs-string"><span class="hljs-string">""</span></span>) [| <span class="hljs-string"><span class="hljs-string">""</span></span> |]</code> </pre><br><br>  <i>This is an author code with translated comments.</i>  <i>A similar, but shorter (and simpler, in my opinion) solution can be found here: <a href="https://gist.github.com/1368245">Gist</a> .</i> <br><br><h3>  Other examples </h3><br>  <i>I experimented a bit with quoting function declarations and sticking names ‚Äî these experiments are described in <a href="http://laughedelic.github.com/blog/categories/template-haskell/">my blog</a> .</i>  <i>I will be glad to advice and recommendations.</i> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/132679/">https://habr.com/ru/post/132679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132673/index.html">Report from the Russian presentation of the Samsung Galaxy Note</a></li>
<li><a href="../132674/index.html">Qt + OpenGl Basics. Part 1</a></li>
<li><a href="../132676/index.html">We write online game part 2 or work on the bugs</a></li>
<li><a href="../132677/index.html">Sketch - 100 seconds about Asus</a></li>
<li><a href="../132678/index.html">ThinkQuest 2012. Mini-grants for teachers</a></li>
<li><a href="../132680/index.html">QVV, QVC, and now - QVP: a plastic card from QIWI Wallet</a></li>
<li><a href="../132682/index.html">JavaScript Decorators</a></li>
<li><a href="../132683/index.html">Algorithms LZW, LZ77 and LZ78</a></li>
<li><a href="../132684/index.html">X Neural Switcher - Cookbook (Part 1). Forerunners and analogues</a></li>
<li><a href="../132687/index.html">Just in case, US universities occupy .XXX domains.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>