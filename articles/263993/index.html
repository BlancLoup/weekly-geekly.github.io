<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuously distributed random variables generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The random number generator is in many ways similar to sex: when it‚Äôs good, it‚Äôs fine, when it‚Äôs bad, it‚Äôs still nice (George Marsalya, 1984) 
 The po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuously distributed random variables generators</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  The random number generator is in many ways similar to sex: when it‚Äôs good, it‚Äôs fine, when it‚Äôs bad, it‚Äôs still nice (George Marsalya, 1984) </blockquote><br>  The popularity of stochastic algorithms is growing.  Many of them are based on the generation of a large number of different random variables.  Not always evenly distributed.  Here I tried to collect information about fast and accurate random variable generators with known distributions.  Tasks may be different, criteria may be different.  The generation time is important to someone, accuracy to someone, cryptostability to someone, speed of convergence to someone.  Personally, I proceeded from the assumption that we have a certain basic generator that returns a pseudo-random integer uniformly distributed from 0 to a certain RAND_MAX <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BasicRandGenerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> randomVariable; <span class="hljs-comment"><span class="hljs-comment">// some magic here ... return randomVariable; }</span></span></code> </pre> <br>  and that this generator is fast enough.  I mean, it's cheaper to generate a dozen random numbers, rather than calculate the logarithm or raise one of them to a power.  These can be standard generators: std :: rand (), rand in MATLAB, Java.util.Random, etc.  But keep in mind that these generators are rarely suitable for serious work.  Often they fail various statistical tests.  And also, remember that you are completely dependent on them and it is better to use your own generator to have an idea of ‚Äã‚Äãits work. <br><br>  In the article I will talk about algorithms, the essence of which should be clear to anyone who has ever come across the theory of probability.  It is not necessary to be familiar with the theory of measure, as a rule, it‚Äôs rather enough to understand what the distribution function and the density distribution function are: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/591/8a7/1dc/5918a71dcb1e4a6bb432c273bc65541d.png"></div><br>  I will accompany each algorithm with a code, a small amount of mathematics and a histogram of ten million generated random variables. <br><br><h4>  <font color="#089">Uniform distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/abf/358/849/abf35884902446349f8fd3516788f894.png"></div><br><img src="https://habrastorage.org/files/ccb/249/991/ccb24999157e4f0d9b268e4b6bb7374d.png"><br><br><a name="habracut"></a><br>  Uniform distribution can be used when generating almost any random variable, since there is a very simple and universal <b>method of inversion (inverse transform sampling)</b> : generate a random variable U uniformly distributed from 0 to 1, and return the inverse distribution function (quantile) with the parameter U. Really: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/db6/c26/038/db6c260383fb4971b4b2455942989543.png"></div><br>  The problem is that the calculation of the inverse distribution function can be long, if analytically possible at all. <br><br>  With a uniform distribution generator, I hope I don‚Äôt need to stop for a long time (with a large number of random variables generated, it‚Äôs better to count (b - a) / RAND_MAX only once): <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Uniform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + BasicRandGenerator() * (b - a) / RAND_MAX; }</code> </pre><br>  Of course, continuity is just an abstraction.  In the real world, and in this case, specifically, this implies a rather small discretization step.  It is worth noting an important thing.  If you generate a random number evenly distributed from 0 to 1, then 32 bits are not enough to cover all the values ‚Äã‚Äãthat double can take on this range (although, for a float, this is more than enough).  For better quality, you must either generate 64-bit integers, or combine two 32-bit integers. <br><br><h4>  <font color="#089">Normal distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/37d/dbf/53c/37ddbf53cb9647c7a05f56d103b48be8.png"></div><br><img src="https://habrastorage.org/files/4c1/b82/f29/4c1b82f299d94f699445074edf682498.png"><br><br>  The inversion method will require the calculation of the inverse error function.  If you do not use special approximating functions, it is difficult and incredibly long.  For a normal quantity, there is the Box-Muller method.  It is quite simple and widespread.  Its obvious disadvantage is the computation of transcendental functions.  On Habr√©, the <a href="http://habrahabr.ru/post/208684/">polar method</a> has already been mentioned, which helps to avoid counting sine and cosine.  But we still have to read the logarithm and the root of it.  The beautifully named Ziggurat method, invented by George Marsalla, the author of the same polar method, works much faster. <br>  The polar method is an example of a <b>sample with a deviation (acceptance-rejection sampling)</b> .  Literally, you generate a value and accept it if it fits; otherwise, reject and generate it again.  The main example: you need to generate a random variable with a density f (x), but it is too difficult to do with a simple inversion method.  On the other hand, you can generate a random variable with a density g (x) not very different from f (x).  In this case, you take the smallest constant M, such that M&gt; 1 and almost everywhere f (x) &lt;Mg (x), and perform the following algorithm: <br><br><ul><li>  We generate a random variable X from the distribution g (x) and a random variable U, uniformly distributed from 0 to 1. </li><li>  If U &lt;f (X) / Mg (X) - return X, otherwise - repeat again. </li></ul><br>  The probability of accepting a random variable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f36/9f9/1a2/f369f91a23a74cfba2c052d76f8bffb8.png"></div><br>  The less you choose M - the more this probability - the faster the generator will work. <br><br><div class="spoiler">  <b class="spoiler_title">Proof of the algorithm:</b> <div class="spoiler_text">  Taking advantage of the fact that the probability of the origin of two events A and B is equal to <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/39e/e7e/cd5/39ee7ecd501f48a4b894cb3beaf1106e.png"></div><br>  Let us calculate the probability of accepting a random variable X with the distribution density function g (x) and the distribution function G (x), but under the condition that it is less than a certain given parameter x: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/39a/214/0f7/39a2140f72944aa8b10b1937a2c62006.png"></div><br>  And then according to the Bayes theorem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1e6/961/29b/1e696129b9be44369efe70db3fab4b7d.png"></div><br></div></div><br><img src="https://habrastorage.org/files/f34/cdd/4ce/f34cdd4cebc74954995a19eeba770dc8.png" align="right"><br>  For example, we generate a module of a standard normal value.  By virtue of the symmetry of the normal distribution, the resulting value can be multiplied by a random variable taking values ‚Äã‚Äãof +1 and -1 with equal probabilities, and thus a standard normally distributed quantity X. Any normal quantity is obtained from the standard multiplication by sigma and a shift by mu.  Density distribution function | X |: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7fc/abf/6f6/7fcabf6f6332427d9bb768e5d523072b.png"></div><br>  We will try to approximate it with the density function of the standard exponential distribution.  I am running a little ahead, because I have not yet spoken about the exponential distribution.  It is generated simply by the notorious inversion method - we take the value U uniformly distributed on [0, 1] and return -ln (U). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/335/83c/269/33583c269a314210b86f1574f34c8f5b.png"></div><br>  The minimum value of M, satisfying the condition f (x) &lt;Mg (x), is achieved at x = 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f29/c1a/1f9/f29c1a1f9b9c442e91cd8503038c5dee.png"></div><br>  Then: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/16d/9a6/76c/16d9a676c3d44c2c90b476de53e499a7.png"></div><br>  And the algorithm for generating a normal random variable will be as follows: <br><br><ol><li>  We generate U - uniformly distributed random variable on [0, 1]. </li><li>  We generate an exponentially distributed random variable E (about an algorithm that is faster than the calculation of -ln (U), I will tell further). </li><li>  If U &lt;exp (- (E - 1) <sup>2</sup> ) - then | X |  = E, otherwise we return to the first step. </li><li>  We generate a new U. If U &lt;0.5, then we return - | X |, or | X |  otherwise. </li></ol><br>  It is easy to see that: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e94/058/7e4/e940587e48164083b303ab73b4fbc8e5.png"></div><br>  And this means that instead of U, you can generate another exponentially distributed quantity and not consider an exponential function.  The new algorithm will look like this: <br><br><ol><li>  We generate standard exponentially distributed random variables E <sub>1</sub> and E <sub>2</sub> . </li><li>  If E <sub>2</sub> &gt; (E <sub>1</sub> - 1) 2/2, then we take | X |  = E <sub>1</sub> , otherwise go back. </li><li>  We generate U. If U &lt;0.5, then we return - | X |, or | X |  otherwise. </li></ol><br>  Another point: if the value of E <sub>1 is</sub> accepted, the difference E <sub>2</sub> - (E <sub>1</sub> - 1) 2/2 will also be distributed exponentially and independently of E <sub>1</sub> .  Therefore, it can be memorized and used next time instead of E <sub>1</sub> . <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  The exponential distribution has the absence of memory property: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b4d/ff1/22e/b4dff122edd140a2b3d8b9ccb38bd417.png"></div><br>  This means that the difference distribution function: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/858/15c/558/85815c558051415fb31cf4797125e9ea.png"></div><br></div></div><br>  The general problem of a sample with a deviation is the selection of such a random variable with a distribution density g (x) so that the deviations are as small as possible.  To solve this problem, there are many extensions.  The method itself is the basis for almost all subsequent algorithms, including Ziggurat.  The essence of the latter is the same: we try to cover the density function of the normal distribution with a similar and simpler function and return the values ‚Äã‚Äãthat fall under the curve.  The function is unique and resembles a multistage structure, from which, in fact, this is the name of the algorithm. <br><br><img src="https://habrastorage.org/files/ab0/a18/218/ab0a18218b3f49dabf712e2b1f7892fc.png" align="right" height="220" width="380"><br>  Ziggurat is constructed as follows.  At the foot of the function f (x), the points x <sub>1</sub> and y <sub>0</sub> = f (x <sub>1</sub> ) are selected.  The area under the rectangle from (0,0) to (x <sub>1</sub> , y <sub>0</sub> ) + the area under the tail of the function f (x&gt; x <sub>1</sub> ) = A. So we built the base layer.  Another rectangle is placed on top of it, such that its width is x <sub>1</sub> , and the height is y <sub>1</sub> = A / y <sub>0</sub> and thus its area will be A. This rectangle already includes points that lie above the function f (x), for example (x <sub>1</sub> , y <sub>1</sub> ).  The second rectangle intersects the function f (x) at the point (x <sub>2</sub> , y <sub>1</sub> ) - this will be the coordinate of the lower right point of the third rectangle, which is superimposed in the same way as the second, so that its area is A. This continues until we will not build a ziggurat to the top of the function.  The area of ‚Äã‚Äãeach step will be equal to A. Further algorithm <i>(without processing to fall into the base layer)</i> : <br><br><ol><li>  Randomly and uniformly select the rectangle i and generate a uniformly distributed value X from 0 to x <sub>i</sub> </li><li>  If X &lt;x <sub>i + 1</sub> , then we definitely got under the curve - return X. </li><li>  We generate a new uniformly distributed quantity Y from y <sub>i</sub> to y <sub>i + 1</sub> .  If the point with coordinates (X, Y) lies under the curve, that is, Y &lt;f (X) - we return X. Otherwise we return to the first step. </li></ol><br>  What to do if you hit the base layer?  You can also make a rectangle from it with area A by entering an imaginary point x <sub>0</sub> = A / y <sub>0</sub> .  Then the area of ‚Äã‚Äãthe rectangle from (0,0) to (x <sub>0</sub> , y <sub>0</sub> ) will also be equal to A. The difference in the base layer is that if we do not fall under the curve in the new imaginary rectangle, then we should not reject x - we just hit the tail.  For the tail, George Marsalla suggests using the same method that we had previously considered - a sample with a deviation.  Only with some changes: <br><br><ol><li>  We generate standard exponentially distributed random variables E <sub>1</sub> with density x <sub>1</sub> and E <sub>2</sub> with unit density. </li><li>  If E <sub>2</sub> &gt; E <sub>1</sub> 2/2, then we take | X |  = E <sub>1</sub> + x <sub>1</sub> , otherwise we go back. </li><li>  We generate U. If U &lt;0.5, then we return - | X |, or | X |  otherwise. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Proof for tail</b> <div class="spoiler_text">  We know that the random variable | X |  &gt; x <sub>1</sub> .  We will try to construct for it a sampling algorithm with a deviation using E <sub>1</sub> + x <sub>1</sub> , where E <sub>1</sub> is an exponentially distributed random variable with density x <sub>1</sub> .  Density distribution function E <sub>1</sub> + x <sub>1</sub> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d64/13b/e4d/d6413be4da954ef0bf0efe02137a9784.png"></div><br>  To know the value of M, we need to find the maximum of the ratio of functions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/721/13e/7ad/72113e7ad55141d6b9906c1045918355.png"></div><br>  The point x corresponding to the maximum fraction will deliver the maximum degree of the exponent.  Equating the derivative of degree to zero, we find the corresponding x: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fba/75c/174/fba75c17467f4d46ab59d1e649f01200.png"></div><br>  We get the boundary for a uniform random variable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b77/c5d/7f9/b77c5d7f9cdc44c1b260461e1d8520cc.png"></div><br>  And then the condition for accepting a random variable will be: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/776/516/401/776516401f0749a8b96a3d090b9bba21.png"></div><br></div></div><br>  Then the algorithm will look completely like this: <br><br><ol><li>  Randomly and uniformly select the rectangle i and generate a uniformly distributed value X from 0 to x <sub>i</sub> . </li><li>  If X &lt;x <sub>i + 1</sub> , then we definitely got under the curve - return X. </li><li>  If you hit the base layer, that is, i = 0, then we run the algorithm for the tail and return its result. </li><li>  We generate a new uniformly distributed quantity Y from y <sub>I</sub> to y <sub>i + 1</sub> .  If the point with coordinates (X, Y) lies under the curve, that is, Y &lt;f (X) - we return X. Otherwise we return to the first step. </li></ol><br>  The question is how to find the constants A and x <sub>1</sub> depending on the number of rectangles?  You can find them by an ordinary numerical method.  We take the initial assumption x <sub>1</sub> , build the base layer, calculate A and build the ziggurat until we have built the required number of rectangles.  If we were above the function, it means we took too small a value of x <sub>1</sub> and a too large value of A - try to build with new values ‚Äã‚Äãagain. <br><br>  The algorithm itself can be accelerated by various tricks of work with 32-bit integers, removing unnecessary multiplication.  For more information, see George Marsaglia and Wai Wan Tsang, "The Ziggurat Method for Generating Random Variables."  Here I imagine not fully optimized, but clear code (given that we can generate exponential distribution). <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">double</span></span> stairWidth[<span class="hljs-number"><span class="hljs-number">257</span></span>], stairHeight[<span class="hljs-number"><span class="hljs-number">256</span></span>]; const <span class="hljs-type"><span class="hljs-type">double</span></span> x1 = <span class="hljs-number"><span class="hljs-number">3.6541528853610088</span></span>; const <span class="hljs-type"><span class="hljs-type">double</span></span> A = <span class="hljs-number"><span class="hljs-number">4.92867323399e-3</span></span>; /// area under rectangle <span class="hljs-type"><span class="hljs-type">void</span></span> setupNormalTables() { // coordinates <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the implicit rectangle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> base layer stairHeight[<span class="hljs-number"><span class="hljs-number">0</span></span>] = exp(<span class="hljs-number"><span class="hljs-number">-.5</span></span> * x1 * x1); stairWidth[<span class="hljs-number"><span class="hljs-number">0</span></span>] = A / stairHeight[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // implicit <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the top layer stairWidth[<span class="hljs-number"><span class="hljs-number">256</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">255</span></span>; ++i) { // such x_i that f(x_i) = y_{i<span class="hljs-number"><span class="hljs-number">-1</span></span>} stairWidth[i] = sqrt(<span class="hljs-number"><span class="hljs-number">-2</span></span> * log(stairHeight[i - <span class="hljs-number"><span class="hljs-number">1</span></span>])); stairHeight[i] = stairHeight[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + A / stairWidth[i]; } } <span class="hljs-type"><span class="hljs-type">double</span></span> NormalZiggurat() { <span class="hljs-type"><span class="hljs-type">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { unsigned long long B = BasicRandGenerator(); <span class="hljs-type"><span class="hljs-type">int</span></span> stairId = B &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span> x = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, stairWidth[stairId]); // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> horizontal coordinate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; stairWidth[stairId + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((signed)B &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? x : -x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stairId == <span class="hljs-number"><span class="hljs-number">0</span></span>) // handle the base layer { static <span class="hljs-type"><span class="hljs-type">double</span></span> z = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) // we don<span class="hljs-string"><span class="hljs-string">'t have to generate another exponential variable as we already have one { x = Exponential(x1); z -= 0.5 * x * x; } if (z &lt;= 0) // if previous generation wasn'</span></span>t successful { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = Exponential(x1); y = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); z = y - <span class="hljs-number"><span class="hljs-number">0.5</span></span> * x * x; // we <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> acceptance it becomes exponentially distributed } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); } x += x1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((signed)B &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? x : -x; } // handle the wedges <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> other stairs <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Uniform(stairHeight[stairId - <span class="hljs-number"><span class="hljs-number">1</span></span>], stairHeight[stairId]) &lt; exp(<span class="hljs-number"><span class="hljs-number">-.5</span></span> * x * x)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((signed)B &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? x : -x; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++iter &lt;= <span class="hljs-number"><span class="hljs-number">1e9</span></span>); /// one billion should be enough <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>; /// fail due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> error } <span class="hljs-type"><span class="hljs-type">double</span></span> Normal(<span class="hljs-type"><span class="hljs-type">double</span></span> mu, <span class="hljs-type"><span class="hljs-type">double</span></span> sigma) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu + NormalZiggurat() * sigma; }</code> </pre><br><br><h4>  <font color="#089">Exponential distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5b8/8e6/80d/5b88e680db99481eab2ddd004b75ee6b.png"></div><br><img src="https://habrastorage.org/files/0d7/10e/5ea/0d710e5ea51740d886659b770ec6e17d.png"><br><br>  It has already been said that for an exponential distribution one can take the logarithm of a uniformly distributed quantity and what can be done to generate faster.  Since any exponential value is obtained from the standard division by density, the generation can be made notorious Ziggurat.  In the case of hitting the tail, you can run the algorithm on the new and add to the resulting value x <sub>1</sub> : <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  It is necessary to prove that for E&gt; x <sub>1</sub> the distribution function E - x <sub>1</sub> will also be distributed exponentially.  This is possible due to the previously mentioned lack of memory in the exponential distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/654/82c/950/65482c95049748c3aa8cef7e1932a35b.png"></div><br></div></div><br>  A couple more facts: if you use a table with 255 rectangles, then the probability of accepting from the first time for the exponential distribution is 0.989, for a normal one - 0.993.  In MATLAB version 5, Ziggurat is used for normal distribution (the polar method was used before).  In R, for normal values, as far as I know, the inverse error function is approximated by polynomials and the inversion method is used. <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">double</span></span> stairWidth[<span class="hljs-number"><span class="hljs-number">257</span></span>], stairHeight[<span class="hljs-number"><span class="hljs-number">256</span></span>]; const <span class="hljs-type"><span class="hljs-type">double</span></span> x1 = <span class="hljs-number"><span class="hljs-number">7.69711747013104972</span></span>; const <span class="hljs-type"><span class="hljs-type">double</span></span> A = <span class="hljs-number"><span class="hljs-number">3.9496598225815571993e-3</span></span>; /// area under rectangle <span class="hljs-type"><span class="hljs-type">void</span></span> setupExpTables() { // coordinates <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the implicit rectangle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> base layer stairHeight[<span class="hljs-number"><span class="hljs-number">0</span></span>] = exp(-x1); stairWidth[<span class="hljs-number"><span class="hljs-number">0</span></span>] = A / stairHeight[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // implicit <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the top layer stairWidth[<span class="hljs-number"><span class="hljs-number">256</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">255</span></span>; ++i) { // such x_i that f(x_i) = y_{i<span class="hljs-number"><span class="hljs-number">-1</span></span>} stairWidth[i] = -log(stairHeight[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); stairHeight[i] = stairHeight[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + A / stairWidth[i]; } } <span class="hljs-type"><span class="hljs-type">double</span></span> ExpZiggurat() { <span class="hljs-type"><span class="hljs-type">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-type"><span class="hljs-type">int</span></span> stairId = BasicRandGenerator() &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-type"><span class="hljs-type">double</span></span> x = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, stairWidth[stairId]); // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> horizontal coordinate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; stairWidth[stairId + <span class="hljs-number"><span class="hljs-number">1</span></span>]) /// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we are under the upper stair - accept <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stairId == <span class="hljs-number"><span class="hljs-number">0</span></span>) // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we catch the tail <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x1 + ExpZiggurat(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Uniform(stairHeight[stairId - <span class="hljs-number"><span class="hljs-number">1</span></span>], stairHeight[stairId]) &lt; exp(-x)) // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we are under the curve - accept <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; // rejection - go back } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++iter &lt;= <span class="hljs-number"><span class="hljs-number">1e9</span></span>); // one billion should be enough <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be sure there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a bug <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>; // fail due <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> error } <span class="hljs-type"><span class="hljs-type">double</span></span> Exponential(<span class="hljs-type"><span class="hljs-type">double</span></span> rate) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpZiggurat() / rate; }</code> </pre><br><br><h4>  <font color="#089">Gamma distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/42a/771/a70/42a771a70a5e483ab100b659e7a9b769.png"></div><br><img src="https://habrastorage.org/files/740/290/742/74029074278e4b5daa7c048c9f8da5b0.png"><br><br>  Algorithms for generating here are more complicated, so I will not describe their evidence here, I give only examples.  To generate a standard value (theta = 1), four algorithms are used, each depending on k. <br><ul><li>  If k or 2k is an integer and k &lt;5 is a GA algorithm. </li><li>  If k &lt;1 - GS algorithm. </li><li>  If 1 &lt;k &lt;3 - GF algorithm. </li><li>  If k&gt; 3 - GO algorithm. </li></ul><br>  Non-standard random variable with gamma distribution, obtained from the standard multiplication by theta. <br><br><h5>  GA algorithm </h5><br>  If we add two random variables with the gamma distribution with the parameters k1 and k2, we get a random variable with the gamma distribution and with the parameter k1 + k2.  Another property - if theta = k = 1, then it is easy to verify that the distribution will be exponential.  Therefore, if k is integer - then you can simply sum up k random variables with standard exponential distribution. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GA1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k; ++i) x += Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre><br>  If k is not integer, but 2k is integer, then instead of one of the exponential random variables in total, one can use half of the square of the normal value.  Why is it possible, it will become clear later. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GA2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = Normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span> * x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; k; ++i) x += Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre><br><br><h5>  GS Algorithm </h5><br><ol><li>  We generate the standard exponentially distributed quantity E and the quantity U, uniformly distributed from 0 to 1 + k / e.  If U &lt;= 1, then go to step 2. Otherwise, to step 3. </li><li>  Set x = U <sup>1 / k</sup> .  If x &lt;= E, then return x, otherwise go back to step 1. </li><li>  Set x = -ln ((1 - U) / k + 1 / e).  If (1 - k) * ln (x) &lt;= E, then we return x, otherwise we return to step 1. </li></ol><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> GS(<span class="hljs-type"><span class="hljs-type">double</span></span> k) { // Assume that k &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { // M_E <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> base <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">natural</span></span> logarithm <span class="hljs-type"><span class="hljs-type">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> + k / M_E) <span class="hljs-type"><span class="hljs-type">double</span></span> W = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = pow(U, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / k); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt;= W) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = -log((<span class="hljs-number"><span class="hljs-number">1</span></span> - U) / k + <span class="hljs-number"><span class="hljs-number">1.0</span></span> / M_E); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span> - k) * log(x) &lt;= W) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++iter &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>); // excessive maximum number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> rejections <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>; // shouldn<span class="hljs-string"><span class="hljs-string">'t end up here }</span></span></code> </pre><br><br><h5>  GF algorithm </h5><br>  As far as I know, the author of this algorithm, a professor at the University of North Carolina, J. S. Fishman, did not publish his achievement.  The algorithm itself works for k&gt; 1, however, its average execution time increases proportionally to sqrt (k), therefore it is effective only for k &lt;3. Algorithm: <br><ol><li>  We generate two independent random variables E <sub>1</sub> and E <sub>2</sub> with standard exponential distribution. </li><li>  If E <sub>2</sub> &lt;(k - 1) * (E <sub>1</sub> - ln (E <sub>1</sub> ) - 1), then go back to step 1. </li><li>  Return x = k * E <sub>1</sub> </li></ol><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">  <i>Theorem.</i>  Let U be a uniformly distributed random variable on [0, 1] and W is an exponentially distributed random variable with a density of 1 / lambda.  Let be: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aee/8d9/ea4/aee8d9ea45eb4a6592311a588389b6e0.png"></div><br>  If g (W)&gt; = U, then W has a gamma distribution with the lambda parameter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ed2/50d/a07/ed250da0791e475ead7decae3982557f.png"></div><br>  <i>Evidence.</i>  Distribution density function W: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/086/2d8/122/0862d812288d4511b243691cc8faee25.png"></div><br>  In this way, <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5fe/f1e/7db/5fef1e7dbdc24e5e974bd0e9606d8c4f.png"></div><br>  Since U has a uniform distribution, <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fa7/35e/b51/fa735eb517fa491480d9fd20c8f163d8.png"></div><br>  if 0 &lt;g (x) &lt;1. Then the unconditional probability: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fde/d64/5c0/fded645c0c7d44e8b29e204dd06e2c10.png"></div><br>  As a result, the conditional probability density: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/421/59b/d05/42159bd05dd849ecaa16c1e042af463b.png"></div><br>  qed <br>  The generator efficiency is determined by the probability that U &lt;= g (W), which is equal to C (lambda).  For large values ‚Äã‚Äãof the \ lambda parameter, using the Stirling approximation, we can roughly calculate the probability: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f9c/e2b/975/f9ce2b9753484058b1dffce2f2f7a577.png"></div><br>  The algorithm becomes inefficient with a growing lambda. <br></div></div><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> GF(<span class="hljs-type"><span class="hljs-type">double</span></span> k) { // Assume that <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; k &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> E1, E2; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { E1 = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); E2 = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (E2 &lt; (k - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (E1 - log(E1) - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k * E1; }</code> </pre><br><br><h5>  GO Algorithm </h5><br>  The algorithm of Dieter and Arens is based on the asymptotic normality of the distribution with increasing parameter, and therefore is faster for large k.  It works for k&gt; 2.533, but not as efficient as the Fisher algorithm for k &lt;3. First, you need to set some constants (depending only on k). <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setupConstants(<span class="hljs-type"><span class="hljs-type">double</span></span> k) { m = k - <span class="hljs-number"><span class="hljs-number">1</span></span>; s_2 = sqrt(<span class="hljs-number"><span class="hljs-number">8.0</span></span> * k / <span class="hljs-number"><span class="hljs-number">3</span></span>) + k; s = sqrt(s_2); d = M_SQRT2 * M_SQRT3 * s_2; b = d + m; w = s_2 / (m - <span class="hljs-number"><span class="hljs-number">1</span></span>); v = (s_2 + s_2) / (m * sqrt(k)); c = b + log(s * d / b) - m - m - <span class="hljs-number"><span class="hljs-number">3.7203285</span></span>; } <span class="hljs-type"><span class="hljs-type">double</span></span> GO(<span class="hljs-type"><span class="hljs-type">double</span></span> k) { // Assume that k &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-type"><span class="hljs-type">double</span></span> U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U &lt;= <span class="hljs-number"><span class="hljs-number">0.0095722652</span></span>) { <span class="hljs-type"><span class="hljs-type">double</span></span> E1 = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">double</span></span> E2 = Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>); x = b * (<span class="hljs-number"><span class="hljs-number">1</span></span> + E1 / d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m * (x / b - log(x / m)) + c &lt;= E2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">double</span></span> N; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { N = Normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); x = s * N + m; // ~ Normal(m, s) } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt; b); U = Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">double</span></span> S = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * N * N; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (N &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> - w * S) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> + S * (v * N - w)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (log(U) &lt; m * log(x / m) + m - x + S) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (++iter &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>; // shouldn<span class="hljs-string"><span class="hljs-string">'t end up here; }</span></span></code> </pre><br><br>  As in the case of previous distributions, any value with a gamma distribution is generated from the standard multiplication by the theta parameter.  Being able to generate uniform, normal, exponential and gamma distributions, you most likely can easily get most of the other distributions, since they can easily be expressed through the aforementioned ones. <br><br><h4>  <font color="#089">Cauchy distribution</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/534/f41/144/534f41144b454f34a522b273a3e62c0a.png"></div><br><img src="https://habrastorage.org/files/dd6/1b4/563/dd61b45634cc4009b4c6a9036c018ff9.png"><br>  One way to quickly get a random variable with a Cauchy distribution is to take two normal random variables and divide them into each other.  Is it faster?  You can use the usual method of inversion, but it will require the calculation of tangent.  This is even slower. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/2f9/72b/c3f/2f972bc3fdb8403f883d4a55949bb436.png"></div><br>  Or not? <br><img src="https://habrastorage.org/files/398/991/989/3989919897a84d4db2b6b86ffb06dc96.png" align="right" height="140"><br>  Remember the polar method of George Marsaly?     -         .        .       x  y   [-1, 1]x[-1, 1].         (0, 0)    ‚Äî  x/y,  ‚Äî  x  y  .     , ,       0.01. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cauchy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gamma</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, y; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = Uniform(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); y = Uniform(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x * x + y * y &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span> || y == <span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x0 + gamma * x / y; }</code> </pre><br><br><h4> <font color="#089"> </font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/492/d26/1ee/492d261eeac04942ac6ee989dc9e13e1.png"></div><br><img src="https://habrastorage.org/files/198/f49/29c/198f4929c74a438c88edeeab124d78c4.png"><br>   ‚Äî    ,    . <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Laplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> E = Exponential(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu + (((<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span>)BasicRandGenerator() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? E : -E); }</code> </pre><br><br><h4> <font color="#089"> </font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/7ce/b35/45f/7ceb3545f08f4706817be626042a39a2.png"></div><br><img src="https://habrastorage.org/files/ee1/545/090/ee15450903184b60bcaac1cccff3faa7.png"><br><br>   ,      ,        : <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Levy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> N = Normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu + c / (N * N); }</code> </pre><br><br><h4> <font color="#089"> -</font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5df/251/ae2/5df251ae25474d25ac2f7e40a4e6ac71.png"></div><br><img src="https://habrastorage.org/files/a05/f2c/036/a05f2c0363d949ad986d9cc06cfe4325.png"><br>  ,     -   k ‚Äî    k    .  ,    k      k/2    (   ).        GA2: <br><br><div class="spoiler">  <b class="spoiler_title">Evidence</b> <div class="spoiler_text">    ,    ‚Äî      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6da/ea3/788/6daea37880834b2d81604bbb43fc7f3c.png"></div><br>            : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c5e/a45/366/c5ea4536606a416680880544e9e52be1.png"></div><br>  E ‚Äî     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/73a/933/c47/73a933c471aa4e27adcfe0646e0a01f1.png"></div><br>    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a65/867/180/a65867180a854b1caeedb87c36d6668f.png"></div><br>            : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/df1/2e0/6dd/df12e06ddf7a4404b6f91d67d36587d4.png"></div><br>      -,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bd3/35a/345/bd335a345916482b900d6f992c7b8280.png"></div><br>  .    ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f11/d1a/ed3/f11d1aed3a174b1088898f7292c85261.png"></div><br>   , : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bbc/1b9/3dd/bbc1b93dd4814c3bba2c486b393b031d.png"></div><br>  qed <br></div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> ChiSquared(<span class="hljs-type"><span class="hljs-type">int</span></span> k) { // ~ Gamma(k / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span>) // too big parameter <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GO(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * k); <span class="hljs-type"><span class="hljs-type">double</span></span> x = ((k &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) ? GA2(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * k) : GA1(k &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + x; }</code> </pre><br>      :           (x, y),    (0,0)      . <br><br><h4> <font color="#089"> </font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e8c/31f/d40/e8c31fd4022d490dbe0e7b5f8f687298.png"></div><br><img src="https://habrastorage.org/files/e86/36e/6ec/e8636e6ec7c341f3b0f6f05ac3eb3ee9.png"><br> ,       ,      .  , -, -      ‚Äî  .  ,     , , ,          /  -. ,   .   : <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sigma)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(Normal(mu, sigma)); }</code> </pre><br><br><h4> <font color="#089"> </font> </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/588/c68/3ef/588c683ef54743968b26d22238a6366d.png"></div><br><img src="https://habrastorage.org/files/7a4/208/fe4/7a4208fe40ff43af959dc3339dd77af6.png"><br>      ,     ,       : <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Logistic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mu, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mu + s * <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><br>      ,        : <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Erlang</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GA1(k) / l; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Weibull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(Exponential(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rayleigh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sigma)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sigma * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Exponential(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pareto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xm / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(Uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / alpha); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StudentT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cauchy(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(ChiSquared(v) / v); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FisherSnedecor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numerator = d2 * ChiSquared(d1); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> denominator = d1 * ChiSquared(d2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numerator / denominator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Beta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x = Gamma(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / (x + Gamma(b)); }</code> </pre><br><br>  <a href="https://github.com/Quanteeks/RandLib">Implementing these and other C ++ generators 17</a> </div><p>Source: <a href="https://habr.com/ru/post/263993/">https://habr.com/ru/post/263993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263979/index.html">Soon ICFPC 2015</a></li>
<li><a href="../263981/index.html">The digest of interesting materials for the mobile developer # 114 (July 27-August 2)</a></li>
<li><a href="../263983/index.html">Implementing a search engine with Python ranking (Part 3)</a></li>
<li><a href="../263985/index.html">Answers to the quest about the space admin with comments</a></li>
<li><a href="../263991/index.html">Probabilistic programming</a></li>
<li><a href="../263995/index.html">Google Analytics with Unity3D</a></li>
<li><a href="../263997/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ170 (July 26 - August 2, 2015)</a></li>
<li><a href="../263999/index.html">Using Visual Studio Application Insights - Test Engineer's Experience</a></li>
<li><a href="../264001/index.html">We clean the Internet from annoying ads (AD Blocker for MikroTik)</a></li>
<li><a href="../264003/index.html">Lambda expressions in Java, how and why to serialize them?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>