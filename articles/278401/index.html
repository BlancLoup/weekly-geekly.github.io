<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript parser for treasure hunters of photographic depths</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first photo that came down to us was black and white and blurred. Then sharpness came into the picture. Later - color. One more step forward is a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript parser for treasure hunters of photographic depths</h1><div class="post__text post__text-html js-mediator-article">  The first photo that came down to us was black and white and blurred.  Then sharpness came into the picture.  Later - color.  One more step forward is a number.  The popularity and distribution of "photography" is constantly growing and growing.  Now the cats make a selfie.  What's next?  And then (or rather, right now) digital images, which, in addition to millions of colored dots, store information about the depth of the space captured on them. <br><br> <a href="https://habrahabr.ru/company/intel/blog/278401/"><img src="https://habrastorage.org/files/1dc/997/5b4/1dc9975b4a094ec0a0246471771659f4.jpg"></a> <br><br>  This opens up <a href="https://software.intel.com/ru-ru/articles/intel-realsense-depth-enabled-photography">tremendous</a> opportunities.  Among them are motion effects, such as parallax and ‚Äúhitting-departure‚Äù.  In the ‚Äúdepths‚Äù of images, new approaches to art filters, to setting sharpness, to editing images, to measuring by photo are lurking.  And this is just the beginning. <br><a name="habracut"></a><br>  Today we will talk about the JavaScript implementation of the parser of photos with support for depth.  It works with <a href="https://software.intel.com/en-us/articles/the-extensible-device-metadata-xdm-specification-version-10">eXtensible Device Metadata</a> (XDM) image files, extracting embedded metadata from them and storing the received materials as XML files.  In addition, the program can extract color and depth information from XML.  As a result, the output is XML files, color images, and depth map files. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you‚Äôre <a href="http://depthy.me/">looking forward</a> to trying what‚Äôs discussed below, take a look at <a href="http://depthy.me/">Depthy</a> , our open source project.  It involves the described photo analyzer.  Practice has shown that he does his work efficiently and quickly. <br><br>  Before considering the code, we will focus on the XDM format. <br><br><h2>  <font color="#0071c5">XDM format</font> </h2><br>  At the entrance of the script served XDM-files.  In the XDM format, metadata is stored in container images, and the images are compatible with existing graphics viewing applications.  This format is designed for <a href="http://www.intel.com/content/www/us/en/architecture-and-technology/realsense-overview.html">Intel RealSense</a> technology.  Metadata contains technical information.  Namely, it is the depth map, the spatial position of the device and the camera, the model of the lens perspective, information on the equipment manufacturer, the cloud of points.  Here's what the color image looks like (on the right) and the corresponding depth map in XDM format (left), which is stored in the image file as metadata. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b47/02e/fa5/b4702efa53738abcf8607274f3ac027d.jpg"><br>  <i><font color="#999999">Color image and its depth map</font></i> <br><br>  Data format XDM need to somehow integrate into the file container.  To do this, use the standard Adobe XMP. <br><br><h2>  <font color="#0071c5">Adobe XMP standard</font> </h2><br>  Now the XDM specification provides for the use of graphic container files of four formats: JPEG, PNG, TIFF and GIF.  XDM metadata is serialized and embedded in a graphic container file.  Metadata storage is based on the <a href="http://www.adobe.com/devnet/xmp.html">Adobe Extensible Metadata Platform</a> (XMP) standard.  The application considered here is designed for using containers in JPEG format.  Let us briefly discuss how XMP metadata is embedded in JPEG files, and how the program processes XMP packets. <br><br>  In the XMP standard, data fragments are marked with 2-byte sequences.  Type markers 0xFFE0‚Äì0xFFEF are usually used for these applications.  Their names are APP <i>n</i> .  Such markers are usually started from the line describing their purpose.  This is the so-called namespace string or signature string.  The APP <i>1</i> token identifies Exif and TIFF metadata.  Code APP <i>13</i> mark data format Photoshop Image Resources.  They contain IPTC metadata.  The location of the XMP packet or packets is indicated by one or more APP <i>1</i> -markers. <br><br>  Here‚Äôs what a StandardXMP format entry looks like in a JPEG file. <br><br>  <i>StandardXMP format entry fields</i> <br><table><tbody><tr><td width="100">  <b>Offset byte</b> <br></td><td width="100">  <b>Length, byte</b> <br></td><td>  <b>Value</b> <br></td><td width="100">  <b>Name</b> <br></td><td>  <b>Comments</b> <br></td></tr><tr><td>  0 <br></td><td>  2 <br></td><td>  0xFFE1 <br></td><td>  APP1 <br></td><td>  The APP1 marker points to the metadata section <br></td></tr><tr><td>  2 <br></td><td>  2 <br></td><td>  2 + 29 + XMP packet length <br></td><td>  Lp <br></td><td>  Size in bytes equal to the sum of the sizes of this section and the following two <br></td></tr><tr><td>  four <br></td><td>  29 <br></td><td>  ASCII string without quotes, ending with a null character <br></td><td>  namespace <br></td><td>  The XMP namespace URI is used as a unique identifier: <a href="http://ns.adobe.com/xap/1.0/">ns.adobe.com/xap/1.0</a> <br></td></tr><tr><td>  33 <br></td><td>  &lt;65503 <br></td><td>  XMP packet <br></td><td></td><td>  UTF-8 encoding required. <br></td></tr></tbody></table><br>  If after serialization, the size of the XMP packet is larger than 64 KB, it can be divided into parts and these parts can be saved in several places in the JPEG file.  Namely, with this approach, the packet data will be represented by the main (StandardXMP) and extended (ExtendedXMP) segments.  ExtendedXMP uses the same recording format as StandardXMP.  The only exception - in the field that stores information about the namespace (namespace), indicated <a href="http://ns.adobe.com/xmp/extension/">http://ns.adobe.com/xmp/extension/</a> . <br><br>  This is how the XMP packet data is embedded in the JPEG file as StandardXMP and ExtendedXMP format records. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0b8/984/121/0b898412101149dd951b4a02237d0433.png"></div><br>  <i><font color="#999999">Records of the formats StandardXMP and ExtendedXMP in a JPEG file</font></i> <br><br>  Consider three functions. <br><br><ul><li>  The <b>findMarker</b> function analyzes a JPEG file in the search for a 0xFFE1 marker, starting at a given position.  The file content is represented by the parameter of the function buffer, position by the parameter position.  If the token is found, the function will return its address; if not found, the value is -1. <br><br></li><li>  The <b>findHeader</b> function <b>searches</b> for the StandardXMP (http://ns.adobe.com/xap/1.0/) and ExtendedXMP (http://ns.adobe.com/xmp/extension/) namespaces in a JPEG file.  It is passed, again, the buffer with the file data (buffer) and the position from which to start the search (position).  If a match is found, the function will return a string corresponding to the detected namespace.  If not, an empty string will be returned. <br><br></li><li>  The findGUID function searches for a GUID that is stored in the xmpNote: HasExtendedXMP element in a JPEG file (buffer parameter), starting with the position in the file (position) and ending with the position in the file, calculated as position + zize-1.  Finding the desired item, it returns its address. </li></ul><br>  Here is the code for these functions. <br><br><pre><code class="hljs pgsql">//     (buffer),    <span class="hljs-number"><span class="hljs-number">0xFFE1</span></span>,      (position) //  <span class="hljs-number"><span class="hljs-number">-1</span></span>,     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> findMarker(buffer, position) {    var <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = position; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> &lt; buffer.length; <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++) {        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((buffer[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] == marker1) &amp;&amp; (buffer[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] == marker2))            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } //  ,    ,  ‚Äì  ,    . <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> findHeader(buffer, position) {    var string1 = buffer.toString(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>, position + <span class="hljs-number"><span class="hljs-number">4</span></span>, position + <span class="hljs-number"><span class="hljs-number">4</span></span> + header1.length);    var string2 = buffer.toString(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>, position + <span class="hljs-number"><span class="hljs-number">4</span></span>, position + <span class="hljs-number"><span class="hljs-number">4</span></span> + header2.length);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (string1 == header1)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> header1;    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (string2 == header2)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> header2;    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noHeader; } //   GUID <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> findGUID(buffer, position, size) {    var string = buffer.toString(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>, position, position + size - <span class="hljs-number"><span class="hljs-number">1</span></span>);    var xmpNoteString = "xmpNote:HasExtendedXMP=";    var GUIDPosition = string.<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>(xmpNoteString);    var returnPos = GUIDPosition + position + xmpNoteString.length + <span class="hljs-number"><span class="hljs-number">1</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnPos; }</code> </pre> <br>  The 128-bit GUID is stored as a 32-byte hexadecimal ASCII string in each ExtendedXMP segment, behind the namespace.  It is also stored in the StandardXMP segment, as the value of the xmpNote: HasExtendedXMP property.  Due to this, we can detect inappropriate or modified ExtendedXMP-segments. <br><br><h2>  <font color="#0071c5">XML</font> </h2><br>  XMP format metadata can be embedded directly into <a href="https://www.w3.org/TR/REC-xml/">XML documents</a> .  In accordance with the XDM specification, the XML data structure can be defined as shown in the table. <br><br>  <i>XML representation of XMP data</i> <br><img src="https://habrastorage.org/files/5ec/271/c94/5ec271c94b4b4240bd888c1714df62fd.png"><br><br>  The graphic file contains the elements described above in RDF / XML format.  It should be noted that the image container is an external object with respect to the XDM data.  It remains compatible with conventional graphics viewing applications that do not support XDM. <br><br>  Here is a snippet of code that demonstrates the core of the parser.  This is where the analysis of the input JPEG file, the search for APP <i>1-</i> marker 0xFFE1 is carried out.  If the token is found, it searches for string representations of the StandardXMP and ExtendedXMP namespaces.  If the first is found, the size of the metadata and their starting address are calculated, the data is extracted and the StandardXMP XML file is created.  If the second is found, the procedure is repeated, but the XML file is ExtendedXMP.  The output of the application are two XML files. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     XDM- function xdmParser(xdmFilePath) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  JPEG-      var fileStats = fs.statSync(xdmFilePath);    var fileSizeInBytes = fileStats[<span class="hljs-string"><span class="hljs-string">"size"</span></span>];    var fileBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(fileSizeInBytes);       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  JPEG-    var xdmFileFD = fs.openSync(xdmFilePath, <span class="hljs-string"><span class="hljs-string">'r'</span></span>);    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> JPEG-       fs.readSync(xdmFileFD, fileBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, fileSizeInBytes, <span class="hljs-number"><span class="hljs-number">0</span></span>);    var bufferIndex, segIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, segDataTotalLength = <span class="hljs-number"><span class="hljs-number">0</span></span>, XMLTotalLength = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; bufferIndex &lt; fileBuffer.length; bufferIndex++) {        var markerIndex = findMarker(fileBuffer, bufferIndex);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (markerIndex != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {               <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">0xFFE1</span></span>            var segHeader = findHeader(fileBuffer, markerIndex);            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (segHeader) {                <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>                  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,    ,                      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> segIndex   <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="hljs-number"><span class="hljs-number">1</span></span>                var segSize = fileBuffer[markerIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span> + fileBuffer[markerIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>];                var segDataStart;                <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>--&gt;segSize  <span class="hljs-number"><span class="hljs-number">2</span></span>-                   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>--&gt;  <span class="hljs-number"><span class="hljs-number">0</span></span>   ,                  segSize -= (segHeader.length + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>);                <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>--&gt;<span class="hljs-number"><span class="hljs-number">0xFFE1</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>-                <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>--&gt;segSize  <span class="hljs-number"><span class="hljs-number">2</span></span>                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>--&gt;  <span class="hljs-number"><span class="hljs-number">0</span></span>   ,                  segDataStart = markerIndex + segHeader.length + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;                              <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (segHeader == header1) {                       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> StandardXMP                    var GUIDPos = findGUID(fileBuffer, segDataStart, segSize);                    var GUID = fileBuffer.toString(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>, GUIDPos, GUIDPos + <span class="hljs-number"><span class="hljs-number">32</span></span>);                    var segData_xap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(segSize - <span class="hljs-number"><span class="hljs-number">54</span></span>);                    fileBuffer.copy(segData_xap, <span class="hljs-number"><span class="hljs-number">0</span></span>, segDataStart + <span class="hljs-number"><span class="hljs-number">54</span></span>, segDataStart + segSize);                    fs.appendFileSync(outputXAPFile, segData_xap);                }                <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (segHeader == header2) {                       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ExtendedXMP                    var segData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(segSize - <span class="hljs-number"><span class="hljs-number">40</span></span>);                    fileBuffer.copy(segData, <span class="hljs-number"><span class="hljs-number">0</span></span>, segDataStart + <span class="hljs-number"><span class="hljs-number">40</span></span>, segDataStart + segSize);                    XMLTotalLength += (segSize - <span class="hljs-number"><span class="hljs-number">40</span></span>);                    fs.appendFileSync(outputXMPFile, segData);                }                bufferIndex = markerIndex + segSize;                segIndex++;                segDataTotalLength += segSize;            }        }        <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {               <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,              <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;        };    } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(ex) {  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Something bad happened! "</span></span> + ex); } }</code> </pre> <br>  Here is a code snippet that analyzes the XML file and generates a color image and its depth map.  Then this data can be used to process photos with depth support.  Everything is very simple here.  The xmpMetadataParser () function searches for the <i>IMAGE: DATA</i> attribute and extracts the corresponding data in a JPEG file.  It turns out a color image.  If several such attributes are found, several JPEG files will be created.  In addition, the function searches for the <i>DEPTHMAP: DATA</i> attribute and extracts the corresponding data into a PNG file.  This is the depth map.  If several such attributes are found, respectively, several PNG files are created.  At the output we get one or several JPEG and PNG files. <br><br><pre> <code class="hljs pgsql">//  XMP-   ,       <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> xmpMetadataParser() {   var imageIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, depthImageIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, outputPath = "";   parser = sax.<span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>();   //    ,     <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.onattribute = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (attr) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((attr.name == "IMAGE:DATA") || (attr.name == "GIMAGE:DATA")) {           outputPath = inputJpgFile.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, inputJpgFile.length - <span class="hljs-number"><span class="hljs-number">4</span></span>) + "_" + imageIndex + ".jpg";           var atob = require(<span class="hljs-string"><span class="hljs-string">'atob'</span></span>), b64 = attr.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, bin = atob(b64);           fs.writeFileSync(outputPath, bin, <span class="hljs-string"><span class="hljs-string">'binary'</span></span>);           imageIndex++;       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((attr.name == "DEPTHMAP:DATA") || (attr.name == "GDEPTH:DATA")) {           outputPath = inputJpgFile.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, inputJpgFile.length - <span class="hljs-number"><span class="hljs-number">4</span></span>) + "_depth_" + depthImageIndex + ".png";           var atob = require(<span class="hljs-string"><span class="hljs-string">'atob'</span></span>), b64 = attr.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, bin = atob(b64);           fs.writeFileSync(outputPath, bin, <span class="hljs-string"><span class="hljs-string">'binary'</span></span>);           depthImageIndex++;       }   };   <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.onend = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> () {       console.log("All done!")   } } //  XMP- <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> processXmpData(filePath) {   try {       var file_buf = fs.readFileSync(filePath);       <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(file_buf.toString(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)).<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>();   } catch (ex) {       console.log("Something bad happened! " + ex);   } }</code> </pre> <br><h2>  <font color="#0071c5">Results</font> </h2><br>  So, XDM files are parsed, turned into JPEG and PNG, into color images and depth maps.  All this is done exclusively by means of our <a href="">script</a> , without attracting additional libraries.  Would you like to incorporate photo processing tools with depth support into your web project?  The JavaScript parser we talked about can be the foundation on which such tools can be built. <br><br>  PS Do you write in Java and want to process depth-supporting photos in your projects?  If so, then you are <a href="https://github.com/IntelRealSense/JavaParserForDepthPhoto">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/278401/">https://habr.com/ru/post/278401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278389/index.html">Lua Micro Apache Framework</a></li>
<li><a href="../278391/index.html">Stack Overflow Architecture</a></li>
<li><a href="../278393/index.html">alter table without table locale</a></li>
<li><a href="../278395/index.html">We promote mobile applications in the AppStore and Google Play: how to use the method of featuring</a></li>
<li><a href="../278399/index.html">Grace "Grandma COBOL" Hopper</a></li>
<li><a href="../278403/index.html">Dollar</a></li>
<li><a href="../278405/index.html">Creating applications for Firebird with the use of various components and drivers: ADO.NET Entity Framework 6</a></li>
<li><a href="../278407/index.html">The key to JetBrains products for all students on Stepic.org</a></li>
<li><a href="../278409/index.html">Introduction to practical analytics, or what is common in neural networks with diet pills</a></li>
<li><a href="../278411/index.html">Authentication using Spring Security and JWT tokens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>