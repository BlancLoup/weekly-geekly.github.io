<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spring AOP. Little question from the interview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I had a chance here the other day to attend the next interview. And they asked me there is such a question. What actually will be executed (from the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spring AOP. Little question from the interview</h1><div class="post__text post__text-html js-mediator-article">  I had a chance here the other day to attend the next interview.  And they asked me there is such a question.  What actually will be executed (from the point of view of transactions) if to cause method1 ()? <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do something method2(); } @Transactional (propagation=Propagation.REQUIRES_NEW) public void method2() { //do something } }</span></span></code> </pre> <br>  Well, we are all smart, we read the documentation, or at least we watch the video of Yevgeny Borisov‚Äôs speeches.  Accordingly, we know the correct * answer (the correct * is the one who asks those who ask to hear from us).  And it should sound like this. <br><br>  ‚Äú <i>Due to the fact that Spring AOP is used to support transactions through annotations, at the time of calling method1 (), the object's proxy method is actually called.</i>  <i>A new transaction is created and then method1 () is called on the MyServiceImpl class.</i>  <i>And when we call method2 () from method1 (), there is no appeal to the proxy, the method of our class is called right away and, accordingly, no new transactions will be created</i> . ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But you know how it happens, and the answer has been known for a long time.  And apply this knowledge regularly.  But what if all of a sudden ... and suddenly you think about it: ‚Äú <i>Wait a minute, because if we use Spring AOP, then there can be created a proxy through JDK, or with CGLIB;</i>  <i>and it is also possible that CTW or LTW is hooked up.</i>  <i>And that such an answer will always be true?</i>  ". <br><br>  Well then: interesting?  Need to check. <br><a name="habracut"></a><br>  In fact, I was not interested in how transactions would be created, but in the very statement that Spring AOP always creates proxy objects, and these proxy objects have the behavior described above.  Obviously, if the JDK dynamic proxy is used to create wrappers, this statement should be true.  Indeed, in this case, objects are created on the basis of interfaces.  Such an object will fully comply with the Proxy pattern and everything looks quite logical.  But CGLib uses a different approach, it creates classes of heirs.  And then doubts are beginning to creep in whether the behavior will be identical.  Everything becomes even more interesting when we decide to use external binding tools, i.e.  CTW (compile-time weaving) and LTW (load-time weaving). <br><br>  To begin with, I will add here a couple of definitions from the Spring AOP documentation, which are most interesting in the context of what we are considering (all the other definitions themselves can be found in the documentation itself, for example, <a href="https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/html/aop.html">here</a> ) <br><blockquote><ul><li>  AOP proxy: an order created by the AOP framework in order to implement the aspect contracts (advise method executions and so on).  In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy. </li><li>  Weaving:  This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime.  Spring AOP framework, like other pure Java AOP frameworks, performs weaving at runtime. </li></ul><br></blockquote>  Now we will create the simplest project on which we will conduct experiments.  For this we use Spring Boot.  Since I use STS for development, I will describe the steps for this IDE.  But, by and large, everything will be about the same for other tools. <br><br>  Run the wizard for creating the Spring Boot project: File&gt; New&gt; Spring Starter Project.  And fill in the form: <br><br><ul><li>  <b>Name</b> : AOPTest; </li><li>  <b>Type</b> : Maven; </li><li>  <b>Packaging</b> : Jar; </li><li>  <b>Java version</b> : 8; </li><li>  <b>Language</b> : Java; </li><li>  <b>Group</b> : com.example.AOPTest; </li><li>  <b>Artifact</b> : AOPTest; </li><li>  <b>Package</b> : com.example.AOPTest. </li></ul><br>  The rest to taste.  Click the Next button, and fill out again: <br><br><ul><li>  <b>Spring Boot Version</b> : 2.0.0.M7 (and why not? This is the last available version at the time of this writing).  What Spring Boot actually does is that in its minimal form it includes all the necessary dependencies and definitions.  We only need to specify what we will use from Spring. </li><li>  At the same step, in the list of available dependencies, we find Aspects (you can use the filter) and add it. </li></ul><br>  Click Finish.  Our application is ready.  The created pom'nik should look something like this. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modelVersion</span></span></span><span class="hljs-tag">&gt;</span></span>4.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modelVersion</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.example.AOPTest<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>AOPTest<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.0.1-SNAPSHOT<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">packaging</span></span></span><span class="hljs-tag">&gt;</span></span>jar<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">packaging</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>AOPTest<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spring-boot-starter-parent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>2.0.0.M7<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">relativePath</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project.build.sourceEncoding</span></span></span><span class="hljs-tag">&gt;</span></span>UTF-8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project.build.sourceEncoding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project.reporting.outputEncoding</span></span></span><span class="hljs-tag">&gt;</span></span>UTF-8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project.reporting.outputEncoding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">java.version</span></span></span><span class="hljs-tag">&gt;</span></span>1.8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">java.version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spring-boot-starter-aop<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spring-boot-starter-test<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scope</span></span></span><span class="hljs-tag">&gt;</span></span>test<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">scope</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">build</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugins</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spring-boot-maven-plugin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugins</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">build</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In fact, due to the fact that we are using the milestone version, the code will be slightly larger, links to the repositories will be added. <br><br>  An application class will also be generated. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.SpringApplication; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.autoconfigure.SpringBootApplication; <span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AopTestApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(AopTestApplication.class, args); } }</code> </pre><br>  Our annotation (since, as I said, we are not interested in transactions, but how this situation will be handled, we create our own annotation): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.annotation.ElementType.METHOD; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.annotation.RetentionPolicy.RUNTIME; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.annotation.Retention; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.annotation.Target; <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(METHOD) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Annotation1 { }</code> </pre> <br>  And aspect <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Aspect; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Before; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Pointcut; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-meta"><span class="hljs-meta">@Aspect</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAspect1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Pointcut</span></span>(<span class="hljs-string"><span class="hljs-string">"@annotation(com.example.AOPTest.Annotation1)"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Before</span></span>(<span class="hljs-string"><span class="hljs-string">"annotated()"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printABit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Aspect1"</span></span>); } }</code> </pre> <br>  Actually created an aspect that will bind to the methods that have an annotation @ Annotation1.  Before executing such methods, the text ‚ÄúAspect1‚Äù will be displayed in the console. <br>  Note that the class itself is also annotated as a <a href="https://habrahabr.ru/users/component/" class="user_link">Component</a> .  This is necessary so that Spring can find this class and create a bin based on it. <br><br>  And now you can add our class. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Service; <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Annotation</span></span>1 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"method1"</span></span>); method2(); } <span class="hljs-meta"><span class="hljs-meta">@Annotation</span></span>1 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"method2"</span></span>); } }</code> </pre> <br>  With goals, objectives and tools decided.  You can begin to experiment. <br><br><h2>  JDK dynamic proxy vs CGLib proxy </h2><br>  If you refer to the documentation, you can find the following text there. <br><blockquote>  Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object.  (JDK dynamic proxies are preferred). <br>  JDK dynamic proxy will be used.  All types of interfaces are implemented.  The CGLIB proxy will be created. <br>  For example, it can be used to make it easier for you to use it. <br>  CGLIB proxies set the value of the proxy target attribute of the &lt;aop: config&gt; element to true <br></blockquote>  That is, according to the documentation, both JDK and CGLib can be used to create proxy objects, but preference should be given to JDK.  And, if a class has at least one interface, then the JDK dynamic proxy will be used (although this can be changed by explicitly setting the proxy-target-class flag).  When creating a proxy object using JDK, all interfaces of the class and the method for implementing new behavior are passed to the input.  As a result, we obtain an object that exactly implements the Proxy pattern.  All this happens at the stage of creating bins, so when the introduction of dependencies begins, in reality, this very proxy object will be implemented.  And all calls will be made to him.  But after completing its part of the functional, it will access the object of the original class and transfer control to it.  If this object itself is addressed to one of its methods, then it will be a direct call without any proxies.  Actually, it is this behavior that is expected according to the correct * answer. <br><br>  With this, everything seems to be clear, but what about CGLib?  After all, he actually creates not a proxy object, but a class heir.  And here my brain is just shouting: STOP!  After all, here we have, well, just an example from an OOP textbook. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleParent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"SampleParent.method1"</span></span>); method2(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"SampleParent.method2"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleChild</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleParent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"SampleChild.method2"</span></span>); } }</code> </pre> <br>  Where SampleChild is, in fact, our proxy object.  And here I am already beginning to doubt even the PLO (or in my knowledge about it).  After all, if we have inheritance, then the overlapped method should be called instead of the parent one, and then the behavior will be different from what we have when using JDK dynamic proxy. <br><br>  Although there is another option, maybe I misunderstood how objects are created using CGLib and, in fact, they are ‚Äúnot exactly heirs‚Äù, but also ‚Äúsome kind of proxy‚Äù.  And, of course, the easiest way to be sure of at least something is to check it with a simple example.  So let's create another small project. <br><br>  This time, we no longer need Spring, just create the simplest maven project and add a CGLib dependency to pom (in fact, this is the entire content of our pom-file). <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>cglib<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>cglib<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>3.2.5<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Let's add our two Sample classes to the created project (well, just in case, to convince ourselves that the principles of the OOP are unshakeable) and the class itself with the main () method, in which we will perform our tests. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.CGLIBTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sf.cglib.proxy.Enhancer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sf.cglib.proxy.MethodInterceptor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sf.cglib.proxy.MethodProxy; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGLIBTestApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleChild().method1(); System.out.println(<span class="hljs-string"><span class="hljs-string">"//------------------------------------------//"</span></span>); Enhancer enhancer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Enhancer(); enhancer.setSuperclass(SampleParent.class); enhancer.setCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodInterceptor() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(method.getName().equals(<span class="hljs-string"><span class="hljs-string">"method2"</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"SampleProxy.method2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> proxy.invokeSuper(obj, args); } } }); ((SampleParent) enhancer.create()).method1(); } }</code> </pre> <br>  The first line is to call method1 () on the SampleChild object of the class (as already said, well, just to be sure ...) and then create the Enchancer.  In the Enchancer object, we override the behavior of the method method2 ().  After that, in fact, a new object is created and already we call method1 () on it.  And run. <br><br><pre> <code class="hljs objectivec">SampleParent.method1 SampleChild.method2 <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------// SampleParent.method1 SampleProxy.method2</span></span></code> </pre><br>  Fuh ... You can breathe out.  If you believe the first two lines of output, over the past 20 years, nothing has changed in the PLO. <br><br>  The last two lines say that with the objects created through CGLib, my understanding was absolutely correct.  This is really an inheritance.  And from this point on, my doubts about the fact that the object created in this way will work exactly the same as the JDK dynamic proxy object only intensified.  Therefore, we no longer postpone, but run our project, which we created for experiments.  To do this, we will need to add a runner in the application class, and our class will take the following form. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.CommandLineRunner; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.SpringApplication; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.autoconfigure.SpringBootApplication; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.ApplicationContext; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.annotation.Bean; <span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AopTestApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MyService myService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(AopTestApplication.class, args); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CommandLineRunner </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commandLineRunner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationContext ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args -&gt; { myService.method1(); }; } }</code> </pre> <br>  I still like this Spring Boot, everything that needs to be done has already been done for us (sorry for this little lyrical digression).  The @SpringBootApplication annotation includes many other annotations that you would have to write if we didn‚Äôt use Spring Boot.  By default, it is already indicated that this class contains the configuration, and also that it is necessary to scan the packages for the presence of definitions of bins. <br><br>  At the same time, right here we are creating a new CommandLineRunner bean, which itself will execute the method1 () method call on our myService bean. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Aspect1</span></span> method1 method2</code> </pre><br>  Hmm ... This conclusion was unexpected for me.  Yes, it fully meets expectations, if Spring AOP uses the JDK dynamic proxy.  Those.  when calling method1 () of our service, the aspect was first worked out, after which control was transferred to an object of the class MyServiceImpl and further calls would be made within this object. <br><br>  But we did not specify a single interface for the class.  And I expected Spring AOP to use CGLib in this case.  Can Spring somehow bypass this limitation and, as written in the documentation, try to use the JDK dynamic proxy as the main option, unless explicitly stated otherwise? <br><br>  After sitting a little above the call stack at the moment of raising the application, i.e.  at the stage of creating bins, I found a place where the choice is actually made which library to use.  This happens in the DefaultAopProxyFactory class, namely in the method <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AopProxy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAopProxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AdvisedSupport config)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> AopConfigException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) { Class&lt;?&gt; targetClass = config.getTargetClass(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetClass == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AopConfigException(<span class="hljs-string"><span class="hljs-string">"TargetSource cannot determine target class: "</span></span> + <span class="hljs-string"><span class="hljs-string">"Either an interface or a target is required for proxy creation."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JdkDynamicAopProxy(config); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjenesisCglibAopProxy(config); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JdkDynamicAopProxy(config); } }</code> </pre> <br>  In Javadocs to this class is written <br><blockquote> <code>Default AopProxyFactory implementation, creating either a CGLIB proxy or a JDK dynamic proxy. <br> <br> Creates a CGLIB proxy if one the following is true for a given AdvisedSupport instance: <br> <br> ‚Ä¢ the optimize flag is set <br> ‚Ä¢ the proxyTargetClass flag is set <br> ‚Ä¢ no proxy interfaces have been specified <br> <br> In general, specify proxyTargetClass to enforce a CGLIB proxy, or specify one or more interfaces to use a JDK dynamic proxy.</code> </blockquote>  And in order to make sure that no interfaces to our class have appeared, it suffices to check the hasNoUserSuppliedProxyInterfaces (config) condition.  In our case, it returns true.  And, as a result, the creation of a proxy through CGLib is called. <br><br>  In other words, Spring AOP not only uses CGLib to create heirs from the classes of beans, but implements a full-fledged proxy object at this stage (ie, an object corresponding to the Proxy pattern).  How exactly he does it, everyone can see for himself, walking through the steps under debugging in this application.  Far more important for me was the conclusion that absolutely no matter which library Spring uses under the hood.  In any case, his behavior will be the same.  In any case, a proxy object will be created for the organization of end-to-end programming, which itself will provide calls to the methods of the real class object.  On the other hand, if any methods are called from the methods of the same class, then intercepting (blocking) with Spring AOP means they cannot be obtained. <br><br>  We could stop at this with a search for differences in the behavior of proxies created through the JDK and CGLib.  But my inquisitive mind continued its attempts to find at least some inconsistency.  And I decided to ensure that the proxy object will be created through the JDK.  Theoretically, this should be simple and not take a lot of time.  Returning to the documentation, you can remember that this option should be used by default, with the only caveat: the object must have interfaces.  Also, the ProxyTargetClass flag must be cleared (i.e., false). <br><br>  The first condition is fulfilled by adding the appropriate interface to the project (I will not give this code anymore, I think it‚Äôs pretty obvious how it will look like).  The second is by adding the corresponding annotation to the configuration, i.e.  something like this <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span>(proxyTargetClass = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AopTestApplication</span></span></span><span class="hljs-class"> </span></span>{</code> </pre><br>  But in fact, everything was not so simple.  Both checks ‚Äî config.isProxyTargetClass () and hasNoUserSuppliedProxyInterfaces (config) still returned true.  I decided to stop at this.  I received an answer to my question, and also made a note in my memory that (at least when using Spring 5), despite the statements of the documentation, proxies are more likely to be created using CGLib. <br><br>  By the way, if someone knows how to force Spring AOP to use the JDK, I will wait for your comments. <br><br><h2>  Compile-time weaving and AspectJ </h2><br>  Well, our hypothesis that the behavior of the code under the aspects will depend on which library is used under the hood, failed.  However, this is not all the features that Spring provides in terms of AOP.  One of the most interesting (in my opinion) features that Spring AOP provides us with is the ability to use the AspectJ compiler.  Those.  the framework is written in such a way that if we use the @AspectJ annotations to describe aspects, we will not have to make any changes to move from runtime weaving to compile-time weaving.  In addition (another advantage of Spring Boot) all the necessary dependencies are already included.  We just need to connect the plugin, which will compile. <br><br>  To do this, make changes to our pom'nik.  Now the build section will look like this. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">build</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugins</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.springframework.boot<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>spring-boot-maven-plugin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.codehaus.mojo<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>aspectj-maven-plugin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.10<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">complianceLevel</span></span></span><span class="hljs-tag">&gt;</span></span>1.8<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">complianceLevel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag">&gt;</span></span>${maven.compiler.source}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">target</span></span></span><span class="hljs-tag">&gt;</span></span>${maven.compiler.target}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">target</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">showWeaveInfo</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">showWeaveInfo</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">verbose</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">verbose</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Xlint</span></span></span><span class="hljs-tag">&gt;</span></span>ignore<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Xlint</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">encoding</span></span></span><span class="hljs-tag">&gt;</span></span>UTF-8 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">encoding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">weaveDirectories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">weaveDirectory</span></span></span><span class="hljs-tag">&gt;</span></span>${project.build.directory}/classes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">weaveDirectory</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">weaveDirectories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">forceAjcCompile</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">forceAjcCompile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">executions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">execution</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">goals</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">goal</span></span></span><span class="hljs-tag">&gt;</span></span>compile<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">goal</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- &lt;goal&gt;test-compile&lt;/goal&gt; --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">goals</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">execution</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">executions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">plugins</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">build</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  I will not dwell on the configuration parameters of this plug-in, I will only explain why I commented out the purpose of test-compile.  When building a project, maven fell with an error during the test run.  Rummaging through the Internet, I saw that this problem is known, and there are ways to solve it.  But, since, in our test application, the tests seem to be absent, the simplest solution was to simply disable their call completely (and at the same time call the plug-in at the compilation stage). <br><br>  Actually, these are all the changes we needed to make.  We can run our application <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Aspect1</span></span> Aspect1 method1 Aspect1 Aspect1 method2</code> </pre> <br>  At this point, I realized the whole depth of my misunderstanding of aspects.  I rechecked the whole code several times.  I tried to scroll in my mind, where and what I did wrong.  But I did not realize why I got such a result (no, well, honestly, it‚Äôs not obvious why the aspect code is called twice before each call of the method of our class). <br><br>  In the end, I still guessed to see the logs received during the project build phase and found the next 4 lines there. <br><br><pre> <code class="hljs pgsql">[<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'method-call(void com.example.AOPTest.MyServiceImpl.method1())'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.AopTestApplication'</span></span> (AopTestApplication.java:<span class="hljs-number"><span class="hljs-number">32</span></span>) advised <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> advice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyAspect1'</span></span> (MyAspect1.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MyAspect1.java)) [<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'method-call(void com.example.AOPTest.MyServiceImpl.method2())'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyServiceImpl'</span></span> (MyServiceImpl.java:<span class="hljs-number"><span class="hljs-number">12</span></span>) advised <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> advice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyAspect1'</span></span> (MyAspect1.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MyAspect1.java)) [<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'method-execution(void com.example.AOPTest.MyServiceImpl.method1())'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyServiceImpl'</span></span> (MyServiceImpl.java:<span class="hljs-number"><span class="hljs-number">10</span></span>) advised <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> advice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyAspect1'</span></span> (MyAspect1.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MyAspect1.java)) [<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'method-execution(void com.example.AOPTest.MyServiceImpl.method2())'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyServiceImpl'</span></span> (MyServiceImpl.java:<span class="hljs-number"><span class="hljs-number">17</span></span>) advised <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> advice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'com.example.AOPTest.MyAspect1'</span></span> (MyAspect1.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MyAspect1.java))</code> </pre> <br>  Everything fell into place.  Code binding occurred not only at the place where the methods were executed, but also at the place of their calls.  The fact is that Spring AOP has a restriction that allows you to link the code only at the place of execution.  The possibilities of AspectJ in this regard are much wider.  Removing unnecessary aspect calls is quite simple, for example, you can modify the aspect code like this. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.AOPTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Aspect; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Before; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.aspectj.lang.annotation.Pointcut; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-meta"><span class="hljs-meta">@Aspect</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAspect1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Pointcut</span></span>(<span class="hljs-string"><span class="hljs-string">"execution(public * *(..))"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publicMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Pointcut</span></span>(<span class="hljs-string"><span class="hljs-string">"@annotation(com.example.AOPTest.Annotation1)"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Before</span></span>(<span class="hljs-string"><span class="hljs-string">"annotated() &amp;&amp; publicMethod()"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printABit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Aspect1"</span></span>); } }</code> </pre> <br>  Then our conclusion will take the expected form. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Aspect1</span></span> method1 Aspect1 method2</code> </pre> <br>  Well, here we can already say that our correct * answer still needs clarification.  At a minimum, if you are asked at the interview about the expected behavior of the code given at the beginning, you should clarify: ‚ÄúBut aren't we using compile-time binding?  Indeed, in the class code this is not reflected in any way, but pom'nik was not provided to us. ‚Äù <br><br>  What else would I like to mention.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The documentation on Spring AOP describes that everything was done, so that with a flick of the wrist, (c) switches from runtime linking to compile-time linking. And as we have seen, this is true. The code for both cases was used the same (in fact, the work that was done much more than just creating handlers for the same annotations, but I will not dwell on this, those who wish can read the documentation and be impressed on their own). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With all this, depending on the choice of binding, the behavior may be different (and even unexpected). Except for those cases that have already been considered, I want to note that the AspectJ compiler does not need the </font></font><a href="https://habrahabr.ru/users/component/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> annotation </font><font style="vertical-align: inherit;">.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if we remove it, then Spring AOP will not find such a bean and the aspect will not be involved. </font><font style="vertical-align: inherit;">At the same time, if we decide to switch to AspectJ compilation, this aspect will be valid, but the behavior of the application is unpredictable.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Load-time weaving </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspired by the result of the previous stage, I mentally rubbed my hands. </font><font style="vertical-align: inherit;">After all, if, when linking the code during compilation, we got excellent behavior, the one we had for binding during execution, then we probably expect about the same result if we connect during loading (well, I thought so). </font><font style="vertical-align: inherit;">Having quickly read the documentation about this, I found out that LTW in Spring is available out of the box. </font><font style="vertical-align: inherit;">All you need is just to add another annotation in the configuration class: @EnableLoadTimeWeaving.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableLoadTimeWeaving</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AopTestApplication</span></span></span><span class="hljs-class"> </span></span>{</code> </pre> <br>  Oh yes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to remove the aspectj-maven-plugin from the pom'nik that we added earlier. </font><font style="vertical-align: inherit;">We don't need it anymore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now you can run ... No, in fact there is another nuance.</font></font><br><blockquote><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generic Java applications </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is not supported by the existing LoadTimeWeaver implementations, a JDK agent can be used. </font><font style="vertical-align: inherit;">For such cases, Spring provides InstrumentationLoadTimeWeaver, which requires a Spring-specific agent (previously named spring-agent.jar). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM options: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-javaagent: /path/to/org.springframework.instrument- {version} .jar</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a small inaccuracy in the documentation, the name of the library: spring-instrument- {version} .jar. And this library is already on your computer (thanks to Spring Boot and Maven). In my case, the path to it looks like this: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c: \ Users \ {MyUserName} \. M2 \ repository \ org \ springframework \ spring-instrument \ 5.0.2.RELEASE \ spring-instrument-5.0.2.RELEASE.jar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If you, like me, use STS for development, perform the following steps. Open the menu Run&gt; Run Configurations ... We find there Spring Boot App and in it the launch configuration of our application. Open the bookmark Arguments. In the VM arguments: add parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-javaagent: c: \ Users \ \ {MyUserName} \. M2 \ repository \ org \ springframework \ spring-instrument \ 5.0.2.RELEASE \ spring-instrument-5.0.2.RELEASE.jar</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And now we start.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Aspect1</span></span> method1 method2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, again. I did not expect such a result. Maybe it's still not so easy to connect LTW, maybe something else needs to be set up somewhere? And again, the easiest way to make sure that our settings work, run the application under debugging and see what code is being executed. The above piece of documentation states that in our case the class should be the InstrumentationLoadTimeWeaver class. And there is a method in it that should be called exactly at the stage of creating beans.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTransformer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassFileTransformer transformer)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is where we set the breakpoint. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start ... We stop ... DefaultAopProxyFactory.createAopProxy (). </font><font style="vertical-align: inherit;">The breakpoint we set earlier worked when the JDK vs CGLib was parsed. </font><font style="vertical-align: inherit;">We start again, and this time it stops exactly where it was expected. </font><font style="vertical-align: inherit;">Doubt no more. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, in this case, Spring AOP creates all the same proxy objects that we saw earlier. </font><font style="vertical-align: inherit;">With the only difference that the binding will now be made not at the stage of execution, but already at the stage of loading classes. </font><font style="vertical-align: inherit;">For details of this process, please in the code.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, it seems that our correct * answer is indeed correct, albeit with a reservation (see chapter "Compile-time weaving and AspectJ"). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Does the behavior depend on which proxying mechanism is selected: JDK or CGLib? The framework is written in such a way that the fact that there under the hood does not affect what result we get. And even the LTW connection should not affect this in any way. And within the framework of the example we considered, we did not observe these differences. And yet in the documentation you can find a mention that there are differences. JDK dynamic proxy can override only public methods. CGLib proxy - except public, also protected methods and package-visible. Accordingly, if we have not explicitly specified the restriction ‚Äúonly for public methods‚Äù for a slice (pointcut), then we can potentially get unexpected behavior. Well, if you have any doubts, you can force the use of CGLib to generate proxy objects (it seems that in recent versions of Spring this has already been done for us).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP is a proxy-based framework. This means that proxy objects will always be created on any of our bin that falls under the aspect. And the moment that calling one class method to another cannot be intercepted by Spring AOP tools - this is not a mistake or a flaw in the developers, but a feature of the pattern underlying the implementation of the framework. On the other hand, if we still need to achieve that in this case the aspect code is executed, then we need to take this fact into account and write the code, so that the calls go through a proxy object. In the documentation there is an example of how this can be done, but even there it is directly stated that this is not a recommended solution. Another option is to ‚Äúinject‚Äù the service to itself. In the latest versions of Spring, this is the solution that will work.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServiceImpl</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MyServiceImpl myService; <span class="hljs-meta"><span class="hljs-meta">@Annotation</span></span>1 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"method1"</span></span>); myService.method2(); } <span class="hljs-meta"><span class="hljs-meta">@Annotation</span></span>1 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"method2"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this option is applicable only for bins with a scope equal to "singleton". If we change the scope to ‚Äúprototype‚Äù, the application will not be able to rise due to the attempt of the infinite introduction of the service into itself. It will look like this</font></font><br><br><pre> <code class="hljs markdown"><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">** APPLICATION FAILED TO START **</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span><span class="hljs-strong"><span class="hljs-strong">*****</span></span> Description: The dependencies of some of the beans in the application context form a cycle: aopTestApplication (field private com.example.AOPTest.MyServiceImpl com.example.AOPTest.AopTestApplication.myService) ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê | myServiceImpl (field private com.example.AOPTest.MyServiceImpl com.example.AOPTest.MyServiceImpl.myService) ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What else I would like to draw attention to is the overhead that accompanies us when using Spring AOP. I repeat that there will always be created proxy objects on any of our bin falling under the action of an aspect. And there will be exactly as many of them as the bin instances will be created. In the example we looked at the singleton bin, respectively, only one proxy object was created. We use prototype - and the number of proxy objects will correspond to the number of implementations. The proxy object itself does not make calls to the methods of the target object, it contains a chain of interceptors that do this. Regardless of whether or not each particular method of the target object is affected by an aspect, its call passes through a proxy object. Well, plus at least one instance class of the aspect will be created (in our example it will be only one,but it can be controlled).</font></font><br><br><h2>  Afterword </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The feeling of cognitive dissonance never left me. </font><font style="vertical-align: inherit;">Something in this example with transactions is still wrong. </font><font style="vertical-align: inherit;">I duplicate his code.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do something method2(); } @Transactional (propagation=Propagation.REQUIRES_NEW) public void method2() { //do something } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although no, it seems, understood. </font><font style="vertical-align: inherit;">And it's not only and not so much about AOP. </font><font style="vertical-align: inherit;">It is not obvious to me why it might be necessary to create another one in the middle of one transaction (assuming that it was originally intended to get exactly this result). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If someone can give an example from real projects, when it was necessary, I would appreciate it in the comments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I see only problems here.</font></font></div><p>Source: <a href="https://habr.com/ru/post/347752/">https://habr.com/ru/post/347752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347740/index.html">Front End Developer Checklist</a></li>
<li><a href="../347744/index.html">How to package a dependent library in obr when developing a plugin for Jira</a></li>
<li><a href="../347746/index.html">Chromium: memory leaks</a></li>
<li><a href="../347748/index.html">Object in a case or Optional in Java 8 and Java 9. Part 3: ‚ÄúWhat's added in Java 9‚Äù</a></li>
<li><a href="../347750/index.html">Learn OpenGL. Lesson 4.6 - Cubic cards</a></li>
<li><a href="../347754/index.html">JavaScript proxy: beautiful and useful</a></li>
<li><a href="../347756/index.html">SuperJob IT meetup. Work with business requirements at different project scales</a></li>
<li><a href="../347758/index.html">Nonrandom chance, or Attack on PRNG in .NET</a></li>
<li><a href="../347760/index.html">And so it will do ... or how the data of 14 million Russians were in my hands</a></li>
<li><a href="../347764/index.html">20 times cheaper, 2.5 times more accurate and twice as convenient</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>