<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Five ways to paginate in Postgres, from basic to outlandish</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You may be surprised by the fact that pagination, which is widespread, as such, in web applications, can easily be implemented irrationally. In this a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Five ways to paginate in Postgres, from basic to outlandish</h1><div class="post__text post__text-html js-mediator-article">  You may be surprised by the fact that pagination, which is widespread, as such, in web applications, can easily be implemented irrationally.  In this article, we will try out various server-side pagination methods and discuss their convenience when used in PostgreSQL.  The article will help you understand which technique is more appropriate in your situation, including some you may not have seen before, namely those that rely on physical clustering and the database statistics collector. <br><a name="habracut"></a><br>  Before continuing, mention should be made of pagination on the application side.  Some applications transfer all (or most) server information to the client and share it on the page there.  For small amounts of data, application-side pagination can be a good choice, reducing the number of HTTP calls.  This approach becomes impractical when records begin to number in the thousands.  Pagination on the server side has the following advantages: <br><br><ul><li>  Faster loading start page </li><li>  Higher accuracy when total data changes </li><li>  Faster operations on large amounts of data </li><li>  Business Logic Encapsulation </li><li>  Better performance on clients with limited resources </li></ul><br>  PostgreSQL gives us a certain number of server-side pagination techniques that differ in speed, integrity (do not lose a record), as well as support for access patterns to specific pages.  Not all methods work in all situations, some require special data or queries.  Consider the methods in order of generality, starting with those that work with any queries, and continuing with those that require ordered data.  We end with a few exotic methods that are based on PostgreSQL's internal structure. <br><br><h2>  Splitting arbitrary queries </h2><br><h3>  Limit-offset </h3><br>  The easiest method of pagination, limit-offset, is also the most risky.  Unfortunately, it is one of the foundations of tutorials on web development.  Object-relational mapping (ORM) libraries make using this method easy and tempting, from SQLAlchemy <b><i>.slice (1, 3)</i></b> to ActiveRecord <b><i>.limit (1) .offset (3)</i></b> to Sequelize <b><i>.findAll ({ offset: 3, limit: 1})</i></b> .  It is not a coincidence that limit-offset is used everywhere; you can attach it to any request without further modification. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The ORM methods of limit and offset are one thing, pagination helper libraries can be even more deceptive.  For example, the popular Ruby library Kaminari uses limit-offset by default, hiding it behind a high-level interface. <br><br>  This technique has two big problems, inconsistency of result and inefficiency of bias.  The consistency is related to the fact that the passage through the results must receive each element strictly once, without gaps or repetitions.  The inefficiency of the bias is associated with the delay arising from the shift of the results by a large bias. <br><br>  This is how limit-offset pagination can be inconsistent.  Suppose the user goes from page <i>n</i> to page <i>n + 1</i> , while at the same time a new element is inserted on page <i>n</i> .  This will cause duplication (the last element from page <i>n is</i> pushed onto page <i>n + 1</i> ) and skipping (new element).  Alternatively, suppose that item <i>n is</i> deleted, at the moment when the user navigates to page <i>n + 1</i> .  The preloaded initial element of page <i>n + 1</i> will move to page <i>n</i> and will be skipped. <br><br>  Now on the topic of inefficiency.  Big shifts are really expensive.  Even if there is an index, the database will have to scan all the storage, counting the rows.  To use an index, we must filter the column by value, but in this case we need a certain number of rows, regardless of their column values.  In addition, strings are not required to be the same size when stored, and some of them may be present on the disk, but be marked as deleted so that the database cannot use simple arithmetic to find disk space and start reading the results.  Let's measure the slowdown. <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--        CREATE TABLE medley AS SELECT generate_series(1,10000000) AS n, substr(concat(md5(random()::text), md5(random()::text)), 1, (random() * 64)::integer + 1) AS description; --        VACUUM ANALYZE; --     EXPLAIN ANALYZE SELECT * FROM medley LIMIT 100;</span></span></code> </pre> <br>  Estimated cost is quite low: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..1.85 rows=100 width=38) (actual time=0.008..0.036 rows=100 loops=1) -&gt; Seq Scan on medley (cost=0.00..185460.60 rows=9999660 width=38) (actual time=0.007..0.017 rows=100 loops=1) Planning time: 0.040 ms Execution time: 0.059 ms (4 rows)</span></span></code> </pre><br>  The choice of offset = 1000, changes its value to 19 and the runtime to 0.609 ms.  As soon as offset = 5000000, the cost becomes already 92734 and the runtime is 758.484 ms. <br><br>  These problems do not necessarily mean that the limit-offset method is not applicable in your case.  In some applications, users, as a rule, do not pass many pages in the results, and you can even use the limitation of the number of pages on the server side.  If data inconsistency and limiting the number of pages are not a problem in your application, then the limit-offset method is quite suitable for you. <br><br>  <b>When to use: Limit-Offset.</b>  Applications with limited pagination depth and non-consistency tolerant results. <br><br><h3>  Cursors </h3><br>  Despite its shortcomings, the limit-offset method has a plus in the form of no impact on the server.  In contrast to this approach, there is another method of dividing pages, cursors.  Like offset, cursors can be used with any requests, but they differ in that they require a separate connection and transaction from the server via an HTTP client. <br><br>  This is how cursors can be used: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      BEGIN; --     DECLARE medley_cur CURSOR FOR SELECT * FROM medley; --  10  FETCH 10 FROM medley_cur; -- ... --   10 ,   ,      FETCH 10 FROM medley_cur; --   COMMIT;</span></span></code> </pre><br>  Cursors have the desired property of consistency of pagination on any requests, showing the results that exist in the database at the time of the start of the transaction.  Transaction <a href="http://www.postgresql.org/docs/9.5/static/transaction-iso.html">isolation level</a> ensures that the paged result does not change. <br><br>  Each pagination approach has its own weaknesses, and the cursors are no exception: they are dependent on the use of resources and the client-server bundle.  Each open transaction consumes allocated base resources and does not scale for a large number of clients.  Of course, there are "WITH HOLD" cursors that may exist outside the transaction, but they must materialize the data. Thus, these errors make the pagination with cursors suitable only for a narrow circle of situations, for example for an internal network. <br><br>  Adding an HTTP connection to cursors brings with it complications.  Servers must identify clients between requests, whether through a token or by storing an identifier, such as the client‚Äôs IP address during a session.  Servers also have to decide when to release transactions due to their downtime.  Finally, server load balancing becomes difficult, as the client must connect to a particular server each time. <br><br>  <b>When to use: Cursors.</b>  The application is within the network, on a single server, which should paginate requests with a variable and variable order, especially when consistency of the result is important. <br><br><h2>  Pagination ordered queries </h2><br><h3>  Keyset pagination </h3><br>  The techniques listed above can paginate the results of queries of any type, including unordered queries.  If we are ready to abandon this community, then we can reap the benefits of optimization.  In particular, when organizing by indexed columns, the user can use the values ‚Äã‚Äãfrom the current page to select which objects to show on the next page.  This is called key set pagination. <br><br>  For example, let's return to our example: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--     (btrees  ) CREATE INDEX n_idx ON medley USING btree (n); SELECT * FROM medley ORDER BY n ASC LIMIT 5;</span></span></code> </pre><br>  With my random data, it returns: <br><br><pre> <code class="sql hljs"> n | description <span class="hljs-comment"><span class="hljs-comment">---+------------------------------------------------------------- 1 | 74f70e009396 2 | 8dac5a085eb670a29058d 3 | fce303a32e89181bf5df1601487 4 | fddcced2c12e83516b3bd6cc94f23a012dfd 5 | f51ae548dd27f51147e53e839eeceb6b0c92922145276d668e73d4a6621 (5 rows)</span></span></code> </pre><br>  Now the user can look at the maximum n from the result and use it to call the next page: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  Even when filtering with n&gt; 5000000, it works faster than in the limit-offset example. <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.43..0.62 rows=5 width=38) (actual time=0.101..0.103 rows=5 loops=1) -&gt; Index Scan using n_idx on medley (cost=0.43..185579.42 rows=5013485 width=38) (actual time=0.100..0.102 rows=5 loops=1) Index Cond: (n &gt; 5000000) Planning time: 0.071 ms Execution time: 0.119 ms (5 rows)</span></span></code> </pre><br>  This pagination works quickly and at the same time guarantees the integrity of the data.  Any additions / deletions to the current page will leave the result unchanged.  Two weak points of this method are the lack of random access and a possible connection between the client and the server. <br><br>  In general, there is no way to move to the selected page without visiting the previous ones to determine their maximum elements.  Under certain conditions, however, we can do better.  If the values ‚Äã‚Äãin the indexed column are evenly distributed (or even better, adjacent numbers without spaces), the user can perform some mathematical calculations to find the page of interest, because the index makes it cheaper to find the largest value: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(n) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------ Result (cost=0.46..0.47 rows=1 width=0) (actual time=0.021..0.021 rows=1 loops=1) InitPlan 1 (returns $0) -&gt; Limit (cost=0.43..0.46 rows=1 width=4) (actual time=0.018..0.018 rows=1 loops=1) -&gt; Index Only Scan Backward using n_idx on medley (cost=0.43..284688.43 rows=10000000 width=4) (actual time=0.017..0.017 rows=1 loops=1) Index Cond: (n IS NOT NULL) Heap Fetches: 0 Planning time: 0.087 ms Execution time: 0.042 ms (8 rows)</span></span></code> </pre><br>  Another issue of pagination by key values, client / server connection, requires attention.  Initially, the user does not know which columns are indexed.  The server is likely to provide a fixed result endpoint, rather than allowing the client to change the order.  The code provided to the client may not know which column is ordered, the server should provide a hint how to request the next page.  <a href="https://tools.ietf.org/html/rfc5988">RFC5988</a> defines the relationship between the previous and the next HTTP links to encode the links for the user to which he should go. <br><br>  Since users tend to access information pages in a linear fashion, pagination by key values ‚Äã‚Äãis usually preferable for pagination of records on high-load web servers. <br><br>  <b>When to use: Keyword pagination.</b>  Scalable applications that serve data sequentially from column (s) indexed for comparison.  Supports filtering. <br><br><h2>  Strange, specialized pagination </h2><br><h3>  Clustered TID Scan </h3><br>  We can get non-standard pagination methods for special situations using low-level PostgreSQL functions.  For example, we can get really random access to data if we <br><br><ol><li>  Do not require pages to be the same size. </li><li>  We support only a single order for paged lines. </li></ol><br>  The trick is to select returned pages that are associated with pages from a database on disk, or with certain parts of these pages on disk.  Each table in the PostgreSQL database contains a secret column called ctid, which identifies its row: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ctid, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; ctid | n | description <span class="hljs-comment"><span class="hljs-comment">--------+----+------------------------------------------------------------- (0,1) | 1 | 74f70e009396 (0,2) | 2 | 8dac5a085eb670a29058d (0,3) | 3 | fce303a32e89181bf5df1601487 (0,4) | 4 | fddcced2c12e83516b3bd6cc94f23a012dfd (0,5) | 5 | f51ae548dd27f51147e53e839eeceb6b0c92922145276d668e73d4a6621 (0,6) | 6 | eb9fe1dfe1e421903f96b3b5c5dfe1ee1253582d728c35b4ee7330b (0,7) | 7 | e95202d7f5c612f8523ae705d (0,8) | 8 | 6573b64aff262a2b940326 (0,9) | 9 | a0a43 (0,10) | 10 | 82cdc134bd249a612cfddd3088dd09e32de5f4fa33 (10 rows)</span></span></code> </pre><br>  Each ctid is the following: (page, line).  PostgreSQL can get strings very quickly via ctid, in fact, this is how indexes work - they associate column values ‚Äã‚Äãwith ctids. <br><br>  Note that, although PostgreSQL determines the order relation based on the tid type, it cannot effectively get ctids from the inequality <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ctid &gt;= <span class="hljs-string"><span class="hljs-string">'(0,1)'</span></span>::tid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ctid &lt; <span class="hljs-string"><span class="hljs-string">'(1,0)'</span></span>::tid; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------- Aggregate (cost=235589.00..235589.01 rows=1 width=0) (actual time=1241.851..1241.852 rows=1 loops=1) -&gt; Seq Scan on medley (cost=0.00..235464.00 rows=50000 width=0) (actual time=477.933..1241.802 rows=116 loops=1) Filter: ((ctid &gt;= '(0,1)'::tid) AND (ctid &lt; '(1,0)'::tid)) Rows Removed by Filter: 9999884 Planning time: 0.047 ms Execution time: 1241.889 ms (6 rows)</span></span></code> </pre><br>  The range query does not work, but there is still a way to efficiently query all lines from a page on disk.  Each page contains current_setting ('block_size') data bytes (usually 8k).  The strings are linked by a 32-bit pointer, so most of them are block_size / 4 lines per page.  (Actually, the lines are usually wider than the minimum size and a quarter of the block size provides the upper limit of the lines on the page.) The next sequence will generate all possible ctids on the j-th page <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> (<span class="hljs-string"><span class="hljs-string">'('</span></span> || j || <span class="hljs-string"><span class="hljs-string">','</span></span> || si || <span class="hljs-string"><span class="hljs-string">')'</span></span>)::tid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,current_setting(<span class="hljs-string"><span class="hljs-string">'block_size'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> s(i);</code> </pre><br>  Let's use it to get all the lines in our example on page zero. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ctid = <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> (<span class="hljs-string"><span class="hljs-string">'(0,'</span></span> || si || <span class="hljs-string"><span class="hljs-string">')'</span></span>)::tid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,current_setting(<span class="hljs-string"><span class="hljs-string">'block_size'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> s(i) ) );</code> </pre><br>  The scheduler determined the cost of executing this request to be equal to = 25.03..65.12 and executes it for 2.765ms.  Request page number 10,000 has the same cost.  So we get really random access, why not love it? <br><br>  There are three bottlenecks: <br><br><ol><li>  When lines are deleted - they leave holes in the pages. </li><li>  The order of the lines cannot be meaningful.  The database inserts rows into holes left from deleting rows, causing the rows to fall out of sequence. </li><li>  "Where" is not supported </li></ol><br>  In some situations, this is not a problem.  One case is the data whose natural order is related to the order of addition to the database, such as only increasing data of time intervals.  The other is data that does not change often.  This is due to the fact that we have control over the arrangement of lines on the pages through the CLUSTER command. <br><br>  Let's go back to our example.  Its rows on the disk are ordered by column n in ascending order, since this is the order in which we added them to the database.  But what if we want to sort them by the description column?  To do this, we will have to physically rebuild the table by creating an index on the description column and perform clustering. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> description_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> btree (description); CLUSTER medley USING description_idx;</code> </pre><br>  Now sampling of all lines from the first page returns us data sorted alphabetically by the description column.  If the table changes, the new lines will drop out of the alphabetical list, but as long as the table is unchanged - the returned objects will be in perfect order.  In addition, it can be periodically reclustered after changes, despite the fact that this operation locks the table and cannot be performed when people need access to it. <br><br>  Finally, you can determine the total number of pages for a table using its total size in bytes. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_size(<span class="hljs-string"><span class="hljs-string">'medley'</span></span>) / current_setting(<span class="hljs-string"><span class="hljs-string">'block_size'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>;</code> </pre><br>  <b>When to use: TID Scan.</b>  When fast random access is required and no filtering is required.  Works especially well with only increasing time data, with practically unchanged line width. <br><br><h3>  A set of keys with estimated bookmarks </h3><br>  As we have seen, the usual pagination on sets of keys does not allow you to move to specific pages, except when the user guesses.  However, the PostgreSQL statistics collector supports histograms of the distribution of values ‚Äã‚Äãacross columns.  We can use these estimates in conjunction with constraints and small offsets to get quick pagination with random access through a hybrid approach. <br><br>  To begin, let's take a look at the statistics in our example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_length(histogram_bounds, <span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'medley'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attname = <span class="hljs-string"><span class="hljs-string">'n'</span></span>;</code> </pre><br>  In my database, column n has 101 boundary exponents, i.e.  100 ranges between them.  Specific values ‚Äã‚Äãare not too knocked out, since the data is evenly distributed. <br><br><pre> <code class="sql hljs">{719,103188,193973,288794, ‚Ä¶ ,9690475,9791775,9905770,9999847}</code> </pre> <br><br>  Note that the values ‚Äã‚Äãare approximate.  The first number is not exactly 0, and the last is not exactly ten million.  Ranges divide our information into a block of size B = 10,000,000 / 100 = 100,000 lines. <br><br>  We can use PostgreSQL statistics collector histogram ranges to obtain probabilistically correct pages.  If we choose the page size on the client side, equal to W, then how do we get the i-th page?  It will be in the IW / B block, with an offset of IW% B. <br><br>  Choosing W = 20, let's request a page of 270,000 from our test table. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> bookmark <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> (histogram_bounds::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>[])[((<span class="hljs-number"><span class="hljs-number">270000</span></span> * <span class="hljs-number"><span class="hljs-number">20</span></span>) / <span class="hljs-number"><span class="hljs-number">100000</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, (histogram_bounds::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>[])[((<span class="hljs-number"><span class="hljs-number">270000</span></span> * <span class="hljs-number"><span class="hljs-number">20</span></span>) / <span class="hljs-number"><span class="hljs-number">100000</span></span>)+<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'medley'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attname = <span class="hljs-string"><span class="hljs-string">'n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookmark) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> n &lt; (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookmark) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFFSET</span></span> ((<span class="hljs-number"><span class="hljs-number">270000</span></span> * <span class="hljs-number"><span class="hljs-number">20</span></span>) % <span class="hljs-number"><span class="hljs-number">100000</span></span>);</code> </pre><br>  This is performed super-fast (note that the shift occurs in a time close to zero in this case).  The query returns rows with n = 5407259 to 5407278. The true values ‚Äã‚Äãon page 270000 are equal to n = 5400001 to 5400020. The slip is 7239, or approximately 0.1%. <br><br>  We were lucky with the choice of the page in this case.  For contrast, page 74999 requires an offset of 99980. We know that our offset will be no more than 100,000. The upper limit is under our control if we want to reach a compromise.  By customizing the PostgreSQL statistics collector, we can get a more accurate bar graph by column. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> medley <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>; VACUUM <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>;</code> </pre><br>  Now we have 1000, instead of 100 histogram values.  In my database, it looks like this: <br><br><pre> <code class="sql hljs">{10,10230,20863, ‚Ä¶, 9980444,9989948,9999995}</code> </pre><br>  In this case, the step of our shift will be no more than 10,000. The compromise is that the scheduler now scans more values, but slows down.  So this is something between a bias inefficiency and a statistics collector overhead. <br><br>  This hybrid ‚Äúkey / offset‚Äù method is probably not suitable for many real-life pagination applications.  And the where clause will not work here.  In addition, it is inaccurate and becomes only more and more inaccurate when the table is changed and if the statistics collector has not been launched for a long time. <br><br>  <b>When to use: Keyset with rating bookmarks.</b>  When the user needs deep, but approximate random access, without any additional filtering. <br><br><h3>  findings </h3><br>  Like many other engineering solutions, the choice of pagination technique requires compromises.  It is safe to say that keying pagination is most applicable for an average site with an ordered linear access.  However, even the limit / offset method has its strengths, and more exotic methods provide specific performance characteristics for certain types of data.  As you can see, there are quite a few possibilities.  Choose the right tool for the job and do not allow the pagination to be a closed book. </div><p>Source: <a href="https://habr.com/ru/post/301044/">https://habr.com/ru/post/301044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301030/index.html">Metromarathon Algorithm. As a Yandex analyst, I calculated that all stations can be visited in one day.</a></li>
<li><a href="../301032/index.html">12 week sketch marathon, do or die</a></li>
<li><a href="../301036/index.html">Best Go practices, six years in</a></li>
<li><a href="../301040/index.html">What browsers do with your JavaScript code: about optimizations in JS engines using V8 as an example</a></li>
<li><a href="../301042/index.html">Angular 2 brings the world to the frontend galaxy</a></li>
<li><a href="../301046/index.html">Test lab v.9: impossible or nothing</a></li>
<li><a href="../301048/index.html">EDS of CIS countries in Python</a></li>
<li><a href="../301052/index.html">Watch out! Cycle bike! Or 5 service errors worth 1000 rubles</a></li>
<li><a href="../301056/index.html">4 ways of a young regional developer that I went through in my student years</a></li>
<li><a href="../301058/index.html">How MasterCard Develops Biometric Identification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>