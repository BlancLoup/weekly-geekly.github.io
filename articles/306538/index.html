<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Over Engineering in Documenting ViewSets Django REST Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It happens in our lives, dear colleagues, that you want to do as easier, but it turns out like a beginner. And, interestingly, there are quite a few p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Over Engineering in Documenting ViewSets Django REST Framework</h1><div class="post__text post__text-html js-mediator-article">  It happens in our lives, dear colleagues, that you want to do as easier, but it turns out like a beginner.  And, interestingly, there are quite a few powerful tools that offer a simple solution in exchange for a soul.  I mean, the price of abstraction is disproportionate to the beauty of its use.  For me, the example of such an unequal exchange was the Django Rest Framework 3.4.0, its ViewSets mechanism and the need to display detailed documentation on the API being developed. <br><br><a name="habracut"></a>  Let's start with a simple one: my favorite format for working with DRF is to write only APIView descendants.  On the one hand, this is a repeating code, and on the other, it is quite a concise solution with a predictable and controllable user case.  First of all, with a 95% probability, we will not hang several serializers on one endpoint.  Second, we can fine tune the URL binding.  But, over time, you begin to think: have I done everything correctly?  Maybe it's time to move away from the idea of ‚Äã‚Äãconservatism proven over the years REST?  Moreover, DRF has a fairly good abstraction layer: <a href="http://www.django-rest-framework.org/api-guide/viewsets/">ViewSets</a> . <br><br>  The idea of ‚Äã‚ÄãViewSets is simple: we have a serviced model, and we don‚Äôt need to write our endpoints or describe them as separate classes.  A class that registers views, binds urls, etc. is enough.  Those.  This is a lot of templates packed in a box tied with a blue ribbon.  The task was relatively standard: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. There is a custom user profile. <br>  2. It has additional fields. <br>  3. During registration, we use REST and manually determine which fields are required and which are not (override model fields at the DRF level). <br>  4. Login is generated automatically. <br>  5. The profile has a connection with an invite, and an invite is associated with the organization that invited this invite. <br><br>  After some thought, it was decided to make 2 or 3 serializer.  Absolutely there is a separate serializer on create.  Separate - on the view.  Perhaps, but not the fact that the third is needed - on update (change).  The classic REST application scheme would look like this: <br><br>  <b>serializers.py</b> <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserCreateSerializer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(serializers.ModelSerializer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSerializer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(serializers.ModelSerializer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserUpdateSerializer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(serializers.ModelSerializer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserCreateView</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(APIView)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDetailsView</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(APIView)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserUpdateView</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(APIView)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br><br>  After a little refactoring, we can get one APIView: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserApiView</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(APIView)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__list_view(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'pk'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.kwargs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.__detail_view(request) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__create_view(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'pk'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.kwargs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.__update_view(request)</code> </pre><br><br>  As you can see, there is no special need for ViewSet.  The trace of the request is exactly one line, but the functions get, post, put, and others like them are available to us.  In addition, if we suddenly do not like the result, we can always return to the format of three separate classes of endpoints.  This method has another advantage: when you install an application for automatic documentation ( <a href="https://github.com/marcgibbons/django-rest-swagger">Swagger</a> or <a href="http://drfdocs.com/">DRF Docs</a> ), you get a predictable conclusion: either three endpoints or one endpoint with the three methods described. <br><br>  However, let's move on to the ViewSet abstraction: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet)</span></span></span><span class="hljs-class">:</span></span> serializer_classes = { <span class="hljs-string"><span class="hljs-string">'list'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'get'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'create'</span></span>: UserCreateSerializer, <span class="hljs-string"><span class="hljs-string">'update'</span></span>: UserUpdateSerializer, <span class="hljs-string"><span class="hljs-string">'set_password'</span></span>: UserEditSerializer, <span class="hljs-comment"><span class="hljs-comment">#   ? 'activate': UserEditSerializer } def list(self, request, *args, **kwargs): serializer_class = self.serializer_classes['list'] pass def create(self, request, *args, **kwargs): serializer_class = self.serializer_classes['create']</span></span></code> </pre><br><br>  First, the abundance of code is striking.  It is much more than in the version with one endpoint and three methods.  Secondly, we see a rather pleasant declarativeness of the code, which, by the way, we will soon have a knife on the pope. <br><br>  <b>So our problem is that Swagger and DRF Docs will not work correctly with this viewpoint.</b> <br><br>  I didn‚Äôt dig into Swagger code, but I think I‚Äôm not going to sin if I say that it gets endpoint methods like this: <br><br>  1. Get urlpattern <br>  2. Endpoint = urlpattern.callback <br>  3. Methods = endpoint.available_methods <br><br>  Pay attention to the fact that the callback is requested without creating an instance, or by calling the as_view method, which receives the request argument.  Let's test our theory: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet)</span></span></span><span class="hljs-class">:</span></span> serializer_classes = { <span class="hljs-string"><span class="hljs-string">'list'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'get'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'create'</span></span>: UserCreateSerializer, <span class="hljs-string"><span class="hljs-string">'update'</span></span>: UserUpdateSerializer, <span class="hljs-string"><span class="hljs-string">'set_password'</span></span>: UserEditSerializer, <span class="hljs-comment"><span class="hljs-comment">#   ? 'activate': UserEditSerializer } def get_serializer_class(self): logger.warn(self.request) logger.warn(self.actions) return UserViewSerializer # Actions here...</span></span></code> </pre><br><br>  We get a 500 error with the information that the UserViewSet object does not have a request attribute.  If we remove the problematic line, we get the second error: this object does not have the actions attribute.  This happens because ViewSetMixin exposes actions when there is a request, although it would be more logical to make a list of available actions in the form of classproperty (after all, when inheriting miksin, standard actions are fixed by the name and conditions of triggering). <br><br>  But now we are not interested in what would happen if the grandmother had mudiki (Dahl‚Äôs dictionary, if I'm not mistaken).  We have an interface that cannot be documented.  Here is the grief! <br><br>  I did not manage to document the Swagger interface.  The problem crutch lies in the very <b>get_serializer_class ()</b> method that you saw in the previous snippet.  Both Swagger and DRF Docs use it to get the current serializer.  We can assume that our code should look like this: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet)</span></span></span><span class="hljs-class">:</span></span> serializer_classes = { <span class="hljs-string"><span class="hljs-string">'list'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'get'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'create'</span></span>: UserCreateSerializer, <span class="hljs-string"><span class="hljs-string">'update'</span></span>: UserUpdateSerializer, <span class="hljs-string"><span class="hljs-string">'set_password'</span></span>: UserEditSerializer, <span class="hljs-comment"><span class="hljs-comment">#   ? 'activate': UserEditSerializer } def get_serializer_class(self): return self.serializer_classes.get(self.action, UserViewSerializer) # Actions here...</span></span></code> </pre><br><br>  But we remember that at the time of triggering get_serializer_class, self.action does not exist as an attribute.  This causes a 500 error and does not allow the use of this case.  Having studied both solutions (Swagger, DRF Docs), I stopped at the last one.  And then I got another problem: <br><br>  <i>- <u>today is July 27, 2016, and the DRF Docs code from the wizard branch is different from the DRF Docs code, which is placed via pypi or by downloading the GIT repository.</u></i> <br><br>  I don‚Äôt know if this is a glitch, but, apparently, git gives the code marked as release 0.0.11, and the developers had the audacity to update the wizard without release.  Fail! <br><br>  The problem is being solved with a crutch - replacing api_endpoint.py in the package.  You understand perfectly well that this is not an option.  Here I have two ways of developing the code: either I will wait until the developers roll out a new release, or return to the inheritance option from APIView.  Today there is no time and strength to do it.  Understanding the code of this file (which is working in the wizard), I came across two interesting fragments.  Here is the first one: <br><br>  <b>api_endpoint.py</b> <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get_serializer_class__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(self.callback.cls, <span class="hljs-string"><span class="hljs-string">'serializer_class'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.callback.cls.serializer_class <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(self.callback.cls, <span class="hljs-string"><span class="hljs-string">'get_serializer_class'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.callback.cls.get_serializer_class(self.pattern.callback.cls())</code> </pre><br><br>  The fact is that our implementation of ViewSet will always contain property <b>serializer_class = None</b> .  It would be logical to swap checks in order to prioritize the dynamic shift of the serializer. <br><br>  The second point: <br><br>  <b>api_endpoint.py</b> <br><br><pre> <code class="python hljs"> view_methods = [force_str(m).upper() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.callback.cls.http_method_names <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hasattr(self.callback.cls, m)] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewset_methods + view_methods</code> </pre><br><br>  Now, if you stick a stopper between these two lines and try to get self.callback.actions, then you will get the dictionary that we lack for work.  Of course, it was possible to connect to the development and add a separate logic to document the actions ... but we don‚Äôt need it for free.  Now I am waiting for the DRF Docs developers to accept the issue with the first problem (serializer_class = None) and hope for a quick release.  If it doesn't happen, go back to the APIView version.  As for the method of getting the serializer, it looks like this: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet)</span></span></span><span class="hljs-class">:</span></span> serializer_classes = { <span class="hljs-string"><span class="hljs-string">'list'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'get'</span></span>: UserViewSerializer, <span class="hljs-string"><span class="hljs-string">'create'</span></span>: UserCreateSerializer, <span class="hljs-string"><span class="hljs-string">'update'</span></span>: UserUpdateSerializer, <span class="hljs-string"><span class="hljs-string">'set_password'</span></span>: UserEditSerializer, <span class="hljs-comment"><span class="hljs-comment">#   ? 'activate': UserEditSerializer } def get_serializer_class(self): if not hasattr(self, 'action'): action = 'create' if 'POST' in self.allowed_methods else 'list' else: action = self.action return self.serializer_classes.get(action, UserViewSerializer) # Actions here...</span></span></code> </pre><br><br>  It remains to hope that the update method will not create problems when adding.  Another small remark: I had to add the post method: <br><br>  <b>views.py</b> <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserViewSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(mixins.ListModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin, viewsets.GenericViewSet)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#... def post(self, *args, **kwargs): return super().post(*args, **kwargs) # Actions here...</span></span></code> </pre><br><br>  Without it, DRF Docs could not get allowed_methods, and Swagger also had problems. <br><br>  So, dear colleagues, when addressing the high level of framework abstraction, I ran into an architectural problem.  It boils down to a simple conclusion: "I am guilty myself."  Although, the question is, of course, controversial, because ViewSets is a convenient and official tool.  However, it can be seen with the naked eye that the issue of registering actions in a class is not worked out.  Hence the reluctance of documentary developers to handle actions normally.  The outcome of the situation is simple: today it is easier to use separate API Views than the presentation templates for the model.  At least, in most well-known REST engines or frameworks that can create REST, you most likely will not see such abstractions.  And a very big question: are they needed at all? </div><p>Source: <a href="https://habr.com/ru/post/306538/">https://habr.com/ru/post/306538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306526/index.html">Installing the service desk system vsDesk 3.0</a></li>
<li><a href="../306528/index.html">Where did the System Administrator Day come from and why is it important to celebrate it</a></li>
<li><a href="../306530/index.html">Video reports from DevConf 2016</a></li>
<li><a href="../306534/index.html">Money does not sleep: who wins in the confrontation of hackers and financial organizations</a></li>
<li><a href="../306536/index.html">uDev tech events: Kharkov, August 9th. Better Architecture with UX-Driven Design</a></li>
<li><a href="../306540/index.html">Personal management system development</a></li>
<li><a href="../306542/index.html">Urgently required VPS with SLA: analysis of services of 32 Russian data centers</a></li>
<li><a href="../306544/index.html">Universal https using GOST certificate</a></li>
<li><a href="../306548/index.html">Distributed execution of Python tasks using Apache Mesos. Yandex experience</a></li>
<li><a href="../306550/index.html">JavaScript in 2016: functional programming has come seriously and for a long time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>