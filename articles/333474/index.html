<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let's talk about micro-optimizations on the example of Tizen code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a rule, when discussing the diagnostic capabilities of PVS-Studio, the recommendations provided by the analyzer regarding the micro-optimizations o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let's talk about micro-optimizations on the example of Tizen code</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/99b/586/aa199b586c6647555e497f0b3ef5146a.png" alt="Micro-optimizations in code"></div><br>  As a rule, when discussing the diagnostic capabilities of PVS-Studio, the recommendations provided by the analyzer regarding the micro-optimizations of C and C ++ code remain behind the scenes.  Of course, micro-optimizations are not as important as diagnostics that detect errors, but it's also interesting to talk about them. <br><a name="habracut"></a><br><h2>  Micro-optimizations </h2><br>  I continue the cycle of articles related to the code analysis of the operating system Tizen.  The Tizen project, (including third-party libraries) has about 72,500,000 lines of C and C ++ code.  The project is interesting to me because of its size, since it allows to demonstrate various aspects of using the methodology of static code analysis. <br><br>  In the previous article, " <a href="https://habrahabr.ru/company/pvs-studio/blog/332912/">27000 errors in the Tizen operating system</a> ", I showed how you can estimate the number of errors that can be detected by a static code analyzer.  The article also reviewed a large number of code fragments that demonstrate the capabilities of the analyzer in identifying various types of defects.  However, in addition to detecting errors, the analyzer can offer a number of improvements that affect the performance of the code. <br><br>  I‚Äôll say right away that PVS-Studio does not act and cannot act as a substitute for the tools of program profiling.  Only dynamic program analyzers can identify bottlenecks.  Static analyzers do not know which input data the program receives and how often a particular code section is executed.  Therefore, we say that the analyzer offers to perform some ‚Äú <b>micro-</b> optimization‚Äù of the code that does not guarantee a performance boost at all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the use of micro-optimizations should not wait for a noticeable performance increase, are they needed at all?  Yes, and I have the following rationales for this: <br><br><ol><li>  Appropriate analyzer diagnostics often reveal bad code.  Changing it, the programmer will make the code easier, clearer and often shorter. </li><li>  There is little use of micro-optimizations in the Release version, as compilers now know how to optimize code perfectly.  But in the Debug version, some micro-optimizations are not at all ‚Äúmicro‚Äù and allow us to speed up the operation of the application, which is very useful. </li></ol><br>  In PVS-Studio, there are still few diagnostics dedicated to micro-optimizations (see <a href="https://www.viva64.com/ru/w/">diagnostics</a> with V801-V820 numbers), but gradually we will develop a set of these diagnostics.  In the articles we rarely paid attention to them, so now, in the process of studying the Tizen code, there is a good time to talk about this topic. <br><br>  So, let's look at the existing PVS-Studio warnings dedicated to micro-optimizations. <br><br><h2>  Examples of triggers </h2><br>  As I wrote in the previous <a href="https://habrahabr.ru/company/pvs-studio/blog/332912/">article</a> , I studied about 3.3% of the Tizen code.  Therefore, I can predict how many alerts of a certain type PVS-Studio will issue for the entire project, multiplying the number of messages found by 30. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/cd2/2c8/bffcd22c8a89a08ae013c4fa3b457217.png" alt="thirty"></div><br>  Please remember this factor <b>30</b> , since I will constantly use it in further calculations. <br><br><h3>  V801: It is better to redefine the function. </h3><br>  It is inefficient to make functions that take "heavy" arguments by value.  Diagnostics are triggered when the arguments are constant and therefore will not exactly change in the body of the function. <br><br>  Example from Tizen code: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLogTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tagName)</span></span></span><span class="hljs-function"> </span></span>{ m_tag = tagName; }</code> </pre> <br>  PVS-Studio: V801 Decreased performance.  It is better to redefine it.  Consider replacing 'const ... tagName' with 'const ... &amp; tagName'.  Logger.h 110 <br><br>  An extra <i>tagName</i> object is <i>created</i> , which is an expensive operation.  This code performs operations such as allocating memory and copying data.  Moreover, these expensive operations can be avoided.  The simplest option is to pass an argument over a constant link: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLogTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tagName)</span></span></span><span class="hljs-function"> </span></span>{ m_tag = tagName; }</code> </pre> <br>  So we got rid of memory allocation and string copying. <br><br>  There is another option.  You can remove <i>const</i> and not copy, but move the data: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLogTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tagName)</span></span></span><span class="hljs-function"> </span></span>{ m_tag = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tagName); }</code> </pre> <br>  This code will be just as effective. <br><br>  The variant with <i>std :: string is of</i> course harmless.  Creating an extra line is unpleasant, but it cannot somehow affect the speed of work.  However, there may be more serious situations when, for example, in vain you create an array of strings.  We will take a look at one such case below, when we talk about diagnosing the V813. <br><br>  In total, the analyzer issued 76 warnings for the projects I studied. <br><br>  It should be borne in mind that the analyzer can sometimes produce triggers that are not of practical use.  For example, the analyzer cannot distinguish a self-made smart pointer from a single-linked list element.  Both there and there will be a pointer (to the line / next element).  Both there and there will be an integer variable (the length of the string / value of the list item).  It seems to be the same thing, but the costs of copying such objects will be fundamentally different.  Of course, you can look into the copy constructor and try to understand what's what, but on the whole, this is a hopeless exercise.  Therefore, it makes sense to ignore such alarms and to suppress them you should use one of the mechanisms provided by the PVS-Studio analyzer.  About these mechanisms, I, perhaps, in the future, I will write a separate article. <br><br>  Now we need a factor of 30, about which I spoke earlier.  Using it, I can calculate that for the entire Tizen project, the PVS-Studio analyzer will generate about 76 * 30 = <b>2280</b> warnings of V801. <br><br><h3>  V802: On the 32-bit / 64-bit platform, it can be reduced to </h3><br>  Diagnostics V802 is looking for structures and classes, the size of which can be reduced by sorting the fields in descending order of their size.  Example of non-optimal structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiseElement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isActive; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_pNext; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_value; };</code> </pre> <br>  This structure in the 64-bit code ( <a href="https://www.viva64.com/ru/t/0026/">LLP64</a> ) will occupy 24 bytes, which is associated with <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">data alignment</a> .  If you change the sequence of fields, then its size will be only 16 bytes.  The optimized version of the structure will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiseElement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_pNext; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_value; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isActive; };</code> </pre> <br>  Note that the structure is always 12 bytes in a 32-bit program, regardless of the sequence of the fields.  Therefore, when checking the 32-bit configuration ( <a href="https://www.viva64.com/ru/t/0019/">ILP32LL</a> ), the message V802 will not be issued. <br><br>  It should be noted that optimization of structures is not always possible and is not always necessary. <br><br>  Optimization is not possible if you need to maintain data format compatibility.  More often, this optimization is simply not needed.  If objects of a non-optimal structure are created in tens or hundreds, then no useful gain will be obtained.  It makes sense to think about this optimization when the number of elements is in the millions.  After all, the smaller the size of each structure, the more such structures will be placed in the microprocessor caches. <br><br>  As you can see, the scope of application of the V802 diagnostics is extremely small, so it is often reasonable to turn off this diagnostics so that it does not interfere.  Accordingly, I see no reason to count how many non-optimal structures PVS-Studio can find in the Tizen code.  I think that in more than 99% of cases it is not necessary to optimize structures.  I will demonstrate here only the very possibility of such an analysis, citing one warning issued to the Tizen code. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> format; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fields; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; } <span class="hljs-keyword"><span class="hljs-keyword">bt_pbap_pull_vcard_parameters_t</span></span>;</code> </pre> <br>  PVS-Studio: V802 On 32-bit platform, it can be reduced by 24 to 16 bytes by rearranging.  bluetooth api.h 1663 <br><br>  If the analyzer does not make mistakes, then when compiling code for the Tizen platform, the type <i>long long unsigned</i> should be aligned at the 8 byte boundary.  To be honest, we haven‚Äôt yet clarified this point, since this platform is new for us, but this is the case in systems I know :). <br><br>  So, once the variable <i>fields is</i> aligned on the border of 8 bytes, the structure will look like this in memory: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/79d/3d5/341/79d3d534153dc20263db5d588d7af877.png" alt="Non-optimal structure"></div><br><br>  You can shuffle class members like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fields; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> format; } <span class="hljs-keyword"><span class="hljs-keyword">bt_pbap_pull_vcard_parameters_t</span></span>;</code> </pre> <br>  Then it will be possible to save 8 bytes and the structure will be allocated in memory as follows: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/e29/830/12be2983094b6ebbc3fd7380a685ee08.png" alt="Improved structure"></div><br><br>  As you can see, the size of the structure has decreased. <br><br><h3>  V803.  It is a form of ++ it.  Replace iterator ++ with ++ iterator </h3><br>  In books, it is recommended to use the prefix increment of iterators in cycles, instead of postfix increment.  The question of how relevant this is today is considered in the articles: <ul><li>  Andrey Karpov.  <a href="https://www.viva64.com/ru/b/0093/">Is it practical to use the prefix increment operator ++ it for iterators instead of postfix increment it ++</a> . </li><li>  Silviu Ardelean.  <a href="http://silviuardelean.ro/2011/04/20/pre-vs-post-increment-operator/">pre vs.</a>  <a href="http://silviuardelean.ro/2011/04/20/pre-vs-post-increment-operator/">post increment operator - benchmark</a> . </li></ul><br>  A brief conclusion is this.  For the release version of the application there is no difference.  For the Debug version there is a difference, and a significant one.  Therefore, the recommendation is relevant and it should be followed.  It is often useful for the Debug version to work quickly. <br><br>  Consider an example of analyzer triggering: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ServiceManagerPrivate::loadServiceLibs() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> end = servicesLoaderMap.end(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> slm = servicesLoaderMap.begin(); slm !=end; slm++ ){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ ServiceFactory* factory=((*slm).second-&gt;getFactory()); servicesMap[factory-&gt;serviceName()] = factory; }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&amp; e){ BROWSER_LOGD(e.what() ); } } }</code> </pre> <br>  PVS-Studio: V803 Decreased performance.  In case of a slm is an iterator  Replace iterator ++ with ++ iterator.  ServiceManager.cpp 67 <br><br>  It will be useful to replace <i>slm ++</i> with <i>++ slm</i> .  Of course, one replacement will give nothing and this should be approached systematically.  For the code I tested, the analyzer issued 103 recommendations.  This means that, if desired, it will be possible to modify about <b>3,000</b> places in Tizen.  Due to such changes, the debug version will work a bit faster. <br><br><h3>  V804: the same string </h3><br>  There are situations when the code calculates the length of the same line two or more times.  In the debug version, this is an unambiguous slowdown of the program, especially if the code is executed many times.  As it will be in the Release-version is unknown, but there is a high probability that the compiler will not guess how much to combine the calls to the <i>strlen</i> function into one call. <br><br>  Consider the sample code. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> isc_result_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildfilename</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *directory, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) &gt; <span class="hljs-number"><span class="hljs-number">0U</span></span> &amp;&amp; directory[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) - <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">'/'</span></span>) isc_buffer_putstr(out, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  PVS-Studio: V804 Decreased performance.  The 'strlen' function is to calculate the length of the string.  dst_api.c 1832 <br><br>  The length of the directory name is calculated twice.  By the way, V805 warning will be issued for this code, but we'll talk about it below. <br><br>  This code can be improved by adding a temporary variable to store the length: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> directory_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directory_len &gt; <span class="hljs-number"><span class="hljs-number">0U</span></span> &amp;&amp; directory[directory_len - <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">'/'</span></span>) isc_buffer_putstr(out, <span class="hljs-string"><span class="hljs-string">"/"</span></span>);</code> </pre> <br>  I am not saying that this is a must do.  I myself think that this code can be set as it is.  I just need a demo.  The fact that specifically editing the code will not give a win means nothing.  There may be places where such optimization can significantly speed up the work of cycles in which there is a processing of strings. <br><br>  For the verified code, the analyzer issued 20 warnings.  The total predicted number of warnings is <b>600</b> . <br><br><h3>  V805: It 's using the' strlen (str)&gt; 0 'construct </h3><br>  Returning to the code discussed in the previous section. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) &gt; <span class="hljs-number"><span class="hljs-number">0U</span></span> &amp;&amp; directory[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) - <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">'/'</span></span>)</code> </pre> <br>  PVS-Studio: V805 Decreased performance.  It is not necessary to identify the string by using 'strlen (str)&gt; 0' construct.  A more efficient way is to check: str [0]! = '\ 0'.  dst_api.c 1832 <br><br>  In addition to storing the length of the string in an intermediate variable, there is another way to optimize the code.  The first call to <i>strlen is</i> needed to check if the string is empty or not.  In fact, using the strlen function for this purpose is a redundant operation, since it suffices to check only the value of the first byte of the string.  Therefore, you can optimize the code like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*directory != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; directory[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) - <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">'/'</span></span>)</code> </pre> <br>  Or so: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directory[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; directory[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(directory) - <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">'/'</span></span>)</code> </pre> <br>  And so on.  As you understand, there are a lot of options how to change the code.  It doesn‚Äôt matter how the check is recorded, the main thing is that you don‚Äôt need to go through all the characters of the string to understand whether it is empty or not.  Of course, the compiler can guess the programmer‚Äôs intention and optimize the check in the Release version, but you shouldn‚Äôt expect such a gift in advance. <br><br>  One more example: <br><br>  V805 Decreased performance.  It is not necessary to identify the string by using 'strlen (str)! = 0' construct.  A more efficient way is to check: str [0]! = '\ 0'.  bt-util.c 376 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _bt_util_set_phone_name(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *phone_name = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; phone_name = vconf_get_str(VCONFKEY_SETAPPL_DEVICE_NAME_STR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!phone_name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(phone_name) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (!g_utf8_validate(phone_name, -1, (const char **)&amp;ptr)) *ptr = '\0'; bt_adapter_set_name(phone_name); } free(phone_name); }</span></span></code> </pre> <br>  PVS-Studio: V805 Decreased performance.  It is not necessary to identify the string by using 'strlen (str)! = 0' construct.  A more efficient way is to check: str [0]! = '\ 0'.  bt-util.c 376 <br><br>  There is nothing special about this code.  With it, I wanted to specifically demonstrate that this is a typical and extremely common way to check whether an empty string or not.  In fact, I'm even surprised why there is no standard function or macro in C to detect a blank line.  You can not even imagine how many such ineffective checks live in our programs.  I'm going to shock you now. <br><br>  In the part of Tizen I tested, the PVS-Studio analyzer revealed 415 places where the <i>strlen</i> function or its equivalent is used to determine if the string is empty or not. <br><br>  Accordingly, the predicted number of warnings for the entire Tizen project is <b>12,450</b> . <br><br>  Imagine how often the microprocessor drives stupid cycles to search for a terminal zero and clogs the caches with data that it might not be useful to it. <br><br>  In my opinion, it makes sense to get rid of such inefficient calls to <i>strlen</i> functions.  You can write: <ul><li>  if (* phone_name) </li><li>  if (* phone_name! = '\ 0') </li><li>  if (phone_name [0]) </li><li>  if (phone_name [0]! = '\ 0') </li></ul><br>  But I do not like such options, since such code is difficult to read.  It is much better to make a special macro in C, and an inline function in C ++.  Such code will be read much better: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_empty_str(phone_name))</code> </pre> <br>  Once again, it is strange for me that for all the years the universal standard method for checking C-lines for emptiness has not been created.  In my opinion, this generates a huge amount of code in many projects that could work a little faster.  Agree, 12450 ineffective checks deserve attention. <br><br><h3>  V806: The expression of strlen (MyStr.c_str ()) kind can be rewritten as MyStr.length () </h3><br>  If there were a huge number of V805 warnings, then for scanned projects the analyzer issued only 2 warnings of V806.  Let's take a look at one of these rare birds: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panel_slot_forward_key_event</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> KeyEvent &amp;key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_mode)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(key.get_key_string().c_str()) &gt;= <span class="hljs-number"><span class="hljs-number">116</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  PVS-Studio: V806 Decreased performance.  The expression of strlen (MyStr.c_str ()) kind can be rewritten as MyStr.length ().  wayland_panel_agent_module.cpp 2511 <br><br>  Usually this situation arises after refactoring the old C-code, which has become C ++ code.  The length of a string in a variable of type <i>std :: string</i> is determined using <i>strlen</i> .  The method is clearly ineffective, and even complicating code.  Normal way: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key.get_key_string().length() &gt;= <span class="hljs-number"><span class="hljs-number">116</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  The code has become shorter and faster.  The expected number of warnings in the project Tizen: <b>60</b> . <br><br><h3>  V807: Consider creating the same expression repeatedly </h3><br>  Sometimes in programs you can find an expression that includes many operators "-&gt;" and ".".  For example, something like this: <br><pre> <code class="cpp hljs">To()-&gt;be.<span class="hljs-keyword"><span class="hljs-keyword">or</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>().to()-&gt;be();</code> </pre> <br>  In Russia, this is called "programming using the train."  I don‚Äôt know if there is an English analogue to this coding style, but I think in any case it‚Äôs clear why the train is mentioned here. <br><br>  Such code is considered bad, and in books dedicated to the quality of the code, it is recommended to avoid it.  It is even worse if such ‚Äútrains‚Äù repeat many times.  First, they clutter up the text of the program, and secondly, they can degrade program performance.  Consider one of these cases: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/953/74f/8ad/95374f8ad9d93a5620413c6b8d092cf5.png" alt="The trains in the code"></div><br><br>  PVS-Studio: V807 Decreased performance.  Consider creating a reference to avoid using the same expression repeatedly.  ImageObject.cpp 262 <br><br>  In my opinion, this code will look better if you write it like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;keypoint = obj.__features.__objectKeypoints[keypointNum]; os &lt;&lt; keypoint.pt.x &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.pt.y &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.size &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.response &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.angle &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.octave &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; os &lt;&lt; keypoint.class_id &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br>  Will such code be faster?  Not.  Compared to the slow data output to the stream, all other operations are insignificant, even if we are talking about the debug version. <br><br>  But the second version of the code is shorter, it is easier to read and accompany. <br><br>  As I said, we won‚Äôt get performance gains here.  However, there may be places where such optimization can be useful.  This happens if there are calls of slow long functions in the ‚Äústeam train‚Äù.  In such places, the compiler cannot figure out how to perform optimization and it turns out a huge number of redundant function calls. <br><br>  In total, the analyzer pointed to 93 code fragments.  The predicted total number of alerts is <b>2,700</b> . <br><br><h3>  V808: </h3><br>  The following diagnosis is very interesting.  It identifies variables and arrays that are not used.  Most often, such artifacts arise in the process of refactoring, when they forget to remove the declaration of a more unused variable. <br><br>  An unused variable may also indicate a logical error in the program, but, in my experience, this happens rarely. <br><br>  The analyzer issues a warning in the following cases: <ul><li>  An array is created, but not used.  This means that the function uses more stack memory than necessary.  First, it may contribute to a situation where a stack overflow occurs.  Secondly, it can reduce the efficiency of the cache in the microprocessor. </li><li>  Class objects are created but not used.  The analyzer warns not about all objects, but about those that are guaranteed to be meaningless to create and not to use.  For example, <i>std :: string</i> or <i>CString</i> .  Creating and destroying such objects is a waste of CPU time and stack. </li></ul><br>  Separately, I note that the analyzer does not swear for extra variables, for example, of type <i>float</i> or <i>char</i> .  In this case, an incredible amount of uninteresting false positives is obtained.  There are a lot of such situations in the code, where macros or preprocessor directives are widely used <i>#if .. # else .. # endif</i> .  Moreover, these extra variables are harmless, since the compiler will remove them in the optimization process. <br><br>  Let's look at a couple of examples of alerts issued for the Tizen code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CynaraAdmin::userRemove(<span class="hljs-keyword"><span class="hljs-keyword">uid_t</span></span> uid) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;CynaraAdminPolicy&gt; policies; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(uid)); emptyBucket(Buckets.at(Bucket::PRIVACY_MANAGER),<span class="hljs-literal"><span class="hljs-literal">true</span></span>, CYNARA_ADMIN_ANY, user, CYNARA_ADMIN_ANY); }</code> </pre> <br>  PVS-Studio: V808 'policies' object of 'vector' type created.  cynara.cpp 499 <br><br>  The variable <i>policies is</i> not used.  It just needs to be removed. <br><br>  And now a more suspicious code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _focused(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data, Evas_Object *obj, Elm_Object_Item *item) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">menumgr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">menumgr</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> Elm_Focus_Direction focus_dir[] = { ELM_FOCUS_LEFT, ELM_FOCUS_RIGHT, ELM_FOCUS_UP, ELM_FOCUS_DOWN }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; Evas_Object *neighbour; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!obj || !m) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m-&gt;info[id] &amp;&amp; m-&gt;info[id]-&gt;focused) m-&gt;info[id]-&gt;focused(m-&gt;data, id); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(focus_dir) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(focus_dir[<span class="hljs-number"><span class="hljs-number">0</span></span>]); ++i) { neighbour = elm_object_focus_next_object_get(obj, i); evas_object_stack_above(obj, neighbour); } }</code> </pre> <br>  PVS-Studio: V808 'focus_dir' array was not used.  menumgr.c 110 <br><br>  The <i>focus_dir</i> array <i>is</i> not used.  This is strange, and maybe there is some kind of mistake, but maybe not.  It is difficult for me to give an answer without starting a serious study of the code. <br><br>  For the verified code, the analyzer issued 30 warnings.  The predicted number of warnings for the entire code is <b>900</b> . <br><br><h3>  V809: The 'if (ptr! = NULL)' check can be be removed </h3><br>  We got to the diagnosis, which gives the most positives.  Very often people write this code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(P); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Q) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Q;</code> </pre> <br>  This code is redundant.  The <i>free</i> function and the <i>delete</i> operator work perfectly well with null pointers. <br><br>  The code can be simplified: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(P); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Q;</code> </pre> <br>  An extra check does nothing and only slows down the code. <br><br>  Here I can say that such code is faster.  If the pointer is zero, then it is not necessary to go inside the <i>free</i> function or the <i>delete</i> operator and do a check somewhere inside them. <br><br>  I disagree.  Most of the code is written based on the fact that pointers are not null.  A null pointer is usually a special / emergency situation that occurs rarely.  Therefore, almost always, when we refer to <i>free / delete</i> , we pass a non-zero pointer there.  And if so, then the preliminary check is harmful, but at the same time clutters the code. <br><br>  As an example, consider the following function: <br><pre> <code class="cpp hljs">lwres_freeaddrinfo(struct addrinfo *ai) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ai != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ai_next = ai-&gt;ai_next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ai-&gt;ai_addr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai-&gt;ai_addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ai-&gt;ai_canonname) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai-&gt;ai_canonname); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai); ai = ai_next; } }</code> </pre> <br>  Here are two extra checks at once, about which the analyzer informs <ul><li>  V809 Verifying that a pointer value is not NULL is not required.  The 'if (ai-&gt; ai_addr! = NULL)' check can be removed.  getaddrinfo.c 694 </li><li>  V809 Verifying that a pointer value is not NULL is not required.  The 'if (ai-&gt; ai_canonname)' check can be be removed.  getaddrinfo.c 696 </li></ul><br>  Let's remove the redundant checks: <br><pre> <code class="cpp hljs">lwres_freeaddrinfo(struct addrinfo *ai) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ai != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ai_next = ai-&gt;ai_next; <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai-&gt;ai_addr); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai-&gt;ai_canonname); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ai); ai = ai_next; } }</code> </pre> <br>  In my opinion, the code has become much simpler and more beautiful.  A great example of refactoring. <br><br>  In the projects I tested, the analyzer revealed 620 unnecessary checks! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/30a/156/a8430a1568f159f136d0e6b2e4c61033.png" alt="Unnecessary checks before free / delete"></div><br><br>  This means that for all projects, the analyzer will issue about <b>18,600</b> warnings!  Wow!  Just imagine, you can safely delete 18600 <i>if statements</i> . <br><br><h3>  V810: The 'A' </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIZEN_USER_CONTENT_PATH tzplatform_getenv(TZ_USER_CONTENT) int _media_content_rollback_path(const char *path, char *replace_path) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (strncmp(path, TIZEN_USER_CONTENT_PATH, strlen(TIZEN_USER_CONTENT_PATH)) == 0) { .... }</span></span></code> </pre> <br>  V810 Decreased performance.  The 'tzplatform_getenv (TZ_USER_CONTENT)' function was called.  You can‚Äôt be saved a variable variable, which can then be used while the strncmp function is called.  media_util_private.c 328 <br><br>  The analyzer detects the code in which there is a function call, to which the result of several calls to the same function is passed as actual arguments.  Moreover, these used functions are called with the same arguments.  If these functions run slowly, then the code can be optimized by placing the result in an intermediate variable. <br><br>  In the above code, the <i>tzplatform_getenv</i> function is called twice with the same actual argument. <br><br>      7       .     . <br><br><h3> V811: Excessive type casting: string -&gt; char * -&gt; string </h3><br>   ,     .  : <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> A = Foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A.c_str())</span></span></span></span>;</code> </pre> <br>  <i>B</i>    ,       ,   .       ,     <i>A</i> .          .  ,             <i>A</i> .    : <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> A = Foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code is not only faster, but also shorter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's look at an example of how diagnostics work on the Tizen code</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PasswordUI::changeState(PasswordState state) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> text = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (m_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PasswordState::ConfirmPassword: text = TabTranslations::instance().ConfirmPassword.c_str(); m_naviframe-&gt;setTitle(<span class="hljs-string"><span class="hljs-string">"IDS_BR_HEADER_CONFIRM_PASSWORD_ABB2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio: V811 Decreased performance. </font><font style="vertical-align: inherit;">Excessive type casting: string -&gt; char * -&gt; string. </font><font style="vertical-align: inherit;">Consider inspecting the expression. </font><font style="vertical-align: inherit;">PasswordUI.cpp 242 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the projects I checked, the analyzer issued 41 warnings. </font><font style="vertical-align: inherit;">This means, it can be expected that the analyzer will detect in the Tizen project </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1230</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> such inefficient copying of strings.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V812: Ineffective use of the 'count' function </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the verified projects, no V812 warnings were issued, so I‚Äôll only briefly explain what it is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of calling the functions </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">count</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">count_if</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the standard library is compared with zero. </font><font style="vertical-align: inherit;">This can be potentially slow, because these functions need to process the entire container in order to count the number of items needed. </font><font style="vertical-align: inherit;">If the value returned by the function is compared with zero, then we are wondering if there is at least 1 such element or not at all. </font><font style="vertical-align: inherit;">Checking that the element is present / absent in the container can be more effectively performed using the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_if function</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ineffective:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">multiset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;ms)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ms.count(<span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) Foo(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Effectively: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">multiset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;ms)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ms.find(<span class="hljs-number"><span class="hljs-number">10</span></span>) != ms.end()) Foo(); }</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V813: Constant pointer / reference </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An argument representing a structure or class is passed to the function by value. The analyzer, checking the function body, came to the conclusion that this argument is not modified. For the purpose of optimization, such an argument can be passed as a constant reference. This can speed up the execution of the program, since when the function is called, only the address will be copied, not the entire class object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The V813 diagnostics is similar to the V801, but in this case the variable is not marked as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This means that the analyzer will have to try to figure out whether the variable in the function is modified or not. If modified, no warning is required. Occasionally there are false positives, but in general, diagnostics work well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider an example of a function detected using this diagnostic.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDescriptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; toAdd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_descCount + toAdd.size() &gt; MAX_POLICY_DESCRIPTIONS) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::length_error(<span class="hljs-string"><span class="hljs-string">"Descriptions count would exceed "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(MAX_POLICY_DESCRIPTIONS)); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> addDesc = [] (DescrType **desc, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;name) { (*desc) = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;DescrType *&gt;(<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DescrType))); (*desc)-&gt;result = result; (*desc)-&gt;name = strdup(name.data()); }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;it : toAdd) { addDesc(m_policyDescs + m_descCount, it.first, it.second); ++m_descCount; } m_policyDescs[m_descCount] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br> PVS-Studio: V813 Decreased performance. The 'toAdd' argument should probably be rendered as a constant reference. CyadCommandlineDispatcherTest.h 63 <br><br>      <i>std::vector&lt;std::pair&lt;int, std::string&gt;&gt;</i> . ,     ‚Äî   . <br><br>  ,     .      : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDescriptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::pair&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; &amp;toAdd)</span></span></span></span></code> </pre> <br>  , ,  .   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TabService::errorPrint(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> method) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code = bp_tab_adaptor_get_errorcode(); BROWSER_LOGE(<span class="hljs-string"><span class="hljs-string">"%s error: %d (%s)"</span></span>, method.c_str(), error_code, tools::capiWebError::tabErrorToString(error_code).c_str()); }</code> </pre> <br> PVS-Studio: V813 Decreased performance. The 'method' argument should probably be rendered as a constant reference. TabService.cpp 67 <br><br>       .  ,        -. <br><br>       303 .  ,     Tizen  <b>9090</b> . ,      ,      . <br><br><h3> V814: The 'strlen' function was called multiple times inside the body of a loop </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reader probably already noticed that mostly micro-optimizations are associated with strings. The reason is that most of these diagnostics are developed at the suggestion of one client, for whom efficient work with strings is important. The diagnostics that we are about to consider are no exception and are also related to strings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The analyzer detects cycles in which the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strlen (S)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or similar is called. In this case, the string </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not change, and therefore, its length can be calculated in advance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a couple of examples of how this diagnostic works.</font></font> Example 1 <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SETTING_FONT_PRELOAD_FONT_PATH </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/usr/share/fonts"</span></span></span><span class="hljs-meta"> static Eina_List *_get_available_font_list() { .... for (j = 0; j </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; fs-&gt;nfont; j++) { FcChar8 *family = NULL; FcChar8 *file = NULL; FcChar8 *lang = NULL; int id = 0; if (FcPatternGetString(fs-&gt;fonts[j], FC_FILE, 0, &amp;file) == FcResultMatch) { int preload_path_len = strlen(SETTING_FONT_PRELOAD_FONT_PATH); .... }</span></span></span></span></code> </pre> <br> PVS-Studio: V814 Decreased performance. The 'strlen' function was called multiple times inside the body of a loop. setting-display.c 1185 <br><br>    ,        "/usr/share/fonts".   ,       . ,  ,    ,  ,           . <br><br>    :         . <br><br>  The second example. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BN_fromhex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BIGNUM *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hexdigits[] = <span class="hljs-string"><span class="hljs-string">"0123456789abcdef"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; BIGNUM *out; RUNTIME_CHECK(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str) &lt; <span class="hljs-number"><span class="hljs-number">1024U</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str) % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0U</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str); i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> high, low; s = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(hexdigits, <span class="hljs-built_in"><span class="hljs-built_in">tolower</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)str[i])); RUNTIME_CHECK(s != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); high = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s - hexdigits); s = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(hexdigits, <span class="hljs-built_in"><span class="hljs-built_in">tolower</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)str[i + <span class="hljs-number"><span class="hljs-number">1</span></span>])); RUNTIME_CHECK(s != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); low = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s - hexdigits); data[i/<span class="hljs-number"><span class="hljs-number">2</span></span>] = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((high &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + low); } out = BN_bin2bn(data, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str)/<span class="hljs-number"><span class="hljs-number">2</span></span>, b); RUNTIME_CHECK(out != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br> PVS-Studio: V814 Decreased performance. Calls to the 'strlen' function have being made multiple times when a condition for the loop's continuation was calculated. openssldh_link.c 620 <br><br>      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str); i += <span class="hljs-number"><span class="hljs-number">2</span></span>) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At each iteration of the loop, the length of the string passed as an argument will be calculated. Perfectionist in shock. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . As a rule, such code is written by people who have previously worked with the Pascal language (Delphi environment). In Pascal, the end-of-cycle boundary is calculated once, therefore, there such code is appropriate and common. </font></font><a href="https://www.viva64.com/ru/b/0391/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (see chapter ‚Äú18. Knowledge gained in working with one language is not always applicable to another language‚Äù). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, it‚Äôs not worth hoping for optimizations by the compiler here either. A pointer to the line came from outside. Yes, inside the function we cannot change the string (it is, after all, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const char *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). But this does not mean that it cannot be changed by someone from the outside. Suddenly this string changes, for example, the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strchr</font></font></i> .  ‚Ä¶ <br><br> ,   ,      .  Now I will explain. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ value = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;A)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, A); Foo(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, A); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Example(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>   <i>A</i>   <i>const int &amp;</i> ,      1,   2. <br><br>  Like this.    ,  <i>const</i> ‚Äî    ,  ,    .    ,     . <br><br>   : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BN_fromhex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BIGNUM *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hexdigits[] = <span class="hljs-string"><span class="hljs-string">"0123456789abcdef"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> data[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; BIGNUM *out; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> strLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str); RUNTIME_CHECK(strLen &lt; <span class="hljs-number"><span class="hljs-number">1024U</span></span> &amp;&amp; strLen % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0U</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; strLen; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> high, low; s = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(hexdigits, <span class="hljs-built_in"><span class="hljs-built_in">tolower</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)str[i])); RUNTIME_CHECK(s != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); high = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s - hexdigits); s = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(hexdigits, <span class="hljs-built_in"><span class="hljs-built_in">tolower</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)str[i + <span class="hljs-number"><span class="hljs-number">1</span></span>])); RUNTIME_CHECK(s != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); low = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s - hexdigits); data[i/<span class="hljs-number"><span class="hljs-number">2</span></span>] = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((high &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + low); } out = BN_bin2bn(data, strLen / <span class="hljs-number"><span class="hljs-number">2</span></span>, b); RUNTIME_CHECK(out != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br>      112   <i>strlen</i>  ,       .      <b>3360</b> . <br><br>        PVS-Studio    ?   !      <a href="https://www.viva64.com/ru/pvs-studio/"></a> . <br><br><h3> V815: Consider replacing the expression 'AA' with 'BB' </h3><br>     ,        ,    .   ,  : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;A, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A != <span class="hljs-string"><span class="hljs-string">""</span></span>) B = <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br>   : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;A, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!A.empty()) B.clear(); }</code> </pre> <br>    Release-             ? <br><br>    ,    ,    Visual C++ (Visual Studio 2015).         .          ,        <i>std::basic_string::assign</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/85e/756/ae985e756699c9e912ace6f4fbc3f38d.png" alt=" "></div><br><br>      Tizen: <br><pre> <code class="cpp hljs">services::SharedBookmarkFolder FoldersStorage::getFolder(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) { BROWSER_LOGD(<span class="hljs-string"><span class="hljs-string">"[%s:%d] "</span></span>, __PRETTY_FUNCTION__, __LINE__); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name = getFolderName(id); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name != <span class="hljs-string"><span class="hljs-string">""</span></span>) folder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;services::BookmarkFolder&gt;( id, name, count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> folder; }</code> </pre> <br> PVS-Studio: V815 Decreased performance. Consider replacing the expression 'name != ""' with '!name.empty()'. FoldersStorage.cpp 134 <br><br>      ,    .        : <br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> buffer; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> GpsNmeaSource::tryParse(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> data) { .... buffer = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... }</code> </pre> <br> PVS-Studio: V815 Decreased performance. Consider replacing the expression 'buffer = ""' with 'buffer.clear()'. gpsnmea.cpp 709 <br><br>  ,   .  , ,  ,       (str == "")       .  ,        .   - ,  ,    ,   (str == "")    Release . <br><br>      ,  .   ,   ,     .   ,    ,        ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In total, the PVS-Studio analyzer issued 63 warnings of this type for verified projects. </font><font style="vertical-align: inherit;">If the developers consider these warnings worthy of attention, then all of them will be around </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1890</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V816: By reference rather than by value </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An exception is more efficient to intercept, not by value, but by reference. </font><font style="vertical-align: inherit;">At the same time, this avoids some other errors. </font><font style="vertical-align: inherit;">For example, you can avoid the problem of "cutting" (slice). </font><font style="vertical-align: inherit;">However, this topic is beyond the scope of this diagnostic. </font><font style="vertical-align: inherit;">To combat the cut-off there is a diagnosis of </font></font><a href="https://www.viva64.com/ru/w/V746/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V746</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagnostic response example:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *fmt, ...)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[size]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc) { Logger::getInstance().<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Error while allocating memory!!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio: V816 </font><font style="vertical-align: inherit;">LoggerTools.cpp 37 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Better to write:</font></font><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc &amp;) {</code> </pre> <br>   84     . :  <b>2500</b> . <br><br><h3> V817: It is more efficient to search for 'X' character rather than a string </h3><br>      .     ,  2 .  The first: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> URIEntry::_uri_entry_editing_changed_user(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* data, Evas_Object*, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((entry.find(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (entry.find(<span class="hljs-string"><span class="hljs-string">"https://"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (entry.find(<span class="hljs-string"><span class="hljs-string">"."</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= self-&gt;setDocIcon(); } else { .... }</span></span></code> </pre> <br> PVS-Studio: V817 It is more efficient to seek '.' character rather than a string. URIEntry.cpp 211 <br><br>     ,    .  Those.    : <br><pre> <code class="cpp hljs">|| (entry.find(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)) {</code> </pre> <br>     : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_gl_info__detail_title_get( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data, Evas_Object *obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *part) { .... p = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(szSerialNum, <span class="hljs-string"><span class="hljs-string">","</span></span>); .... }</code> </pre> <br> PVS-Studio: V817 It is more efficient to seek ',' character rather than a string. setting-info.c 511 <br><br>       <i>strchr</i> : <br><pre> <code class="cpp hljs">p = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(szSerialNum, <span class="hljs-string"><span class="hljs-string">','</span></span>);</code> </pre> <br>     PVS-Studio  37 ,      .     Tizen: <b>1110</b> . <br><br><h3>   </h3><br>  ,    ,  PVS-Studio  6.16    V818, V819, V820.     Tizen                 .      ,   : <br><br><ul><li> <a href="https://www.viva64.com/ru/w/V818/">V818</a> . It is more efficient to use an initialization list rather than an assignment operator. </li><li> <a href="https://www.viva64.com/ru/w/V819/">V819</a> . Decreased performance. Memory is allocated and released multiple times inside the loop body. </li><li> <a href="https://www.viva64.com/ru/w/V820/">V820</a> . The variable is not used after copying. Copying can be replaced with move/swap for optimization. </li></ul><br><h2>  Results </h2><br> ,   ,       PVS-Studio,       . ,  -    .              ( <i>std::string</i> , <i>CString</i>  ..). ,              . <br><br>      ,         Tizen     . <ul><li> V801 ‚Äî 2280 </li><li> V803 ‚Äî 3000 </li><li> V804 ‚Äî 600 </li><li> V805 ‚Äî 12450 </li><li> V806 ‚Äî 60 </li><li> V807 ‚Äî 2700 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V808 - 900 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V809 - 18600 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V811 - 1230 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V813 - 9090 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V814 - 3360 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V815 - 1890 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V816 - 2500 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V817 - 1110 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TOTAL: about </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59,000 warnings</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I don‚Äôt urge to start reading all these warnings and correct the code. </font><font style="vertical-align: inherit;">I understand that such edits will not improve at least some noticeable performance of the operating system. </font><font style="vertical-align: inherit;">Moreover, if you make so many edits, there is a high risk of accidentally breaking something by making a typo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nevertheless, I find these analyzer warnings useful. </font><font style="vertical-align: inherit;">Using them wisely allows you to write simpler and more efficient code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My opinion: it makes no sense to touch the old code. </font><font style="vertical-align: inherit;">However, it is worthwhile to develop a new code taking into account these diagnostics of micro-optimizations. </font><font style="vertical-align: inherit;">This article well shows that you can write code a little better in so many places.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We offer to install </font></font><a href="https://www.viva64.com/ru/pvs-studio/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and try to check your projects. </font><font style="vertical-align: inherit;">Under Windows, the demo version will be immediately available to you. </font><font style="vertical-align: inherit;">To try the Linux version, </font></font><a href="https://www.viva64.com/ru/about-feedback/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">email</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> us and we will send you a temporary license key.</font></font><br><br>  Thank you all for your attention. <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional recommended materials </font></font></h2><br><ol><li>  Andrey Karpov.  <a href="https://habrahabr.ru/company/pvs-studio/blog/332912/">27000 errors in the Tizen operating system</a> . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sergey Vasiliev. </font></font> <a href="https://www.viva64.com/ru/b/0514/">How can PVS-Studio help in finding vulnerabilities?</a> </li><li>  Andrey Karpov. <a href="https://www.viva64.com/ru/b/0510/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We provide the PVS-Studio analyzer to security experts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>  Andrey Karpov. <a href="https://www.viva64.com/ru/b/0500/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio team: code audit and other services</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>  Sergey Khrenov. <a href="https://www.viva64.com/ru/b/0513/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio as a plugin for SonarQube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catherine Milovidova. </font></font><a href="https://www.viva64.com/ru/b/0490/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bug of the month: relay race from PC-Lint to PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ol><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0520/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov. <a href="http://www.viva64.com/en/b/0520/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exploring Microoptimizations Using Tizen Code as an Example</font></font></a> <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/333474/">https://habr.com/ru/post/333474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333462/index.html">About the value of goodwill in the team</a></li>
<li><a href="../333464/index.html">SIP communications analysis using 3CX Log Viewer utility</a></li>
<li><a href="../333466/index.html">Muda marriage</a></li>
<li><a href="../333468/index.html">Installing MS SQL ODBC Driver for Linux and building a plugin for Qt 5.9</a></li>
<li><a href="../333470/index.html">Getting started in Kubernetes with Minikube</a></li>
<li><a href="../333476/index.html">Tuning typical roles of Windows. Part Two: Terminal Server and Deduplication</a></li>
<li><a href="../333478/index.html">Upgrading Fujitsu ETERNUS DX Entry Storage Systems</a></li>
<li><a href="../333480/index.html">DBMS for 1C Fresh. Quickly. Reliably Is free</a></li>
<li><a href="../333482/index.html">Hazards in measuring productivity</a></li>
<li><a href="../333484/index.html">Setting up the development environment: needlework circle (Part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>