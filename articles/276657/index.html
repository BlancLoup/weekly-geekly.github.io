<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Undefined behavior is closer than you think.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people believe that the indefinite behavior of the program arises due to gross errors (for example, writing beyond the bounds of the array) or on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Undefined behavior is closer than you think.</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/69f/5c9/5e3/69f5c95e357fb23ab450549f705735bb.png" alt="Hell is closer than it seems" align="left">  Many people believe that the indefinite behavior of the program arises due to gross errors (for example, writing beyond the bounds of the array) or on inadequate constructions (for example, i = i ++ + ++ i).  Therefore, for many, it is a surprise when an indefinite behavior suddenly manifests itself in a completely familiar and non-alarming code.  Consider one such example.  When programming in C / C ++, you should never let your guard down.  Hell is closer than it seems. <br><br><a name="habracut"></a><br><br><h2>  Error description </h2><br>  I haven't raised the topic of <a href="http://www.viva64.com/ru/t/0002/">64-bit errors for a</a> long time.  I shake the old days.  In this case, undefined holding will manifest itself in a 64-bit program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider an incorrect synthetic sample code. <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Count = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 Gb if (is64bit) Count *= 5; // 5 Gb char *array = (char *)malloc(Count); memset(array, 0, Count); int index = 0; for (size_t i = 0; i != Count; i++) array[index++] = char(i) | 1; if (array[Count - 1] == 0) printf("The last array element contains 0.\n"); free(array);</span></span></code> </pre> <br>  This code works correctly if you build the 32-bit version of the program.  But if you build a 64-bit version of the program, everything is much more interesting. <br><br>  A 64-bit program allocates an array of 5 gigabyte size bytes and fills it with zeros.  Then in the loop the array is filled with some random numbers that are not equal to zero.  To prevent numbers from being 0, use "| 1". <br><br>  Try to guess how this program, compiled in x64 mode, will behave using the compiler included in Visual Studio 2015. Have you prepared an answer?  If yes, then continue. <br><br>  If you run the <b>debug</b> version of this program, it will fall due to overrun of the array.  At some point, the index variable will overflow and its value will be equal to? 2147483648 (INT_MIN). <br><br>  Logical explanation?  Nothing like this!  This indefinite behavior and anything can happen. <br><br>  Additional links: <ul><li>  <a href="https://en.wikipedia.org/wiki/Integer_overflow">Integer overflow</a> </li><li>  <a href="https://www.cs.utah.edu/~regehr/papers/overflow12.pdf">Understanding Integer Overflow in C / C ++</a> </li><li>  <a href="http://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">Is signed integer overflow still undefined behavior in C ++?</a> </li></ul><br>  When I or someone else says that this is indefinite behavior, people start grumbling.  I don't know why, but people are sure that they know exactly how calculations work in C / C ++ and how compilers behave. <br><br>  But in fact they do not know.  If they knew, they would not have said all sorts of nonsense.  Usually stupid things look something like this (collective image): <br><br>  <i>You carry a theoretical nonsense.</i>  <i>Well, yes, formally overflowing 'int' leads to undefined damage.</i>  <i>But this is nothing more than chatter.</i>  <i>In practice, you can always say what happens.</i>  <i>If we add 1 to INT_MAX, we get INT_MIN.</i>  <i>Maybe there are some exotic architectures where this is not the case, but my Visual C ++ / GCC compiler produces the correct result.</i> <br><br>  So, now I will demonstrate undefined behavior without any magic using a simple example and not on some kind of magic architecture, but in a Win64 program. <br><br>  Just collect the above example in <b>Release x64</b> mode and run it.  The program will stop falling, and the message ‚ÄúThe last array element contains 0‚Äù will not be displayed. <br><br>  The indefinite behavior here manifested itself as follows.  The array will be completely filled, despite the fact that the type 'int' is insufficient for indexing all the elements of the array.  For those who do not believe, I suggest to look at the assembly code: <br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != Count; i++) <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D102D xor ecx,ecx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D102F nop <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++] = <span class="hljs-type"><span class="hljs-type">char</span></span>(i) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D1030 movzx edx,cl <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D1033 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> dl,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D1036 mov byte ptr [rcx+rbx],dl <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D1039 inc rcx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D103C cmp rcx,rdi <span class="hljs-number"><span class="hljs-number">000000013</span></span>F6D103F jne main+<span class="hljs-number"><span class="hljs-number">30</span></span>h (<span class="hljs-number"><span class="hljs-number">013</span></span>F6D1030h)</code> </pre> <br>  Here it is a manifestation of uncertain behavior!  And no exotic compilers.  This is VS2015. <br><br>  If you replace 'int' with 'unsigned', the undefined behavior will disappear.  The array will be filled only partially, and at the end the message ‚Äúthe last array element contains 0‚Äù will be displayed. <br><br>  Assembly code when 'unsigned' is used: <br><pre> <code class="hljs pgsql"> unsigned <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F07102D xor r9d,r9d <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != Count; i++) <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071030 mov ecx,r9d <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071033 nop dword ptr [rax] <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071037 nop word ptr [rax+rax] <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>++] = <span class="hljs-type"><span class="hljs-type">char</span></span>(i) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071040 movzx r8d,cl <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071044 mov edx,r9d <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071047 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r8b,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000000013</span></span>F07104B inc r9d <span class="hljs-number"><span class="hljs-number">000000013</span></span>F07104E inc rcx <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071051 mov byte ptr [rdx+rbx],r8b <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071055 cmp rcx,rdi <span class="hljs-number"><span class="hljs-number">000000013</span></span>F071058 jne main+<span class="hljs-number"><span class="hljs-number">40</span></span>h (<span class="hljs-number"><span class="hljs-number">013</span></span>F071040h)</code> </pre> <br><h2>  Note about PVS-Studio </h2><br>  PVS-Studio analyzer does not directly diagnose overflow of sign variables.  This is a thankless task.  It is almost impossible to predict what values ‚Äã‚Äãwill have one or another variable and overflow occurs or not.  However, he may notice erroneous patterns in this code, which he associates with ‚Äú64-bit errors‚Äù. <br><br>  In fact, there are no 64-bit errors.  There are just mistakes, for example, undefined behavior.  Simply, these errors sleep in 32-bit code and manifest themselves in 64-bit.  But if we talk about uncertain behavior, this is not interesting, and no one will buy the analyzer.  Yes, and do not believe that there may be some problems.  But if the analyzer says that a variable can overflow in a cycle, and that this is a ‚Äú64-bit‚Äù error, then it is a completely different matter.  Profit. <br><br>  The PVS-Studio code given above is considered erroneous and issues warnings related to a group of <a href="http://www.viva64.com/ru/viva64-tool/">64-bit diagnostics</a> .  The logic is as follows: in Win32, variables of type size_t are 32-bit, a 5 GB array cannot be allocated and everything works correctly.  Win64 has a lot of memory, and we wanted to work with a large array.  But the code failed and fails.  Those.  32-bit code works, but 64-bit code does not.  In PVS-Studio, this is called a 64-bit error. <br><br>  Here are the diagnostic messages that PVS-Studio will issue to the code shown at the beginning: <ul><li>  V127 An overflow of 32-bit 'index' variable is possible inside a long cycle which utilizes a memsize-type loop counter.  consoleapplication1.cpp 16 </li><li>  V108 Incorrect index type: array [not a memsize-type].  Use memsize type instead.  consoleapplication1.cpp 16 </li></ul><br>  More details on 64-bit traps are suggested to get acquainted with the following articles: <ul><li>  <a href="http://www.viva64.com/ru/l/full/">Development of 64-bit C / C ++ applications</a> </li><li>  <a href="http://www.viva64.com/ru/a/0043/">64-bit horse that can count</a> </li><li>  <a href="http://www.viva64.com/ru/a/0065/">Collection of examples of 64-bit errors in real programs</a> </li><li>  <a href="http://www.viva64.com/ru/b/0253/">C ++ 11 and 64-bit errors</a> </li></ul><br><h2>  Correct code </h2><br>  For everything to work well, you must use the appropriate data types.  If you are going to handle large arrays, then forget about int and unsigned.  For this, there are types ptrdiff_t, intptr_t, size_t, DWORD_PTR, std :: vector :: size_type, and so on.  In this case, let size_t be: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != Count; i++) <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[index++] = <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(i) | <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h2>  Conclusion </h2><br>  If the C ++ language construct causes an undefined behavior, then it causes it and there is no need to argue with it or predict how it will manifest itself.  Just do not write dangerous code. <br><br>  There is a mass of stubborn programmers who do not want to see anything dangerous in the shifts of negative numbers, overflow of sign numbers, comparing this to zero and so on. <br><br>  Do not be among them.  The fact that the program is working now does not mean anything.  How to show UB is impossible to predict.  The expected behavior of the program - this is just one of the options for UB. </div><p>Source: <a href="https://habr.com/ru/post/276657/">https://habr.com/ru/post/276657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276645/index.html">Improving education in universities on information security / IT</a></li>
<li><a href="../276649/index.html">Angular 2 versus Aurelia side by side</a></li>
<li><a href="../276651/index.html">Google has thrown out an ad blocker from Google Play</a></li>
<li><a href="../276653/index.html">Configuring Authentication in OpenVPN via Active Directory on CentOS 7</a></li>
<li><a href="../276655/index.html">Extreme Networks Wi-Fi Solutions for Wireless Network Access</a></li>
<li><a href="../276659/index.html">Live webcast of the Make Web conference, Not War from Montreal - February 5, Friday, at 17:00 (Moscow)</a></li>
<li><a href="../276661/index.html">Recommendations on stream</a></li>
<li><a href="../276663/index.html">Load testing from the cloud</a></li>
<li><a href="../276665/index.html">Is Tox as safe as it is painted?</a></li>
<li><a href="../276669/index.html">Review of physics in Sonic games. Part 1: hard tiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>