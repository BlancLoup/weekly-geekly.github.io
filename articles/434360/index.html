<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explanatory conversation about asynchronous programming in Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all! 

 As you may remember, back in October we translated an interesting article about the use of timers in Javascript. It caused a huge dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explanatory conversation about asynchronous programming in Javascript</h1><div class="post__text post__text-html js-mediator-article"> Hello to all! <br><br>  As you may remember, back in <a href="https://habr.com/company/piter/blog/426709/">October</a> we translated an interesting article about the use of timers in Javascript.  It caused a huge discussion, according to the results of which we have long wanted to return to this topic and offer you a detailed analysis of asynchronous programming in this language.  We are glad that we managed to find decent material and publish it before the end of the year.  Enjoy reading! <br><a name="habracut"></a><br>  Asynchronous programming in Javascript has undergone a multi-stage evolution: from callbacks to promises and further to generators, and soon - to <code>async/await</code> .  At each stage, asynchronous programming in Javascript was somewhat simplified for those who were already knee-deep in their own way in this language, but for beginners it only became more frightening because they needed to understand the nuances of each paradigm, mastering the use of each and, no less importantly, understand how it all works. <br><br>  In this article, we decided to briefly remind you how to use callbacks and promises, give a brief introduction to generators, and then help you intuitively understand exactly how asynchronous programming is organized under the hood using async / async and generators.  We hope that in this way you can confidently apply different paradigms exactly where they are relevant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is assumed that the reader has already used callbacks, promises, and generators for asynchronous programming, as well as being completely familiar with closures and currying in Javascript. <br><br>  <b>Hell callbacks</b> <br><br>  Initially there were callbacks.  There is no synchronous I / O (hereinafter referred to as I / O) in Javascript and locks are not supported at all.  So, for the organization of any I / O or for the postponement of any action, the following strategy was chosen: the code that was required to be executed asynchronously was passed to the function with deferred execution, which was run somewhere lower in the event loop.  One callback is not so bad, but the code grows, and callbacks usually generate new callbacks.  The result is something like this: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Apart from the goose bumps that run at the sight of such a fractal code, there is another problem: now we have delegated the control of our logic to <code>do*Stuff</code> other functions ( <code>get*UserData()</code> ), to which you may not have the source code, and you cannot have are sure if they are doing your callback.  Great, isn't it? <br><br>  <b>Promises</b> <br><br>  Promises reverse the control inversion provided by the callbacks and help to unravel the tangle of callbacks into an even chain. <br>  Now the previous example can be converted to something like this: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  Not so indifferent, eh? <br><br>  But let me !!!  Let's look at a more vital (but still largely contrived) example of callbacks: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     ‚Äì   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  So, we select a user profile, then his interests, then, based on his interests, select recommendations and, finally, having collected all the recommendations, display the page.  Such a set of callbacks that you can probably be proud of, but, nevertheless, some kind of shaggy.  Nothing, let's apply promises here - and everything will be fine.  Right? <br><br>  Let's change our <code>fetchJson()</code> method to return a promise, rather than accept a callback.  Promis is resolved by the response body parsed in JSON format. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Beautiful, is not it?  What is wrong now with this code? <br><br>  ... Oops! .. <br>  We do not have access to the profile or interests in the last function of this chain?  So nothing works!  What to do?  Let's try nested promises: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  Yes ... now it looks much more awkward than we hoped.  Not because of these crazy dolls, we, not least, sought to break the hell of callbacks?  What to do now? <br><br>  The code can be combed a bit, leaning on the circuit: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  Yes, now everything is almost the way we wanted, but with one fad.  Noticed how we called arguments inside callbacks in <code>fetchedUser</code> and <code>fetchedInterests</code> , not <code>user</code> and <code>interests</code> ?  If so, then you are very observant! <br><br>  The flaw in this approach is as follows: one must be very, very careful not to name anything in the internal functions as well as the ‚Äúout of cache‚Äù variables that you are going to use in your closure.  Even if you have enough skill to avoid shading, referring to a variable so high in the closure still seems pretty dangerous, and this is definitely not good. <br><br>  <b>Asynchronous generators</b> <br><br>  Generators will help!  If you use generators, then all the excitement disappears.  Just magic.  True.  Take a look only: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  That's all.  It will work.  You do not break into a tear when you see how beautiful the generators are, do you not regret that you were so short-sighted and began to learn Javascript even before generators appeared in it?  I confess that such a thought once visited me. <br>  But ... how does all this work?  Really magic? <br><br>  Of course not.  We turn to the exposure. <br><br>  <b>Generators</b> <br><br>  In our example, it seems that the generators are easy to use, but in fact a lot of them are going on.  To understand the asynchronous generators in more detail, you need to better understand how the generators work and how they provide asynchronous execution, seemingly synchronous in appearance. <br><br>  As the name implies, the generator makes the values: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  It's pretty simple, but, anyway, let's talk about what's going on here: <br><br><ol><li> <code>const counter = counts();</code>  - we initialize the generator and save it in the counter variable.  The generator is in a suspended state, no code in the body of the generator has yet been executed. </li><li> <code>console.log(counter.next());</code>  - issuance ( <code>yield</code> ) 1 is interpreted, after which 1 is returned as <code>value</code> , and <code>done</code> results in <code>false</code> , because the output does not end there </li><li> <code>console.log(counter.next());</code>  - Now 2! </li><li> <code>console.log(counter.next());</code>  - Now 3!  Finished.  Is that right?  Not.  Execution is suspended in step <code>yield 3;</code>  To complete, call next () again. </li><li> <code>console.log(counter.next());</code>  - Now 4, and it returns, but not issued, so now we exit the function, and everything is ready. </li><li> <code>console.log(counter.next());</code>  - Generator job finished!  He has nothing to say except "everything is done." </li></ol><br>  So we figured out how the generators work!  But wait, but what a shocking truth: generators can not only belch the values, but also devour them! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  Ugh, what ?!  The generator consumes the values, instead of generating them.  How is this possible? <br><br>  The secret in the function <code>next</code> .  It not only returns values ‚Äã‚Äãfrom the generator, but can also return them to the generator.  If you give the <code>next()</code> argument, then the <code>yield</code> operation that the generator is now waiting for actually results in the argument.  That is why the first <code>counter.next(1)</code> registered as <code>undefined</code> .  There is simply no issue that could be allowed. <br><br>  All the same, as if the generator allowed the calling code (procedure) and the generator code (procedure) to cooperate in partnership, so that they transmit values ‚Äã‚Äãto each other as they are executed and wait for each other.  The situation is practically the same, as if Javascript generators would have thought about the possibility of implementing cooperatively executed competitive procedures, they are also ‚Äúcorutines‚Äù.  Actually, quite reminiscent of <code>co()</code> , right? <br><br>  But let's not be in a hurry, but we will outsmart ourselves.  In this case, it is important that the reader intuitively learned the essence of generators and asynchronous programming, and the best way to do this is to assemble the generator yourself.  Not to write the function of the generator and not to use the finished one, but to recreate the function of the generator itself. <br><br>  <b>Internal device of the generator - we generate generators</b> <br><br>  Well, I really do not know exactly how the insides of the generator look in different JS runtimes.  But this is not so important.  Generators match the interface.  A ‚Äúconstructor‚Äù for instantiating a generator, the <code>next(value? : any)</code> method, with which we order the generator to continue working and give it values, another <code>throw(error)</code> method in case an <code>throw(error)</code> generated instead of a value, and finally <code>return()</code> , which while we keep silent.  If compliance with the interface is achieved, then everything is fine. <br><br>  So, let's try building the aforementioned <code>counts()</code> generator on pure ES5, without the <code>function*</code> keyword.  For now, you can ignore <code>throw()</code> and pass the value to <code>next()</code> , because the method does not accept any input.  How to do it? <br><br>  But in Javascript, there is another mechanism for suspending and resuming program execution: closures!  Familiar looks? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  If you used closures before, I‚Äôm sure you‚Äôve already written something like that.  The function returned by makeCounter can generate an infinite sequence of numbers, just like a generator. <br><br>  However, this function does not correspond to the generator interface, and it cannot be directly applied in our example with <code>counts()</code> , which returns 4 values ‚Äã‚Äãand terminates.  What is needed for a universal approach to writing generator-like functions? <br><br>  Closures, state machines and hard labor! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  By running this code, you will see the same results as in the version with the generator.  Nice, right? <br>  So, we have disassembled the generating side of the generator;  let's analyze consuming? <br>  In fact, there are not many differences. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  All you need to do is add <code>input</code> as an argument to <code>go</code> , and values ‚Äã‚Äãare piped.  Does it look like magic again?  Almost like generators? <br><br>  Hooray!  So we recreated the generator as a supplier and as a consumer.  Why not try to combine these functions in it?  Here is another rather artificial example of a generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  Since we are all already experts on generators, we understand that this generator adds the value given in <code>next(value)</code> to <code>sum</code> , and then returns sum.  It works exactly as we expected: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Cool.  Now let's write this interface as a normal function! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Wow, we implemented a full-fledged coruntine. <br><br>  It remains to discuss something about the work of generators.  How do exceptions work?  With the exceptions that occur inside the generators, everything is simple: <code>next()</code> will make the exception penetrate to the caller and the generator will die.  Passing an exception to the generator is done in the <code>throw()</code> method, which we omitted above. <br><br>  Let's enrich our addendum with a cool new opportunity.  If the caller passes the exception to the generator, it will return to the last value of the sum. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Programming Challenge - Generator Error Penetration</b> <br><br>  Comrade, how do we implement throw ()? <br><br>  Easily!  Error is just another value.  We can pass it to <code>go()</code> as the next argument.  In fact, some caution is needed here.  When <code>throw(e)</code> called, the <code>yield</code> will work just as if we had written throw e.  This means that we must check for the presence of errors every state of our state machine, and blame the program if we cannot handle the error. <br><br>  Let's start with the previous implementation of the supplicant, copied <br><br>  <a href="">Template</a> <br><br>  <a href="">Decision</a> <br><br>  Boom!  We implemented a set of quorutines capable of transmitting messages and exceptions to each other, just like a real generator. <br><br>  But the situation is getting worse, isn't it?  The implementation of the state machine is increasingly moving away from the implementation of the generator.  Not only that, due to error handling, the code is cluttered with garbage;  the code is all the more complicated because of such a long <code>while</code> , which we succeeded here.  To convert a <code>while</code> you need to ‚Äúweave‚Äù it into states.  So, our case 1 actually involves 2.5 iterations of the <code>while</code> , because <code>yield</code> ends in the middle.  Finally, you have to add extra code to push exceptions from the caller and back, if there is no <code>try/catch</code> in the generator to handle this exception. <br><br>  You did it!!!  We have completed a detailed analysis of possible options for the implementation of generators, and I hope you have already better understood how the generators work.  The bottom line: <br><br><ul><li>  A generator can generate values, consume values, or both. </li><li>  The state of the generator can be paused (state, state machine, catch?) </li><li>  The caller and the generator allow you to form a set of corutin, interacting with each other </li><li>  Exceptions are sent in any direction. </li></ul><br>  Now that we understand generators better, I propose a potentially convenient way of reasoning about them: these are syntactic constructions with which you can write competitively executed procedures that transmit values ‚Äã‚Äãto each other through a channel that transmits values ‚Äã‚Äãone by one (the <code>yield</code> instruction).  This will be useful to us in the next section, where we will produce <code>co()</code> implementation from Corutin. <br><br>  <b>Inversion Control with Corutin</b> <br><br>  Now, having mastered the work with generators, let's think about how they can be used in asynchronous programming.  If we can write generators as such, this does not mean that promises in generators will be automatically resolved.  But wait, the generators are not meant to work by themselves.  They must interact with another program, the main procedure, the one that calls <code>.next()</code> and <code>.throw()</code> . <br><br>  What if to put our business logic not in the main procedure, namely in the generator?  Whenever a business logic gets some asynchronous value, say, promise, the generator says: ‚ÄúI don‚Äôt want to mess with this stupidity, wake me up when it resolves‚Äù, pause and issue a promise to the servicing procedure.  The serving procedure: ‚ÄúOK, I'll call you later‚Äù.  After that, it registers a callback with this promise, exits and waits until it is possible to trigger a cycle of events (that is, when promise is resolved).  When this happens, the procedure will announce: ‚ÄúHey, your turn‚Äù, and send the value via <code>.next()</code> sleeping generator.  She will wait for the generator to do its work, while in the meantime she will be engaged in other asynchronous tasks ... and so on.  You listened to a sad story about how the procedure lives in the service of the generator. <br><br>  So, back to the main topic.  Now that we know how generators and promises work, it will not be difficult for us to create such an ‚Äúofficial procedure‚Äù.  The utility procedure itself will be competitively executed as promise, instantiate and maintain the generator, and then return to the final result of our main procedure using the callback <code>.then()</code> . <br><br>  Next, let's go back to the co () program and discuss it in more detail.  <code>co()</code> is a service procedure that takes on slave labor so that the generator can work only with synchronous values.  Already much more logical looks, right? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   ‚Äî co() </b> <br><br>  Fine!     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br>  <a href="">Template</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br>  <a href="">Decision</a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   ‚Äì    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br>  <a href="">Template</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br>  <a href="">Decision</a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  ‚Äî !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br> <b></b> <br><br>       Javascript   , ,  ¬´ ¬ª     <code>co()</code> ,  ,    ,    <code>async/await</code> . ?  Right. </div><p>Source: <a href="https://habr.com/ru/post/434360/">https://habr.com/ru/post/434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434346/index.html">MIT course "Computer Systems Security". Lecture 22: MIT Information Security, Part 3</a></li>
<li><a href="../434348/index.html">Do you remember your password on Habr√©?</a></li>
<li><a href="../434354/index.html">Creating a face recognition model using deep learning in Python</a></li>
<li><a href="../434356/index.html">Python Stiller Mailing</a></li>
<li><a href="../434358/index.html">Import Substitution Operating Systems. How do I see domestic OS</a></li>
<li><a href="../434362/index.html">Non-forecast for 2019</a></li>
<li><a href="../434364/index.html">Hangfire queue support</a></li>
<li><a href="../434366/index.html">The Big Four are preparing to share 5G frequencies</a></li>
<li><a href="../434368/index.html">Machine learning for finding errors in code: how I trained at JetBrains Research</a></li>
<li><a href="../434370/index.html">Regular shadow shadows in the Phaser, or the use of bicycles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>