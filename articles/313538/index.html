<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Differences between MVVM and the rest of the MV * patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator : 
 Many materials on MVC and its derived patterns have already been published, but everyone understands them in their own way. On...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Differences between MVVM and the rest of the MV * patterns</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/e32/84d/b85/e3284db85c3d43559ee22e2299dab71a.jpg"></p><br><blockquote>  <em>From the translator</em> : <br>  <em>Many materials on MVC and its derived patterns have already been published, but everyone understands them in their own way.</em>  <em>On this basis, differences and holivars arise.</em>  <em>Even experienced developers argue about what is the difference between MVP, MVVM and Presentation Model and what one or another component should do in each pattern.</em>  <em>The situation is aggravated by the fact that many do not know the true role of the controller in the classic version of MVC.</em>  <em>I bring to your attention the translation of a <a href="https://blogs.msdn.microsoft.com/erwinvandervalk/2009/08/14/the-difference-between-model-view-viewmodel-and-other-separated-presentation-patterns/">good review article</a> , which clarifies a lot and puts everything in its place</em> . <a name="habracut"></a></blockquote><p>  Before we begin to dive into the details of the Model-View-ViewModel pattern (MVVM), I think it would be useful to describe the similarities and differences between MVVM and other design patterns for separating the model and the view (MV * patterns). </p><br><p>  There are quite a few MV * patterns: Model-View-Controller, Model-View-Presenter, Presentation Model, Passive View, Supervising Controller, Model-View-ViewModel and many others: </p><br><p><img src="https://habrastorage.org/files/9b6/fe7/747/9b6fe77475fb46e4980536ddbd544a1d.png" alt="mv_patterns_img"></p><br><p>  Looking at the diagrams, you certainly see that the arrows show the relationship between the components.  But is this the only difference?  Is the Controller the same as Presenter or PresentationModel?  How would you compare the Model-View-Presenter and Model-View-ViewModel?  In this article, I'm going to describe the similarities and differences between the most common MV * patterns. </p><br><h2 id="postroenie-ui-bez-ispolzovaniya-mv-patternov">  Build UI without using MV * patterns </h2><br><p>  How would you build a user interface (UI) without using the above patterns?  Would take the form, add widgets to it, and write the logic in the code.  This code, which describes the logic of View, is tightly connected to the user interface, as it directly interacts with the elements on the screen.  This is a good, but straightforward approach.  It is applicable only for very simple interfaces.  When logic becomes more complex, supporting such a UI can turn into a nightmare! </p><br><p>  The root of the problem lies in the fact that building a UI in this way violates the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> , which says: " <em>A class must have only one reason for change</em> ."  If a UI component contains code for display, logic, and data, then it has several reasons for changing.  For example, if you want to change the type of user element that is used to display data, then the changes should not affect the logic.  However, since logic is so closely connected with controls, it will also have to be changed.  This is the so-called ‚Äúcode smell‚Äù ( <a href="http://en.wikipedia.org/wiki/Code_smell">code smell</a> ), which signals that the principle of sole responsibility has been violated. </p><br><p>  Thus, if the form contains code for displaying controls, interface logic (what happens when a button is pressed), and data to display on the screen, you will encounter the following problems: </p><br><ul><li><p>  <strong>Complication of support</strong> <br>  Changes in UI, logic, or data are likely to result in changes in other parts.  Therefore, it is much more difficult to make edits, which makes support difficult. </p><br></li><li><p>  <strong>Deterioration in testability</strong> <br>  The logic and data of the application can be written in such a way that each component can be tested separately.  However, the code associated with the user interface is difficult to unit test, because it often requires user input to run the logic in the UI.  In addition, any visualization often requires an assessment by the person that everything ‚Äúlooks right.‚Äù  <em>Note that there are solutions for automating user interface testing.</em>  <em>However, they only mimic user interaction.</em>  <em>As a rule, they are more difficult to configure and maintain than unit tests, and are most often used for integration testing, since this requires the launch of the entire application</em> . </p><br></li><li>  <strong>Reduced reusability</strong> <br>  If your UI code is mixed with logic and data code, then it becomes much more difficult to reuse. </li></ul><br><h2 id="celi-mv-patternov">  Objectives MV * -patternov </h2><br><p>  Although each of the patterns has quite a few differences, their goals are similar: to separate the UI code (View) from the logic code (Presenter, Controller, ViewModel, etc.) and the data processing code (Model).  This allows each of them to develop independently.  For example, you can change the appearance and style of an application without affecting logic and data. </p><br><p>  In addition, since the logic and data are separate from the display, they can be tested separately.  For simple applications this may not be so important.  For example, if your application is a simple data editor.  However, if you have more complicated interface logic, then the ability to automatically verify that it works correctly will be very valuable. </p><br><h2 id="model-view-controller">  Model-View-Controller </h2><br><p>  One of the very first patterns for separating the presentation from logic and model was the <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593controller">Model-View-Controller</a> (MVC).  This concept was described by <a href="https://en.wikipedia.org/wiki/Trygve_Reenskaug">Trygve Reenskaug</a> . </p><br><blockquote>  <strong>In 1979!</strong>  (I was not even born then). </blockquote><p>  This pattern was designed to write Smalltalk applications.  But in those days, programming was not the same as today.  There was no windows.  There was no graphical user interface.  There were no widget libraries.  If you want a user interface, you need to draw it yourself.  Or if you want to interact with input devices, such as a keyboard. </p><br><p>  But what Trughwe did was quite revolutionary.  Where everyone mixed up the mapping code, logic, and data, he applied a pattern to divide these responsibilities between the individual classes. </p><br><p>  The problem with the MVC pattern is that it is probably one of the most misunderstood patterns in the world.  And I think it's because of the name.  Trygve first called the Model Model-View-Editor, but later settled on Model-View-Controller.  It is clear what Model is (data) and what is View (what I see on the screen).  But what is a controller?  Is the <a href="http://www.martinfowler.com/eaaCatalog/applicationController.html">application controller</a> the same as in the MVC pattern?  ( <em>No, but you can see where the confusion came from</em> ). </p><br><p><img src="https://habrastorage.org/files/ffb/a13/9d5/ffba139d5caf44df94483e459b99cd68.png" alt="mvc_img"></p><br><p>  What are these Model, View and Controller: </p><br><ul><li><p>  <strong>Model</strong> <br>  The model is the data of your application, the logic of their receipt and saving.  This is often a <em>domain model</em> based on a database or on the results from web services.  In some cases, the <em>domain model is</em> well projected onto what you see on the screen.  But sometimes it is necessary to adapt, modify or expand it before use. </p><br></li><li><p>  <strong>View</strong> <br>  View was responsible for displaying UI on the screen.  Without widget libraries, this meant drawing blocks, buttons, input fields, etc., on its own. View can also monitor the model and display data from it. </p><br></li><li>  <strong>Controller</strong> <br>  The controller processes the user actions and then updates the Model or View.  If the user interacts with the application (presses buttons on the keyboard, moves the mouse cursor), the controller receives a notification about these actions and decides what to do with them. </li></ul><br><blockquote>  <em>Note from the translator:</em> <br>  <em>It should be noted that the Controller receives input events directly, and not through the View.</em>  <em>The controller interprets user input from the keyboard or mouse, and sends commands to the model and / or view to make the appropriate changes.</em> </blockquote><p>  I wrote a quick example to illustrate what the controller would look like in a pure MVC implementation.  I implemented it on the usual asp.net (not asp.net MVC), but without using any user controls.  So this is a more traditional asp style.  ( <em>Yes, this is not a very good example, but I hope that it will be a starting point for understanding the true role of the controller</em> ). </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IView _view; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Controller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IView view</span></span></span><span class="hljs-function">)</span></span> { _view = view; HttpRequest request = HttpContext.Current.Request; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.Form[<span class="hljs-string"><span class="hljs-string">"ShowPerson"</span></span>] == <span class="hljs-string"><span class="hljs-string">"1"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(request.Form[<span class="hljs-string"><span class="hljs-string">"Id"</span></span>])) { ShowError(<span class="hljs-string"><span class="hljs-string">"The ID was missing"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ShowPerson(Convert.ToInt32(request.Form[<span class="hljs-string"><span class="hljs-string">"Id"</span></span>])); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { _view.ShowError(s); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository().GetModel(Id); _view.ShowPerson(model); } }</code> </pre> <br><p>  After many years, the programming paradigm has changed somewhat - user controls ( <a href="https://en.wikipedia.org/wiki/Widget_(GUI)">widgets</a> ) have appeared.  Widgets both draw themselves and interpret user input.  The button knows what to do if you click on it.  The input field knows what to do if you enter text in it.  This reduces the need for a controller, and the MVC pattern has become less relevant.  However, since there is still a need to separate application logic from presentation and data, another pattern called Model-View-Presenter (MVP) gained popularity. </p><br><p>  Most examples of the MVC pattern focus on very small components, such as a text box implementation or a button implementation.  When using more modern user interface technologies (Visual Basic 3 is modern compared to Smalltalk 1979), as a rule, there is no need for this pattern.  But it can help if you are developing your widget using a very low level API (for example, Direct X). </p><br><p>  The last couple of years, the MVC pattern has become relevant again, but for a different reason, due to the advent of <a href="https://www.asp.net/mvc">ASP.NET MVC</a> .  The ASP.NET MVC framework does not use the concept of widgets, unlike ASP.NET.  The ASP.NET MVC View is an ASPX control that renders HTML.  And the controller processes the user's actions again, as it accepts HTTP requests.  Based on the <em>http</em> request, it determines what to do (update the Model or display a specific View). </p><br><h2 id="model-view-presenter">  Model-View-Presenter </h2><br><p>  With the development of a visual programming environment and the introduction of widgets that encapsulate the rendering and processing of user input, there is no need to create a separate controller class.  But developers still need to separate logic from presentation, only now at a higher level of abstraction.  Because it turned out that if you create a form from several user elements, it also contains the interface and data logic.  The MVP pattern describes how to separate the UI from the interface logic (what happens when interacting with widgets) and from the data (what data to display on the screen). </p><br><p><img src="https://habrastorage.org/files/0ca/527/44b/0ca52744b20f4d54bee49198af906f57.png" alt="mvp_img"></p><br><ul><li><p>  <strong>Model</strong> <br>  This is the data of your application, the logic of their receipt and storage.  Often it is based on a database or on the results of web services.  In some cases, you will need to adapt, modify or expand it before using it in View. </p><br></li><li><p>  <strong>View</strong> <br>  Usually is a form with widgets.  The user can interact with its elements, but when some event of the widget will affect the logic of the interface, View will send it to the presenter. </p><br></li><li>  <strong>Presenter</strong> <br>  The presenter contains all the user interface logic and is responsible for synchronizing the model and the presentation.  When the presentation notifies the presenter that the user has done something (for example, pressed a button), the presenter decides to update the model and synchronizes all changes between the model and the presentation. </li></ul><br><p>  It is worth noting one important thing that the presenter does not communicate with the presentation directly.  Instead, it communicates through the interface.  Thanks to this, the presenter and the model can be tested separately. </p><br><p>  There are two variants of this pattern: Passive View and Supervising Controller. </p><br><h3 id="passive-view">  Passive view </h3><br><p>  In this MVP view, the view <strong>knows nothing</strong> about the model, but instead provides simple properties for all the information that needs to be displayed on the screen.  The presenter will read information from the model and update the properties in the View. </p><br><p>  This would be an example of PassiveView: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PersonalDataView : UserControl, IPersonalDataView { TextBox _firstNameTextBox; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _firstNameTextBox.Value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _firstNameTextBox.Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><p>  As you can see, you need to write quite a lot of code in both the View and the presenter.  However, this will make the interaction between them more testable. </p><br><h3 id="supervising-controller">  Supervising controller </h3><br><p>  In this embodiment, the MVP view is <strong>aware</strong> of the model and is responsible for associating the data with the display.  This makes the communication between the presenter and the View more concise, but at the expense of the testability of the View-Presenter interaction.  Personally, I hate the fact that this pattern contains the name ‚ÄúController‚Äù.  Because the controller is again not the one in MVC and not the same as the Application Controller. </p><br><p>  This would be an example of representation in the Supervising Controller pattern: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PersonalDataView</span></span> : <span class="hljs-title"><span class="hljs-title">UserControl</span></span>, <span class="hljs-title"><span class="hljs-title">IPersonalDataView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> TextBox _firstNameTextBox; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPersonalData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PersonalData data</span></span></span><span class="hljs-function">)</span></span> { _firstNameTextBox.Value = data.FirstName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePersonalData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PersonalData data</span></span></span><span class="hljs-function">)</span></span> { data.FirstName = _firstNameTextBox.Value; } }</code> </pre> <br><p>  As you can see, this interface is less detailed and places more responsibility on View. </p><br><h2 id="presentation-model">  Presentation Model </h2><br><p>  Martin Fowler describes another approach on his website to achieve a shared responsibility called the <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> .  PresentationModel is a <strong>logical representation of the</strong> user interface, without relying on any visual elements. </p><br><p><img src="https://habrastorage.org/files/fa6/5fd/043/fa65fd04305e4fc6895f44e5d76d4c92.png" alt="presentation_model_img"></p><br><p>  PresentationModel has several responsibilities: </p><br><ol><li><p>  <strong>Contains user interface logic:</strong> <br>  Like the presenter, PresentationModel contains user interface logic.  When you click a button, this event is sent to PresentationModel, which then decides what to do with it. </p><br></li><li><p>  <strong>Provides data from the model for display on the screen.</strong> <br>  PresentationModel can convert data from a model so that it is easily displayed on the screen.  Often the information contained in the model cannot be directly used on the screen.  You may first need to convert the data, complete it, or collect it from several sources.  This is most likely when you do not have full control over the model.  For example, if you receive data from third-party web services or from an existing application database. </p><br></li><li>  <strong>Stores user interface status</strong> <br>  Often, the user interface must store additional information that has nothing to do with the model.  For example, which item is currently selected on the screen?  What validation errors have occurred?  PresentationModel can store this information in properties. </li></ol><br><p>  View can easily extract data from PresentationModel and get all the necessary information to display on the screen.  One of the advantages of this approach is that you can create a logical and fully testable representation of your UI without relying on testing visual elements. </p><br><p>  The Presentation Model pattern does not describe how the View uses data from the model (PresentationModel). </p><br><h2 id="model-view-viewmodel">  Model-View-ViewModel </h2><br><p>  Finally, the Model-View-ViewModel pattern also known as MVVM or just the ViewModel template.  It is very similar to the Presentation Model pattern: </p><br><p><img src="https://habrastorage.org/files/77c/6f6/70e/77c6f670eaa245d191b958a20841fbd0.png" alt="mvvm_img"></p><br><p>  In fact, the only difference is the obvious use of data binding capabilities ( <em>databinding</em> ) in WPF and Silverlight.  Not surprisingly, because <a href="http://blogs.msdn.com/johngossman/archive/2005/10/08/478683.aspx">John Gossman</a> was one of the first to mention this pattern on his blog. </p><br><p>  ViewModel cannot communicate with View directly.  Instead, it presents easily bound properties and methods as <a href="http://msdn.microsoft.com/en-us/library/system.windows.input.icommand.aspx">commands</a> .  View can bind to these properties to get information from the ViewModel and invoke commands on it (methods).  This does not require View to know about the ViewModel.  XAML Databinding uses reflection to bind View and ViewModel.  Thus, you can use any ViewModel for View, which provides the desired properties. </p><br><p>  Some of the things that I really like about this pattern when applied to Silverlight or WPF: </p><br><ul><li><p>  You get a fully tested logical model of your application. </p><br></li><li><p>  Since the ViewModel provides the View with all the necessary information in a convenient way, the view itself can be quite simple.  A designer can experiment with appearance and style in the Expression Blend editor and modify it without affecting the user interface. </p><br></li><li>  And finally, you can avoid writing code for View ( <em>code behind</em> ).  Now this is a cause for disputes among fans of the MVVM pattern.  I personally think that, as a rule, you do not need to write additional code for View, and there will be a better solution.  Yes, sometimes you need to do some tricks ( <em>such as creating attached behaviors</em> ), but they provide good and reusable solutions.  However, I also acknowledge that not everyone likes XAML markup and data binding in XAML.  The ViewModel pattern does not force you to use or avoid <em>code behind</em> .  Do what seems right to you. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I hope that this description of the most common MV * patterns helps you understand their differences. </p><br><blockquote>  Translator's comment: <br><br>  Like the author, I hope that this description will help you understand the similarities and differences between MV * patterns.  Having understood them, it will be easier for you to decide which of the patterns to apply in your application. <br><br>  The main conclusions that can be drawn from the article: <br><ul><li>  The model in all the patterns looks the same and has the same goal - receiving, processing, and saving data. </li><li>  In classic MVC, user input handles the Controller, not the View. </li><li>  Modern operating systems and widget libraries handle user input, so you no longer need the controller from the MVC pattern. </li><li>  The purpose of MV * -patterns: to separate from each other the display of UI, the logic of the interface and the data (their acquisition and processing). </li><li>  Using MV * -pattern in your application, you simplify its support and testing, separating data from the way they are visualized. </li><li>  MVP is quite a universal pattern and will work in many cases (this is my personal opinion).  Which option to use: Passive View or Supervising Controller - you decide.  Be guided by what you need: more control and testability or conciseness and brevity of the code.  Maneuver between tasks and use one or the other approach. </li><li>  If the system has a good implementation of automatic data binding (databinding), then MVVM is your choice. </li><li>  Presentation Model is a good alternative to MVVM, and will be useful where there is no automatic linking.  But you will have to write the binding code yourself (this is a simple but routine code).  There are ideas on how to implement this elegantly, but we'll talk about this in the next <a href="https://habrahabr.ru/company/mobileup/blog/326962/">article</a> . </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>PS Separately, I want to thank my colleague <a href="https://habrahabr.ru/users/jeevuz/" class="user_link">Jeevuz</a> for his help in preparing the translation</em> . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/313538/">https://habr.com/ru/post/313538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313528/index.html">ISO release of the 3CX image for Debian and the virtual PBX 3CX in the Google Cloud infrastructure</a></li>
<li><a href="../313530/index.html">QIWI Security Development Lifecycle</a></li>
<li><a href="../313532/index.html">Duma about the web-API. part two</a></li>
<li><a href="../313534/index.html">IBM Watson will help organize an advertising campaign</a></li>
<li><a href="../313536/index.html">Mikhail Balakin, CityAds: ‚ÄúWe have always been a more technological company than a purely advertising one‚Äù</a></li>
<li><a href="../313540/index.html">Applications from the cloud</a></li>
<li><a href="../313542/index.html">Paul Graham's strategic speech at Defcon 2005: ‚ÄúInequality and Risk‚Äù</a></li>
<li><a href="../313544/index.html">Simple, powerful, forever. Elecard CodecWorks 990 - Live Software Transcoder for AVC and HEVC</a></li>
<li><a href="../313546/index.html">Researchers have created an exploit to get root-access to Android-based smartphones using the Rowhammer vulnerability</a></li>
<li><a href="../313550/index.html">Customize business processes web studio in CRM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>