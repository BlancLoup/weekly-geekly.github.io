<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tree van Emde Boas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all! 

 Today I will tell you about one interesting data structure, about which only a few have heard, and about which very little is writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tree van Emde Boas</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/e978eaa7/923eae07/4b31cbe2/73bda7cd.gif" align="left">  Good day to all! <br><br>  Today I will tell you about one interesting data structure, about which only a few have heard, and about which very little is written rightly in runet, and in the English-language information, in general, it is also sparse.  It was decided to correct the situation and to share with the public in an accessible form this rather exotic data structure. <br><br>  The van Emde Boas tree is an associative array that allows you to store integers in the range [0;  U), where U = 2 <sup>k</sup> , in other words, numbers consisting of no more than k bits.  It would seem, why do we need some other tree, and even allowing you to store only whole numbers, when there are many different balanced binary search trees that allow you to perform insert, delete and other operations for O (log n), where n is the number of elements in the tree ? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main feature of this structure is the execution of all operations during O (log (log (U))) regardless of the number of elements stored in it. <br><br><a name="habracut"></a>  Actually, here is a small list of supported operations: <br><ul><li>  Insert (x) - Insert a number in the tree </li><li>  Remove (x) - Remove a number </li><li>  GetMin (), GetMax () - Finding the minimum and maximum in the tree </li><li>  Find (x) - Search for a number in the tree </li><li>  FindNext (x) - Find the next number after x contained in the tree </li><li>  FindPrevious (x) - Search for the preceding x number </li></ul>  In this case, of course, you can associate any information with each of the numbers, for example, we will store the numbers of some goods in the tree and by the number we will be able to recognize the name of the goods, that is, Find (x) will return not just True / False - whether the product exists or not, and the name of the product with the number x.  We will consider an implementation in which just numbers are stored, without additional information.  To fasten this feature is not difficult. <br><br>  So, let's start building our structure, and we will build it recursively. <br><br>  Let the k-tree store numbers in the interval [0;  2 <sup>k</sup> ), that is, consisting of k bits.  In this case, the number k itself will be a power of two, later it will be clear why we need such a condition.  Then it is obvious how to build a 1-tree, it will only store information about whether the numbers 0 or 1 exist in it or not. <br><br>  Now we build the k-tree.  It will store: <br><ul><li>  2 <sup>k / 2</sup> pieces (k / 2) -trees </li><li>  Auxiliary (k / 2) -tree </li><li>  The minimum and maximum number contained in this tree (if it is not empty) </li></ul>  It becomes unclear why we need all this? <br><br>  Imagine now that we are trying to insert a number x consisting of k bits into a k-tree containing the subtrees children [0..2 <sup>k / 2</sup> - 1].  For example, let x = 93. Let's look at its binary representation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fd/cd1/547/4fdcd15476400f17a112de72edebb2ba.png" alt="image"><br><br>  Divide our number into two equal parts high and low, each in (k / 2) bits.  We recall that our tree contains 2 <sup>k / 2</sup> trees that store numbers from (k / 2) bits.  And now, from all these trees, we take the high ones in a row (that is, children [high]) and recursively insert the number low into it. <br><br>  Thus, we obtain a simple algorithm for inserting and searching in the tree T of the number x, pseudocode: <br><br><pre><code class="python hljs">insert(T, x): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Tk == <span class="hljs-number"><span class="hljs-number">1</span></span>: T.exist[x] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-comment"><span class="hljs-comment">#      1- else: insert(T.children[high(x)], low(x)) find(T, x): if Tk == 1: return T.exist[x] else: return find(T.children[high(x)], low(x))</span></span></code> </pre> <br>  Let us estimate asymptotically the operation time of these functions.  Let T (k) be the number of operations required to insert / search for a number in a k-tree.  To insert / search in a 1-tree, we need O (1) operations, we obtain that T (1) = O (1).  If we consider the k-tree (k&gt; 1), we get that cutting the number using bit operations in it occurs in O (1), after which we perform an insert / search operation for the (k / 2) tree, we get such that T (k) = O (1) + T (k / 2).  The obvious solution of this equation is T (k) = O (log (k)) = O (log (log (U)). It turns out that we have achieved the required asymptotics for insertion and search. <br><br>  Unfortunately, such a structure with only insert, search and delete operations, to put it mildly, is meaningless in most cases, given that in this case it was easier to create a regular array A, in whose x-th element it is stored, does the number x exist in our set or not. <br><br>  It's time to fix the situation!  To do this, we implement, say, the operation FindNext (x).  Recall that this operation looks for the minimum number q contained in our tree, such that q&gt; = x. <br><br>  To do this, a little complement our structure.  Let me remind you that at the very beginning I said that we would keep in a k-tree not only 2 <sup>k / 2</sup> pieces (k / 2) -trees, but at least in it, a maximum and one more auxiliary (k / 2) -tree, let's call it aux (from English <i>auxiliary</i> - auxiliary).  What will it help us so much? <br><br>  Take a k-tree with its subtrees children [0..2 <sup>k / 2</sup> - 1] and the aux auxiliary tree.  In aux, we will store all such numbers p such that the children [p] tree is not empty, that is, it contains at least one number.  Accordingly, if the p-th tree of children [p] is empty, then the number p is not contained in aux. <br><br>  Also, we will make a minor modification: for any tree T we will not store the minimum number in its subtrees T.children, we will simply write it in the variable T.min.  When we have to insert into the insert query the number x less than T.min, then since T.min is not contained in our subtrees, we insert it into the subtrees, and then assign T.min = x. <br><br>  Note that now we will not consider separately the case of k = 1, since we have the variables T.min and T.max.  And if, say, a 1-tree contained the numbers 0 and 1, then it will simply have T.min = 0, and T.max = 1. If, for example, it contained only the number 1, then it will have T.min = T.max = 1. <br><br>  Now consider the algorithm for inserting into the tree, taking into account all of the above: <br><br><pre> <code class="python hljs">insert(T, x): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> T.is_empty(): T.min = T.max = x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; T.min: swap(x, T.min) <span class="hljs-comment"><span class="hljs-comment">#      ,     if x &gt; T.max: T.max = x if Tk != 1: #   1-,      -  if T.children[high(x)].is_empty(): insert(T.aux, high(x)) #  ,   insert   O(1) insert(T.children[high(x)], low(x))</span></span></code> </pre><br>  The asymptotic behavior of its operation will still be O (log (log (U))), it is evaluated similarly to the previous version of the insert function.  It only needs to be noted that if we insert into aux, then the insert following it will work beyond O (1), since this subtree will be empty. <br><br>  The search function will change a bit: <br><br><pre> <code class="python hljs">find(T, x): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> T.is_empty(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> T.min == x <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> T.max == x: <span class="hljs-comment"><span class="hljs-comment">#  T.max == x      return True else: return find(T.children[high(x)], low(x))</span></span></code> </pre><br><br>  Now consider the function FindNext (x), here is its pseudocode with comments: <br><br><pre> <code class="python hljs">find_next(T, x): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> T.is_empty() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> x &gt; T.max: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment">#    x      if x &lt;= T.min: return T.min #    ,     if Tk == 1: #   1- if T.max == x: return T.max else: return None if not T.children[high(x)].is_empty() and low(x) &lt;= T.children[high(x)].max: # ,  ,   ,   high(x) return merge(high(x), find_next(T.children[high(x)], low(x))) else: #      ,    next_high = find_next(aux, high(x) + 1) #     if next_high != None: return merge(next_high, T.children[next_high].min) #  ,    return None merge(high, low): return   (k / 2)-  high  low</span></span></code> </pre><br>  The asymptotic behavior of her work is obviously O (log (log (U)). <br><br>  I think the writing of such functions as Remove, FindPrevious and others should not cause much difficulty, since they are all written in the same way, therefore I will omit their pseudocode. <br><br><h4>  Application </h4><br>  In addition to the obvious use of the tree van Emde Boas, you can come up with many unexpected, for example: <br><ul><li><h5>  Sorting a sequence of N numbers for O (n * log (log (U))) </h5>  Indeed, we insert all our numbers into the tree.  Then we take the minimum number in the tree and sequentially perform the operation x = FindNext (x + 1), as a result of which all our numbers will be in the sorted order in the variable x.  Note that you can write different implementations of this sort, including those that also remove duplicate elements.  The main advantage of this sorting is that, asymptotically, this algorithm overtakes even digital sorting. <br><br></li><li><h5>  Finding the longest increasing subsequence for O (n * log (log (U))) </h5>  Some have probably heard of such a task as finding the CWP and its solution in O (n * log (n)).  For those who have not heard, can read about it <a href="http://e-maxx.ru/algo/longest_increasing_subseq_log">here</a> .  The main idea of ‚Äã‚Äãoptimization is that a binary search in an array can be replaced by the FindPrevious operation in the van Emde Boas tree. <br><br></li><li><h5>  Dijkstra's algorithm for O (E * log (log (U))) </h5>  For those who are not familiar with the Dijkstra algorithm for finding the shortest path in a weighted graph, I suggest that you read <a href="http://e-maxx.ru/algo/dijkstra">this</a> and <a href="http://e-maxx.ru/algo/dijkstra_sparse">this</a> article.  The implementation of the Dijkstra algorithm using a heap is known to work for O (E * log (V)), where V is the number of vertices and E is the number of edges.  But if instead of a heap, we apply the already known data structure to all of us, then we obtain the asymptotics O (E * log (log (U))), which is good news. <br><br></li><li>  And many, many tasks, the number of which is limited only by your imagination :) </li></ul><br>  The minus of all these algorithms is that for too large U the van Emde Boas tree will occupy a larger amount of memory (a rough estimate is O (U)), which, however, can be partially avoided by creating the necessary subtrees "lazily", that is only when we need them. <br><br><h4>  Instead of conclusion </h4><br>  <a href="http://pastebin.com/zv8F88MS">Here</a> is my implementation of the van Emde Boas tree in C ++.  She does not claim perfection, but should do her job.  Additions and comments are welcome. <br><br>  Thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/125499/">https://habr.com/ru/post/125499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125491/index.html">Some features of the programming language development environment tmaplatform</a></li>
<li><a href="../125494/index.html">Logitech Revue with Android Honeycomb beta for $ 100</a></li>
<li><a href="../125495/index.html">UAV WASP has learned to intercept GSM-traffic</a></li>
<li><a href="../125496/index.html">Intellectualization of dome dome camera: automatic patrol, target selection and tracking</a></li>
<li><a href="../125497/index.html">How to do everything and forget nothing: ToDo for companies, workgroups and at home</a></li>
<li><a href="../125500/index.html">Review of the salaries of "mobile" developers</a></li>
<li><a href="../125501/index.html">Video: Igor Ashmanov about the crisis, crooks and snails</a></li>
<li><a href="../125502/index.html">Import photos from Picasa and Flickr into albums VKontakte</a></li>
<li><a href="../125503/index.html">Explosive Friday and the Social App per Day</a></li>
<li><a href="../125505/index.html">Local Area Network LED (800 Mbps)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>