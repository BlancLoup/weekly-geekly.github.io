<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Access iFrame content from another domain</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I want to talk about how we in our project indexisto.com made an analogue tool Google Webmaster Marker. Let me remind you that Marker is a tool ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Access iFrame content from another domain</h1><div class="post__text post__text-html js-mediator-article">  Today I want to talk about how we in our project <a href="http://indexisto.com/">indexisto.com</a> made an analogue tool Google Webmaster Marker.  Let me remind you that Marker is a tool in the Google Webmaster office that allows you to annotate your Open Graph pages with tags.  To do this, you simply select with a mouse a piece of text on the page and indicate that this is a title, and this is a rating.  Your page is loaded into the Iframe in the webmaster's office. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce1/423/624/ce1423624cf3691cf9a7299203b71d6d.png"><br><br>  Now Google, having met a similar page on your site, already knows what content is published on it, and how beautiful it is to parse it into substance (article, product, video ..) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We needed similar functionality.  The task seemed simple and client-side exclusively.  However, in practice, the solution lies at the interface between the client side and the serverside (‚Äúpure‚Äù JS programmers may not know anything about various proxy servers and go to the projectile for a very long time).  However, I did not find an article on the Internet that would describe all the technology from start to finish.  I would also like to say thanks to the <a href="https://habrahabr.ru/users/belove/" class="user_link">BeLove</a> user and our security personnel for their help. <br><br><a name="habracut"></a><br><br>  In our case, we wanted the webmaster to conveniently (with the mouse) get the xPath value to specific elements on his page. <br><br><h4>  Iframe "Same Origin" </h4><br>  And so in our admin a person should enter the URL of the page of his site, we will display it in iFrame, a person will click the mouse where necessary, we will get the desired xPath.  Everything would be OK, but we do not have access to the content of the page from another domain loaded into the iframe in our admin panel (our domain), due to the security policy of the browser. <br><br><h4>  CORS - Cross origin resource sharing </h4><br>  Some people advised me to use CORS.  Trendy technology that solves many problems with access to content from another domain in the browser and allows you to bypass the same origin policy restrictions. <br>  A site that wants to give access to its content on the pages of another domain simply writes the http header: <br><pre><code class="bash hljs">Access-Control-Allow-Origin: http://example.com</code> </pre> <br>  And in the header of the http request coming from the page of another domain from the browser should be the field of origin: <br><pre> <code class="bash hljs">Origin: www.mysupersite.com</code> </pre><br>  it is clear that the origin field for the request is added by the browser itself.  Let's add an article on Habr√© and see that modern browsers add Origin even to the request for the same domain: <br><img src="https://habrastorage.org/getpro/habr/post_images/c5b/a81/abc/c5ba81abcbbce27a93107dd12b08ecc9.png"><br><br>  but: <br><ol><li>  the browser <i>does not put origin</i> in the request header for the page loaded in the iframe (can anyone explain why?) </li><li>  we do not want to ask webmasters to register the header <b>Access-Control-Allow-Origin</b> </li></ol><br><br><h4>  Iframe sandbox </h4><br>  Another fashionable technology.  <b>Sandbox</b> is an attribute of the Iframe tag.  As one of the values ‚Äã‚Äãof this attribute, you can set the value of <b>allow-same-origin</b> .  Before I started digging this topic, I did not know what exactly this attribute does, but it sounded very tempting.  However, the sandbox attribute simply restricts what the page loaded in the iframe can do and has nothing to do with the problem of access from the parent document to the contents of the frame. <br><br>  Specifically, the value of <b>allow-same-origin</b> (or rather its absence) just says that the iframe should always be regarded as loaded from someone else‚Äôs domain (for example, you cannot send an AJAX request to the domain of the parent document from such a frame) <br><br><h4>  Let's see how Google does </h4><br>  Time to take care of how big brother has done <br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/05f/625/b5c05f62508d11597cae2d5eb9c2cd6e.png"><br><br>  Pay attention to the src attribute of the iframe element: <b><code>src="https://wmthighlighter.googleusercontent.com/webmasters/data-highlighter/RenderFrame/007....."</code></b> - our page is loaded into the admin area from the Google domain.  Further, it is even more severe: even scripts and images in the source document are run through a proxy.  All src, href ... are replaced in html with proxied ones.  Like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df6/557/7fc/df65577fc3d46ccf529bf0c62b5b729e.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/854/395/29e85439516f7e5243251696d67e8535.png"><br><br>  All resources that your page uses are also stored on Google proxy servers.  For example, our <a href="http://indexisto.com/sites/all/themes/indexisto/logo.png">logo on the proxy server Google</a> . <br><br><h4>  CGIProxy? </h4><br>  It immediately seemed that in order to do the same you need to raise a full-fledged proxy like <a href="http://www.jmarshall.com/tools/cgiproxy/">CGIProxy</a> .  This proxy server does about the same thing as Google‚Äôs wmthighlighter.googleusercontent.com <br><blockquote>  Visit the script's URL to start a browsing session.  Once you've gotten through the proxy page.  You can go through your bookmarks through the proxy as they did the first time. </blockquote><br><br><h4>  Your proxy! </h4><br>  However, if you narrow down the task, it is much easier to write a simple proxy yourself.  The fact is that doing so does Google, driving all the content through a proxy page is not necessary.  We just need to give html of any page from our domain, and resources can be uploaded from the original domain.  Https we have so far discarded. <br>  The task of super performance or convenience settings is not worth it, and it can be done quickly and on anything, from node.js to php.  We wrote a servlet in Java. <br><br><h4>  Downloading the page </h4><br>  What should the proxy servlet do?  Through the get parameter, we get the url of the page you want to load, then download the page. <br><br>  Be sure to determine the page encoding (via http response or charset in html) - our proxy should respond in the same encoding as the page we downloaded.  We will also define the Content-Type just in case, although it is clear that we get the page in text / html and give it the same way. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String url = request.getParameter(<span class="hljs-string"><span class="hljs-string">"url"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpGet requestApache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpGet(url); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpClient httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpResponse responseApache = httpClient.execute(requestApache); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpEntity entity = responseApache.getEntity(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String encoding = EntityUtils.getContentCharSet( entity ); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String mime = EntityUtils.getContentMimeType(entity); String responseText = IOUtils.toString(entity.getContent(), encoding);</code> </pre><br>  <i>* For those who like to evaluate someone else's code: in our team we all have the same formatting options for the eclicpse code, and while saving the file, Eclipse itself adds to all final variables if they do not change anywhere else.</i>  <i>Which by the way is quite convenient in the end.</i> <br><br><h4>  Change relative URLs to absolute in the page code </h4><br>  It is necessary to go through all the attributes with src and href in the page (paths of style files, images), and replace the relative URLs with absolute ones.  Otherwise, the page will try to download images from some folders on our proxy, which we naturally do not have.  In any language there are ready-made classes or you can find code snippets for this case on stackoverflow: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> URI uri = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URI(url); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String host = uri.getHost(); responseText = replaceRelativeLinks(host,responseText);</code> </pre><br><br><h4>  We send html </h4><br>  That's it, the proxy servlet is ready.  We send the answer, having set the necessary coding and mime. <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletResponse response, String responseText, String encoding, String mime)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ response.setContentType(mime); response.setCharacterEncoding(encoding); response.setStatus(HttpServletResponse.SC_OK); response.getWriter().print(responseText ); response.flushBuffer(); }</code> </pre><br><br><h4>  Deploy and test </h4><br>  Deploy our proxy servlet on the same address as adminpanel.indexisto.com admin <a href="http://adminpanel.indexisto.com/">panel</a> , <a href="http://adminpanel.indexisto.com/">load the</a> proxy webmaster site into our iframe page and all cross-domain problems disappear. <br>  Our proxy works at <br><pre> <code class="bash hljs">http://adminpanel.indexisto.com/highlighter?url=http://habrahabr.ru</code> </pre><br>  - that's how Habr will boot from our domain.  We give this address in the iframe and try to get access to the DOM tree of the habr through JS in the admin panel - everything works.  CSRF naturally does not pass as the page is loaded from our proxy which does not have cookies. <br><br><h4>  SSRF Problem </h4><br>  Let's load into our iframe site with the address ‚Äúlocalhost‚Äù - opa, here is the start page of our nginx.  Let's try some internal (not visible outside) resource on the same network as our proxy server.  For example secured_crm.indexisto.com - everything is in place. <br>  Of course, we are trying to ban these things in our proxy, in case someone tries to proxify localhost, we exit without returning anything: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url.contains(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>)||url.contains(<span class="hljs-string"><span class="hljs-string">"127"</span></span>)||url.contains(<span class="hljs-string"><span class="hljs-string">"highlighter"</span></span>)||url.contains(<span class="hljs-string"><span class="hljs-string">"file"</span></span>)) { LOG.debug(<span class="hljs-string"><span class="hljs-string">"Trying to get local resource. Url = "</span></span> + url); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  but we obviously will not list all the resources of the network here.  So you need to make a proxy in a completely isolated environment so that the machine can not see anything except the Internet, itself and our proxy.  Select the machine, set up and start our servlet there. <br><br><h4>  XSS Problem </h4><br>  Let's load into our iframe our page on which we will write: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">alert(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'xss'</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Alert pops up.  Sadly  This can be bypassed with the iframe <b>sandbox allow-scripts</b> attribute, but what about old browsers that do not really understand this attribute?  You can only steal your cookies, but you can‚Äôt leave it alone anyway. <br>  We carry out the servlet not only on a separate machine, but also make it a separate subdomain <b>highlighter.indexisto.com</b> . <br><br>  Sailed, we broke our own solution bypassing cross-domain restrictions.  Now we can‚Äôt reach the iframe content again. <br><br><h4>  Interesting idea. </h4><br>  Continuing to reschedule the decision from google, I opened our proxy page in a separate window <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46a/189/f46/46a189f46a97d0e250f88f9db5edf045.png"><br><br>  and drew attention to a strange error in the console. <br><pre> <code class="bash hljs">CrossPageChannel: Can<span class="hljs-string"><span class="hljs-string">'t connect, peer window-object not set.</span></span></code> </pre><br>  It became clear that everything is organized more complicated than simply loading the page in the iframe from your domain.  Pages communicate with each other.  Respectively we move towards <b>window.postMessage</b> <br><br><h4>  Post Message </h4><br>  To force our script to embed a webmaster into its page that would ensure the selection of page elements with a mouse, and then send xPath of these elements to our parent document via <b>postMessage</b> was not humane.  However, no one bothers our proxy to inject any scripts on the page loaded into iFrame. <br>  We save all the necessary scripts to a file, and paste them before the closing <b>body</b> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> positionToInsert = responseText.indexOf(<span class="hljs-string"><span class="hljs-string">"&lt;/body&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> InputStream inputStream = getServletContext().getResourceAsStream(<span class="hljs-string"><span class="hljs-string">"/WEB-INF/inject.js"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StringWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringWriter(); IOUtils.copy(inputStream, writer); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String jsToInsert = writer.toString(); responseText = responseText.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, positionToInsert) + jsToInsert + responseText.substring(positionToInsert, responseText.length());</code> </pre><br>  For the test, we insert an <b>alert</b> - everything works. <br><br><h4>  JS part - we highlight the house element under the mouse and get xpath </h4><br>  Okay, let's go to JS itself, which we pasted on the webmaster's page. <br>  We need to highlight the dom elements over which a person drives a mouse.  It is better to do this with the help of shadow, since then the element will not shift, and the whole page will jump.  We hang onmouseover on the body and look at the target of the event.  In the same handler, I calculate the element's xpath.  It is better to calculate the xPath element per click, but I did not notice any brakes in this implementation. <br><pre> <code class="javascript hljs">elmFrame.contentWindow.document.body.onmouseover= <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">)</span></span>{ ev.target.style.boxShadow = <span class="hljs-string"><span class="hljs-string">"0px 0px 5px red"</span></span>; curXpath = getXPathFromElement(ev.target); }</code> </pre><br>  I don‚Äôt include here an implementation of getting the xPath of a DOM element.  There are many snippets of how to do this.  These snippets can be modified to suit your needs, for example, you need only tags in xpath.  Or you need an id if they are and classes if there is no id - everyone has their own requirements. <br><br>  Here is an example of a hacked Habr's main page with an embedded script: <br>  <a href="http%253A%252F%252Fhabrahabr.ru%26expires%3D1390468360">http://highlighter.indexisto.com/?md5=6ec7rdHxUfRkrFy55jrJQA==&amp;url=http%3A%2F%2Fhabrahabr.ru&amp;expires=1390468360</a> <br><br><h4>  JS part - we process click </h4><br>  A person‚Äôs click on the page in the iframe is immediately ‚Äúextinguished‚Äù (no link will be followed in the iframe).  And also we send the string obtained by xPath to the parent window (we saved it at the stage of driving the mouse over the element) <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.parent.postMessage( curXpath, <span class="hljs-string"><span class="hljs-string">"*"</span></span>); ev.preventDefault(); ev.stopPropagation(); }</code> </pre><br><br><h4>  Profit! </h4><br>  That's all, now in our admin webmaster can be much easier to quickly get xpath paths to the elements on your pages. <br><img src="http://habrastorage.org/getpro/habr/post_images/f23/3e0/bea/f233e0beafc8c2135f57aa040d01d9dd.png"><br><br><h4>  Add more security issues </h4><br>  Okay, everything worked for us, but there is a moment with the fact that our proxy looks into the world completely unprotected.  Anyone can log anything. <br><br>  We put in front of the nginx proxy, it listens to port 80, we remove the proxy itself to another port.  All other ports except 80 are closed from the outside world. <br><br>  Now we will do so that the proxy only works through the admin panel.  At the moment when the webmaster enters the URL of your site, we quickly run to the server where we generate the md5 hash from the current TimeStamp + 1 hour, the URL itself and the super secret when: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String md5Me = timeStampExpires + urlEncoded + <span class="hljs-string"><span class="hljs-string">"SUPERSECRET"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MessageDigest md = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"MD5"</span></span>); md.reset(); md.update(md5Me.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>)); String code = Base64.encodeBase64String(md.digest()); code = code.replaceAll(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span>); code = code.replaceAll(<span class="hljs-string"><span class="hljs-string">"\\+"</span></span>,<span class="hljs-string"><span class="hljs-string">"-"</span></span>);</code> </pre><br>  Also note that in the code we get the md5 string not as the usual hex, but in base64 encoding, plus in the resulting md5 we make strange replacements of the slash and plus characters for underscores and dashes. <br>  The fact is that ngnix uses base64 Filename Safe Alphabet <a href="http://tools.ietf.org/html/rfc3548">tools.ietf.org/html/rfc3548#page-6</a> <br>  And Java gives the canonical base64. <br><br>  Having received a response from the server with security md5 in our admin panel, we are trying to load this url into the iframe: <br>  <a href="http%253A%252F%252Fhabrahabr.ru%26expires%3D1389791582">highlighter.indexisto.com/?md5=Dr4u2Yeb3NrBQLgyDAFrHg==&amp;url=http%3A%2F%2Fhabrahabr.ru&amp;expires=1389791582</a> <br><br>  Now we configure the nginx <a href="http://wiki.nginx.org/HttpSecureLinkModule">HttpSecureLinkModule</a> module.  This module checks the md5 of all the parameters that came to it (the same secret key as in the admin servlet is registered in the module), checks whether the link has been pro-parked, and only in this case sends a request to our proxy servlet. <br><br>  Now no one can use our proxy from the admin panel, nor can she insert a picture that has been proxied to our server somewhere ‚Äî she will die in an hour anyway. <br><br><h5>  That's all folks! </h5><br>  Google in its marker tool naturally went much further.  In order to clearly identify an element on a page, you need to mark the same element (for example, the article title) on several pages of the same type so that you can more accurately build xpath and discard different ‚Äúpost-2334‚Äù type ids that obviously work only on one page .  In our admin, while xpath must be corrected by hand to get an acceptable result </div><p>Source: <a href="https://habr.com/ru/post/210050/">https://habr.com/ru/post/210050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210040/index.html">Top 10 problems online stores</a></li>
<li><a href="../210042/index.html">"Hello everyone in this chat" - my favorite response to the mass newsletter</a></li>
<li><a href="../210044/index.html">Engineer work - different unusual stories</a></li>
<li><a href="../210046/index.html">Mobile development for the media. The basics you need to know</a></li>
<li><a href="../210048/index.html">Protection system for remote banking services and electronic payments</a></li>
<li><a href="../210056/index.html">Once again about Intel contests. Memo to future participants</a></li>
<li><a href="../210058/index.html">Web Components - the future of the Web</a></li>
<li><a href="../210060/index.html">Treating tree structures and unified AST</a></li>
<li><a href="../210062/index.html">Smart cards for the smallest</a></li>
<li><a href="../210068/index.html">MySQL engine in 5 minutes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>