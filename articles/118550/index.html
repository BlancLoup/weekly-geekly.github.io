<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dependency Reversal and Generating Design Patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="annotation 
 This is the third article, enlightened by generating design patterns and related issues. Here we look at the favorite techniques for crea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dependency Reversal and Generating Design Patterns</h1><div class="post__text post__text-html js-mediator-article"><h1>  annotation </h1><br>  This is the third article, enlightened by generating design patterns and related issues.  Here we look at the favorite techniques for creating objects: factories, <s>factories</s> , abstract factories, builders, prototypes, multitons, deferred initialization, and also touch on a little pimpl idioms or a ‚Äúbridge‚Äù pattern.  The use of singletons was discussed in detail in the <a href="http://habrahabr.ru/blogs/cpp/116577/">first [1]</a> and <a href="http://habrahabr.ru/blogs/cpp/118368/">second [2]</a> articles, however, as you will see later, singletons are often used in conjunction with other design patterns. <br><a name="habracut"></a><br><br><h1>  Introduction </h1><br>  Many probably have heard, read, or even used <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">generative design patterns [4]</a> .  This article will be about them.  However, the emphasis here will be on other things.  Of course, this article can be used as a reference for generating patterns, or as an introduction to them.  But my final goal is somewhat in a different plane, namely, in the plane of using these patterns in real code. <br><br>  It is no secret that many, having learned about patterns, try to start using them everywhere.  However, not all so simple.  Many articles on this topic do not pay enough attention to their use in the code.  And when they begin to fasten the templates to the code, then something so inconceivable arises that neither to say in a fairy tale nor to describe with a pen.  I have seen various incarnations of these ideas, sometimes you involuntarily ask yourself: what was the author smoking?  Take, for example, a factory or <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">factory method from Wikipedia [3]</a> .  I will not give all the code, I will give only use: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// An array of creators Creator* creators[count] = { new ConcreteCreatorA(), new ConcreteCreatorB() }; // Iterate over creators and create products for (size_t i = 0; i &lt; count; i++) { Product* product = creators[i]-&gt;factoryMethod(); cout &lt;&lt; product-&gt;getName() &lt;&lt; endl; delete product; } for (size_t i = 0; i &lt; count; i++) delete creators[i];</span></span></code> </pre> <br>  If you ask yourself, and how to use it in real life, then immediately the following observations arise: <br><ol><li>  How do I know that I need to use exactly the 0th or 1st element?  They are no different. </li><li>  Suppose you need to create some elements in a loop.  Where do I get the knowledge of where these factories are located?  If I initialize the factory right there, then why do I need them at all?  You can simply create an object and call a specific method or a stand-alone function that does everything. </li><li>  It is assumed that objects are created by the operator new.  Here the question immediately arises with the processing of exceptional situations and the lifetime of the object. </li></ol><br>  Anyway, and this example is just some illustration that contains many flaws.  In real life, this is not used. <br><br>  ‚ÄúWhat are they using then?‚Äù, The attentive reader will ask.  Below is the use code.  This list does not claim to be complete: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  ,    Object* o = Factory::getInstance().createObject("object_name"); //      Configuration* conf = Configuration::getCurrentConfiguration(); Object* o = Factory::getInstance().createObject(conf-&gt;getObjectNameToCreate());</span></span></code> </pre><br>  It is worth noting that factories in ‚Äúreal life‚Äù are usually singletones.  You may also notice that when creating objects, the ears of the used templates stick out.  During the subsequent refactoring, this will be felt from the unpleasant side.  Often used approach when returning objects to the pointer.  So taught in all books, so the code continues to be written.  If everything is clear with the createObject method - you need to call delete at the end, what to do with the configuration?  Is it singleton or not?  If yes, then nothing needs to be done.  And if not?  Questions arise again with a lifetime.  We should not forget about the correct handling of exceptions either, and such code with exception handling causes problems associated with cleaning up resources. <br><br>  Whatever one may say, but I would like to have a unified approach, which would run like a red thread through the generated objects and did not differ in the various ways of creation, of which there are many.  In order to put this into practice, we will use the powerful <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">principle of reversing dependencies [7]</a> .  Its essence is that some kind of abstraction is introduced, an interface.  Next, using and using the code is connected through the entered interface using, for example, <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D1%258F">call control [8]</a> .  This allows code that wants to create objects to abstract from the specifics of creating a class and simply use a dedicated interface.  All care falls on the shoulders of the functional that implements this interface.  The article discusses in detail how to create objects using almost all known generating design patterns, and also gives an example when several generating patterns are used to create instances at the same time.  An example of a singleton is described in detail in a <a href="http://habrahabr.ru/blogs/cpp/118368/">previous article [2]</a> ; in this article, it will only be used together in other templates. <br><br><h1>  Infrastructure </h1><br>  An object and the infrastructure around it are described in detail in the <a href="http://habrahabr.ru/blogs/cpp/118368/">second article [2]</a> .  Here I will only give the code that will be used in the further narrative.  For more details, see <a href="http://habrahabr.ru/blogs/cpp/118368/">previous article [2]</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">An</span></span></span><span class="hljs-class">;</span></span> An() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; An(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> An&lt;U&gt;&amp; a) : data(a.data) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; An(An&lt;U&gt;&amp;&amp; a) : data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a.data)) {} T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get0(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ data.reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data) reinit(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reinit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ anFill(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create&lt;T&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-function">U&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ U* u = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> U; data.reset(u); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *u; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u)</span></span></span><span class="hljs-function"> </span></span>{ anProduce(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, u); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> An&lt;U&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ data.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> U(*a.data)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;An*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;init(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.get(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; data; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anFill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;T&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot find implementation for interface: "</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).name()); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnAutoCreate</span></span></span><span class="hljs-class"> :</span></span> An&lt;T&gt; { AnAutoCreate() { create(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; An&lt;T&gt; anSingle() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single&lt;AnAutoCreate&lt;T&gt;&gt;(); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PROTO_IFACE(D_iface, D_an) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; void anFill&lt;D_iface&gt;(An&lt;D_iface&gt;&amp; D_an) #define DECLARE_IMPL(D_iface) \ PROTO_IFACE(D_iface, a); #define BIND_TO_IMPL(D_iface, D_impl) \ PROTO_IFACE(D_iface, a) { a.create&lt;D_impl&gt;(); } #define BIND_TO_SELF(D_impl) \ BIND_TO_IMPL(D_impl, D_impl) #define BIND_TO_IMPL_SINGLE(D_iface, D_impl) \ PROTO_IFACE(D_iface, a) { a = anSingle&lt;D_impl&gt;(); } #define BIND_TO_SELF_SINGLE(D_impl) \ BIND_TO_IMPL_SINGLE(D_impl, D_impl) #define BIND_TO_IFACE(D_iface, D_ifaceFrom) \ PROTO_IFACE(D_iface, a) { anFill&lt;D_ifaceFrom&gt;(a); } #define BIND_TO_PROTOTYPE(D_iface, D_prototype) \ PROTO_IFACE(D_iface, a) { a.copy(anSingle&lt;D_prototype&gt;()); }</span></span></span></span></code> </pre><br>  In brief, the An object is a ‚Äúsmart‚Äù pointer, which is automatically filled when it is accessed using the anFill function.  We will overload this function for the interface we need.  To create an object based on input data, the anProduce function is used, the use of which will be described in the section on factories. <br><br><h1>  Bridge pattern </h1><br>  Let's start with the simplest and most common case: hide the object data, leaving only the interface to use.  Thus, when changing data, for example, adding one field to a class, there is no need to recompile everything that uses this class.  This design pattern is called a ‚Äúbridge‚Äù, also referred to as a pimpl idiom.  This approach is often used to separate the interface from the implementation. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header file //     struct IObject { virtual ~IObject() {} }; struct IFruit : IObject { virtual std::string getName() = 0; }; //      IFruit DECLARE_IMPL(IFruit) // cpp file struct Orange : IFruit { virtual std::string getName() { return "Orange"; } }; //   IFruit   Orange BIND_TO_IMPL(IFruit, Orange)</span></span></code> </pre><br>  First of all, create an IObject class so that in each abstract class we don‚Äôt write a virtual destructor.  Then just inherit each interface (abstract class) from our IObject.  The iFruit interface contains a single getName () function to illustrate the approach.  The entire declaration takes place in the header file.  The concrete implementation is already recorded in the cpp file.  Here we define our getName () function and then associate our interface with the implementation.  When changing the class of Orange, it is enough to recompile one file. <br><br>  Let's look at using: <br><br><pre> <code class="cpp hljs">An&lt;IFruit&gt; f; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Name: "</span></span> &lt;&lt; f-&gt;getName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output Name: Orange</span></span></code> </pre><br>  Here we simply create an An object, and then at initial access an object is created with the desired implementation, which is described in the cpp file.  Lifetime is controlled automatically, i.e.  upon exiting the function, the object is automatically destroyed. <br><br><h1>  Template "factory" </h1><br>  Now let's talk about the most common pattern: factory method or just factory.  Here I will not give examples of how the factory is usually used.  You can read this, for example, on <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia</a> .  I am going to show a slightly different use of this design pattern. <br><br>  The difference in use is that for the user it remains invisible in most cases.  But this does not mean that there will be any restrictions.  The article will demonstrate the flexibility and strength of the proposed approach. <br><br>  To do this, we set the task: it is necessary to create different objects depending on the input parameters of the function.  A generating function, generally speaking, can have several parameters.  However, without limiting the generality, we can assume that any function with several parameters can be reduced to a function with a single parameter, where the structure with the necessary input data is used as an argument.  Therefore, we will use the function with one parameter everywhere and everywhere to simplify interfaces and understanding.  Those interested can use the variadic templates of the new standard c ++ 0x, although the compilers msvc and icc, unfortunately, do not support them yet. <br><br>  So, we are faced with the task of creating an implementation of the IFruit interface, depending on the type of FruitType fruit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FruitType { FT_ORANGE, FT_APPLE };</code> </pre><br>  To do this, we need an additional implementation for Apple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cpp file struct Apple : IFruit { virtual std::string getName() { return "Apple"; } };</span></span></code> </pre><br>  Create a generating function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anProduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IFruit&gt;&amp; a, FruitType type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FT_ORANGE: a.create&lt;Orange&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FT_APPLE: a.create&lt;Apple&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Unknown fruit type"</span></span>); } }</code> </pre><br>  This function is automatically called when you call the An :: produce method, as shown below: <br><br><pre> <code class="cpp hljs">An&lt;IFruit&gt; f; f.produce(FT_ORANGE); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; f-&gt;getName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f.produce(FT_APPLE); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; f-&gt;getName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output: Orange Apple</span></span></code> </pre><br>  It is often useful to create objects not depending on the time of execution;  at any given time we clearly know what object we want to create.  Then you can use other, more simple ways to create.  The first way is to create intermediate objects - tags: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       struct OrangeTag {}; struct AppleTag {}; //     cpp  void anProduce(An&lt;IFruit&gt;&amp; a, OrangeTag) { a.create&lt;Orange&gt;(); } void anProduce(An&lt;IFruit&gt;&amp; a, AppleTag) { a.create&lt;Apple&gt;(); } //  An&lt;IFruit&gt; f; f.produce(AppleTag()); std::cout &lt;&lt; f-&gt;getName() &lt;&lt; std::endl; f.produce(OrangeTag()); std::cout &lt;&lt; f-&gt;getName() &lt;&lt; std::endl; // output Apple Orange</span></span></code> </pre><br>  The second option is to create special interfaces and use the ‚Äúbridge‚Äù template: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header file struct IOrange : IFruit {}; DECLARE_IMPL(IOrange) struct IApple : IFruit {}; DECLARE_IMPL(IApple) // cpp file struct Orange : IOrange { virtual std::string getName() { return "Orange"; } }; BIND_TO_IMPL(IOrange, Orange); struct Apple : IApple { virtual std::string getName() { return "Apple"; } }; BIND_TO_IMPL(IApple, Apple); //  An&lt;IOrange&gt; o; std::cout &lt;&lt; "Name: " &lt;&lt; o-&gt;getName() &lt;&lt; std::endl; An&lt;IApple&gt; a; std::cout &lt;&lt; "Name: " &lt;&lt; a-&gt;getName() &lt;&lt; std::endl; // output Name: Orange Name: Apple</span></span></code> </pre><br><br><h1>  Builder pattern </h1><br>  Many (including me) are wondering why a builder is needed when there is a factory?  Indeed, in essence, these are similar templates.  How do they differ then? <br><br>  I clearly distinguish them in the following simple way: the factory is used to create an instance, the type of which depends on the parameters being transferred.  While the builder is used when the type is known, you only need to fill in the fields of the object in different ways.  Those.  the factory creates different types, for the builder the same type is used, but with different content.  Now let's take an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header file struct Fruit { Fruit(const std::string&amp; name) : m_name(name) {} std::string getName() { return m_name; } private: std::string m_name; }; // cpp file struct Orange : Fruit { Orange() : Fruit("Orange") {} }; struct Apple : Fruit { Apple() : Fruit("Apple") {} }; enum FruitType { FT_ORANGE, FT_APPLE }; void anProduce(An&lt;Fruit&gt;&amp; a, FruitType type) { switch (type) { case FT_ORANGE: a.create&lt;Orange&gt;(); break; case FT_APPLE: a.create&lt;Apple&gt;(); break; default: throw std::runtime_error("Unknown fruit type"); } }</span></span></code> </pre><br>  Here we have a class Fruit, which is no longer abstract.  It contains the familiar getName () method, which simply extracts the desired type from the class contents.  The task of the builder is to fill this field correctly.  For this purpose, 2 classes are used, the constructors of which fill this field with the correct value.  The anProduce generating function creates the necessary instance, the constructor of which does all the necessary work: <br><br><pre> <code class="cpp hljs">An&lt;Fruit&gt; f; f.produce(FT_ORANGE); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; f-&gt;getName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f.produce(FT_APPLE); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; f-&gt;getName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output Orange Apple</span></span></code> </pre><br><br><h1>  Abstract Factory Template </h1><br>  This template is used in case of need to create a set of objects with some kind of affinity.  To illustrate this approach, consider the following example. <br><br>  Suppose we need to create GUI objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWindow</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWindowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IButton</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getButtonName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  At the same time, we have several frameworks that allow working with such objects, one of which is, for example, gtk.  To do this, create an interface for generating objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IWindowsManager</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produceWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IWindow&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produceButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IButton&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Now we declare the implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GtkWindow</span></span></span><span class="hljs-class"> :</span></span> IWindow { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWindowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"GtkWindow"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GtkButton</span></span></span><span class="hljs-class"> :</span></span> IButton { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getButtonName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"GtkButton"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GtkWindowsManager</span></span></span><span class="hljs-class"> :</span></span> IWindowsManager { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produceWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IWindow&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ a.create&lt;GtkWindow&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produceButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IButton&gt;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ a.create&lt;GtkButton&gt;(); } }; BIND_TO_IMPL_SINGLE(IWindowsManager, GtkWindowsManager)</code> </pre><br>  And create generating functions: <br><br><pre> <code class="cpp hljs">PROTO_IFACE(IWindow, a) { An&lt;IWindowsManager&gt; pwm; pwm-&gt;produceWindow(a); } PROTO_IFACE(IButton, a) { An&lt;IWindowsManager&gt; pwm; pwm-&gt;produceButton(a); }</code> </pre><br>  Now you can use our interfaces: <br><br><pre> <code class="cpp hljs">An&lt;IButton&gt; b; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; b-&gt;getWindowName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; An&lt;IWindow&gt; w; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; w-&gt;getButtonName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output GtkButton GtkWindow</span></span></code> </pre><br>  Let's complicate the example.  Suppose we need to choose a framework depending on the configuration.  We look, how it can be implemented: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ManagerType { MT_GTK, MT_UNKNOWN }; <span class="hljs-comment"><span class="hljs-comment">//   struct Configuration { //      Configuration() : wmType(MT_UNKNOWN) {} ManagerType wmType; }; //      () BIND_TO_SELF_SINGLE(Configuration) //          struct WindowsManager { //     ,  [1] An&lt;IWindowsManager&gt; aWindowsManager; An&lt;Configuration&gt; aConfiguration; WindowsManager() { switch (aConfiguration-&gt;wmType) { case MT_GTK: aWindowsManager.create&lt;GtkWindowsManager&gt;(); break; default: throw std::runtime_error("Unknown manager type"); } } }; BIND_TO_SELF_SINGLE(WindowsManager) //   IWindow PROTO_IFACE(IWindow, a) { An&lt;WindowsManager&gt; wm; wm-&gt;aWindowsManager-&gt;produceWindow(a); } //   IButton PROTO_IFACE(IButton, a) { An&lt;WindowsManager&gt; wm; wm-&gt;aWindowsManager-&gt;produceButton(a); } //  An&lt;Configuration&gt; conf; conf-&gt;wmType = MT_GTK; //   gtk An&lt;IButton&gt; b; std::cout &lt;&lt; b-&gt;getButtonName() &lt;&lt; std::endl; An&lt;IWindow&gt; w; std::cout &lt;&lt; w-&gt;getWindowName() &lt;&lt; std::endl; // output GtkButton GtkWindow</span></span></code> </pre><br><br><h1>  Prototype template </h1><br>  This template allows you to create complex or ‚Äúheavy‚Äù objects by cloning an already existing object.  Often this template is used in conjunction with the singleton template, which the cloned object stores.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header file struct ComplexObject { std::string name; }; //      ComplexObject DECLARE_IMPL(ComplexObject) // cpp file struct ProtoComplexObject : ComplexObject { ProtoComplexObject() { name = "ComplexObject from prototype"; } }; //   ComplexObject  ProtoComplexObject   BIND_TO_PROTOTYPE(ComplexObject, ProtoComplexObject)</span></span></code> </pre><br>  Here we have a complex and heavy class ComplexObject that we need to create.  We create this class by copying a ProtoComplexObject object, which is taken from a singleton: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIND_TO_PROTOTYPE(D_iface, D_prototype) \ PROTO_IFACE(D_iface, a) { a.copy(anSingle</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;D_prototype&gt;()); }</span></span></span></span></code> </pre><br>  Now you can use the prototype as follows: <br><br><pre> <code class="cpp hljs">An&lt;ComplexObject&gt; o; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; o-&gt;name &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output ComplexObject from prototype</span></span></code> </pre><br><br><h1>  Template "multiton" </h1><br>  Suppose that we need to create connections to data centers, for example, to obtain the necessary information.  In order not to overload the data center, we must use only one connection to each data center.  If we had one single data center, then we would use Singleton and use it every time to send a message / request.  However, we have 2 identical data centers and we want to balance the load between them, i.e.  If possible, use both data centers.  Therefore, here the singleton is not suitable, but the multi-tone is suitable, which allows you to maintain several instances of the object: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// header //    struct IConnection : IObject { virtual void send(const Buffer&amp; buf) = 0; virtual Buffer recieve(size_t bytes) = 0; }; //    DECLARE_IMPL(IConnection) // cpp file //     struct DataCenterConnection : IConnection { DataCenterConnection() { std::cout &lt;&lt; "Creating new connection" &lt;&lt; std::endl; // ... } ~DataCenterConnection() { std::cout &lt;&lt; "Destroying connection" &lt;&lt; std::endl; // ... } //  recieve &amp; send // ... }; // ,       struct ConnectionManager { ConnectionManager() : connectionCount(0), connections(connectionLimit) { } void fillConnection(An&lt;IConnection&gt;&amp; connection) { std::cout &lt;&lt; "Filling connection: " &lt;&lt; connectionCount + 1 &lt;&lt; std::endl; if (connectionCount &lt; connectionLimit) { //    connections[connectionCount].create&lt;DataCenterConnection&gt;(); } //     connection = connections[connectionCount ++ % connectionLimit]; } private: //    static const size_t connectionLimit = 2; //     size_t connectionCount; std::vector&lt;An&lt;IConnection&gt;&gt; connections; }; //      BIND_TO_SELF_SINGLE(ConnectionManager) //   IConnection PROTO_IFACE(IConnection, connection) { An&lt;ConnectionManager&gt; manager; manager-&gt;fillConnection(connection); } //  for (int i = 0; i &lt; 5; ++ i) { An&lt;IConnection&gt; connection; connection-&gt;send(...); } // output Filling connection: 1 Creating new connection Filling connection: 2 Creating new connection Filling connection: 3 Filling connection: 4 Filling connection: 5 Destroying connection Destroying connection</span></span></code> </pre><br>  For implementation, the simplest connection balancing algorithm was used: each new request for using a connection is redirected to the next data center.  This is enough to illustrate the effect of this design pattern: at the very beginning, 2 connections are created, and then they are reused for new connection objects.  At the end of the program, they are automatically destroyed. <br><br><h1>  Singleton, factory and prototype </h1><br>  In the final example, consider the synergy of several generating patterns.  Suppose we need to create different objects depending on the value being passed.  The number of different types created is assumed to be quite large, so I want to use a reasonably quick way to select the desired type, that is  want to use search using hash functions.  Each instance of the desired type will be quite heavy, so there is a need to use the ‚Äúprototype‚Äù template to facilitate the creation of instances.  Each prototype wants to generate lazily, i.e.  do not create a prototype, there is no need for them yet.  It is also possible that this functionality will never be used, so you don‚Äôt want to create an object for generation in advance, i.e.  We will create a "lazy" factory. <br><br>  So let's get started.  To begin with, we will create interfaces and objects that we would like to create: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IShape</span></span></span><span class="hljs-class"> :</span></span> IObject { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapeName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeftBoundary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> IShape { Square() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Square ctor"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } Square(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Square&amp; s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Square copy ctor"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShapeName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Square"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeftBoundary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_x; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// upper left vertex int m_x; int m_y; // size of square int m_size; }; struct Circle : IShape { Circle() { std::cout &lt;&lt; "Circle ctor" &lt;&lt; std::endl; } Circle(const Circle&amp; s) { std::cout &lt;&lt; "Circle copy ctor" &lt;&lt; std::endl; } virtual std::string getShapeName() { return "Circle"; } virtual int getLeftBoundary() { return m_x - m_radius; } private: // center of the circle int m_x; int m_y; // its radius int m_radius; };</span></span></code> </pre><br>  I added classes with some functionality that we do not need so that everything looks ‚Äúgrown-up‚Äù.  For a quick search, we will use unordered_map, which can be found either in boost or in std, if your compiler supports the new standard.  The key will be a string denoting the type, and the value will be the object that generates the necessary instance of the specified type.  To do this, create the appropriate interfaces: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      template&lt;typename T&gt; struct ICreator : IObject { virtual void create(An&lt;T&gt;&amp; a) = 0; }; // ,   T_impl     T template&lt;typename T, typename T_impl&gt; struct AnCreator : ICreator&lt;T&gt; { virtual void create(An&lt;T&gt;&amp; a) { a.create&lt;T_impl&gt;(); } }; // ,   T_impl     T, //   ,    template&lt;typename T, typename T_impl&gt; struct AnCloner : ICreator&lt;T&gt; { virtual void create(An&lt;T&gt;&amp; a) { a.copy(anSingle&lt;T_impl&gt;()); } };</span></span></code> </pre><br>  Because  we plan to create heavy objects, then we will use AnCloner in the factory. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeFactory</span></span></span><span class="hljs-class"> {</span></span> ShapeFactory() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ShareFactory ctor"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ICreator     add&lt;Square&gt;("Square"); add&lt;Circle&gt;("Circle"); } template&lt;typename T&gt; void add(const std::string&amp; type) { // AnCloner      // AnAutoCreate      An&lt;ICreator&lt;...&gt;&gt; m_creator.insert(std::make_pair(type, AnAutoCreate&lt;AnCloner&lt;IShape, T&gt;&gt;())); } void produce(An&lt;IShape&gt;&amp; a, const std::string&amp; type) { auto it = m_creator.find(type); if (it == m_creator.end()) throw std::runtime_error("Cannot clone the object for unknown type"); it-&gt;second-&gt;create(a); } private: std::unordered_map&lt;std::string, An&lt;ICreator&lt;IShape&gt;&gt;&gt; m_creator; }; //      "" BIND_TO_SELF_SINGLE(ShapeFactory)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So the factory is ready. </font><font style="vertical-align: inherit;">Now we‚Äôll translate the spirit and add the last function for spawning objects:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anProduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(An&lt;IShape&gt;&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; type)</span></span></span><span class="hljs-function"> </span></span>{ An&lt;ShapeFactory&gt; factory; factory-&gt;produce(a, type); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the factory can be used: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Begin"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; An&lt;IShape&gt; shape; shape.produce(<span class="hljs-string"><span class="hljs-string">"Square"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Name: "</span></span> &lt;&lt; shape-&gt;getShapeName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; shape.produce(<span class="hljs-string"><span class="hljs-string">"Circle"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Name: "</span></span> &lt;&lt; shape-&gt;getShapeName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; shape.produce(<span class="hljs-string"><span class="hljs-string">"Square"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Name: "</span></span> &lt;&lt; shape-&gt;getShapeName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; shape.produce(<span class="hljs-string"><span class="hljs-string">"Parallelogram"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Name: "</span></span> &lt;&lt; shape-&gt;getShapeName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What will display on the screen: </font></font><br><br><pre> <code class="cpp hljs">Begin ShareFactory ctor Square ctor Square copy ctor Name: Square Circle ctor Circle copy ctor Name: Circle Square copy ctor Name: Square Cannot clone the object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unknown type</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us consider in more detail what is happening here. At the very beginning, Begin is displayed, which means that no objects have yet been created, including the factory and our prototypes, which speak of the ‚Äúlaziness‚Äù of what is happening. Then the call to shape.produce (‚ÄúSquare‚Äù) creates a whole chain of actions: a factory is created (ShareFactory ctor), then the Square prototype is born (Square ctor), then the prototype is copied (Square copy ctor) and the necessary object is returned. It calls the getShapeName () method, which returns the string Square (Name: Square). A similar process occurs with the Circle object, only now the factory has already been created and re-creation and initialization is no longer required. During the subsequent creation of Square by means of shape.produce ("Square"), now only the prototype copying is called, since the prototype itself has already been created (Square copy ctor).When attempting to create an unknown shape.produce ("Parallelogram"), an exception is thrown, which is caught in a handler omitted for brevity (Cannot clone the object for unknown type).</font></font><br><br><h1>  findings </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article discusses generating design patterns and their use in various situations. </font><font style="vertical-align: inherit;">This article does not pretend to the complete presentation of such templates. </font><font style="vertical-align: inherit;">Here I would like to demonstrate a slightly different view on known issues and problems arising during the design and implementation stages. </font><font style="vertical-align: inherit;">This approach uses a very important principle that underlies everything that is described in this article: the </font></font><a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principle of reversing dependencies [7]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For greater clarity and understanding, I put the use of different templates in a single table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparison Table: unconditional instantiation</font></font><br><table><tbody><tr><th>  Template </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal use </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use in article </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Singleton </font></font></td><td><pre> <code class="cpp hljs">T::getInstance()</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt; -&gt;</code> </pre> </td></tr><tr><td>  Bridge </td><td><pre> <code class="cpp hljs">T::createInstance()</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt; -&gt;</code> </pre> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Factory </font></font></td><td><pre> <code class="cpp hljs">T::getInstance().create()</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt; -&gt;</code> </pre> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multiton </font></font></td><td><pre> <code class="cpp hljs">T::getInstance(instanceId)</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt; -&gt;</code> </pre> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparison table: creating instances based on input data </font></font><br><table><tbody><tr><th>  Template </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normal use </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use in article </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Factory </font></font></td><td><pre> <code class="cpp hljs">T::getInstance().create(...)</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt;.produce(...)</code> </pre> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstract Factory </font></font></td><td><pre> <code class="cpp hljs">U::getManager().createT(...)</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt;.produce(...)</code> </pre> </td></tr><tr><td>  Prototype </td><td><pre> <code class="cpp hljs">T::getInstance().clone()</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt;.produce(...)</code> </pre> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Singleton, prototype and factory </font></font></td><td><pre> <code class="cpp hljs">T::getInstance().getPrototype(...).clone()</code> </pre> </td><td><pre> <code class="cpp hljs">An&lt;T&gt;.produce(...)</code> </pre> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantages are obvious: the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementation does not penetrate the interfaces</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Such an approach allows the code using to abstract away from the specific way of creating instances and concentrate on the problem being solved. </font><font style="vertical-align: inherit;">This, in turn, allows you to create very flexible applications, adding the ability to easily change the implementation without having to refactor the corresponding code.</font></font><br><br><h1>  What's next? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then - a list of references. </font><font style="vertical-align: inherit;">Well, in the next article questions of multithreading and other interesting and unusual "buns" will be considered.</font></font><br><br><h1>  Literature </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="http://habrahabr.ru/blogs/cpp/116577/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Using the singleton pattern</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [2] </font></font><a href="http://habrahabr.ru/blogs/cpp/118368/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habrahabr: Singleton and object lifetime</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Factory method</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [4] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B6%25D0%25B4%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Generating design patterns</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [5] </font></font><a href="http://andrey.moveax.ru/%3Ftag%3D/Creational%2Bpatterns"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrey on .NET: Generating patterns</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] </font></font><a href="http://andrey.moveax.ru/post/patterns-oop-creational-factory-method.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andrey on .NET : Factory Method</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [7] </font></font><a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Dependency inversion principle</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D1%258F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Handling Control</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/118550/">https://habr.com/ru/post/118550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118537/index.html">Vogue as a system monitor</a></li>
<li><a href="../118538/index.html">Open the SMS24X7 internal API for developers</a></li>
<li><a href="../118541/index.html">Did you like Unity?</a></li>
<li><a href="../118544/index.html">Demo scene on Android</a></li>
<li><a href="../118546/index.html">Some new features of Windows 8</a></li>
<li><a href="../118554/index.html">Another visualization of a number of algorithms and data structures</a></li>
<li><a href="../118558/index.html">About parallel worlds</a></li>
<li><a href="../118559/index.html">Tanya Misyutina about the interface</a></li>
<li><a href="../118560/index.html">Twitter will buy TweetDeck for 40-50 million dollars</a></li>
<li><a href="../118561/index.html">Google Chrome tests multiple profiles.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>