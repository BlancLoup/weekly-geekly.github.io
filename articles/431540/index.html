<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Packages and package managers for k8s</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all use some kind of package managers, including cleaning lady Aunt Galya, who has an iPhone in her pocket right now. But there is no general agree...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Packages and package managers for k8s</h1><div class="post__text post__text-html js-mediator-article">  We all use some kind of package managers, including cleaning lady Aunt Galya, who has an iPhone in her pocket right now.  But there is no general agreement on the functions of the package managers, and the standard rpm and dpkg for the OS, and the build systems are called package managers.  We propose to reflect on their functions - what it is and why they are needed in the modern world.  And then we will dig in the direction of Kubernetes and carefully consider Helm from the point of view of these functions. <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Let us see why in this diagram only the template function is highlighted in green, and what are the problems with assembly and packaging, automation of the environment and other things.  But do not worry, the article will not end on the fact that everything is bad.  The community could not come to terms with this and offers alternative tools and solutions - let's deal with them. <br><br>  <b>Ivan Glushkov</b> ( <a href="https://habr.com/users/gli/" class="user_link">gli</a> ) helped us in this with his report on RIT ++, the video and text version of this detailed and detailed presentation below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Videos of this and other talks on DevOps on RHS ++ are published and open for free viewing on our <a href="https://www.youtube.com/c/DevOpsChannel">youtube channel</a> - go in search of answers to your working questions. <br></blockquote><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V_DGgD7ihsQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Ivan Glushkov has been developing software for 15 years.  I managed to work in MZ, in Echo over the platform for comments, to participate in the development of compilers for the Elbrus processor in MCST.  Now he is engaged in infrastructure projects in Postmates.  Ivan is one of the leading <a href="https://devzen.ru/">DevZen</a> podcasts, which also talk about our conferences: <a href="https://devzen.ru/episode-0194/">there</a> is about RHS ++, and <a href="https://devzen.ru/episode-0217/">here</a> about HighLoad ++. <br><br><h2>  Package managers <br></h2><br>  Although everyone uses any kind of package managers, there is no single agreement on what it is.  There is a common understanding, and each has its own. <br><br>  Let's remember what types of package managers first come to mind: <br><br><ul><li>  Standard package managers of all operating systems: <strong>rpm, dpkg, portage</strong> , ... </li><li>  Package managers for different programming languages: <strong>cargo, cabal, rebar3, mix</strong> , ... </li></ul><br>  Their main function is to execute commands to install a package, update a package, delete a package, manage dependencies.  In package managers inside programming languages, everything is a bit more complicated.  For example, there are commands like ‚Äúrun package‚Äù or ‚Äúcreate release‚Äù (build / run / release).  It turns out that this is already an assembly system, although we also call it a package manager. <br><img src="https://habrastorage.org/webt/ct/di/ni/ctdinidgmq8e-zcuksmz-cfym2y.png"><br><br>  All this is only due to the fact that you can‚Äôt just take it and ... let the Haskell lovers forgive this comparison.  You can run a binary file, but you cannot run a program in Haskell or in C, you must first prepare it in some way.  And this preparation is quite complicated, and users want everything to be done automatically. <br><br><h3>  Development <br></h3><br>  The one who worked with the GNU libtool, which is made for a large project consisting of a large number of components, does not laugh at the circus.  It is really very difficult, and some cases cannot be resolved in principle, but can only be circumvented. <br><br>  Compared to him, modern package managers of languages ‚Äã‚Äãlike Rust are much more convenient - you press a button and everything works.  Although in fact, under the hood solved a large number of problems.  At the same time, all these new functions require something additional, in particular, a database.  Although in the package manager itself it can be called whatever you like, I call it a database, since  the data is stored there: about installed packages, about their versions, connected repositories, versions in these repositories.  All this must be stored somewhere, so there is an internal database. <br><br>  Development in this programming language, testing for this programming language, launches - everything is built in and located inside, the <strong>work becomes very convenient</strong> .  Most modern languages ‚Äã‚Äãhave supported this approach.  Even those that did not support, begin to support, because the community crushes and says that in the modern world without this is impossible. <br><br>  <strong>But any decision always has not only pluses, but also minuses</strong> .  Here, the downside is that wrappers, additional utilities, and the built-in ‚Äúdatabase‚Äù are needed. <br><br><h2>  Docker <br></h2><br><blockquote>  Do you think Docker is a package manager or not? <br></blockquote><br>  No matter how, but in fact yes.  I do not know a more correct utility in order to fully install the application along with all dependencies, and to make it work by pressing one button.  What is this if not a package manager?  This is a great batch manager! <br><br>  Maxim Lapshin has already <a href="https://youtu.be/pTRRfW0_eC0">said</a> that with Docker it has become much easier, and it is.  Docker has a built-in build system, all these databases, bindings, utilities. <br><br>  What is the price of all the benefits?  Those who work with Docker think little about industrial applications.  I have this experience, and the price is, in fact, very high: <br><br><ul><li>  <strong>The amount of information</strong> (image size) that should be stored in the Docker image.  It is necessary to pack all dependencies, parts of utilities, libraries inside, the image is large and you need to know how to work with it. </li><li>  Much more difficult is <strong>the paradigm shift</strong> . </li></ul><br>  For example, I had the task to translate one program to use Docker.  The program has been developed by the team that has developed over the years.  I come, we do everything that is written in the books: we write users stories, roles, see what and how they do, their standard routines. <br><br>  I say: <br><br>  - Docker can solve all your problems.  See how it is done. <br><br>  - Everything will be on the button - great!  But we want to do SSH inside Kubernetes containers. <br><br>  - Wait, no SSH anywhere. <br><br>  - Yes, yes, all is well ... Can you use SSH? <br><br>  In order to turn the perception of users in a new direction, it takes a lot of time, it needs educational work and a lot of effort. <br><br>  Another factor in the price is that the <strong>Docker-registry</strong> is an external repository for images; it must somehow be installed and controlled.  There are problems of their own, garbage collector, etc., and it can often fall if it is not followed, but this is all solved. <br><br><h2>  Kubernetes <br></h2><br>  Finally we reached Kubernetes.  This is a cool OpenSource application management system that is actively supported by the community.  Although she originally left the same company, now Kubernetes has a huge community, and it‚Äôs impossible to keep up with it, there are practically no alternatives. <br><br>  Interestingly, all Kubernetes nodes work in Kubernetes itself through containers, and all external applications work through containers ‚Äî <strong>everything works through containers</strong> !  This is a plus and a minus. <br><br>  Kubernetes has a lot of useful functionality and properties: distribution, fault tolerance, the ability to work with different cloud services, focusing on microservice architecture.  All this is interesting and cool, but how to install the application in Kubernetes? <br><br><h3>  How to install the application? <br></h3><br><blockquote>  Install the Docker image in the Docker registry. </blockquote><br>  Behind this phrase is the abyss.  You imagine - you have an application written in, say, Ruby, and you have to put the Docker image into the Docker registry.  This means you must: <br><br><ul><li>  prepare a Docker image; </li><li>  understand how it is going, on which versions it is based; </li><li>  be able to test it; </li><li>  collect, fill in the Docker-registry, which you, by the way, have installed before. </li></ul><br>  In fact, this is a big-big pain in one line. <br><br>  Plus, you still need to describe the application manifests in terms of (resources) k8s.  The easiest option: <br><br><ul><li>  describe deployment + pod, service + ingress (possible); </li><li>  Run the kubectl apply -f resources.yaml command, and transfer all resources to this command. </li></ul><br><img src="https://habrastorage.org/webt/o9/pj/8w/o9pj8wgukswoi3laskibnzkemg0.png"><br><br>  On the slide, Gandhi rubs his hands - it looks like I found a package manager at Kubernetes.  But kubectl is not a package manager.  It simply says that I want to see the final state of the system.  This is not a package installation, not a dependency operation, not an assembly ‚Äî it's just ‚ÄúI want to see this final state.‚Äù <br><br><h2>  Helm <br></h2><br>  Finally we come to Helm.  Helm is a multipurpose utility.  Now we will consider what directions Helm is developing and working with it. <br><br><h3>  Template engine <br></h3><br>  First, Helm is a template engine.  We discussed the need to prepare resources, and the problem is to write in Kubernetes terms (it is possible and not only in yaml).  The most interesting thing is that these are static files for your specific application in this particular environment. <br><br>  However, if you work with several environments and you have not only Production, but also Staging, Testing, Development and different environments for different teams, you need to have several such manifests.  For example, because in one of them there are several servers, and you need to have a large number of replicas, and in the other - only one replica.  There is no database accessing RDS, and you need to install PostgreSQL inside.  And here we have an old version, and we need to rewrite everything a bit. <br><br>  All this diversity leads to the fact that you have to take your manifesto for Kubernetes, copy it everywhere and correct it everywhere: change one number here, something else here.  This becomes very uncomfortable. <br><br>  The solution is simple - you must <strong>enter the templates</strong> .  That is, you form the manifest, define variables in it, and then you define the variables defined from the outside as a file.  The template creates the final manifest.  It turns out the reuse of the same manifest for all environments, which is much more convenient. <br><br>  For example, the manifest for Helm. <br><img src="https://habrastorage.org/webt/ls/ys/ms/lsysmsc7kcnrm1vl8epif7ooowu.png"><br><br><ul><li>  The most important part in Helm is <strong>Chart.yaml</strong> , which describes what the manifest is, what versions, how it works. </li><li> <strong>templates</strong> are just Kubernetes resource templates that contain variables inside themselves.  These variables must be defined in an external file or on the command line, but always outside. </li><li>  <strong>values.yaml</strong> is the standard name for the file with variables for these templates. </li></ul><br>  The simplest startup command for installing the chart is helm install ./wordpress (folder).  To redefine some parameters, we say: "I want to redefine precisely these parameters and set such and such values." <br><br>  Helm copes with this task, so we‚Äôll mark it green in the diagram. <br><img src="https://habrastorage.org/webt/it/nk/7s/itnk7so3wdowimy9riigh74amhy.png"><br><br>  True cons appear: <br><br><ul><li>  <strong>Verbosity</strong> .  Resources are defined completely in terms of Kubernetes, no concepts of additional levels of abstraction are introduced: we simply write everything that we would like to write for Kubernetes, and substitute variables there. </li><li>  <strong>Don't repeat yourself - does not apply.</strong>  You have to repeat the same thing often.  If you have two similar services with different names, you need to completely copy the entire folder (most often do so) and change the necessary files. </li></ul><br>  Before plunging into the direction of Helm - the package manager, for which I am telling all this, let's see how Helm works with dependencies. <br><br><h3>  Work with dependencies <br></h3><br>  With dependencies Helm works hard.  First, there is a requirements.yaml file that fits with what we depend on.  While working with requirements, it makes requirements.lock - this is the current state (impression) of all dependencies.  After that, he downloads them to a folder called / charts. <br><br>  There are tools to control: who, how, where to connect - <strong>tags and conditions</strong> , with the help of which it is determined in which environment, depending on which external parameters to connect or not to connect any dependencies. <br><br>  Let's say you have PostgreSQL for the Staging environment (or RDS for Production, or NoSQL for tests).  By installing this package in Production, you do not install PostgreSQL, because it is not needed there - just with the help of tags and conditions. <br><br>  What is interesting here? <br><br><ul><li>  Helm mixes all the resources of all dependencies and applications; </li><li>  sort -&gt; install / update </li></ul><br>  After we have downloaded all the dependencies in / charts (these dependencies can be, for example, 100), Helm inside it takes and copies all the resources.  After he has rendered the templates, he collects all the resources in one place and sorts them in some kind of his own order.  You cannot influence this order.  You have to decide for yourself what your package depends on, and if the package has transitive dependencies, you need to include them all in the description in the requirements.yaml.  This must be borne in mind. <br><br><h3>  Batch manager <br></h3><br>  Helm installs applications and dependencies, and you can tell Helm install ‚Äî and it will install the package.  So this is a package manager. <br><br>  At the same time, if you have an external repository in which you are uploading a package, you can not access it as a local folder, but simply say: ‚ÄúFrom this repository, take this package, install it with such and such parameters‚Äù. <br><br>  There are open repositories with a large number of packages.  For example, you can run: helm install -f prod / values.yaml stable / wordpress <br><br>  From the repository of stable you take wordpress and install to yourself.  You can do everything: search / upgrade / delete.  It turns out, indeed, Helm - package manager. <br><br>  But there are downsides: all <strong>transitive dependencies</strong> must be turned inward.  This is a big problem when transitive dependencies are independent applications, and you want to work with them separately for testing and development. <br><br>  Another disadvantage is <strong>end-to</strong> - <strong>end configuration</strong> .  When you have a database and its name needs to be transferred to all packages, it is possible, but difficult to do. <br><br><img src="https://habrastorage.org/webt/ws/8m/ox/ws8moxa7dp9ekfc_fcb4mcrytae.png"><br><br>  Most often it does not happen that you have installed one small bag, and it works.  The world is complex: the application depends on the application, which in turn also depends on the application - you need to tweak them somehow cleverly.  Helm does not know how to support it, or supports it with big problems, and sometimes you have to dance a lot with a tambourine to make it work.  This is bad, so the ‚Äúpackage manager‚Äù on the scheme is highlighted in red. <br><br><img src="https://habrastorage.org/webt/c5/rj/sz/c5rjszxy-hf_-pulkkcz_tsaie0.png"><br><br><h3>  Assembly and packaging <br></h3><br>  "You can not just take and" run the application in Kubernetes.  You need to build it, that is, make a Docker image, write it to the Docker registry, etc.  Although all the definition of the package in Helm is.  We define what a package is, what features and fields there should be, signatures and authentication (your company's security system will be very pleased).  Therefore, on the one hand, the build and packaging seems to be supported, and on the other, the work with Docker images is not configured. <br><br><blockquote>  Helm does not allow you to start the application without a Docker image.  At the same time, Helm is not configured to build and package, that is, in fact, it does not know how to work with Docker-images. <br></blockquote><br>  This is the same as if, in order to make an upgrade install for some small library, you would be sent to a remote folder to run the compiler. <br><br>  Therefore, we say that Helm does not know how to work with images. <br><img src="https://habrastorage.org/webt/am/li/ia/amliiax7srabjlml74xvn2xtyb8.png"><br><br><h3>  Development <br></h3><br>  The next headache is development.  In development, we want to quickly and conveniently change our code.  The time has passed when you punched holes on punched cards, and the result was obtained after 5 days.  Everyone is used to replacing one letter with another in the editor, pressing the compilation, and the already changed program works. <br><br>  It also turns out that when changing the code, a lot of additional actions are needed: prepare a Docker file;  Run Docker to create an image;  somewhere to push it;  deploy to the kubernetes cluster.  And only then you will get what you want on Production, and will be able to check the operation of the code. <br><br>  Another inconvenience is due to the <strong>destructive</strong> helm upgrade upgrade.  You looked at how everything works, through kubectl exec looked inside the container, everything is fine.  At this point, you are launching an update, a new image is being downloaded, new resources are being launched, and old ones are being deleted - everything must be started from the very beginning. <br><br>  The biggest pain is the <strong>big images</strong> .  Most companies do not work with small applications.  Often this if not supermonolith, then at least a small monolithic.  Over time, the growth of annual rings, increases the amount of code base, and gradually the application becomes quite large.  I have come across more than once Docker images larger than 2 GB.  Imagine now that you make a change of one byte in your program, press a button, and a two-gigabyte Docker image begins to assemble.  Then you press the next button, and the transfer of 2 GB to the server begins. <br><br>  Docker allows you to work with layers, i.e.  checks if there is one layer or another and sends the missing one.  But the world is such that more often it will be one big layer.  While 2 GB will go to the server, while they and the Docker-registry come to Kubernetes, roll out all the boxes, until you finally start - you can safely drink tea. <br><br>  Helm does not provide any help in working with large Docker images.  I believe that this should not be, but the Helm developers know better than all users, and Steve Jobs smiles at this. <br><br><img src="https://habrastorage.org/webt/xk/wk/4z/xkwk4zdrvxa1xpejhdf02ogsdgo.png"><br><br>  The development block also turned red. <br><br><img src="https://habrastorage.org/webt/pu/o2/ha/puo2ha8r-gmi9cqnkr_sfdv_mpq.png"><br><br><h3>  Environment Automation <br></h3><br>  The last area, environment automation, is an interesting area.  Before the Docker world (and Kubernetes, as a related model), it was not possible to say: ‚ÄúI want to install my application on this server or on these servers, so that there are n replicas, 50 dependencies, and it all works automatically!‚Äù that was, but was not! <br><br>  Kubernetes provides this and it is logical to use it somehow, for example, to say: ‚ÄúI‚Äôm deploying a new environment here and I want all the development teams that have prepared their applications to simply press a button, and all these applications are automatically installed on the new environment‚Äù .  Theoretically, Helm should help with this, so that the configuration can be taken from an external data source - S3, GitHub - from anywhere. <br><br>  It is desirable that in Helm there was a special button ‚ÄúMake me feel good at last!‚Äù - and it would immediately become good.  Kubernetes allows you to do this. <br><br>  This is especially convenient because Kubernetes can be run anywhere, and it works through the API.  Running minikube locally, or in AWS, or in the Google Cloud Engine, you get Kubernetes right out of the box and work the same everywhere: press a button, and everything is all right at once. <br><br>  It would seem, of course Helm allows you to do this.  Because otherwise, what was the point of creating Helm? <br><br>  But it turns out, no! <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Automation environment absent. <br><br><h2>  Alternatives <br></h2><br>  When there is an application from Kubernetes that everyone uses (this is now in fact the solution number 1), but at the same time Helm has the problems discussed above, the community could not help but answer.  It began to create alternative tools and solutions. <br><br><h3>  Template engines <br></h3><br>  It would seem that, as a template engine, Helm solved all the problems, but still the community creates alternatives.  I recall the problems of the template engine: verbosity and code reuse. <br><br>  A good representative here is <strong>Ksonnet.</strong>  It uses a fundamentally different data model and concepts, and it does not work with Kubernetes resources, but with its own definitions: <br>  <em>prototype (params) -&gt; component -&gt; application -&gt; environments.</em> <em><br></em> <br><br>  There are parts (parts) that make up the prototype.  The prototype is parameterized by external data, and a component appears.  Several components make up an application that can be run.  It runs in different environments.  Some understandable links to Kubernetes resources are here, but there may not be a direct analogy. <br><br>  The main purpose of the emergence of Ksonnet was, of course, the <strong>reuse of resources</strong> .  They wanted to make it so that you, once having written the code, could later use it anywhere, which increases the speed of development.  If you create a large external library, people can constantly place their resources there, and the whole community will be able to reuse them. <br><br>  Theoretically it is convenient.  I practically did not use it. <br><br><h3>  Package managers <br></h3><br>  The problem here, as we remember, is nested dependencies, end-to-end configs, transitive dependencies.  Their Ksonnet does not solve.  Ksonnet has a very similar model to Helm, which also defines the list of dependencies in the file, it is uploaded to a specific directory, etc.  The difference is that you can make patches, that is, you prepare a folder in which you put patches for specific packages. <br><img src="https://habrastorage.org/webt/-e/ed/76/-eed76zagrsnj_ydzkcqedelf1g.png"><br><br>  When you upload a folder, these patches overlap, and the result obtained by merging several patches can begin to be used.  Plus there is a validation of configurations for dependencies.  This may be convenient, but it is still very raw, there is almost no documentation, and the version has stopped at 0.1.  I think it's too early to use it. <br><img src="https://habrastorage.org/webt/-c/om/sm/-comsmfipyfxjxvsbit48zbwhoe.png"><br><br>  So, the package manager is <strong>KubePack</strong> , and I haven‚Äôt yet seen other alternatives. <br><br><h3>  Development <br></h3><br>  Solutions are divided into several different categories: <br><br><ol><li>  try to work on top of Helm; <br></li><li>  instead of helm; <br></li><li>  they use a fundamentally different approach, in which they try to work directly in a programming language; <br></li><li>  and other variations about which later. <br></li></ol><br><h4>  1. Development over Helm <br></h4><br>  A good representative is <strong>Draft</strong> .  Its goal is to be able to try the application before the code is committed, that is, to see the current status.  Draft uses the Heroku-style programming method: <br><br><ul><li>  there are packages for your languages ‚Äã‚Äã(pack); </li><li>  write, say, in Python "Hello, world!"; </li><li>  press the button, a Docker file is automatically created (you do not write it); </li><li>  resources are automatically created, it all starts, it is sent to the docker-registry that you had to configure; </li><li>  The application starts automatically. </li></ul><br>  This can be done in any directory with code, everything seems to be quick, easy and good. <br><br>  But in the future it is better to start working with Helm anyway, because Draft creates Helm-resources, and when your code reaches production-ready state, it‚Äôs not worth hoping that Draft will create Helm-resources well.  You will still have to create them manually. <br><br>  It turns out that Draft is needed to quickly start and try at the very beginning before you have written at least one Helm-resource.  Draft - the first contender for this direction. <br><br><h4>  2. Development without Helm <br></h4><br>  Development without Helm Charts involves building the same Kubernetes manifestos that would otherwise be built through Helm Charts.  I suggest three alternatives: <br><br><ul><li>  GitKube; </li><li>  Skaffold; </li><li>  Forge. </li></ul><br>  They are all very similar to Helm, the differences in small details.  In particular, some solutions assume that you will use the command line interface, and Chart assumes that you will do git push and manage hooks. <br><br>  In the end, you still run docker build, docker push and kubectl rollout.  All the problems that we listed for Helm are not solved at all.  It is just an alternative with the same drawbacks. <br><br><h4>  3. Development in the language of the application <br></h4><br>  The next alternative is the development in the language of the application.  Here is a good example - <strong>Metaparticle</strong> .  Let's say you write code in Python, and right inside Python you start to think what you want from the application. <br><br><blockquote>  I see this as a very interesting concept, because most often the developer does not want to think about how the application should work on the servers, what is the correct way to set the config in sysconfig, etc.  It is important working application. <br></blockquote><br>  If it is correct to describe a working application, what parts it consists of, how they interact, theoretically some kind of magic will help turn this knowledge from the point of view of the application into Kubernetes resources. <br><br>  With the help of decorators we determine: where the repository is located, how to properly push it;  what services are and how they interact with each other;  there should be so many replicas on the cluster, etc. <br><img src="https://habrastorage.org/webt/wn/vg/4-/wnvg4-72i7bhg5dabn9_1zinijw.png"><br><br>  I don‚Äôt know about you, but personally I don‚Äôt like it when instead of me some kind of magic decides that you need to make such a Kubernetes config from the Python definitions.  And if I need another? <br><br>  All this works up to a certain limit, while the application is fairly standard.  After that, problems begin.  Let's say I want the preinstall container run before the main container runs, which will perform some actions to configure the future container.  This is all done in the framework of Kubernetes-configs, but I don‚Äôt know whether it is done in the framework of Metaparticle. <br><br>  I cite commonplace simple examples, and there are many more of them, there are a lot of parameters in the specification of Kubernetes-configs.  I am sure that they are not fully present in decorators like Metaparticle. <br><br><img src="https://habrastorage.org/webt/l1/py/fi/l1pyfi0l2xjkhgatomlhj6sil3s.png"><br><br>  Metaparticle appears on the diagram, and we discussed three alternative approaches to Helm.  However, there are additional, and they are very promising in my opinion. <br><br>  <strong>Telepresence / Ksync</strong> is one of them.  Suppose you have an application that has already been written, there are Helm-resources that are also written.  You installed the application, it started somewhere in the cluster, and at this moment you want to try something, for example, change one line in your code.  Of course, I‚Äôm not talking about Production clusters, although some of them even rule something on Production. <br><br>  The Kubernetes problem is that you need to transfer these local edits via the Docker update, via the registry, to Kubernetes.  But to bring to the cluster one modified line can be in other ways.  You can synchronize the local and remote folder, which is located on the hearth. <br><br>  Yes, of course, at the same time there should be a compiler in the image, everything necessary for Development should be there in place.  But what a convenience: install the application, change a few lines, synchronization works automatically, the updated code becomes on the page, we start the compilation and tests - nothing breaks, nothing updates, no destructive updates, as in Helm, does not happen, we get the updated one that works attachment. <br><br>  In my opinion, this is an excellent solution to the problem. <br><br><h4>  4. Development for Kubernetes without Kubernetes <br></h4><br>  I used to think that there was no point in working with Kubernetes without Kubernetes.  I thought that it‚Äôs better to make the Helm-definitions once and use the appropriate tools so that in local development you can have the same configs for everything.  But over time, I was faced with reality and saw applications for which it is extremely difficult to do.  Now I have come to the conclusion that it is easier to write a Docker-compose file. <br><br>  When you do a Docker-compose file, you run all the same images, and mount, just like in the previous case, the local folder on the folder in the Docker container, just not inside Kubernetes, but just in Docker-compose, which is running locally .  Then just run the compiler, and everything works fine.  The downside is that you need to have additional configs for Docker.  The advantage is speed and simplicity. <br><br>  In my example, I tried to run in minikube the same thing that I tried to do with Docker-compose, and the difference was huge.  It worked badly, there were incomprehensible problems, and you raise Docker-compose in 10 lines and everything works.  Since you are working with the same images, it guarantees repeatability. <br><img src="https://habrastorage.org/webt/m2/h4/tt/m2h4tthsizav7rv4tubxlkfo0qg.png"><br><br>  Docker-compose is added to our scheme, and as a whole, it turns out that the community summed up with all these solutions to solve the development problem. <br><br><h3>  Assembly and packaging <br></h3><br>  Yes, assembly and packaging is a problem for Helm, but probably the developers of Helm were right after all.  Each company has its own CI / CD system that collects artifacts, checks and tests.  If it is already there - why close this problem in Helm, when everyone has his own?  Perhaps one correct solution will fail, each will have modifications. <br><br>  If you have a CI / CD, there is integration with an external repository, dockers are automatically collected for each commit, set tests are run, and you can press the button and close it all, you have solved the problem - it is not left. <br><br>  CI / CD is really a solution to the build and packaging problem, and we paint it green. <br><br><h2>  Results <br></h2><br><img src="https://habrastorage.org/webt/fy/pc/ba/fypcbahu2fgsz16tn-imk2a5vpy.png"><br><br>  From 5 directions, Helm itself closes only the template engine.  Immediately it becomes clear why it was created.  The rest of the solutions the community has jointly added, the problems of development, assembly and packaging are completely solved by external solutions.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is not completely convenient, it is not always easy to do within the framework of the established traditions within the company, but it is possible, at least. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future helm </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am afraid that none of us knows for sure what Helm should come to. </font><font style="vertical-align: inherit;">As we have seen, the Helm developers sometimes know better than us what needs to be done. </font><font style="vertical-align: inherit;">I think that most of the problems that we have considered will not be closed by the next releases of Helm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see what has been added to the current Road Map. </font><font style="vertical-align: inherit;">There is such a </font></font><a href="https://github.com/helm/community"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuberneres Helm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repository </font><a href="https://github.com/helm/community"><font style="vertical-align: inherit;">in the community</font></a><font style="vertical-align: inherit;"> , in which there are development plans and good documentation on what will happen in the next version of </font></font><a href="https://github.com/helm/community/tree/master/helm-v3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helm V3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiller disclaimer, only cli </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have not yet discussed these details, so we will consider now. </font><font style="vertical-align: inherit;">The Helm architecture consists of two parts:</font></font><br><br><ol><li>  ,       (cmd  ..). <br></li><li> Tiller ‚Äî  ,      Kubernetes. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiller handles requests that you send through the Command Line Interface. So you say: ‚ÄúI want to install this Chart‚Äù - and in fact Helm collects it, packs it, sends it to Tiller, and he already decides: ‚ÄúOh, something has come to me! It seems that this is projected into the next Kubernetes resources ‚Äù- and it launches. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to the Helm developers, one Tiller should work per cluster and manage the entire technology zoo that is in the cluster. But it turned out that in order to properly share access, it is more profitable for us to have not one but several Tillers - for each namespace its own. So that Tiller can create resources only in the namespace, in which it is running, and did not have the right to go to the neighboring ones. This makes it possible to divide the area of ‚Äã‚Äãresponsibility, the area of ‚Äã‚Äãvisibility for different teams.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next version of V3 Tiller will not. </font></font><br><img src="https://habrastorage.org/webt/k2/rs/3d/k2rs3djfuxajcdf1cgr2whzob58.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And why is he even needed? </font><font style="vertical-align: inherit;">In essence, it contains information transmitted via the Command Line Interface, which it uses to launch resources in Kubernetes. </font><font style="vertical-align: inherit;">It turns out that Kubernetes already contains exactly the same information that is contained in Tiller. </font><font style="vertical-align: inherit;">But I can do the same with kubectl cli. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of Tiller, an </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event system</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is introduced </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">On all new resources that you send to Kubernetes via the Command Line Interface there will be events: settings, changes, deletions, pre-and post-events. </font><font style="vertical-align: inherit;">There are quite a few of these events.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chart Lua Scripts </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some of them you cannot edit, some you can, and you can do this with the help of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lua scripts</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At the stage of creating a Chart, you add a collection of lua-scripts that you put into a special folder. They will fully track the handling of external events. It must be convenient. In fact, some of the problems we discussed earlier can be solved with this approach. </font></font><br><img src="https://habrastorage.org/webt/cr/ie/h1/crieh1qr2o9qc9oocuti_i9bhhm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua and events can close development problems, because it will be possible to control what needs to be done when something happens, both on the server side and on the automation side of the environment too.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, there is still no implementation, one can only guess. </font><font style="vertical-align: inherit;">But theoretically, the most important problem for me is to automate the environment, we can completely close it. </font><font style="vertical-align: inherit;">You can write a new application in Kubernetes, send some configs to it, and using the mechanism that you program yourself, the application will install everything that you want.</font></font> Let's see what happens. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Release object + release release secret </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to fully track the release process, a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Release-object</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will appear </font><font style="vertical-align: inherit;">with information about which Release was written. </font><font style="vertical-align: inherit;">It has not yet been announced that it will be a Release object, how it will be created, maybe it will be a CRD, or maybe not.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Binding to release namespace </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This release object will be created in the namespace in which everything was running, and accordingly because of this, it is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not necessary to bind Tiller</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the namespace ‚Äî the problem I mentioned a little earlier.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CRD: controller </font></font><br></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, in the distant future, developers are thinking of creating a CRD controller for Helm for those cases that cannot be covered by the standard push model. </font><font style="vertical-align: inherit;">But information about the implementation of this is not at all.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collection of recipes </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In total, I recommend using the system. </font></font><br><img src="https://habrastorage.org/webt/c-/kk/zv/c-kkzvsvdzuwr3werccbixl1an4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this is </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helm</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is created by the community, all alternative solutions are created by independent teams, about which we are not sure how long they will exist. Unfortunately, the day after tomorrow they may abandon their projects, and you will remain at the bottom of the trough. And Helm is, after all, a part of Kubernetes. In addition, it will somehow develop and, perhaps, solve problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CI / CD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , automatic assembly by commit. In our company, we have done </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integration with Slack.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we have a bot that tells you when a new build went through in master, and that all the tests were successful. </font><font style="vertical-align: inherit;">You say to him: ‚ÄúI want to install it in Staging‚Äù - and he installs, say: ‚ÄúI want to run a test there!‚Äù - and he launches. </font><font style="vertical-align: inherit;">Pretty comfortable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For development use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker-compose or Telepresence.</font></font></strong> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multiple versions of the same service </font></font><br></h2><br><img src="https://habrastorage.org/webt/gg/cq/wv/ggcqwvrbonamtzi4wudhx3t9jly.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end we will analyze the situation when there are two applications A and B, which depend on C, but C different versions. </font><font style="vertical-align: inherit;">Need to solve this problem:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for development, because in fact we must develop the same, but two different versions; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for release; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for name conflicts, because in all standard package managers, installing two packages of different versions can cause problems. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, Kubernetes decides everything for us - you just need to use it correctly. </font></font><br><br><img src="https://habrastorage.org/webt/wq/ra/mr/wqramrfg3yh1izbnppjmxeuc9hs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would advise you to create 4 Chart in terms of Helm, 3 repositories (for the C repository this will be just two different branches). What is most interesting, all installations for v1 and for v2 should contain information about the version or for which service it was created. One of the solutions on the slide, Appendix C; the release name indicates that this is version v1 for service A; The service name also contains a version. This is the simplest example you can do in a completely different way. But most importantly, the names were unique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is transitive dependencies, and more complicated here.</font></font><br><img src="https://habrastorage.org/webt/pi/5l/ya/pi5lyafuuagwemrrfdhkdb_zby4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, you are developing a chain of services and want to test A. For this, you must pass all the dependencies on which A depends, including transitive, to the Helm-definition of your package. But at the same time, you want to develop B and test it too - how to do it is incomprehensible, because you need to put all transitive dependencies in it as well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, I advise you not to add all dependencies inside each package, but to make them independent and from the outside manage what is running. This is inconvenient, but it is the lesser of two evils.</font></font><br><br><h2>  useful links <br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ </font></font><a href="https://draft.sh/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Draft</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://gitkube.sh/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitKube</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://helm.sh/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helm</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://ksonnet.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ksonnet</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ Telegram stickers: </font></font><a href="https://telegram.org/blog/stickers-meet-art-and-history"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://telegram.org/blog/moar-stickers"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">two</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://github.com/kubernetes/community/tree/master/sig-apps"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sig-Apps</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://kubepack.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KubePack</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://metaparticle.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaparticle</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://github.com/GoogleContainerTools/skaffold"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skaffold</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://github.com/kubernetes-helm/community/tree/master/helm-v3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Helm v3</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://docs.docker.com/compose/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker-compose</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://vapor-ware.github.io/ksync/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ksync</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://www.telepresence.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telepresence</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://drone.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drone</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Ä¢ </font></font><a href="https://forge.sh/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forge</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speaker Ivan Glushkov's profile on </font></font><a href="http://github.com/gliush"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in </font></font><a href="http://twitter.com/gliush"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , on </font></font><a href="https://habr.com/users/gli/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great news </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On our </font></font><a href="https://www.youtube.com/c/DevOpsChannel"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">youtube channel,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opened a video of all the reports on DevOps from the RIT ++ festival</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is a separate </font></font><a href="https://www.youtube.com/playlist%3Flist%3DPLrFmwYyxJyVPhVg01geHFEDqEh9DkxRiD"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playlist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but in the </font></font><a href="https://www.youtube.com/channel/UC1nDIT9thqoFSSxvLyPHF5w/videos"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full list of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> videos there is a lot of useful information from other conferences. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is even better to subscribe to the channel and </font></font><a href="http://eepurl.com/bN_0E1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because in the upcoming year there </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be a lot of devos waiting for us</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : in May, within the framework of RIT ++; </font><font style="vertical-align: inherit;">in the spring, summer and autumn as a HighLoad ++ section, and a separate autumn </font></font><a href="https://devopsconf.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevOpsConf Russia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/431540/">https://habr.com/ru/post/431540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431530/index.html">Open lesson "Android Material Design: review of updates"</a></li>
<li><a href="../431532/index.html">Memristors consisting of 2 nm thick parts</a></li>
<li><a href="../431534/index.html">Problem personalities among developers</a></li>
<li><a href="../431536/index.html">Ceph. Anatomy of a catastrophe</a></li>
<li><a href="../431538/index.html">Case Rate & Goods and Mobio: Incremental increase of all indicators</a></li>
<li><a href="../431546/index.html">Why do we say OK?</a></li>
<li><a href="../431548/index.html">Solar Dozor - what is behind the stars?</a></li>
<li><a href="../431550/index.html">Injection Molded Films (IMD): How It Works</a></li>
<li><a href="../431554/index.html">Facebook counter from old electric meter</a></li>
<li><a href="../431556/index.html">Sidenis about working with insurance corporations, agile coaching and prohibited technologies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>