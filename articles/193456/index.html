<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a mutex outside the OS using the example of an AVR microcontroller and a TWI bus</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I decided to build a weather station for myself. The sensors are different there, including on the I2C bus. And as is good, usually at the beginn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a mutex outside the OS using the example of an AVR microcontroller and a TWI bus</h1><div class="post__text post__text-html js-mediator-article">  Once I decided to build a weather station for myself.  The sensors are different there, including on the I2C bus.  And as is good, usually at the beginning, he did everything on the flags of waiting.  But the path of the real Jedi is different, and it was decided to hang everything up for interruptions.  That's where hemorrhoids began.  The problem I encountered is the processing of several requests in a row.  For example, the pressure sensor <a href="https://www.sparkfun.com/datasheets/Components/General/BST-BMP085-DS000-05.pdf">BMP085</a> for further work with it requires you to pull out 11 calibration constants from its EEPROM: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/33b/6f6/b6f/33b6f6b6f9354b2e85738a72aa27044d.png"></div><br>  About how I came to the decision and the sequence of thoughts are described below. <br><a name="habracut"></a><br><h4>  Waiting flags </h4>  We define the functions <b>get_AC1, get_AC2, ..., get_MD</b> .  Each of them receives a corresponding constant from the sensor EEPROM via the I2C bus.  The format of the package from the datasheet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/45d/da2/5ce/45dda25ce93a6f95e381a9f60678de80.png"></div><br>  And the sample code for the <b>get_AC1</b> function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">get_AC1</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_AC1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Word; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Byte[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } AC1; <span class="hljs-comment"><span class="hljs-comment">//  AC1 // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  START  (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = 0xEE; //  SLA+W TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+W (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = 0xAA; //  0xAA TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  0xAA (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  REPEATED START  (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = 0xEF; //  SLA+R TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+R (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //       ACK (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- AC1.Byte[1] = TWDR; //  MSB TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //       NACK (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- AC1.Byte[0] = TWDR; //  LSB TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(1&lt;&lt;TWSTO)| //  STOP  (0&lt;&lt;TWWC); // ---------------------------------------- return AC1.Word; }</span></span></code> </pre> </div></div><br>  And here is its waveform: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/d11/312/aaa/d11312aaa645350e640b4a307359b1ec.png"></div><br>  The use of union union for AC1 is related to the difference in order of bytes.  For TWI, this is big-endian, for AVR - little-endian.  The <b>get_AC2</b> function differs only in sending byte <b>0xAC</b> (we look at the datasheet) instead of <b>0xAA</b> after the command <b>SLA + W.</b>  In all other respects, the functions are absolutely identical.  Therefore, we can define one <b>get_Data</b> , which will take the Register address as parameters in accordance with the datasheet: <br><br><div class="spoiler">  <b class="spoiler_title">get_Data</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_Data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Register_adress)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Word; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Byte[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } Data; <span class="hljs-comment"><span class="hljs-comment">//  Data // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  START  (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = 0xEE; //  SLA+W TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+W (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = Register_adress; //  Register_adress TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  Register_adress (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  REPEATED START  (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWDR = 0xEF; //  SLA+R TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+R (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //       ACK (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- Data.Byte[1] = TWDR; //  MSB TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //       NACK (0&lt;&lt;TWWC); while (!(TWCR &amp; (1&lt;&lt;TWINT))) //    TWINT ; // ---------------------------------------- Data.Byte[0] = TWDR; //  LSB TWCR = (1&lt;&lt;TWEN)| //  TWI  (0&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(1&lt;&lt;TWSTO)| //  STOP  (0&lt;&lt;TWWC); // ---------------------------------------- return Data.Word; }</span></span></code> </pre></div></div><br>  and then just: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC1; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC2; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC3; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC4; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC5; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> AC6; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> B1; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> B2; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> MB; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> MC; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> MD; } BMP085_EEPROM; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_EEPROM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ BMP085_EEPROM.AC1 = get_Data(<span class="hljs-number"><span class="hljs-number">0xAA</span></span>); BMP085_EEPROM.AC2 = get_Data(<span class="hljs-number"><span class="hljs-number">0xAC</span></span>); BMP085_EEPROM.AC3 = get_Data(<span class="hljs-number"><span class="hljs-number">0xAE</span></span>); BMP085_EEPROM.AC4 = get_Data(<span class="hljs-number"><span class="hljs-number">0xB0</span></span>); BMP085_EEPROM.AC5 = get_Data(<span class="hljs-number"><span class="hljs-number">0xB2</span></span>); BMP085_EEPROM.AC6 = get_Data(<span class="hljs-number"><span class="hljs-number">0xB4</span></span>); BMP085_EEPROM.B1 = get_Data(<span class="hljs-number"><span class="hljs-number">0xB6</span></span>); BMP085_EEPROM.B2 = get_Data(<span class="hljs-number"><span class="hljs-number">0xB8</span></span>); BMP085_EEPROM.MB = get_Data(<span class="hljs-number"><span class="hljs-number">0xBA</span></span>); BMP085_EEPROM.MC = get_Data(<span class="hljs-number"><span class="hljs-number">0xBC</span></span>); BMP085_EEPROM.MD = get_Data(<span class="hljs-number"><span class="hljs-number">0xBE</span></span>); }</code> </pre><br>  Here's what happened in the end: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/076/f53/ebe/076f53ebe0c0957a88216ef363296525.png"></div><br><h4>  Work on interruptions </h4><br><h5>  Foreword </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/dfe/f0c/03e/dfef0c03ed7b3a099b852d7d91e9f891.png"></div><br>  As can be seen from the figure above, the duration of a single operation is <b>488 Œºs</b> , for a bus transfer frequency of <b>100 kHz</b> , which is <b>3094</b> processor <b>clock</b> speeds at a frequency of <b>8 MHz</b> .  Well, this is not in any gate guys.  Of course, you can increase the frequency, if the target device allows.  For example, for <b>400 kHz, the</b> duration is <b>128 Œºs</b> or <b>1024 cycles</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/dea/c6a/2d6/deac6a2d688d4fe6203d5dd857c136c8.png"></div><br>  Waiting for the flag to be raised is an absolutely useless operation.  For thousands of clock cycles, the processor can do a lot of useful work, for example, perform the operation of dividing floating-point numbers.  Therefore, the only adequate way out of this situation is to use interrupts. <br><br><h5>  Work on interruptions </h5><br>  Define the structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> SLA; <span class="hljs-comment"><span class="hljs-comment">// Slave address unsigned char *pW; // ? unsigned char nW; // ? unsigned char *pR; // ? unsigned char nR; // ? } TWI;</span></span></code> </pre><br>  and now our <b>get_AC1</b> function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> Register_address; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_AC1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Register_address = <span class="hljs-number"><span class="hljs-number">0xAA</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Register address TWI.SLA = 0x77; // Slave address  BMP085 TWI.pW = &amp;Register_address; //       TWI.nW = 1; //   ? TWI.pR = &amp;BMP085_EEPROM.AC1; //   ? TWI.nR = 2; //   ? TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  START  (0&lt;&lt;TWWC); }</span></span></code> </pre><br>  A couple of words about the interrupt handler.  If <b>nW = n</b> , <b>nR = 0</b> , the frame format is: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/a61/ac9/6de/a61ac96dec25a3254af38a34d38a723e.png"></div><br>  if <b>nW = 0</b> , <b>nR = m</b> : <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/03b/90f/b78/03b90fb78407808e746645fe3c58dd3f.png"></div><br>  and if <b>nW = n</b> , <b>nR = m</b> : <br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/142/7a0/295/1427a029546a9e357e28aeea339b4190.png"></div><br>  By the way the interrupt handler can be anything.  The logic of the state machine can be implemented in different ways.  An example of mine is shown below: <br><div class="spoiler">  <b class="spoiler_title">Interrupt handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ISR(TWI_vect) { <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Jump table which is stored in flash ------------------------------------------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> twi_list[] PROGMEM = {&amp;&amp;TWI_00, &amp;&amp;TWI_08, &amp;&amp;TWI_10, &amp;&amp;TWI_18, &amp;&amp;TWI_20, &amp;&amp;TWI_28, &amp;&amp;TWI_30, &amp;&amp;TWI_38, &amp;&amp;TWI_40, &amp;&amp;TWI_48, &amp;&amp;TWI_50, &amp;&amp;TWI_58, &amp;&amp;TWI_60, &amp;&amp;TWI_68, &amp;&amp;TWI_70, &amp;&amp;TWI_78, &amp;&amp;TWI_80, &amp;&amp;TWI_88, &amp;&amp;TWI_90, &amp;&amp;TWI_98, &amp;&amp;TWI_A0, &amp;&amp;TWI_A8, &amp;&amp;TWI_B0, &amp;&amp;TWI_B8, &amp;&amp;TWI_C0, &amp;&amp;TWI_C8, &amp;&amp;TWI_F8}; <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Jump to label, address of which is in twi_list[TWSR&gt;&gt;3] ------------------------------------------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *(pgm_read_word(&amp;(twi_list[TWSR&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>]))); <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Bus error handler ------------------------------------------------------------------------------------*/</span></span> TWI_00: <span class="hljs-comment"><span class="hljs-comment">// STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- A START condition has been transmitted A repeated START condition has been transmitted nW = nR = 0: STOP condition will be generated nW &gt; 0, nR - don't care: SLA+W will be send nW = 0, nR &gt; 0: SLA+R will be send ------------------------------------------------------------------------------------*/ TWI_08: TWI_10: if (TWI.nW != 0) // SLA+W will be send TWDR = (TWI.SLA)&lt;&lt;1; else if (TWI.nR != 0) // SLA+R will be send TWDR = (TWI.SLA)&lt;&lt;1 | 1&lt;&lt;0; else // STOP condition will be generated goto STOP; TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+R/W (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- SLA+W has been transmitted; ACK has been received Data byte has been transmitted; ACK has been received nW &gt; 0, nR - don't care: Data byte will be transmitted and ACK or NOT ACK will be received nW = 0, nR &gt; 0: Repeated START will be transmitted nW = nR = 0: STOP condition will be generated ------------------------------------------------------------------------------------*/ TWI_18: TWI_28: if (TWI.nW != 0) { // Data byte will be transmitted and ACK or NOT ACK will be received TWDR = *TWI.pW++; TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //   (0&lt;&lt;TWWC); TWI.nW--; } else if (TWI.nR != 0) // Repeated START will be transmitted TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  START  (0&lt;&lt;TWWC); else // STOP condition will be generated goto STOP; return; /* ----------------------------------------------------------------------------------- SLA+W has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_20: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Data byte has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_30: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Arbitration lost in SLA+W or data bytes Arbitration lost in SLA+R or NOT ACK bit ------------------------------------------------------------------------------------*/ TWI_38: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- SLA+R has been transmitted; ACK has been received nR = 1: Data byte will be received and NOT ACK will be returned nR &gt; 1: Data byte will be received and ACK will be returned ------------------------------------------------------------------------------------*/ TWI_40: if (TWI.nR == 1) // Data byte will be received and NOT ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + NACK (0&lt;&lt;TWWC); else // Data byte will be received and ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + ACK (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- SLA+R has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_48: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Data byte has been received; ACK has been returned nR = 2: Data byte will be received and NOT ACK will be returned nR &gt; 2: Data byte will be received and ACK will be returned ------------------------------------------------------------------------------------*/ TWI_50: // Read data *TWI.pR++ = TWDR; if (TWI.nR-- == 2) // Data byte will be received and NOT ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + NACK (0&lt;&lt;TWWC); else // Data byte will be received and ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + ACK (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- Data byte has been received; NOT ACK has been returned Repeated START will be transmitted STOP condition will be transmitted and TWSTO Flag will be reset STOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset ------------------------------------------------------------------------------------*/ TWI_58: // Read data *TWI.pR = TWDR; TWI_60: TWI_68: TWI_70: TWI_78: TWI_80: TWI_88: TWI_90: TWI_98: TWI_A0: TWI_A8: TWI_B0: TWI_B8: TWI_C0: TWI_C8: TWI_F8: // STOP condition will be transmitted and TWSTO Flag will be reset STOP: TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(1&lt;&lt;TWSTO)| //    + NACK (0&lt;&lt;TWWC); }</span></span></code> </pre></div></div><br>  Well, the result of the work: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/d51/ac2/b96/d51ac2b9683e5c2912f44561d989ca55.png"></div><br>  as we see, the execution time has increased from <b>488 Œºs</b> to <b>538 Œºs</b> .  This is due to the transition to and return from the handler, as well as the calculation of the jump address on the lookup table.  But the most important thing is that all transmission is hardware.  So, after executing the small function <b>get_AC1</b> , which lasts only <b>3.5 microseconds</b> or <b>28 cycles</b> , we can safely do other things, rather than blunt the wait cycle. <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/43e/ca2/24a/43eca224a7781bea53b82b07ae795442.png"></div><br>  Let's see what happens if we call the <b>get_AC1</b> , <b>get_AC2</b> , ..., <b>get_MD functions</b> in order: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/172/d1c/1d4/172d1c1d43b65c74b193d394dca8d27f.png"></div><br>  Only one will be <b>executed</b> , <b>get_MD</b> , and all because: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/6dd/335/f68/6dd335f68cf1fc699f26e93f2474e00a.png"></div><br>  The last function loads data into the structure before SLA + W completes, therefore Register_address corresponds to it and is equal to <b>0xBE</b> .  In fact, this is probably the most innocent scenario.  After all, if the transfer was a little faster than Register_address would correspond to the <b>get_AC5</b> function <b>,</b> for example, and we would <b>write it</b> in <b>BMP085_EEPROM.MD</b> .  That is, we expect <b>AC1</b> , we get <b>AC5</b> stored in <b>MD</b> .  And if instead of <b>get_AC5 there</b> would be another, with our SLA, we could send half of the address of one and the other of the other would get NACK, and then interrupt the logic of the interrupt handler, or the program will loop, or throw STOP.  There is one obvious way out of this situation.  Do not run the next function until the previous one has ended.  That is, by running <b>get_AC1, we</b> set the flag to 1, and the handler, <b>after completing</b> STOP, will reset it.  And <b>get_AC2</b> will not start until this flag is cleared.  Yes, this is a way out, but all the beauty of interruptions is lost, which in this case is used as much as 0%.  It is better flag machine.  But there is another beautiful solution. <br><br><h5>  Analog mutex </h5><br>  Functions <b>get_AC1</b> , ..., <b>get_MD</b> do not cause data transfer directly.  They call another function that puts them in a queue and initializes the transfer itself if the queue is not empty.  Rewrite our structure by creating an array of structures: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> size 8 ... typedef struct { unsigned char SLA; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Slave address unsigned char *pW; // ? unsigned char nW; // ? unsigned char *pR; // ? unsigned char nR; // ? } twi; twi TWI[size];</span></span></span></span></code> </pre><br><br>  Let's see how the <b>get_AC1</b> function will look like now: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[size]; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_AC1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> twi *pl; <span class="hljs-comment"><span class="hljs-comment">//     twi buf[0] = 0xAA; //  Register address pl-&gt;SLA = 0x77; // Slave address  BMP085 pl-&gt;pW = buf; //       pl-&gt;nW = 1; //   ? pl-&gt;pR = buf; //   ? pl-&gt;nR = 2; //   ? Scheduler(pl); //    }</span></span></code> </pre><br>  Practically the same, only instead of initializing the START state, we call the <b>Scheduler</b> function, passing as a parameter a pointer to the <b>twi</b> structure, which contains all the data necessary for the TWI frame.  Consider the basic functions of the scheduler and some changes to the processor: <br><ul><li>  receiving the pointer, the function copies all data into the TWI [i] structure, where i is the current element number of the array of structures, after which it is increased by 1;  if i falls outside the array dimension, it is reset;  so we turn the array of structures into a circular buffer; </li><li>  j variable points to the element that will be processed in the interrupt handler, after which it increases by 1;  if j falls outside the dimension of the array, it is reset; </li><li>  if i overtakes j (queue overflow) - writing to an array of structures is not possible; </li><li>  the flag variable is initialized to 0; </li><li>  if i is not equal to j (the queue is not empty) and flag = 0, then flag = 1, start the START state; </li><li>  in the handler, after working on frame j, we increase by 1, so it will point to the next frame; </li><li>  in the processor after the frame has been worked out and j is changed, if i is not equal to j, we give the STOP-START state, otherwise STOP and flag = 0; </li></ul><br>  Do not bother with what is written above.  It is better to see a small presentation that will clarify some points of the above: <br><br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.slideshare.net/slideshow/embed_code/26105311&amp;xid=17259,15700019,15700186,15700190,15700253,15700256,15700259&amp;usg=ALkJrhjaH930vgaoEHuhK9SkFCdeIXwruA" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div><br>  Scheduler Scheduler <b>Function</b> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(twi *pl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tail-head !=<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; head-tail != size<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    ,  { twi *pg = &amp;TWI[head]; //      pg-&gt;SLA = pl-&gt;SLA; //  SLA pg-&gt;pW = pl-&gt;pW; //  *pW pg-&gt;nW = pl-&gt;nW; //  nW pg-&gt;pR = pl-&gt;pR; //  *pR pg-&gt;nR = pl-&gt;nR; //  nR head = (head+1)&amp;(size-1); //       -  if (!flag.twi_run) //   TWI    (  0) { flag.twi_run = 1; //    1 TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| (0&lt;&lt;TWWC); } } }</span></span></code> </pre><br>  Well, the handler itself: <br><div class="spoiler">  <b class="spoiler_title">Redesigned interrupt handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ISR(TWI_vect) { twi *p = &amp;TWI[tail]; <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Jump table which is stored in flash ------------------------------------------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> twi_list[] PROGMEM = {&amp;&amp;TWI_00, &amp;&amp;TWI_08, &amp;&amp;TWI_10, &amp;&amp;TWI_18, &amp;&amp;TWI_20, &amp;&amp;TWI_28, &amp;&amp;TWI_30, &amp;&amp;TWI_38, &amp;&amp;TWI_40, &amp;&amp;TWI_48, &amp;&amp;TWI_50, &amp;&amp;TWI_58, &amp;&amp;TWI_60, &amp;&amp;TWI_68, &amp;&amp;TWI_70, &amp;&amp;TWI_78, &amp;&amp;TWI_80, &amp;&amp;TWI_88, &amp;&amp;TWI_90, &amp;&amp;TWI_98, &amp;&amp;TWI_A0, &amp;&amp;TWI_A8, &amp;&amp;TWI_B0, &amp;&amp;TWI_B8, &amp;&amp;TWI_C0, &amp;&amp;TWI_C8, &amp;&amp;TWI_F8}; <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Jump to label, address of which is in twi_list[TWSR&gt;&gt;3] ------------------------------------------------------------------------------------*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *(pgm_read_word(&amp;(twi_list[TWSR&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>]))); <span class="hljs-comment"><span class="hljs-comment">/* ----------------------------------------------------------------------------------- Bus error handler ------------------------------------------------------------------------------------*/</span></span> TWI_00: <span class="hljs-comment"><span class="hljs-comment">// STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- A START condition has been transmitted A repeated START condition has been transmitted nW = nR = 0: STOP condition will be generated nW &gt; 0, nR - don't care: SLA+W will be send nW = 0, nR &gt; 0: SLA+R will be send ------------------------------------------------------------------------------------*/ TWI_08: TWI_10: if (p-&gt;nW != 0) // SLA+W will be send TWDR = p-&gt;SLA&lt;&lt;1; else if (p-&gt;nR != 0) // SLA+R will be send TWDR = p-&gt;SLA&lt;&lt;1 | 1&lt;&lt;0; else // STOP condition will be generated goto STOP; TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  SLA+R/W (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- SLA+W has been transmitted; ACK has been received Data byte has been transmitted; ACK has been received nW &gt; 0, nR - don't care: Data byte will be transmitted and ACK or NOT ACK will be received nW = 0, nR &gt; 0: Repeated START will be transmitted nW = nR = 0: STOP condition will be generated ------------------------------------------------------------------------------------*/ TWI_18: TWI_28: if (p-&gt;nW != 0) { // Data byte will be transmitted and ACK or NOT ACK will be received TWDR = *p-&gt;pW; p-&gt;pW++; TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //   (0&lt;&lt;TWWC); p-&gt;nW--; } else if (p-&gt;nR != 0) // Repeated START will be transmitted TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //  START  (0&lt;&lt;TWWC); else // STOP condition will be generated goto STOP; return; /* ----------------------------------------------------------------------------------- SLA+W has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_20: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Data byte has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_30: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Arbitration lost in SLA+W or data bytes Arbitration lost in SLA+R or NOT ACK bit ------------------------------------------------------------------------------------*/ TWI_38: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- SLA+R has been transmitted; ACK has been received nR = 1: Data byte will be received and NOT ACK will be returned nR &gt; 1: Data byte will be received and ACK will be returned ------------------------------------------------------------------------------------*/ TWI_40: if (p-&gt;nR == 1) // Data byte will be received and NOT ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + NACK (0&lt;&lt;TWWC); else // Data byte will be received and ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + ACK (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- SLA+R has been transmitted; NOT ACK has been received ------------------------------------------------------------------------------------*/ TWI_48: // STOP condition will be generated goto STOP; /* ----------------------------------------------------------------------------------- Data byte has been received; ACK has been returned nR = 2: Data byte will be received and NOT ACK will be returned nR &gt; 2: Data byte will be received and ACK will be returned ------------------------------------------------------------------------------------*/ TWI_50: // Read data *p-&gt;pR = TWDR; p-&gt;pR++; if (p-&gt;nR-- == 2) // Data byte will be received and NOT ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + NACK (0&lt;&lt;TWWC); else // Data byte will be received and ACK will be returned TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (1&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| //    + ACK (0&lt;&lt;TWWC); return; /* ----------------------------------------------------------------------------------- Data byte has been received; NOT ACK has been returned Repeated START will be transmitted STOP condition will be transmitted and TWSTO Flag will be reset STOP condition followed by a START condition will be transmitted and TWSTO Flag will be reset ------------------------------------------------------------------------------------*/ TWI_58: // Read data *p-&gt;pR = TWDR; TWI_60: TWI_68: TWI_70: TWI_78: TWI_80: TWI_88: TWI_90: TWI_98: TWI_A0: TWI_A8: TWI_B0: TWI_B8: TWI_C0: TWI_C8: TWI_F8: // STOP condition will be transmitted and TWSTO Flag will be reset STOP: tail = (tail+1)&amp;(size-1); //  tail  1,    ,   if (head != tail) //  head  tail  ,  TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(1&lt;&lt;TWSTO)| // - (0&lt;&lt;TWWC); else //  { TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| //  !   (0&lt;&lt;TWEA)|(0&lt;&lt;TWSTA)|(1&lt;&lt;TWSTO)| //  (0&lt;&lt;TWWC); flag.twi_run = 0; //   } }</span></span></code> </pre></div></div><br>  Well, the result of the execution of <b>get_AC1</b> : <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/22a/4bd/c0d/22a4bdc0dd3678388c94a23e62674b65.png"></div><br><h5>  Afterword </h5><br>  In fact, if, by analogy with <b>get_AC1,</b> to make <b>get_AC2</b> and run 2 functions in a row, then only the last one will be executed twice.  This is due to the fact that we constantly store data for transmission in buf [0].  To avoid this, we could write data to buf [1] and everything would work as it should.  But this is not done.  Correctly passing the pointer where to get the data and how much, and some third-party function will put this in the buffer for TWI and return the pointer where in it to get the data in the handler.  In general, the code for example: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bufTx[size]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_AC1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> twi *pl; <span class="hljs-comment"><span class="hljs-comment">//     twi volatile uint8_t buf[] = {0xAA}; //  Register address  buf pl-&gt;SLA = 0x77; // Slave address  BMP085 pl-&gt;pW = buf; //       pl-&gt;nW = 1; //   ? pl-&gt;pR = buf; //   ? pl-&gt;nR = 2; //   ? Scheduler(pl); //    } // ============================================ void get_AC2(void) { volatile twi *pl; //     twi volatile uint8_t buf[] = {0xAC}; //  Register address  buf pl-&gt;SLA = 0x77; // Slave address  BMP085 pl-&gt;pW = buf; //       pl-&gt;nW = 1; //   ? pl-&gt;pR = buf; //   ? pl-&gt;nR = 2; //   ? Scheduler(pl); //    } // ============================================ void Scheduler(volatile twi *pl) { if (tail-head !=1 &amp;&amp; head-tail != size-1) //    ,  { twi *pg = &amp;TWI[head]; //      pg-&gt;SLA = pl-&gt;SLA; //  SLA pg-&gt;pW = pushToBuf(pl-&gt;pW,pl-&gt;nW); //  ,    //  buf  bufTX    pg-&gt;nW = pl-&gt;nW; //  nW pg-&gt;pR = pl-&gt;pR; //  *pR pg-&gt;nR = pl-&gt;nR; //  nR head = (head+1)&amp;(size-1); //       -  if (!flag.twi_run) //   TWI    (  0) { flag.twi_run = 1; //    1 TWCR = (1&lt;&lt;TWEN)| //  TWI  (1&lt;&lt;TWIE)|(1&lt;&lt;TWINT)| (0&lt;&lt;TWEA)|(1&lt;&lt;TWSTA)|(0&lt;&lt;TWSTO)| (0&lt;&lt;TWWC); } } } // ============================================ unsigned char *pushToBuf(unsigned char *buf, unsigned char n) { unsigned char *p = &amp;bufTx[pos]; //      do { bufTx[pos++] = *buf++; //   buf  bufTx pos &amp;= size-1; //   -  } while (--n); //  n  return p; //   p }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> look at the picture: </font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/d5e/a56/b7d/d5ea56b7d7b2dcbbf9b916a28dbca876.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kindly, by analogy, the same function must be done for the receiving buffer. </font><font style="vertical-align: inherit;">You tell her how much, and she sends you where. </font><font style="vertical-align: inherit;">You can also modify the TWI structure, for example, passing not pointers, but indexes to optimize memory. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If anyone has a question about why the code is used for zeroing:</font></font><br><pre> <code class="cpp hljs">head = (head+<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;(size<span class="hljs-number"><span class="hljs-number">-1</span></span>); tail = (tail+<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;(size<span class="hljs-number"><span class="hljs-number">-1</span></span>); pos &amp;= size<span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will say this faster and less code. The only condition is that the value be 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the features we should also note the maximum size of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the TWI. If it is less than the maximum possible number of consecutive requests, we will certainly lose some of them. Therefore, it is important to highlight this emphasis. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Always use size at least 1 more than the maximum number of simultaneous requests</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be possible to add a handler of the received data, after working out the function. For our example, this is the processing of the received AC1 and AC2, which we receive in Big-endianne and have to convert to Little-endiann, and then save it in the appropriate place. To do this, in the TWI structure one could also store a pointer to the handler function and figure out how to call it after working out. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few words should be said about the processes. With reference to my scheme, there are 2 sensors of the number, pressure, 1 time chip and 1 memory chip on the TWI bus. And access to them can be regarded as atomic, for example for a pressure sensor:</font></font><br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/197/eea/83f/197eea83fdb7a1f3d6364475dd033e1e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if we lose the transmission for uncompressed pressure, the uncompressed temperature obtained is useless and we must start all over again, because we can get non-valid data. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, there is no case of failure in the transmission of TWI. Since we are changing the original TWI [i] in the handler, we cannot restart the transfer. To do this, you can declare a global structure of type twi, and before each start, copy data from TWI [tail] into it, and let the handler spoil the copy. In the event of a failure, we can recover the data from the original.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many will ask: ‚ÄúWhy? </font><font style="vertical-align: inherit;">After all, to store the 16 elements of the structure, you need 16 * (1 + 2 + 1 + 2 + 1) = 112 bytes of SRAM! </font><font style="vertical-align: inherit;">Why not use RTOS? </font><font style="vertical-align: inherit;">Let the pier be a structure with 1 element and if it doesn‚Äôt fit into it, we queue for n ms. ‚ÄùI think that this solution is very useful in operating systems. </font><font style="vertical-align: inherit;">Think how long will such a transfer? </font><font style="vertical-align: inherit;">If we put in the queue, then each next transmission will be in n ms, and the whole will end in n * m ms. </font><font style="vertical-align: inherit;">And why bother to queue with unnecessary m instructions, because there is a chance to miss a really important task. </font><font style="vertical-align: inherit;">And the OS kernel is unloaded without queuing m * (m + 1) / 2 tasks.</font></font></div><p>Source: <a href="https://habr.com/ru/post/193456/">https://habr.com/ru/post/193456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../19344/index.html">8 most important Firefox extensions for web developers</a></li>
<li><a href="../193442/index.html">Live Broadcast Windows Camp</a></li>
<li><a href="../193450/index.html">Electromagnetic radiation that blocks the operation of engines</a></li>
<li><a href="../193452/index.html">Load testing in Skyforge, or Bots - server orderlies. Part 2</a></li>
<li><a href="../193454/index.html">IBM Introduces NeXtScale System - High-Performance Computing Platform for Data Centers</a></li>
<li><a href="../193458/index.html">RESTful API on Node.js + MongoDB</a></li>
<li><a href="../19346/index.html">A little bit about the hobby of old iron</a></li>
<li><a href="../193460/index.html">Automate monitoring: low-level detection</a></li>
<li><a href="../193464/index.html">Yealink and 3CX become strategic partners</a></li>
<li><a href="../193466/index.html">Competition within the team kills the team spirit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>