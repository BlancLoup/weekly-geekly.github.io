<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Steganography in .NET applications or watermarks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine that your application brazenly steal and spread to the network. And there‚Äôs no way to understand which of the most honest customers are leakin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Steganography in .NET applications or watermarks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/d81/d56/747/d81d56747336b1c832442e0768007b69.png" align="left" alt="enigma"><br>  Imagine that your application brazenly steal and spread to the network.  And there‚Äôs no way to understand which of the most honest customers are leaking.  The way out is clear: it is enough just to issue applications to clients with different versions and determine the leakage by version. <br><br>  But what if the situation became more complicated, and your program this time is stolen by a hacker, and he will take care to clear out all the traces that identify the program.  For such a case, universal methods have been developed for introducing secret data into the application, the so-called watermarks or watermarks (tracing from the English watermark). <br><br>  We will only consider Watermark here and the purpose of which is not to be removed under any circumstances, so that the creator of the application can read them after any attacks by a potential intruder, and users of the application did not guess about them.  There are other types of watermarks, designed, for example, to track changes in the application, such hidden cheksummy, and they must also be difficult to remove, but that‚Äôs another story. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Best Watermark </h4><br>  A great way to integrate Watermark into an application is to fantasize and come up with a place where no hacker will search for your watermark: just be afraid to drown in tons of code and drop this case.  If you are developing a visual application, then nothing prevents you from changing the color of a pixel hidden in the corner of a button in a God-forgotten dialog box.  The color of the pixel will be watermark.  Unfortunately, such a case is not always acceptable and it is more convenient for developers to use some kind of universal solution for implementing a watermark in an already compiled application.  Traditionally, this function is embedded in obfuscators. <br><a name="habracut"></a><br><h4>  How will a hacker fight Watermark? </h4><br>  So, we need a universal solution for inserting watermarks into the application.  Versatility imposes serious limitations because we are not going to write artificial intelligence, which will determine which pixel can be tinted, for example.  At first glance, you might think: ‚ÄúSo there are so many places where you can write some data unnoticed.  Choose any! ‚ÄùBut let's not hurry. <br><br>  Imagine that a hacker is a smart hacker and he knows for sure that there are watermarks in the application and they need to be found and neutralized, leaving the application working.  Suppose, after another attempt to remove a watermark, he can somehow find out whether the developers were able to read the watermark or not (and we don‚Äôt feel sorry).  Successively, the hacker will perform the following attacks: <br><br><ul><li>  Disassemble / assemble the application.  Here all methods breaking the watermark into different secret places of the file will be broken off, in the hope that no one will guess.  Yes, it will not guess, but will delete. </li><li>  Pack / Obfuscate application.  All methods that do not require real execution of the program will be broken off here, as it is full of protectors, completely reassembling all the headers and erasing all the original data, and only large anti-virus companies have universal unpackers and we will not write this. </li><li>  An obfuscator will be involved, actively interfering with the intervention of the debager in the course of the program execution.  So connect to the application and put breakpoints in it, etc.  will not work. </li><li>  The hacker will find our watermark (it is sure to find it!) And hangs a bunch of his watermarks to overwrite the existing ones. </li><li>  The hacker will insert his watermark into his typical application consisting of a thousand knos and will see through our algorithm. </li><li>  The hacker will proceed to manual disassembly and, as he has been doing this for many years, he will see through the algorithm.  I propose to think that there is no panacea for this, they are such hackers. </li><li>  A hacker will write a static analyzer that searches all watermarks and tears them out. </li></ul><br>  As you can see from the last point of protection is not, but I would like to make it so that few hackers get to it. <br><br><h4>  How to be? </h4><br>  And what to do?  Is there a cure-all?  There is no final answer to this question, this problem is very voluminous and has been studied for a long time.  For example, look at the following review of academic studies on this topic: <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.103.8892%26rep%3Drep1%26type%3Dpdf">citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.8892&amp;rep=rep1&amp;type=pdf</a> . <br><br>  Nevertheless, there are two places that are relatively stable to changes that the application mercilessly exposes a hacker. <br><br><ul><li>  First place: application data.  Of course, not strings, since any obfuscator will encrypt them and in memory you will see them only for a moment. </li><li>  Second place: application code logic.  But note: it is the logic, since the hacker obfuscators will distort the code itself. </li></ul><br>  At this point, it becomes clear why watermarkers come bundled with obfuscators: there are few other types of programs that interfere with the application code so much. <br><br><h4>  Strategy </h4><br>  From the above, about hacker obfuscators and protectors (at least from hacker attack number two), it is clear that in order to read the watermark, you will have to start the application and somehow connect to it during operation.  We assume that a hacker can hang a protector, prohibiting debug, which means you need to touch the application very gently to extract the watermark.  The following options come to mind. <br><br><ul><li>  Insert code that generates some globally accessible object, a pipe, for example, and send a secret message on it.  Many applications have units of similar objects and the hacker will have no difficulty in figuring out which of them is a watermark (remember: the hacker must have already figured out our algorithm and knows where to look!). </li><li>  Insert code that generates a hidden file somewhere in the system, or an entry in the registry, or something else.  It has the disadvantages of the previous method, plus it is easy to understand that adding such logic to the application is fraught with all sorts of bad consequences. </li><li>  Insert the code that generates an array in the memory of the application that is not deleted by the garbage collector, which we will then find by scanning the application's memory.  Moreover, many objects can act as an array (MemoryWriter, for example), because when blindly reading from memory no one can figure out what it was originally.  So this is our method. </li></ul><br>  In general, the algorithm is simple: we add static ‚Äúarrays‚Äù to random types (recall that these are not necessarily arrays) select random methods and insert into them a code that generates a watermark message in the ‚Äúarray‚Äù (we make several of them so that the hacker had to sweat, finding all of them).  But you need to solve several important problems. <br><br><ul><li>  The code that generates the array is dead, since the array is not used after that and therefore statically, that is, without starting the program, can be detected by the hacker.  The array must be revived. </li><li>  Methods with a watermark are detected statistically by the presence of a large number of constant assignments to an array.  Solution: fill some pieces of watermark with the help of cycles. </li><li>  If you insert the code that generates a watermark into a performance-critical method, the speed of the application may drop significantly.  Solution: insert watermark only in relatively large methods. </li><li>  It is necessary to ensure that in blind reading of memory, we will not accept any random block of data as a watermark. </li><li>  Somehow it is necessary to counteract the attempts of the hacker to rub the watermark by imposing a hacker watermark. </li><li>  If a hacker finds one watermark, he must be made so that he cannot litter the application with pseudo-watermarks with garbage text. </li></ul><br>  A lot of problems, let's get started. <br><br><h4>  Message failure </h4><br>  In our watermark coder / decoder, we store an array of static signatures sig [i] (one hundred pieces, for example) - random arrays of 100 bytes each.  They do not change from version to version and are not a secret.  We rely on the SHA256 hash algorithm (this is like MD5 and SHA1 is only better), it will ensure that there are no collisions in the memory and solve a few more problems.  I recall, it is not known fast algorithms in order to HASH hash to find the string STR such that SHA256 (STR) = HASH.  The second pillar on which the fairmark will hold is the Rijndael (AES) algorithm.  Let me remind you, if KEY is a secret key for encryption / decryption, then unknown effective algorithms like not knowing KEY from the AES (STR, KEY) line get STR. <br><br>  From the developer of the protected application you will need a password that is secret and should be carefully stored in a safe.  When the user enters the password PASS and the message MSG to create a watermark, we generate sequentially: <br><br><ul><li>  Individual signatures: indSig [i] = SHA256 (sig [i] + PASS + salt), where sig [i] is the i-th signature and salt is a little salt to strengthen the password; </li><li>  We generate a short message signature: MsgSig = SHA256 (PASS + salt) [0..3] (only the first four bytes of the hash). </li><li>  We calculate the individual key KEY [i] = SHA256 (indSig [i] + PASS + salt); </li><li>  For each individual signature indSig [i] prepare the message encrypted using the AES algorithm, indMsg [i] = AES (MsgSig + MSG, KEY [i]); </li><li>  Generate Watermark [i] = indSig [i] + &lt;indMsg [i] .Length&gt; watermarks + indMsg [i] watermarks, where &lt;indMsg [i] .Length&gt; are four bytes of indMsg [i]. </li></ul><br>  Everything!  Watermark Watermark [i] is ready to use at randomly selected program locations. <br><br>  To read watermarks from memory, we also generate indSig [i] with a password and look for the memory of the watermark process indSig [i].  Then, using the key KEY [i] = SHA256 (indSig [i] + PASS + salt), we decrypt the secret message following indSig [i].  Do not forget to check that the first four bytes of the message are equal to MsgSig = SHA256 (PASS + salt) [0..3]. <br><br>  The SHA256 algorithm with its ability to withstand collisions ensures that a random data block will not be mistaken for a watermark.  Without knowing the password, the hacker will not be able to rub the watermark, which is again guaranteed by the anti-collisionality of SHA256.  Having found one watermark without having a password, the hacker cannot create a trash message or even read a watermark message, which is guaranteed by the Rijndael algorithm and a short message signature.  According to the watermark found, the hacker will not be able to find the remaining watermarks without a password, for which individual signatures and keys are generated.  As a result, we solved problems 4, 5 and 6, described earlier. <br><br><h4>  Array Renewal </h4><br>  In order to stop watermark arrays from being dead data, we involve them in calculations performed in random methods.  In this case, even after finding a watermark, it cannot simply be deleted without affecting the performance of the application.  For example, suppose somewhere in a certain method was: <br><br> <code>return baseOffset + 55;</code> <br>  Let the watermark array MyClass.WatermarkArr contain the number 55 in the cell MyClass.WatermarkArr [42].  Then the code above will turn into: <br><br> <code>return baseOffset + MyClass.WatermarkArr[42];</code> <br>  Everything looks good, but who can guarantee that at the time the code is executed, the watermark array is already created?  To figure this out, we are building a control flow method graph.  Such a construction involves a lot of difficulties, because the methods are invoked via Wpf, Reflection, using virtual calls, static constructors, and so on.  We try to analyze as many cases as possible and reinsure wherever possible, using our own .NET code emulator for this. <br><br><h4>  Conclusion </h4><br>  Watermark is a very effective method to identify a user and / or a specific assembly.  Of course, this method, like any other, has its limitations.  In particular, you cannot pre-assemble one distribution kit for all your users (although in the case of SaaS obfuscator this problem is less relevant - you can obfuscate the program on the fly, just before downloading).  On the other hand, for large individual products, the use of such protection is more than justified, because users, knowing in advance that they are being watched, will be much more reluctant to transfer your intellectual property to third parties. <br><br>  <i>Publication author: Dmitry Kosolobov, <a href="http://appfuscator.com/">Appfuscator</a> developer.</i> </div><p>Source: <a href="https://habr.com/ru/post/193666/">https://habr.com/ru/post/193666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193650/index.html">How to buy a 3D printer in China, or Toy for $ 1000</a></li>
<li><a href="../193654/index.html">Application of EDS in SAP NetWeaver web templates</a></li>
<li><a href="../193658/index.html">Applying local binary patterns to solving face recognition tasks</a></li>
<li><a href="../193660/index.html">Media Center from MacMini and Rapsberry PI</a></li>
<li><a href="../193662/index.html">Sharing SAML 2.0 SSO Integration Experience</a></li>
<li><a href="../193668/index.html">Straight lines in a hexagonal raster</a></li>
<li><a href="../193670/index.html">Autonomous operation of the smartphone: "intelligible" comparative guide</a></li>
<li><a href="../193672/index.html">Pandorama BigData Infrastructure and Protecting Its Data from Failure</a></li>
<li><a href="../193674/index.html">Profiler in MarkLogic Server</a></li>
<li><a href="../193676/index.html">How to make so as not to be confused pizza? Pizzeria tracker interfaces and their features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>