<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java place in the HFT world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the article, the author tries to analyze why there are trading systems written in Java. How can Java compete in high performance with C and C ++? T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java place in the HFT world</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/e87/f57/89d/e87f5789da254fc7b72bf55ed8bc7fb7.jpg"></div><br>  In the article, the author tries to analyze why there are trading systems written in Java.  How can Java compete in high performance with C and C ++?  Then there are some small thoughts about the advantages and disadvantages of using Java as a programming language / platform for developing HFT systems. <br><a name="habracut"></a><br>  A small disclaimer: the world of Java is broad, and in the article I will mean HotSpot, the implementation of Java, unless otherwise stated. <br><br><h2>  1. Introduction </h2><br>  I want to tell a lot about the place of Java in the world of HFT.  To begin with, let's define what HFT (High Frequency Trading) is.  This term has several definitions explaining its various aspects.  In the context of this article, I will stick to the explanation given by Peter Lauri (Peter Lawrey), creator of the Java Performance User's Group: ‚ÄúHFT is a trade that is faster than a person‚Äôs reaction rate (faster than a human can see)‚Äù. <br><br>  HFT trading platforms can analyze different markets simultaneously and are programmed to conduct transactions in the most appropriate market conditions.  The progressive technology used makes it possible to process data incredibly quickly thousands of transactions per day, while extracting only a small profit from each transaction. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This definition covers the entire electronic automated trading with characteristic times of hundreds of milliseconds and less, up to microseconds.  But if the speeds are reached in units of microseconds, then why do we need systems that are an order of magnitude slower?  And how can they make money?  The answer to this question consists of two parts: <br><br><ol><li>  The faster the system should be, the simpler the model should be.  Those.  If our trading logic is implemented on FPGA, then you can forget about complex models.  And vice versa, if we write code not on FPGA or plain assembler, then we should lay more complex models in the code. </li><li>  Network latency.  It makes sense to optimize microseconds only when it can significantly reduce the total processing time, which includes network delays.  It's one thing when network delays are tens and hundreds of microseconds (if you work with only one exchange), and completely different - 20ms on each side to London (and even further to New York!).  In the second case, optimization of microseconds spent on data processing will not bring a noticeable reduction in the total response time of the system, which includes network latency. </li></ol><br>  Optimization of HFT systems in the first place pursues the reduction not of the total speed of information processing (throughput), but of the system response time to an external impact (latency).  What does this mean in practice? <br><br>  For optimization through throughput, the resulting performance over a long time interval (minutes / hours / days / ...) is important.  Those.  for such systems, it is normal to stop processing for some tangible period of time (milliseconds / second), for example, at the Garbage Collection in Java (hi, Enterprise Java!) if this does not entail a significant decrease in performance over a long time interval. <br><br>  When optimizing latency, first of all, the fastest response to an external event is interesting.  Such optimization leaves its mark on the means used.  For example, if for optimizing through throughput, OS kernel level synchronization primitives are usually used (for example, mutexes), then to optimize for latency, you often have to use busy-spin, as this minimizes the response time to an event. <br><br>  Having determined what HFT is, we will move on.  Where is the place of Java in this "brave new world"?  And how can Java be in speed with titans like C, C ++? <br><br><h2>  2. What is included in the concept of "performance" </h2><br>  As a first approximation, we divide all aspects of performance into 3 baskets: <br><br><ol><li>  CPU performance per se, or the execution speed of the generated code, </li><li>  Memory performance, </li><li>  Network performance. </li></ol><br>  Consider each component in more detail. <br><br><h3>  2.1.  CPU-performance </h3><br>  <b>First</b> , in the arsenal of Java there is the most important means for generating really fast code: the real profile of the application, that is, understanding which parts of the code are ‚Äúhot‚Äù and which are not.  This is critical for low-level code layout planning. <br><br>  Consider the following small example: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">1</span></span>) { goo(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { foo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚Ä¶; }</code> </pre> <br>  When generating code from a static compiler (which works in compile-time), there is physically no way to determine (if you do not take into account PGO) which option is more frequent: i == 1 or not.  Because of this, the compiler can only guess which generated code is faster: # 1, # 2, or # 3.  At best, the static compiler will be guided by some kind of heuristics.  And at worst, just the location in the source code. <br><br><div class="spoiler">  <b class="spoiler_title">Option 1</b> <div class="spoiler_text"><pre> <code class="hljs sql">cmpl $1, %edi je .L7 <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> goo <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span>: ... ret .L7: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo jmp <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Option # 2</b> <div class="spoiler_text"><pre> <code class="hljs sql">cmpl $1, %edi jne .L9 <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span>: ... ret .L9: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> goo jmp <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Option # 3</b> <div class="spoiler_text"><pre> <code class="hljs sql">cmpl $1, %edi je/jne .L3 <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo/goo jmp <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span>: .L3: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> goo/foo <span class="hljs-keyword"><span class="hljs-keyword">NEXT</span></span>: ‚Ä¶ ret</code> </pre> <br></div></div><br>  In Java, due to the presence of a dynamic profile, the compiler always knows which option to prefer and generates code that maximizes performance for the actual load profile. <br><br>  <b>Secondly</b> , in Java there are so-called speculative optimizations.  Let me explain by example.  Suppose we have the code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMyInterface impl)</span></span></span><span class="hljs-function"> </span></span>{ impl.doSmth(); }</code> </pre> <br>  Everything seems to be clear: a call to the virtual function doSmth should be generated.  The only thing that static C / C ++ compilers can do in this situation is to try to de-virtualize the call.  However, in practice, this optimization happens relatively rarely, since its implementation requires complete confidence in the correctness of this optimization. <br><br>  The Java compiler running when the application is running has additional information: <br><br><ul><li>  A full tree of currently loaded classes, on the basis of which it is possible to effectively conduct de-virtualization, </li><li>  Statistics about what implementation was called in this place. </li></ul><br>  Even if there are other implementations of the IMyInterface interface in the class hierarchy, the compiler will embed (inline) the implementation code, which will, on the one hand, get rid of a relatively expensive virtual call and perform additional optimizations on the other hand. <br><br>  <b>Third</b> , the Java compiler optimizes the program for the specific hardware on which it was run. <br><br>  Static compilers are forced to use only instructions of sufficiently ancient iron to ensure backward compatibility.  As a result, all modern extensions available in x86 extensions remain overboard.  Yes, you can compile under several instruction sets and, while running the program, do run-dispatching (for example, using ifunc's in LINUX), but who does this? <br><br>  The Java compiler knows on which particular hardware it is running and can optimize the code for this particular system.  For example, if the system supports AVX, then new instructions will be used, operating with new vector registers, which significantly speeds up the work of floating-point calculations. <br><br><h3>  2.2.  Memory performance </h3><br>  Let us single out several aspects of the memory subsystem's performance: memory access pattern, speed of allocation and memory allocation (release).  It is obvious that the issue of the speed of the memory subsystem is extremely extensive and cannot be fully exhausted by the 3 aspects considered. <br><br><h4>  2.2.1 Memory Access Pattern </h4><br>  In terms of the memory access pattern, the most interesting question is the difference in the physical location of objects in memory or the data layout.  And here C and C ++ languages ‚Äã‚Äãhave a huge advantage - after all, we can clearly control the location of objects in memory, and the differences from Java.  For example, consider the following code in C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> l; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> A a; B b; }; C c;</code> </pre> <br>  When compiling this code with the C / C ++ compiler, the fields of the subobject fields will be physically arranged in series, approximately as follows (we disregard the possible padding between the fields and the possible data-layout transformations produced by the compiler): <br><br><img src="https://habrastorage.org/web/38d/cb0/a4d/38dcb0a4dc6d4bcfa7768b39ed428943.png"><br><br>  Those.  an expression of the form 'return cai + cbl' will be compiled into such x86 assembler instructions: <br><br><pre> <code class="hljs perl">mov (%rdi), %rax ; &lt;&lt;  cai add ANY_OFFSET(%rdi), %rax ; &lt;&lt;  cbl    cai ret</code> </pre> <br>  Such simple code was achieved due to the fact that the object is located linearly in memory and the compiler at the stage of compiling the displacement of the required fields from the beginning of the object.  Moreover, when accessing the cai field, the processor will load the entire cache line with a length of 64 bytes, in which neighboring fields are likely to fall, for example, cbl. Thus, access to several fields will be relatively fast. <br><br>  How will this object be located when using Java?  Since the objects cannot be values ‚Äã‚Äã(as opposed to primitive types), but always referential, during execution, the data will be located in memory in the form of a tree structure, rather than a sequential memory area: <br><br><img src="https://habrastorage.org/web/de2/510/8d9/de25108d978346b1b9a774ff75ae5d48.png"><br><br>  And then the expression 'cai + cbl' will compile at best into something similar to such x86 assembly code: <br><br><pre> <code class="hljs perl">mov (%rdi), %rax ; &lt;&lt;    a mov <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rdx ; &lt;&lt;    b mov (%rax), %rax ; &lt;&lt;    i  a add (%rdx), %rax ; &lt;&lt;    l  b</code> </pre> <br>  We received an additional level of indirection when accessing data inside field objects, since the object of type C contains only references to field objects.  An additional level of indirection significantly increases the amount of data load from memory. <br><br><h4>  2.2.2.  Allocation rate </h4><br>  Java has a significant advantage over traditional languages ‚Äã‚Äãwith manual memory management (if you do not take the artificial case that all memory is allocated on the stack). <br><br>  Usually, Java uses so-called TLABs (Thread local allocation buffer), that is, memory areas that are unique to each thread.  Allocation looks like a decrease of the pointer indicating the beginning of free memory. <br><br>  For example, a pointer to the beginning of the free memory in TLAB indicates 0x4000.  To allocate, say, 16 bytes, you need to change the pointer value to 0x4010.  Now you can use the newly allocated memory in the range 0x4000: 0x4010.  Moreover, since access to TLAB is possible only from one thread (this is a thread-local buffer, as the name implies), there is no need for synchronization! <br><br>  In languages ‚Äã‚Äãwith manual memory management, operator new / malloc / realloc / calloc functions are usually used to allocate memory.  Most implementations contain resources that are shared between threads and are much more complex than the Java memory allocation method described.  In some cases, memory shortages or heap fragmentation (memory allocation) operations can take a long time, which can affect latency. <br><br><h4>  2.2.3.  Memory release speed </h4><br>  In Java, automatic memory management is used and the developer now does not have to manually release the previously allocated memory, as the Garbage collector does.  The advantages of this approach include the simplification of writing code, because there is less reason for a headache. <br><br>  However, this leads to not quite expected consequences.  In practice, the developer has to manage various resources, not only memory: network connections, connections to the DBMS, open files. <br><br>  And now, due to the lack of intelligible syntactic means of control over the life cycle of resources in the language, it is necessary to use rather cumbersome constructions such as try-finally or try-with-resources. <br><br>  Compare: <br><br>  Java: <br><br><pre> <code class="java hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Connection c = createConnection()) { ... } }</code> </pre> <br>  or so: <br><br><pre> <code class="java hljs">{ Connection c = createConnection(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { c.close(); } }</code> </pre> <br>  With what you can write in C ++ <br><br><pre> <code class="cpp hljs">{ Connection c = createConnection(); } <span class="hljs-comment"><span class="hljs-comment">//        scope'</span></span></code> </pre> <br>  But back to the release of memory.  For all garbage collectors shipped with Java, there is a Stop-The-World pause.  The only way to minimize its impact on the performance of the trading system (do not forget that we need optimization not by throughput, but by latency) is to reduce the frequency of any stops at the Garbage Collection. <br><br>  At the moment, the most commonly used way to do this is to "reuse" objects.  That is, when we no longer need an object (in C / C ++, we must call the delete operator), we write an object to a certain pool of objects.  And when we need to create an object instead of the operator new, refer to this pool.  And if there is a previously created object in the pool, then we take it out and use it as if it had just been created.  Let's see how it will look at the source code level: <br><br>  Automatic memory management: <br><br><pre> <code class="java hljs">{ Object obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); ..... <span class="hljs-comment"><span class="hljs-comment">//     ,     }</span></span></code> </pre> <br>  And with reuse of objects: <br><br><pre> <code class="java hljs">{ Object obj = Storage.malloc(); <span class="hljs-comment"><span class="hljs-comment">//     ... Storage.free(obj); //     }</span></span></code> </pre> <br>  The theme of reuse of objects, it seems to me, is not sufficiently covered and, of course, deserves a separate article. <br><br><h3>  2.3.  Network performance </h3><br>  Here, Java positions are quite comparable with traditional C and C ++ languages.  Moreover, the network stack (level 4 of the OSI model and below), located in the OS kernel, is physically the same when using any programming language.  All network stack performance settings that are relevant for C / C ++ are also relevant for a Java application. <br><br><h2>  3. Development and debugging speed </h2><br>  Java allows you to develop logic much faster due to much faster code writing speed.  Last but not least, this is a consequence of the rejection of manual memory management and the pointer-number dualism.  Indeed, it is often quicker and easier to configure the Garbage Collection to a satisfactory level than to catch numerous dynamic memory management errors.  Recall that errors when developing in C ++ often take a completely mystical turn: they are reproduced in a release assembly or only on Wednesdays (hint: in English, ‚ÄúWednesday‚Äù is the longest day of the week in writing).  Developing in Java in the overwhelming majority of cases goes without such an occult, and for every error you can get a normal stack trace (even with line numbers!).  Using Java in HFT allows you to spend significantly less time on writing the correct code, which entails an increase in the system's adaptation speed to constant changes in the market. <br><br><h2>  4. Summary </h2><br>  In the HFT world, how successful a trading system depends on is the sum of two parameters: the speed of the trading system itself and the speed of its development and development.  And if the speed of the trading system is a relatively simple and understandable criterion (at least it is clear how to measure), then the speed of development of the system is noticeably more difficult to assess.  You can imagine the speed of development as the sum of countless factors, among which are the speed of writing code and debugging speed and speed of profiling and convenience of tools and entry threshold.  Also, important factors are the speed of integration of ideas obtained from quantitative analysts (Quantitative Researchers), who, in turn, can reuse the code of the grocery trading system for data analysis.  As it seems to me, Java is a reasonable compromise between all these factors.  This language combines: <br><br><ul><li>  good enough speed; </li><li>  relatively low entry threshold; </li><li>  simplicity of tools (Unfortunately, for C ++ there are no development environments comparable to IDEA); </li><li>  possibility of simple reuse of code by analysts; </li><li>  simplicity of work under large technically complex systems. </li></ul><br>  Summarizing the above, we can summarize the following: Java in the HFT has its essential niche.  Using Java, not C ++, significantly speeds up the development of the system.  In terms of performance, Java performance can be comparable to C ++ performance, and in addition, Java has a set of unique optimization capabilities that are not available for C / C ++. </div><p>Source: <a href="https://habr.com/ru/post/331608/">https://habr.com/ru/post/331608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331596/index.html">Level editor for three in a row</a></li>
<li><a href="../331598/index.html">Phoenix Framework - Webpack instead of Brunch, deploy using Distillery and a little systemd</a></li>
<li><a href="../331600/index.html">Two in one: how to use vim and nano?</a></li>
<li><a href="../331604/index.html">How to create visual effects for games</a></li>
<li><a href="../331606/index.html">The digest of interesting materials for the mobile developer # 209 (June 19 - June 25)</a></li>
<li><a href="../331612/index.html">Limit the number of method executions per second</a></li>
<li><a href="../331614/index.html">Another example of asynchronous circuit synthesis: VME bus controller</a></li>
<li><a href="../331618/index.html">Image smoothing by Peron and Malik anisotropic diffusion filter</a></li>
<li><a href="../331620/index.html">Knowledge Base: 100 practical materials on safety, economics and IaaS tools</a></li>
<li><a href="../331624/index.html">How do retail companies evaluate the effectiveness of loyalty systems implementation in Russia and abroad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>