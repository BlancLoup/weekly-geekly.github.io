<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Motion Detection in FPGA Video Stream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 I have long been interested in the topic of video processing, only on the debug shawls of the 7th and 9th ARMs, this worked out very slowly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Motion Detection in FPGA Video Stream</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/962/8aa/aec/9628aaaec3174d568350ebabfe265fe3.jpg"></div><br><h3>  Foreword </h3><br>  I have long been interested in the topic of video processing, only on the debug shawls of the 7th and 9th ARMs, this worked out very slowly and this was not interesting. <br><br>  Currently, it is full of powerful multi-core iron and many libraries have been created for working with video, but my choice fell on FPGAs. <br><a name="habracut"></a><br>  This project originates 5 or 6 years ago, at a time when there was no Aliexpress and similar shops, where you can buy a digital camera module or a debug board with FPGA for ridiculous money.  The first version of the project was launched using the HV7131GP camera from a mobile phone on a homemade board, a display from Siemens S65 and a debug board from Terasic DE2.  Then 5 years the project was gathering dust on the shelf and on the disk. <br><br>  It looked like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/7bkddXssa9I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Subsequently, the Altera Cyclone II EP2C8F256 FPGA board and the OV7670 camera module were purchased specifically for this project.  After purchasing the board, it turned out that there was no documentation for it and the seller did not respond to the request.  Through a long network search, I found a project made on this board and borrowed assignments from it. <br><br><img src="https://habrastorage.org/files/5e2/881/90b/5e288190b50e4e7dae5eb68304204534.png" width="330" height="183" align="left"><br><img src="https://habrastorage.org/files/4fa/e03/41d/4fae0341d4454b1399694941cb9816a3.png" width="172" height="176"><br><br>  In this article I want to introduce the reader to methods of capturing an image from a camera, converting color space, zooming in, displaying an image through an HDMI interface and detecting the movement of objects in a video stream using FPGAs from Altera. <br><br>  I want to immediately note that programming an FPGA is not my main specialization, but, more than that, a hobby in my spare time.  Therefore, I may be mistaken in the conclusions made and my decisions may be far from optimal.  In the pursuit of Fmax, many sections of the code were written in such a way that they may seem redundant, strange, meaningless, and suboptimal. <br><br><h3>  Tools </h3><br>  As the main development environment, I chose HDL Designer from Mentor Graphics.  All graphic blocks and links between them are made in it.  For the synthesis and tracing used environment Quartus II from Altera. <br><br><h3>  Project structure </h3><br>  The structural scheme of the project is shown in the figure below.  It reflects only the main functional units, which will be discussed in detail below. <br><br><img src="https://habrastorage.org/files/f44/f5b/957/f44f5b9577424db7b9ed65cf85e28fe8.png"><br><br>  In HDL Designer, it looks like this: <br><br> <a href=""><img src="https://habrastorage.org/files/416/abf/d63/416abfd6389047ab8086484d57fe3bf9.png"><br></a> <br><br>  Not all project blocks are shown in the diagram.  they are on a higher level. <br><br> <a href=""><img src="https://habrastorage.org/files/946/ca8/d8e/946ca8d8ec8a4745a1993e6f8ea11d32.png"><br></a> <br><h3>  Capture module </h3><br><img src="https://habrastorage.org/files/417/d92/05d/417d9205d7494fb797f5832a9fc00858.png" width="180" height="250" align="left">  The video capture module accepts data from the pixel_data camera in the YCbCr 4: 2: 2 or RGB: 565 format and the frame and line sweep control signals hsync, vsync, translates them into the clk domain (50 MHz), generates the out_pixel_valid control signal and out_vclk and passes them to the data format conversion module.  Also, this module generates out_stat statistics on the number of received data for 1 frame.  Statistics can be read through the UART.  The module is controlled by an external capt_en data enable signal.  This signal is set by the camera setup module upon completion of the setup.  Verilog code: <br><br><div class="spoiler">  <b class="spoiler_title">Capture</b> <div class="spoiler_text"><pre><code class="hljs vhdl">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> hs_sync_1 &lt;= hsync;hs_sync_2 &lt;= hs_sync_1; vs_sync_1 &lt;= vsync;vs_sync_2 &lt;= vs_sync_1; vclk_sync_1 &lt;= pclk;vclk_sync_2 &lt;= vclk_sync_1; pixdata_sync_1 &lt;= pixel_data;pixdata_sync_2 &lt;= pixdata_sync_1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> reg vclk_old; always @(posedge clk)vclk_old &lt;= vclk_sync_2; wire vclk_posedge = (vclk_old == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>) &amp;&amp; (vclk_sync_2 == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>); reg sample_new,sample_hsync,sample_vsync; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] sample_pixel; always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sample_new &lt;= vclk_posedge; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vclk_posedge) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> sample_hsync &lt;= hs_sync_2; sample_vsync &lt;= vs_sync_2; sample_pixel &lt;= pixdata_sync_2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> reg last_vsync_sample,P2_vsync_triggered,P2_vsync_end_triggered; reg P2_sample_vsync,P2_sample_new,P2_sample_hsync; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] P2_sample_pixel; reg P2_new_frame,capt_done,capt_enable; always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (capt_en == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> || P2_vsync_triggered == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) capt_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> capt_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> last_vsync_sample &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>,P2_vsync_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; P2_vsync_end_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>,P2_new_frame &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; capt_done &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (capt_enable) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sample_new) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> last_vsync_sample &lt;= (sample_vsync<span class="hljs-comment"><span class="hljs-comment">/* &amp;&amp; capt_en*/</span></span>); P2_sample_pixel &lt;= sample_pixel; P2_sample_hsync &lt;= sample_hsync; P2_sample_vsync &lt;= sample_vsync; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> // Pipeline Step P2_sample_new &lt;= sample_new; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!P2_vsync_end_triggered) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((last_vsync_sample == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) &amp;&amp; (sample_vsync == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P2_vsync_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; P2_new_frame &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P2_vsync_triggered &amp;&amp; sample_vsync) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P2_vsync_end_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; P2_vsync_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; capt_done &lt;= ~capt_done; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> P2_vsync_end_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; P2_vsync_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P2_new_frame) P2_new_frame &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> last_vsync_sample &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>;P2_vsync_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; P2_vsync_end_triggered &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>;P2_new_frame &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>;capt_done &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br></div></div><br><h3>  Format conversion module </h3><br><img src="https://habrastorage.org/files/c9a/9b1/51c/c9a9b151cc8e4dfaa147971a5ffb2552.png" align="left">  The YCbCr 4: 2: 2 format is not very convenient for further work, since  the data follow in the following sequence: Y0 Cb0 Y1 Cr1 Y2 Cb2 Y3 Cr3 ... Therefore, we will convert it to the YCbCr 4: 4: 4 format.  In fact, the entire conversion is reduced to issuing Y Cb Cr data per 1 clock of the data_strob signal.  In Verilog it looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">YCbCr 4: 2: 2 =&gt; 4: 4: 4</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) pix_ctr &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pixel_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vclk) pix_ctr &lt;= pix_ctr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pix_ctr &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (pix_ctr) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> YYY &lt;= pixel_data; CCr &lt;= Crr; CCb &lt;= Cbb; Ypix_clock &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d1</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Cbb &lt;= pixel_data; YY &lt;= YYY; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d2</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> YYY &lt;= pixel_data; CCr &lt;= Crr; CCb &lt;= Cbb; Ypix_clock &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d3</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Crr &lt;= pixel_data; YY &lt;= YYY; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase assign data_strob = Ypix_clock; assign Y = YY; assign Cb = CCb; assign Cr = CCr;</code> </pre> <br></div></div><br><h3>  Color Space Conversion Module </h3><br><img src="https://habrastorage.org/files/ede/83a/5f8/ede83a5f8f2a47bfa97b42a9d0cac5c0.png" align="left">  In the end, we always work with data in the RGB format, so we need to get it from YCbCr.  This is done according to the formula of datasheet on camera: <br><br>  <b>R = Y + 1.402 (Cr - 128)</b> <b><br></b>  <b>G = Y - 0.714 (Cr - 128) - 0.344 (Cb - 128)</b> <b><br></b>  <b>B = Y + 1.772 (Cb - 128)</b> <br><br>  In Verilog language looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">YCbCr =&gt; RGB</b> <div class="spoiler_text"><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> PRECISION = <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> OUTPUT = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> INPUT = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> OUT_SIZE = PRECISION + OUTPUT; <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BUS_MSB = OUT_SIZE + <span class="hljs-number"><span class="hljs-number">2</span></span>; always @ (posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> R_int &lt;= <span class="hljs-number"><span class="hljs-number">22</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; G_int &lt;= <span class="hljs-number"><span class="hljs-number">22</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; B_int &lt;= <span class="hljs-number"><span class="hljs-number">22</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrb) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //R = Y + <span class="hljs-number"><span class="hljs-number">1.371</span></span>(Cr - <span class="hljs-number"><span class="hljs-number">128</span></span>) R_int &lt;= (Y_reg &lt;&lt; PRECISION)+(C1*(Cr_reg-<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d128</span></span>)); //G = Y - <span class="hljs-number"><span class="hljs-number">0.698</span></span>(Cr-<span class="hljs-number"><span class="hljs-number">128</span></span>)-<span class="hljs-number"><span class="hljs-number">0.336</span></span>(Cb-<span class="hljs-number"><span class="hljs-number">128</span></span>) G_int &lt;= (Y_reg &lt;&lt; PRECISION)-(C2*(Cr_reg-<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d128</span></span>))-(C3*(Cb_reg-<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d128</span></span>)); //B = Y + <span class="hljs-number"><span class="hljs-number">1.732</span></span>(Cb-<span class="hljs-number"><span class="hljs-number">128</span></span>) B_int &lt;= (Y_reg &lt;&lt; PRECISION)+(C4*(Cb_reg-<span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d128</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign R = (R_int[BUS_MSB]) ? <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d16</span></span> : (R_int[OUT_SIZE+<span class="hljs-number"><span class="hljs-number">1</span></span>:OUT_SIZE] == <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b00</span></span>) ? R_int[OUT_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:PRECISION] : <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>; assign G = (G_int[BUS_MSB]) ? <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d16</span></span> : (G_int[OUT_SIZE+<span class="hljs-number"><span class="hljs-number">1</span></span>:OUT_SIZE] == <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b00</span></span>) ? G_int[OUT_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:PRECISION] : <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>; assign B = (B_int[BUS_MSB]) ? <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d16</span></span> : (B_int[OUT_SIZE+<span class="hljs-number"><span class="hljs-number">1</span></span>:OUT_SIZE] == <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b00</span></span>) ? B_int[OUT_SIZE-<span class="hljs-number"><span class="hljs-number">1</span></span>:PRECISION] : <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>;</code> </pre> <br></div></div><br><h3>  RGB format conversion module: 24 to RGB: 565 </h3><br><img src="https://habrastorage.org/files/2f8/838/a46/2f8838a46b6b4369b397a8ff7125766a.png" align="left">  This module makes us out of a 24-bit 16-bit RGB format.  It is convenient for us because  Takes up less space in memory, reduces bitrate, has color reproduction acceptable for our purposes and, most importantly, fits into one word of SDRAM data, which makes work much easier.  The data strobe signal is simply transmitted from the previous module. <br><br>  Module code is very simple: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> oRGB = {iR[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>], iG[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>], iB[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> ostrb = istrb;</code> </pre> <br><h3>  Rescaler </h3><br><img src="https://habrastorage.org/files/b4f/70e/d9b/b4f70ed9be44493e8389bb239311feef.png" align="left" width="250" height="180">  This module came to the project from the very beginning.  Its goal is to convert an input stream of 640x480 pixels into a stream of 320x240, 160x120, 128x120, 80x60 and 320x480.  These formats were needed to work with the LCD display from the Siemens S65, TFT display for the Arduino board and to implement image rotation in the FPGA and SDRAM block memory using the CORDIC algorithm.  In other words, this is the legacy of other projects.  In this project it is possible to change the screen resolution on-the-fly, and this module plays the first violin here.  The module also generates statistics on the amount of data per frame for debugging.  The module has been created for a long time and its code should be redeveloped, but while it works, we will not touch it. <br><br>  The module code is quite capacious, and in this article I will give only its main part: <br><br><div class="spoiler">  <b class="spoiler_title">Rescaler</b> <div class="spoiler_text"><pre> <code class="hljs scala">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) begin w_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;h_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; rsmp_w &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;rsmp_h &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resampler_init) begin w_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;h_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; rsmp_w &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>;rsmp_h &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin <span class="hljs-comment"><span class="hljs-comment">/* This case works ONLY if the input strobe is valid */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrb) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (w_ctr == <span class="hljs-type"><span class="hljs-type">I_WIDTH</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) begin w_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h_ctr == <span class="hljs-type"><span class="hljs-type">I_HEIGHT</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) begin h_ctr &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin h_ctr &lt;= h_ctr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>;frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsmp_h == <span class="hljs-type"><span class="hljs-type">H_FACT</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) begin rsmp_h &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin rsmp_h &lt;= rsmp_h + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; end end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin w_ctr &lt;= w_ctr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsmp_w == <span class="hljs-type"><span class="hljs-type">W_FACT</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) begin rsmp_w &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin rsmp_w &lt;= rsmp_w + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; end end end end reg pix_valid; always @(rsmp_w or rsmp_h or wh_multiply or <span class="hljs-type"><span class="hljs-type">H_FACT</span></span>) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wh_multiply == <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>) begin pix_valid = ((rsmp_w == <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>) &amp;&amp; (rsmp_h == <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>))?<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin pix_valid = ((rsmp_w == <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>) &amp;&amp; (rsmp_h != <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span> ))?<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end end assign pixel_valid = pix_valid; always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) begin frame_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resampler_init) begin frame_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (frame_start) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lcd_busy) frame_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame_enable &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end end end reg local_frame_start = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) begin ostrb_port &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; dout_port &lt;= <span class="hljs-number"><span class="hljs-number">17</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; local_frame_start &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> begin local_frame_start &lt;= frame_start ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>: local_frame_start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrb &amp;&amp; !resampler_init &amp;&amp; !lcd_busy) begin <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pixel_valid) begin <span class="hljs-comment"><span class="hljs-comment">// if our column and our row if (frame_enable &amp;&amp; !dout_dis) begin dout_port[16:0] &lt;= {local_frame_start, din[15:0]}; ostrb_port &lt;= 1'b1; local_frame_start &lt;= 1'b0; end else begin ostrb_port &lt;= 1'b0; end end else ostrb_port &lt;= 1'b0; end else ostrb_port &lt;= 1'b0; end</span></span></code> </pre> <br></div></div><br><h3>  FIFO IN </h3><br><img src="https://habrastorage.org/files/635/835/ef0/635835ef0adb454c99aac6346b00d1e9.png" align="left" width="250" height="130">  This is a two-blade FIFO dcfifo mega-function Altera 256x17.  The sixteenth bit - the frame_start signal is added for convenience of indicating the start of a new frame after rescaler. <br><br>  The write clock is 50 MHz, the read clock is 100 MHz, it is also a clock of the SDRAM controller. <br><br><h3>  Read-write controller </h3><br><img src="https://habrastorage.org/files/34a/a12/f19/34aa12f1925d420b8fbbc0994ff75e55.png" align="left" width="330" height="260">  This bulky module is a single writer who takes data from the FIFO IN module and writes it to SDRAM alternately in different memory areas for even and odd frames and two readers who read data from SDRAM, each from its own memory area and write it to the weekend FIFO.  Priority is given to readers, since they work on an HDMI controller with a frequency of 25 MHz (640x480), and he does not tolerate delays, there must always be data in the FIFO for processing and output to the screen.  The time left from filling the output FIFO is the time of the inactive screen area plus the emptying time of the FIFO, the writer works. <br><br>  When developing this module, I ran into a problem: if you use the FIFO signals full and empty, then the FIFO starts to fail and break the data.  This does not happen for FIFO IN.  The frequency of writing a block to it is significantly lower than the frequency of reading from it.  This bug is manifested at the weekend FIFO.  A write block of 100 MHz is 4 times as high as a read block of 25 MHz, which, according to my guesses, leads to the fact that the write pointer catches up with and overtakes the read pointer.  I found a mention in the network of a certain Alter FIFO bug, I don‚Äôt know if it is related to my problem or not.  The problem itself was solved without using the wr_full and rd_empty signals, but using the wrusedw and rdusedw signals.  I made a FIFO state controller for the fifo_almost_full and fifo_almost_empty circuits.  It looks like this: <br><br><pre> <code class="hljs erlang-repl">// FIFO <span class="hljs-number"><span class="hljs-number">1</span></span> wire out_fifo_almost_full = &amp;fifo_wr_used[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]; wire out_fifo_almost_empty = !(|fifo_wr_used[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>]); // FIFO <span class="hljs-number"><span class="hljs-number">2</span></span> wire out_fifo_almost_full_2 = &amp;fifo_wr_used_2[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]; wire out_fifo_almost_empty_2 = !(|fifo_wr_used_2[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>]);</code> </pre> <br>  Also, the module implements the change of operation modes: Background Subtraction or Frame Difference.  This is achieved by the learning signal, which is connected to the clock button on the board. <br><br>  I will not give all the module code, there is quite a lot of it and there is no know-how there.  This module operates at a 100 MHz SDRAM frequency. <br><br><h3>  SDRAM controller </h3><br><img src="https://habrastorage.org/files/a76/1e7/78f/a761e778fc904daab5404381897fc5aa.png" align="left" width="290" height="230">  The module from the site <a href="http://www.fpga4fun.com/SDRAM2.html">fpga4fun.com</a> was taken as a <a href="http://www.fpga4fun.com/SDRAM2.html">basis</a> and was slightly modified for our type of SDRAM K4S561632 chip with the addition of chip initialization and additional delays to comply with the time frame: <br><br>  <i>Row active to row active delay: tRRD 15 n sec and</i> <i><br></i>  <i>Row precharge time: tRP 20 n sec</i> <br><br>  The module code can be downloaded from the website at the link above.  The main problem was the writing of the constraints in TimeQuest for the correct operation of our SDRAM and the selection of the phase shift of the clock by the pin SDRAM_CLK with the PLL.  Otherwise, everything worked right away.  Writing and reading is done by bursts, only one active bank for 4 megaslova is used, no refresh is used. <br><br><h3>  FIFO OUT </h3><br><img src="https://habrastorage.org/files/e77/3df/acf/e773dfacf6af42eb900db2977d7febb2.png" align="left" width="200" height="180">  As in the case of FIFO IN, these FIFOs are two-fold mega-functions of 1024x16 dcfifo. <br><br>  The write clock is 100 MHz, the read clock is 25 MHz. <br><br><br><br><br><br><h3>  Motion Detector </h3><br><img src="https://habrastorage.org/files/fa4/e53/ac0/fa4e53ac086843508235d0553a8cbd18.png" align="left">  So we got to the module, which is the salt of the earth of this project.  As you can see, it receives data and control signals from both output FIFOs, a slice of the HDMI 25 MHz controller pixel_clock, pixel counters counter_x, counter_y and a signal from the active display area of ‚Äã‚Äãthe blank.  RGB signals come out of it, ready for display on the display. <br><br><br><br><br><br><br>  It also implements the FIFO occupancy chains: <br><br><pre> <code class="hljs erlang-repl">// FIFO <span class="hljs-number"><span class="hljs-number">1</span></span> wire in_fifo_data_avail = |fifo_rd_used[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]; wire in_fifo_almost_empty = !(|fifo_rd_used[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]); // FIFO <span class="hljs-number"><span class="hljs-number">2</span></span> wire in_fifo_data_avail_2 = |fifo_rd_used_2[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]; wire in_fifo_almost_empty_2 = !(|fifo_rd_used_2[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>]); wire fifos_available = in_fifo_data_avail &amp; in_fifo_data_avail_2; wire fifos_almost_empty = in_fifo_almost_empty | in_fifo_almost_empty_2;</code> </pre> <br>  We need to control the area of ‚Äã‚Äãthe screen in which we display the picture from the camera: <br><br><pre> <code class="hljs scala">wire in_frame = ((counter_x &lt; <span class="hljs-type"><span class="hljs-type">RES_X</span></span>) &amp;&amp; (counter_y &lt; <span class="hljs-type"><span class="hljs-type">RES_Y</span></span>))?<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; wire frame_start = ((counter_x == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (counter_y == <span class="hljs-number"><span class="hljs-number">0</span></span>))?<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>;</code> </pre> <br>  Both FIFOs are read simultaneously by the data availability flag in both of them: <br><br><pre> <code class="hljs vhdl">// Reader FIFO <span class="hljs-number"><span class="hljs-number">1</span></span> &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> always @(posedge pix_clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fifo_rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; fifo_rd_req_2 &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; pixel_data &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0000</span></span>; worker_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (worker_state) <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (in_frame) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fifos_almost_empty) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //worker_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1</span></span>; fifo_rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; fifo_rd_req_2 &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pixel_data &lt;= fifo_data; pixel_data_2 &lt;= fifo_data_2; fifo_rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; fifo_rd_req_2 &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fifo_rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; fifo_rd_req_2 &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blank) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> worker_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // start reading <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> more than <span class="hljs-number"><span class="hljs-number">16</span></span> words are already <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the fifo <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fifos_available &amp;&amp; frame_start) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> fifo_rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; fifo_rd_req_2 &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; worker_state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h0</span></span>; nd <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The data read from FIFO has the format RGB: 565, for our purposes it should be converted to a black and white representation.  This is done like this: <br><br><pre> <code class="hljs pgsql">// Convert <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> grayscale frame <span class="hljs-number"><span class="hljs-number">1</span></span> wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] R1 = {pixel_data[<span class="hljs-number"><span class="hljs-number">15</span></span> : <span class="hljs-number"><span class="hljs-number">11</span></span>], pixel_data[<span class="hljs-number"><span class="hljs-number">15</span></span> : <span class="hljs-number"><span class="hljs-number">13</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] G1 = {pixel_data[<span class="hljs-number"><span class="hljs-number">10</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span>], pixel_data[<span class="hljs-number"><span class="hljs-number">10</span></span> : <span class="hljs-number"><span class="hljs-number">9</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] B1 = {pixel_data[<span class="hljs-number"><span class="hljs-number">4</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>], pixel_data[<span class="hljs-number"><span class="hljs-number">4</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] GS1 = (R1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)+(R1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>)+(G1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)+(G1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+(B1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+(B1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); // Convert <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> grayscale frame <span class="hljs-number"><span class="hljs-number">2</span></span> wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] R2 = {pixel_data_2[<span class="hljs-number"><span class="hljs-number">15</span></span> : <span class="hljs-number"><span class="hljs-number">11</span></span>], pixel_data_2[<span class="hljs-number"><span class="hljs-number">15</span></span> : <span class="hljs-number"><span class="hljs-number">13</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] G2 = {pixel_data_2[<span class="hljs-number"><span class="hljs-number">10</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span>], pixel_data_2[<span class="hljs-number"><span class="hljs-number">10</span></span> : <span class="hljs-number"><span class="hljs-number">9</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] B2 = {pixel_data_2[<span class="hljs-number"><span class="hljs-number">4</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>], pixel_data_2[<span class="hljs-number"><span class="hljs-number">4</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>]}; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] GS2 = (R2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>)+(R2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>)+(G2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)+(G2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+(B2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)+(B2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  The <b>GS1</b> and <b>GS2</b> signals are our black and white presentation. <br><br>  Now a little about the algorithms.  There are many ways to detect motion.  In this article I will consider only two of them, in my opinion, the simplest and most easily implemented in the framework of this project. <br><br><h4>  Method one.  Background subtraction. </h4><br>  The idea is that to find a motion or an object in a video stream, subtraction is used: <br><br>  <b>P [F (t)] = P [I (t)] - P [B]</b> <br><br>  P [F (t)] - the resulting difference, <br>  P [I (t)] - the current frame from the camera, <br>  P [B] - reference frame or background <br><br>  Reference frame or background is usually done when there is no movement.  For example, if we want to detect movement in one corner of a room, then before that we must make and remember a snapshot of this angle when there is no movement there, and then subtract this pixel by pixel-by-pixel from all subsequent snapshots.  Everything is very simple.  However, due to noise in the image, automatic white balance in the camera and other factors, we need to apply the detector trigger threshold.  This threshold applies to frame difference.  If the difference is greater than the threshold, then there is movement, otherwise - no. <br><br>  P [F (t)]&gt; Threshold <br><br>  There are more disadvantages to this method than advantages, however, it is used to detect movement because of its ease of implementation.  Disadvantages are: <br><br><ul><li>  Light dependence </li><li>  Dependence on camera shift </li><li>  Dependence on weather conditions </li><li>  Effect of auto white balance </li></ul><br>  Any change in external factors will lead to motion detection and false triggering of the detector. <br><br>  Figuratively, the detector circuit looks like this: <br><br><img src="https://habrastorage.org/files/55b/561/e76/55b561e76dc349feaabfa733e0dd8675.png" width="415" height="220"><br><br><h4>  The second way.  Frame difference </h4><br>  This method of implementation is not much different from the previous one.  All the differences lie in the fact that instead of the background, the previous frame is subtracted from the current frame and the difference is compared with the Threshold threshold. <br><br>  The mathematical representation is as follows: <br><br>  <b>P [F (t)] = P [I (t)] - P [I (t - 1)]&gt; Threshold</b> <br><br>  The advantage of this method is the relative resistance to external factors.  Even with a change in camera position or illumination, this will not cause long-term false positives, but only a short-term one within two consecutive frames. <br><br>  Disadvantages are: <br><br><ul><li>  Frame rate dependence </li><li>  Inability to detect immovable objects </li><li>  Weak detection of objects with low speed </li></ul><br>  Due to the above disadvantages, this method has not found widespread use in its pure form. <br><br>  Implementation in the Verilog language. <br><br>  In our case, no matter what frame from which we subtract, the absolute difference between them is important to us. <br><br><pre> <code class="hljs vhdl">reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] difference = <span class="hljs-number"><span class="hljs-number">0</span></span>; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] max_val = (GS1 &gt; GS2) ? GS1 : GS2; wire [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] min_val = (GS1 &lt; GS2) ? GS1 : GS2; always @(posedge pix_clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (in_frame) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> difference &lt;= max_val - min_val; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> difference &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> wire [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] out_val = in_frame ? (difference &gt; `BS_THRESHOLD) ? <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'hF1_00</span></span> : pixel_data_2 : in_frame2 ? pixel_data_diff : <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'h00_00</span></span>;</code> </pre> <br>  As can be seen from the code, we replace the pixel with red (16'hF1_00), if the difference is greater than the <i>BS_THRESHOLD</i> threshold. <br><br>  To display on the screen, we need to convert data from the RGB format: 565 to the RGB format: 24 <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// VGA 24 bit assign R = {out_val[15 : 11], out_val[15 : 13]}; assign G = {out_val[10 : 5], out_val[10 : 9]}; assign B = {out_val[4 : 0], out_val[4 : 2]};</span></span></code> </pre> <br><h3>  HDMI controller </h3><br><img src="https://habrastorage.org/files/1bb/3af/a5f/1bb3afa5f17443f9b02c19e3b0476259.png" align="left" width="200" height="220"><br><img src="https://habrastorage.org/files/c67/de7/3ed/c67de73edeee486880702ef28f6e051f.png" width="300" height="100"><br><br>  Part of this module was taken from the same site <a href="http://www.fpga4fun.com/HDMI.html">fpga4fun.com</a> and converted according to an <a href="https://marsohod.org/projects/proekty-dlya-platy-marsokhod3/307-max10-hdmi">article from the site marsohod.org</a> .  Instead of using diff.  LVDS pairs I used DDIO megafunction.  For what it is done, you can read by reading the article on the link above. <br><br><h3>  Clocks </h3><br><img src="https://habrastorage.org/files/992/675/470/9926754700a54cf29050df606c5da8e5.png" align="left"><br><img src="https://habrastorage.org/files/203/3b0/f8e/2033b0f8ea9d41ed8695dfd359d857de.png"><br><br>  A system clock frequency of 50 MHz is taken from the generator on the board.  Shreds are made from it for the SDRAM controller and the SDRAM chip.  These clocks have the same frequency of 100 MHz, but are shifted in phase by 90 degrees.  For this, the mega-function PLL is used <br><br>  The 125 MHz clock (clk_TMDS2) is used for DDIO, after which it turns into 250 MHz.  Such is the trick. <br><br>  The video data pixel_clock is equal to 25 MHz, it is done by dividing by 2 system clock 50 MHz. <br><br><h3>  Camera setup OV7670 </h3><br><img src="https://habrastorage.org/files/456/14f/d0a/45614fd0ae724fb19f8bdd55024fdb68.png" align="left">  A <a href="https://github.com/westonb/OV7670-Verilog/tree/master/src">third-party SCCB interface module is</a> used to configure the camera.  It is slightly modified for the needs of the project and is capable of recording camera register values ‚Äã‚Äãon-the-fly upon a command from the UART interface. <br><br><br><br><br><br><br><br><br><br><h3>  UART </h3><br><img src="https://habrastorage.org/files/4a8/aa9/372/4a8aa93728964144a452ca58cd5f8992.png" align="left">  The module consists of a receiver and transmitter UART and module io_controller <br><br>  The code of the receiver and transmitter modules was taken from the Internet.  The modules operate at 115200 baud with 8N1 settings. <br><br><br><br><br><br><br><img src="https://habrastorage.org/files/781/c07/504/781c0750468c44c6a3497ec6f8120d7d.png" align="left"><br>  This module (io_controller) is the link between the UART transceiver and external modules of the project.  It provides statistics output to the UART, receiving and processing commands.  With it, you can change the display resolution, change the output format of the camera (YCbCr or RGB), record any of its registers and output any requested statistics. <br><br><br><h3>  Video demonstration of the result </h3><br><div class="spoiler">  <b class="spoiler_title">Video quality</b> <div class="spoiler_text">  I apologize for the quality of the video, this is my phone. <br></div></div><br>  <b>Video 1. Frame Difference</b> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vMcSStQvuTw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The left side of the screen displays the image from the camera in 320x240 format, and on the right is the threshold frame difference.  The left image is tinted red in places where we detected movement. <br><br>  The video shows that when the object is stopped, the movement is not detected, and when the speed of the object decreases, it is detected much worse. <br><br>  <b>Video 2. Background Subtraction</b> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w2mqw74Qisc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  You can see that as the object approaches the camera, the white balance changes and we get a false trigger of the detector.  Such phenomena can be filtered or compensated.  One of the compensation methods is the training with the averaging of the reference image (Approximate Median Filter). <br><br><h3>  findings </h3><br>  This development can and should be improved by complicating the detection algorithms.  It would also be nice to implement tracking of moving objects by drawing a rectangular frame around the object. <br><br>  The video has horizontal rectangles.  This phenomenon is associated with a read bug from the SDRAM controller, which I have not yet been able to completely overcome. <br><br><h3>  Materials on the topic </h3><br>  ‚Üí <a href="https://habrahabr.ru/post/321618/">Article about motion detection on OpenCV</a> <br>  ‚Üí <a href="https://habrahabr.ru/company/avi/blog/200804/">Yet another detector on OpenCV</a> <br>  ‚Üí <a href="https://www.ics.uci.edu/~dramanan/teaching/cs117_spring13/lec/bg.pdf">Background subtraction</a> <br>  ‚Üí <a href="http%253A%252F%252Fgiapjournals.com%252Findex.php%252Fijimc%252Farticle%252Fdownload%252F438%252F388%26usg%3DAFQjCNHa9SxhjeRgxoOzG6pgAHXluDIs0A">Methods to improve detection</a> <br><br><h3>  <b>UPD</b> </h3><br>  <i><b>As promised, I publish the project.</b></i>  <i><b>Available on Yandex disk.</b></i>  <i><b>This is a copy of the project made in Quartus, while I‚Äôm not going to upload it to HDL Designer, it‚Äôs unlikely that it will run for anyone even if I post it.</b></i> <br>  <a href="https://yadi.sk/d/5x1Ld-EZ3GFikt">reference to the project</a> </div><p>Source: <a href="https://habr.com/ru/post/323258/">https://habr.com/ru/post/323258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323246/index.html">I prepare CentOS 6.8 for work</a></li>
<li><a href="../323250/index.html">PVS-Studio security research</a></li>
<li><a href="../323252/index.html">Python program for statistical text analysis</a></li>
<li><a href="../323254/index.html">Backbone projects of telecommunications giants and maps of underwater communication channels</a></li>
<li><a href="../323256/index.html">DariaDB. Database development for storing time series</a></li>
<li><a href="../323260/index.html">Women's Day Gift by FPGA</a></li>
<li><a href="../323262/index.html">Implementing HQoS on Juniper MX80 / MX104 fixed ports</a></li>
<li><a href="../323266/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ252 (March 27 - 5, 2017)</a></li>
<li><a href="../323268/index.html">8 best extensions for WordPress to improve the menu on your site</a></li>
<li><a href="../323270/index.html">Forms and custom input fields in Angular 2+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>