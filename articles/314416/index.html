<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to solve the problem of limitations in 64K methods in Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Can you imagine an Android game made in Unity that uses more than 64K Java methods? Could not this and the architects of the byte code Dalvik . Perhap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to solve the problem of limitations in 64K methods in Unity3D</h1><div class="post__text post__text-html js-mediator-article">  Can you imagine an Android game made in Unity that uses more than 64K Java methods?  Could not this and the architects of the <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html">byte code Dalvik</a> .  Perhaps they succeeded (I did not read the specifications), and other elements of the toolchain should be blamed.  Be that as it may, if your game exceeds the limit of 64K methods on a DEX file, you will have to poke around in your native plugins and / or build process.  This post is an attempt to show different ways to solve the problem. <br><a name="habracut"></a><br><h1>  Start over </h1><br>  There are very few <a href="https://www.contentful.com/blog/2014/10/30/android-and-the-dex-64k-methods-limit/">posts on forums and blogs on</a> this topic.  The most important conclusion is that if you manage to stay well below this number, it will save you from a lot of problems. <br><br><h3>  Understand your plugins </h3><br>  The most likely way to exceed this limit in Unity is to use native plugins.  Native Android plugins are required in almost all Unity games.  Unfortunately, some plugins are quite large.  For example, <a href="https://github.com/playgameservices/play-games-plugin-for-unity">Google Play Game Services</a> itself contains almost 25K methods.  This is a significant chunk of 64K that you are limited to. <br><br><h3>  Super brief introduction to Android plugins under Unity </h3><br>  Android Unity plugins usually consist of Unity C # code and native Android code and resources.  Native code and resources are packaged either as an Android library project (Library Project), or as an Android Archive archive (AAR) in the <code>Assets/Plugins/Android/</code> directory.  Project libraries are the old way to transfer components to the Android system, and AAR is a newer one.  You will encounter plugins using both methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Classes in both project libraries and AAR exist in JAR files, which are simple zip files from compiled Java class files.  The AAR file is also a simple zip of various Android resources.  Some of them will become <code>libs/*.jar</code> (also known as Java class archives).  Library projects are simple directory structures, and the JAR, again, will be in <code>libs/*.jar</code> . <br><br><h1>  Stages of minimizing the number of methods </h1><br>  The only way to reduce the number of Java methods contained in the game's APK using the standard Unity build system is to delete or modify the JAR files included with the native Android plugins.  An alternative way is to export the Unity project as an Android project, in which more powerful technologies can be applied. <br><br>  Try each of the following techniques in turn: <br><br><ul><li>  Remove all plugins that are not used by the game. </li><li>  Google has broken Play Services into a set of modules.  Use only those that you really need. </li><li>  Use the <a href="https://code.google.com/archive/p/jarjar/">Jar Jar Links</a> tool with the zap rule to remove unnecessary classes from JAR files of plugins. </li><li>  Export the project as an Android project to apply ProGuard or MultiDex.  But this method is quite dangerous. </li></ul><br>  Most blog posts focus only on the last paragraph, because at the time of writing there were not many resources that could help with this approach.  Exporting to an Android project has a more negative impact on the development cycle and builds.  As long as ProGuard and MultiDex are not directly supported in Unity, it‚Äôs better to use this method as a last resort. <br><br><h3>  What to look for when testing </h3><br>  When your game stops violating the 64K limit and you can generate the APK file again, the most important thing to look for in a <a href="https://developer.android.com/studio/command-line/logcat.html">logcat</a> when testing a game is the errors <code>ClassNotFoundException</code> and <code>VerifyError</code> .  They mean that your code is trying to use an inaccessible class or method.  Usually, an error causes the application to crash, so it will be pretty obvious.  However, sometimes the plugin can continue to work without failure.  In this case, some functions in the availability of which you are sure will not work correctly. <br><br><h1>  ProGuard and MultiDex </h1><br>  <a href="http://proguard.sourceforge.net/">ProGuard</a> is a tool used to obfuscate and remove unused classes and methods.  <a href="https://developer.android.com/studio/build/multidex.html">MultiDex</a> is a technology that allows you to use multiple DEX files in your APK, thus removing the limit of 64K methods in the game.  Unity does not directly support these technologies, but you can use them by exporting a project as an Android project. <br><br>  If nothing else helps, ProGuard can help lower the maximum limit.  If this fails, use MultiDex.  MultiDex has another limitation - it works only in API Level 14 (4.0) and higher.  It is natively supported in Android (5.0) and higher.  For versions 4.X you need to use support libraries.  In addition, MultiDex has a list of <a href="https://developer.android.com/studio/build/multidex.html">known limitations</a> . <br><br><h1>  Export to Android project </h1><br>  If you need ProGuard or MultiDex, the first step is to export the Unity project as an Android project.  If your project is complex enough, this in itself can be a daunting task.  Most likely, it will also mean the unavailability of Unity Cloud Build.  However, with the right process, it may look like exporting to Xcode for iOS.  After export, you need to set up an Android Studio or Gradle project, but this will be a one-time task.  Re-exporting the project does not require new configuration of the Android assembly configuration. <br><br>  I found three ways to successfully work with a project exported to Android.  In brief, I will describe the first two, because they are simpler, and may be preferred if the project is not too complicated.  The latter approach requires a little more manual setup, but this is probably the cleanest way to organize a project.  It may also be the only option if you need MultiDex. <br><br><h3>  A couple of words of caution </h3><br>  Even after exporting the game to Android Studio, the plugins used by your game may depend on Unity post-processing scripts that are not translated into Android Studio or Gradle builds.  This may lead you to a dead end. <br><br><h1>  First way: simple export from Unity and import to Android Studio </h1><br>  This method is suitable for games that do not use a lot of plug-ins.  I hope that Unity and Android Studio will continue to improve this way. <br><br><ol><li>  In the <em>File -&gt; Build Settings -&gt; Android</em> section, select the <em>Google Android Project</em> checkbox and click the <em>Export</em> button.  Create or select a directory to export.  I recommend choosing the Android directory. </li><li>  Open Android Studio and select <em>Import project (Eclipse ADT, Gradle, etc.)</em> .  Navigate to the exported Unity project, which will be located in the subdirectory of the export directory (for example, <code>./Android/Your Unity Project</code> ). </li><li>  Select destination directory.  All options can be left as is. </li></ol><br>  After that, if everything went well, you can run the project in Android Studio. <br><br><h3>  Advantages and disadvantages </h3><br><ul><li>  <strong>Plus</strong> : this is an easy way. </li><li>  <strong>Plus</strong> : the imported Android Studio project is also a standard Gradle project, providing easy integration of tasks performed in Gradle. </li><li>  <strong>Minus</strong> : each time you export from Unity and import into Android Studio, a completely new project is created.  Any changes you make to the Studio project ‚Äî for example, setting up ProGuard ‚Äî must be made during each build.  This is quite a serious impact on the development cycle. </li><li>  <strong>Less</strong> : if the project is very complicated, it may simply not make money without significant changes in the project of Android Studio. </li></ul><br><h1>  Second way: import the exported Unity project from source </h1><br>  With this method, the exported Unity project is imported into Android Studio directly from the sources, and then manually updated various modules and dependencies.  The difference with the first method is that instead of importing <code>/Android/Your Unity Project</code> importing <code>/Android</code> , and Android Studio is trying to configure modules for the main application and projects of each exported library. <br><br>  The good side of this approach is that after setting up an Android Studio project, you can re-export a Unity project to the same directory.  In this case, in general, an update of the Android Studio project is not required. <br><br>  The disadvantage of this method is that the Android project will be associated with the files of the Android Studio project.  Configuring and configuring dependencies will be challenging. <br><br>  Since I want to focus on the third method, I‚Äôll just say that after transferring the project to Android Studio, connecting ProGuard is quite simple.  However, the process of setting up an Android Studio project involves correctly configuring each module and dependencies using the Android Studio interface.  If you haven't mastered the Android Studio project modules very well, this can be quite a tricky task.  In addition, configuring MultiDex through the interface of Android Studio seemed to me difficult, and this led me to the third method. <br><br><h1>  Third way: configuring the Gradle project for the exported Unity project </h1><br>  <a href="https://developer.android.com/studio/build/index.html">Gradle</a> is a build tool that was used in Android several years ago.  Android Studio projects can sync to Gradle projects.  While old Android Studio project modules are still supported, new projects are based on Gradle files.  In the third method, we will correctly configure the Gradle files for the exported Unity project, after which we will be able to work with them and perform builds from Android Studio or from the command line.  We will get access to such useful functions of Gradle, as ProGuard and MultiDex. <br><br><h3>  Setting Gradle Wrapper </h3><br>  Set up the Gradle Wrapper in the directory with the exported project with the following command: <br><br><pre> <code class="hljs pgsql">gradle <span class="hljs-keyword"><span class="hljs-keyword">wrapper</span></span> <span class="hljs-comment"><span class="hljs-comment">--gradle-version 2.14.1</span></span></code> </pre> <br>  Gradle comes with Android Studio, so you need to have some version of it installed.  The above command creates a <code>gradlew</code> script that binds your build script to a specific version of Gradle.  At the moment, it is well suited <code>2.14.1</code> . <br><br><h3>  Create root build.gradle file </h3><br>  In the same directory, create your top-level Gradle <code>build.gradle</code> file.  You can simply copy the following code: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    ,      ,      . buildscript { repositories { jcenter() } dependencies { classpath 'com.android.tools.build:gradle:2.2.0' } } allprojects { repositories { jcenter() } }</span></span></code> </pre> <br><h3>  Creating the build.gradle application file </h3><br>  Place the following file in the main project subdirectory created for the Unity project in the export directory (for example, <code>Android/Your Unity Project</code> ).  This file should also be called <code>build.gradle</code> . <br><br><pre> <code class="hljs pgsql">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span> dependencies { compile fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> buildToolsVersion "24" sourceSets { main { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'AndroidManifest.xml'</span></span> java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] resources.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] aidl.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] renderscript.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res'</span></span>] assets.srcDirs = [<span class="hljs-string"><span class="hljs-string">'assets'</span></span>] jniLibs.srcDirs = [<span class="hljs-string"><span class="hljs-string">'libs'</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/debug'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">release</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/release'</span></span>) } }</code> </pre> <br><h3>  Create file settings.gradle </h3><br>  In the root directory of the exported Android project, create a file <code>settings.gradle</code> with the following contents.  Of course, you need to replace <code>:Your Unity Project</code> with the name of the directory created by Unity for the exported project. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">':Your Unity Project'</span></span></code> </pre> <br>  If you have a super-simple Unity project without plug-ins, this will be enough for you.  In Android Studio, you can select the <em>Open an existing Android Studio project</em> .  Then find and open the <code>settings.gradle</code> file you created and work with the project in Android Studio.  You can also build a project from the command line as follows: <br><br><pre> <code class="hljs">./gradlew assembleDebug</code> </pre> <br>  You can view the entire Gradle build task list: <br><br><pre> <code class="hljs">./gradlew tasks</code> </pre> <br><h3>  But my project was not so simple. </h3><br>  There is a possibility that you are reading this, because your project was not so simple.  When exporting from Unity, in addition to the main application directory (for example, the <code>Android/Your Unity Project</code> ), the engine creates a directory for each library project and AAR used by native plugins.  AARs are extracted into the library's project format. <br><br>  Add the following file to each subdirectory of library projects created when exporting from Unity.  Name these files <code>build.gradle</code> . <br><br><pre> <code class="hljs pgsql">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span> dependencies { compile fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> buildToolsVersion "24" publishNonDefault <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> defaultConfig { minSdkVersion <span class="hljs-number"><span class="hljs-number">9</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> } sourceSets { main { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'AndroidManifest.xml'</span></span> java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res'</span></span>] assets.srcDirs = [<span class="hljs-string"><span class="hljs-string">'assets'</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/debug'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">release</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/release'</span></span>) } }</code> </pre> <br>  Then, in the <code>settings.gradle</code> file, add rules for each subdirectory. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">':appcompat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">':google-play-services_lib'</span></span></code> </pre> <br>  Finally, in the main application‚Äôs <code>build.gradle</code> file (for example, <code>Android/Your Unity Project/build.gradle</code> ), change the dependencies section to include library projects. <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) compile project(<span class="hljs-string"><span class="hljs-string">':google-play-services_lib'</span></span>) }</code> </pre> <br><h3>  Work with dependencies </h3><br>  In some cases, you may need one library project depending on another library project.  For example, this is what is displayed when the <code>MainLibProj</code> module from Google Play Game Services depends. <br><br><pre> <code class="hljs sql">.../MainLibProj/build/intermediates/manifests/aapt/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/AndroidManifest.xml:<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span><span class="hljs-number"><span class="hljs-number">-65</span></span>: AAPT: <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource</span></span> <span class="hljs-keyword"><span class="hljs-keyword">found</span></span> that matches the given <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-string"><span class="hljs-string">'value'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-string"><span class="hljs-string">'@integer/google_play_services_version'</span></span>).</code> </pre> <br>  There is no unambiguous and fast rule for interpreting such dependencies, but in the general case the name of the missing resource gives a sufficient hint.  In our case, <code>google_play_services_version</code> quite clearly to Google Play Game Services.  You can use <em>grep</em> to determine which of the modules of Google Play game services contain this value. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> -r google_play_services_version . ./MainLibProj/AndroidManifest.xml: android:value=<span class="hljs-string"><span class="hljs-string">"@integer/google_play_services_version"</span></span> /&gt; ... ./play-services-basement-<span class="hljs-number"><span class="hljs-number">9.4</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>/res/<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>/values.xml: &lt;integer name=<span class="hljs-string"><span class="hljs-string">"google_play_services_version"</span></span>&gt;<span class="hljs-number"><span class="hljs-number">9452000</span></span>&lt;<span class="hljs-regexp"><span class="hljs-regexp">/integer&gt;</span></span></code> </pre> <br>  We see that the resource is defined in <code>play-services-basement</code> , and it is referenced by <code>MainLibProj</code> .  Open <code>&lt;_&gt;/MainLibProj/build.gradle</code> and change the entry with the dependency as follows: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) compile project(<span class="hljs-string"><span class="hljs-string">':play-services-basement-9.4.0'</span></span>) }</code> </pre> <br>  Now Gradle knows that the <code>MainLibProj</code> module depends on <code>play-services-basement-9.4.0</code> . <br><br><h3>  Resolving Class Duplication Conflicts </h3><br>  When Unity exports plugins as library projects, the following errors often appear: <br><br><pre> <code class="hljs vbscript">Dex: <span class="hljs-keyword"><span class="hljs-keyword">Error</span></span> converting bytecode <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> dex: Cause: com.android.dex.DexException: Multiple dex files define Lcom/unity/purchasing/googleplay/BuildConfig;</code> </pre> <br>  The <code>BuildConfig</code> class <code>BuildConfig</code> generated by Android build tools.  They are often included when a plugin is constructed as AAR, and a duplicate is created during the build process, when AAR is converted to a library project and recompiled.  This error can be fixed by removing the class from the extended library project. <br><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">zip</span></span> -d <span class="hljs-type"><span class="hljs-type">GooglePlay</span></span>/libs/classes.jar <span class="hljs-string"><span class="hljs-string">"com/unity/purchasing/googleplay/BuildConfig.class"</span></span> deleting: com/unity/purchasing/googleplay/<span class="hljs-type"><span class="hljs-type">BuildConfig</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span></code> </pre> <br>  Since this will need to be done with each export, you may want to write a script to clear all JARs after export. <br><br>  Alternative solution: use AAR, if it exists in the plugin, instead of the extracted library project created by Unity for AAR when exporting.  In our example, we will find <code>GooglePlay.aar</code> , which is included in the <code>UnityPurchasing</code> plugin, and copy it to the new <code>aars</code> directory that we created in the tree of the exported project. <br><br><pre> <code class="hljs xml">cp /Assets/Plugins/UnityPurchasing/Bin/Android/GooglePlay.aar <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">exported_proj</span></span></span><span class="hljs-tag">&gt;</span></span>/aars/</code> </pre> <br>  Then we add the line to the root file <code>build.gradle</code> to add the new <code>aars</code> directory to the repository search path. <br><br><pre> <code class="hljs bash">allprojects { repositories { jcenter() flatDir { <span class="hljs-built_in"><span class="hljs-built_in">dirs</span></span> <span class="hljs-string"><span class="hljs-string">'../aars'</span></span> } } }</code> </pre> <br>  Finally, add a dependency to <code>Your Unity Project/build.gradle</code> .  Note that we use a slightly different format to refer to aar instead of the library project. <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) compile <span class="hljs-string"><span class="hljs-string">':GooglePlay</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@aar</span></span></span><span class="hljs-string">'</span></span> }</code> </pre> <br><h3>  Other problems </h3><br>  There are many other issues that you may or may not encounter when converting an exported Unity project to Gradle / Android Studio.  In general, these will be two classes of problems: <br><br><ol><li>  conflicts between <code>AndroidManifest.xml</code> included in plugins </li><li>  postprocess scripts behavior on which native plugins depend may be incorrectly translated into the exported project </li></ol><br>  The first type of problem occurs regularly in regular Unity builds during the process of merging manifests.  Solving such problems requires configuring manifest entries.  Usually errors tell where the conflict is found and give hints on how to resolve it.  Whenever possible, it is better to resolve them in the main Unity project so as not to re-execute the steps on each export. <br><br>  The second type, related to post-processing scripts, is much more complex and can become an obstacle for efficient work with the exported project.  For his decision it is impossible to give general recommendations. <br><br><h1>  Solving the problem of 64K limiting DEX methods in the Gradle project </h1><br>  So, our Unity project is already in Gradle, now you can use ProGuard to try to make the number of methods less than 64K, or enable MultiDex to support more than 64K methods. <br><br><h3>  Enable ProGuard </h3><br>  You can write a separate post about setting up ProGuard for exported Unity projects.  I'll show you how to add ProGuard to the Gradle build script.  Add the following lines to the <code>android</code> section of the <code>Your Unity Project/build.gradle</code> to enable ProGuard for release builds. <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">buildTypes</span></span> { <span class="hljs-section"><span class="hljs-section">release</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">minifyEnabled</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> proguardFiles getDefaultProguardFile(<span class="hljs-string"><span class="hljs-string">'proguard-android.txt'</span></span>), <span class="hljs-string"><span class="hljs-string">'proguard-unity.txt'</span></span> } }</code> </pre> <br>  We have specified two ProGuard configuration files - standard, supplied with the Android SDK ( <code>proguard-android.txt</code> ) and exported with the Unity project for Unity version 5.4 ( <code>proguard-unity.txt</code> ).  Almost always you will need to maintain another ProGuard configuration file with rules defining which classes and methods should be saved for the plugins used by the game. <br><br>  To disable ProGuard, you can simply change the value of <code>minifyEnabled</code> to <code>false</code> . <br><br><h3>  Enable MultiDex </h3><br>  To enable MultiDex for the exported assembly, add the following lines to the <code>android</code> section of the <code>Your Unity Project/build.gradle</code> . <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">defaultConfig</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">minSdkVersion</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> //   multidex. multiDexEnabled <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  This enables MultiDex support for devices running Android 5.0 and higher.  To support devices for Android 4.0 and above, you need to make additional changes.  First, add a new dependency to the <code>New Unity Project\build.gradle</code> to support the <code>com.android.support:multidex</code> library. <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'com.android.support:multidex:1+'</span></span> compile fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, include: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) //   }</code> </pre> <br>  Then change the label <pre>  &lt;application&gt; </pre>  basically <code>AndroidManifest.xml</code> , specifying the support class <code>MultiDexApplication</code> . <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.support.multidex.MultiDexApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> &gt;</span></span></code> </pre> <br>  If the Unity project does not yet contain the main <code>AndroidManifest.xml</code> file, then you can add it to <code>/Assets/Plugins/Android/AndroidManifest.xml and</code> change the <code>application</code> label there to include it in future builds. <br><br><h1>  Complete application file build.gradle </h1><br>  Here‚Äôs what a complete build.gradle file looks like for a simple application with a simple dependency.  A complex project exceeding 64K methods will probably contain much more dependencies. <br><br><pre> <code class="hljs pgsql">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.application'</span></span> dependencies { compile <span class="hljs-string"><span class="hljs-string">'com.android.support:multidex:1+'</span></span> compile fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: <span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>) compile <span class="hljs-string"><span class="hljs-string">':GooglePlay@aar'</span></span> } android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> buildToolsVersion "24" sourceSets { main { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'AndroidManifest.xml'</span></span> java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] resources.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] aidl.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] renderscript.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res'</span></span>] assets.srcDirs = [<span class="hljs-string"><span class="hljs-string">'assets'</span></span>] jniLibs.srcDirs = [<span class="hljs-string"><span class="hljs-string">'libs'</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/debug'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">release</span></span>.setRoot(<span class="hljs-string"><span class="hljs-string">'build-types/release'</span></span>) signingConfigs { myConfig { storeFile file("&lt;path-to-key&gt;/private_keystore.keystore") storePassword <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.getenv("KEY_PASSWORD") keyAlias "&lt;your_key_alias&gt;" keyPassword storePassword } } } defaultConfig { minSdkVersion <span class="hljs-number"><span class="hljs-number">14</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">24</span></span> //   multidex. multiDexEnabled <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } buildTypes { <span class="hljs-keyword"><span class="hljs-keyword">release</span></span> { minifyEnabled <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> proguardFiles getDefaultProguardFile(<span class="hljs-string"><span class="hljs-string">'proguard-android.txt'</span></span>), <span class="hljs-string"><span class="hljs-string">'proguard-unity.txt'</span></span> signingConfig signingConfigs.myConfig } } }</code> </pre> <br>  This snippet also adds entries needed to sign the application with the private key.  The key password is retrieved from the environment variable.  If everything worked out, you can build a game processed by ProGuard / MultiDex as follows: <br><br><pre> <code class="hljs">KEY_PASSWORD=XXXXXX ./gradlew assembleRelease</code> </pre> <br><h1>  Links </h1><br><ul><li>  <a href="https://www.contentful.com/blog/2014/10/30/android-and-the-dex-64k-methods-limit/">Android and the DEX 64K Method Limit</a> : A good overview of the problem, not related to Unity only.  Android MultiDex support and tools have been improved since the release of this post. </li><li>  <a href="https://github.com/mihaip/dex-method-counts">dex-method-counts</a> : A useful tool for checking which packages and Java classes use many methods. </li><li>  <a href="https://sourceforge.net/projects/jarjar/">Jar Jar Links</a> : a handy tool for working with JAR files. </li><li>  <a href="https://docs.unity3d.com/Manual/android-BuildProcess.html">Unity build process for Android</a> </li><li>  <a href="https://developer.android.com/studio/build/shrink-code.html">Android ProGuard Documentation</a> </li><li>  <a href="https://developer.android.com/studio/build/multidex.html">Android MultiDex Documentation</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/314416/">https://habr.com/ru/post/314416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314404/index.html">How we built our mini data center. Finance, pricing</a></li>
<li><a href="../314408/index.html">Once met JMeter and a stranger ...</a></li>
<li><a href="../314410/index.html">Going deeper into the Underground: the story of one extreme game design</a></li>
<li><a href="../314412/index.html">Setting UEFI-loader. The quickest guide in the world</a></li>
<li><a href="../314414/index.html">Android Account Manager Vulnerability You Should Know About</a></li>
<li><a href="../314418/index.html">Microsoft refuses EMET support</a></li>
<li><a href="../314422/index.html">Announcement of Kharkiv WordPress Meetup # 3</a></li>
<li><a href="../314424/index.html">Donald Knuth: about Richard Feynman, awards and algorithm of the ILC</a></li>
<li><a href="../314428/index.html">Few will pass your game, so is it worth spending time on the ending?</a></li>
<li><a href="../314432/index.html">Richard Stallman Manifesto: How I do my computing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>