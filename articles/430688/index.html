<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data transfer via animated QR to Gomobile and GopherJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about a small and fun project of the day off on the transfer of files through animated QR codes. The project is written...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data transfer via animated QR to Gomobile and GopherJS</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article I want to talk about a small and fun project of the day off on the transfer of files through animated QR codes.  The project is written on Go, using Gomobile and Gopherjs - the last one for a web application to automatically measure the speed of data transfer.  If you are interested in the idea of ‚Äã‚Äãtransferring data through visual codes, web application development is not on JS or Go‚Äôs true cross platform platform - well-known as a cat. </p><br><p><img src="https://habrastorage.org/webt/2p/zg/t_/2pzgt_2anc92t0udxgl3cnt3xy0.gif" alt="txqr demo"></p><a name="habracut"></a><br><p>  The idea of ‚Äã‚Äãthe project was born out of a specific task for a mobile application - how to transfer a small portion of data (~ 15KB) to another device most simply and quickly, in terms of network locks.  The first thought was to use Bluetooth, but this is not as convenient as it seems - the relatively long and not always working process of detecting and pairing devices makes the task too difficult.  A good idea would be to use NFC (Near Field Communication), but there are still too many devices in which NFC support is limited or not available at all.  It needed something simpler and more accessible. </p><br><p>  What about QR codes? </p><br><h1 id="qr-kody">  QR codes </h1><br><p>  QR (Quick Response) code is the most popular type of visual codes in the world.  It allows you to encode up to 3K of arbitrary data and has various levels of error correction, allowing you to read even a third of a closed or dirty code with confidence. </p><br><p>  But with QR codes there are two problems: </p><br><ul><li>  3KB is not enough </li><li>  the more data is encoded, the higher the quality requirements of the image to scan </li></ul><br><p>  Here is the QR code of the 40th version (the highest recording density) with 1276 bytes: </p><br><p><img src="https://habrastorage.org/webt/wp/r1/mp/wpr1mp7p-uz4vzzssaai5zp8v44.gif" alt="qrv40"></p><br><p>  For my task, it was necessary to learn how to transfer ~ 15KB of data on standard devices (smartphones / tablets), so the question arose by itself - why not animate the sequence of QR codes and transfer the data in chunks? </p><br><p>  A quick search on ready-made implementations led to <a href="https://github.com/leonjza/qrxfer">several</a> <a href="https://volumeintegration.com/jumping-the-gap-data-transmission-over-an-air-gap/">such</a> <a href="http://stephendnicholas.com/posts/quicker-video-qr-codes">projects</a> ‚Äî mostly projects on hackathons (although the <a href="http://www.theseus.fi/bitstream/handle/10024/96359/Grasbeck_Max.pdf%3Fsequence%3D1%26isAllowed%3Dy">thesis was</a> met) ‚Äîbut all were written in Java, Python or JavaScript, which, unfortunately, made the code almost unportable and unused.  But considering the great popularity of QR codes and the low technical complexity of the idea, it was decided to write from scratch on Go - a cross-platform, readable and fast language.  Usually, cross-platform means the ability to build binary code for Windows, Mac and Linux, but in my case, the assembly for web (gopherjs) and mobile systems (iOS / Android) was also important.  Go gives it all out of the box with minimal cost. </p><br><p>  I also considered alternative versions of visual codes, such as <a href="https://en.wikipedia.org/wiki/High_Capacity_Color_Barcode">HCCB</a> or <a href="https://github.com/jabcode/jabcode">JAB Code</a> , but for them I would have to write an OpenCV scanner, implement a coder / decoder from scratch and that was too much for a project for one weekend.  Circular QR codes ( <a href="https://en.wikipedia.org/wiki/ShotCode">shotcodes</a> ), and their counterparts used in Facebook, Kik, and Snapchat allow you to encode much less information, and Apple‚Äôs incredibly cool Apple‚Äôs patented approach to pairing the Apple Watch and iPhone ‚Äî an <a href="https://www.youtube.com/watch%3Fv%3D-WK4jiwlE5k">animated cloud of multicolored particles</a> ‚Äî is also optimized for the wow effect, and not under maximum bandwidth.  QR codes are integrated into native SDK cameras of mobile OS, which greatly facilitates work with them. </p><br><h1 id="txqr">  Txqr </h1><br><p>  This is how the <em>txqr</em> project (from Tx - transmission, and QR) was born, which implements a library for encoding / decoding QR on pure Go and a protocol for data transmission. </p><br><p>  The main idea is as follows: one client selects a file or data to be sent, the program on the device splits the file into pieces, encodes each of them into QR frames and shows them in an infinite loop with a given frame rate until the recipient receives all the data.  The protocol is made in such a way that the recipient can start from any frame, receive QR frames in any order - thus avoiding the problem of the need to synchronize the animation frequency and scanning frequency.  The recipient may be an old device, the power of which allows you to decode 2 frames per second, and the sender - a new smartphone issuing 120Hz animation, or vice versa, and this will not be a fundamental problem for the protocol. </p><br><p> This is achieved as follows - when the file is broken into pieces ( <em>frames</em> further), the prefix with information about the offset with respect to all data and the total length - <code>OFFSET/TOTAL|</code>  (where OFFSET and TOTAL are integer offset and length, respectively).  Binary data is currently encoded in Base64, but this is not really necessary - the QR specification allows not only to encode data as binary, but also to optimize different parts of data for different encodings (for example, the prefix with minor changes can be encoded as <em>alphanumeric</em> , and the rest is - as <em>binary</em> ), but for simplicity Base64 performed its function perfectly. </p><br><p>  Moreover, the frame size and frequency can even be changed dynamically, adapting to the capabilities of the recipient. </p><br><p><img src="https://habrastorage.org/webt/qm/7g/dg/qm7gdgycvmlhgjflhc_xudrfeu8.png" alt="protocol"></p><br><p>  The protocol itself is very simple, and its main disadvantage is that for large files (although this goes beyond the scope of the task, but still), one frame skipped during scanning will double the scanning time - the recipient will have to wait for the full cycle again.  In coding theory there are solutions for such cases - <a href="https://habr.com/company/wunderfund/blog/302638/">fountain codes</a> , but I will leave this for some next free weekend. </p><br><p>  The most interesting point was to write a mobile application that can use this protocol. </p><br><h2 id="gomobile">  Goomobile </h2><br><p>  If you have not heard of <a href="https://github.com/golang/mobile">gomobile</a> , then this is a project that allows you to use Go libraries in iOS and Android projects and does so until propriety is a simple procedure. </p><br><p>  The standard process is: </p><br><ul><li>  you write plain go code </li><li>  launch <code>gomobile bind ...</code> </li><li>  copy the resulting artifact (s) ( <code>yourpackage.framework.</code> or <code>yourpackage.aar</code> ) into your mobile project </li><li>  import <code>yourpackage</code> and work with it as with a regular library </li></ul><br><p>  You can try it yourself how easy it is. </p><br><p>  Therefore, I pretty quickly wrote an application on Swift, which scans QR codes (thanks to this <a href="https://medium.com/appcoda-tutorials/how-to-build-qr-code-scanner-app-in-swift-b5532406dd6b">wonderful article</a> ) and decodes them, sticks together and, when the entire file is received, it shows in the preview window. </p><br><p>  Being new to Swift (even though I read the book on Swift 4), there were many moments when I was stuck on something simple, trying to figure out how to do it correctly and, as a result, the best solution was to implement this functionality on Go and use via Gomobile.  Do not get me wrong, Swift is in many ways a wonderful language, but, like most other programming languages, it gives too many ways to do the same thing, and already has a decent history of back-incompatible changes.  For example, I needed to do a simple thing - measure the duration of an event with millisecond precision.  Google search and StackOverflow led to a lot of different, controversial and often outdated solutions, none of which, in the end, looked neither beautiful for me nor correct for the compiler.  After 40 minutes of time spent, I just made another method in the Go package that called <code>time.Since(start) / time.Millisecond</code> and used its result from Swift directly. </p><br><p>  I also wrote the <code>txqr-ascii</code> console utility to quickly test the application.  It encodes the file and animates QR codes in the terminal.  All together it worked surprisingly well - I could send a small picture in a few seconds, but as soon as I started testing different frame rates, the number of bytes in each QR frame and the level of error correction in the QR encoder, it became clear that the terminal solution was not copes with high frequency (more than 10) of animation, and that manually testing and measuring the results is a bad job. </p><br><h1 id="txqr-tester">  TXQR Tester </h1><br><p><img src="https://habrastorage.org/webt/bc/tp/a6/bctpa6fnru8q-kxbezmo27dcc1w.jpeg"></p><br><p>  To find the optimal combination of frame rate, data size in a QR frame and error correction level among the reasonable limits of these values, I needed to run over 1000 tests, manually changing parameters, waiting for the full cycle with the phone in hand and writing the results on a tablet.  Of course, this should be automated! </p><br><p>  This is <code>txqr-tester</code> idea of ‚Äã‚Äãthe next application, <code>txqr-tester</code> .  I originally planned to use <a href="http://x/exp/shiny">x / exp / shiny</a> - an experimental UI framework for native desktop applications on Go, but it looks like it was abandoned.  About a year ago, I tried it, and the impression was not bad - it was perfect for low-level things.  But today the master branch has not even compiled.  It seems that there are no incentives to invest in the development of desktop frameworks - a complex and cumbersome task, with almost zero demand now, all UI solutions have been transferred to the web for a long time. </p><br><p>  As we know, programming languages ‚Äã‚Äãhave just started to go into web programming, thanks to WebAssembly, but this is just the first steps for children.  Of course, there are also JavaScript and add-ons, but friends do not allow friends to write applications in JavaScript, so I decided to use my recent discovery - the <a href="https://github.com/gopherjs/vecty">Vecty</a> framework, which allows you to write frontends on pure Go, which are automatically converted to JavaScript using a very adult and surprisingly well-working project <a href="https://github.com/gopherjs/gopherjs">gopherjs</a> . </p><br><h1 id="vecty-i-gopherjs">  Vecty and GopherJS </h1><br><p><img src="https://habrastorage.org/webt/rf/xc/zz/rfxczzfu4b5efmhjtu_lmf7ema4.png" alt="vecty"></p><br><p>  I have never received such pleasure in the development of front-end interfaces in life. </p><br><p>  A little later, I plan to write a couple more articles about my experience in developing frontends on Vecty, including WebGL applications, but the point is that after several projects on React, Angulyarah and Ember, writing frontend in a thoughtful and simple programming language is a breath of fresh air!  I can write quite nice front-ends in a short time and not write a single line in JavaScript! </p><br><p>  For starters, here‚Äôs how you start a new project on Vecty (no "initial project" code generators creating tons of files and folders) - just main.go: </p><br><pre> <code class="go hljs">ackage main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/gopherjs/vecty"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() vecty.SetTitle(<span class="hljs-string"><span class="hljs-string">"My App"</span></span>) vecty.AddStylesheet(<span class="hljs-comment"><span class="hljs-comment">/* ... add your css... */</span></span>) vecty.RenderBody(app) }</code> </pre> <br><p>  An application, like any UI component, is just a type: a structure that includes the <code>vecty.Core</code> type and must implement the <code>vecty.Component</code> interface (consisting of one <code>Render()</code> method).  And it's all!  Further you operate with types, methods, functions, libraries for DOM work and so on - no hidden magic and new terms and concepts.  Here is the simplified code for the main page: </p><br><pre> <code class="go hljs">/ App is a top-level app component. <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { vecty.Core session *Session settings *Settings <span class="hljs-comment"><span class="hljs-comment">// any other stuff you need, // it's just a struct } // Render implements the vecty.Component interface. func (a *App) Render() vecty.ComponentOrHTML { return elem.Body( a.header(), elem.Div( vecty.Markup( vecty.Class("columns"), ), // Left half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), elem.Div(a.QR()), // QR display zone ), // Right half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), vecty.If(!a.session.Started(), elem.Div( a.settings, )), vecty.If(a.session.Started(), elem.Div( a.resultsTable, )), ), ), vecty.Markup( event.KeyDown(a.KeyListener), ), ) }</span></span></code> </pre> <br><p>  You, for certain, now look at the code and think - how much is unfounded working with the DOM!  I also thought so at first, but as soon as I started working, I realized how convenient it is: </p><br><ol><li>  There is no magic - each block (Markup or HTML) is only a variable of the desired type, with clear limits where you can put what, thanks to static typing. </li><li>  There are no opening / closing tags that you should either remember to change when refactoring, or use an IDE that does this for you. </li><li>  The structure suddenly becomes clear - I never, for example, understood why in React until the 16th version it was impossible to return several tags from a component - this is ‚Äújust a string‚Äù.  Seeing how this is done in Vecty, it suddenly became clear where the roots of this restriction grew in React.  All the same, it is not clear, however, why after React 16 it became possible, but not necessary. </li></ol><br><p>  In general, as soon as you try this approach of working with the DOM, its advantages will become very obvious.  Cons, too, of course, but after the minuses of the usual methods, they are invisible. </p><br><p>  Vecty is called a React-like framework, but this is not the case.  For React, there is a native GopherJS library ‚Äî <a href="">myitcv.io/react</a> , but I don't think it's a good idea to repeat the React architectural solutions for Go.  When you write frontend on Vecty, it suddenly becomes clear how much simpler everything is.  Suddenly, all this hidden magic and new terms and concepts that each JavaScript framework invents become superfluous - they are just an <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B1%25D1%2580%25D1%258F%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BF%25D1%2583%25D0%25BB%25D0%25B8_%25D0%25BD%25D0%25B5%25D1%2582">added complexity</a> , nothing more.  All that is needed is to clearly and clearly describe the components, their behavior, and link them together - types, methods and functions, that's all. </p><br><p>  For CSS, I used a surprisingly decent <a href="https://bulma.io/">Bulma</a> framework - it has a very clear naming of classes and a good structure, and the declarative UI code with its help is very readable. </p><br><p>  True magic, however, begins when you compile Go code in JavaScript.  It sounds very scary, but, in fact, you just call <code>gopherjs build</code> and in less than a second, you have an auto-generated JavaScript file ready to include in your basic HTML page (a normal application consists only of an empty body tag and Js-script).  When I first started this command, I expected to see a lot of messages, warnings and errors, but no - it works out fantastically quickly and silently, only one-liners in case of compilation errors generated by the Go compiler output to the console, so they are very clear.  But it was even cooler to see errors in the browser console, with spectra pointing to the .go files and the correct line!  It is very cool. </p><br><h2 id="testirovanie-parametrov-qr-animacii">  Testing the parameters of QR animation </h2><br><p>  Within a few hours, I had a web application ready that allowed me to quickly change the parameters for testing: </p><br><ul><li>  FPS - frame rate </li><li>  QR Frame Size - how many bytes should be in each frame </li><li>  QR Recovery Level - QR Error Correction Level </li></ul><br><p>  and run the test automatically. </p><br><p><img src="https://habrastorage.org/webt/dl/51/my/dl51myjlg-kfbii5wxjx3ggu9tm.png" alt="app"></p><br><p>  The mobile application, of course, also had to be automated - it had to understand when the next round begins with new parameters, understand when the reception takes too much time and terminate the round, send the results to the application, and so on. </p><br><p>  The snag was that the web application, being launched in the browser sandbox, cannot create new connections, and if I'm not mistaken, the only possibility of a real peer-to-peer connection to the browser is only through WebRTC (I don‚Äôt need to punch NAT ), but it was too cumbersome.  A web application could only be a client. </p><br><p>  The solution was simple - a web service on Go, which gave the web application (and launched the browser to the desired URL), also launched the WebSocket proxy for two clients.  As soon as two clients join it, it transparently sends messages from one connection to another, allowing clients (the web application and the mobile client) to communicate directly.  They must be for this, in one WIFI network, of course. </p><br><p>  There remained the problem of how to tell the mobile device where to actually connect, and it was solved with the help of a ... QR code! </p><br><p>  The testing process looks like this: </p><br><ul><li>  mobile application searches for a QR code with a start marker and a link to a WebSocket proxy </li><li>  as soon as the token is read, the application connects to this WebSocket proxy </li><li>  the web application (already connected to the proxy) understands that the mobile application is ready and shows a QR code with the marker "ready for the next round?" </li><li>  The mobile application recognizes the signal, resets the decoder, and sends an e-mail message through the WebSocket. </li><li>  Web application, having received confirmation, generates a new QR animation and twists it until it receives results or timeout. </li><li>  the results are added to a table next to it, which can be immediately downloaded as a CSV </li></ul><br><p><img src="https://habrastorage.org/webt/u_/gm/jx/u_gmjxdtzg16tus3pboxicibyuk.png" alt="design"></p><br><p>  In the end, all I had to do was just to put the phone on a tripod, launch the application, and then the two programs did all the dirty work themselves, politely communicating via QR codes and WebSocket :) </p><br><p><img src="https://habrastorage.org/webt/b-/no/wn/b-nownnc3g_qjijctnqqwpjppri.gif" alt="tester demo"></p><br><p>  At the end, I downloaded the CSV results file, drove it to RStudio, and analyzed the results in <a href="https://plot.ly/organize/home">Plotly Online Chart Maker</a> . </p><br><h1 id="rezultaty">  results </h1><br><p>  The full cycle of testing takes about 4 hours (unfortunately, the hardest part of the process - generating an animated GIF image with QR frames, had to run in the browser, and since the resulting code is still in JS, only one processor is used), during which, it was necessary to monitor, so that suddenly the screen did not go out or some application did not close the window with the web application.  The following parameters were tested: </p><br><ul><li>  FPS - from 3 to 12 </li><li>  The size of the QR frame - from 100 to 1000 bytes (in increments of 50) </li><li>  All 4 levels of QR error correction (Low, Medium, High, Highest) </li><li>  The size of the transferred file - 13KB randomly generated bytes. </li></ul><br><p>  A few hours later I downloaded the CSV and began to analyze the results. </p><br><p>  A picture is more important than a thousand words, but interactive 3D visualizations are more important than a thousand pictures.  Here is a visualization of the results (clickable): </p><br> <a href="https://plot.ly/~divan0/1/%3Fshare_key%3Dt8DizOL9dynI6NTcLA88Xi" title="qr_scan_results"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/833/7f1/ba38337f18e68ef62245173481e497f7.png" alt="qr_scan_results" width="600"></a> <br><br><br><p>  The best result was 1.4 seconds, which is approximately equal to 9KB / s!  This result was recorded at a frequency of 11 frames per second, a frame size of 850 bytes, and an average level of error correction.  In most cases, however, the camera decoder missed some frames at such a speed, and you had to wait for the next repeat of the missed frame, which had a negative effect on the results - instead of two seconds, it could easily turn out to be 15, or a timeout that was set to 30 seconds. </p><br><p>  Here are graphs of the results of variable variables: </p><br><h3 id="vremya--razmer-freyma">  Time / frame size </h3><br><p> <a href="https://plot.ly/~divan0/3/"><img src="https://habrastorage.org/webt/pd/9c/rp/pd9crp3igj0djkv3uftlpxcgb2y.png" alt="Time vs size"></a> </p><br><p>  As can be seen, at low values ‚Äã‚Äãof the number of bytes in each frame, the excess coding is too large and the total reading time, respectively, too.  There is a local minimum at 500-600 bytes per frame, but the values ‚Äã‚Äãalongside still lead to lost frames.  The best result was observed at 900 bytes, but 1000 and higher is almost guaranteed loss of frames. </p><br><h3 id="vremya--fps">  Time / FPS </h3><br><p> <a href="https://plot.ly/~divan0/2/"><img src="https://habrastorage.org/webt/-g/al/up/-galupwvvmk5k78p2bqgmsg1zme.png" alt="Time vs FPS"></a> </p><br><p>  The value of the number of frames per second, to my surprise, didn‚Äôt have much effect - small values ‚Äã‚Äãincreased the total transmission time too much, and large ones increased the probability of a missing frame.  The optimal value, judging by these tests, is around 6-7 frames per second for those devices on which I tested. </p><br><h3 id="vremya--uroven-korrekcii-oshibok">  Time / Error Correction Level </h3><br><p> <a href="https://plot.ly/~divan0/6/"><img src="https://habrastorage.org/webt/c4/2g/di/c42gdiq0sqjxynepawom9j6bpi4.png" alt="Time vs Lvl"></a> </p><br><p>  The level of error correction showed a clear relationship between the file transfer time and the level of redundancy, which is not surprising.  The clear winner here is a low (L) correction level - the less redundant data, the more readable the QR code for the scanner with the same data size.  In fact, for this experiment, redundancy is not needed at all, but the standard does not offer such an option. </p><br><p>  Of course, for more objective data, this test should be run hundreds and thousands of times, on different devices and different screens, but for my weekend experiment, it was more than enough results. </p><br><h1 id="vyvody">  findings </h1><br><p>  This fun project proved that one-way data transfer via animated codes is certainly possible, and for situations where you need to transfer a small amount in the absence of any kind of networks, it is quite suitable.  Although my maximum result was about 9KB / s, in most cases the actual speed was 1-2KB / s. </p><br><p>  I also really enjoyed using Gomobile and GopherJS with Vecty as an everyday tool for problem solving.  These are very mature projects, with an excellent speed of work, and, in most cases, giving the experience "it just works." </p><br><p>  Finally, I still admire how productive you can be with Go, when you clearly know what you want to implement - an extremely short cycle ‚Äúchange‚Äù - ‚Äúcollect‚Äù - ‚Äúcheck‚Äù allows you to experiment a lot and often, simple code and the lack of a class hierarchy in the structure programs make it easy and painless to refactor them on the go, and the fantastic cross-platform built into the language from the very beginning allows you to write code once and use it on the server, on the web client and in the native mobile application.  At the same time, despite more than enough performance out of the box, there is still plenty of space for optimization and acceleration. </p><br><p>  So if you have never tried Gomobile or GopherJS, I recommend you to try it at the next opportunity.  It will take an hour of your time, but perhaps it will open you a whole new layer of possibilities in the web or mobile development.  Feel free to try! </p><br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://github.com/divan/txqr">https://github.com/divan/txqr</a> </li><li>  <a href="https://github.com/divan/txqr/tree/master/cmd/txqr-tester">https://github.com/divan/txqr/tree/master/cmd/txqr-tester</a> </li><li>  <a href="https://github.com/divan/txqr-tester-ios">https://github.com/divan/txqr-tester-ios</a> </li><li>  <a href="https://github.com/divan/txqr-reader">https://github.com/divan/txqr-reader</a> </li><li>  <a href="https://github.com/gopherjs/vecty">https://github.com/gopherjs/vecty</a> </li><li>  <a href="https://github.com/golang/mobile">https://github.com/golang/mobile</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430688/">https://habr.com/ru/post/430688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430678/index.html">Test ten dimmers with LED lamps</a></li>
<li><a href="../430680/index.html">Writing a simple processor and environment for it</a></li>
<li><a href="../430682/index.html">Three years of the lunar microsatellite project: stages of maturation</a></li>
<li><a href="../430684/index.html">Scanning Live Ethereum of Unchecked-Send Error Contracts. Part 2</a></li>
<li><a href="../430686/index.html">Review: WAZER, the first desktop waterjet cutting machine</a></li>
<li><a href="../430690/index.html">Deterministic exceptions and error handling in the ‚ÄúC ++ future‚Äù</a></li>
<li><a href="../430694/index.html">A brief guide to learning C ++: what, when and what to create</a></li>
<li><a href="../430700/index.html">A unified online movie viewing system will start working in Russia</a></li>
<li><a href="../430702/index.html">Very strange training</a></li>
<li><a href="../430704/index.html">How artificial intelligence technologies help Aviasales grow: seven examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>