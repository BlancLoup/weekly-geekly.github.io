<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural level generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Work on programming, graphics and sounds in some new igrahe finished - there were only levels. Light and pleasant work, but for some reason it goes wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural level generation</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/2m/0y/gv/2m0ygvmlc1izxgmo4chumrammxi.png"></p><br><p>  Work on programming, graphics and sounds in <em>some new igrahe</em> finished - there were only levels.  Light and pleasant work, but for some reason it goes with great difficulty.  Perhaps the effect is general fatigue. </p><br><p>  Thinking how to simplify my life, the idea of ‚Äã‚Äãprocedural generation came to mind.  Obviously, it will also need to be written, but as stated in one famous work, ‚Äúit‚Äôs better to lose a day, then fly in five minutes.‚Äù </p><br><p>  <strong>Attention!</strong>  <strong>Under the cut a lot of text and "fat" gifs.</strong> </p><a name="habracut"></a><br><h2 id="vvodnaya">  Introductory </h2><br><p>  The levels will still be polished manually, so there are no special requirements for memory, speed of work, or even the quality of the levels obtained. </p><br><p>  Initially, I planned that the generator would only distribute rooms and doors, and all further refinement (plot, scenery and enemies) would be carried out in manual mode.  But at the moment I think that the generator will be able to much more.  However, manual refinement will still remain - it is necessary that players feel that at least a little love has been invested in the levels. </p><br><p>  I looked through my knowledge base on game development, and wrote out links to procedural generation articles in a separate document.  Most, of course, about the generation of <a href="https://habr.com/post/320140/">classical labyrinths</a> or the <a href="https://habr.com/post/322504/">generation of relief</a> (by the way, the results are very impressive), which is not suitable for a 3D shooter.  But some were close to what I needed (I marked with an asterisk those that seemed to me the most suitable): </p><br><ul><li>  <a href="https://www.progamer.ru/dev/procedural-dungeon-generation.htm">https://www.progamer.ru/dev/procedural-dungeon-generation.htm</a> (*) </li><li>  <a href="https://habr.com/post/333692/">https://habr.com/post/333692/</a> </li><li>  <a href="http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php">http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php</a> </li><li>  <a href="http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html">http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html</a> </li><li>  <a href="https://habr.com/post/332832/">https://habr.com/post/332832/</a> (*) </li><li>  <a href="https://habr.com/post/184818/">https://habr.com/post/184818/</a> (*) </li></ul><br><p>  I decided to start with the last two - they are simply realized, and they give good results. </p><br><h2 id="struktura-generatora">  Generator structure </h2><br><p>  In fact, I did not come to this structure immediately, but in the process of numerous refactorings and rewriting, but I write about it immediately, so that it is clear what is happening: </p><br><ol><li>  Generation of the original geometry (your choice - or "BSP", or the layout of the premises). </li><li>  Cleaning garbage sections (such sections that can not exist in the game). </li><li>  Building connections </li><li>  Clearing junk subgraphs (such groups of sections that are interconnected, but not connected to the remaining sections). </li><li>  Clearing of unnecessary connections (construction of a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">spanning tree</a> , the link is given to the <strong>minimum</strong> spanning tree, because there is a picture, but for the generator there is no need in the minimum). </li><li>  Randomization of compounds - restoration of some remote connections back (for a more "human" type of level), as well as the transformation of some others into passages between sections (which "merges" several sections into one of a more complex form). </li><li>  Generate secret rooms. </li><li>  Generation of the "script" (where there will be an initial and final section, and which path will have to be traveled in order to get from the initial to the final one). </li><li>  Compound optimization. </li><li>  Creating doors and windows. </li><li>  Select the action to be performed in this section (press the switch, raise the key or find the secret wall). </li></ol><br><p>  There are still about 12 points, but they are not completed yet (when I‚Äôm done, I‚Äôll write a separate post about them). </p><br><h2 id="generaciya-iznachalnoy-geometrii-bsp">  Generation of the original geometry: "BSP" </h2><br><p><img src="https://habrastorage.org/webt/zn/j4/_k/znj4_kemnzlvr4cfr45tqtzami8.gif"></p><br><p>  <a href="https://habr.com/post/332832/">This translation</a> was taken as a basis.  I'm not sure how much what is happening in this algorithm is close to a real BSP, so I write "BSP" in quotes. </p><br><p>  The algorithm is quite simple.  Initially create a rectangle the size of the whole playing field: </p><br><p><img src="https://habrastorage.org/webt/fh/mx/x-/fhmxx-boo4euwsc4dl2g0gfc2nk.png"></p><br><p>  Then divide it randomly into two parts - either horizontally or vertically.  Where the separation line will be held, we also choose randomly: </p><br><p><img src="https://habrastorage.org/webt/ml/lo/jm/mllojmhd2qxiga7ma_skqxqoera.png"></p><br><p>  Recursively doing the same for new rectangles: </p><br><p><img src="https://habrastorage.org/webt/ew/sw/wf/ewswwfagu3jcskhcebem5sd-jo8.png"></p><br><p>  And again and again, to some limit: </p><br><p><img src="https://habrastorage.org/webt/fl/s-/hd/fls-hd2xm17ghbjbvnwpyhwzd_m.png"></p><br><p>  Then in each rectangle we select "room" - a rectangle of the same size as the original or smaller (but not less than 3x3 - in more detail about this will be lower). </p><br><p><img src="https://habrastorage.org/webt/r8/h1/_y/r8h1_yacj5bpuux_xmmxuwzdlo0.png"></p><br><p>  Then the rooms are connected by corridors.  But not everyone with each, but somewhat cunning, because of the fact that they are stored in the "BSP" -like structure (for more details, see the original algorithm). </p><br><p><img src="https://habrastorage.org/webt/5t/y6/3e/5ty63ewmz5eey4oaphja4uixjuu.png"><br>  <em>The corridor connecting the purple and white sections.</em> </p><br><p>  In the original algorithm, both the rooms and the corridors are of the same color (i.e., equivalent), so there the corridors are simply drawn over the rooms.  In my case, the original rooms should be preserved, so that the corridors are drawn as if ‚Äúbehind‚Äù the rooms. </p><br><p> In addition, if a room (in the picture is turquoise) crosses the corridor, then it should divide it into two different sections (therefore, the same corridor can be drawn in different colors): </p><br><p><img src="https://habrastorage.org/webt/5n/wr/51/5nwr510wdeg8x9iw3cgy_eorsau.png"></p><br><p>  And that's what comes out of it: </p><br><p><img src="https://habrastorage.org/webt/q4/hq/7r/q4hq7rocs2amqbt-guzspzcmbp4.png"></p><br><p>  Then begins the phase of marking garbage cells: </p><br><p><img src="https://habrastorage.org/webt/f0/ob/sc/f0obscdf1tabhec9mxv4m-wrj5s.png"></p><br><p>  As I already wrote, no sector can be less than 3x3 cells.  This is due to the fact that the sector must be surrounded by walls (at least 1 cell on each side), and there must be at least one free space in it: </p><br><p><img src="https://habrastorage.org/webt/iy/e8/ne/iye8ne6qltvzxtwrpgrtjgmgeae.png"></p><br><p>  Therefore, all those cells that do not fit this rule are marked.  But just to take, and you can not remove them - so many connections disappear, and the level is very scanty. </p><br><p>  Instead, for each labeled cell, it looks for a sector to which it can join (observing the 3x3 rule): </p><br><p><img src="https://habrastorage.org/webt/nc/6q/-y/nc6q-yh8jlkx_rhlilpamtzt27s.png"><br>  <em>If a cell cannot be attributed to any sector, it will be deleted (but not in this case, everything is fine here).</em> </p><br><p>  At the last stage, this beautiful picture is vectorized, and the drawn sectors turn into polyboxes ‚Äî such polygons, with each edge either vertically or horizontally (probably, there is a more scientific name): </p><br><p><img src="https://habrastorage.org/webt/xx/8x/8v/xx8x8vpyawz-uricpycndaadgfy.png"></p><br><h2 id="generaciya-iznachalnoy-geometrii-planirovka-pomescheniy">  Generation of the original geometry: room layout </h2><br><p><img src="https://habrastorage.org/webt/7w/jh/nb/7wjhnbk6xzc6zmdaqyiufpq7t5m.gif"></p><br><p>  The basis was taken <a href="https://habr.com/post/184818/">another article</a> .  This algorithm is somewhat more complicated than the previous one, but also not rocket science. </p><br><p>  To begin with, the playing field is filled with a kind of stop value, and then a rectangular area is cleared randomly on it: </p><br><p><img src="https://habrastorage.org/webt/4n/24/py/4n24pyropjvmm0d8gsmzj9znte0.png"></p><br><p>  The cleaning stage of a random rectangle is performed some more (also random) times, and as a result, the outer contours of the level are obtained: </p><br><p><img src="https://habrastorage.org/webt/np/4v/fi/np4vfi_iumlrznv8bsy8ba3babk.png"></p><br><p>  In the free space, the growth points of rooms are randomly spread out (the minimum size of a room is 3x3): </p><br><p><img src="https://habrastorage.org/webt/2y/wm/3n/2ywm3n3lgak23tcn0dmyshbicne.png"></p><br><p>  The first stage of the growth of rooms begins - for each room, the largest side is selected, which can still grow, and it grows by 1 square (if there are several sides with the same length, random ones).  The rooms are moving one by one, so that there are no intersections. </p><br><p><img src="https://habrastorage.org/webt/-b/4r/cd/-b4rcdczwe-_hu8xvha_cko1ihk.gif"></p><br><p>  Then the rooms are converted to polyboxes: </p><br><p><img src="https://habrastorage.org/webt/pd/j8/qo/pdj8qos36_hf4slo-jlm2eailsw.png"></p><br><p>  And the second stage of growth begins - at this stage the side can be divided into several parts.  Unlike the first stage, it does not grow one cell at a time, but immediately to the maximum stop - this allows you to avoid the ‚Äúladders‚Äù at the joints of the rooms.  If after the passage through all the rooms there are still empty cells, the cycle repeats. </p><br><p>  The result is a completely filled space: </p><br><p><img src="https://habrastorage.org/webt/mi/8j/zf/mi8jzfzhpksr2cz7jzd1_k3gmng.png"></p><br><p>  Next polyboxes are drawn in the form of a raster, and (as in the case of the "BSP" generator) the stage of marking "junk" cells begins: </p><br><p><img src="https://habrastorage.org/webt/ev/na/ru/evnaruhyjwsei7hfbywiiuxyzq4.png"></p><br><p>  And joining them to existing sectors: </p><br><p><img src="https://habrastorage.org/webt/1h/yv/kf/1hyvkfcnerw5yu30txvbztecfzw.png"><br>  <em>It was not possible to attach all the cells - the extra ones were deleted.</em> </p><br><p>  The result turns back into polyboxes: </p><br><p><img src="https://habrastorage.org/webt/ji/l3/yq/jil3yqqnbqpf4cfjyx-sklb_g8w.png"></p><br><h2 id="ochistka-ot-musornyhsekciy">  Cleaning the garbage sections </h2><br><p>  Sometimes there are sections within which the 3x3 rule is not respected: </p><br><p><img src="https://habrastorage.org/webt/6v/zx/2v/6vzx2vnhvhn_kkxvqp1jyzenh6g.png"></p><br><p>  You can try to restore such sections, but I went along a simpler path, and just delete them: </p><br><p><img src="https://habrastorage.org/webt/gc/5s/4y/gc5s4yzeywvc6pi1kh0apfk90pm.png"></p><br><h2 id="postroenie-soedineniy">  Building connections </h2><br><p><img src="https://habrastorage.org/webt/af/3m/w2/af3mw25mgkjtqwskriypbpzzaeo.gif"></p><br><p>  For each section, its neighbors are sought, and connections are created at the points of contact of such sections.  Connections are created on both sides - if section A is in contact with section B, there will be a connection from A to B and from B to A. The result is a bidirectional graph. </p><br><h2 id="ochistka-ot-musornyh-podgrafov">  Clearing trash subgraphs </h2><br><p>  Sometimes, as a result of cleaning the garbage sections, it turns out not one graph, but several independent ones, as in this example: </p><br><p><img src="https://habrastorage.org/webt/yi/s5/5u/yis55urvft0bohq8x0dsurgyyam.png"></p><br><p>  In this case, the subgraph is chosen as the main one, the ‚Äúarea‚Äù of sections is maximum, and the rest are removed (the ‚Äúarea‚Äù is in quotes, because although it is possible to calculate the real polybox area, I simplified the task and consider the area of ‚Äã‚Äãthe bounding rectangle - This is wrong, but suitable for the generator). </p><br><h2 id="ochistka-ot-izlishnih-soedineniy">  Purification of unnecessary compounds </h2><br><p>  If from each sector there is a passage to each with which it is connected, then there will be too many doors at the level, and it will be more felt that it is generated.  Therefore, at this stage, extra connections are deleted: </p><br><p><img src="https://habrastorage.org/webt/oa/sh/oy/oashoyuavho98281lo_s4hpc-ks.gif"></p><br><p>  For more randomization, I do not generate a spanning tree in the minimum number of passes, but, on the contrary, I delete one random edge at a time (choosing it randomly from all possible at the current step). </p><br><p>  <em>Although, when I was writing this, I had the idea that it would be quite enough to randomly select the starting sector, and deleting the edges would be a more efficient algorithm.</em> </p><br><h2 id="randomizaciya-soedineniy">  Randomization of compounds </h2><br><p><img src="https://habrastorage.org/webt/ok/zl/vk/okzlvk4rclc7x3imkpjnjza3kje.gif"><br>  <em>Hereinafter, illustrations will come from another generation, since</em>  <em>in the previous one there was an error in the generator, due to which further images were incorrect.</em> </p><br><p>  But the level in which there is not a single superfluous connection also does not look very human, therefore some chaos is introduced: </p><br><ol><li>  Some deleted edges are restored. </li><li>  And some turn into passages. </li></ol><br><p>  Further, those sections between which the aisles were formed, "merge" into one: </p><br><p><img src="https://habrastorage.org/webt/nh/j_/uj/nhj_ujd0n7sqjdnddlvs9uozq5u.gif"><br>  <em>If it seemed to you that the connections removed at the previous step appeared again in this illustration - it seemed to you :).</em>  <em>When I was reading the text, it seemed to me that way too, but after looking closely at the previous illustration it becomes clear that everything is ok.</em> </p><br><h2 id="generaciya-sekretnyh-komnat">  Generate secret rooms </h2><br><p>  On the graph, select such sectors that have only one connection: </p><br><p><img src="https://habrastorage.org/webt/xt/ku/qw/xtkuqweqgctwcbcckilick4-es4.png"></p><br><p>  If there are several such sectors, then they are all gathered into an array, and sorted by "area".  Then this array is cropped randomly (but so that at least one element remains in it).  These sectors will become secret rooms: </p><br><p><img src="https://habrastorage.org/webt/pf/w0/yu/pfw0yufvv3orwiw_xohtfii8gqi.png"></p><br><h2 id="generaciya-scenariya">  Script generation </h2><br><p><img src="https://habrastorage.org/webt/p2/ql/dn/p2qldn0n-scgjotykszlvsvd05a.gif"></p><br><p>  First, sectors are selected with a minimum number of free connections (ie, those that are closer to the ‚Äúedge‚Äù of the graph): </p><br><p><img src="https://habrastorage.org/webt/lc/iw/7v/lciw7vahyrhoirla-hyahd7jzhu.png"><br>  <em>In this illustration, one sector is selected, but if there were more of them, one would be chosen anyway (randomly).</em> </p><br><p>  <em>Nb.</em>  <em>While reading the article, I was able to come up with a situation where a sector with a minimum number of free connections would not only be on the edge, but also assigning a scenario to it would lead to an impassable level.</em>  <em>In fact, you can choose any sector, but only this one, after removing which the graph would not split into several subgraphs.</em> </p><br><p>  Next, select the sectors that are connected to the current sector, and which have only one free connection.  With some probability, they will be used to continue the scenario.  For example, if the graph were the same as in the illustration below, then the sector indicated by the question could be included in the list. </p><br><p><img src="https://habrastorage.org/webt/6u/b6/vf/6ub6vfbxncsmbug4optzec19gyw.png"><br>  <em>Gray indicates the secret room, a cross marks those connections that should be removed in the source graph, plus is the source sector.</em> </p><br><p>  <em>Nb.</em>  <em>During the reading of the article, it seemed to me that the condition of having only one connection was too strict, it would be enough the same as in the last step, so that after the removal of this sector, the graph would not break up.</em> </p><br><p>  Next, this list of sectors is assigned a script number (just a number, at this stage it does not mean anything concrete), and connections on the borders of this list of sectors are marked as closed by this script. </p><br><p><img src="https://habrastorage.org/webt/tw/4w/3w/tw4w3wxhybxndd5_94mw-l0e1zc.png"><br>  <em>In these illustrations, different scenarios will have different colors of the sector fill.</em>  <em>They have nothing to do with the color of the edging sector (in the next steps it will fix, but in this step it is more convenient for me).</em> </p><br><p>  Then the next sector is selected, a list is compiled, and this list is marked with a new scenario: </p><br><p><img src="https://habrastorage.org/webt/qo/01/qw/qo01qww9cg-s2km6vfrjvoqb_vk.png"></p><br><p>  Notice the little blue dots inside the red squares - this is how the scenario opener is drawn - i.e.  somewhere inside the section with the red script there will be a key or switch that will open the passage to the sectors with the blue script. </p><br><p>  This continues until there are no free sectors: </p><br><p><img src="https://habrastorage.org/webt/5f/ok/yn/5fokynxff0gfpspu7-d8paaw7wi.png"></p><br><p>  The most recent sector is not assigned a scenario, but only a scenario opener.  This sector will be the sector in which the player will start the game. </p><br><p>  For this level: </p><br><ul><li>  The player starts in the starting sector, somewhere there finds a ‚Äúopener‚Äù to the yellow sector, goes there. </li><li>  In the yellow sector opens the blue sector, goes there. </li><li>  In the blue sector opens green, goes there. </li><li>  In the green sector opens purple, goes there. </li><li>  In purple opens red. </li><li>  In red - blue. </li><li>  Where and finds the end of the level switch. </li></ul><br><p>  Schematically, this can be shown as: </p><br><p><img src="https://habrastorage.org/webt/c7/6o/xd/c76oxdwcgff53io6pv3sfcptpuu.png"></p><br><p>  Opener can be either a key or a switch, or something else, for example, the task of destroying all enemies in any sector (but I do not plan that in the near future a generator or engine will support this). </p><br><h2 id="optimizaciya-soedineniy">  Compound Optimization </h2><br><p><img src="https://habrastorage.org/webt/5q/vl/gw/5qvlgwjtnablead4upxcwph7m6k.gif"></p><br><p>  At this step, one side is selected for each of the connections (as you remember, connections are initially generated in both directions).  This is necessary to make the level look more ‚Äúmanual‚Äù, and to simplify the next steps <em>(but for an even more interesting level look, in the near future I plan to take a step to ‚Äúde-optimize‚Äù some connections)</em> . </p><br><h2 id="sozdanie-dverey-iokon">  Creating doors and windows </h2><br><p><img src="https://habrastorage.org/webt/xr/je/m5/xrjem5kqzr7ncka2vuf8nsukw2c.gif"></p><br><p>  For each sector, all its connections are viewed (which, after the previous step, look only in one direction), and on each viewed connection there are doors and windows. </p><br><ul><li>  First, a point is selected at the junction, preferably closer to the center. </li><li>  Then at this point is placed either a door or a window (and if this is a connection to a secret room, then a secret wall). </li><li>  If a door is placed, it can be from 1 to 3 cells in size (one is a regular door, two or three is a thick pressure door, which opens after pressing any switch). </li><li>  Then the connection is divided into two parts - the part before the selected point, and the part after.  And, if either before or after a place is left, the function is called recursively. </li></ul><br><p>  To make the level look more interesting, at different steps there is a different probability of placing a door or window: </p><br><ol><li>  In the first step, the door must be placed, because  what's the use of the connection, if there is only one window. </li><li>  In the second step, a window is placed more likely (75%) than a door. </li><li>  If there is a third step (for example, a long connection), then a window must be placed on it. </li><li>  In the case of the 4th step, the door or window is placed equally likely. </li><li>  If the connection is extra long, the generator returns to the second step. </li></ol><br><h2 id="vybor-deystviya">  Choice of action </h2><br><p>  Although this has nothing to do with generation, the visualization at this step changes - now the edging of the sector is painted in the color of the script: </p><br><p><img src="https://habrastorage.org/webt/rc/6y/xv/rc6yxvsq6duv-xdujaamzq0fdry.png"><br>  <em>Starting sector - light gray, the final - blue.</em>  <em>Also note that instead of the door at the secret room (dark gray on the left) a wall is drawn - everything is correct, this is a secret wall.</em> </p><br><p>  Next, select the sector in which you can place the keys: </p><br><p><img src="https://habrastorage.org/webt/kl/os/jz/klosjzmyvv_tl2djbz5v6b9sqze.png"></p><br><p>  They are selected simply enough: </p><br><ul><li>  If this is a secret room, then there can be no openers in it, and the key cannot be placed there. </li><li>  You can not place the key in the final sector - after all, it is the final one. </li><li>  Also, the key cannot open double and triple doors - due to the nature of the engine, they can only be opened using the switch <em>(in the above illustration there are no such sectors)</em> . </li></ul><br><p>  After that, the number of keys at a level (from zero to three) is randomly selected, and then, in the same way, from the available list of sectors, those in which there will be keys are selected. </p><br><p>  In other sectors there will be switches. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418685/">https://habr.com/ru/post/418685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418675/index.html">How I went to Droidcon Berlin</a></li>
<li><a href="../418677/index.html">The whole truth about the RTOS. Article # 6. Other RTOS services</a></li>
<li><a href="../418679/index.html">Writing a component with ‚Äúmaterial‚Äù buttons for Svelte</a></li>
<li><a href="../418681/index.html">On Friendship Day - 50% discount on all IDE JetBrains for our friends</a></li>
<li><a href="../418683/index.html">Creating an emulator arcade machine. Part 2</a></li>
<li><a href="../418687/index.html">The 3.5 "revolution: details of a small diskette boom with wavepave music</a></li>
<li><a href="../418689/index.html">How to create a library of components in Figma, saving the budget, for example, an online auction</a></li>
<li><a href="../418691/index.html">Rancher: Kubernetes in 5 minutes on bare iron</a></li>
<li><a href="../418695/index.html">Anti-Piracy Wars - The Empire Strikes Back</a></li>
<li><a href="../418699/index.html">Creating an emulator arcade machine. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>