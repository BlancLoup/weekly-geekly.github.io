<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cheat Sheet for Technical Interview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This cheat sheet will help you prepare for a technical interview so you can brush up on key things. In fact, this is the content of the course on comp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cheat Sheet for Technical Interview</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/fk/or/_s/fkor_shnbmukmr_y8a3b41zwpeg.png"></p><br><p>  This cheat sheet will help you prepare for a technical interview so you can brush up on key things.  In fact, this is the content of the course on computer science without any details. </p><a name="habracut"></a><br><h2 id="osnovy-struktur-dannyh">  Basics of data structures </h2><br><h3 id="massiv">  Array </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Stores data items based on a sequential index, most often with a zero base. </li><li>  It is based on <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2582%25D0%25B5%25D0%25B6_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">tuples</a> from set theory. </li><li>  An array is one of the oldest and most used data structures. </li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  The array is optimal for indexing;  bad for searching, inserting and deleting (unless you do this at the very end of the array). </li><li>  The main variety is <strong>linear arrays</strong> , or one-dimensional. <br><ul><li>  Their size is static, that is, when a linear array is declared, a fixed size is specified. </li></ul></li><li>  <strong>Dynamic arrays</strong> are similar to linear ones, but they reserve space for additional elements. <br><ul><li>  When a dynamic array is populated, its contents are copied into a larger array. </li></ul></li><li>  <strong>Two-dimensional arrays</strong> have two indices x and y, like grids or nested arrays. </li></ul><br><p>  <strong><em>Efficiency ("O" large)</em></strong> : </p><br><ul><li>  Indexing: linear array - O (1), dynamic array - O (1). </li><li>  Search: linear array - O (n), dynamic array - O (n). </li><li>  Optimized search: linear array - O (log n), dynamic array - O (log n). </li><li>  Insertion: linear array - not allowed, dynamic array - O (n). </li></ul><br><h3 id="svyaznyy-spisok">  Linked list </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Data is stored in <strong>nodes</strong> pointing to other nodes. <br><ul><li>  A node contains one data item and one link (to another node). </li><li>  A linked list connects nodes with each other using links from one node to another. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  The linked list is designed to optimize insertion and deletion.  Slowly working when indexing and searching. </li><li>  <strong>A doubly linked list</strong> contains nodes that reference previous nodes. </li><li>  <strong>A ring link list</strong> is a simple link list whose <strong>tail</strong> (last node) refers to the <strong>head</strong> (first node). </li><li>  <strong>The stack is</strong> usually implemented using linked lists, but can also be created from arrays. <br><ul><li>  Stacks are <strong>LIFO</strong> data structures ( <a href="https://ru.wikipedia.org/wiki/LIFO">last in, first out</a> ). </li><li>  The head of the linked list underlying the stack is the only place to insert and delete items. </li></ul></li><li>  <strong>Queues</strong> can also be implemented using a linked list or array. <br><ul><li>  Queues are <strong>FIFO</strong> data structures ( <a href="https://ru.wikipedia.org/wiki/FIFO">first in, first out</a> ). </li><li>  The queue is a doubly linked list in which elements are removed from the head and added to the tail. </li></ul></li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Indexing: linked list - O (n). </li><li>  Search: linked list - O (n). </li><li>  Optimized search: linked list - O (n). </li><li>  Insert: the linked list is O (1). </li></ul><br><h3 id="hesh-tablica">  Hash table </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Data is stored as key-value pairs. </li><li>  <strong>Hash functions</strong> take a key and return output corresponding only to that key. <br><ul><li>  This process is called <strong>hashing</strong> : a one-to-one mapping of input and output data to each other. </li><li>  Hash functions return unique in-memory addresses for the data. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  Hash functions are designed to optimize search, insert, and delete. </li><li>  <strong>Hash collisions</strong> are situations where, for two different inputs, a function returns the same output. <br><ul><li>  This problem is common to all hash functions. </li><li>  Often it is solved by increasing the hash tables to a huge size. </li></ul></li><li>  Hashes are important for associative arrays and indexing databases. </li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Indexing: hash tables - O (1). </li><li>  Search: hash tables - O (1). </li><li>  Insert: hash tables - O (1). </li></ul><br><h2 id="dvoichnoe-derevo">  Binary tree </h2><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  A binary tree is a data structure in which each node has a maximum of two children. <br><ul><li>  Child elements are left and right. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  Trees are designed to optimize the list and sort. </li><li>  <strong>A degenerate tree</strong> is an unbalanced tree.  If it is completely one-sided, then it is, in fact, a linked list. </li><li>  Trees are relatively easy to implement compared to other data structures. </li><li>  Used to create <strong>binary search trees</strong> . <br><ul><li>  The binary tree decides which direction to go to the child node by comparing keys. </li><li>  The key of the left child node is smaller than that of the parent. </li><li>  The key of the right child node is larger than that of the parent. </li><li>  There can be no duplicate nodes. </li><li>  In connection with the foregoing, such a tree is more often used as a data structure than a binary tree. </li></ul></li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Indexing: binary search tree - O (log n). </li><li>  Search: binary search tree - O (log n). </li><li>  Insert: binary search tree - O (log n). </li></ul><br><h2 id="poisk">  Search </h2><br><h3 id="poisk-v-shirinu">  Search wide </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Search in width is an algorithm that searches by tree (or graph), looking through the levels starting from the root. <br><ul><li>  The algorithm finds all nodes of the current level, usually moving from left to right. </li><li>  During this process, it registers all the child nodes associated with the nodes at the current level. </li><li>  Upon completion of the search at the current level, the algorithm moves to the leftmost node of the next level. </li><li>  The last rightmost node of the lowest level is analyzed. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  A wide search is optimal for a search on a tree whose width exceeds the depth. </li><li>  While walking on the tree, the algorithm stores information about it in the queue. <br><ul><li>  Due to the use of a queue, this search method consumes more memory than a search in depth. </li><li>  The queue uses memory to store pointers. </li></ul></li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Search: search wide - O (| E | + | V |). </li><li>  E is the number of edges (faces?). </li><li>  V is the number of vertices. </li></ul><br><h3 id="poisk-v-glubinu">  Depth search </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Depth search is an algorithm that searches the tree (or graph), first in depth, starting from the root. <br><ul><li>  The algorithm goes through the tree, moving between the levels along the left child nodes, until it reaches the bottom. </li><li>  After completing the passage along the branch, the algorithm goes back, looking through the right child nodes of this branch.  And, if possible, selects the left-most of the nodes located to the right of the previous route. </li><li>  Having finished viewing the entire branch, the algorithm proceeds to the node located to the right of the root, and again goes along the left child nodes to the very bottom. </li><li>  The last analysis of the rightmost node (located to the right of all its predecessors). </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  The algorithm is optimal for searching the tree, whose depth exceeds the width. </li><li>  The algorithm uses a stack. <br><ul><li>  Since the stack is a LIFO structure, it does not need to keep track of node pointers; therefore, less memory is consumed than with a wider search. </li><li>  When the algorithm can not go further on the left side, it begins to analyze the stack. </li></ul></li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Search: depth search - O (| E | + | V |). </li><li>  E is the number of edges (faces?). </li><li>  V is the number of vertices. </li></ul><br><p>  <strong><em>Comparison of searches in width and in depth</em></strong> </p><br><ul><li>  Choose a search type according to the size and shape of the tree. <br><ul><li>  For wide, small trees use a wide search. </li><li>  For deep, narrow trees, use depth search. </li></ul></li></ul><br><p>  <strong><em>Nuances:</em></strong> </p><br><ul><li>  Since wide search uses queues to store information about nodes and their children, it may take up more memory than is available on your computer.  (But you hardly have to worry about it.) </li><li>  If you use depth-first search on a very deep tree, the algorithm may go too far down.  Read more about it <a href="http://xkcd.com/761/">here</a> . </li><li>  Search wide - cyclic algorithm. </li><li>  Search in depth is a recursive algorithm. </li></ul><br><h2 id="effektivnaya-sortirovka">  Efficient sorting </h2><br><h3 id="sortirovka-sliyaniem">  Merge sort </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Comparing data using a sorting algorithm: <br><ul><li>  The entire data set is divided into at least two groups. </li><li>  Pairs of values ‚Äã‚Äãare compared with each other, the smallest is moved to the left. </li><li>  After sorting within all pairs, the left values ‚Äã‚Äãof the two left pairs are compared.  Thus, a group of four values ‚Äã‚Äãis created: the smallest - on the left, the largest - on the right. </li><li>  The process is repeated until only one set is left. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  This is one of the fundamental sorting algorithms. </li><li>  The data are divided into as small sets as possible, which are then compared. </li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  The best sorting option: merge sorting - O (n). </li><li>  Medium sorting option: merge sorting - O (n log n). </li><li>  The worst sorting option: merge sorting is O (n log n). </li></ul><br><h3 id="bystraya-sortirovka">  Quick sort </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  A sorting algorithm based on a comparison. <br><ul><li>  The entire data set is divided in half by selecting the middle element and moving all those smaller than it to the left. </li><li>  Then the same procedure is performed iteratively with the left side until only two elements remain.  As a result, the left side will be sorted. </li><li>  Then all the same is done with the right side. </li></ul></li><li>  This algorithm is preferred to use in computing system architectures. </li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  Although ‚ÄúO‚Äù is large here it has the same values ‚Äã‚Äã(and in some cases it is worse) as many other sorting algorithms, but in practice this algorithm often works faster, for example, the same merge sort. </li><li>  The data will be consistently divided in half until they are completely sorted. </li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Best Sort: Quick Sort - O (n). </li><li>  Medium Sort: Fast Sort - O (n log n). </li><li>  The worst sorting option: quick sort is O (n ^ 2). </li></ul><br><h3 id="puzyrkovaya-sortirovka">  Bubble Sort </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  A sorting algorithm based on a comparison. <br><ul><li>  Iterates from left to right, comparing the values ‚Äã‚Äãinside each pair and moving the smallest to the left. </li><li>  The process is repeated until no value can be moved. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  The algorithm is very simple to implement, but the least effective of all three described here. </li><li>  Comparing the two values ‚Äã‚Äãand moving the smallest to the left, the algorithm moves one position to the right. </li></ul><br><p>  <strong><em>Efficiency ("O" large):</em></strong> </p><br><ul><li>  Best Sort: Bubble Sort - O (n). </li><li>  Medium sorting option: bubble sorting - O (n ^ 2). </li><li>  The worst sorting option: bubble sorting is O (n ^ 2). </li></ul><br><p>  <strong><em>Comparison of merge sorting and quick sorting algorithms</em></strong> </p><br><ul><li>  Quick sorting in practice is often more efficient. </li><li>  Merge sorting immediately divides the data set into the smallest possible groups, and then restores the set, incrementally sorting and enlarging the group. </li><li>  The quick sort sequentially divides the set by the mean value until it is sorted recursively. </li></ul><br><h2 id="osnovnye-tipy-algoritmov">  The main types of algorithms </h2><br><h3 id="rekursivnye-algoritmy">  Recursive algorithms </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  As follows from the definition, this algorithm calls itself. <br><ul><li>  <strong>Recursive script</strong> - when a conditional statement is used to start recursion. </li><li>  <strong>The baseline scenario</strong> is when a conditional statement is used to interrupt recursion. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  <strong>Stack level too deep and stack overflow.</strong> <br><ul><li>  If, during the operation of the recursive algorithm, you encounter one of the above, it means that you have spoiled everything. </li><li>  This means that the baseline script was never launched due to errors, or the problem was so serious that your memory ran out before the recursion was interrupted. </li><li>  Knowing whether you can achieve the baseline scenario is an integral part of the proper use of recursion. </li><li>  Such algorithms are often used when searching in depth. </li></ul></li></ul><br><h3 id="iterativnye-algoritmy">  Iterative Algorithms </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  An iterative algorithm is an algorithm that is called repeatedly, but a limited number of times.  Each call is a separate iteration. <br><ul><li>  Often used for incremental traversal of a data set. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li> Usually, iterations are represented as cycles, <code>for</code> , <code>while</code> and <code>until</code> expressions. </li><li>  Iteration is a single pass through the data set. </li><li>  Such algorithms are often used to process arrays. </li></ul><br><p>  <strong><em>Comparing recursiveness and iteration</em></strong> </p><br><ul><li>  It is difficult to distinguish recursiveness from iteration, since both are used to implement each other.  But: <br><ul><li>  Recursiveness is usually more expressive and easy to implement. </li><li>  Iteration consumes less memory. </li></ul></li><li>  <strong>Functional languages</strong> tend to use recursiveness (for example, Haskell). </li><li>  <strong>Imperative languages</strong> tend to use iteration (for example, Ruby). </li><li>  More information can be obtained from the post on <a href="http://stackoverflow.com/questions/19794739/what-is-the-difference-between-iteration-and-recursion">Stack Overflow</a> . </li></ul><br><p>  <strong><em>Pseudocode for traversing an array (which is why iteration is used for this)</em></strong> </p><br><pre> <code class="hljs vbscript"> |  ----------------------------------|---------------------------------- recursive method (<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, n) | iterative method (<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nil | <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n from <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> size of <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> print <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n] | print(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]) recursive method(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, n+<span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> |</code> </pre> <br><h3 id="zhadnye-algoritmy">  Greedy </h3><br><p>  <strong><em>Definition:</em></strong> </p><br><ul><li>  Greedy algorithms are called, choosing only the information that meets certain criteria. </li><li>  The greedy algorithm contains five main components: <br><ul><li>  The candidate set, on the basis of which the solution is created. </li><li>  A selection function that decides which best candidate will be added to the solution. </li><li>  The justification function (feasibility function), which decides whether a candidate can contribute to the decision. </li><li>  Objective function (objective function), which assigns a value to a solution or a partial value. </li><li>  The solution function (solution function), which signals that we have found a complete solution. </li></ul></li></ul><br><p>  <strong><em>What you need to know:</em></strong> </p><br><ul><li>  Greedy algorithms are used to find the optimal solution to this problem. </li><li>  They are usually applied to data sets in which only a small portion of the processed information gives the desired result. </li><li>  Often greedy algorithms can help in reducing the ‚ÄúO‚Äù of a large other algorithm. </li></ul><br><p>  Pseudo-code greedy algorithm for finding the biggest difference between two numbers in an array </p><br><pre> <code class="hljs pgsql">greedy algorithm (<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) var largest difference = <span class="hljs-number"><span class="hljs-number">0</span></span> var <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> difference = find next difference (<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[n], <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[n+<span class="hljs-number"><span class="hljs-number">1</span></span>]) largest difference = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> difference <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> difference <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> &gt; largest difference repeat above two steps <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> differences have been <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> largest difference</code> </pre> <br><p>  This algorithm does not need to compare with each other all the differences, which saves us a whole iteration. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350326/">https://habr.com/ru/post/350326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350316/index.html">Creating a game on Lua and L√ñVE - 4</a></li>
<li><a href="../350318/index.html">There is a job for chatbot: virtual assistant help desk</a></li>
<li><a href="../350320/index.html">Rocket straight in the AppStore</a></li>
<li><a href="../350322/index.html">Gentleman's set in the field of marketing and sales of the company-developer of custom software</a></li>
<li><a href="../350324/index.html">Unity 2018 and ProBuilder: create, edit and texture 3D models directly in the editor</a></li>
<li><a href="../350328/index.html">Reinforcement training never worked</a></li>
<li><a href="../350332/index.html">Vue.js + Asp.Net Core MVC + TypeScript and more Bootstrap4</a></li>
<li><a href="../350334/index.html">One day at Alfa-Bank: mobile development</a></li>
<li><a href="../350336/index.html">System crafting in the Cursed Lands</a></li>
<li><a href="../350338/index.html">Setting up the proftpd + {mysql / postgresql} bundle with storing passwords in md5 + salt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>