<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>More than go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When throwing pebbles into the water, look at the circles they form; 
 otherwise, such a throwing will be empty fun. 

 Kozma bars " Fruits of meditat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>More than go</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/2a4/61e/ed7/2a461eed7238486cb288a6666020cb5e.PNG">  <b><i>When throwing pebbles into the water, look at the circles they form;</i></b> <b><i><br></i></b>  <b><i>otherwise, such a throwing will be empty fun.</i></b> <b><br><br></b>  <b><a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B7%25D1%258C%25D0%25BC%25D0%25B0_%25D0%259F%25D1%2580%25D1%2583%25D1%2582%25D0%25BA%25D0%25BE%25D0%25B2">Kozma bars</a> " <a href="http://az.lib.ru/p/prutkow_k_p/text_0080.shtml">Fruits of meditation</a> "</b> <b><br><br></b> <br>  This game is a real <a href="https://github.com/GlukKazan/ZoG/commits/master/Axiom/Margo">unfinished</a> .  I started working on it back in <a href="http://habrahabr.ru/post/259611/">June</a> !  I can‚Äôt say that every day I broke up, but she spoiled a lot of blood for me.  Today, this is my most difficult project in <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> .  In terms of the (highly non-trivial) code, <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">MarGo is</a> comparable, perhaps, to <a href="http://habrahabr.ru/post/234587/">Rhythmomachia</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is special about this game?  Was it worth it to suffer so much?  I will tell, and you judge. <br><a name="habracut"></a><br><h4>  <b>Surface similarity</b> </h4><br>  Attempts to ‚Äúimprove‚Äù <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE">Go were</a> made repeatedly, but they were rarely successful.  MarGo, in my opinion, just such a rarity!  The main thing that is captivating in this game is the fact that it is <b>above the</b> set of Go.  I already <a href="http://geektimes.ru/post/240456/">wrote</a> about how the seemingly simple rules of Guo lead to unexpectedly complex tactical constructions.  I will not repeat myself, let me just say that everything I wrote about Go also applies to MarGo too (as long as we do not go beyond the limits of the plane).  So, for example, looks like the famous " <a href="http://www.e-reading.club/chapter.php/112811/39/Stepanov,_Grishin,_Emel%27yanov_-_Myslit%27_i_pobezhdat%27__igra_Go_dlya_nachinayushchih.html">latch</a> " - the simplest victim of one stone, in order to get three: <br><br><img src="https://habrastorage.org/files/a27/022/021/a270220215884ea9aadbd5873819c1f8.PNG"><br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  Using any ‚Äúclips‚Äù on the position above is completely unnecessary!  Black is already doomed, there is no need to ‚Äúfinish‚Äù it.  But why use such small boards in MarGo?  The main reason is that the game is not on the plane, but in volume.  Players build pyramids and hardly anyone has the patience to do this on a 19x19 board.  The standard for MarGo is a 9x9 board, in Go it is used mainly for training beginners! <br><br>  For me, this was a great relief, because already when using the 9x9 board, I ran into problems of lack of memory.  I had to <a href="http://habrahabr.ru/post/260599/">optimize</a> its use by removing extra strings from the array.  This moment is quite obvious - by building a pyramid, we can never place figures on most of the fields of a three-dimensional board. <br></div></div><br>  When determining the status of groups, only empty points located in the plane of the board are important.  Each stone of a ‚Äúliving‚Äù group must be connected (directly or through other stones) to at least one of such points (called ‚Äú <b>dame</b> ‚Äù).  As soon as the last <b>dame</b> is closed, the group becomes dead and is removed from the board. <br><br><div class="spoiler">  <b class="spoiler_title">How it works?</b> <div class="spoiler_text">  The basis of Go functionality is the mechanism of removing stones in the environment.  It works quite simply.  To begin with, it is necessary to identify the stones that are certainly alive (they are adjacent to empty points on the board).  Then, all stones (of the same color) adjacent to any of the previously added stones should be added to the group of ‚Äúliving‚Äù stones. <br><br>  Everything would be fine if it were not for the stupid semantics of the progress in ZoG / Axiom.  Throughout the course of construction of the course, the contents of the board looks like at the time of the start of the calculation (all changes made by the course will become visible only after its completion).  In simple cases, this can be fought, but our game has never been easy!  Due to the fact that we create the illusion of three-dimensionality, adding only one piece to the board can lead to the displacement of a large number of tile-figures.  Handling all these "special cases" in a special way is completely unrealistic!  I had to divide the addition of a new piece to the board and the subsequent deletion of the ‚Äúkilled‚Äù pieces: <br><br><pre><code class="hljs pgsql">{players {player} W {player} B {player} ?C {random} players} {turn-<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> {turn} W {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} normal {turn} ?C {<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-player} W {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} clean {turn} B {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} normal {turn} ?C {<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-player} B {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} clean turn-<span class="hljs-keyword"><span class="hljs-keyword">order</span></span>}</code> </pre> <br>  In order for the ‚Äúcleaning‚Äù to be performed automatically, we had to create another player acting on behalf of the owners of the figures.  His move consists in placing a special (invisible) figure on one of the unused board fields (there are a lot of such fields, despite <a href="http://habrahabr.ru/post/260599/">optimization</a> ).  All actions to remove the "dead" groups are performed as a "side effect" of this move: <br><br><pre> <code class="hljs dos">: drop-m ( -- ) here a1 = <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> (   ? ) drop (   ) ['] my-enemy? (    ) init-alive (       ) proceed-alive (     ) capture-all (         ) captured-tiles @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (       ) ['] my-friend? (        ) init-alive proceed-alive capture-all ENDIF add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> (    ) ;</code> </pre><br>  This code solves two problems at once: <br><br><ol><li>  Deleting all enemy groups killed by the last move </li><li>  A friendly group's suicide, if the move was suicidal and you could not kill any of your enemies </li></ol><br><div class="spoiler">  <b class="spoiler_title">More details</b> <div class="spoiler_text"><pre> <code class="hljs php">TOTAL [] alive[] (    ) VARIABLE alive-count (    ) : not-alive? ( -- ? ) (    ) <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN DUP alive-count @ &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP alive[] @ here = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> SWAP DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> SWAP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>+ <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL DROP ; : add-alive ( -- ) (    ) not-alive? alive-count @ TOTAL &lt; <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (    ! ) here alive-count @ alive[] ! alive-count ++ <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-alive ( <span class="hljs-string"><span class="hljs-string">'op '</span></span>dir -- ) (     ) EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> add-alive <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : init-alive ( <span class="hljs-string"><span class="hljs-string">'op -- '</span></span>op ) (   ) <span class="hljs-number"><span class="hljs-number">0</span></span> alive-count ! <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN (       ! ) DUP <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>-at? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP to OVER [<span class="hljs-string"><span class="hljs-string">'] n check-alive DUP to OVER ['</span></span>] s check-alive DUP to OVER [<span class="hljs-string"><span class="hljs-string">'] w check-alive DUP to OVER ['</span></span>] e check-alive <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>+ DUP PLANE &gt;= UNTIL DROP ; : proceed-alive ( <span class="hljs-string"><span class="hljs-string">'op -- '</span></span>op ) (   <span class="hljs-string"><span class="hljs-string">""</span></span>  ) <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN (     ) DUP alive-count @ &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP alive[] @ to OVER [<span class="hljs-string"><span class="hljs-string">'] n check-alive DUP alive[] @ to OVER ['</span></span>] s check-alive DUP alive[] @ to OVER [<span class="hljs-string"><span class="hljs-string">'] w check-alive DUP alive[] @ to OVER ['</span></span>] e check-alive <span class="hljs-number"><span class="hljs-number">1</span></span>+ <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL DROP ;</code> </pre><br></div></div><br></div></div><br>  The small size of the board leads to high competition for <b>dame</b> .  Those of you who play Go must know that the fights on a small board (9x9) can be much more fierce than playing on a standard board (19x19).  From the very first move, players enter into tight contact and are forced to continuously solve the ‚Äúlife and death‚Äù tasks.  Such is the game in MarGo, but if that were the case, I would not talk about it. <br><br><h4>  <b>Main difference</b> </h4><br>  The name of the game consists of two words: "marbles" (balls) and "Go".  Together it turns out - ‚Äúthe game of go balls‚Äù.  What is the difference from the traditional game?  In its three-dimensionality!  Attempts to play Go on three-dimensional boards were made several times (I <a href="http://geektimes.ru/post/252036/">wrote</a> about a program that allows you to play on arbitrary graphs), but in most of these cases, the game balance was seriously affected.  The exception, perhaps, is only a board that imitates a diamond crystal lattice.  It is much like a classic flat board.  Each node has from 2 to 4 neighbors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/727/85d/b06/72785db068954845af18145fffe78e3f.png"></div><br>  MarGo's approach is completely different.  The ball can not just "hang in the air."  In order to ‚Äúrise above the board,‚Äù he must rely on four other balls (his own or his opponent's).  Of course, in order for this ball to remain alive, it must be in contact with a group that has access to at least one <b>dame</b> .  Vertical directions are added to the orthogonal connections lying in the plane of the board, connecting the balls at the base of the pyramid with its top. <br><br>  This connection works both ways.  Access to the <b>dame</b> not only gives life to the "top" of the pyramid, but can also move on to the lower layers, bending around enemy figures lying in the plane of the board.  This alone can make the game more interesting, but there is another, much less obvious point.  As long as the stone at the top of the pyramid remains ‚Äúalive‚Äù, the stones from its base cannot be removed, even if they belong to the ‚Äúdead‚Äù group! <br><br><img src="https://habrastorage.org/files/b92/76e/719/b9276e71990744548dad97f64882363d.PNG"><br><br>  Such stones, deprived of access to a <b>dame</b> and crushed by figures of a different color, are called ‚Äúzombies‚Äù and they remain on the board when the rest of the ‚Äúkilled‚Äù group leaves it.  Zombies are equated to captured stones (removed from the board), but as long as they remain on the board, they can ‚Äútransfer‚Äù access to the <b>dam to</b> other stones (if it suddenly appears).  In addition, zombies can be brought back to life by removing the top of the pyramid. <br><br><div class="spoiler">  <b class="spoiler_title">Invasion of three dimensions</b> <div class="spoiler_text">  I already <a href="http://habrahabr.ru/post/259611/">wrote</a> that to create the effect of three-dimensionality, I had to divide each figure into 4 tiles.  It works, but the snag is that tile figures have to be placed on a ‚Äúthree-dimensional‚Äù board in a rather bizarre way.  There is no way to avoid this.  All tiles visible "from above" must be in the same plane.  This layout pattern also has its own additional advantages, but the navigation in it is too intricate.  For starters, I needed a meditation <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25BD%25D0%25B4%25D0%25B0%25D0%25BB%25D0%25B0">mandala</a> : <br><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">4</span></span> AA <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-params"><span class="hljs-params">|9 9 2 5 5|</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span><span class="hljs-params"><span class="hljs-params">|7 7 1 1 1|</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-params"><span class="hljs-params">|3 3|</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> + ABCDEFGH <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-params"><span class="hljs-params">|5|</span></span><span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-params"><span class="hljs-params">|AA|</span></span><span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-params"><span class="hljs-params">|7|</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-params"><span class="hljs-params">|2 2|</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-params"><span class="hljs-params">|4 3 5|</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span><span class="hljs-params"><span class="hljs-params">|7 4 8|</span></span><span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  I agree that the picture is so-so, but it allowed me to somehow orient myself.  I needed directions for the natural movement within this scheme.  Fortunately, from the point of view of the Axiom, directions are just functions that change the position of the current position marker as a side effect of its call (the main result of calling such a function is returning a boolean value indicating success of the move).  In general, the directions could be redefined and, soon, I had a whole hierarchy of them: <br><br><img src="https://habrastorage.org/files/aa5/2d5/016/aa52d5016b3349de95e0721e0ae43d79.PNG"><br><br>  The diagram shows only functions that lead strictly to the "north" (in a sense).  Some of them I have used previously.  The direction of ' <b>n</b> ', for example, I had to enter when I threw out extra lines from the ‚Äúboard‚Äù array, in order to optimize memory usage.  The main part of the "rocket science" is a function that allows you to move in a plane parallel to the plane of the board: <br><br><div class="spoiler">  <b class="spoiler_title">I will not even try to comment on this.</b> <div class="spoiler_text"><pre> <code class="hljs cmake">: common-internal ( 'dir -- ? ) here is-plane? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> get-height SWAP EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> get-height - DUP <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> BEGIN d <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> UNTIL empty? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> u verify <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> here OVER EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> to BEGIN u <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ;</code> </pre><br></div></div><br>  Most of the subsequently found errors were associated with this function (and I am still not sure that I fixed them all).  On its basis, such movements as north-internal, south-internal, etc. are constructed: <br><br><pre> <code class="hljs swift">: north-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ( -- ? ) ['] n common-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ; : south-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ( -- ? ) ['] s common-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ; : west-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ( -- ? ) ['] w common-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ; : east-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ( -- ? ) ['] e common-<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> ;</code> </pre><br>  These are practically full-fledged functions of moving, possessing only one drawback.  In case of unsuccessful movement, the position position of the current position becomes undefined.  It is easy to fix.  It is enough to remember the location of the marker <b>before</b> moving and restore it if it was not possible to move for any reason: <br><br><pre> <code class="hljs cmake">: wrap-direction ( 'dir -- ? ) here (   <span class="hljs-string"><span class="hljs-string">""</span></span> ) SWAP EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (      ) DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> (    ,    ) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> (   ,  <span class="hljs-string"><span class="hljs-string">""</span></span>    ) <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : north ( -- ? ) ['] north-internal wrap-direction ; : south ( -- ? ) ['] south-internal wrap-direction ; : west ( -- ? ) ['] west-internal wrap-direction ; : east ( -- ? ) ['] east-internal wrap-direction ;</code> </pre><br>  There are very few.  In addition to the "horizontal" movements lying in the plane of the board, directions are needed leading from one plane to another ("up" and "down"): <br><br><div class="spoiler">  <b class="spoiler_title">Some more strange code without comment</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">: up-internal ( -- ? ) here <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-plane? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-literal"><span class="hljs-literal">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> BEGIN u <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL ENDIF <span class="hljs-literal"><span class="hljs-literal">TRUE</span></span> ENDIF ; : down-internal ( -- ? ) here <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-plane? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-literal"><span class="hljs-literal">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> BEGIN d <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> UNTIL <span class="hljs-literal"><span class="hljs-literal">empty</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> u verify ENDIF <span class="hljs-literal"><span class="hljs-literal">TRUE</span></span> ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> u verify here <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-plane? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ENDIF ; : up ( -- ? ) [<span class="hljs-comment"><span class="hljs-comment">'] up-internal wrap-direction ; : down ( -- ? ) ['] down-internal wrap-direction ;</span></span></code> </pre><br></div></div><br>  That's all!  Now we have a complete set of directions required for the detection of "connected" groups. <br></div></div><br>  Zombies - an interesting new entity, generated by simple and logical rules of the game.  Interesting, but not the only one!  MarGo stockpiled other surprises. <br><br><h4>  <b>Bridges and gorges</b> </h4><br>  The stones at the top of the pyramid ‚Äúpass‚Äù access to the <b>dam to</b> friendly stones, which might be surrounded, everything happens on a plane.  There is another way to avoid the environment!  But wait, this is exactly the reason why it is not very interesting to play Go in <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D431">three dimensions</a> .  Groups getting too hard to kill!  There is a way to fix it. <br><br><img src="https://habrastorage.org/files/8d6/60a/ebf/8d660aebfb1f4e01a2010aea8015faf1.PNG"><br><br>  In Go, such a connection is considered not to be cut in principle, regardless of the possible errors of the player who built it.  The stones standing nearby live and die together.  They can not be separated, but not in MarGo!  In this game, standing stones can be "cut" by building a bridge over them.  The stones that are on the bottom, on opposite sides of the bridge, turn into two separate groups. <br><br><div class="spoiler">  <b class="spoiler_title">On the other side of the bridge</b> <div class="spoiler_text">  The essence of the "cutting" is that we can not move in the chosen direction.  This means that we will have to expand the hierarchy of directions, which I wrote about above, adding a new direction, controlling the presence ‚Äúabove the head‚Äù of a bridge built of foreign figures.  Since the rule of ‚Äúcutting bridges‚Äù is very similar to the option (the game can be interesting without it), we define a constant flag that controls its operation: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> BRIDGE-CUTTING</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Then everything is simple</b> <div class="spoiler_text"><pre> <code class="hljs cmake">: is-covered? ( -- ? ) player up empty? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> player &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : check-bridge? ( 'dir piece-type -- ? ) piece-type SWAP <span class="hljs-keyword"><span class="hljs-keyword">equal</span></span>-types? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here is-covered? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> SWAP OVER to EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> is-covered? SWAP to <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> to DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : common-cutting ( 'dir 'dir piece-type 'dir piece-type -- ? ) BRIDGE-CUTTING <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> check-bridge? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> check-bridge? <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-number"><span class="hljs-number">2</span></span>DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ; : north-cutting ( -- ) ['] north ['] east nw-piece ['] west ne-piece common-cutting ; : south-cutting ( -- ) ['] south ['] east sw-piece ['] west se-piece common-cutting ; : west-cutting ( -- ) ['] west ['] south nw-piece ['] north sw-piece common-cutting ; : east-cutting ( -- ) ['] east ['] south ne-piece ['] north se-piece common-cutting ;</code> </pre><br></div></div><br>  <b>Is</b> all the magic hidden in the <b>check-bridge?</b>  .  To define a ‚Äúbridge‚Äù above your head, we ‚Äúlook‚Äù up in search of someone else‚Äôs tile.  We do the same on the next tile.  If both tiles are ‚Äúcovered‚Äù with figures of another color (different), we ‚Äúchop‚Äù the corresponding direction, replacing the value returned by them with a false one. <br></div></div><br>  Do you think the surprises are over on this?  No matter how wrong! <br><br><h4>  <b>The most difficult case</b> </h4><br>  Suicidal moves are forbidden (and for the most part useless).  A player can not put his stone "in the environment", if it does not take a single opponent stone.  In Go, this is simple.  If we take a group of stones, it must be in contact with the newly added stone and its ‚Äúkilling‚Äù will reveal the <b>dame</b> we need for survival.  But in MarGo there are zombies! <br><br><img src="https://habrastorage.org/files/908/dea/d0a/908dead0a36141dab90a6cc573e3833d.PNG"><br><br>  Even taking a stone at the top of the pyramid, the white stone will still be ‚Äúsurrounded‚Äù, thereby creating an unacceptable position!  Two black stones make up a ‚Äúvirtual group‚Äù protected by a ‚Äúzombie‚Äù underlying it.  It's funny that this protection is very ephemeral.  If white, for some reason, manages to take any of the four stones next to him, the protection of the ‚Äúvirtual group‚Äù will cease to act.  This is not just an artificial construction.  Virtual groups - an important tactical component of the game MarGo!  What do you say, for example, about the status of this position? <br><br><img src="https://habrastorage.org/files/57e/f4d/58b/57ef4d58b2014921bc603ec4cd3b49ae.png"><br><br>  It looks like a completely surrounded group (with one ‚Äúeye‚Äù), which the white began to eat.  In principle, the way it is, but to ‚Äúfinish‚Äù the black group is not so simple.  White can not just go to the lower left corner.  Since two white stones surround only ‚Äúzombies‚Äù, such a move will be considered suicidal.  But black should not be in a hurry to eat the invading white stone: <br><br><img src="https://habrastorage.org/files/629/526/994/6295269949904ec7803604fcf41fa4c7.png"><br><br>  Black adds a non-‚Äúzombie‚Äù stone to the board, thereby destroying the protection of the ‚Äúvirtual group‚Äù.  White gets the right to go to the same place where his stone had just been eaten, taking five black stones.  It turns out that the best solution for black is not to do anything?  Of course, it is not.  White has another opportunity to kill the group. <br><br><img src="https://habrastorage.org/files/523/48a/38f/52348a38fe9b4a9ab554fb485a220be9.PNG"><br><br>  If black ignores this threat - his group is doomed!  By connecting their groups, the white player will be able to safely occupy the last <b>dame</b> .  Protection against such an invasion is obvious.  The best opponent move is your best move! <br><br><div class="spoiler">  <b class="spoiler_title">Really difficult</b> <div class="spoiler_text">  As I wrote above, I had to divide the addition of a stone and the removal of ‚Äúdead‚Äù groups into two successive moves (otherwise it would be very difficult).  Among other inconveniences, this means that I cannot forbid a player to make a move, simply on the basis that he is "suicidal."  In principle, this is not a very big problem.  Let us make a move and let the added stone just die (maybe with a group of other stones of its color), but this is only part of the problem!  Remember, I wrote something like this code? <br><br><pre> <code class="hljs dos">: drop-m ( -- ) here a1 = <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> drop ['] my-enemy? init-alive proceed-alive check-zombies capture-all captured-tiles @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> ['] my-friend? init-alive proceed-alive check-zombies capture-all captured-tiles @ NEGATE update-variables <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> captured-tiles @ update-variables ENDIF add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ;</code> </pre><br>  We are trying to remove the enemy‚Äôs stones and, if this failed, we try to remove ours (while counting the stones taken).  So, this code does not work!  Indeed, if you look at our cunning case, you can see that the enemy‚Äôs stones are removed, but the added stone still remains surrounded!  This is really a problem.  In order for everything to work properly, we must remove the dead stones of the enemy, then our own and, if we succeed, return the enemy‚Äôs stones to their place.  Yes, in Axiom there are functions that allow you to create a copy of the board, make some changes to it, and then roll back everything, but I would not like to use them here!  Fortunately, there is another, well-functioning mechanism for rolling back changes. <br><br><div class="spoiler">  <b class="spoiler_title">We divide the code for deleting "dead" groups into two parts</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">{players {player} W {player} B {player} ?C {random} players} {turn-<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> {turn} W {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {turn} ?C {<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-player} W {turn} B {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {turn} ?C {<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-player} B turn-<span class="hljs-keyword"><span class="hljs-keyword">order</span></span>} {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-priorities {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-priority} normal-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-priority} low-priority <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-priorities} {moves w-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-w {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-nw {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority moves} {moves n-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-n {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-ne {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority moves} {moves e-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-e {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-se {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority moves} {moves s-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-s {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>-sw {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} high-priority moves} {moves m-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} clear-e {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} normal-priority {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>} clear-f {<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>} low-priority moves} {pieces {piece} M {drops} m-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {piece} tw {drops} w-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {piece} zw {piece} ww {piece} bw {piece} tn {drops} n-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {piece} zn {piece} wn {piece} bn {piece} te {drops} e-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {piece} ze {piece} we {piece} be {piece} ts {drops} s-<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> {piece} zs {piece} ws {piece} bs pieces}</code> </pre><br></div></div><br>  With a higher ( <b>normal</b> ) priority, the removal code of the enemy's dead groups (clear-e) will be executed, and with a low ( <b>low</b> ) - removal of their dead groups ( <b>high</b> level, outside the priority list, we reserve for the usual addition of stones to the board).  Now everything works as it should.  First, the move generator attempts to perform a higher-priority <b>clear-e</b> , at the end of which we check whether the added stone has got into the environment (prohibiting the move, if this happened).  If the priority move fails any of the checks, the move generator <b>itself</b> rolls back all the changes, and fulfills the low <b>-</b> priority <b>clear-f</b> .  This code is always successful.  Sometimes a side effect of its execution is the removal of ‚Äúsuicide‚Äù groups. <br><br><div class="spoiler">  <b class="spoiler_title">Cleaning code too complicated</b> <div class="spoiler_text"><pre> <code class="hljs dos">: clear-e ( -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> captured-count ! here a1 = <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> drop ['] my-enemy? init-alive proceed-alive check-zombies capture-all captured-tiles @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> captured-tiles @ update-variables ['] my-friend? init-alive proceed-alive check-zombies check-<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-captured add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ; : clear-f ( -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> captured-count ! here a1 = <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> drop ['] my-friend? init-alive proceed-alive check-zombies capture-all captured-tiles @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> captured-tiles @ NEGATE update-variables <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP ENDIF add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ;</code> </pre><br></div></div><br>  In general, a little confused, but it works. <br></div></div><br><h4>  <b>Without Ko no Go</b> </h4><br>  Well, there is another <a href="http://geektimes.ru/post/240680/">difficult case</a> , safely inherited from a more traditional version of the game.  Since, as I said, in the plane of the board, all the rules of Go remain in force, it is possible to do the following focus: <br><br><img src="https://habrastorage.org/files/aad/fb3/956/aadfb3956bbf40d2a163f1915af08773.PNG"><br><br>  If you somehow do not break off all this fun, players will be able to devour each other‚Äôs stones indefinitely.  Of course, MarGo cannot allow this and prohibits moves leading to the repetition of the previous position.  In the <a href="http://www.cameronius.com/games/margo/margo-basics-41.pdf">rules of the game</a> , we are talking about the <a href="http://senseis.xmp.net/%3FSuperko">situational superko</a> <br><br><img src="https://habrastorage.org/files/29e/543/f66/29e543f6689146af8bde5ca651b19220.PNG"><br><br>  Black cannot eat a white stone immediately and has to walk in another part of the board.  The next move, white can connect. <br><br><div class="spoiler">  <b class="spoiler_title">From life invisible</b> <div class="spoiler_text">  Alas, I do not realize the detection of any positional or situational superko.  This requires information about previous positions (at least hashes), but I do not have it!  Fortunately, all these " <a href="http://www.gameofgo.ru/7.htm">cyclical ko</a> ", " <a href="http://www.gameofgo.ru/8.htm">eternal life</a> " and other exotic positions do not make the weather.  In real Co-wrestling, almost always, <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BA%25D0%25BE">simple Ko</a> .  We will catch him. <br><br><div class="spoiler">  <b class="spoiler_title">To prohibit a move to an ‚Äúempty‚Äù item, you must make it non-empty.</b> <div class="spoiler_text"><pre> <code class="hljs dos">: drop-marks ( -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN DUP captured-count @ &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> mark OVER captured[] @ create-piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>+ FALSE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> TRUE ENDIF UNTIL DROP ; : clear-marks ( -- ) <span class="hljs-number"><span class="hljs-number">0</span></span> BEGIN DUP empty-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> mark = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP capture-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> ENDIF ENDIF <span class="hljs-number"><span class="hljs-number">1</span></span>+ DUP PLANE &gt;= UNTIL DROP ;</code> </pre><br></div></div><br>  We can place invisible tiles on the board to make it impossible to move to the selected position.  When making a move to any permitted item, we will simply remove this interference.  Here, one of the important properties of MarGo plays into our hands.  Any Ko-fight will always occur in the plane of the base of the board!  So that the added "empty" tiles do not interfere with the determination of the status of groups, we will change the function of determining the void node: <br><br><pre> <code class="diff hljs">: my-empty-at? ( pos -- ? ) DUP curr-pos ! - empty-at? IF + DUP empty-at? SWAP piece-type-at mark = OR IF TRUE ELSE ... ENDIF ;</code> </pre><br>  It remains to add Ko-mark on the board.  We do this in the place of the enemy's stone shot, provided that if this stone had not been removed, the ‚Äúsuicide‚Äù group would consist of exactly one stone that had just been added.  Sounds hard?  In general, yes, the way it is. <br></div></div><br><h4>  <b>What is behind the scenes?</b> </h4><br>  Of course, not everything went smoothly.  I simply could not implement some rules.  Suicidal moves, for example, in MarGo are absolutely prohibited.  This means that the player does not have the right to make a move which deprives a group (possibly consisting of only one stone that has just been added) of the last <b>dame</b> , provided that it does not take the opponent‚Äôs stones. <br><br>  I was forced to divide the moves that performed the addition of a stone and the removal of the stones taken, which deprived me of any possibility of prohibiting "suicidal" moves.  This may seem like a trifle.  In the end, although the ‚Äúsuicidal‚Äù moves are prohibited in most variants of the Go <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%2598%25D0%25BD%25D0%25B3%25D0%25B0">rules, the Inga rules</a> allow them.  There is a good reason for this.  There are (very rare) positions in which the killing of one‚Äôs own group allows the player to escape in a completely <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%2598%25D0%25BD%25D0%25B3%25D0%25B0">hopeless situation</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ef8/f2c/dc3/ef8f2cdc3208428eb915d51e08d6e87c.png"></div><br><br>  <a href="http://www.gameofgo.ru/5.htm">Seki</a> will not bring points, but compared to the total loss of the group, this is a serious help, because the enemy will not receive points either!  Unfortunately, one pulls the other.  In MarGo (unlike Go), players are forbidden to miss a move. ,    , ,  ,     ,       .     <abbr title="        !"> </abbr> ?   ,      . <br><br>   ,     ,     .  AI   <b></b> .      !     ¬´¬ª         ,      .       AI   ( ZoG   DLL-engine      ).     AI,  ,   ,   . <br><br>      ¬´¬ª   (     ),  <abbr title="         "> </abbr> ( ,      ,   <a href="http://geektimes.ru/post/241844/"></a> ).      ,         . MarGo    .    ,    ,    ¬´¬ª,      .  ,   .        ¬´¬ª       . ,  <b></b>    !      ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c8d/0d9/08c/c8d0d908cabd41e7b044c8c4a50c4e71.PNG"></div><br><br>  ,   ,  ,   .  ,    . MarGo     ,     ¬´¬ª. ,      4x4,   16   ,    ¬´¬ª    4  (     ,    ).  ,    4x4  ,       .    ,           ForthScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8a6/441/4a2/8a64414a2ad843d2996f77b6628f9f34.PNG"></div><br><br>    ‚Äî   .  ,    ,  ,  ,  ¬´¬ª (,   ),   ,  , ,   ,    (   ‚Äî  ). ,   ,      ¬´¬ª ,   ZoG    ! <br><br>        ,     ,         AI   .  , , . <br></div><p>Source: <a href="https://habr.com/ru/post/274043/">https://habr.com/ru/post/274043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274029/index.html">Free hosting control panels. Goddess vesta</a></li>
<li><a href="../274033/index.html">A little bit about working with containers</a></li>
<li><a href="../274035/index.html">SVG highs and lows</a></li>
<li><a href="../274037/index.html">How to kill the smartphone Sony Xperia C2305 using a router D-Link DIR-300</a></li>
<li><a href="../274041/index.html">Interactive Client Map - Apache Spark Streaming and Yandex.Maps</a></li>
<li><a href="../274045/index.html">Protecting the Scrypt Encryption Utility with the Intel¬Æ Tamper Protection Toolkit</a></li>
<li><a href="../274049/index.html">Happy New Year 2016</a></li>
<li><a href="../274051/index.html">My Location Companion application for ViaLatM service</a></li>
<li><a href="../274053/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 28. "Carder Court"</a></li>
<li><a href="../274055/index.html">Work on the design of space reptiloids: wandering through the maze of possibilities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>