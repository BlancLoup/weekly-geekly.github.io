<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CoffeeScript: Detailed Cycle Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, CoffeeScript offers a slightly different set of control structures than JavaScript . 



 Despite the fact that the language developers m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CoffeeScript: Detailed Cycle Guide</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/363/111/98a/36311198a5ca70be13e4d1189d46d778.jpg" alt="CoffeeScript: Detailed Cycle Guide"><br><br><p>  As you know, <i>CoffeeScript</i> offers a slightly different set of control structures than <i>JavaScript</i> . </p><br><br><p>  Despite the fact that the language developers maximally simplified the <a href="http://en.wikipedia.org/wiki/Formal_grammar">grammar</a> and gave a detailed description of all the <a href="http://en.wikipedia.org/wiki/Statement_%2528programming%2529">instructions</a> , making a more or less non-standard cycle for many remains a great difficulty. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><br><br><br><br><p>  In this article I will try to tell as much as possible about the principles of working with cycles in <i>CoffeeScript</i> and closely related control structures. </p><br><br><p>  All code is accompanied by comparative examples in <i>JavaScript</i> . </p><br><br><br><h4>  For-in instruction </h4><br><p>  Let's start with the simplest for loop: </p><br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... }</code> </pre> <br><p>  In CoffeeScript, it will be written like this: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br><p>  <a href="http://en.wikipedia.org/wiki/Range_%2528computer_programming%2529">Ranges</a> are used to determine the number of iterations. <br>  In our case, the range from <i>0 ... 10</i> means: perform <i>10</i> iterations of the loop. </p><br><p>  But what if you want to specify a condition of type <i>i &lt;= 10</i> ? </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre><br><p>  At first glance, nothing has changed, but if you look closely, you will notice that in the range of one point has become less. </p><br><br><p>  As a result, we get the following entry: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... }</code> </pre><br><p>  If the initial value of the range is greater than the final <i>[10..0]</i> , then we will get a reverse cycle with an inverted result: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">10</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>.. }</code> </pre><br><p>  I want to note, it is also possible to use negative values ‚Äã‚Äãof the range: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [-<span class="hljs-number"><span class="hljs-number">10</span></span>..<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  And so, you can fill the array with negative values: <br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>..-<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#[0, -1, -2, -3]</span></span></code> </pre><br><p>  Now consider the real situation, using the example of a function that calculates the factorial of the number n: </p><br><br><h6>  Javascript: </h6><br><pre> <code class="ruby hljs">var factorial = function(n) { var result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= n; i++) { result *= i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }; factorial(<span class="hljs-number"><span class="hljs-number">5</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/120</span></span></code> </pre><br><br><h6>  CoffeeScript: </h6><br><pre> <code class="ruby hljs">factorial = (n) -&gt; result = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..n] result *= i result factorial <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">#120</span></span></code> </pre><br><p>  As you can see from the example above, the <i>CoffeeScript</i> code is more compact and readable compared to <i>JavaScript</i> . </p><br><br><p>  However, this code can be slightly simplified: </p><br><br><pre> <code class="ruby hljs">factorial = (n) -&gt; result = <span class="hljs-number"><span class="hljs-number">1</span></span> result *= i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..n] result</code> </pre><br><p>  <s>In this article, this is not the last example of factorial calculation, more efficient methods will be discussed a little later.</s> </p><br><br><h6>  [...] </h6><br><p>  I will dare to step back a little from the topic and mention another interesting point related to the use of the <i>[...] (slice)</i> construction. </p><br><br><p>  Sometimes to someone else's code you can find something like this: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">'a,b,c'</span></span>[<span class="hljs-string"><span class="hljs-string">''</span></span>...][<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><p>  Which of course will mean the following: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">'a,b,c'</span></span>.slice(<span class="hljs-string"><span class="hljs-string">''</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//a</span></span></code> </pre><br><p>  At first glance, it is quite difficult to distinguish ranges from slices.  There are two main differences: </p><br><br><p>  First, in the slices, you can skip one extreme value </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>...]</code> </pre><br><p>  Here I would like to pay special attention to what we get after the translation of this expression: </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> __slice = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice; __slice.call(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  This can be convenient for many situations, for example, to get a list of function arguments: <br><br><pre> <code class="ruby hljs">fn = -&gt; [arguments...] fn [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#0,1,2,3</span></span></code> </pre><br><br>  I want to note that in <i>CoffeeScript</i> to get a list of function arguments there is a safer and more elegant option ( <a href="http://coffeescript.org/">splats</a> ): <br><br><pre> <code class="ruby hljs">fn = (args...) -&gt; args fn [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#0,1,2,3</span></span></code> </pre><br>  It is also acceptable to use arithmetic and logical operations: <br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>...]</code> </pre><br><br><p>  Secondly, an object is allowed before slices. </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>][...<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-comment"><span class="hljs-comment">#1,2</span></span></code> </pre><br><br><p>  Thirdly, it is acceptable to use transfers in slices. </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>...]</code> </pre><br>  This example performs a simple concatenation operation: <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>].concat(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice.call(<span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//[1,2,3]</span></span></code> </pre><br><p>  More useful example: </p><br><br><pre> <code class="ruby hljs">list1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] list2 = [<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] [list1, list2 ...] <span class="hljs-comment"><span class="hljs-comment">#[1,2,3,4,5,6]</span></span></code> </pre><br><br><h4>  List comprehension </h4><br><p>  The most striking syntax for working with objects in <i>CoffeeScript</i> is <a href="http://en.wikipedia.org/wiki/List_comprehension">List comprehension</a> . </p><br><br><p>  An example of how you can get a list of all factorial calculations from <i>1</i> to <i>n</i> : </p><br><br><pre> <code class="ruby hljs">factorial = (n) -&gt; result = <span class="hljs-number"><span class="hljs-number">1</span></span> result *= i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..n] factorial <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">#1,2,6,24,120</span></span></code> </pre><br><p>  Now let's look at a more interesting example and display a list of the first five members of the <i>location</i> object: </p><br><br><pre> <code class="ruby hljs">(i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i of location)[<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment"># hash, host, hostname, href, pathname</span></span></code> </pre><br><p>  In <i>JavaScript,</i> this code would look like this: </p><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> location) { result.push(i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }().slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br><p>  In order to display a list of elements (not indexes) of an array, you need to specify one more parameter: </p><br><br><pre> <code class="ruby hljs">foo = (value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, value of [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-comment"><span class="hljs-comment"># [ a, b ]</span></span></code> </pre><br><p>  On the one hand, list expressions are a very efficient and compact way to work with objects.  On the other hand, you need to clearly understand what code will be obtained after the broadcast in <i>JavaScript</i> . </p><br><br><p>  For example, the code above, which lists the elements from <i>0</i> to <i>2</i> , can be rewritten more effectively as follows: </p><br><br><pre> <code class="ruby hljs">foo = (value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">2</span></span>])</code> </pre><br>  Or so: <br><br><pre> <code class="ruby hljs">[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>].filter (value, i) -&gt; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  At this point, please pay special attention to the space in front between the method name and the opening bracket.  This space is required! <br><br>  If you skip the space, we get the following: <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>].filter(value, i)(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; }); <span class="hljs-comment"><span class="hljs-comment">//ReferenceError: value is not defined!</span></span></code> </pre><br><p>  Now, you <i>might</i> be wondering why the option with the <i>.filter ()</i> method was the most preferable? </p><br><p>  The fact is that when we use the <i>for-of</i> instruction, the translator substitutes a slower version of the loop than is required, namely <i>for-in</i> : </p><br><br><h6>  The result of the broadcast: </h6><br><br><pre> <code class="ruby hljs">var i, value; [ (function() { var _ref, _results; _ref = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>].slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); _results = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _ref) { value = _ref[i]; _results.push(value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _results; })() ];</code> </pre><br><p>  Let's face it, the final code is terrible. </p><br><p>  Now let's look at the code obtained using the <i>filter</i> method: </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>].filter(function(value, i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; });</code> </pre><br><p>  As you can see, we got the perfect and efficient code! </p><br><br><p>  If you use <i>CoffeeScript</i> on the server, then you have nothing to worry about, if not, then it is worth remembering that <i>IE9</i> does not support the <i>filter</i> method.  Therefore, you yourself should <a href="">take care</a> of its availability! </p><br><br><h4>  Then operator </h4><br><p>  As you know, to interpret <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar)">expressions</a> , the <i>CoffeeScript</i> parser analyzes indents, line breaks, carriage returns, etc. </p><br><br><p>  Below is a typical cycle for raising numbers from 1 to n to a power of two: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>] i * i</code> </pre><br><p>  For clarity, we used the line break and indent. </p><br><p>  However, in a real situation, most developers would prefer to write this expression in one line: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> i * i</code> </pre><br><p>  In the <i>while</i> , <i>if / else</i> , and <i>switch / when</i> statements, the <i>then</i> statement indicates to the analyzer that expression is split. </p><br><br><h4>  Operator by </h4><br><p>  Up to this point we have considered only ‚Äú <i>simple</i> ‚Äù cycles, now it‚Äôs time to talk about cycles with missing values ‚Äã‚Äãin a certain step. </p><br><br><p>  Let's output only even numbers from <i>2</i> to <i>10</i> : </p><br><br><pre> <code class="ruby hljs">alert i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] by <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#0,2,4,6,8,10</span></span></code> </pre><br><p>  In <i>JavaScript,</i> this code would look like this: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { alert(i); }</code> </pre><br><p>  The by statement is applied to the range of elements in which the iteration step can be set. </p><br><br><p>  We can also work not only with numbers or array elements, but also with strings: </p><br><br><pre> <code class="ruby hljs">[i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'Hello World'</span></span> by <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#H,l,W,l</span></span></code> </pre><br><p>  The <i>by</i> and <i>then</i> operators can be used together: </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'hello world'</span></span> by <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> i.toUpperCase()] <span class="hljs-comment"><span class="hljs-comment"># H,E,L,L,O, ,W,O,R,L,D</span></span></code> </pre><br><p>  Although this example is a bit far-fetched and in reality the ‚Äú <i>one-to-one</i> ‚Äù step should be done, nevertheless, the joint work of the <i>by-then</i> operators allows you to write very compact and efficient code. </p><br><br><h4>  Operator own </h4><br>  <i>JavaScript</i> often uses the <i>.hasOwnProperty ()</i> method, which, unlike the in operator, does not check properties in the object's prototype chain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; object.constructor.prototype.bar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object); <span class="hljs-comment"><span class="hljs-comment">// true console.log(object.hasOwnProperty('bar')); // false</span></span></code> </pre><br>  Consider an example of using the <i>.hasOwnProperty ()</i> method in the body of a <i>for-in</i> loop: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; object.constructor.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foo; }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (object.hasOwnProperty(i)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">//foo } }</span></span></code> </pre><br>  Although we added the <i>.toString ()</i> method to the object <i>object</i> prototype, it will not be listed in the body of the loop.  Although you can contact him directly: <br><br><pre> <code class="javascript hljs">object.toString() <span class="hljs-comment"><span class="hljs-comment">//1</span></span></code> </pre><br>  <i>CoffeeScript</i> has a special operator for these purposes: <br><br><pre> <code class="coffeescript hljs">object = foo: <span class="hljs-number"><span class="hljs-number">1</span></span> object.constructor::toString = <span class="hljs-function"><span class="hljs-function">-&gt;</span></span> @foo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log i <span class="hljs-comment"><span class="hljs-comment">#foo</span></span></code> </pre><br>  If you need to use the second key of the <i>for-of</i> instruction, then it is enough to specify it separated by commas, while adding the <i>own</i> statement again is not necessary: <br><br><pre> <code class="coffeescript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> own key, value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> object <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log <span class="hljs-string"><span class="hljs-string">'#{key}, #{value}'</span></span> <span class="hljs-comment"><span class="hljs-comment">#foo, 1</span></span></code> </pre><br><br><h4>  If / else conditional statements </h4><br><p>  Now I would like to draw attention to one very important point, which is associated with the sharing of cycles with if / else statements. </p><br><br><p>  Sometimes in <i>JavaScript</i> applications we can find similar code: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre><br><p>  We will not discuss, let alone condemn, developers who write like this. </p><br><p>  For us, it is of interest only how to correctly write an expression in <i>CoffeeScript</i> . </p><br><br><p>  The first thing that comes to mind is to do this: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment"># Parse error on line 1: Unexpected 'TERMINATOR'</span></span></code> </pre><br><p>  Fine ... but according to the rules of <a href="http://coffeescript.org/documentation/docs/lexer.html">lexical analysis of</a> <i>CoffeeScript</i> , an unexpected terminal value will be detected before the <i>if statement</i> , which will lead to a parsing error! </p><br><br><p>  From the previous material, we remember that we can write the expression in one line using the <i>then</i> operator: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment">#Parse error on line 1: Unexpected 'POST_IF'</span></span></code> </pre><br><p>  However, this did not help, we again see the error of parsing. </p><br><br><p>  Let's try to figure it out ... </p><br><p>  The point is that the <i>if statement</i> follows the same rules as other instructions for which the <i>then</i> operator is possible.  Namely, in order for our expression to be parsed correctly, we need to add the <i>then</i> operator after the expression with <i>if</i> again: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span></code> </pre><br><p>  So we get the following code: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br><p>  Sometimes there are situations when, before a cycle, you need to check the execution of a kl.  conditions: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (foo === <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><p>  Due to the use of <a href="http://en.wikipedia.org/wiki/Nondeterministic_Turing_machine">non</a> - <a href="http://en.wikipedia.org/wiki/Nondeterministic_Turing_machine">deterministic</a> data processing and list expressions, we can present our code as follows: </p><br><br><pre> <code class="ruby hljs">(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> foo is on</code> </pre><br><p>  Note that in this case we did not use the <i>then</i> operator, and no parsing errors occurred! </p><br><br><h4>  Conditional operator when </h4><br><p>  We have already considered the <i>by</i> and <i>then</i> operators, it is time to talk about the next statement in our list, namely the conditional <i>when</i> clause. </p><br><br><p>  And we begin with the correction of the previous example: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> foo is on <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span></code> </pre><br><p>  In this case, the code turned out to be a little more than the previous version, but it acquired a lot more expressiveness and meaning. </p><br><br><p>  Let's look at another example of how you can derive the order of numbers from <i>1</i> to <i>10</i> modulo a natural number n: </p><br><br><pre> <code class="ruby hljs">alert i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> i % <span class="hljs-number"><span class="hljs-number">2</span></span> is <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><p>  After the translation into <i>JavaScript</i> code: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>) { alert(i); } }</code> </pre><br><p>  As you can see the use of the when clause gives us even more opportunities to work with arrays. </p><br><br><h4>  For-of instruction </h4><br><p>  You have already seen examples of using <i>for-of</i> instructions when looking at list expressions.  Now let's take a closer look at the <i>for-of</i> instruction, which, along with <i>for-in,</i> allows you to iterate over the properties of an object. </p><br><br><p>  Let's immediately draw a comparative analogy with the <i>for-in</i> instruction in <i>JavaScript</i> : </p><br><br><pre> <code class="ruby hljs">var object = { <span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { alert(key + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + object[i]); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">0</span></span> : foo, <span class="hljs-number"><span class="hljs-number">1</span></span> : bar }</code> </pre><br><p>  As you can see, to get the value of the properties of an object, we used the following syntax: <i>object [i]</i> . </p><br><p>  In <i>CoffeeScript</i> , everything is simpler; first, we can get the value of an object using list expressions: </p><br><br><pre> <code class="ruby hljs">value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value of {<span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>}</code> </pre><br><p>  Secondly, for more complex expressions we can apply a more detailed notation using the operators already familiar to us: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value of {<span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key is <span class="hljs-string"><span class="hljs-string">'foo'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> value is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span></code> </pre><br><p>  In <i>JavaScript,</i> the same result can be obtained as follows: </p><br><br><pre> <code class="ruby hljs">var object = { <span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === <span class="hljs-string"><span class="hljs-string">'foo'</span></span> &amp;&amp; object[i] === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br><p>  Another example of effective use of <i>for-in</i> : </p><br><br><pre> <code class="ruby hljs">(<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value is <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> alert <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{key}</span></span></span><span class="hljs-string"> : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{value}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value of document <span class="hljs-comment"><span class="hljs-comment">#ELEMENT_NODE : 1, #DOCUMENT_POSITION_DISCONNECTED : 1</span></span></code> </pre><br><p>  Let me remind you that the most effective way to get the list of object properties is the <i>keys ()</i> method: </p><br><br><pre> <code class="ruby hljs">Object.keys obj {<span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-comment"><span class="hljs-comment"># foo, bar</span></span></code> </pre><br><p>  In order to get property values, the <i>keys ()</i> method must be used in conjunction with the <i>map ()</i> method: </p><br><br><pre> <code class="ruby hljs">object = <span class="hljs-symbol"><span class="hljs-symbol">foo:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">bar:</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Object.keys(object).map (key) -&gt; object[key]; <span class="hljs-comment"><span class="hljs-comment"># 1, 2</span></span></code> </pre><br><br><h4>  While instruction </h4><br><p>  In addition to the <i>for-of / in</i> instructions, <i>CoffeeScript</i> also implements a <i>while</i> instruction. </p><br><br><p>  When we looked at the <i>for-in</i> instruction, I promised to show an even more efficient way to calculate the factorial number <i>n</i> , the time is just right: </p><br><br><pre> <code class="ruby hljs">factorial = (n) -&gt; result = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> result *= n-- result</code> </pre><br><p>  To the bottom I want to add that the most elegant solution for calculating factorial is the following: </p><br><br><pre> <code class="ruby hljs">factorial = (n) -&gt; !n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> n * factorial n - <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br><h4>  Loop instruction </h4><br><p>  We will not dwell on this instruction for a long time, because its only purpose is to create an <a href="http://en.wikipedia.org/wiki/Infinite_loop">infinite loop</a> : </p><br><br><pre> <code class="ruby hljs">loop <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> foo is bar</code> </pre><br><br><p>  Relat broadcast: </p><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (foo === bar) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br><br><h4>  Until instruction </h4><br><p>  The <i>until</i> statement is similar to the <i>while</i> instruction, with one exception, that negation is added to the expression. </p><br><p>  This can be useful for example for finding the next character set position in a string: </p><br><br><pre> <code class="ruby hljs">expr = <span class="hljs-regexp"><span class="hljs-regexp">/foo/g</span></span>; alert <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{array[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string"> : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{expr.lastIndex}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> (array = expr.exec(<span class="hljs-string"><span class="hljs-string">'foofoo'</span></span>)) is null</code> </pre><br><p>  Relat broadcast: </p><br><br><pre> <code class="ruby hljs">var array, expr; expr = <span class="hljs-regexp"><span class="hljs-regexp">/foo*/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((array = expr.exec(<span class="hljs-string"><span class="hljs-string">'foofoo'</span></span>)) !== null) { alert(<span class="hljs-string"><span class="hljs-string">""</span></span> + array[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">" : "</span></span> + expr.lastIndex); } /<span class="hljs-regexp"><span class="hljs-regexp">/foo : 3, foo : 6</span></span></code> </pre><br><p>  As you can see from the example, the loop is executed until the result of the expression reaches zero. </p><br><br><h4>  Do-while instruction </h4><br><p>  I will say right away that in <i>CoffeeScript there is</i> no implementation of the <i>do-while</i> instruction.  However, with the help of simple manipulations, it is possible to emit its partial behavior using the <i>loop</i> statement: </p><br><br><pre> <code class="ruby hljs">loop <span class="hljs-comment"><span class="hljs-comment">#... break if foo()</span></span></code> </pre><br><br><h4>  Array methods (filter, forEach, map, etc.) </h4><br><p>  As it is known, all the same methods are available in <i>CoffeeScript</i> as in <i>JavaSctipt</i> . </p><br><p>  There is no sense in examining this whole group of methods; we will only consider the general principle of operation using the example of the <i>map ()</i> method. </p><br><br><p>  Create an array of three elements and square each of them: </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>].map (i) -&gt; i * i</code> </pre><br><p>  Relat broadcast: </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].map(function(i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i * i; });</code> </pre><br><p>  Consider another example: </p><br><br><pre> <code class="ruby hljs">[<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>].map (value, i) -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{value}</span></span></span><span class="hljs-string"> : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment">#foo : 0, bar : 1</span></span></code> </pre><br><p>  The second argument, the <i>map</i> method, accepts the calling context: </p><br><br><pre> <code class="ruby hljs">var object = new function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>].map(function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this }); }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [Window map]</code> </pre><br><p>  As you can see <i>this</i> inside the map points to <i>Window</i> , to change the context of the call, you need to do this explicitly: </p><br><br><pre> <code class="ruby hljs">var object = new function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>].map(function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }, this); }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [Object {}]</code> </pre><br><p>  In <i>CoffeeScript, the</i> special operator <i>=&gt; is</i> intended for this purpose: </p><br><br><pre> <code class="ruby hljs">object = new -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>].map (i) =&gt; @</code> </pre><br><p>  Relat broadcast: </p><br><br><pre> <code class="ruby hljs">var object = new function() { var _this = this; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>].map(function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this; }, this); };</code> </pre><br><p>  In other words, use these array methods as far as possible. </p><br><br><p>  I posted a <a href="">cross-</a> browser implementation of these methods on <a href="">github'e</a> </p><br><p>  A real example of using the <i>map</i> and <i>filter</i> methods in <i>CoffeeScript</i> , can also be viewed in one of my projects on <a href="https://github.com/monolithed/toCSS/blob/master/CoffeeScript%2520version/toCSS.coffee">github'e</a> </p><br><br><h4>  Do statement / closures </h4><br><p>  As you know, in <i>JavaScript</i> , <a href="http://en.wikipedia.org/wiki/Closure_%2528computer_science%2529">closures</a> are actively used, and <i>CoffeeScript</i> also does not deprive us of this pleasure. </p><br><br><p>  <i>CoffeeScript</i> uses the <i>do</i> statement, which takes an arbitrary number of arguments to create an anonymous self-bound function. </p><br><br><p>  Consider an example: </p><br><br><pre> <code class="ruby hljs">array = []; i = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i-- <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> array[i] = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (i) -&gt; -&gt; i array[<span class="hljs-number"><span class="hljs-number">0</span></span>]() <span class="hljs-comment"><span class="hljs-comment">#0 array[1]() #1</span></span></code> </pre><br><p>  The essence of this code comes down to filling the array.  At the same time, array elements contain not elementary values, but functions, each of which returns the index of its element. </p><br><br><p>  <i>JavaScript</i> code would look like this: </p><br><br><pre> <code class="ruby hljs">var array = [], i = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i--) { array[i] = function(i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }; }(i); } array[<span class="hljs-number"><span class="hljs-number">0</span></span>]() /<span class="hljs-regexp"><span class="hljs-regexp">/0 array[1]() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/1</span></span></code> </pre><br><br><h4>  Enclosed instructions </h4><br>  Nested instructions are not much different from other instructions and follow the same rules: <br><br>  For example, fill in the array with paired elements from 1 to 3: <br><br><pre> <code class="ruby hljs">list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] list.push i list <span class="hljs-comment"><span class="hljs-comment"># [0,0,1,1,2,2]</span></span></code> </pre><br>  As you can see there is nothing difficult! <br><br>  Perhaps you will want to write it in one line.  Well, let's try to simplify the recording now: <br><br><pre> <code class="ruby hljs">list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> list.push i</code> </pre><br>  PS: I personally, would not use such a record, however, you should know that it is also possible to write this way, because sooner or later you will have to work with someone else's code. <br><br>  What if you need to add an expression before the second cycle? <br><br>  As an example, we derive three pairs of elements from 0-3: <br><br><pre> <code class="ruby hljs">list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] list.push i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] list.push i list <span class="hljs-comment"><span class="hljs-comment">#[0,0,1,1,2,2]</span></span></code> </pre><br><br>  This is the right option and there is nothing to improve.  It‚Äôs also impossible to write everything into one line, because an explicit identification is required before the second cycle.  But the body of the cycle can be written in short notation. <br><br><pre> <code class="ruby hljs">list = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>] list.push i list.push i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">1</span></span>] list <span class="hljs-comment"><span class="hljs-comment">#[0,1,2,3]</span></span></code> </pre><br><br>  In the third line you can use both the prefix and postfix forms of the record. <br><br><h4>  jQuery, etc. </h4><br><p>  I will say right away, for <i>CoffeeScript, it</i> does not matter which <i>JavaScript</i> library you use. </p><br><br>  Let's start with the most important <i>jQuery</i> function -. <i>Ready ()</i> <br><br><h6>  .ready (): </h6><br><pre> <code class="ruby hljs">$ -&gt; @</code> </pre><br><p>  The result of the broadcast: </p><br><pre> <code class="ruby hljs">$(function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; });</code> </pre><br><p>  <s>I don‚Äôt know about you, but this record almost always causes me to laugh</s> </p><br><br>  The next <i>jQuery</i> method in our list is <i>.each ()</i> , which is almost equivalent to the standard <i>.forEach ()</i> method <br><br><h6>  $ .each: </h6><br><pre> <code class="ruby hljs">$.each [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>], (i) -&gt; i</code> </pre><br><p>  The result of the broadcast: </p><br><br><pre> <code class="ruby hljs">$.each([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], function(i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; });</code> </pre><br><br><h4>  ECMASctipt 6 </h4><br>  <s>If you are not interested in the future development of the ECMASctipt 6 standard, feel free to skip this section.</s> <br><br>  As you know, in the future standard <i>ECMASctipt 6 it</i> is planned to implement generators, iterators and list expressions. <br>  Firefox now supports most of the draft standard. <br><br>  Why am I doing this? <br><br>  The fact is that the future syntax of ES6 is practically more than completely incompatible with today's CoffeeScript. <br><br>  For example, the instruction <i>for ... of</i> , now is more general than it is needed: <br><br><pre> <code class="ruby hljs">[value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key, value of [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]]</code> </pre><br>  At the output we get the following <s>perversion</s> : <br><br><pre> <code class="hljs matlab">var key, value; [ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ref</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_results</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ref</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[1, 2, 3]</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_results</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key in _ref)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_ref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key]</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_results</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_results</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ]; //</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[1, 2, 3]</span></span></span></span></code> </pre><br>  The future standard makes it possible to use iteration through objects, where it is easier: <br><br><pre> <code class="hljs json">[for i of [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]]</code> </pre><br>  Wow, isn't it? <br><br>  Expression generators will also be available: <br><br><pre> <code class="hljs actionscript">[i * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])]; <span class="hljs-comment"><span class="hljs-comment">//2,4,6</span></span></code> </pre><br>  The following entry will be possible: <br><br><pre> <code class="hljs matlab">[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> in [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> <span class="hljs-comment"><span class="hljs-comment">% 2 == 0)]; //2</span></span></code> </pre><br>  Iterators will also be available: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>= { a: <span class="hljs-number"><span class="hljs-number">1</span></span>, b: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = <span class="hljs-type"><span class="hljs-type">Iterator</span></span>(lang); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair = it.next(); <span class="hljs-comment"><span class="hljs-comment">//[a, 1] pair = it.next(); //[b, 2]</span></span></code> </pre><br>  Iterators can also be used in conjunction with expression generators: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = <span class="hljs-type"><span class="hljs-type">Iterator</span></span>([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]); [i * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> it)]; <span class="hljs-comment"><span class="hljs-comment">//1, 4, 6</span></span></code> </pre><br><br>  With the release of the new standard, many <i>CoffeScript</i> chips will cease to be so, and kernel developers obviously have a lot of work to do to keep their ‚Äúsugar‚Äù positions.  We wish them good luck. </div><p>Source: <a href="https://habr.com/ru/post/140764/">https://habr.com/ru/post/140764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140758/index.html">Drupal and multilingual, how to programmatically add a language switch</a></li>
<li><a href="../140759/index.html">Sony is going to release a laptop with Chrome OS</a></li>
<li><a href="../140760/index.html">CSS3 gradient for block borders</a></li>
<li><a href="../140761/index.html">STM32: Clock Security System</a></li>
<li><a href="../140762/index.html">PHP does not like destructors</a></li>
<li><a href="../140765/index.html">Angry Birds: Space - in 3 days 10 million horse races</a></li>
<li><a href="../140767/index.html">Amazon Route53 DNS delivers the client directly to your server.</a></li>
<li><a href="../140768/index.html">So, you need a font ...</a></li>
<li><a href="../140770/index.html">Proper promotion or how to invite a porn star to prom</a></li>
<li><a href="../140771/index.html">Fixing the order of the keyboard layout (Win XP)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>