<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The use of machine learning in building AI for the game of Japanese chess (shogi)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 

 For quite some time now, my friend Gorkoff and I have been fond of playing shogi . And we are so keen that we decided to write our own bo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The use of machine learning in building AI for the game of Japanese chess (shogi)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/39c/5c9/3e739c5c925413f8f6eeb7f5c7971a24.jpg"><br><br>  Good day. <br><br>  For quite some time now, my friend <a href="http://habrahabr.ru/users/gorkoff/" class="user_link">Gorkoff</a> and I have been <a href="http://habrahabr.ru/users/gorkoff/" class="user_link">fond of</a> playing <a href="http://habrahabr.ru/post/168867/">shogi</a> .  And we are so keen that we decided to write our own bot for this wonderful game.  This article is a further description of the development process of the bot, which, with some interruptions, we have been doing for several months. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h5>  About alpha-beta clipping or why it is important to sort the moves </h5><br>  To decide which move to take in <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D1%2582%25D0%25B0%25D0%25B3%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0">antagonistic</a> games such as chess (as well as traditional and Japanese), checkers and tic-tac-toe, a minimax-optimization strategy called alpha-beta cut-off is used. <br>  This algorithm was repeatedly considered on Habr√©, as in the <a href="http://habrahabr.ru/post/168867/">article of</a> my friend, and in other <a href="http://habrahabr.ru/post/168867/">articles</a> . <br>  Briefly recall its essence with the following picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5eb/dbd/297/5ebdbd29724003b45d3045daaa5a3790.png"><br><br>  The numbers in the squares indicate the assessment of the position after making the appropriate sequence of moves. <br><br>  In this example, a node is <i>cut off</i> , the value of which is marked with question marks. <br>  You can verify the validity of this cut-off by making an expression that calculates the value at node b: <br><br>  <i><b>b = min (c, d) = min (max (4,6), max (7, X))</b></i> <br><br>  Obviously, the value of this expression does not depend on <b><i>X</i></b> , since the expression <i><b>max (7, X) is</b></i> obviously greater than or equal to 7, therefore, it is greater than <b><i>max (4,6)</i></b> and the value of <b>b</b> will be equal to <b><i>b = 6</i></b> . <br><br>  Thus, the alpha-beta cut-off algorithm makes it possible not to consider branches that are obviously worse than the one that has already been obtained. <br>  Consequently, the consideration of more promising moves in the first gives the acceleration of the algorithm.  Determining which course is more promising is the goal of this article. <br><br><h5>  Hypothesis </h5><br>  In a game, it is often obvious to a person that it is simply not necessary to consider some moves.  For example, to move a pawn standing on the edge of the board at the moment when the opponent put the rook under attack. <br>  For the computer, the concept of "obvious" does not exist, he will check all possible moves in turn and only after that he will conclude that eating the boat is the right decision. <br>  If in any way to streamline the examination of moves so that the take move of the rook turns out to be first in consideration, the alpha-beta cut-off algorithm will end quickly, discarding all the branches whose evaluation is obviously worse than taking the rook. <br><br>  In this example, a special case of the heuristic choice of the order of consideration of moves is considered, and it can hardly be used separately in the program.  Manual description of a set of special cases is very laborious, moreover, there is always a chance that in any subset of the options, leaving the rook under attack, the pawn move is the only correct one. <br><br>  Here an idea about the possibility of automatically obtaining information about promising moves from already played games appears.  The use of machine learning methods is justified in this case by the hypothesis that moves with similar parameters (about them below) give a similar result. <br><br><h5>  Learning set </h5><br>  The first question that needs to be solved when using machine learning is to obtain a training set, which will determine the quality of the moves. <br>  Oddly enough, this turned out to be the smallest problem, despite the inferior popularity of shogi compared to regular chess. <br><br>  There is a <a href="http://playok.com/">playok.com</a> site on the <a href="http://playok.com/">Net</a> , which provides an opportunity to play various board games with other players for free.  Among the games provided are shogi.  Moreover, all the games played on this site are saved in the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B8%25D1%2584%25D1%2583_(%25D1%2581%25D1%2591%25D0%25B3%25D0%25B8)">kifu</a> format and are in the public domain, which makes it possible to write a simple script that downloads the required number of games. <br><br>  The number of games stored on this site is very large (millions), so it was decided to create a database for local storage of the parameters of the games and moves. <br>  It is worth saying that the task of storing such data is not very trivial, since the process of working with the base requires a large number of operations to obtain moves by the batch number. <br>  Those.  in the case of SQL, a sample of several dozen rows from a table containing millions of rows. <br>  I considered the possibility of using NoSQL databases, such as MongoDB.  In the case of NoSQL, such an operation would boil down to a simple pointer transition.  Despite this advantage of NoSQL, PostgreSQL is used in the current implementation, and the move table has an index by lot number. <br><br>  The scripts that implement the loading of batches from the playok.com website and their entry into the database, as well as the scripts that perform data preparation (ie, those functions whose execution time is not critical), are written in Ruby, because  This language provides high speed of writing code, and also has all the necessary components for working with the database.  Links to source codes are provided at the end of the article. <br><br><h5>  About the description of the moves </h5><br>  In order for the application of machine learning methods to be possible, it is necessary to describe each move using a set of features.  Such a description, oddly enough, is called an attribute description of the object. <br><br>  An attribute description is a vector of values, which, in turn, is the coordinates of a point in the attribute space. <br>  For example, an indicative description of a box may be its dimensions and weight.  Thus, a box measuring 2 by 3 by 1 meter and weighing 10 kilograms will have a characteristic description <i><b>(2,3,1,10)</b></i> in the four-dimensional feature space. <br><br>  Due to the fact that the move with the same designation (e2e4) in different batches can lead to opposite results, it is necessary to include signs containing information about the position of other pieces on the board in the indicative description of the move. <br>  For signs, it is also necessary to observe the invariance with respect to the color of the figure that made the move, since in the training sample both black and white moves can be good.  For example, the horizontal number of a move is better to be replaced by the number of horizontal lines to the initial position (in this case, it is considered that black starts from horizontal 9, and white starts from horizontal 1). <br><br>  The version of the feature description used consists of the following parameters: <br><br><div class="spoiler">  <b class="spoiler_title">Long list</b> <div class="spoiler_text"><ul><li>  The weight of the move </li><li>  Weight of eaten figure (0, if not) </li><li>  The amount of horizontal from the initial position to the position from which the move is made </li><li>  Vertical number from which the move is made </li><li>  The amount of horizontal from the initial position to the position to which the move is made </li><li>  Vertical number to move to </li><li>  Whether the figure was flipped (1/0) </li><li>  The total weight of the attacked figures </li><li>  The weight of the strongest attacked figure </li><li>  The arithmetic average of the weights of the attacked figures </li><li>  The weight of the weakest attacked figure </li><li>  The total weight of the enemy pieces attacking the position from which the move is made </li><li>  The weight of the strongest of the enemy pieces attacking the position from which the move is made </li><li>  The average weight of enemy pieces attacking the position from which the move is made </li><li>  The weight of the weakest of the enemy pieces attacking the position from which the move is made </li><li>  The total weight of the enemy pieces attacking the new position </li><li>  The weight of the strongest of the enemy pieces attacking the new position </li><li>  The average weight of enemy pieces attacking a new position </li><li>  The weight of the weakest enemy figure attacking the new position </li><li>  Number of pieces attacking a new piece </li><li>  The total weight of their figures, protecting the original position </li><li>  The weight of the strongest of his figures, protecting the original position </li><li>  The average weight of their figures, protecting the original position </li><li>  The weight of the weakest of his figures, protecting the original position </li><li>  The total weight of their figures, protecting the new position </li><li>  The weight of the strongest of their figures defending a new position </li><li>  The average weight of their figures, protecting the original new </li><li>  The weight of the weakest of their figures defending the new position </li><li>  The number of their figures defending the new position </li><li>  The distance to the opponent's king horizontally in a new position </li><li>  The distance to the king of the enemy vertically </li><li>  Horizontal distance to his king </li><li>  Vertical distance to his king </li><li>  Move number in the game </li></ul><br></div></div><br><br><h5>  About the choice of classification algorithm </h5><br><br>  Problem statement implies the classification of moves for promising and unpromising (good and bad), however, some additional conditions are also imposed on the algorithm: <br><br><ul><li>  It must be possible to rank moves from best to worst. </li><li>  High speed must be ensured, since the classification (and sorting) must be done at each stage of the tree viewing. </li></ul><br><br>  Among the classification algorithms for our task, the <a href="http://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">nearest neighbor</a> method is well suited. <br>  The method consists in determining which object of which class in the feature space is located closest to the classified object. <br>  This method is good because it naturally determines which of the two considered moves is better.  To do this, it is enough to compare the distances to their nearest neighbors. <br>  However, the method has a significant drawback: you need to check a large number of objects before you can claim that the closest one is found. <br><br>  One way to solve this problem is to use clustering. <br>  Replacing the set of source points with the set of points that are cluster centers, we will significantly reduce the number of operations required to classify an object.  Such a replacement will obviously degrade the quality of the classification, and the smaller the clusters in the output set, the worse the quality will be.  Thus, the number of clusters is a value reflecting a compromise between accuracy and speed. <br><br><h5>  About the choice of moves </h5><br>  Before proceeding to the processing of batches it is necessary to decide which moves are considered good and which are bad in our database.  Several options immediately come to mind: <br><br><ul><li>  The moves that led to the material advantage. </li><li>  The moves that led to the mat. </li><li>  The moves made by top rated players. </li></ul><br>  If you think a little more, it becomes clear that the first and second options are not guaranteed to be good. <br>  Since, firstly, there are situations in which a player, in which the sacrifice of a strong figure subsequently results in the loss of the player who accepted the sacrifice. <br>  Secondly, the mate can be placed because of the negligence of the loser player, which happens quite often. <br>  If a player with a high rating wins the game, then we can say that he did not make unequivocally stupid moves (at a sufficient level, yawning is guaranteed to fail), and our task, I remind you, is not to establish absolutely accurate moves in specific situations, And a sort of moves by quality on average. <br>  Based on the above arguments, we find that in order to solve our problem, we will have to trust the authorities. <br><br>  In the current implementation, the moves are selected as follows: <br><br><ul><li>  Sets the lower and upper thresholds of ratings. </li><li>  In each game, the winner's rating in which is higher than the upper threshold, the last 2/3 of the winner's moves are selected and marked as good. </li><li>  In each game, the losing rating in which is less than the lower threshold, the last 2/3 of the loser‚Äôs moves are selected and are marked as bad. </li></ul><br>  Weeding out the first moves is justified by the fact that there are other, more efficient algorithms for the debut of the game, which are beyond the scope of the article. <br><br><h5>  About clustering </h5><br>  In contrast to the classification that must be performed at each step of viewing the game tree, clustering, in our case, has less stringent requirements. <br>  First of all, clustering should be performed only 1 time, which gives the right to use algorithms that require more time than what we have at the time of the game. <br><br>  By itself, the clustering problem is not clearly formulated, which gives many options for its interpretation.  We will use the following definition: <br><br>  Clustering consists of dividing a set of objects into non-intersecting sets (clusters) in such a way as to minimize the distance between objects within the cluster and maximize the distance between clusters. <br><br>  Formally, this definition can be written as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/27c/352/760/27c3527600d1857d6b80ea1886ee8f42.png"><br><br>  Where <b><i>K <sub>y</sub></i></b> - cluster number <b><i>y</i></b> <br>  <b><i>p (x, y)</i></b> is a function that determines the distance in a given metric <br>  <i><b>Œº <sub>y</sub></b></i> - the center of the cluster with the number <b><i>y</i></b> <br>  <i><b>x <sub>i</sub></b></i> - object number <b><i>i</i></b> <br><br>  In my implementation, I used the k-means clustering algorithm, its detailed description can be found, for example, in <a href="http://en.wikipedia.org/wiki/K-means_clustering">Wikipedia</a> . <br>  The peculiarity of the algorithm is that it uses random values ‚Äã‚Äãas the initial partition into clusters, the choice of which strongly influences the result of further splitting, which makes it possible to repeatedly perform clustering to achieve better results, and we are not limited in execution time at this stage. <br><br>  For example, clustering random points in a two-dimensional space looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebb/da0/fb0/ebbda0fb0edd8d3bd5e33b42648c552d.png"><br><br><div class="spoiler">  <b class="spoiler_title">Implementation in ruby</b> <div class="spoiler_text"><pre><code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">midle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cluster)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># "" res = [0]*cluster[0].size(); cluster.each do |e| i = 0; e.each do |x| res[i] += x; i+=1; end end res.map! {|x| x/cluster.size.to_f} return res; end def dist(x1,x2) if(x1.size != x2.size) raise "WrongSizeException"; end mode = 1 if mode ==1 then #     dist = 0; for i in 0..x1.size-1 dist += (x1[i]-x2[i])**2 end return dist; end if mode == 2 then #   dist = 0; x1_s = 0; x2_s = 0; for i in 0..x1.size-1 dist += x1[i]*x2[i] x1_s += x1[i]**2; x2_s += x2[i]**2; end dist =1 - dist / Math.sqrt(x1_s) / Math.sqrt(x2_s) end end def quality1 (clusters) #    ( ,    - ) sum = 0; clusters.each do |cluster| center = midle(cluster) local_sum = 0 cluster.each do |vector| local_sum += dist(vector, center); end sum += local_sum / cluster.size.to_f; end return sum; end def quality2 (clusters) #    centers = []; clusters.each do |cl| centers += [midle(cl)]; end sum = 0 centers.each do |c1| centers.each do |c2| sum += dist(c1,c2) end end return sum; end def quality (clusters) #    return quality1(clusters)/quality2(clusters); end def find_nearest(vectors, point) min = Float::INFINITY imin = 0 i = 0 vectors.each do |vector| d = dist(vector, point) if(d &lt; min) then min = d; imin = i; end i += 1; end return imin end def k_means(vectors, k) len = vectors.size; clusters = []; centers_index = []; if len &lt; k then raise "count of clusters more than objects"; end while centers_index.size != k do #    k   centers_index = (1..k).map { Random.rand(len)}; #  k   centers_index.uniq! end centers = centers_index.map{ |e| vectors[e] } clusters_new = [] begin #       clusters = clusters_new; clusters_new = k.times.map {[]}; vectors.each do |vector| clusters_new[find_nearest(centers, vector)] += [vector]; end #    centers = []; clusters_new.each do |cluster| return nil if cluster == nil; #  ,  -    return nil if cluster.size == 0; centers += [midle(cluster)] end end until clusters_new == clusters return clusters_new end</span></span></code> </pre> <br></div></div><br><br>  As a result of clustering, we obtain <b><i>N</i></b> (I chose <b><i>N = 20</i></b> ) points, which are the centers of clusters of good and bad moves in the feature space. <br>  The distance to these points will be used when sorting the order of viewing moves. <br><br><h5>  About classification </h5><br><br>  Now that we have a significantly smaller number of points compared to the original base, we can apply sorting based on proximity to these points. <br><br>  As in the previous stages, we face a choice.  Namely, the choice of the metric in which the distance to the clusters will be calculated. <br>  It is possible to use both the usual Euclidean metric and the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259C%25D0%25B0%25D1%2585%25D0%25B0%25D0%25BB%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B1%25D0%25B8%25D1%2581%25D0%25B0">Mahalanobis</a> metric, which takes into account the correlation between the coordinates of points. <br><br><div class="spoiler">  <b class="spoiler_title">Pictures for clarity:</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/e28/f41/bf5e28f41e267ff3e34dc34fedbb9b21.png"><br>  <i>Euclidean metric in two-dimensional space.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/9ad/880/9479ad8801a0c91c12c87585c361a4e7.png"><br>  <i>Mahalanobis metric in two-dimensional space.</i>  <i>Ellipses show the variance of the values.</i> <br></div></div><br><br>  Which metric is better and by what parameters is a separate and very difficult question, so for the beginning we will stop on a simple variant - the Euclidean metric. <br><br>  The value by which the moves will be sorted will choose the following: <b><i>((Distance to the nearest cluster of bad moves) - (Distance to the nearest cluster of good moves))</i></b> . <br>  Thus, the larger the specified value of the turn, the earlier it should be considered when building the game tree. <br>  Here it is also possible to use other expressions to obtain an estimate of the course, for example, the average distance to clusters of good moves, etc. <br><br><div class="spoiler">  <b class="spoiler_title">A piece of java implementation</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">euclidian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;Double&gt; p1, ArrayList&lt;Double&gt; p2)</span></span></span><span class="hljs-function"> </span></span>{ Double sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p1.size(); i++) { sum += (p1.get(i) - p2.get(i)) * (p1.get(i) - p2.get(i)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMinDist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;Double&gt; point, ArrayList&lt;ArrayList&lt;Double&gt;&gt; clusters)</span></span></span><span class="hljs-function"> </span></span>{ Double min = Double.MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ArrayList&lt;Double&gt; cluster : clusters) { min = Math.min(min, euclidian(cluster, point)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortMoves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CMovesList movesList)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// (   ) - (  ) for (CMove move : movesList.Moves) { ArrayList&lt;Double&gt; move_params = CDataMining.getFeature(localBoard, move).toArray(); //   //  Double good_dist = CAdviser.getMinDist(move_params, clusters_good); //    Double bad_dist = CAdviser.getMinDist(move_params, clusters_bad); move.H = bad_dist - good_dist; } movesList.sortH(); } /** * -  * * @param color    * @param D  * @param A * @param B * @return */ public int AB(boolean color, int D, int A, int B) { ABtimes++; if ((D == 0) || Math.abs(localBoard.Evaluate(color)) &gt;= 15000) return localBoard.Evaluate(color); CMovesList ML; ML = localBoard.getAllMoves(color); if (D == MaxD) { //    sortMoves(ML); // &lt; -----       . } else { ML.sortH(); } while ((ML.getMovesCount() &gt; 0) &amp;&amp; (A &lt; B)) { CMove Move = ML.getMoveByIndex(0); CFigure previousFigure = localBoard.makeMove(Move); int tmp = -AB(!color, D - 1, -B, -A); localBoard.unmakeMove(Move, previousFigure); if (tmp &gt; A) { A = tmp; if (D == MaxD) BestMove.cp(Move); } ML.removeByIndex(0); } return A; }</span></span></code> </pre><br></div></div><br><br><h5>  Result </h5><br>  The main criterion in assessing the effectiveness of the described method was the number of recursive calls to the Alpha-Beta cut-off procedure, since this criterion does not depend on the implementation and, therefore, is the most objective. <br>  Experiments have shown that the effectiveness of the method strongly depends on the situation on the board.  This is not surprising, since the training of the classifier took place on real batches, therefore, its efficiency for solving artificially designed tasks can be significantly lower than that of simple heuristics, sorting out moves by the weight of attacked figures. <br><br><div class="spoiler">  <b class="spoiler_title">Work examples (for clarity, the result is shown using the BCDGames program):</b> <div class="spoiler_text">  Maximum rendering depth: 4 half shots. <br><br>  Random position taken from a real batch. <br><img src="https://habrastorage.org/getpro/habr/post_images/758/a66/dcd/758a66dcd34eae617f2c3d3d763661c1.jpg"><br><br>  Simple heuristics: <br>  The number of recursive calls - 22027 <br><img src="https://habrastorage.org/getpro/habr/post_images/b0a/cf5/f98/b0acf5f98fcf69c6bb3e072c2f722b7a.jpg"><br><br>  Heuristics using Machine Learning for the first, for subsequent moves - simple heuristics: <br>  The number of recursive calls - 18719 <br><img src="https://habrastorage.org/getpro/habr/post_images/39f/2f9/220/39f2f9220f3e2875c718fe79cf3c81cb.jpg"><br><br>  The made moves are different, since in the constructed tree the games at the maximum depth have the same score. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/737/7dc/149/7377dc149789fe9ab58acc3997b62e48.jpg"><br><br>  Simple heuristics: <br>  The number of recursive calls - 32561 <br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/50e/139/7b050e139aff7ea42e150c6a9cad8f99.jpg"><br><br>  Heuristics using Machine Learning for the first, for subsequent moves - simple heuristics: <br>  The number of recursive calls - 28524 <br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/50e/139/7b050e139aff7ea42e150c6a9cad8f99.jpg"><br><br>  Artificial situation with a small number of pieces on the board and a few pieces in hand. <br>  (Viewing rude - 3 semi-moves) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e0/2d1/fa0/5e02d1fa00aff9f21611216104ecd4bd.jpg"><br><br>  Simple heuristics: <br>  The number of recursive calls - 379376 <br><img src="https://habrastorage.org/getpro/habr/post_images/b44/3ff/4f1/b443ff4f1ddfaf326570f5ed6f5d4840.jpg"><br><br>  Heuristics using Machine Learning for the first, for subsequent moves - simple heuristics: <br>  The number of recursive calls - 541866 <br><img src="https://habrastorage.org/getpro/habr/post_images/aa7/04f/9bc/aa704f9bcf79eabae366b5d7439f5632.jpg"><br><br>  As can be seen, in the case of an artificially formed situation on the board, heuristics based on machine learning, as expected, gives a worse efficiency compared to simple heuristics. <br></div></div><br><br><h5>  Disadvantages of the method </h5><br><ul><li>  <b>Long.</b> </li></ul><br><br>  In the process of calculating the nearest points, operations with real numbers are used, which significantly increases the viewing time of the game tree. <br><br><ul><li>  Limited use </li></ul><br><br>  As noted above, for some situations, the machine learning method can give a worse result than simple heuristics. <br><br><h5>  Possible ways to improve </h5><br>  Get rid of the real operations can, for example, using the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25BA%25D0%25B2%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B2">Manhattan</a> distance. <br>  The number of real operations can also be reduced by reducing the number of clusters.  Such a reduction will lead to a loss of accuracy and, consequently, to a deterioration of the work of the Alpha-Beta cut-off algorithm, which will increase the running time.  Therefore, ideally, it is necessary to solve the optimization problem for this parameter. <br><br>  To solve the applicability problem of machine learning heuristics, the following improvements are possible: <br><ul><li>  Consideration of moves in the context of the situation on the board, which includes the construction of a graph of interaction of the figures and the addition of information from this graph to the parameters of the course. </li><li>  Creating different clusters for different types of positions on the board (Depending on the number of pieces, in the case of an attacking strategy, in the case of a defensive strategy, etc.) and applying a particular set of clusters depending on the game situation. </li></ul><br><br><h5>  References and literature </h5><br><ul><li>  In machine learning there is a remarkable <a href="http://www.machinelearning.ru/wiki/index.php%3Ftitle%3D%25D0%259C%25D0%25B0%25D1%2588%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BA%25D1%2583%25D1%2580%25D1%2581_%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B9%252C_%25D0%259A.%25D0%2592.%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D1%2586%25D0%25BE%25D0%25B2)">course of lectures by</a> K. V. Vorontsov, from which I took information about the methods used.  His lectures were recently <a href="http://habrahabr.ru/company/yandex/blog/208034/">posted</a> on Habr. </li><li>  The repository with the bot itself, written in java: <a href="https://github.com/gorkoff/Shogi/tree/DataMining">https://github.com/gorkoff/Shogi/tree/DataMining</a> </li><li>  Repository with Ruby helper scripts: <a href="https://github.com/generall/ScriptsForShogi">https://github.com/generall/ScriptsForShogi</a> </li></ul><br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/208580/">https://habr.com/ru/post/208580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208566/index.html">Installing ownCloud 6 on Debian 7 wheezy</a></li>
<li><a href="../208568/index.html">Configuring 6in4 on Zyxel Keenetic routers</a></li>
<li><a href="../208570/index.html">45 Tips Tricks and Javascript Practitioner</a></li>
<li><a href="../208576/index.html">ZTE modular smartphone presented live at CES</a></li>
<li><a href="../208578/index.html">Play Pure Drive - smart tennis racket for everyone</a></li>
<li><a href="../208582/index.html">Text interface, part 2. User interaction</a></li>
<li><a href="../208586/index.html">Asterisk / FreePBX: Integration of number identifier with customer base</a></li>
<li><a href="../208588/index.html">JetBrains discounts for startups</a></li>
<li><a href="../208590/index.html">‚ÄúFriends‚Äù redis with nginx</a></li>
<li><a href="../208600/index.html">Backbone.Component - standalone UI components for Backbone.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>