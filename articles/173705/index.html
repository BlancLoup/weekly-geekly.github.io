<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing your bootloader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was written for people who are always interested to know how different things work. For those developers who usually write their programs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing your bootloader</h1><div class="post__text post__text-html js-mediator-article">  This article was written for people who are always interested to know how different things work.  For those developers who usually write their programs at a high level, C, C ++ or Java is not important, but they are faced with the need to do something at a low level.  We will consider low-level programming using the example of the bootloader. <br><br>  We describe what happens after the computer is turned on and how the system boots.  As a practical example, consider how you can write your own bootloader, which is actually the starting point for booting the system. <br><br><br><a name="habracut"></a><br><h4>  What is Boot Loader </h4><br>  Boot loader is a program that is recorded on the first sector of a hard disk.  The BIOS automatically reads the entire contents of the first sector into memory, immediately after power on.  The first sector is also called the master boot record.  In fact, it is not necessary for the first sector of the hard disk to boot something.  This name was historically established, as the developers used such a mechanism to load the operating system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Be prepared to dive deeper. </h4><br>  In this section, I will talk about what knowledge and tools are needed to develop your own bootloader, and also remind you of some useful information about booting the system. <br><br><h5>  And so, what language do you need to know to write a boot loader </h5><br>  In the first stage, when a computer is running, the hardware is monitored primarily through BIOS functions, known as ‚Äúinterrupts‚Äù.  You can call an interrupt only in assembly language - it would be great if you are at least a little familiar with this language.  But this is not a prerequisite.  Why?  We will use the "mixed code" technology, where you can combine high-level constructions with low-level commands.  This does not simplify our task much. <br><br>  This article will mainly use the C ++ language.  But if you know C, it will be easy for you to recognize the necessary C ++ elements.  In general, even knowledge of the C language will be enough, but then you will have to change the source code of the examples. <br><br>  If you know Java or C #, then unfortunately this does not help for our task.  The point is that Java and C # code that is produced after compilation is intermediate.  A special virtual machine is used for further processing (Java machine for Java and .NET for C #), converting the intermediate code into instructions for the processor.  After conversion, it can be executed.  This architecture makes it impossible to use mixed code technology - but we will use it to make our lives easier, so Java and C # will not help here. <br><br>  And so, to develop a simple bootloader, you must know C or C ++, and it would not be bad if you know a little Assembly language. <br><br><h4>  Which compiler do you need </h4><br>  To use mixed code technology, you need at least two compilers: for the assembler and for C / C ++, and a linker that will merge the object files (.obj) into one executable file. <br><br>  Now, let's talk about some special moments.  There are two modes of operation of the processor: real and protected mode.  Real mode is 16-bit and has some limitations.  Protected mode is 32-bit and is fully utilized by the operating system.  When the computer is just starting, the processor runs in 16-bit mode.  Thus, in order to write a program and get an executable file, you need a compiler and linker for the assembler for 16-bit mode.  For C / C ++, you only need a compiler that can create object files for 16-bit mode. <br><br>  Modern compilers are made for 32-bit applications, so we cannot use them. <br><br>  I tried several free and commercial compilers for 16-bit mode and chose a product from Microsoft.  The compiler together with the linker for the assembler, C and C ++ are included in Microsoft Visual Studio 1.52, you can download it from the official website of the company.  Some details about the compilers we need are given below. <br><br>  <b>ML 6.15</b> - Microsoft's assembler compiler for 16-bit mode. <br>  <b>LINK 5.16</b> is a linker that can create COM files for 16-bit mode. <br>  <b>CL</b> - C, C ++ compiler for 16-bit mode. <br><br>  You can also use several alternatives. <br><br>  <b>DMC</b> is a free compiler for compiling assembler, C, C ++ for 16-bit and 32-bit Digital Mars. <br>  <b>LINK</b> is a free linker for the DMC compiler. <br><br>  There are also some products from Borland. <br><br>  <b>BCC 3,5</b> - C, C ++ compiler that can create files for 16-bit mode. <br>  <b>TASM</b> - assembler compiler for 16-bit mode. <br>  <b>TLINK</b> is a linker that can create COM files for 16-bit mode. <br><br>  All code samples in this article have been developed with tools from Microsoft. <br><br><h4>  How the system boots </h4><br>  In order to solve our problem, we must remember how the system loads. <br>  Let us briefly consider how the components of the system interact when the system boots. <br><br><img src="https://habrastorage.org/storage2/c55/75e/428/c5575e428e5c36d5d9545e9e6fce1934.png"><br><br>  After control has been transferred to the address 0000: 7C00, the Master Boot Record (MBR) starts its work and starts the loading of the operating system. <br><br><h4>  Let's go to coding </h4><br>  In the following sections, we will be directly involved in low-level programming - we will write our own loader. <br><br><h5>  Program architecture </h5><br>  We are developing a bootloader for ourselves.  His tasks are only the following: <br><ol><li>  Correct loading into memory at 0000: 7 C00. </li><li>  Calling the BootMain function we wrote in a high-level language. </li><li>  Display the phrase - ‚ÄúHello, world ...", from low-level. </li></ol><br><br>  The architecture of the program. <br><br><img src="https://habrastorage.org/storage2/e44/81e/835/e4481e8358d3ad1ae51dcd13ef95817c.png"><br><br>  The first object is StartPoint, which is written exclusively in assembly language, since there are no instructions we need in high-level languages.  This tells the compiler what type of memory should be used, and the address of the command in RAM that should be executed after reading it.  It also corrects the registers of the processor and transfers control to the BootMain function, which is written in a high level language. <br><br>  The next object, BootMain, is analogous to main, which, in turn, is the main function in which all program functions are concentrated. <br><br>  Classes CDisplay and CString take care of the functional part of the program and displays a message on the screen.  As you can see in the previous picture, the CDisplay class uses the CString class in its work. <br><br><h5>  Development environment </h5><br>  Here I use standard Microsoft Visual Studio 2005 or 2008 development environments. You can use any other tools, but I'm sure that these two, with some settings, compile and work easily and conveniently. <br><br>  First we need to create a project Makefile Project, where the main work will be done. <br><br>  <b>File-&gt; New \ Project-&gt; General \ Makefile Project</b> <br><img src="https://habrastorage.org/storage2/fea/462/f03/fea462f03c49c8789c8e6a0746a29396.png"><br><br><h5>  BIOS interrupts and clears the screen </h5><br>  To display a message on the screen, we need to clear it to start.  We will use special BIOS interrupts for this purpose. <br><br>  The BIOS offers a series of interrupts for working with hardware, such as a video card, keyboard, system disk.  Each interrupt has the following structure: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> [number_of_interrupt];</code> </pre> <br>  Where "number_of_inter" is the interrupt number. <br><br>  Each interrupt has a number of parameters that must be set before it is called.  The processor register is ah, always responsible for the number of functions for the current interrupt, and other registers are usually used for other parameters of the current operation.  Let's see how the work of interrupt number 10h is done in assembler.  We will use the 00-function, it changes the video mode and clears the screen: <br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">02</span></span>h;    <span class="hljs-number"><span class="hljs-number">80</span></span>x25 () mov ah, <span class="hljs-number"><span class="hljs-number">00</span></span>h;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h;  </code> </pre> <br>  We will consider only those interrupts and functions that will be used in our application.  We will need: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h, function <span class="hljs-number"><span class="hljs-number">00</span></span>h ‚Äì       ; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h, function <span class="hljs-number"><span class="hljs-number">01</span></span>h ‚Äì   ; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h, function <span class="hljs-number"><span class="hljs-number">13</span></span>h ‚Äì    ;</code> </pre> <br><h4>  "Mixed Code" </h4><br>  The C ++ compiler supports inline assembly, that is, when writing code in a high level language, you can also use a low level language.  Assembler instructions that are used at a high level are also called asm inserts.  They consist of the keyword "__asm" and a block of assembler instructions: <br><br><pre> <code class="cpp hljs">__asm ;  ,    ASM  { ;   ‚Ä¶ ;     } ;  </code> </pre> <br>  To demonstrate an example of mixed code, we will use the previously mentioned assembly code that cleans up the screen and combine it with code written in C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __asm { mov al, <span class="hljs-number"><span class="hljs-number">02</span></span>h;    <span class="hljs-number"><span class="hljs-number">80</span></span>x25 () mov ah, <span class="hljs-number"><span class="hljs-number">00</span></span>h;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h;   } }</code> </pre> <br><h5>  CString implementation </h5><br>  The CString class is designed to work with strings.  It includes the Strlen () method, which takes a pointer to a string as a parameter and returns the number of characters in that string. <br><br>  CDisplay class is designed to work with the screen.  It includes several methods: <br><ol><li>  TextOut () - displays a string on the screen. </li><li>  ShowCursor () - controls the on-screen view cursor: show, hide. </li><li>  ClearScreen () - changes the video mode and thus clears the screen. </li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// CString.h #ifndef __CSTRING__ #define __CSTRING__ #include "Types.h" class CString { public: static byte Strlen(const char far* inStrSource); }; #endif // __CSTRING__ // CString.cpp #include "CString.h" byte CString::Strlen(const char far* inStrSource) { byte lenghtOfString = 0; while(*inStrSource++ != '\0') { ++lenghtOfString; } return lenghtOfString; }</span></span></code> </pre><br><h5>  CDisplay - implementation </h5><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// CDisplay.h #ifndef __CDISPLAY__ #define __CDISPLAY__ // // colors for TextOut func // #define BLACK 0x0 #define BLUE 0x1 #define GREEN 0x2 #define CYAN 0x3 #define RED 0x4 #define MAGENTA 0x5 #define BROWN 0x6 #define GREY 0x7 #define DARK_GREY 0x8 #define LIGHT_BLUE 0x9 #define LIGHT_GREEN 0xA #define LIGHT_CYAN 0xB #define LIGHT_RED 0xC #define LIGHT_MAGENTA 0xD #define LIGHT_BROWN 0xE #define WHITE 0xF #include "Types.h" #include "CString.h" class CDisplay { public: static void ClearScreen(); static void TextOut( const char far* inStrSource, byte inX = 0, byte inY = 0, byte inBackgroundColor = BLACK, byte inTextColor = WHITE, bool inUpdateCursor = false ); static void ShowCursor( bool inMode ); }; #endif // __CDISPLAY__ // CDisplay.cpp #include "CDisplay.h" void CDisplay::TextOut( const char far* inStrSource, byte inX, byte inY, byte inBackgroundColor, byte inTextColor, bool inUpdateCursor ) { byte textAttribute = ((inTextColor) | (inBackgroundColor &lt;&lt; 4)); byte lengthOfString = CString::Strlen(inStrSource); __asm { push bp mov al, inUpdateCursor xor bh, bh mov bl, textAttribute xor cx, cx mov cl, lengthOfString mov dh, inY mov dl, inX mov es, word ptr[inStrSource + 2] mov bp, word ptr[inStrSource] mov ah, 13h int 10h pop bp } } void CDisplay::ClearScreen() { __asm { mov al, 02h mov ah, 00h int 10h } } void CDisplay::ShowCursor( bool inMode ) { byte flag = inMode ? 0 : 0x32; __asm { mov ch, flag mov cl, 0Ah mov ah, 01h int 10h } }</span></span></code> </pre> <br><h5>  Types.h - implementation </h5><br>  Types.h is a header file that includes definitions of data types and macros. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types.h #ifndef __TYPES__ #define __TYPES__ typedef unsigned char byte; typedef unsigned short word; typedef unsigned long dword; typedef char bool; #define true 0x1 #define false 0x0 #endif // __TYPES__</span></span></code> </pre> <br><h5>  BootMain.cpp - implementation </h5><br>  BootMain () is the main function of the program, which is the first entry point (analogous to main ()).  The main work is carried out here. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// BootMain.cpp #include "CDisplay.h" #define HELLO_STR "\"Hello, world‚Ä¶\", from low-level..." extern "C" void BootMain() { CDisplay::ClearScreen(); CDisplay::ShowCursor(false); CDisplay::TextOut( HELLO_STR, 0, 0, BLACK, WHITE, false ); return; }</span></span></code> </pre> <br><h5>  StartPoint.asm - implementation </h5><br><pre> <code class="cpp hljs">;------------------------------------------------------------ <span class="hljs-number"><span class="hljs-number">.286</span></span> ; CPU type ;------------------------------------------------------------ .model TINY ; memory of model ;---------------------- EXTERNS ----------------------------- extrn _BootMain:near ; prototype of C func ;------------------------------------------------------------ ;------------------------------------------------------------ .code org <span class="hljs-number"><span class="hljs-number">07</span></span>c00h ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BootSector main: jmp <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> start ; go to main nop ;----------------------- CODE SEGMENT ----------------------- start: cli mov ax,cs ; Setup segment registers mov ds,ax ; Make DS correct mov es,ax ; Make ES correct mov ss,ax ; Make SS correct mov bp,<span class="hljs-number"><span class="hljs-number">7</span></span>c00h mov sp,<span class="hljs-number"><span class="hljs-number">7</span></span>c00h ; Setup a <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> sti ; start the program call _BootMain ret END main ; End of program</code> </pre> <br><h4>  Let's put it all together </h4><br><h5>  Creating a COM file </h5><br>  Now that the code has been developed, we need to convert it to a file for 16-bit OS.  These files are .COM files.  We can run the compiler from the command line, passing the necessary parameters, as a result we get several object files.  Next, we run the linker to convert all .COM files into one executable file with the extension.  Com.  This is a workable option but not very easy. <br><br>  Let's better automate this process.  To do this, we need to create a .bat file and write the necessary commands in it with the necessary parameters. <br><br><br><br>  Place compilers and linker in the project directory.  In the same directory, we create a batch file and fill it in accordance with the example (you can use any directory instead of VC152, the main thing is for the compilers and linker to be in it) .: <br><pre> <code class="cpp hljs">.\VC152\CL.EXE /AT /G2 /Gs /Gx /c /Zl *.cpp .\VC152\ML.EXE /AT /c *.<span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> .\VC152\LINK.EXE /T /NOD StartPoint.obj bootmain.obj cdisplay.obj cstring.obj del *.obj</code> </pre> <br><h5>  Assembly - Automation </h5><br>  As a final step in this section, we describe how to turn Microsoft Visual Studio 2005, 2008 into a development environment with the support of any compiler.  To do this, go to the project properties: <b>Project-&gt; Properties-&gt; Configuration Properties \ General-&gt; Configuration Type</b> . <br><br>  The <b>Configuration Properties</b> tab includes three items: <b>General</b> , <b>Debugging,</b> and <b>NMake</b> .  Select NMake and specify the path to ‚Äúbuild.bat‚Äù in <b>Build Command Line</b> and <b>Rebuild Command Lin</b> . <br><br><br><br>  If done correctly, then you can compile by pressing F7 or Ctrl + F7.  In this case, all related information will be displayed in the output window.  The main advantage here is not only assembly automation, but also monitoring errors in the code if they occur. <br><br><h4>  Testing and demonstration </h4><br>  This section will tell you how to see the boot loader in action, how to test and debug it. <br><br><h5>  How to check the bootloader </h5><br>  You can check the bootloader on real hardware or using VMware virtual machines designed for this purpose.  Testing on real hardware gives you more confidence that it works just like a virtual machine.  Of course, we can say that VmWare is a great way to test and debug.  We will consider both methods. <br><br>  First of all, we need a tool to write our bootloader to a virtual or physical disk.  As far as I know, there are several free and commercial consoles and GUI applications.  I used Disk Explorer for NTFS 3.66 (version for FAT, called Disk Explorer for FAT) for working in Windows OS and Norton Disk Editor 2002 for working in MS-DOS. <br><br>  I will describe only Disk Explorer for NTFS 3.66 because it is the easiest way and most suitable for our purposes. <br><br><h5>  Testing with the VmWare virtual machine </h5><br><h6>  Create a virtual machine </h6><br>  We will need VmWare software version 5.0, 6.0 or higher.  To test the bootloader, we will create a new virtual machine with a minimum disk size, for example, 1 Gb.  Format it to the NTFS file system.  Now we need to display the formatted hard disk on VmWare as a virtual disk.  To do this, select: <br><br>  <b>File-&gt; Map or Disconnect Virtual Disks ...</b> <br><br>  After that, a window will appear.  There you must click the "Map" button.  In the next window that appears, you must specify the path to the disk.  Now you can also select a drive letter. <br><br><br><br>  Do not forget to uncheck the box "Open file in read-only mode (recommended)".  After you have completed all of the above indications, the disk must be read-only to avoid data corruption. <br><br>  After that, we can work with the virtual machine disk as with a regular logical disk in Windows.  Now we have to use Disk Explorer for NTFS 3.66 to write the boot record from position 0. <br><br><h6>  Work with Disk Explorer for NTFS </h6><br>  After starting the program we go to our disk (File-&gt; Drive).  In the window that appears, go to the partition logical drives and select our created disk (in my case it is Z). <br><br><br><br>  Now we select the menu item View as Hex commands.  In this window that appears, we can see the disk information in a 16-bit representation, divided into sectors.  Now we only have 0, since the disk is empty, for now. <br><br><br><br>  Now we need to write our bootloader in the first sector.  We set the marker to position 00, as shown in the previous image.  To copy the bootloader we use the menu item <b>Edit-&gt; Paste from file command</b> .  In the window that opens, specify the path to the file and click <b>Open</b> .  After that, the contents of the first sector should change and look like it is shown in the picture - if you, of course, have not changed anything in the code. <br><br>  You should also record the 55AAh signature on the 1FE position from the beginning of the sector.  If you do not do this, the BIOS will check the last two bytes, and if it does not find the specified signature, it will assume that this sector is not bootable and will not load it into memory. <br><br>  To switch to edit mode, press the <b>F2</b> key and write the necessary numbers - 55AAh signature.  To exit edit mode, press <b>ESC</b> . <br><br>  Now we need to confirm the recorded data. <br><br><br><br>  To apply the recorded we go to <b>Tools-&gt; Options</b> , now we go to the <b>Mode</b> item and select the write method - <b>Virtual Write</b> and click the <b>Write</b> button. <br><br><br><br>  Most of the routine actions have finally been completed, and now you can see that we have developed from the very beginning of this article.  Let's go back to VwWare to disconnect the virtual disk (File-&gt; Map or Disconnect Virtual Disks ... and click Disconnect). <br><br>  Let's run the virtual machine.  We see now how familiar lines appear from the depths of the realm of machine codes - ‚ÄúHello World ...‚Äù, from low-level ... ". <br><br><br><br><h6>  Testing on real equipment </h6><br>  Testing on real hardware is almost the same as on a virtual machine, except that if something does not work, you will need much more time to restore it than to create a new virtual machine.  To test the bootloader without having the opportunity to lose data (anything can happen), I suggest using a flash drive, but first you need to restart your computer, go to the BIOS and make sure that it supports booting from the flash drive.  If he supports him, then everything is in order.  If not, then you should limit testing on a virtual test machine. <br><br>  The process of writing a bootloader to a flash disk in Disk Explorer for NTFS 3.66 is the same as for a virtual machine.  You just have to select the hard disk itself instead of your logical partition. <br><br><br><br><h4>  Conclusion </h4><br>  In this article, we looked at what the boot loader is, how the BIOS works, and how the system components interact when the system boots.  The practical part gave us an understanding of how you can develop your own, simple downloader.  We demonstrated the technology of mixed code and assembly automation using Microsoft Visual Studio 2005, 2008. <br><br>  Of course, this is only a small part compared to the huge topic of low-level programming, but if this article was interesting to you, then this is cool. <br><br>  UPD: <a href="http://www.codeproject.com/Articles/36907/How-to-develop-your-own-Boot-Loader">link to the source</a> </div><p>Source: <a href="https://habr.com/ru/post/173705/">https://habr.com/ru/post/173705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173693/index.html">Dater - determines the time zone, localizes and formats the time in PHP</a></li>
<li><a href="../173697/index.html">New vulnerability allows you to bypass the lock screen in iOS 6.1.3</a></li>
<li><a href="../173699/index.html">High Availability FTP Server with AWS S3 Data Storage</a></li>
<li><a href="../173701/index.html">Checking PHP engine for durability</a></li>
<li><a href="../173703/index.html">Ultra-hard sapphire glass for smartphones</a></li>
<li><a href="../173707/index.html">Internet project managers</a></li>
<li><a href="../173709/index.html">Working with the LCD indicator on the debug board STM32L-Discovery</a></li>
<li><a href="../173711/index.html">6 practical tips for beginners in building a simple BI solution</a></li>
<li><a href="../173713/index.html">Balancing incoming connections on iptables</a></li>
<li><a href="../173715/index.html">Unity Technologies is now on Habr√©. Post about the present and the future</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>