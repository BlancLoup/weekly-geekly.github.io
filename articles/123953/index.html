<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiplication overflow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before performing the multiplication, C ++ leads the factors to one type not shorter than int, and the bitness of the result coincides with the bit de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiplication overflow</h1><div class="post__text post__text-html js-mediator-article">  Before performing the multiplication, C ++ leads the factors to one type not shorter than int, and the bitness of the result coincides with the bit depth of the factors mentioned.  In order not to lose accuracy, it is sometimes required to perform additional operations for multiplication. <a name="habracut"></a><br>  Consider the task.  The system determines the time since the launch of the program in ticks of the microprocessor by calling the function: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTickCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  The length of unsigned long long is 64 bits.  To convert to physical units of time in the system there is a constant: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> TICKS_PER_SECOND = <span class="hljs-number"><span class="hljs-number">1999000001U</span></span>LL;</code> </pre> <br>  It is required to define the function of converting ticks to nanoseconds getNsec (unsigned long long ticks) with semantics: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNsecNaive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticks)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> NSEC_PER_SECOND = <span class="hljs-number"><span class="hljs-number">1000000000U</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> nsec = NSEC_PER_SECOND * ticks / TICKS_PER_SECOND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nsec; }</code> </pre><br>  For the getNsec () function, it is necessary to ensure the highest possible accuracy.  The ticks parameter can be both large and small.  For small ticks (say, up to 2 ^ 34) you need to perform calculations in the following order: <br><pre> <code class="cpp hljs">(NSEC_PER_SECOND * ticks) / TICKS_PER_SECOND</code> </pre> <br>  That is, first multiply, then divide.  Since NSEC_PER_SECOND &lt;2 ^ 30, multiplication will not cause an overflow, since its result will be less than 2 ^ 64. <br>  For large ticks, since multiplication can cause overflow, it is better to perform operations in the following order: <br><pre> <code class="cpp hljs">NSEC_PER_SECOND * (ticks / TICKS_PER_SECOND)</code> </pre> <br>  The problem in this case is that the second factor is always integer, the result in the decimal number system will always end with nine zeros, that is, in fact, second accuracy is provided and the getNsec () function should be renamed to getSec ().  On the other hand, the initial data allow <i>for</i> greater accuracy. <br>  Taking into account the non-associative nature of machine operations of multiplication and division of everything, 4 orders of computation are possible, that is, 2 more in addition to the two considered: <br><pre> <code class="cpp hljs">(NSEC_PER_SECOND / TICKS_PER_SECOND) * ticks</code> </pre> <br>  and <br><pre> <code class="cpp hljs">ticks / (TICKS_PER_SECOND / NSEC_PER_SECOND)</code> </pre> <br>  The first one always gives zero, and the second one - ticks, that is, almost 50% error (which in this case can be reduced to 0.1%, but this error is still not the smallest possible). <br>  So, at best, we get second precision.  The problem of increasing accuracy can be solved in the following ways (in order of increasing preference): <br><ol><li>  Make calculations with real (double) types </li><li>  Arguments to 128-bit integers </li><li>  Use the MultDiv () function </li></ol>  These approaches may not be applicable for reasons of limitations of the platform (processor), programming environment and libraries, project requirements. <br>  We use the following approach.  Let, as a result of dividing ticks by TICKS_PER_SECOND, we get an incomplete quotient of seconds and a remainder of r: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> seconds = ticks / TICKS_PER_SECOND; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> r = ticks % TICKS_PER_SECOND;</code> </pre><br>  Then ticks = seconds * TICKS_PER_SECOND + r.  Substitute in the formula for nsec: <br>  nsec = NSEC_PER_SECOND * (seconds * TICKS_PER_SECOND + r) / TICKS_PER_SECOND = NSEC_PER_SECOND * seconds + (NSEC_PER_SECOND * r) / TICKS_PER_SECOND.  Because r &lt;TICKS_PER_SECOND, (NSEC_PER_SECOND * r) will never overflow.  Summary function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNsec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticks)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> NSEC_PER_SECOND = <span class="hljs-number"><span class="hljs-number">1000000000U</span></span>LL; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NSEC_PER_SECOND * (ticks / TICKS_PER_SECOND) + ((NSEC_PER_SECOND)*(ticks % TICKS_PER_SECOND))/TICKS_PER_SECOND; }</code> </pre><br>  The result is exactly the same as if we counted the NSEC_PER_SECOND * ticks as a 128-bit value, and then divided it into TICKS_PER_SECOND, that is, it provides maximum accuracy for the given initial values ‚Äã‚Äãand a given bitness of the result.  The formula in the return statement is not simplified: neither NSEC_PER_SECOND nor / TICKS_PER_SECOND is bracketed. <br>  In fact, the solution of the problem is reduced to the implementation of the MultDiv (a, b, c) function, which calculates a * b / c, where b and c are large constants, and the fraction b / c is not contractible. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/123953/">https://habr.com/ru/post/123953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123947/index.html">Personal data protection - how to be and what to do?</a></li>
<li><a href="../123948/index.html">Best DNS practices for telecom</a></li>
<li><a href="../123949/index.html">Semantics for CSS selectors and combinators</a></li>
<li><a href="../123950/index.html">The work of the Ural physicists on spintronics in Physical Review Letters</a></li>
<li><a href="../123951/index.html">AVL trees and their breadth</a></li>
<li><a href="../123954/index.html">Starved? New culinary search engine</a></li>
<li><a href="../123955/index.html">Working with URL and storing them</a></li>
<li><a href="../123956/index.html">Debian + SFLC = FAQ</a></li>
<li><a href="../123957/index.html">MIT researchers create paper solar panels</a></li>
<li><a href="../123959/index.html">Undocumented Google Plus Features: Text Layout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>