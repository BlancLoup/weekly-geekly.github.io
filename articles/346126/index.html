<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tachometer or speedometer: The flow of thoughts about measuring the frequency in the Arduino</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 


 If there is an Arduino at home, a car or a motorcycle in the garage, or even a motorcycle dog, there is a vague idea about programming ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tachometer or speedometer: The flow of thoughts about measuring the frequency in the Arduino</h1><div class="post__text post__text-html js-mediator-article"><h2 id="predistoriya">  Prehistory </h2><br><p>  If there is an Arduino at home, a car or a motorcycle in the garage, or even a motorcycle dog, there is a vague idea about programming in the head - there is a desire to measure the speed of movement or engine speed, to count the mileage and hours. </p><br><p>  In this article, I want to share my experience in making such handicrafts. </p><br><p><img src="https://habrastorage.org/webt/a6/7k/fc/a67kfchtxmuderetiy0dubpnhwa.png" alt="Picture to attract attention"></p><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  ,      ,   . //      .       .</span></span></code> </pre> <br><h2 id="nemnogo-fiziki">  A bit of physics </h2><br><p>  To measure the rotational speed, we need a wheel / shaft / circle / so forth sensor.  The sensor is usually placed one.  It is possible that it will trigger more than once per revolution.  For example, you have a Hall sensor and 4 magnets on a wheel.  Thus, to correctly calculate the frequency you need to know: </p><br><ul><li>  the number of sensor activations per revolution K; </li><li>  Minimum Frequency Expected Min. </li><li>  maximum expected frequency Max. </li></ul><br><pre> <code class="hljs 1c"> = () / ; <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ( &lt; <span class="hljs-built_in"><span class="hljs-built_in"></span></span>)  = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ( &lt; <span class="hljs-built_in"><span class="hljs-built_in"></span></span>)  = </code> </pre> <br><p>  That is, if the frequency is less than the reasonable minimum, then we believe that it is zero, if it is greater than the maximum, we ignore the readings. </p><br><p>  The number of operations is understandable, but why else are these mines and maxes?  Let's first consider the options for calculating the frequency. </p><br><p>  With speed everything is simpler, it is enough to know the number œÄ, the diameter of the wheel, and we already know the rotational speed. </p><br><h2 id="bolvanka-dlya-koda">  Code pig </h2><br><p>  Since we are dealing with such gentle values ‚Äã‚Äãas time and space, it is better to master the interrupts immediately. </p><br><pre> <code class="hljs ruby">const byte fqPin = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ATMega32  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>. volatile unsigned long counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    . void ISR() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    counter++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  } void setup() { Serial.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ISR        fqPin. attachInterrupt(digitalPinToInterrupt(fqPin), ISR, RISING); } void loop() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  . noInterrupts(); unsigned long cnt = counter; interrupts(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -   . /<span class="hljs-regexp"><span class="hljs-regexp">/ ... Serial.println(cnt); delay(1000); }</span></span></code> </pre> <br><p>  Pay attention to the volatile modifier in the counter variable.  All variables that will be changed in the interrupt handler (ISR) must be volatile.  This word tells the compiler that the variable may change unexpectedly and access to it cannot be optimized. </p><br><p>  The ISR () function is called each time a unit appears on the leg of fqPin.  We do not call this function, it is done by the controller itself.  It does this even when the main program is in a stupor at the delay () function.  Consider that ISR () serves an event that is independent of you and is given to you from above as setup () and loop ().  The controller interrupts the execution of your program, performs ISR (), and returns back to the same point where it interrupted. </p><br><p>  Note that in the loop () function, we disable any interrupts, in general, in order to read the counter variable and store it in the cnt temporary variable.  Then, of course, turn it on again.  So we can lose one call, of course, but on the other hand, the unsigned long variable has 32 bits, and the ATMega32 processor is 8-bit, it is unlikely that it will copy the data in one clock cycle, and during the copying process an interruption may occur and some data will change .  For the same reason, we copy the value of counter locally, since the value of this variable, when used in different places of the program, may be different again because of its change in the interrupt. </p><br><p>  The body of the ISR () function should be as short as possible; more precisely, the function itself should be performed as quickly as possible.  This is important because it interrupts the execution of your code, which may be sensitive to unexpected delays.  Some libraries disable interrupts to perform delay-sensitive operations, such as controlling the WS2812 LED strip. </p><br><h3 id="schitaem-oboroty-za-edinicu-vremeni">  We consider revolutions per unit of time. </h3><br><p>  The first thing that comes to mind is to take a time interval and count the number of measurements. </p><br><pre> <code class="hljs"> = (  /  ) / </code> </pre> <br><pre> <code class="hljs ruby">const byte fqPin = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ATMega32  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>. const unsigned long interval = <span class="hljs-number"><span class="hljs-number">1000000</span></span>UL; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     const int K = <span class="hljs-number"><span class="hljs-number">1</span></span>; unsigned long oldMks = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    volatile unsigned long counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    . void ISR() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    counter++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  } void setup() { Serial.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ISR        fqPin. attachInterrupt(digitalPinToInterrupt(fqPin), ISR, RISING); } void loop() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     unsigned long mks=microseconds(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  . noInterrupts(); unsigned long cnt = counter; counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    interrupts(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Serial.println( <span class="hljs-number"><span class="hljs-number">1000000</span></span>f * (float)cnt / (float)(mks-oldMks) / (float)K ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span>    /<span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ mks-oldMks ,  interval ,       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,  interval -- . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       oldMks=mks; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        delayMicroseconds(interval); }</span></span></code> </pre> <br><p>  Like many simple solutions, this has unobvious disadvantages.  To increase the accuracy of measurements, you need a rather large time interval.  The principle is the same as that of <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D1%2583%25D0%25BC_%25D0%25BA%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">quantization noise</a> .  At a turn-around time comparable to the counting time, significant changes in the rotational speed will not be noticed.  The readings of such a frequency meter will differ up to two times for each count. </p><br><p>  To improve accuracy at low speed, you can increase the number of K, as is done, for example, in automotive technology for the ABS sensor.  You can increase the counting time.  By doing both, we come to the second problem - overflow of the counter.  Yes, overflow is easily treated by increasing the number of bits, but the ardume of the Arduino processor does not know how to count 64-bit numbers as quickly as we would like and how it does it with 16-bit ones. </p><br><p>  The increase in the calculation time is also not very good, so we need to know the frequency right now, when you press the gas, and not after a couple of seconds.  And after a couple of seconds, we get rather a certain average value.  During this time, you can do a few times vrummm-vrumm. </p><br><p>  There is another method.  He is deprived of the above shortcomings, but, as usual, has its own. </p><br><h3 id="schitaem-interval-mezhdu-otschyotami">  We consider the interval between readings. </h3><br><pre> <code class="hljs"> = 1 / (  *  )</code> </pre> <br><p>  We can detect the time of one reading and another, calculate the difference.  The inverse of the calculated interval is the frequency.  Cool!  But there are downsides. </p><br><pre> <code class="hljs pgsql">const byte fqPin = <span class="hljs-number"><span class="hljs-number">2</span></span>; //  ATMega32  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3.</span></span> const <span class="hljs-type"><span class="hljs-type">int</span></span> K = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> unsigned long <span class="hljs-type"><span class="hljs-type">interval</span></span>; //    . <span class="hljs-type"><span class="hljs-type">void</span></span> ISR() { //    static unsigned long oldTime; //   . unsigned long <span class="hljs-type"><span class="hljs-type">Time</span></span>=microseconds(); <span class="hljs-type"><span class="hljs-type">interval</span></span>=<span class="hljs-type"><span class="hljs-type">Time</span></span>-OldTime(); oldTime=<span class="hljs-type"><span class="hljs-type">Time</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); //   ISR        fqPin. attachInterrupt(digitalPinToInterrupt(fqPin), ISR, RISING); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { //  . noInterrupts(); unsigned long cnt = <span class="hljs-type"><span class="hljs-type">interval</span></span>; interrupts(); //       <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println( <span class="hljs-number"><span class="hljs-number">1000000</span></span>f / ( (<span class="hljs-type"><span class="hljs-type">float</span></span>)K * (<span class="hljs-type"><span class="hljs-type">float</span></span>)(cnt) ); // <span class="hljs-number"><span class="hljs-number">1000000</span></span>    //    . //       // ,       //   <span class="hljs-comment"><span class="hljs-comment">--  . delay(250); }</span></span></code> </pre> <br><p>  What if our wheel spins just barely and the measured interval exceeds reasonable limits?  Above, I suggested counting frequencies below a reasonable minimum as zero. </p><br><p>  A certain disadvantage of the method is quantization noise at high frequencies, when the integer interval is reduced to several binary bits. </p><br><p>  I would also like some statistics calculations to improve the readings, but we take only the latter value. </p><br><p>  Through trial and error, I selected the data display interval on the display at 250ms as the best.  If more often, the numbers are smeared, if less - infuriates stagnation. </p><br><h3 id="kombinirovannyy-metod">  Combined method </h3><br><p>  You can try to combine the advantages of both methods. </p><br><pre> <code class="hljs"> =  /  / </code> </pre> <br><p>  That is, we note the time not only between samples, but the time between data checks and divide by the number of samples during this time.  It turns out the average interval between readings, the return value of which is the frequency.  Let the compiler optimize the calculations. </p><br><pre> <code class="hljs pgsql">const byte fqPin = <span class="hljs-number"><span class="hljs-number">2</span></span>; //  ATMega32  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3.</span></span> const <span class="hljs-type"><span class="hljs-type">int</span></span> K = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> unsigned long counter; //  . <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> unsigned long mks; //   . unsigned long oldTime; //      . //    . <span class="hljs-type"><span class="hljs-type">void</span></span> ISR() { //    mks=microseconds(); //    counter++; //   } <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); //   ISR        fqPin. attachInterrupt(digitalPinToInterrupt(fqPin), ISR, RISING); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { unsigned long rpm; //  . noInterrupts(); unsigned long cnt = counter; counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; unsigned long tmr = mks; interrupts(); //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { rpm = <span class="hljs-number"><span class="hljs-number">1000000</span></span>UL / ((tmr - oldTime) / cnt) / K; oldTime = tmr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rpm = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println( rpm ); delay(<span class="hljs-number"><span class="hljs-number">250</span></span>); }</code> </pre> <br><p>  Please note that the interval is not considered the time of the survey, as in the first example, but the time from the last sample to the previous last sample in the last survey.  This significantly improves the accuracy of the calculation. </p><br><p>  Thus, we can get quite reliable data at both low and high frequencies. </p><br><p>  If you use <a href="https://habrahabr.ru/post/319184/">cooperative multitasking</a> , you can do the calculation, say 100ms times, and output to the display once every 250ms.  A very short polling interval will reduce the sensitivity to low frequencies. </p><br><p>  As they say in advertising, "but that's not all." </p><br><h2 id="oshibki-drebezga">  Bounce errors </h2><br><p>  To frighten you, suppose we measure the engine speed from an inductive ignition sensor.  That is, roughly speaking, a piece of cable is wound on a high-voltage wire and we measure induction in it.  This is a fairly common method, isn't it?  What is so difficult?  The main problem is modern ignition systems, they give not one impulse, but a pack right away. </p><br><p>  Like that: </p><br><img src="https://habrastorage.org/webt/dt/pe/r4/dtper4jmhqafp20ikktyh-vpyhw.jpeg"><br><p>  But even the usual ignition system gives transients: </p><br><img src="https://habrastorage.org/webt/b2/rb/jd/b2rbjdpoazeecxg7esqat7rgxe4.png"><br><p>  Vintage cam contact generally show great pictures. </p><br><p>  How to deal with it?  Rotation speed can not grow instantly, will not give inertia.  In addition, at the beginning of the article I proposed to limit the frequency from above to a reasonable framework.  Counts that occur too often can simply be ignored. </p><br><pre> <code class="hljs"> = ( 1 / ( K * ) )</code> </pre> <br><pre> <code class="hljs pgsql">const byte fqPin = <span class="hljs-number"><span class="hljs-number">2</span></span>; //  ATMega32  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">3.</span></span> const <span class="hljs-type"><span class="hljs-type">int</span></span> K = <span class="hljs-number"><span class="hljs-number">1</span></span>; const unsigned long maxFq = <span class="hljs-number"><span class="hljs-number">20000</span></span>; // rpm (  ) const unsigned long minInterval = <span class="hljs-number"><span class="hljs-number">1000000</span></span>UL / ( K * maxFq ); //     <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> unsigned long counter; //  . <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> unsigned long mks; //   . unsigned long oldTime; //      . //    . <span class="hljs-type"><span class="hljs-type">void</span></span> ISR() { //    static unsigned long oldTmr; //    unsigned long tmr=microseconds(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmr - oldTmr &gt; minImterval) { mks=microseconds(); counter++; oldTmr=tmr; } } <span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">115200</span></span>); //   ISR        fqPin. attachInterrupt(digitalPinToInterrupt(fqPin), ISR, RISING); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { unsigned long rpm; //  . noInterrupts(); unsigned long cnt = counter; counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; unsigned long tmr = mks; interrupts(); //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { rpm = K * <span class="hljs-number"><span class="hljs-number">1000000</span></span>UL / ((tmr - oldTime) / cnt); oldTime = tmr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rpm = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println( rpm ); delay(<span class="hljs-number"><span class="hljs-number">250</span></span>); }</code> </pre> <br><p>  Another type of interference is the loss of samples.  Because of the same inertia, your frequency cannot change twice in one millisecond.  It is clear that it depends on what you actually measure.  The frequency of the beating of the wings of a mosquito can probably fall to zero within a millisecond. </p><br><p>  Statistical processing in this case becomes quite complicated for a small interrupt handling function and I am ready to discuss options in the comments. </p><br><h2 id="osobennosti-izmereniya-skorosti-dvizheniya-i-skorosti-vrascheniya">  Features of measuring the speed of movement and speed of rotation. </h2><br><p>  When measuring the rotational speed of a gasoline engine, it is necessary to take into account the value of K, which is not at all obvious.  For example, you wound a wire on a candle cable and expect that there will be one spark per revolution.  It's not like that at all.  Firstly, in a 4-stroke engine, a flash occurs once every two turns, in a 2-stroke engine once a revolution of the crankshaft.  Secondly, to simplify the ignition system, the switch gives a spark to the currently disabled cylinders, such as on the release.  To get the correct K, you need to read the engine documentation or peep the readings of the reference tachometer. </p><br><p>  When measuring the speed of movement, the refresh rate of the display does not matter much, especially if you are drawing numbers and not moving the arrow.  Even updating the information once a second will not cause rejection.  With engine revs all the way around, the indicator should respond much faster to changes in revolutions. </p><br><h3 id="vyvod-informacii">  Information output </h3><br><p>  A typical resentment of a novice developer of automotive and motorcycle electronics "arrows jerk, numbers are unreadable" is treated in a simple way - you must deceive the client.  Do you think the car tachometer always shows you the truth?  Of course not!  Although you like this deception and you want your device to fool your head in the same way. </p><br><h4 id="strelki">  Arrows </h4><br><p>  If you turn on the ignition on a new fashionable car or motorcycle, the hands of the instruments will make a beautiful out to the maximum and will slowly fall to zero.  Here!  This is what we need to do.  It is necessary that when the maximum value is shown, the arrow does not dash towards it instantly and does not fall as the scam share to zero. </p><br><p>  So, we need to take into account the maximum speed of the arrow to increase and the maximum to decrease readings.  It‚Äôs quite good to make these speeds non-linear, so that the arrow first moves faster and then slowly approaches the specified value. </p><br><p>  Here is an example with non-linear reading: </p><br><pre> <code class="hljs ruby">dispRPM(unsigned int rpm) { static unsigned int lastRpm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rpm &gt; lastRpm) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  unsigned int disp = rpm - (lastRpm-rpm)/<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   outputRPM(disp); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   lastRpm=disp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  unsigned int disp = rpm - (lastRpm-rpm)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   outputRPM(disp); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   lastRpm=disp; } }</code> </pre> <br><p>  You can play with the coefficients.  The same principle is used when outputting the volume of a signal, for example, for any analog indicator: arrows, stripes, brightness, color, size, etc.  The above example is the simplest, but not the most beautiful.  Offer your options in the comments. </p><br><h4 id="cifry">  Numbers </h4><br><p>  With numbers, everything is much more complicated.  Rapid changes in readings lead to the fact that several orders merge into a muddy spot.  For speed, as I wrote above, you can set the interval once a second and the eye will have time to read three numbers. </p><br><p>  In motorcycle technology, analog speed indicators are not in vain, exact figures are not needed, the relative proximity to the speed of the maximum torque, to the maximum in general and idle is important. </p><br><p>  I propose to change the frequency of displaying information on the display depending on the degree of change in the magnitude.  If the speed changes, say, by 5% from the last calculation, and not the display - you can blunt and show once in 300-500ms.  If at 20%, then show once in 100ms. </p><br><p>  You can harden the scale and show only two significant digits. </p><br><p>  Taking into account motomatics, it is possible to fairly accurately show the idling speed as described just above and harden the output on the revolutions of two idle ones.  At high speeds for racers it is more important to make blinkers like ‚Äútransfer down‚Äù, ‚Äútransfer up‚Äù and ‚Äúyou burn the engine‚Äù.  That is, keep the engine near the maximum torque and prevent it from spinning above the maximum allowed speed.  Blinkers are great with <a href="https://github.com/nw-wind/SmartDelay">SmartDelay</a> when you can inherit your class from this class with a given controller foot and blink rate, there are methods to override and they are called once at a given time. </p><br><p>  Ideas for displaying numbers are also welcome in the comments. </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  If you step on all the rakes, you can become an experienced developer. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346126/">https://habr.com/ru/post/346126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346112/index.html">Telegram-bot as a gift</a></li>
<li><a href="../346114/index.html">Meltdown: not only affects performance</a></li>
<li><a href="../346116/index.html">Restate - or how to turn a Redux log into a tree</a></li>
<li><a href="../346118/index.html">MPS 2017.3 released</a></li>
<li><a href="../346120/index.html">Ok google get me a car</a></li>
<li><a href="../346128/index.html">February 31</a></li>
<li><a href="../346130/index.html">So why aren't you participating in the development of open source software?</a></li>
<li><a href="../346132/index.html">Stimulus 1.0: a modest JavaScript HTML framework that you already have</a></li>
<li><a href="../346134/index.html">Genetic algorithm for constructing algorithms</a></li>
<li><a href="../346136/index.html">L√ñVE Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>