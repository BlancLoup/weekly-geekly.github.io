<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add Distribution to SObjectizer-5 using MQTT and libmosquitto</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once in SObjectizer-4, out of the box, the ability to build distributed applications was available. But it did not always work as well as we would lik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add Distribution to SObjectizer-5 using MQTT and libmosquitto</h1><div class="post__text post__text-html js-mediator-article">  Once in SObjectizer-4, out of the box, the ability to build distributed applications was available.  But it did not always work as well as we would like.  As a result, in SObjectizer-5, we refused to support distribution in the core of <a href="https://stiffstream.com/en/products/sobjectizer.html">SObjectizer,</a> but we refused (this issue is discussed in more detail <a href="https://habr.com/post/325248/">here</a> ).  They refused in favor of choosing a specific transport for a specific task, taking into account the peculiarities of this very task.  Writing for this the appropriate binding, which will hide from the programmer the details of the work of the selected transport. <br><br>  In this article we will try to talk about one such binding around <a href="http://mqtt.org/">MQTT</a> and <a href="https://mosquitto.org/man/libmosquitto-3.html">libmosquttio</a> , through which the possibility of interaction between parts of a distributed application was realized. <br><a name="habracut"></a><br><h1>  What and why </h1><br>  A couple of years ago, we helped one team with the development of a prototype distributed measurement system.  The prototype has earned and, as far as we know, it is still in demo mode.  Unfortunately, the team had difficulty finding further funding and the project froze.  Because of the ‚Äúsuspended‚Äù status of the project, we will be able to tell only what we can tell, without <s>names, attendances and passwords</s> details. <br><br>  So, there was the idea of ‚Äã‚Äãcreating a distributed system for collecting some measurement information.  It was planned to have a central server, where all collected information flows and where it is processed.  And also some set (from several hundred to several thousand) ‚Äúmeasuring stations‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Initially, the central server distributes commands to collect information at the measuring stations.  And already beyond the station themselves at any time can give information to the central server, while the central server at any time can issue new commands to the measuring stations. <br><br>  To implement the filling stations, measuring stations decided to use C ++.  Both because of the savings of resources of these stations, and because of the need to work with the system API in places. <br><br>  In the implementation of the central server, it was possible to use Java and / or something more convenient and secure than C ++.  Although within the framework of the prototype in C ++, a demo ‚Äúserver‚Äù was written in C ++, which supported several scenarios for collecting information from measuring stations, but without processing this information. <br><br><h2>  MQTT as a transport </h2><br>  So, there is a measuring station where a process written in C ++ turns, which should interact with the central server: receive commands from the server, give the results of command execution to the server, monitor connection with the server, reconnect to the server when the connection is broken, etc. <br><br>  A natural question arose: what kind of transport will be used to communicate the central server with the measuring stations? <br><br>  It must be said that the answer to this question was not sought for very long.  We stopped at the protocol MQTT, which: <br><br><ul><li>  has an official specification and there are implementations of this specification for different programming languages; </li><li>  very simple and lightweight.  Those.  even if it is necessary for some very specific conditions to write our own implementation of this protocol, it will not be difficult; </li><li>  makes it easy to exchange information in both directions; </li><li>  involves the use of a simple, but powerful and convenient model Publish / Subscribe. </li></ul><br>  In general, in our opinion, since MQTT was created for such tasks, it is a sin not to use it in such conditions. <br><br>  But MQTT is transport.  It was decided to frame the data in JSON.  Fortunately, JSON is quite simple, understandable and lightweight.  Again, for any more or less popular programming language there are libraries that allow you to work with JSON. <br><br>  Thus, we are faced with the fact that in our C ++ code we have to make SObjectizer friends with MQTT and JSON.  Here's how we did it and talk further. <br><br><h1>  What have we got? </h1><br>  We did a small add-on over SObjectizr and libmosquitto called <a href="">mosquitto_transport</a> .  This add-on takes over the task of interacting with the MQTT broker and provides the developer with a small API for publishing and subscribing the message. <br><br>  The mosquitto_transport library is written in C ++ 14, runs under Linux, supports only a part of the MQTT capabilities (in particular, only QoS = 0 is used).  In general, it implements the minimum that was required for the prototype. <br><br><h2>  What is the use of mosquitto_transport? </h2><br>  To use mosquitto_transport, a developer needs to take a few required steps, which we'll take a closer look at below. <br><br><blockquote>  The mosquitto_transport library places all its contents in the mosquitto_transport namespace.  But such a long name is inconvenient to use in the examples.  Therefore, in the following, the synonym mosqtt will be used, which is introduced as follows: namespace mosqtt = mosquitto_transport; </blockquote><br><br><h3>  Step one.  Initializing mosquitto_transport and libmosquitto </h3><br>  The mosquitto_transport base is libmosquitto, and libmosquitto needs to be explicitly initialized at the beginning of the program and explicitly deinitialized at the end of the program.  Therefore, to work with mosquitto_transport, you need to create somewhere in the program an object of type lib_initializer_t.  This object will initialize libmosquitto in its constructor, and in the destructor it will perform deinitialization.  The link to lib_initializer_t will then need to be passed to the a_transport_manager_t agent constructor. <br><br>  Usually in the program it looks like this: <br><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">lib_initializer_t</span></span> mosqtt_lib; ... }</code> </pre> <br><h3>  Step two.  Run the a_transport_manager_t agent and get an instance_t instance </h3><br>  The whole flow of incoming and outgoing messages is serviced by the special agent a_transport_manager_t.  The developer himself must create an agent of this type in his program and register this agent as part of some kind of cooperation. <br><br>  In addition to actually creating and registering the a_transport_manager_t agent, you need to do one more important thing: take an instance of an object of a special type instance_t from the agent.  This instance_t will be needed to publish and receive messages. <br><br>  If there are only a few agents in the application, then all of them can be put into one cooperation with the a_transport_manager_t agent: <br><br><pre> <code class="hljs markdown">int main() { ... mosqtt::lib<span class="hljs-emphasis"><span class="hljs-emphasis">_initializer_</span></span>t mosqtt<span class="hljs-emphasis"><span class="hljs-emphasis">_lib; ... so_</span></span>5::launch([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::environment_t &amp; env</span></span>) { //   ,     //  . env.introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_coop([&amp;](so_</span></span>5::coop<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; coop) { //   . auto transport = coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mosqtt::a_transport_manager_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(...); //      . coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;first_</span></span>app<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&gt;(..., transport-&gt;instance(), ...); coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">second_app_agent</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(..., transport-&gt;instance(), ...); coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;third_</span></span>app_agent&gt;(..., transport-&gt;instance(), ...); }); }); }</code> </pre> <br>  But in more complex cases, when application agents are more and / or application agents can appear and disappear as the application runs, it makes sense to create a separate cooperation with a_transport_manager_t and link this agent to its own dispatcher.  In this case, it may be reasonable to allocate the creation of a_transport_manager_t into a separate auxiliary function: <br><br><pre> <code class="hljs cpp">mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">instance_t</span></span> make_transport( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env, mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">lib_initializer_t</span></span> &amp; mosqtt_lib, ... <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span>) { mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">instance_t</span></span> instance; env.introduce_coop( <span class="hljs-comment"><span class="hljs-comment">//        . so_5::disp::one_thread::create_private_disp(env)-&gt;binder(), [&amp;](so_5::coop_t &amp; coop) { auto transport = coop.make_agent&lt;mosqtt::a_transport_manager_t&gt;( std::ref{mosqtt_lib}, ... /*   */); instance = transport-&gt;instance(); }); return instance; }</span></span></code> </pre> <br>  This allows you to use make_transport, for example, as follows: <br><br><pre> <code class="hljs markdown">int main() { ... mosqtt::lib<span class="hljs-emphasis"><span class="hljs-emphasis">_initializer_</span></span>t mosqtt<span class="hljs-emphasis"><span class="hljs-emphasis">_lib; ... so_</span></span>5::launch([<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::environment_t &amp; env</span></span>) { //  MQTT-. auto mqtt = make<span class="hljs-emphasis"><span class="hljs-emphasis">_transport(env, mosqtt_</span></span>lib, ...); //       . env.introduce<span class="hljs-emphasis"><span class="hljs-emphasis">_coop([&amp;](so_</span></span>5::coop<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; coop) { coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">first_app_agent</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(..., mqtt, ...); coop.make<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&lt;second_</span></span>app<span class="hljs-emphasis"><span class="hljs-emphasis">_agent&gt;(..., mqtt, ...); coop.make_</span></span>agent<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">third_app_agent</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(..., mqtt, ...); }); //       . env.introduce_coop(...); ... //   . }); }</code> </pre> <br>  A remarkable feature of the a_transport_manager_t agent is that it has a number of event handlers marked as thread-safe.  This makes it possible to bind this agent to the adv_thread_pool type dispatcher.  In this case, the agent will be able to process part of his events in parallel on several working threads at once.  Although in practice we did not need this functionality. <br><br><h3>  Step three.  Implementation of serialization / deserialization of application messages </h3><br>  The most important part when using mosquitto_transport is the implementation of the presentation format of the transmitted messages.  For example, if we have a message like: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sensor_data_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_category_t</span></span> category_; <span class="hljs-keyword"><span class="hljs-keyword">timestamp_t</span></span> when_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value_; ... };</code> </pre> <br>  then, to send it to the MQTT broker and then subscribers should convert the message to some format.  For example, in XML, JSON or ProtoBuf.  In order for this to occur automatically while working with mosquitto_transport, the developer must implement serialization / deserialization.  In more detail this question is considered below, for now we will show the main idea. <br><br>  First, the developer must decide how the data will be presented.  For example, it may be a textual JSON representation.  Or a binary ProtoBuf view.  Maybe this and the other - mosquitto_transport does not interfere with this, but the developer himself must keep track of which message format he uses in which topics. <br><br>  Secondly, for each of its format, the developer must determine the type tag.  For example, if we want to use only JSON, then we define the following type of tag: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json_encoding</span></span></span><span class="hljs-class"> </span></span>{};</code> </pre> <br>  This tag type is required for parameterization of templates and selection of overloaded functions. <br><br>  Third, the developer should define for each of his own form in the mosquitto_transport namespace a partial specialization for the encoder_t and decoder_t template classes. <br>  To get something like: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   -,     . struct my_encoding_tag {}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span>    /<span class="hljs-regexp"><span class="hljs-regexp">/     mosquitto_transport. namespace mosquitto_transport { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . template&lt;typename Msg&gt; struct encoder_t&lt;my_encoding_tag, Msg&gt; { static std::string encode(const Msg &amp; what) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -   . } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . template&lt;typename Msg&gt; struct decoder_t&lt;my_encoding_tag, Msg&gt; { static Msg decode(const std::string &amp; payload) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -   . } }; } /</span></span>* namespace mosquitto_transport *<span class="hljs-regexp"><span class="hljs-regexp">/</span></span></code> </pre> <br>  Further, the operation of posting messages and subscribing to messages will need to specify the type tag as a marker, thanks to which mosquitto_transport will understand exactly how to serialize and deserialize messages. <br><br><h3>  Next steps.  Posting and receiving messages </h3><br>  After the three required steps have been completed, you can perform message publishing and message subscriptions. <br><br>  The publication is as follows: <br><br><pre> <code class="hljs ruby">mosqtt::topic_publisher_t&lt;Tag_Type&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:publish</span></span>( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  instance,   a_transport_manager_t. instance, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    MQTT-,     /<span class="hljs-regexp"><span class="hljs-regexp">/  . "some/topic</span></span><span class="hljs-regexp"><span class="hljs-regexp">/name", /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . some_message_instance);</span></span></code> </pre> <br>  We say such operations that we want to publish a message to a specific topic and that this message should be serialized accordingly (the format defines the template Tag_Type parameter).  For example, we could write this: <br><br><pre> <code class="hljs cpp">mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">topic_publisher_t</span></span>&lt;my_encoding_tag&gt;::publish( instance, <span class="hljs-string"><span class="hljs-string">"/sensor/1023/updates"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sensor_data_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data_category_t</span></span>::recent_value, current_timestamp, value});</code> </pre> <br>  In this case, mosquitto_transport would serialize data from a message of type sensor_data_t into the format defined for my_encoding_tag, and publish the resulting message in the topic "/ sensor / 1023 / updates". <br><br>  In order to receive messages that someone publishes to topics of interest to us, you need to do something like a ‚Äúdouble subscription‚Äù: you need to call a special method subscribe () and inside this method subscribe to messages from a special mbox.  For example, if we want to receive all messages from the "/ sensor / + / updates" topics, then we can make the following call subscribe () inside one of our agents: <br><br><pre> <code class="hljs markdown">class my<span class="hljs-emphasis"><span class="hljs-emphasis">_agent_</span></span>t : public so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::agent_</span></span>t { ... void so<span class="hljs-emphasis"><span class="hljs-emphasis">_define_</span></span>agent() override { mosqtt::topic<span class="hljs-emphasis"><span class="hljs-emphasis">_subscriber_</span></span>t<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">my_encoding_tag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>::subscribe( //  instance,   a<span class="hljs-emphasis"><span class="hljs-emphasis">_transport_</span></span>manager<span class="hljs-emphasis"><span class="hljs-emphasis">_t. instance_</span></span>, // ,    . "sensor/+/updates", // ,       //  . [<span class="hljs-string"><span class="hljs-string">this</span></span>](<span class="hljs-link"><span class="hljs-link">so_5::mbox_t mbox</span></span>) { //    ,     //  . so<span class="hljs-emphasis"><span class="hljs-emphasis">_subscribe(mbox).event(&amp;my_</span></span>agent<span class="hljs-emphasis"><span class="hljs-emphasis">_t::on_</span></span>sensor<span class="hljs-emphasis"><span class="hljs-emphasis">_data); }); } ... void on_</span></span>sensor<span class="hljs-emphasis"><span class="hljs-emphasis">_data( mhood_</span></span>t<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mosqtt::incoming_message_t</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">my_encodig_tag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>&gt; cmd) { ... } };</code> </pre> <br>  A double subscription is needed here because, in essence, we have two different actions: <br><br><ul><li>  First, we need to force transport_manager to subscribe to a specific topic on the MQTT broker.  Without this subscription, the broker simply will not deliver us new incoming messages.  Actually, this is exactly what the subscribe () method does; </li><li>  secondly, when the MQTT broker delivers a message to us from a topic we have signed, then we need to deliver this message to the receiving agent.  For this, the SObjectizer subscription mechanism should be used.  That is why a new mbox is created inside subscribe (), which will be associated with a specific subscription to the MQTT broker.  When the broker gives us a new message, this message will be sent to the mbox.  Accordingly, the message will reach the agent who subscribed to this mbox. </li></ul><br><h3>  Simplest Hello, World </h3><br>  To demonstrate the mosquitto_transport ‚Äúin action‚Äù, we will make a typical Hello-Worlds example.  The example includes two applications: <br><br><ul><li>  demo_server_app.  It connects to the local MQTT broker and subscribes to messages from the "/ client / + / hello" topics.  When the message arrives, it responds with a reply message to the topic "/ client /: ID / replies"; </li><li>  demo_client_app.  It connects to the local MQTT broker, subscribes to the topic "/ client /: ID / replies" and publishes the message to the topic "/ client /: ID / hello".  Finishes its work as soon as the "/ client /: ID / replies" comes the answer. </li></ul><br>  As the ": ID" in the names of the topics, an integer identifier will be used, which demo_client_app generates randomly. <br><br>  Messages are transmitted in JSON format. <br><br>  Sample sources can be found <a href="https://bitbucket.org/sobjectizerteam/so5_mosqtt_demo_ru">in this repository</a> .  We will go through the main points of the example implementation. <br><br><h4>  Defining messages for ‚Äúclient‚Äù and ‚Äúserver‚Äù interactions </h4><br>  In the header file <a href="">demo / messages.hpp</a> , definitions of data structures are made that act as messages for the interaction between the ‚Äúclient‚Äù and ‚Äúserver‚Äù.  The client sends the server a message of the type client_hello_t, and the server sends a message of the type server_hello_t in response.  Of course, in the form of MQTT messages, the representations of these messages are serialized in JSON.  But in the program, the work goes exactly with client_hello_t / server_hello_t types. <br><br>  In order for messages of the client_hello_t / server_hello_t types to be serialized and deserialized properly, we define a tag type with the name json_format_t.  And we do a partial specialization of encoder_t and decoder_t in accordance with how we talked about this above.  To work with JSON, we use a small add-on to RapidJSON called <a href="">json_dto</a> .  Therefore, inside our client_hello_t / server_hello_t types there are json_io template methods - this is just the specifics of json_dto. <br><br>  So, that's what's in messages.hpp: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#pragma once #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;json_dto/pub.hpp&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mosquitto_transport/pub.hpp&gt;</span></span></span><span class="hljs-meta"> namespace demo { // -,         //  . struct json_format_t {}; //    . using publisher_t = mosquitto_transport::topic_publisher_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;json_format_t&gt;</span></span></span><span class="hljs-meta">; using subscriber_t = mosquitto_transport::topic_subscriber_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;json_format_t&gt;</span></span></span><span class="hljs-meta">; //     . struct client_hello_t { int id_; std::string greeting_; std::string reply_topic_; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Json_Io&gt;</span></span></span><span class="hljs-meta"> void json_io(Json_Io &amp; io) { using namespace json_dto; io &amp; mandatory(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"id"</span></span></span><span class="hljs-meta">, id_) &amp; mandatory(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"greeting"</span></span></span><span class="hljs-meta">, greeting_) &amp; mandatory(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"reply_topic"</span></span></span><span class="hljs-meta">, reply_topic_); } }; //    . struct server_hello_t { std::string greeting_; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Json_Io&gt;</span></span></span><span class="hljs-meta"> void json_io(Json_Io &amp; io) { io &amp; json_dto::mandatory(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"greeting"</span></span></span><span class="hljs-meta">, greeting_); } }; } /* namespace demo */ //   - . namespace mosquitto_transport { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Msg&gt;</span></span></span><span class="hljs-meta"> struct encoder_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;demo::json_format_t, Msg&gt;</span></span></span><span class="hljs-meta"> { static std::string encode(const Msg &amp; msg) { return json_dto::to_json(msg); } }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Msg&gt;</span></span></span><span class="hljs-meta"> struct decoder_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;demo::json_format_t, Msg&gt;</span></span></span><span class="hljs-meta"> { static Msg decode(const std::string &amp; json) { return json_dto::from_json</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Msg&gt;</span></span></span><span class="hljs-meta">(json); } }; } /* namespace mosquitto_transport */</span></span></code> </pre> <br>  Separate explanations may deserve the definition of the names publisher_t and subscriber_t.  They are needed so that you can write in the application code, for example: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">publisher_t</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::publish(...)</span></span></code> </pre> <br>  instead: <br><br><pre> <code class="hljs cpp">mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">topic_publisher_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">json_format_t</span></span>&gt;::publish(...)</code> </pre> <br><h4>  Common Utility Code </h4><br>  Another header file, <a href="">demo / common.hpp</a> , contains support functions that both the client and the server need. <br><br>  The function make_loggers (), which we will not consider, creates objects for logging.  We need two such objects.  The first will be used by mosquitto_transport.  The second is a demo application.  In the example for loggers, the level of detail is set to spdlog :: level :: trace.  Those.  everything that allows you to observe almost everything that happens inside the application will be logged. <br><br>  But the run_transport_manager () function, the code of which we will look at, serves just to create and launch the a_transport_manager_t agent.  Returns the run_transport_manager () instance of the mosquitto_transport :: instance_t type, which is then required for publishing and subscribing: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_transport_manager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; client_id, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;spdlog::logger&gt; logger)</span></span></span><span class="hljs-function"> </span></span>{ mosquitto_transport::<span class="hljs-keyword"><span class="hljs-keyword">instance_t</span></span> mqtt; env.introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lib = coop.take_under_control( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;mosquitto_transport::<span class="hljs-keyword"><span class="hljs-keyword">lib_initializer_t</span></span>&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tm = coop.make_agent&lt;mosquitto_transport::<span class="hljs-keyword"><span class="hljs-keyword">a_transport_manager_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(*lib), mosquitto_transport::<span class="hljs-keyword"><span class="hljs-keyword">connection_params_t</span></span>{ client_id, <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">1883u</span></span>, <span class="hljs-number"><span class="hljs-number">60u</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger)); mqtt = tm-&gt;instance(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mqtt; }</code> </pre> <br>  Here a new cooperation is created, which contains a single agent - a_transport_manager_t.  Connection to the MQTT broker (since this is a hello-vorlo example, the MQTT broker on localhost is enough) and the logger that should be used are transferred to this agent in the constructor.  But the most interesting thing here is the creation of the lib_initializer_t object.  It is created dynamically, and responsibility for its removal is shifted to cooperation with the agent a_transport_manager_t.  Thus, we get that libmosquitto will be initialized immediately before creating the a_transport_manager_t agent, and it will be deinitialized after the a_transport_manager_t agent ceases to exist. <br><br><h4>  Main demo_server_app </h4><br>  In <a href="">demo_server_app, the</a> entire listener logic is executed by the listener_t agent, implemented as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">listener_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">listener_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">instance_t</span></span> mqtt, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} , mqtt_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mqtt)} , logger_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger)} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ demo::<span class="hljs-keyword"><span class="hljs-keyword">subscriber_t</span></span>::subscribe(mqtt_, <span class="hljs-string"><span class="hljs-string">"/client/+/hello"</span></span>, [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &amp; mbox) { so_subscribe(mbox).event(&amp;<span class="hljs-keyword"><span class="hljs-keyword">listener_t</span></span>::on_hello); }); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: mosqtt::<span class="hljs-keyword"><span class="hljs-keyword">instance_t</span></span> mqtt_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;demo::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">subscriber_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::msg_type&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{ logger_-&gt;trace(<span class="hljs-string"><span class="hljs-string">"message received from topic: {}, payload={}"</span></span>, cmd-&gt;topic_name(), cmd-&gt;payload()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> msg = cmd-&gt;decode&lt;demo::<span class="hljs-keyword"><span class="hljs-keyword">client_hello_t</span></span>&gt;(); logger_-&gt;info(<span class="hljs-string"><span class="hljs-string">"hello received. client={}, greeting={}"</span></span>, msg.id_, msg.greeting_); demo::<span class="hljs-keyword"><span class="hljs-keyword">publisher_t</span></span>::publish( mqtt_, msg.reply_topic_, demo::<span class="hljs-keyword"><span class="hljs-keyword">server_hello_t</span></span>{<span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>}); } };</code> </pre> <br>  This can be said to be a typical small SObjectizer agent agent.  In its overloaded method so_define_agent (), you subscribe to messages from topics that satisfy the "/ client / + / hello" mask.  When such messages from the broker arrive, the on_hello method will be called to process them. <br><br>  A special object is passed to the on_hello () method, which contains the name of the topic (in which the message was published) and the message itself exactly in the form in which it came from the MQTT broker.  Those.  in the JSON representation.  But we want to receive this message as an object of type client_hello_t.  For this, the decode () method is called, in which the body of the message is deserialized from JSON to client_hello_t. <br><br>  Well, at the end of on_hello (), a response message is published.  The name of the topic for the publication of the answer is taken from the client_hello_t. <br><br><h4>  Main demo_client_app </h4><br>  In <a href="">demo_client_app</a> , the only agent of the client_t type performs the same work.  But this agent is somewhat more complicated than listener_t in demo_server_app.  Here is the client_t code: <br><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_5::agent_t</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_t</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mosqtt::instance_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mqtt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;spdlog::logger&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">logger</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_5::agent_t</span></span></span><span class="hljs-class">{</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::move</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">)} , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id_</span></span></span><span class="hljs-class">{</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">} , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mqtt_</span></span></span><span class="hljs-class">{</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::move</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mqtt</span></span></span><span class="hljs-class">)} , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">logger_</span></span></span><span class="hljs-class">{</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::move</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">logger</span></span></span><span class="hljs-class">)} { } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> { //        . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_subscribe</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mqtt_</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbox</span></span></span><span class="hljs-class">()).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client_t::on_broker_connected</span></span></span><span class="hljs-class">);</span></span> demo::subscriber_t::subscribe(mqtt<span class="hljs-number"><span class="hljs-number">_</span></span>, make_topic_name(<span class="hljs-string"><span class="hljs-string">"/replies"</span></span>), [&amp;](const so_5::mbox_t &amp; mbox) { so_subscribe(mbox).event(&amp;client_t::on_reply); }); } <span class="hljs-symbol"><span class="hljs-symbol">private:</span></span> const int id<span class="hljs-number"><span class="hljs-number">_</span></span>; mosqtt::instance_t mqtt<span class="hljs-number"><span class="hljs-number">_</span></span>; std::shared_ptr&lt;spdlog::logger&gt; logger<span class="hljs-number"><span class="hljs-number">_</span></span>; std::string make_topic_name(const char * suffix) const { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::string(<span class="hljs-string"><span class="hljs-string">"/client/"</span></span>) + std::to_string(id<span class="hljs-number"><span class="hljs-number">_</span></span>) + suffix; } void on_broker_connected(mhood_t&lt;mosqtt::broker_connected_t&gt;) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,        /<span class="hljs-regexp"><span class="hljs-regexp">/  . demo::publisher_t::publish( mqtt_, make_topic_name("/hello</span></span><span class="hljs-string"><span class="hljs-string">"), demo::client_hello_t{ id_, "</span></span>Hello, World<span class="hljs-string"><span class="hljs-string">", make_topic_name("</span></span>/replies<span class="hljs-string"><span class="hljs-string">")}); } void on_reply(mhood_t&lt;demo::subscriber_t::msg_type&gt; cmd) { logger_-&gt;trace("</span></span>message received from <span class="hljs-symbol"><span class="hljs-symbol">topic:</span></span> {}, payload={}<span class="hljs-string"><span class="hljs-string">", cmd-&gt;topic_name(), cmd-&gt;payload()); const auto msg = cmd-&gt;decode&lt;demo::server_hello_t&gt;(); logger_-&gt;info("</span></span>hello received. greeting={}<span class="hljs-string"><span class="hljs-string">", msg.greeting_); //      . logger_-&gt;warn("</span></span>finishing<span class="hljs-string"><span class="hljs-string">"); so_environment().stop(); } };</span></span></code> </pre> <br>  Here the client_t agent handles two events.  With the event that the on_reply () handler is subscribing to, everything should be clear - this is the processing of the message that comes from the MQTT broker. <br><br>  Explains the on_broker_connected handler.  The fact is that when the client starts, you need to choose the moment when you can publish the initial message in the topic "/ client /: ID / hello".  Since if the client_t agent does it right after its start, the message will not go anywhere and will be lost, since  there is no connection to the MQTT broker yet.  Therefore, the client_t agent needs to wait until this connection is established. <br><br>  A_transport_manager_t deals with the interaction with the MQTT broker.  When a connection with a broker appears (that is, when not only a TCP connection is established with a broker, but also when exchanged with a broker by CONNECT / CONNACT messages), the a_transport_manager_t agent sends the broker_connected_t signal to the special mbox.  The client_t subscribes to this signal and when the signal arrives, the client_t publishes the client_hello_t message. <br><br><h4>  The results of the application </h4><br>  Running demo_server_app you can see approximately the following picture: <br><br><img src="https://habrastorage.org/webt/zy/pt/hf/zypthf3uvzvrxeyk4wqk85kor58.jpeg"><br><br>  Here you can see how demo_server_app connected to the broker, how it made the subscription, how it received the incoming message and how it responded to it. <br><br>  Running demo_client_app, you can see a picture of such a plan: <br><br><img src="https://habrastorage.org/webt/lf/as/lf/lfaslfez9m-obygy20azol-eacg.jpeg"><br><br>  Here you can see how demo_client_app connected to the broker, how it made a subscription, how it sent its welcome message and how it received a message from demo_server_app in response. <br><br><h1>  A few words about the design decisions made </h1><br>  Above, we have shown what the <a href="">mosquitto_transport</a> library we have at the moment looks like.  Now you can try to say a few words about a number of design decisions that were the basis for implementation. <br><br><h2>  Small disclaimer: mosquitto_transport is itself a prototype </h2><br>  When we had the task of providing an opportunity for SObjectizer agent agents to communicate with the outside world through MQTT, we quickly became convinced that using widely used libraries such as <a href="https://mosquitto.org/man/libmosquitto-3.html">libmosquitto</a> and <a href="https://www.eclipse.org/paho/">Paho is</a> not convenient.  With primitive C ++ wrappers over them, everything was just as sad. <br><br>  The main problem, in particular, with libmosquitto, was that in libmosquitto it is supposed to do the processing of all incoming messages in the same callback in general.  Whereas we need to have several independent agents in the application, each of which should receive only those messages in which he is interested. <br><br>  Accordingly, it was necessary to make some layer that would be located between the application agents and libmosquitto.  So that this layer hides from agents all the work with libmosquitto calls and callbacks.  But what should this layer be? <br><br>  Naturally, we did not have a ready answer.  In mosquitto_transport we tried to find this answer.  It turned out more or less normal, especially given the fact that the forces in mosquitto_transport were invested, quite frankly, very little.  Most of the work required the support of wildcards in the names of topics in the subscription.  Well, writing an understandable README, so that you yourself do not forget how to use mosquitto_transport. <br><br>  Surely one could do better.  In addition, there are serious white spots in the existing implementation.  For example, support for QoS levels other than 0. Or performance issues that were not essential in the framework of the prototype under development. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we ourselves consider the current implementation of mosquitto_transport as a fully working and debugged prototype. </font><font style="vertical-align: inherit;">Which can be taken and tried. </font><font style="vertical-align: inherit;">But which, for certain, it is necessary to finish a file for any other conditions.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All the main work is done by a_transport_manager_t and one auxiliary working thread. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In mosquitto_transport, almost all the work is performed by the a_transport_manager_t agent. </font><font style="vertical-align: inherit;">It creates an instance of mosquitto, it implements all the necessary callbacks, it launches the main event loop of libmosquitto on the context of a separate working thread using </font></font><a href="https://mosquitto.org/api/files/mosquitto-h.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosquitto_loop_start ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and then it stops this cycle through </font></font><a href="https://mosquitto.org/api/files/mosquitto-h.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosquitto_loop_stop</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in a_transport_manager_t there are several tricks that can be focused on.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delegating work from one worker thread to another </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main event processing loop of libmosquitto runs on the context of a separate working thread. </font><font style="vertical-align: inherit;">This means that callbacks, such as mosquitto_log_callback, mosquitto_connect_callback, mosquitto_subscribe_callback, etc., are called on the context of this particular thread. </font><font style="vertical-align: inherit;">But from these callbacks you need to access the data of the a_transport_manager_t agent. </font><font style="vertical-align: inherit;">Which, in turn, works on another working thread (or even on several other threads in the case of adv_thread_pool-dispatcher).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not protect the a_transport_manager_t agent data with some synchronization primitives (like std :: mutex). </font><font style="vertical-align: inherit;">Instead, we send a message from the callback to the a_transport_manager_t agent. </font><font style="vertical-align: inherit;">Which will already be processed on the main working context of the agent. </font><font style="vertical-align: inherit;">Because of this, when processing a message, we don‚Äôt need to think about synchronizing access to data at all. </font></font><br><br><img src="https://habrastorage.org/webt/oo/eh/s-/ooehs-qugth4xayuq9kj4ioupay.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, for example, how it looks in code. </font><font style="vertical-align: inherit;">Implement mosquitto_message_callback:</font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transport_manager_t</span></span>::on_message_callback( mosquitto *, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * this_object, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mosquitto_message * msg ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tm = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_transport_manager_t</span></span> * &gt;(this_object); tm-&gt;m_logger-&gt;trace( <span class="hljs-string"><span class="hljs-string">"on_message, topic={}, payloadlen={}, qos={}"</span></span> <span class="hljs-string"><span class="hljs-string">", retain={}"</span></span>, msg-&gt;topic, msg-&gt;payloadlen, msg-&gt;qos, msg-&gt;retain ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_received_t</span></span> &gt;( tm-&gt;m_self_mbox, *msg ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the message_received_t message handler: </font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transport_manager_t</span></span>::on_message_received( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_received_t</span></span> &amp; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> subscribers = m_delivery_map.match( cmd.m_topic ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !subscribers.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> * s : subscribers ) s-&gt;deliver_message( cmd.m_topic, cmd.m_payload ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"message for unregistered topic, topic={}, "</span></span> <span class="hljs-string"><span class="hljs-string">"payloadlen={}"</span></span>, cmd.m_topic, cmd.m_payload.size() ); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asynchronous work with subscriptions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When an agent makes a call to subscribe (), the subscription to the corresponding MQTT-shny topic is not synchronized inside the subscribe (), but asynchronously. Initially, the a_transport_manager_t agent is sent a message subscribe_topic_t. Then, the a_transport_manager_t agent processes this message and tries to create a subscription to the MQTT broker. What can be at the moment is impossible if there is no connection with the broker now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, the call to subscribe () does not mean at all that upon leaving the subscription, the subscription has already been created and the agent will immediately begin to receive the messages published in the corresponding topic. This is usually not a problem, but remember this fact.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes it is desirable for an agent to know whether there is a subscription to a topic or there is no subscription for some reason. </font><font style="vertical-align: inherit;">For example, an agent wants to first subscribe to a topic and only then begin to publish his messages. </font><font style="vertical-align: inherit;">In this case, the agent can subscribe to special subscription_available_t, subscription_unavailable_t, and subscription_failed_t. </font><font style="vertical-align: inherit;">Let's say this is how a code for a topic subscription can look like with the receipt of a notification that a subscription was completed successfully:</font></font><br><br><pre> <code class="hljs markdown">mosqtt::topic<span class="hljs-emphasis"><span class="hljs-emphasis">_subscriber_</span></span>t<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">my_encoding_tag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>::subscribe( mqtt, "some/topic/name", [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">const so_5::mbox_t &amp; mbox</span></span>) { //  mbox       ... so<span class="hljs-emphasis"><span class="hljs-emphasis">_subscribe(mbox).event( [&amp;](mhood_</span></span>t<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mosqtt::topic_subscriber_t</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">my_encoding_tag</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>::msg<span class="hljs-emphasis"><span class="hljs-emphasis">_type&gt; cmd) { const auto msg = cmd-&gt;decode&lt;my_</span></span>type&gt;(); ... }); // ...   subscription<span class="hljs-emphasis"><span class="hljs-emphasis">_available_</span></span>t. so<span class="hljs-emphasis"><span class="hljs-emphasis">_subscribe(mbox).event( [&amp;](mhood_</span></span>t<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mosqtt::subscription_available_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> cmd) { ... }); });</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Automatic Unsubscribe from Topics </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subscriptions for MQTT-shny topics are created via calls to subscribe (). But subscriptions are automatically deleted. This happens at the expense of a small street magic, hidden in SObjectizer-ovsky mbox-ah ( </font></font><a href="https://habr.com/post/344580/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which you can create under their own, perhaps, very specific tasks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that the subscribe () method creates a special service mbox and this particular mbox is then given to the lambda function, in which the programmer signs his agent. This service mbox knows exactly how many subscriptions are made. When all subscriptions are destroyed, for example, when deregistration of an agent or manual removal of agent subscriptions, mbox understands that there are no more subscriptions and ask a_transport_manager_t to delete the subscription to the MQTT topic.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The so_define_agent () method as a classic example of setting up a multi-state agent </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually we are confronted with two opposite reactions of people who are familiar with SObjectizer. </font><font style="vertical-align: inherit;">The first ones say that everything is somehow difficult for us, agents need to be inherited from something, you need to know about some so_define_agent (), so_evt_start (), etc. </font><font style="vertical-align: inherit;">And the agents do not understand why there are some incomprehensible states. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second, by contrast, suggests that the state of the agents - this is cool. </font><font style="vertical-align: inherit;">And the presence of the so_define_agent (), so_evt_start () and so_evt_finishe () methods just simplifies the writing of agents and, especially, the proceedings with foreign agents: they say you know where to look and where to look. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, the second point of view is much closer to us. </font><font style="vertical-align: inherit;">And, I think, the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contents of a_transport_manager_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a good confirmation of this. </font><font style="vertical-align: inherit;">In particular, the so_define_agent () method immediately gives an idea of ‚Äã‚Äãwhat, how and when this agent processes:</font></font><br><br><pre> <code class="hljs ruby">void a_transport_manager_t::so_define_agent() { st_working .event( m_self_mbox, &amp;a_transport_manager_t::on_subscribe_topic ) .event( m_self_mbox, &amp;a_transport_manager_t::on_unsubscribe_topic ) .event( m_self_mbox, &amp;a_transport_manager_t::on_message_received, so_5::thread_safe ); st_disconnected .on_enter( [this] { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Everyone should be informed that connection lost. so_5::send&lt; broker_disconnected_t &gt;( m_self_mbox ); } ) .event&lt; connected_t &gt;( m_self_mbox, &amp;a_transport_manager_t::on_connected ); st_connected .on_enter( [this] { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Everyone should be informed that connection established. so_5::send&lt; broker_connected_t &gt;( m_self_mbox ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> All registered subscriptions must be restored. restore_subscriptions_on_reconnect(); } ) .on_exit( [this] { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> All subscriptions are lost. drop_subscription_statuses(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> No more pending subscriptions. m_pending_subscriptions.clear(); } ) .event&lt; disconnected_t &gt;( m_self_mbox, &amp;a_transport_manager_t::on_disconnected ) .event( m_self_mbox, &amp;a_transport_manager_t::on_subscription_result ) .event( m_self_mbox, &amp;a_transport_manager_t::on_publish_message, so_5::thread_safe ) .event( &amp;a_transport_manager_t::on_pending_subscriptions_timer ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moreover, the a_transport_manager_t agent uses a state hierarchy, albeit a very simple one: </font></font><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_working{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"working"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_disconnected{ initial_substate_of{ st_working }, <span class="hljs-string"><span class="hljs-string">"disconnected"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_connected{ substate_of{ st_working }, <span class="hljs-string"><span class="hljs-string">"connected"</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that a_transport_manager_t is not the most complicated SObjectizer agent that we had to implement. </font><font style="vertical-align: inherit;">The larger and more complex the agent, the better the availability of specialized methods so_define_agent (), so_evt_start () and so_evt_finish ().</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Learn more about serialization / deserialization of messages. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, we showed how a user must configure the serialization and deserialization of their messages. But they did not explain why it is done this way. Although this is a very fundamental question. You can even call it "the cornerstone." Therefore, you need to devote a few words to this aspect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firstly, although we did mosquitto_transport for a specific project, we wanted to make mosquitto_transport reusable for other tasks. Therefore, it was necessary to ensure that mosquitto_transport was not tied to a specific data format. So that you can transfer data even in JSON, even in XML, even in ProtoBuf, at least in some other representation. Perhaps even using several different representations in the same program.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we needed to decide on who will spend resources on serializing / deserializing messages: a_transport_manager_t agent or user application agents. I did not want to waste resources on a_transport_manager_t for these operations, since this is a direct way for a_transport_manager_t to become a bottleneck. Therefore, we chose the second way: serialization and deserialization are performed on the user's context. And the serialization is performed automatically within topic_publisher_t :: publish. But deserialization is done manually - the user himself must indicate which type he wants to get at the output when calling the incoming_message_t :: decode () method. Here is how in this example:</font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;demo::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">subscriber_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::msg_type&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> msg = cmd-&gt;decode&lt;demo::<span class="hljs-keyword"><span class="hljs-keyword">server_hello_t</span></span>&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, there is still a moment of errors that can occur when serializing / deserializing messages. For example, the message came in XML format, and we tried to parse it as JSON. We get an error and ... And the question arises: how to inform about this error and how to handle this error? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is another reason why serialization / deserialization is placed on the user's context. If, when calling publish () or decode (), an exception occurs related to a serialization / deserialization error, the user will be able to handle this exception in any way convenient for him.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on the combination of all these factors, the scheme described earlier was chosen: for each data format, the user must define a special type tag for which you need to make a partial specialization of the types encoder_t and decoder_t. </font><font style="vertical-align: inherit;">This scheme allows you to have several formats for messages in one application. </font><font style="vertical-align: inherit;">Plus, everything is resolved statically at compile time, so if serialization / deserialization is not implemented for some type or format, it will be detected in compile-time.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> General impressions of using mosquitto_transport </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's funny, but there are no special impressions from using mosquitto_transport. </font><font style="vertical-align: inherit;">It just works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the above, it is clear that the most code when working with mosquitto_transport has to be done for two things:</font></font><br><br><ul><li> -,  a_transport_manager_t    ; </li><li> -,    / ; </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, as it turned out, in practice, none of these moments caused any problems. The code for creating a_transport_manager_t happened to be written only a few times: in a couple of tests, well, in the main application for which all this was intended. Moreover, compared to other code that is needed to initialize an application (parsing command line arguments, reading configuration, creating and configuring loggers, etc., etc.), a few lines to run a_transport_manager_t are not even a drop in sea, but still quite a bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">json_dto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the code for serializing / deserializing a message has to be written quite a bit. Well, you still have to write it in one form or another, at least until reflexion is introduced in C ++.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we didn‚Äôt notice any particular laborious use of mosquitto_transport when implementing a dozen agents who communicate through the MQTT with the outside world and use about three dozen messages in their work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What left a much brighter impression was working with libmosquitto and studying the behavior of an MQTT broker in some situations through studying its source code. One can only regret that nothing more worthy than the libmosquitto and Paho came across. But that's another story ...</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, perhaps, is all that we wanted to tell about our experiment in the implementation of distribution for SObjectizer applications based on MQTT and libmosquitto. If any moments you are interested in are left behind the scenes, then ask questions - we will try to reveal the moments you are interested in in the comments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, already traditionally, we suggest trying </font></font><a href="https://sourceforge.net/projects/sobjectizer/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://github.com/eao197/so-5-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in business and sharing our impressions: almost all constructive reviews are used by us to improve SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But today I want to touch on another such aspect. The presence of distribution in the core of SObjectizer is good in places, but not very good in places (as SObjectizer-4 experience shows). The lack of distribution in the core is again good in places, but not very good in places. It seems that it turns out like in the well-known wisdom: so that you don‚Äôt choose, you will still regret it. For example, one of the most common questions addressed to SObjectizer-5: ‚ÄúWhat about your distribution?‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It‚Äôs already beginning to bother to explain the same thing for the hundredth time, so the thought creeps in: ‚ÄúIsn‚Äôt it easier to make SO-5 a mechanism for supporting distribution? ? ¬ªIn this connection, please share your comments on this topic in the comments.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do you need a distribution in SO-5? </font><font style="vertical-align: inherit;">If so, for which tasks? </font><font style="vertical-align: inherit;">Do you need to send many small messages? </font><font style="vertical-align: inherit;">Or do you transfer large blobs? </font><font style="vertical-align: inherit;">Do you need interoperability with other languages? </font><font style="vertical-align: inherit;">Or are you satisfied with the protocol / format that is supported by only one framework? </font><font style="vertical-align: inherit;">Do you need confirmation of the delivery of individual messages, automatic resend, etc.? </font><font style="vertical-align: inherit;">Any means of introspecting, monitoring and collecting statistics on traffic? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the more the women will be announced, the easier it will be for us to decide whether to make support for transparent distribution and, if so, in what form. </font><font style="vertical-align: inherit;">And maybe not easier. </font><font style="vertical-align: inherit;">But, in any case, there will be some information for thought.</font></font></div><p>Source: <a href="https://habr.com/ru/post/359212/">https://habr.com/ru/post/359212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../359200/index.html">Google accused of spying on users Safari on iPhone</a></li>
<li><a href="../359204/index.html">Build projects with dapp. Part 2: JavaScript (frontend)</a></li>
<li><a href="../359206/index.html">Caution. How to use process metrics without harming process health</a></li>
<li><a href="../359208/index.html">How to quickly and efficiently work with priorities according to the Lean Prioritization method?</a></li>
<li><a href="../359210/index.html">VPNFilter infected more than 500,000 devices worldwide</a></li>
<li><a href="../359214/index.html">Recognizing scenes in images using deep convolutional neural networks</a></li>
<li><a href="../359216/index.html">Create, configure and use your own Git-server</a></li>
<li><a href="../359218/index.html">Continuing the theme of automating the output of files on the template. Excel</a></li>
<li><a href="../359220/index.html">Economy of semiconductor production in Russia: we are analyzing one news</a></li>
<li><a href="../359222/index.html">Weak HTTPS. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>