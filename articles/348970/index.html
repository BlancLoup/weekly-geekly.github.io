<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Buffers, streams, and binary data in Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the article about buffers, streams and binary data in Node.js, the translation of which we publish, says that he understands the feeling...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Buffers, streams, and binary data in Node.js</h1><div class="post__text post__text-html js-mediator-article">  The author of the article about buffers, streams and binary data in Node.js, the translation of which we publish, says that he understands the feelings of those novice developers who have no special education, to whom all these entities seem mysterious and incomprehensible.  According to him, this may force beginners to put on the back of their efforts to deal with the internal mechanisms of Node, referring to the fact that all this is intended not for them, but only for high-class professionals, but for package developers.  Today, he is going to rectify the situation and help all those who wish to understand the essence of buffers, streams and binary data in Node.js and learn how to work with all this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/9b1/d13/9429b1d138d1b0afede11d00fe918caf.jpg" alt="image"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">About Node internal mechanisms</font> </h2><br>  Unfortunately, many Node.js manuals and books do not pay enough attention to the internal mechanisms of this platform, do not seek to explain the purpose of their existence.  As a rule, in such publications everything comes down to stories about developing web applications using ready-made packages, without going into details of their implementation.  And in some places even brazenly declares that the reader does not need to understand all this, since he most likely will never have to work, say, with objects of the Buffer class directly. <br><br>  For someone who does not plan to go on using ready-made libraries in their projects, this approach is probably justified.  But those in whom puzzles awaken curiosity, those who want to bring their own understanding of JS to a new level, should dig deeper and deal with the many internal features of Node.js, such as the <code>Buffer</code> class. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can read the following in the <a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html">official</a> Node.js <a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html">documentation</a> on the <code>Buffer</code> class: <br><br>  <i>Before the appearance of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArray</a> object in ECMAScript 2015 (ES6), JavaScript had no mechanism for reading binary data streams or for performing other operations with them.</i>  <i>The Buffer class was introduced as part of the Node.js API, which allows you to interact with arbitrary binary data streams in a context, for example, TCP streams and file system operations.</i> <br><br>  Yes, if you did not know those words that are found in this definition, then you may perceive it as an unintelligible bunch of programmer jargon.  Let us try to simplify all this a little, paraphrasing this definition, so that we can work with it, without distracting anything.  From this definition, you can make the following: <br><br>  <i>The Buffer class was introduced as part of the Node.js API, which allows working with binary data streams.</i> <br><br>  So now everything looks a little easier.  But ‚Äúclass Buffer‚Äù, ‚Äústreams‚Äù, ‚Äúbinary data‚Äù - there are still too many complicated concepts.  We will try to deal with them, starting with the last one. <br><br><h2>  <font color="#3AC1EF">What is binary data?</font> </h2><br>  You may already know that computers store and present data in binary form.  Binary data is simply a set of ones and zeros.  For example, here are five different sets of binary data made up of the values ‚Äã‚Äã‚Äú1‚Äù and ‚Äú0‚Äù: <br><br><pre> <code class="hljs">10, 01, 001, 1110, 00101011</code> </pre> <br>  Each number in a binary value, each value "1" and "0" in the set, is called a bit (Bit, Binary digIT, binary digit). <br><br>  In order to work with some data, the computer must convert this data into their binary representation.  For example, in order to save a decimal number of 12, the computer must convert it to binary form, namely, to 1100. <br><br>  How does the computer know how to make such transformations?  This is pure mathematics.  This is a binary number system that is taught in schools.  There are rules for converting decimal numbers into binary ones and the computer understands these rules. <br><br>  However, numbers are not the only data type with which we work.  We have lines, images, and even videos.  The computer knows how to represent in binary form any data types.  Take, for example, strings.  How does a computer present the string ‚ÄúL‚Äù in binary form?  In order to save a string in binary form, the computer first needs to convert the characters of this string to numbers, and then convert these numbers to their binary representation.  So, in the case of our string of one character, the computer first needs to convert ‚ÄúL‚Äù to the number that represents this character.  Let's see how this is done in javascript. <br><br>  Open the browser developer tools console and paste this code there: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"L"</span></span>.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Now press <code>Enter</code> .  What did you see?  The number 76?  This is the so-called numerical representation, or the code, or the code point of the character L. But how does the computer know which number corresponds to a certain character?  How does he know that the number 76 corresponds to the letter L? <br><br><h2>  <font color="#3AC1EF">Character sets</font> </h2><br>  Character sets are predefined rules regarding the matching of characters to their numeric codes.  There are many varieties of such rules.  For example, very popular ones are Unicode and ASCII.  JavaScript is very good at working with Unicode character sets.  In fact, it is the Unicode character table that is used in the browser to convert the L character to the number 76, and the corresponding rule is written in it. <br><br>  So, we saw how the computer represents characters as numbers.  Now let's talk about how the number 76 turns into its binary representation.  It may seem that it is enough to convert 76 from decimal to binary number system, but not everything is so simple. <br><br><h2>  <font color="#3AC1EF">Character encoding</font> </h2><br>  Just as there are rules that indicate that characters match their numeric codes, there are rules for converting numbers into their binary representation.  In particular, they relate to how many bits should be used to represent a number.  This is called character encoding. <br><br>  One of the character encoding rule sets is called UTF-8.  UTF-8 defines the rules for converting characters to bytes.  A byte is a set of eight bits - eight ones and zeros.  So, to represent the code point of any character, a set of eight ones and zeros should be used.  Let's deal with this statement. <br><br>  As already mentioned, the binary representation of the decimal number 12 is 1100. So, when UTF-8 indicates that the number 12 must be represented by an eight-bit value, this means that the computer needs to add a few bits to the left of the actual binary representation of the number 12 in order to represent it as one byte.  As a result, 12 should be stored as 00001100. And the number 76 will look like 01001100. <br><br>  This is how a computer stores strings or individual characters in binary form.  By analogy with this, the machine has special rules for converting images and video to binary form.  The point of all this is that the computer stores in binary form all data types and all this is called binary data. <br><br>  If you are interested in the subtleties of character encodings, take a look at <a href="https://www.w3.org/International/questions/qa-what-is-encoding">this material</a> , in which all this is disclosed in detail. <br><br>  Now we understand what binary data is, but what are the binary data streams we mentioned above? <br><br><h2>  <font color="#3AC1EF">Flow</font> </h2><br>  A stream in Node.js is a sequence of data moving from one place to another.  Data transfer is not instantaneous, it takes some time.  The basic idea here is that streams allow you to process large data sets in parts. <br><br>  If we recall some things from the definition of a buffer, namely, the fact that ‚Äúbinary data streams ... in the context of ... the file system‚Äù is mentioned there, we can understand that we are talking about moving binary data files, for example, when reading these files for later work with their contents.  Let's say we read the text from <code>file1.txt</code> , convert it and save it to <code>file2.txt</code> . <br><br>  And where does the buffer?  How does it work with binary data in the form of a stream? <br><br><h2>  <font color="#3AC1EF">Buffer</font> </h2><br>  Recall that a ‚Äúdata stream‚Äù is the movement of data from one place to another.  Now let us ask ourselves how exactly this data is transferred. <br><br>  Usually, data movement is performed in order to, at a minimum, read them and make them available for possible subsequent processing.  Say, in order to make a decision based on the data.  Computer processing speed is limited, so you can talk about some of the framework, representing the minimum and maximum amount of data that a process can process for a certain period of time.  So, if the data arrival rate is greater than the rate at which they are consumed, the redundant data needs somewhere to wait for its turn for processing. <br><br>  On the other hand, if the system is able to process data faster than it arrives, then a certain amount of data arriving earlier than the next session of processing a certain data packet can be started, you need to wait for some more data to arrive before all of them are sent for processing. . <br><br>  This ‚Äúwaiting area‚Äù is the buffer!  The physical representation of the buffer can be the space in the RAM, where data, when working with a stream, is temporarily accumulated, waiting for its turn, and eventually sent for processing. <br><br>  All this can be imagined as a bus station.  At some stations, buses cannot be sent until they have a certain number of passengers, or until the time of departure.  In addition, passengers can arrive at the station at different speeds.  At the same time, nobody clearly controls the arrival of passengers at the station. <br><br>  In any case, passengers who arrived before the departure of the bus must wait until the station administration decides that it is time for their bus to leave.  And passengers who arrived when the bus is already full, or when it has already departed, must wait for the next bus. <br><br>  In any case, we are talking about a kind of "waiting room".  The buffer in Node.js plays the same role.  Node.js cannot control the speed of data arrival or the time of their arrival.  He can only make decisions on whether to send data that has already arrived for processing.  If the time of sending data for processing has not yet come, Node.js will put them in the buffer - in the "waiting area". <br><br>  A typical example in which you may encounter a buffer in action is watching videos on the Internet.  If your Internet connection is fast enough, the streaming speed is high enough to immediately fill the video player's buffer and allow the player to show the video, then fill the next buffer and send it to view - and so on until the video transfer is completed.  Here is an example of a system in which data arrives faster than it is processed. <br><br>  However, if the connection does not differ at a special speed, after processing the first set of arrived data, the player will show a data download icon, or display ‚Äúbuffering‚Äù, which means that it waits for more data to arrive before the video starts.  And when the buffer is filled and the data received in it are processed, the player displays the video.  In the process of playing video, new data will arrive and wait for their turn in the buffer.  This is the case when the system is able to process data faster than it enters it. <br><br>  If the player has completed playback of the data received earlier, and the buffer has not yet been filled, the inscription ‚Äúbuffering‚Äù will appear again, the system will wait for the amount of data it needs.  In fact, in Node, working with buffers looks like this. <br><br>  From the initial definition of the buffer, you can see that when the data is in the buffer, we can work with it.  What can be done with raw binary data? <br><br><h2>  <font color="#3AC1EF">Work with buffers</font> </h2><br>  The implementation of the buffer in Node.js gives us a lot of options for working with data.  In addition, you can create buffers yourself, setting their characteristics.  So, in addition to the buffer that Node.js will automatically create during data transfer, you can create your own buffer and manipulate it.  There are different ways to create buffers.  Take a look at some of them. <br><br><pre> <code class="hljs vhdl">//     <span class="hljs-number"><span class="hljs-number">10</span></span>. //        <span class="hljs-number"><span class="hljs-number">10</span></span> . const buf1 = <span class="hljs-keyword"><span class="hljs-keyword">Buffer</span></span>.alloc(<span class="hljs-number"><span class="hljs-number">10</span></span>); //     . const buf2 = <span class="hljs-keyword"><span class="hljs-keyword">Buffer</span></span>.from(<span class="hljs-string"><span class="hljs-string">"hello buffer"</span></span>);</code> </pre> <br>  After creating the buffer, you can start working with it. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     buf1.toJSON() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      buf2.toJSON() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ { type: 'Buffer',    data: [      104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114    ]  } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  toJSON()       Unicode /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    buf1.length /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 10 buf2.length /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 12.  ,    ,   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    buf1.write("Buffer really rocks!") /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    buf1.toString() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 'Buffer rea' /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,     buf1      10,     10 </span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Now that you understand what a ‚Äúbuffer‚Äù, ‚Äústream‚Äù, and ‚Äúbinary data‚Äù are, you can open the buffer <a href="https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html">documentation</a> and experimentally experiment with all that is being said. <br>  In addition, in order to see how the buffers work in practice, read the <a href="">source code of the zlib.js library</a> .  This is one of the Node.js core libraries.  Look at how in this library buffers are used to interact with binary data streams.  Here work is being done with files representing gzip archives. <br><br>  We hope that what you learned from this material, what you found in the documentation, and learned from analyzing the code, will help raise your professional level and will be useful to you in your projects. <br><br>  <b>Dear readers!</b>  What do you think, what basic things concerning Node.js should you pay attention to novice developers? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/348970/">https://habr.com/ru/post/348970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348960/index.html">Applying the observer pattern in Redux and Mobx</a></li>
<li><a href="../348962/index.html">English version of Habr: to be or not to be?</a></li>
<li><a href="../348964/index.html">Develop isomorphic RealWorld applications with SSR and Progressive Enhancement. Part 1 - Introduction and Stack Selection</a></li>
<li><a href="../348966/index.html">Psychological portrait using neural network and ordinary camera</a></li>
<li><a href="../348968/index.html">10 IT Heroes According to Kodabra: Web Development</a></li>
<li><a href="../348974/index.html">Armor-piercing shells with a ramjet engine</a></li>
<li><a href="../348976/index.html">Ramda Thinking: Combining Functions</a></li>
<li><a href="../348980/index.html">Biz Breeze # 1. Subjectively - on the news CRM and IT business</a></li>
<li><a href="../348982/index.html">Myths about the infrastructure in the cloud: what kind of illiteracy we face in Russia every day</a></li>
<li><a href="../348984/index.html">I wrote a mobile application - I want a patent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>