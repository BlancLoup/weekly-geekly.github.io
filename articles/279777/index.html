<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Gentle" balancing between multiple providers on the office gateway</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the configuration of a Linux gateway for balancing traffic between channels of different providers. 


 The result achieved in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Gentle" balancing between multiple providers on the office gateway</h1><div class="post__text post__text-html js-mediator-article">  This article describes the configuration of a Linux gateway for balancing traffic between channels of different providers. <br><img src="https://habrastorage.org/files/545/523/90d/54552390dafe441c8da3ecbaccf82eea.png"><img src="https://habrastorage.org/files/86a/115/f9b/86a115f9bcbe4191bb68bae295f5b271.png"><br><br>  The result achieved in this manual differs from the result of <a href="https://www.opennet.ru/docs/RUS/LARTC/x348.html">such manuals</a> : the same external IP address is used for each client, which eliminates problems with Internet services that are not ready to change the client's IP address in one session. <br><a name="habracut"></a><br><h4>  Problems </h4><br>  For an ordinary consumer who does not have any of his own block of addresses and does not participate in the exchange of routes at the level of telecom operators, access to the Internet is possible only from those addresses that each Internet provider provides for each channel.  This means that any connection of several channels from ‚Äúdomestic‚Äù Internet providers to a single node requires not only a choice between different upstream gateways, but also a choice of the correct outgoing address for communicating with them. <br><br>  This state of affairs runs counter to how the standard routing mechanism works.  In general, the route in the routing table depends only on the destination address and does not change the sender's address.  Therefore, the first task that needs to be solved is to organize the correspondence of the sending interface, the gateway and the outgoing address when forwarding packets from clients. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second problem to be solved is how to intelligently distribute the load from clients. <br><br>  Balancing using multipath routes (as in the link at the beginning of the article) is carried out at the destination address and does not always look like an attractive solution.  Where it would be worthwhile to have the same external address, the client may have a different session in one session and vice versa - when accessing popular resources, all clients will use one common channel. <br><br>  Balancing at the sender address can be a compromise between compatibility and granularity of distribution.  Each computer in the local network will always have the same external address and with a considerable number of computers in the network we will get a tolerable load distribution across the channels.  Such a division can be achieved if we form hashes from local addresses, divide the entire space of hashes in proportion to the weights of the channels and use the value of this hash to select the channel. <br><br><h4>  Instruments </h4><br>  In the Linux kernel, it is possible to use several different tables at the same time, depending on what criteria the package meets.  Often this mechanism is called policy based routing (PBR).  This mechanism is controlled through the iproute2 toolkit. <br><br>  Somewhat simplifying the formulation of the problem, one can say: all that is required of us to distinguish between routes, interfaces and outgoing addresses is to create for each provider an additional routing table that looks as if this channel of this provider were the only one.  Then you need to add rules (the same routing policies) that trigger the appropriate routing table for the corresponding traffic. <br><br>  As for balancing by sender, for this you can use the kernel network filter - netfilter (iptables).  With the HMARK action, we will mark the packet with a hash of the address.  According to the fwmark criterion in the routing rules (ip rule command), we will forward the packet to the desired routing table.  iproute2 and iptables play well in pairs here. <br><br><h4>  Example </h4><br>  As an example, I‚Äôll take a Debian based gateway that provides Internet access through three channels from two different providers.  Such an example was chosen specifically, as it considers a delicate situation when the same upstream gateway of one provider is accessible through 2 different wires.  The described configuration will have a similar appearance in all other debian-like operating systems, including Ubuntu. <br><br>  The gateway has 4 working interfaces: <br><table><tbody><tr><th>  Int. </th><th>  Description </th><th>  Capacity </th><th>  Address </th><th>  Gateway </th></tr><tr><td>  eth0 </td><td>  the local network </td><td></td><td>  10.0.0.1/16 </td><td>  - </td></tr><tr><td>  eth1 </td><td>  first channel of the first provider </td><td>  100 Mbps </td><td>  100.1.1.92/24 </td><td>  100.1.1.1 </td></tr><tr><td>  eth2 </td><td>  the only channel from the second provider </td><td>  80 Mbps </td><td>  200.2.2.22/24 </td><td>  200.2.2.1 </td></tr><tr><td>  eth3 </td><td>  second channel of the first provider </td><td>  100 Mbps </td><td>  100.1.1.93/24 </td><td>  100.1.1.1 </td></tr></tbody></table>  Each channel is connected via a normal ethernet with a static address. <br><br><h5>  Initial state </h5><br>  Suppose we have already configured access through one channel.  The / etc / network / interfaces file is: <br><div class="spoiler">  <b class="spoiler_title">/etc/network.interfaces, 3 interfaces, 1 main</b> <div class="spoiler_text"><code># This file describes the network interfaces available on your system <br> # and how to activate them. For more information, see interfaces(5). <br> <br> source /etc/network/interfaces.d/* <br> <br> # The loopback network interface <br> auto lo <br> iface lo inet loopback <br> <br> auto eth0 <br> iface eth0 inet static <br> address 10.0.0.1 <br> netmask 255.255.0.0 <br> <br> auto eth1 <br> iface eth1 inet static <br> address 100.1.1.92 <br> gateway 100.1.1.1 <br> netmask 255.255.255.0 <br> <br> auto eth2 <br> iface eth2 inet static <br> address 200.2.2.22 <br> # gateway 200.2.2.1 #correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br> <br> auto eth3 <br> iface eth3 inet dhcp <br> address 100.1.1.93 <br> # gateway 100.1.1.1 # correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br></code> </div></div><br>  As you can see, only one of the interfaces has a default route. <br><br>  In /etc/sysctl.conf, the value of net.ipv4.ip_forward is set to 1. The iptables-persistent package is installed and the contents of the /etc/iptables/rules.v4 file are: <br><div class="spoiler">  <b class="spoiler_title">/etc/iptables/rules.v4, NAT rules and nothing more</b> <div class="spoiler_text"> <code># Generated by iptables-save v1.4.21 on Tue Feb 30 13:14:06 2016 <br> *mangle <br> :PREROUTING ACCEPT [0:0] <br> :INPUT ACCEPT [0:0] <br> :FORWARD ACCEPT [0:0] <br> :OUTPUT ACCEPT [0:0] <br> :POSTROUTING ACCEPT [0:0] <br> COMMIT <br> # Completed on Tue Feb 30 13:14:06 2016 <br> # Generated by iptables-save v1.4.21 on Tue Feb 30 13:14:06 2016 <br> *filter <br> :INPUT ACCEPT [0:0] <br> :FORWARD ACCEPT [0:0] <br> :OUTPUT ACCEPT [0:0] <br> -A FORWARD -s 10.0.0.0/16 -i eth0 -j ACCEPT # Proposed by ValdikSS due to security clues <br> -A FORWARD -d 10.0.0.0/16 -o eth0 -j ACCEPT # --//-- <br> -A FORWARD -j DROP # --//-- <br> COMMIT <br> # Completed on Tue Feb 30 13:14:06 2016 <br> # Generated by iptables-save v1.4.21 on Tue Feb 30 13:14:06 2016 <br> *nat <br> :PREROUTING ACCEPT [0:0] <br> :INPUT ACCEPT [0:0] <br> :OUTPUT ACCEPT [0:0] <br> :POSTROUTING ACCEPT [0:0] <br> -A POSTROUTING -s 10.0.0.0/8 -o eth1 -j MASQUERADE <br> -A POSTROUTING -s 10.0.0.0/8 -o eth2 -j MASQUERADE <br> -A POSTROUTING -s 10.0.0.0/8 -o eth3 -j MASQUERADE <br> COMMIT <br> # Completed on Tue Feb 30 13:14:06 2016 <br></code> </div></div><br>  Only three rules for address translation from packets originating through three external interfaces.  It does not matter to use a masquerade, but I stopped at it.  Since the gateway is currently configured on only one interface, only the first rule actually works. <br><br><h5>  Routing rules </h5><br>  Now the most difficult: we will solve the first problem of matching addresses, interfaces and gateways.  We will prepare three additional routing tables that we will use for different providers. <br>  Let's start with the optional step - in order not to mention the routing tables everywhere by their number, let's get them in the file of correspondences of the numbers and names of the tables / etc / iproute2 / rt_tables: <br><div class="spoiler">  <b class="spoiler_title">/ etc / iproute2 / rt_tables</b> <div class="spoiler_text"> <code># <br> # reserved values <br> # <br> 255 local <br> 254 main <br> 253 default <br> 0 unspec <br> # <br> # local <br> # <br> #1 inr.ruhep <br> <br> 10 Provider1_Cable1 <br> 20 Provider2 <br> 30 Provider1_Cable2 <br></code> </div></div><br>  So far, quite simple.  Now fill these tables with routes.  Let each table for each external channel contain all routes of all interfaces, except routes through other external interfaces.  When picking up each external interface, add a rule that instructs to use the specified additional routing table if the sender address is equal to the address on this interface. <br><div class="spoiler">  <b class="spoiler_title">/ etc / network / interfaces: routes in additional tables and routing rules to the source address</b> <div class="spoiler_text"> <code># This file describes the network interfaces available on your system <br> # and how to activate them. For more information, see interfaces(5). <br> <br> source /etc/network/interfaces.d/* <br> <br> # The loopback network interface <br> auto lo <br> iface lo inet loopback <br> up ip route add 127.0.0.0/8 dev lo table Provider1_Cable1 <br> up ip route add 127.0.0.0/8 dev lo table Provider2 <br> up ip route add 127.0.0.0/8 dev lo table Provider1_Cable2 <br> <br> auto eth0 <br> iface eth0 inet static <br> address 10.0.0.1 <br> netmask 255.255.0.0 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider1_Cable1 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider2 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider1_Cable2 <br> <br> auto eth1 <br> iface eth1 inet static <br> address 100.1.1.92 <br> gateway 100.1.1.1 <br> netmask 255.255.255.0 <br> up ip route add 100.1.1.0/24 dev eth1 table Provider1_Cable1 <br> up ip route add default dev eth1 via 100.1.1.1 table Provider1_Cable1 <br> up ip rule add from 100.1.1.92 table Provider1_Cable1 <br> <br> auto eth2 <br> iface eth2 inet static <br> address 200.2.2.22 <br> # gateway 200.2.2.1 #correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br> up ip route add 200.2.2.22/24 dev eth2 table Provider2 <br> up ip route add default dev eth2 via 200.2.2.1 table Provider2 <br> up ip rule add from 200.2.2.22 table Provider2 <br> <br> auto eth3 <br> iface eth3 inet dhcp <br> address 100.1.1.93 <br> # gateway 100.1.1.1 # correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br> up ip route add 100.1.1.0/24 dev eth3 table Provider1_Cable2 <br> up ip route add default dev eth3 via 100.1.1.1 table Provider1_Cable2 <br> up ip rule add from 100.1.1.93 table Provider1_Cable2 <br></code> </div></div><br>  Note: the main routing table still gets only one gateway - all the gateway directives, except for one, are commented out. <br>  Here, additional routes and rules are decorated with up directives that simply execute the command when raising the interface.  Commands for adding routes and rules are grouped under the interfaces through which they can be implemented - this is most clearly seen in the example of the lo interface. <br><br>  After restarting the network, we can notice how the output of the list of rules in the ip rule list command has changed: <br><div class="spoiler">  <b class="spoiler_title">ip rule list</b> <div class="spoiler_text"> <code># ip ru li <br> 0: from all lookup local <br> 32763: from 100.1.1.93 lookup Provider1_Cable2 <br> 32764: from 200.2.2.22 lookup Provider2 <br> 32765: from 100.1.1.92 lookup Provider1_Cable1 <br> 32766: from all lookup main <br> 32767: from all lookup default <br></code> </div></div><br>  The corresponding table can be viewed with the command ‚Äúip ro li table XXX‚Äù. <br><br>  Already in this position, the server is ready to use all interfaces at once.  We will verify this by trying to use all the interfaces one by one and checking the address observed by the outside: <br><div class="spoiler">  <b class="spoiler_title">checking external addresses through different interfaces</b> <div class="spoiler_text"> <code># curl --interface 100.1.1.92 http://canihazip.com/s ; echo <br> 100.1.1.92 <br> # curl --interface 100.1.1.93 http://canihazip.com/s ; echo <br> 100.1.1.93 <br> # curl --interface 200.2.2.22 http://canihazip.com/s ; echo <br> 200.2.2.22 <br></code> </div></div><br>  If the external interfaces have real ‚Äúwhite‚Äù addresses, then you can try to join the server using any address ‚Äî the server will communicate through each of them through the correct channel and the correct provider.  If so, then the most difficult thing behind. <br><br><h5>  Balancing </h5><br>  In my example there are two channels of 100 Mb / s and one 80 Mb / s.  In order to divide the load equally between them, it is enough for me to divide it into 14 parts and send 5 parts to two 100-megabit channels and 4 parts to an 80-megabit channel.  Add a rule to the firewall, marking the packet with numbers from 10,000 to 10,013, depending on the outgoing IP address: <br> <code># iptables -t mangle -A PREROUTING -s 10.0.0.0/16 -j HMARK --hmark-tuple src --hmark-offset 10000 --hmark-mod 14 --hmark-rnd 0xfeedcafe <br> # /etc/init.d/netfilter-persistent save <br></code> <br>  Simple enough.  Parameters and values ‚Äã‚Äãspeak for themselves.  It now remains to send traffic, marked by different numbers, through different interfaces.  As a result, / etc / network / interfaces takes the form: <br><div class="spoiler">  <b class="spoiler_title">/ etc / network / interfaces final</b> <div class="spoiler_text"> <code># This file describes the network interfaces available on your system <br> # and how to activate them. For more information, see interfaces(5). <br> <br> source /etc/network/interfaces.d/* <br> <br> # The loopback network interface <br> auto lo <br> iface lo inet loopback <br> up ip route add 127.0.0.0/8 dev lo table Provider1_Cable1 <br> up ip route add 127.0.0.0/8 dev lo table Provider2 <br> up ip route add 127.0.0.0/8 dev lo table Provider1_Cable2 <br> <br> auto eth0 <br> iface eth0 inet static <br> address 10.0.0.1 <br> netmask 255.255.0.0 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider1_Cable1 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider2 <br> up ip route add 10.0.0.0/16 dev eth0 table Provider1_Cable2 <br> <br> auto eth1 <br> iface eth1 inet static <br> address 100.1.1.92 <br> gateway 100.1.1.1 <br> netmask 255.255.255.0 <br> up ip route add 100.1.1.0/24 dev eth1 table Provider1_Cable1 <br> up ip route add default dev eth1 via 100.1.1.1 table Provider1_Cable1 <br> up ip rule add from 100.1.1.92 table Provider1_Cable1 <br> up ip rule add from 10.0.0.0/8 fwmark 10000 table Provider1_Cable1 <br> up ip rule add from 10.0.0.0/8 fwmark 10003 table Provider1_Cable1 <br> up ip rule add from 10.0.0.0/8 fwmark 10006 table Provider1_Cable1 <br> up ip rule add from 10.0.0.0/8 fwmark 10009 table Provider1_Cable1 <br> up ip rule add from 10.0.0.0/8 fwmark 10012 table Provider1_Cable1 <br> <br> auto eth2 <br> iface eth2 inet static <br> address 200.2.2.22 <br> # gateway 200.2.2.1 #correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br> up ip route add 200.2.2.22/24 dev eth2 table Provider2 <br> up ip route add default dev eth2 via 200.2.2.1 table Provider2 <br> up ip rule add from 200.2.2.22 table Provider2 <br> up ip rule add from 10.0.0.0/8 fwmark 10002 table Provider2 <br> up ip rule add from 10.0.0.0/8 fwmark 10005 table Provider2 <br> up ip rule add from 10.0.0.0/8 fwmark 10008 table Provider2 <br> up ip rule add from 10.0.0.0/8 fwmark 10011 table Provider2 <br> <br> auto eth3 <br> iface eth3 inet dhcp <br> address 100.1.1.93 <br> # gateway 100.1.1.1 # correct gateway value, but commented out to avoid routing conflicts <br> netmask 255.255.255.0 <br> up ip route add 100.1.1.0/24 dev eth3 table Provider1_Cable2 <br> up ip route add default dev eth3 via 100.1.1.1 table Provider1_Cable2 <br> up ip rule add from 100.1.1.93 table Provider1_Cable2 <br> up ip rule add from 10.0.0.0/8 fwmark 10001 table Provider1_Cable2 <br> up ip rule add from 10.0.0.0/8 fwmark 10004 table Provider1_Cable2 <br> up ip rule add from 10.0.0.0/8 fwmark 10007 table Provider1_Cable2 <br> up ip rule add from 10.0.0.0/8 fwmark 10010 table Provider1_Cable2 <br> up ip rule add from 10.0.0.0/8 fwmark 10013 table Provider1_Cable2 <br></code> </div></div><br>  For each interface, we added lines like ‚Äúup ip rule add from 10.0.0.0/8 fwmark MARK table TABLE‚Äù.  Each of them sends packets with a corresponding marking for routing to the specified table.  In my example, numbers are intermixed between interfaces for the sake of uniformity. <br><br><h4>  Everything! </h4><br>  Optionally, scripts can be added to such a routing scheme, detecting the drop in one of the channels and rebalancing the load with this in mind.  However, implementation details depend on taste and it is better to leave it to the reader. </div><p>Source: <a href="https://habr.com/ru/post/279777/">https://habr.com/ru/post/279777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279765/index.html">Free Developer Package: Visual Studio Dev Essentials</a></li>
<li><a href="../279767/index.html">Webinar "Parallels VDI Compliance with Information Security Regulators"</a></li>
<li><a href="../279769/index.html">Habrostatistika, part 2 - refutation with graphs</a></li>
<li><a href="../279771/index.html">MoscowJS # 29 (March 31, 2016)</a></li>
<li><a href="../279775/index.html">Report from the conference Data Fest</a></li>
<li><a href="../279779/index.html">Case design: Coral Order e-commerce website</a></li>
<li><a href="../279781/index.html">Reg.ru fell along with all its services</a></li>
<li><a href="../279785/index.html">Make an autonomous photo booth on raspberry pi</a></li>
<li><a href="../279787/index.html">The main threats to site security</a></li>
<li><a href="../279789/index.html">Game development digest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>