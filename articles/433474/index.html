<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pylint from the inside. How he does it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Different assistants in writing a cool code just surround us, linters, tipchekery, utilities to search for vulnerabilities, all with us. We are accust...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pylint from the inside. How he does it</h1><div class="post__text post__text-html js-mediator-article">  Different assistants in writing a cool code just surround us, linters, tipchekery, utilities to search for vulnerabilities, all with us.  We are accustomed to and use without going into details, like a ‚Äúblack box‚Äù.  For example, few people understand the principles of Pylint - one of these indispensable tools for optimizing and improving code in Python. <br><br>  But <strong>Maxim Mazaev</strong> knows how important it is to understand his tools, and he told us at <a href="https://conf.python.ru/">Moscow Python Conf ++</a> .  Using real examples, he showed how knowledge of the internal structure of Pylint and its plug-ins helped reduce the time for code review, improve the quality of the code, and generally improve the efficiency of development.  Below is a transcript instruction. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  Why do we need Pylint? <br></h2><br>  If you already use it, the question may arise: ‚ÄúWhy know what is inside Pylint, how can this knowledge help?‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually, developers write code, run a linter, get messages about what to improve, how to make the code more beautiful, and make the proposed changes.  Now it is more convenient to read the code and it is not a shame to show colleagues. <br><br>  For a long time, in CIAN, this was exactly how they worked with Pylint, with a few additions: they changed configurations, removed extra rules, increased the maximum string length. <br><br>  But at some point we ran into a problem, to solve which, I had to dig deep inside Pylint and figure out how it works.  What is the problem and how it was solved, read on. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Maxim Mazaev ( <a href="https://habr.com/users/backslash/" class="user_link">backslash</a> ), 5 years in development, works in CIAN.  Examines deep Python, asynchrony and functional programming. <br><br><h2>  About CIAN <br></h2><br>  The majority believes that CIAN is a real estate agency with realtors and are very surprised when they find out that instead of realtors, we have programmers working for us. <br><br>  We are a technical company, in which there are no realtors, but there are a lot of programmers. <br><br><ul><li>  1 million unique users per day. </li><li>  The largest bulletin board on selling and renting real estate in Moscow and St. Petersburg.  In 2018, we reached the federal level and work across Russia. </li><li>  Nearly 100 people in the development team, of whom 30 write Python code every day. </li></ul><br>  Every day, hundreds and thousands of lines of new code go into production.  The requirements for code are quite simple: <br><br><ul><li>  Code of decent quality. </li><li>  Stylistic uniformity.  All developers should write approximately similar code, without a ‚Äúvinaigrette‚Äù in the repositories. </li></ul><br>  To achieve this, of course, need a code review. <br><br><h2>  Code review <br></h2><br>  Code review in CIAN takes place in two stages: <br><br><ol><li>  The first stage is <strong>automated</strong> .  A Jenkins robot runs tests, runs Pylint and checks API consistency between microservices, since we use microservices.  If at this stage the tests fail or the linter shows something strange, then this is the reason for rejecting the pull request and sending the code for revision. <br></li><li>  If the first stage is successful, then the second stage comes - approval from <strong>two</strong> <strong>developers</strong> .  They can evaluate how good the code is in terms of business logic, approve a pull request, or return the code for revision. <br></li></ol><br><h3><br>  Problems code review <br></h3><br>  Pull request may fail code review due to: <br><br><ul><li>  errors in business logic, when the developer is ineffective or incorrectly solved the problem; </li><li>  problems with code style. </li></ul><br>  What could be the problems with the style if the linter checks the code? <br><br>  Everyone who writes in Python knows that there is a guide to writing <strong>PEP-8</strong> code.  Like any standard, PEP-8 is quite common and for us, as developers, this is not enough.  The standard wants to be specified in some places, and expanded in others. <br><br>  Therefore, we came up with our own internal arrangements on how the code should look and work, and called them <strong>"Decline Cian Proposals"</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  ‚ÄúDecline Cian Proposals‚Äù is a set of rules, now there are about 15. Each of these rules is the basis for a pull request to be rejected and sent for revision. <br><br><h3>  What prevents productive code review? <br></h3><br><blockquote>  There is one problem with our internal rules - the linter does not know about them, and it would be strange if he knew - they are internal. <br></blockquote>  A developer who performs a task should always remember and keep the rules in mind.  If he forgets one of the rules, then in the process of code review, the reviewers will point out the problem, the task will be sent for revision and the release time of the task will increase.  After completion and correction of errors, the verifiers need to remember what was in the task, switch the context. <br><br>  It creates a problem for both the developer and the verifiers.  As a result, the speed of code review is critically reduced.  Instead of analyzing the logic of the code, the verifiers begin to analyze the visual style, that is, they do the work of the linter: they scan the code line by line and look for inconsistencies in the indents, in the import format. <br><br>  We would like to get rid of this problem. <br><br><h2>  And do not write us your linter? <br></h2><br>  It seems that the problem will be solved by a tool that will know about all internal agreements and will be able to check the code for their execution.  It turns out we need your linter? <br><br>  Not really.  The idea is stupid because we already use Pylint.  This is a convenient linter, it is pleasant to developers and is built into all processes: it runs in Jenkins, generates beautiful reports that are completely satisfied and come in the form of comments in pull request.  Everything is fine, the <strong>second linter is not needed</strong> . <br><br>  So how to solve the problem if we don‚Äôt want to write our own linter? <br><br><h2>  Write a plugin for Pylint <br></h2><br>  For Pylint, you can write plugins, they are called checkers.  Under each internal rule, you can write your checker, which will check it. <br><br>  Consider two examples of such checkers. <br><br><h3>  Example number 1 <br></h3><br>  At some point, it was found that the code contains a lot of comments like ‚ÄúTODO‚Äù - promises to refactor, delete unnecessary code or rewrite it nicely, but not now, but later.  There is a problem with such comments - they absolutely do not oblige to anything. <br><br><h4>  Problem <br></h4><br>  The developer wrote a promise, exhaled and went with peace of mind to engage in the next task. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  Eventually: <br><br><ul><li>  comments with promises hang for years and are not fulfilled; </li><li>  the code is littered; </li><li>  technical debt accumulated over the years. </li></ul><br>  For example, the developer promised to remove something 3 years ago after a successful release, but did the release happen in 3 years?  It is possible that yes.  Does code delete in this case?  This is a big question, but most likely not. <br><br><h4>  Solution: write your checker for Pylint <br></h4><br>  It is impossible to forbid developers to write such comments, but you can make additional work: create a task to refine the promise in the tracker.  Then we will not forget about it. <br><br>  We need to find all comments of the form TODO and make sure that in each of them there is a link to the task in Jira.  Let's write. <br><br>  What is a checker in terms of Pylint?  This is a class that inherits from the base class of the checker and implements a certain interface. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  In our case, this is the <strong>IRawChecker</strong> - the so-called ‚Äúraw‚Äù checker. <br><br>  A raw checker is iterated over file lines and can perform a specific action on a line.  In our case, in each line, the checker will look for something similar to a comment and a link to the task. <br><br>  For the checker, you need to define a list of messages that he will issue: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  The message has: <br><br><ul><li>  the description is short and long; </li><li>  checker code and a short mnemonic name that defines what the message is. </li></ul><br>  The message code is ‚ÄúC1234‚Äù, in which: <br><br><ul><li>  The first letter is clearly standardized for different types of messages: <strong>[C]</strong> onvention;  <strong>[W]</strong> arning;  <strong>[E]</strong> yy;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactoring.  Thanks to the letter, the report immediately shows what is happening: a reminder of the agreements or fatal problems that need to be urgently addressed. </li><li>  4 random numbers unique within Pylint. </li></ul><br>  The code is needed to disable the check if it becomes unnecessary.  You can write Pylint: disable and a short alphanumeric code or mnemonic name: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  The authors of Pylint recommend to abandon the alphanumeric code and use the mnemonic, it is more visual. <br><br>  The next step is to define a method called <strong>process_module</strong> . <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  The name is very important.  The method should be called that way, because then Pylint will call it. <br><br>  The <strong>node</strong> parameter is passed to the module.  In this case, no matter what it is or what type it is, it is only important to remember that the node has a <strong>stream</strong> method that returns a file line by line. <br><br>  You can go through the file and check the presence of comments and links to the task for each line.  If there is a comment, but there is no link, then throw out a warning like <strong>'issue-code-in-todo'</strong> with a checker code and line number.  The algorithm is quite simple. <br><br>  Register the checker so that Pylint knows about it.  This is done by the <strong>register</strong> function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  An instance of the Pylint comes into the function. </li><li>  It calls the register_checker method. </li><li>  We pass the checker itself to the method. </li></ul><br>  <strong>Important point: the</strong> checker module must be in PYTHONPATH, so that Pylint can import it later. <br><br>  The registered checker is checked with a test file with comments without reference to the tasks. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker ‚Ä¶</span></span></code> </pre><br>  For the test, we launch Pylint, transfer the module to it, transfer the checker using the <strong>load-plugins</strong> parameter, and launch two phases inside the linter. <br><br><h4>  Phase 1. Initialization of plugins <br></h4><br><ul><li>  All modules where there are plugins are imported.  Pylint has internal checkers and external ones.  They all come together and imported. </li><li>  Register - <strong>module.register (self)</strong> .  For each checker, the register function is called, to which the Pylint instance is passed. </li><li>  Checks are performed: for the validity of the parameters, for the presence of messages, options and reports in the correct format. </li></ul><br><h4>  Phase 2. Disassemble the checker pool <br></h4><br>  After phase 1 there is a whole list of checkers of different types: <br><br><ul><li>  AST checker; </li><li>  Raw checker; </li><li>  Token checker. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  From the list we select those that belong to the interface of the ‚Äúraw‚Äù checker: we look at which checkers implement the IRawChecker interface and take them for ourselves. <br><br>  For each selected checker, call the method <strong>checker.process_module (module)</strong> , and run the check. <br><br><h4>  Result <br></h4><br>  Run the checker on the test file again: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  A message appears stating that there is a comment with TODO and no link to the task. <br><br>  The problem is solved and now in the process of code review, developers do not need to scan the code with their eyes, find comments, write a reminder to the code author that there is an agreement and it is desirable to leave a link.  Everything happens is automated and code review runs a little faster. <br><br><h3>  Example No. 2. keyword-arguments <br></h3><br>  There are functions that take positional arguments.  If there are a lot of arguments, then when they call the function it is not very clear where the argument is and why it is needed. <br><br><h4>  Problem <br></h4><br>  For example, we have a function: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  In the code there is <strong>sale</strong> and <strong>True</strong> and it is not clear what they mean.  It is much more convenient when functions with many arguments would be called only with named arguments: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  This is a good code in which it is immediately clear where a parameter is and we will not confuse their sequence.  Let's try to write a checker that checks such cases. <br><br>  The ‚Äúraw‚Äù checker used in the previous example is very difficult to write for such a case.  You can add super-complex regular expressions, but such code is hard to read.  It‚Äôs good that Pylint makes it possible to write another type of checker based on the abstract <strong>AST</strong> syntax tree, and we‚Äôll use it. <br><br><h4>  Lyrical digression about AST <br></h4><br>  An AST or abstract syntax tree is a representation of code in the form of a tree, where the vertex is the operands, and the leaves are the operators. <br><br>  For example, a function call, where there is one positional argument and two named, is transformed into an abstract tree: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  There is a vertex with a <strong>Call</strong> type and it has: <br><br><ul><li>  function attributes with the name func; </li><li>  a list of positional args arguments, where there is a node with type Const and a value of 112; </li><li>  list of named arguments. </li></ul><br>  The challenge in this case is: <br><br><ul><li>  Find in the module all nodes with type Call (function call). </li><li>  Count the total number of arguments that the function takes. </li><li>  If there are more than 2 arguments, then make sure that there are no positional arguments in the node. </li><li>  If there are positional arguments, then show a warning. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ ‚Ä¶ ]))]</code> </pre><br>  From the point of view of Pylint, an AST-based checker is a class that inherits from the basic checker class and implements the <strong>IAstroidChecker</strong> interface: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  As in the first example, in the message list the checker description, message code, short mnemonic name is indicated: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  The next step is to define the <strong>visit_call</strong> method: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> ‚Ä¶</span></span></code> </pre><br>  The method need not be so called.  The most important thing in it is the prefix visit_, and then comes the name of the vertex that interests us, with a small letter. <br><br><ul><li>  The AST parser walks through the tree and for each vertex it looks to see if the check_ interface has a visit_ &lt;Name&gt; interface. </li><li>  If yes, then cause it. </li><li>  Recursively passes through all her children. </li><li>  When leaving the node, calls the method le_ve_ &lt;Name&gt;. </li></ul><br>  In this example, the visit_call method will receive a node with a Call type as input and see if it has more than two arguments and positional arguments are present to throw out the warning and pass the code and the node itself. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  We register the checker, as in the previous example: we transfer the Pylint instance, call the register_checker, passing the checker itself, and start it. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  This is an example of a test function call, where there are 3 arguments and only one of them is named: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker ‚Ä¶</code> </pre><br>  This is a function that is potentially called wrong from our point of view.  Launch Pylint. <br><br>  Phase 1 initialization of plug-ins is completely repeated, as in the previous example. <br><br><h4>  Phase 2. Analysis of the module on the AST <br></h4><br>  Code understands AST-tree.  Parsing is done by <a href="https://github.com/PyCQA/astroid">the Astroid library</a> . <br><br><h4>  Why Astroid, not AST (stdlib) <br></h4><br>  Astroid inside itself does not use the standard Python AST module, but the <strong>typed AST parser typed_ast</strong> , characterized in that it supports the TIPs from the PEP 484. <strong>Typed_ast</strong> is a branch of the AST fork, which develops in parallel.  Interestingly, there are the same bugs that are in AST, and are repaired in parallel. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Previously, Astroid used a standard AST module in which it was possible to encounter the problem of using the tiepts defined in the comments used in the second Python.  If you check such code through Pylint, then up to a certain point, it cursed unused imports, because the imported class Entity is only present in the comment. <br><br><blockquote>  At some point on GitHub, Guido Van Rossum came to Astroid and said: ‚ÄúGuys, you have a Pylint that swears at such cases, and we have a typed AST parser that supports this all.  Let's be friends!" <br></blockquote><br>  Work has begun to boil!  2 years have passed, this spring, Pylint has already switched to a typed AST parser and stopped swearing at such things.  Tayphint imports are no longer marked as unused. <br><br>  Astroid uses an AST parser to parse the code into a tree, and then does some interesting things when building it.  For example, if you use <strong>import *</strong> , it will import everything by star, and add to locals to prevent errors with unused imports. <br><br>  <strong>Transform plugins</strong> are used in cases when there are some complex models based on meta-classes, when all attributes are generated dynamically.  In this case, Astroid is very difficult to understand what is meant.  When checking, Pylint will swear that there is no such attribute in the models when it is accessed, and using the Transform plugins you can solve the problem: <br><br><ul><li>  Help Astroid modify the abstract tree and understand the dynamic nature of Python. </li><li>  Supplement the AST with useful information. </li></ul><br>  A typical example is <strong>pylint-django</strong> .  When working with complex django-models, the linter often swears at unknown attributes.  Pylint-django just solves this problem. <br><br><h4>  Phase 3. Disassemble the checker pool <br></h4><br>  We return to the checker.  Again we have a list of checkers, of which we find those that implement the AST checker interface. <br><br><h4>  Phase 4. Disassemble checkers by node type. <br></h4><br>  Then we find methods for each checker, they can be of two types: <br><br><ul><li>  visit_ &lt;node name&gt; </li><li>  l_ &lt;node name&gt;. </li></ul><br>  It would be nice while walking on a tree to know for which node which checkers you need to call.  Therefore, they understand the dictionary, where the key is the name of the node, the value is a list of those checkers who are interested in entering this node. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  The same with leave-methods: a key in the form of a node name, a list of checkers who are interested in the fact of leaving the node. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Launch Pylint.  It shows a warning that we have a function with more than two arguments and a positional argument in it: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  Problem solved.  Now, code review programmers do not need to read the arguments of the function; the linker will do this for them.  <strong>We saved our time</strong> , time for code review and tasks are faster in production. <br><br><h2>  And write the tests? <br></h2><br>  Pylint allows unit checkers to be tested and is very simple.  From the point of view of the linter, the test-checker looks like a class that inherits from the abstract <strong>CheckerTestCase</strong> .  It is necessary to specify the checker that is checked. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  Step 1. Create a test AST node from the part of the code that we check. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  Step 2. We check that the checker, going to the node, either throws, or does not throw the corresponding message: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  There is another type of checker called <strong>TokenChecker</strong> .  It works on the principle of a lexical analyzer.  In Python, there is a <strong>tokenize</strong> module that does the work of a lexical scanner and breaks the code into a list of tokens.  It might look something like this: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  The names of variables, functions, and keywords become tokens of the type NAME, and the delimiters, parentheses, and colons become tokens of the type OP.  In addition, there are separate tokens for indentation, line feed and reverse translation. <br><br>  How Pylint works with TokenChecker: <br><br><ul><li>  The module under test is tokenized. </li><li>  A huge list of tokens is passed to all checkers that implement ITokenChecker and the <strong>process_tokens</strong> (tokens) method is <strong>called</strong> . </li></ul><br>  We have not found the use of TokenChecker, but there are some examples that Pylint itself uses: <br><br><ul><li>  <strong>Spell checker</strong>  For example, you can take all text-type tokens and look at lexical literacy, check words from stop-word lists, etc. </li><li>  <strong>Check indents</strong> , spaces. </li><li>  <strong>Work with strings</strong> .  For example, you can verify that Unicode literals are not used in Python 3 or make sure that only ASCI characters are present in the byte string. </li></ul><br><h2>  findings <br></h2><br>  We had a problem with code review.  The developers did the work of the linter, wasting their time on meaningless scanning of the code and informing the author about errors.  With Pylint, we: <br><br><ul><li>  We transferred the routine checks to the linter, implemented internal agreements in it. </li><li>  Increased speed and quality code review. </li><li>  Reduced the number of rejected pull requests, and the time for passing tasks to production has decreased. </li></ul><br>  A simple checker is written in half an hour, and complex in a few hours.  Checker saves much more time than it takes to write and fight back for a few undone pull request. <br><br>  You can learn more about Pylint and how to write checkers for it in the <a href="https://pylint.readthedocs.io/en/latest/">official documentation</a> , but in terms of writing checkers it is rather poor.  For example, about TokenChecker there is only a mention that it is there, but not about how to write the checker itself.  More information is <a href="https://github.com/PyCQA/pylint">in the Pylint source on GitHub</a> .  You can see what checkers are in the standard package and be inspired to write your own. <br><br>  <em>Knowledge of the internal device Pylint saves man-hours, simplifies</em> <em><br></em>  <em>work and improves the code.</em>  <em>Save your time, write good code and</em> <em><br></em>  <em>use linters.</em> <br><blockquote>  The next <a href="https://conf.python.ru/">Moscow Python Conf ++</a> conference will take place <b>on April 5, 2019</b> and you can book an early birf ticket already now.  It will be even better to collect your thoughts and <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dmpc2019">apply for</a> a report, then the visit will be free, and the bonus will be pleasant buns, including coaching for making the report. <br><br>  Our conference is a platform for meeting with like-minded people, engines of the industry, for communication and discussion of favorite Python developers: backend and web, data collection and processing, AI / ML, testing, IoT.  How it went in the fall <a href="https://youtu.be/ap0dsL_JeLE">in the video report</a> on our <a href="https://www.youtube.com/channel/UCqC1iSQnRIDz_rOy8LHe69g">Python Channel</a> and subscribe to the channel - we will soon post the best reports from the conference to the public. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/433474/">https://habr.com/ru/post/433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433462/index.html">Performance checks and gradual degradation of distributed systems</a></li>
<li><a href="../433464/index.html">Subcosmic race</a></li>
<li><a href="../433466/index.html">Compare pages. Simple plugin for Atlassian Confluence</a></li>
<li><a href="../433468/index.html">Fault Injection: your system is unreliable if you have not tried to break it</a></li>
<li><a href="../433472/index.html">Unity 2018.3 has been released</a></li>
<li><a href="../433476/index.html">50 shades of celery</a></li>
<li><a href="../433480/index.html">Holivarny story about the linter</a></li>
<li><a href="../433486/index.html">What's again? Reviving Non-Bank Debit Cards</a></li>
<li><a href="../433488/index.html">Christmas Scrum Meetup UPD Broadcast Mitap</a></li>
<li><a href="../433490/index.html">Creality CR-X 3D Printer Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>