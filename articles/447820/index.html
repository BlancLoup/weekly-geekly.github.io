<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Import 3D-models in Unity and pitfalls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We present the third article in our series on working with 3D models in Unity. Previous articles: ‚ÄúFeatures of working with Mesh in Unity‚Äù and ‚ÄúUnity:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Import 3D-models in Unity and pitfalls</h1><div class="post__text post__text-html js-mediator-article">  <i>We present the third article in our series on working with 3D models in Unity.</i>  <i>Previous articles: <a href="https://habr.com/ru/company/plarium/blog/440690/">‚ÄúFeatures of working with Mesh in Unity‚Äù</a> and <a href="https://habr.com/ru/company/plarium/blog/443870/">‚ÄúUnity: procedural editing of Mesh‚Äù</a> .</i> <br><br>  In the world of computer graphics, there are many formats for representing 3D models.  Some of them are positioned as universal, others as optimized for specific tasks or platforms.  In any field they dream of working with a universal format, but reality tells us "no."  Moreover, because of such a zoo, there is a vicious circle: the developers of ‚Äúuniversal‚Äù tools invent their own internal formats to summarize the previous ones, increasing the population and producing means of format conversion.  So there is a problem of data loss or corruption during conversion.  The problem is as old as the world (IT world, of course), and it has not bypassed the import of models in <b>Unity</b> . <br><br>  In this article we will talk about some of the difficulties that we have to deal with when working with models in <b>Unity</b> (features of the <b>ModelImporter</b> functioning, the difference in representations of 3D objects, etc.), as well as what tools we have created to overcome these difficulties. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/v9/vb/5z/v9vb5zyqkb4df5in7vwdiij1omq.jpeg"><a name="habracut"></a><br><br><h3>  Features of the ModelImporter </h3><br>  Recall that for the <b>API of</b> video cards the minimal and only three-dimensional primitive is a triangle, while the geometry in <b>FBX</b> , for example, can be represented as quadrangles.  Modern 3D-packages for creating models, as a rule, allow different levels of abstraction, but even there the result is rendered by means of triangles. <br><br>  However, many tools are sharpened to work with quadrilaterals, which pushes 3D artists to use this primitive as the main one.  In such cases, it is often required in TK to triangulate the model before implementation.  If the triangulation is not done, the corresponding <b>Unity</b> module in standard mode automatically executes it when a file is added.  Because of this, errors appear because the triangulation algorithms in different packages are implemented differently.  When choosing a diagonal to divide a quadrilateral, ambiguity arises, hence most of the problems that can be divided into two groups. <br><br>  The first is related to the correctness of the display of the model form.  So, the shape of a non-planar quadrilateral directly depends on the choice of the diagonal. <br><br><img src="https://habrastorage.org/webt/kv/5x/ge/kv5xgek7hkweg4xizlmphkd-zyw.jpeg"><br>  <i>Susanna triangulated in <b>Blender</b> (Quad Method: Beauty) and <b>Unity</b> (automatically upon import)</i> <br><br>  In addition, the baking algorithm for the normal map uses split data, which is why the difference in triangulation can generate artifacts in the form of a cross on a highlight. <br><br><img src="https://habrastorage.org/webt/kf/ql/sv/kfqlsv0wsl9tyoyowvgqfmqiw2m.jpeg"><br>  <i>Healthy man scooter and smoker scooter</i> <br><br>  Problems of the second group are found in the texture scan.  For example, we have a quadrangle with a sufficiently blunt angle to cause an error.  When previewed in a 3D package, it is broken by one of the diagonals into two completely folding triangles. <br><br><img src="https://habrastorage.org/webt/jn/i2/wy/jni2wyyqck_igyqzh8m7fdmffww.jpeg"><br>  <i>Source polygon</i> <br><br><img src="https://habrastorage.org/webt/7e/tn/0z/7etn0z4ncmnhtxmocmjxxrdweek.jpeg"><br>  <i><b>Blender</b> Triangulated Ground</i> <br><br>  However, after importing into a project, it is found that this quadrilateral is broken by another diagonal and that one of the triangles is either generally degenerate or close to that. <br><br><img src="https://habrastorage.org/webt/ae/s5/w7/aes5w7yjbxokpkt8mx3c_qkxwu0.jpeg"><br>  <i>Polygon in <b>Unity</b> with a triangle close to degenerate (the right triangle is almost indistinguishable from the segment)</i> <i><br></i> <br>  The cause of the problems associated with the degeneracy of polygons are errors in floating-point calculations, as well as features of pixel interpolation during rendering.  With such triangles, what the hell is happening: they jerk, each frame changes color.  The extremely small size of the cross section creates difficulties in processing light, because of which parts of dynamic objects may flicker.  And there is nothing good in the non-determinism of baking the <b>lighting card</b> . <br><br><h3>  I am a 3D package, I see it </h3><br><img src="https://habrastorage.org/webt/fe/u4/a6/feu4a6ej38wxub_wplrohwl0opk.jpeg"><br><br>  In 3D modeling, there is often a difference between the actual number of vertices and their number in the 3D package.  The essence of the problem lies in the information that is required for processing by the video card.  The data structure for the vertex is predetermined and includes the position, normal, tangent, texture scan coordinates for each channel and color.  That is, the two normals cannot be pushed into one vertex. <br><br>  For some artists, it is not always obvious that the top is determined not only by its position.  Modellers are well aware of the concepts of <b>Hard / Soft Edges</b> and <b>UV Seams</b> , but not everyone is aware of how they are implemented programmatically.  Additionally confusing are 3D packages, which in standard mode show the number of vertices as the number of unique positions. <br><br>  So, the usual <b>Cube</b> primitive is geometrically represented by 8 vertices.  However, in order to correctly transfer the reflection of light from each face and correctly impose a texture, in each corner of the cube it is necessary to have 3 vertices with the same position, but different normals and texture coordinates, since in each of the corners 3 edges converge.  A small <a href="https://docs.unity3d.com/Manual/BestPracticeMakingBelievableVisuals4.html">block of documentation</a> was devoted to this moment.  There you can see examples. <br><br><img src="https://habrastorage.org/webt/sj/-r/o3/sj-ro30pord7spxkbfqglxoqmlm.jpeg"><br>  <i><b>Blender</b> Cube Metrics</i> <br><br><img src="https://habrastorage.org/webt/q1/fw/m3/q1fwm30cfaob2d51vwtdgwkfoja.jpeg"><br>  <i>Cube Metrics in <b>Unity</b></i> <br><br><h3>  Enough tolerating this! </h3><br>  Faced with these and similar problems, we decided to create a tool for analyzing and validating models when importing into a <b>Unity</b> project.  In other words, a custom validator that answers the query ‚ÄúEat!‚Äù Will respond: ‚ÄúI will not!  Rework, ‚Äùor spit out sets of warnings and values ‚Äã‚Äãof various parameters, notifying you that something is not tasty. <br><br>  For analysis and verification, we developed the following functionality: <br><br><ul><li>  counting the number of unique positions of vertices, colored vertices, <b>Hard Edges</b> , <b>UV Seams</b> ; </li><li>  calculation of <b>Axis-Aligned Bounding Box (AABB)</b> and its center; </li><li>  determination of the output of <b>UV-</b> scan coordinates for the range of 0.0‚Äì1.0; </li><li>  definition of texture overlays; </li><li>  checking the texture scan for the sufficiency of the specified pixel indentation at the specified texture resolution. </li></ul><br>  What does this give us? <br><br>  <b>Calculations of the number of unique vertex positions, Hard Edges, UV Seams</b> and <b>colored vertices</b> are necessary to check the conformity of the model conceived by the artist with the one that was imported into <b>Unity</b> .  This functionality also allows you to monitor compliance with the requirements for optimizing the model (for example, so that the number of vertices does not exceed a certain value).  Due to the same feature of 3D packages that actually show the number of unique positions, there are cases when the metric of the number of vertices in the model editor satisfies this restriction, but after adding a file to the project it may turn out that this is not the case. <br><br>  <b>Calculating the AABB and its center</b> allows you to determine the offset of the model relative to the beginning of its own coordinate system.  This is necessary for the predictable positioning of assets, which are initialized in the scene already while the application is running.  Thus, the <b>AABB</b> building should have minY = 0 in an amicable way, and some chandeliers that are attached to the ceiling should have maxY = 0. <br><br><img src="https://habrastorage.org/webt/gu/fu/sf/gufusfry1kvahfxvaijbueaja1u.jpeg"><br><br><img src="https://habrastorage.org/webt/po/oy/8m/pooy8mif3numjhhf2pkxgjb0mri.jpeg"><br><br><img src="https://habrastorage.org/webt/5g/xq/z1/5gxqz1j4mcvz9alq6fkni-hdajw.jpeg"><br><br>  <b>The output coordinates of the UV-sweep to the range of 0.0‚Äì1.0</b> - in most cases (for example, if the texture should be hidden on the model) is provided.  Often, this approach is used to represent in the scene a multitude of low-detailed small objects (vegetation) and / or located in the distance, as well as tiling large homogeneous objects (buildings).  In the case of tiling, the coordinate values ‚Äã‚Äãof a specific <b>UV</b> channel are simply cut off the integer part at the shader level, if the <b>Wrap Mode</b> texture is set to <b>Repeat</b> . <br><br>  Imagine now that you put the texture in the atlas (and covered with a blanket: 3).  Already transformed coordinates corresponding to the atlas (x * scale + offset) will come to the shader.  This time, most likely, there will be no whole part and there will be nothing to trim, and the model will crawl onto someone else‚Äôs texture (the blanket turned out to be small).  This problem is solved in two ways. <br><br>  The first one assumes that you pre-cut the whole part of the coordinates of the sweep.  In this case, there is the likelihood of polygons overlapping, which we will discuss below. <br><br>  The second is based on the fact that tiling textures are inherently an optimization method.  Nobody forbids you to increase the size and sample the desired piece on the entire model.  However, in this way the usable space of the atlas will be used inefficiently. <br><br><img src="https://habrastorage.org/webt/xr/oa/5b/xroa5b_p8-frowb9nkcxp-qpee4.jpeg"><br><br>  <b>Texture overlays</b> are also more often not random: they are needed to effectively use texture areas.  It happens that a novice makes a mistake, the older comrade sees it, says a strong mot and a novice does not do that anymore.  But it happens that the imposition of so small and is in such an unexpected place that the older comrade can not notice. <br><br>  In an experienced team, the errors that were not noticed on the base sweep get into the project a bit more often than never.  Another thing, when changing the conditions for the use of ready-made content. <br><br>  Example.  We worked with a set of models for dynamic objects in the game.  Since there was no task to bake light for them, overlapping was allowed in the <b>UV</b> scan. <br><br><img src="https://habrastorage.org/webt/ay/y0/q9/ayy0q9fz71xqscfjp2mtb3k62v4.jpeg"><br>  <i>An example of basic <b>UV</b> scanning with overlays (shown in red)</i> <br><br>  But then we decided not to use these models as dynamic ones, but to arrange them as a static decor on the level.  To optimize, as you know, the lighting of static objects in the scene is baked in a special atlas.  These models did not have a separate <b>UV2</b> channel for the <b>lighting map</b> , and the quality of the automatic generator operation in <b>Unity</b> did not suit us, so we decided to use the basic texture scan for baking as often as possible. <br><br>  There were obvious problems with correct lighting.  It is obvious that the rays that fall into some of the statue in the eye, should not create glare <s>at the fifth point</s> on the back of the head. <br><br><img src="https://habrastorage.org/webt/2j/ss/o4/2jsso4clth4abgefjctiysx-sik.jpeg"><br>  <i>Incorrectly baked model lighting (left) and corrected (right)</i> <br><br>  <b>Unity,</b> when forming the <b>lighting map</b> , first of all tries to use the <b>UV2</b> channel.  If it is empty, then the main <b>UV is used</b> , if this one is empty, then excuse me, here you are an exception.  There are two ways to bake models in <b>a lighting map</b> without pre-prepared <b>UV2</b> in <b>Unity</b> . <br><br>  As a first, <b>Unity</b> offers automatic generation of <b>UV2</b> based on model geometry.  This is faster than doing it manually; moreover, this tool can be configured using several parameters.  But even despite this, the final imposition of light and shade is often unsatisfactory for highly detailed objects due to seams and wicking in the wrong places, besides the packaging of parts of such a scan is not the most effective. <br><br><img src="https://habrastorage.org/webt/dr/-l/fo/dr-lfomq-_0uikazqeqhmneekw8.jpeg"><br><br>  The second way is to use the basic <b>UV</b> scan for baking.  A very attractive option, because when working with one texture scan, there is less chance of making a mistake than working with two.  For this reason, we try to minimize the number of models, in the base <b>UV of</b> which there are overlaps.  The created toolkit helps us to do this. <br><br>  <i>Checking the texture scan for the sufficiency of a given pixel indent at a given texture resolution</i> is more accurate <b>UV</b> validation based on rasterization.  More about this method will be discussed in the next article in the series. <br><br>  Summarize.  Of course, it is almost impossible to track all the nuances: sometimes you have to put up with the imperfection of the result in order to complete the task on time.  However, the identification of even some of these shortcomings allows you to speed up the development of the project and improve its quality. </div><p>Source: <a href="https://habr.com/ru/post/447820/">https://habr.com/ru/post/447820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447810/index.html">Analytics for Azure DevOps Services is now publicly available.</a></li>
<li><a href="../447812/index.html">How we implemented continuous delivery of updates to the customer platform</a></li>
<li><a href="../447814/index.html">Where and how to open a development center?</a></li>
<li><a href="../447816/index.html">Some C ++ template magic and CRTP to control the correctness of the programmer's actions in compile-time</a></li>
<li><a href="../447818/index.html">AgileDays 2019</a></li>
<li><a href="../447822/index.html">Almost fired. How I built the Yandex analytics department</a></li>
<li><a href="../447826/index.html">Recruiter should be able to sell</a></li>
<li><a href="../447828/index.html">How we do IT for people in Rostelecom</a></li>
<li><a href="../447830/index.html">The code is alive and dead. Part Three Code as text</a></li>
<li><a href="../447832/index.html">Not so long ago</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>