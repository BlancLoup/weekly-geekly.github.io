<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RAML routing in the Play Framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Play framework is a very flexible tool, but there is little information on how to change the format of the route file on the Internet. I will talk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RAML routing in the Play Framework</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/4c0/eb6/d77/4c0eb6d770974b5dba807bca25df30f7.png" alt="image"><br><br>  <a href="https://www.playframework.com/documentation/2.5.x/Home">The Play framework</a> is a very flexible tool, but there is little information on how to change the <a href="https://www.playframework.com/documentation/2.5.x/ScalaRouting">format of the route file</a> on the Internet.  I will talk about how you can replace the standard route description language based on the route file with a description in <a href="http://raml.org/">RAML</a> format.  And for this we will have to create <a href="https://github.com/bavadim/raml2play">our SBT-plugin</a> . <br><a name="habracut"></a><br>  In a nutshell about RAML (RESTful API Modeling Language).  As quite rightly stated on the main page of the project, this language greatly simplifies working with the application API throughout its life cycle.  It is concise, easily reused, and most valuablely, it is equally easy to read by machine and man.  That is, it is possible to embody the documentation as a code approach, when one artifact (RAML script) becomes an entry point for all participants in the development process - analysts, testers and programmers. <br><br><h2>  Formulation of the problem </h2><br>  Our team is working on a large and complex <a href="https://rbo.raiffeisen.ru/">online banking system</a> .  Special attention is paid to interface documentation and tests.  Once I wondered if it was possible to combine tests, documentation and code generation.  It turned out that to a certain extent it is possible.  But first, a few words about why we needed it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In a large project, documentation of interfaces is of particular importance.  Analysts, developers of services and client applications should have a description of the API of the system on which they are working.  Analysts have important documentation in an easy-to-read form, programmers ultimately describe the interface in code, with different commands writing code in different languages.  Information is repeatedly duplicated, which makes it difficult to synchronize.  When there are many teams, it is almost impossible to manually ensure that the various API formats match each other.  Therefore, we have approached the solution of this problem thoroughly. <br><br>  To begin, we chose a single API description format for all commands.  They became RAML.  Next, we would need to ensure (as far as possible) that our services match the description, and the client applications work with the described services.  To do this, we use testing tools, which I will discuss in another article.  And the final step was the implementation of code generation, which creates code for us based on data from RAML.  Today we will talk about the code generation tools used in the server project. <br><br>  The documentation usually contains information about the REST endpoints, a description of the parameters and the request body, HTTP codes, and a description of the responses.  Moreover, for all the above elements, examples are often indicated.  This information is quite enough to test the endpoint's performance - you just need to take an example request for it and send it to the server.  If the end point has parameters, then its values ‚Äã‚Äãshould also be taken from the examples.  Compare the response with an example response or validate its JSON scheme based on the documentation.  For the sample answers to match the server's responses, the server must work with the correct data in the database.  Thus, if there is a database with test data and the API documentation of the service with a description of the answers and examples of requests, we can provide simple testing of the performance of our service.  About our documentation, testing system and database, I have now mentioned to complete the picture, and we will definitely talk about them another time.  Here I will talk about how, on the basis of such documentation, to generate as much useful server code as possible. <br><br>  Our server is written in Play 2.5 and provides the REST API to its clients.  The data exchange format is JSON.  The standard description of the API in the Play framework is in the conf / route file.  The syntax of this description is simple and is limited to the description of endpoint names and their parameters, as well as the binding of endpoints to the controller methods in the routes file.  Our goal will be to replace the standard syntax with a description in RAML format.  For this we need: <br><br><ol><li>  Understand how routing is arranged in Play and how route files are processed. </li><li>  Replace the standard routing mechanism with our mechanism using RAML. </li><li>  Look at the result and draw conclusions :) </li></ol><br>  So let's go in order. <br><br><h2>  Routing in the Play framework </h2><br>  Play framework is designed for use with two languages ‚Äã‚Äã- Scala and Java.  Therefore, the authors of the framework did not use DSL on the basis of a particular language to describe the routes, but wrote their own language and compiler for it.  Next, I will talk about Scala, but everything said is true for Java.  The play application is built using <a href="http://www.scala-sbt.org/">SBT</a> .  During the project build, route files are compiled into files on Scala or Java, and then the result of the compilation is used during the build.  The SBT plugin com.typesafe.play.sbt-plugin is responsible for processing the route file.  Let's see how it works.  But first, a few words about SBT. <br><br>  The basic concept of SBT is key.  Keys are of two types: TaskKey and SettingsKey.  The first type is used to store functions.  Each call to this key will call this function.  The second type of key stores a constant and is calculated once.  Compile is TaskKey, in the process of execution it calls another TaskKey, sourceGenerators, for code generation and creating source files.  The SBT-plugin itself adds the function of processing the route file to sourceGenerators. <br><br>  Usually, two main artifacts are created based on route ‚Äî the file target / scala-2.11 / routes / main / router / Routes.scala and target / scala-2.11 / routes / main / controllers / ReverseRoutes.scala.  The Routes class is used to route incoming requests.  ReverseRoutes is used to call the endpoints from the controller code and view by the endpoint name.  Let's illustrate the above with an example. <br><br>  <b>conf / routes</b> <br><pre><code class="scala hljs"><span class="hljs-type"><span class="hljs-type">GET</span></span> /test/:strParam   <span class="hljs-meta"><span class="hljs-meta">@controllers</span></span>.<span class="hljs-type"><span class="hljs-type">HomeController</span></span>.index(strParam)</code> </pre> <br>  Here we declare the parameterized endpoint and map it to the HomeController.index method.  Compiling this file results in the following Scala code: <br><br>  <b>target / scala-2.11 / routes / main / router / Routes.scala</b> <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Routes</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">   override val errorHandler: play.api.http.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">HttpErrorHandler</span></span></span></span><span class="hljs-class"><span class="hljs-params">,   </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">HomeController_0</span></span></span></span><span class="hljs-class"><span class="hljs-params">: javax.inject.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Provider</span></span></span></span><span class="hljs-class"><span class="hljs-params">[controllers.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">HomeController</span></span></span></span><span class="hljs-class"><span class="hljs-params">],   val prefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params"> </span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GeneratedRouter</span></span></span><span class="hljs-class"> </span></span>{   ...   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> controllers_HomeController_index0_route = <span class="hljs-type"><span class="hljs-type">Route</span></span>(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>,       <span class="hljs-type"><span class="hljs-type">PathPattern</span></span>(<span class="hljs-type"><span class="hljs-type">List</span></span>(           <span class="hljs-type"><span class="hljs-type">StaticPart</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix),           <span class="hljs-type"><span class="hljs-type">StaticPart</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.defaultPrefix),           <span class="hljs-type"><span class="hljs-type">StaticPart</span></span>(<span class="hljs-string"><span class="hljs-string">"test/"</span></span>),           <span class="hljs-type"><span class="hljs-type">DynamicPart</span></span>(<span class="hljs-string"><span class="hljs-string">"strParam"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"[^/]+"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-literal"><span class="hljs-literal">true</span></span>)       ))       )   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> controllers_HomeController_index0_invoker = createInvoker(       <span class="hljs-type"><span class="hljs-type">HomeController_0</span></span>.get.index(fakeValue[<span class="hljs-type"><span class="hljs-type">String</span></span>]),<span class="hljs-type"><span class="hljs-type">HandlerDef</span></span>(           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass.getClassLoader,           <span class="hljs-string"><span class="hljs-string">"router"</span></span>,<span class="hljs-string"><span class="hljs-string">"controllers.HomeController"</span></span>,<span class="hljs-string"><span class="hljs-string">"index"</span></span>,           <span class="hljs-type"><span class="hljs-type">Seq</span></span>(classOf[<span class="hljs-type"><span class="hljs-type">String</span></span>]),<span class="hljs-string"><span class="hljs-string">"GET"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix + <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"test/"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> + <span class="hljs-string"><span class="hljs-string">"$"</span></span> + <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"strParam&lt;[^/]+&gt;"</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>)       )   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routes</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">RequestHeader</span></span>, <span class="hljs-type"><span class="hljs-type">Handler</span></span>] = {       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> controllers_HomeController_index0_route(params) =&gt;           call(params.fromPath[<span class="hljs-type"><span class="hljs-type">String</span></span>](<span class="hljs-string"><span class="hljs-string">"strParam"</span></span>, <span class="hljs-type"><span class="hljs-type">None</span></span>)) { (strParam) =&gt;               controllers_HomeController_index0_invoker.call(<span class="hljs-type"><span class="hljs-type">HomeController_0</span></span>.get.index(strParam))           }       } }</code> </pre> <br>  This class deals with the routing of incoming requests.  As arguments, it is passed the link to the controller (more precisely, the injector, but this is not significant) and the prefix URL path, which is configured in the configuration file.  Further in the class, the ‚Äúmask‚Äù of routing <b>controllers_HomeController_index0_route is</b> declared.  The mask consists of an HTTP verb and a route pattern.  The latter consists of parts, each corresponding to the URL element of the path.  StaticPart defines a mask for the unchanged part of the path, DynamicPart sets a template for the URL parameter.  Each incoming request falls into the routes function, where it is associated with the available masks (in our case it is one).  If no match is found, the client will receive a 404 error, otherwise the corresponding handler will be called.  In our example, one handler is <b>controllers_HomeController_index0_invoker</b> .  It is the responsibility of the handler to call the controller method with the necessary set of parameters and transform the results of this call. <br><br>  <b>target / scala-2.11 / routes / main / controllers / ReverseRoutes.scala</b> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> controllers {   <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReverseHomeController</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_prefix: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span></span>{       ...        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>(strParam:<span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Call</span></span> = {           <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">ReverseRouteContext</span></span>.empty           <span class="hljs-type"><span class="hljs-type">Call</span></span>(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, _prefix + { _defaultPrefix } +               <span class="hljs-string"><span class="hljs-string">"test/"</span></span> +               implicitly[<span class="hljs-type"><span class="hljs-type">PathBindable</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]].unbind(<span class="hljs-string"><span class="hljs-string">"strParam"</span></span>, dynamicString(strParam)))       }   } }</code> </pre> <br>  This code allows us to access the endpoint through an appropriate function, for example, in view. <br><br>  So, to change the format of the route description we just need to write our own Routes file generator.  We do not need ReverseRoutes, since our service gives JSON and it has no view.  In order for our generator to work, you need to turn it on.  You can copy the source of the generator in each project where it is needed, and then connect it to build.sbt.  But it would be more correct to arrange the generator in the form of a plug-in to SBT. <br><br><h2>  <b>SBT plugin</b> </h2><br>  SBT plug-ins are fully documented.  Here I will mention the main, in my opinion, points.  A plugin is a set of additional functionality.  Usually plugins add new keys to the project and extend existing ones.  For example, we will need to expand the sourceGenerators key.  Some plugins may depend on others, for example, we could use the com.typesafe.play.sbt-plugin plugin as the basis and change only what we need.  In other words, our plugin depends on com.typesafe.play.sbt-plugin.  In order for SBT to automatically connect all dependencies for our plugin, it must be <a href="http://www.scala-sbt.org/0.13/docs/Using-Plugins.html">AutoPlugin</a> .  And finally: due to compatibility issues, plugins are written on Scala 2.10. <br><br>  So, we need to generate Routes.scala based on the RAML file.  Let this file be called conf / api.raml.  In order for documentation in RAML format to be used for routing, it is necessary in some way to specify in it for each end point a controller method that must be called when a request is received.  RAML 0.8, which we will use, does not have the means to indicate such information, so you have to do a dirty hack (RAML 1.0 solves this problem with annotations, but at the time of this writing, this version of the standard is still cheese).  Add information about the controller method being called to the first description line for each endpoint.  Our example in RAML format from the previous chapter will look like this: <br><br><pre> <code class="hljs pgsql">/test/{strParam}:   uriParameters:       strParam:       description: simple parameter       <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string       required: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>       example: "some value"   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>:       description: |           @controllers.HomeController.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(strParam)       responses:           <span class="hljs-number"><span class="hljs-number">200</span></span>:               body:                   application/<span class="hljs-type"><span class="hljs-type">json</span></span>:                       <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>: !<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> ./<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>/statements/operations.json                       example: !<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> ./examples/statements/operations.json</code> </pre> <br><br>  I will not dwell on the details of RAML parsing, I will just say that you can use the <a href="https://github.com/raml-org/raml-java-parser">parser from raml.org.</a>  As a result of the parsing, we get a list of rules - one for each endpoint.  The rule is defined by the following class: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">verb: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">HttpVerb</span></span></span></span><span class="hljs-class"><span class="hljs-params">, path: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PathPattern</span></span></span></span><span class="hljs-class"><span class="hljs-params">, call: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">HandlerCall</span></span></span></span><span class="hljs-class"><span class="hljs-params">, comments: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Comment</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-class"><span class="hljs-params">(</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  The names and types of fields speak for themselves.  Now for each rule we can create our own mask, handler and case element in the route function in the Routes.scala file.  To solve this problem, you can manually generate a line with the code Routes.scala based on the list of rules, or use macros.  But it is better to choose an intermediate version, which was preferred by the developers of Play - to use the template engine.  PB Play uses the <a href="https://github.com/playframework/twirl">twirl</a> templating <a href="https://github.com/playframework/twirl">engine</a> , and we also use it.  Here is a template from our plugin that generates the route function: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routes</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">RequestHeader</span></span>, <span class="hljs-type"><span class="hljs-type">Handler</span></span>] = <span class="hljs-meta"><span class="hljs-meta">@ob</span></span>   <span class="hljs-meta"><span class="hljs-meta">@if</span></span>(rules.isEmpty) {   <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {<span class="hljs-meta"><span class="hljs-meta">@for</span></span>((dep, index) &lt;- rules.zipWithIndex){<span class="hljs-meta"><span class="hljs-meta">@dep</span></span>.rule <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> route @ <span class="hljs-type"><span class="hljs-type">Rule</span></span>(_, _, _, _) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> @(routeIdentifier(route, index))(params) =&gt;           call@(routeBinding(route)) <span class="hljs-meta"><span class="hljs-meta">@ob</span></span> <span class="hljs-meta"><span class="hljs-meta">@tupleNames</span></span>(route)               <span class="hljs-meta"><span class="hljs-meta">@paramsChecker</span></span>(route) @(invokerIdentifier(route, index))                   .call(<span class="hljs-meta"><span class="hljs-meta">@injectedControllerMethodCall</span></span>(route, dep.ident, x =&gt; safeKeyword(x.name)))<span class="hljs-meta"><span class="hljs-meta">@cb</span></span>       }   }}}<span class="hljs-meta"><span class="hljs-meta">@cb</span></span></code> </pre> <br>  It looks somewhat confusing, but if you look closely, everything becomes clear.  Expressions starting with @ are directives and variables of the template engine.  The @ob and @cb variables will be expanded to {and}, respectively.  And, for example, <b>@ (routeIdentifier (route, index))</b> will unfold according to the following rule: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeIdentifier</span></span></span></span>(route: <span class="hljs-type"><span class="hljs-type">Rule</span></span>, index: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = route.call.packageName.replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span>) +   <span class="hljs-string"><span class="hljs-string">"_"</span></span> + route.call.controller.replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"_"</span></span>) +   <span class="hljs-string"><span class="hljs-string">"_"</span></span> + route.call.method + index + <span class="hljs-string"><span class="hljs-string">"_route"</span></span></code> </pre> <br>  Now it‚Äôs clear how to write code that creates Routes.scala based on RAML, and understand how to connect it to the assembly.  Sources of the finished plug-in are on <a href="https://github.com/bavadim/raml2play">Github</a> . <br><br><h2>  <b>Future plans</b> </h2><br>  The plugin allowed us to use the documentation as the source code for the server.  But code generation does not use all the available information from the RAML file.  Namely, we do not use information about the type of request and response.  In Play, request parsing and response generation takes place in controller methods, but we want to generate this code automatically.  In addition, we have plans to use RAML version 1.0. <br><br>  That's all for today, thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/332638/">https://habr.com/ru/post/332638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332628/index.html">5 tricks to help develop on vue.js + vuex</a></li>
<li><a href="../332630/index.html">Extending, modifying, and creating controls on the UWP platform. Part 2</a></li>
<li><a href="../332632/index.html">Rewarded Video: the best show scripts or how to make your ad look</a></li>
<li><a href="../332634/index.html">Things I needed to know before creating a queue system</a></li>
<li><a href="../332636/index.html">Go Developer Tools: Meet Profiler Labels</a></li>
<li><a href="../332640/index.html">How generic-they save us from packing</a></li>
<li><a href="../332642/index.html">Simple field validation</a></li>
<li><a href="../332644/index.html">Tandem office and mobile telephony. How we developed FMC</a></li>
<li><a href="../332646/index.html">Security Week 27: ExPetr = BlackEnergy, more than 90% of sites are insecure, in RCE-vulnerability closed in Linux</a></li>
<li><a href="../332652/index.html">Using LibVirt API, InfluxDB and Grafana to collect and visualize VM execution statistics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>