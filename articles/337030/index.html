<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How recursion works - explanation in flowcharts and video</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the translation of the article Beau Carnes How Recursion Works - explained with flowcharts and a video . 


 ‚ÄúIn order to understand ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How recursion works - explanation in flowcharts and video</h1><div class="post__text post__text-html js-mediator-article">  I present to you the translation of the article Beau Carnes <a href="http://medium.freecodecamp.org/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9">How Recursion Works - explained with flowcharts and a video</a> . <br><br><img src="https://habrastorage.org/web/c13/9d8/988/c139d898804b4e8ebcabd7e539ccdbd4.png"><br><blockquote>  ‚ÄúIn order to understand recursion, you must first understand recursion‚Äù </blockquote><br><p>  Recursion is sometimes difficult to understand, especially for beginners in programming.  Simply put, recursion is a function that calls itself.  But let's try to explain with an example. </p><br><p>  Imagine that you are trying to open the door to the bedroom, and it is closed.  Your three-year-old son appears from the corner and says that the only key is hidden in the box.  You are late for work and you really need to get into the room and take your shirt. </p><br><p>  You open the box just to find ... more boxes.  The boxes are inside the boxes and you don't know which one is your key.  You urgently need a shirt, so you need to come up with a good algorithm and find the key. </p><br><p>  There are two main approaches to creating an algorithm for solving this problem: iterative and recursive.  Here are the flowcharts of these approaches: </p><br><img src="https://habrastorage.org/web/620/c52/954/620c5295459b4d83b0a94f2e20fe8ccc.png"><br><br><h4>  Which approach is easier for you? </h4><a name="habracut"></a><br><p>  The first approach uses a while loop.  Those.  while the stack of boxes is full, grab the next box and look inside it.  Below is a bit of pseudocode in Javascript, which reflects what is happening (Pseudocode is written as code, but more like a human language). </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">look_for_key</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">main_box</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pile = main_box.make_a_pile_to_look_through(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (pile is not empty) { box = pile.grab_a_box(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> box) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.is_a_box()) { pile.append(item) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.is_a_key()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"found the key!"</span></span>) } } } }</code> </pre> <br><p>  In another approach, recursion is used.  Remember, recursion is when a function calls itself.  Here is the second option in pseudocode: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">look_for_key</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">box</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> box) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.is_a_box()) { look_for_key(item); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.is_a_key()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"found the key!"</span></span>) } } }</code> </pre> <br><p>  Both approaches do the same thing.  The main point in using the recursive approach is that once you understand, you can easily read it.  In reality, there is no performance gain from using recursion.  Sometimes an iterative approach with cycles will work faster, but simplicity of recursion is sometimes preferable. </p><br><p>  Since recursion is used in many algorithms, it is very important to understand how it works.  If recursion still doesn't seem easy to you, don't worry: I'm going to go through a few more examples. </p><br><h3>  Boundary and recursive case </h3><br>  What you need to take into account when writing a recursive function is an infinite loop, i.e.  when a function calls itself ... and can never stop. <br>  Suppose you want to write a counting function.  You can write it recursively in Javascript, for example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// WARNING: This function contains an infinite loop! function countdown(i) { console.log(i) countdown(i - 1) } countdown(5); // This is the initial call to the function.</span></span></code> </pre> <br><img src="https://habrastorage.org/web/3a9/51b/d3e/3a951bd3e4374b61bdebe7f50155b12a.png"><br><p>  This function will count to infinity.  So, if you suddenly run the code with an infinite loop, stop it with the key combination "Ctrl-C".  (Or, working for example in CodePen, this can be done by adding ‚Äú? Turn_off_js = true‚Äù at the end of the URL.) </p><br><p>  A recursive function should always know when to stop.  In a recursive function, there are always two cases: the recursive and the boundary cases.  The recursive case is when the function calls itself, and the boundary case when the function stops calling itself.  The presence of a boundary case and prevents looping. </p><br>  And again, the counting function, only with the boundary case: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countdown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// base case return; } else { // recursive case countdown(i - 1) } } countdown(5); // This is the initial call to the function.</span></span></code> </pre> <br><img src="https://habrastorage.org/web/005/234/e2f/005234e2f6db447697723137b3637171.png"><br><p>  What happens in this function may not be completely obvious.  I will explain what happens when you call a function and pass the number 5 into it. </p><br><p>  First we will display the number 5 using the <i>Console.Log</i> command.  Since  5 is not less than or equal to 1, then we move to the <i>else</i> block.  Here we call the function again and pass the number 4 into it (since 5 - 1 = 4). </p><br><p>  We output the number 4. And again <i>i is</i> not less than or equal to 1, so we go to the <i>else</i> block and transfer the number 3. This continues until <i>i</i> becomes 1. And when this happens we output 1 to the console and <i>i</i> becomes less or equal to 1. Finally we go into the block with the keyword <i>return</i> and exit the function. </p><br><h3>  <b>Call stack</b> </h3><br><p>  Recursive functions use the so-called Call Stack.  When a program calls a function, the function is sent to the top of the call stack.  It looks like a stack of books, you add one thing at a time.  Then, when you are ready to remove something back, you always remove the top element. </p><br><p>  I will show you the call stack in action using the factorial counting function.  <i>Factorial (5)</i> is written as <i>5!</i>  and is calculated as <i>5!</i>  <i>= 5 * 4 * 3 * 2 * 1</i> .  Here is a recursive function to calculate the factorial of a number: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fact</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * fact(x<span class="hljs-number"><span class="hljs-number">-1</span></span>); } }</code> </pre><br><p>  Now, let's see what happens when you call <i>fact (3)</i> .  Below is an illustration which shows step by step what happens on the stack.  The topmost box in the stack tells you what to call the <i>fact</i> function that you are currently stopping at: </p><br><img src="https://habrastorage.org/web/0fe/43e/e2b/0fe43ee2b45042aabf4cb82245c152b8.png"><br><p>  Noticed how each call to the <i>fact</i> function contains its own copy of x.  This is a very important condition for recursion work.  You cannot access another copy of the function from <i>x</i> . </p><br><h3>  Have you already found the key? </h3><br><p>  Let's briefly go back to the original example of finding the key in the boxes.  Remember that the first was an iterative approach using cycles?  According to this approach, you create a stack of search boxes, so you always know in which boxes you have not searched. </p><br><img src="https://habrastorage.org/web/6aa/f1a/b7d/6aaf1ab7df5d466380b80e0ad7852b34.png"><br><p>  But in the recursive approach there is no stack.  So how then does the algorithm understand which box to look for?  Answer: The ‚Äústack of boxes‚Äù is stored on the stack.  A stack is formed from half-executed function calls, each of which contains its half-completed list of boxes for viewing.  The stack keeps track of a stack of boxes for you! </p><br><p>  And so, thanks to the recursion, you were finally able to find your key and take the shirt! </p><br><img src="https://habrastorage.org/web/41d/004/d63/41d004d63acc4c08b0b1b87c16122c70.png"><br><p>  You can also watch my five-minute video about recursion.  It should reinforce the understanding of the concepts presented here. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPEJSJMg4jY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Conclusion from the author </h3><br><p>  I hope the article has brought a little more clarity to your understanding of recursion in programming.  The article was based on a lesson in my new video course from Manning Publications called <a href="http://www.manning.com/livevideo/algorithms-in-motion%3Fa_aid%3Dalgmotion%26a_bid%3D9022d293">‚ÄúAlgorithms in Motion‚Äù</a> .  Both the course and the article are written according to the remarkable book <a href="http://www.amazon.com/gp/product/1617292230/ref%3Das_li_qf_sp_asin_il_tl%3Fie%3DUTF8%26tag%3Dbcar08-20%26camp%3D1789%26creative%3D9325%26linkCode%3Das2%26creativeASIN%3D1617292230%26linkId%3D83471c93327ff24766dd812f9799f95a">‚ÄúGrokking Algorithms‚Äù</a> , the author of which is Adit Bhargava, and all these wonderful illustrations were drawn. </p><br><p>  And finally, to really consolidate your knowledge of recursion, you should read this article at least once more. </p><br><p>  From myself I want to add that I am watching with interest the articles and video tutorials of Beau Carnes, and I hope that you also liked the article and especially these really wonderful illustrations from the book A. Bhargav ‚ÄúGrokking Algorithms‚Äù. </p></div><p>Source: <a href="https://habr.com/ru/post/337030/">https://habr.com/ru/post/337030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337014/index.html">Quick releases on a massive scale.</a></li>
<li><a href="../337022/index.html">The digest of interesting materials for the mobile developer # 219 (August 28 - September 3)</a></li>
<li><a href="../337024/index.html">Dive into BerkeleyDB JE. Introduction to Collections API</a></li>
<li><a href="../337026/index.html">GSoC 2017 Project Report: ReactOS Apps Manager</a></li>
<li><a href="../337028/index.html">Bayes Summer | Deep | Bayes Summer School Materials in In-Depth Learning</a></li>
<li><a href="../337034/index.html">Call for free using ENUMER blockchain service</a></li>
<li><a href="../337036/index.html">Wolfenstein 3D pixel-by-pixel fill</a></li>
<li><a href="../337038/index.html">JavaScript scopes</a></li>
<li><a href="../337040/index.html">‚ÄúRise of Machinery Learning‚Äù or combine a hobby in Data Science and analyzing the spectra of light bulbs</a></li>
<li><a href="../337042/index.html">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>