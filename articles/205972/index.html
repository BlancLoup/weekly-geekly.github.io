<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You are not programming microcontrollers yet? Then we go to you!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear Habrazhiteli! 

 In this article I want to talk about how once I decided to start programming microcontrollers, what was needed for this a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You are not programming microcontrollers yet? Then we go to you!</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/331/381/52d/33138152d2bad64e00aa658ca021aedf.png">  Hello, dear Habrazhiteli! <br><br>  In this article I want to talk about how once I decided to start programming microcontrollers, what was needed for this and what happened in the end. <br><br>  I was interested in the topic of microcontrollers for a very long time, in the year 2001. But then it turned out to be problematic to get a programmer at the place of residence, and there was no question of buying via the Internet.  I had to postpone this thing until better times.  And so, one day I discovered that the <s>best of times had come</s> from the comfort of my home, I could buy everything I needed.  Decided to try.  So what we need: <br><a name="habracut"></a><br><h6>  1. Programmer </h6><br>  There are many options on the market - from the cheapest ISP (In-System Programming) programmers for a few dollars, to powerful programmers-debuggers for a couple of hundred.  Not having much experience in this matter, for a start I decided to try one of the simplest and cheapest - USBasp.  I bought at one time on eBay for $ 12, now you can even find it for $ 3-4.  This is actually the Chinese version of the <a href="http://www.fischl.de/usbasp/">Thomas Fischl</a> programmer.  What can I say about him?  Only one thing - it works.  In addition, it supports a lot of AVR controllers of the ATmega and ATtiny series.  Under Linux does not require a driver. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/621/c68/9f3/621c689f345cc0224cf6c67009389d44.jpg"></div><br><br>  For firmware, connect the outputs of the <code>VCC, GND, RESET, SCK, MOSI, MISO</code> programmer to the corresponding outputs of the microcontroller.  For simplicity, I put together an auxiliary circuit right on the breadboard: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/cbf/34a/db2cbf34a9ea3a2a71c34741f5d032de.png" alt="image"></div><br><br>  On the left on the board is the same microcontroller that we are going to flash. <br><br><h6>  2. Microcontroller </h6><br>  With the choice of a microcontroller, I didn‚Äôt really bother and took the Atmega8 ATmega8 - 23 I / O pins, two 8-bit timers, one 16-bit, frequency up to 16 MHz, low consumption (1-3.6 mA), cheap ($ 2).  In general, for the beginning - more than enough. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/952/88a/73b/95288a73b35e64176f808de9b038797d.jpg" alt="image"></div><br><br>  Under Linux, the avr-gcc + avrdude bundle works perfectly for compiling and downloading firmware to the controller.  Installation is trivial.  Following the <a href="http://www.timteatro.net/2012/03/22/beginning-atmel-avr-development-in-linux-using-avr-eclipse-avr-gcc-and-avrdude/">instructions</a> , you can install all the necessary software in a few minutes.  The only nuance to which attention should be paid is that avrdude (software for writing to the controller) may require super user rights to access the programmer.  Exit - run through sudo (not a good idea), or prescribe special udev rights.  The syntax may differ in different versions of the OS, but in my case (Linux Mint 15), the following rule was added to the <code>/etc/udev/rules.d/41-atmega.rules</code> file: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># USBasp programmer SUBSYSTEM=="usb", ATTR{idVendor}=="16c0", ATTR{idProduct}=="05dc", GROUP="plugdev", MODE="0666"</span></span></code> </pre><br><br>  After this, of course, you need to restart the service. <br><pre> <code class="bash hljs">service udev restart</code> </pre><br>  Compiling and flashing without problems can be directly from the command line (who would doubt), but if there are many projects, it is more convenient to install the <a href="http://avr-eclipse.sourceforge.net/wiki/index.php/The_AVR_Eclipse_Plugin">AVR Eclipse</a> plugin and do everything directly from the Eclipse environment. <br><br>  Under Windows you have to install the driver.  The rest is no problem.  For the sake of scientific interest I tried a bunch of AVR Studio + eXtreme Burner in Windows.  Again, everything works out with a bang. <br><br><h3>  We start to program </h3><br>  AVR controllers can be programmed either in assembler (AVR assembler) or in C.  Here, I think everyone should make their own choice, depending on the specific task and their preferences.  Personally, I first started picking assembler.  When programming in assembler, the device architecture becomes clearer and you get the feeling that you are digging directly into the inside of the controller.  In addition, I believe that knowledge of the assembler can be very useful in programs that are especially critical in size and performance.  After getting acquainted with the AVR assembler, I crawled on to C. <br><br>  After becoming acquainted with the architecture and basic principles, I decided to collect something useful and interesting.  Then my daughter helped me, she was engaged in chess, and one fine evening she declared that she wanted to have a clock-timer for parties for a while.  Bam!  Here it is - the idea of ‚Äã‚Äãthe first project!  You could certainly order them on the same eBay, but I wanted to make my own watches, with black ... uh ... with indicators and buttons.  No sooner said than done! <br><br>  As a display, it was decided to use two 7-segment diode indicators.  5 buttons were enough for control - <code>‚Äú 1‚Äù</code> , <code>‚Äú 2‚Äù</code> , <code>‚Äú‚Äù</code> , <code>‚Äú‚Äù</code> and <code>‚Äú‚Äù</code> .  Well, do not forget about the sound indication of the end of the game.  Look like that's it.  The figure below shows the general scheme of connecting the microcontroller to the indicators and buttons.  We will need it when parsing the program source code: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67a/d1a/092/67ad1a092172f113fe1ab3608176fd4d.png"></div><br><br><h3>  Debriefing flight </h3><br>  Let's begin, as it should be, from the entry point of the program - the <code>main</code> function.  In fact, there is nothing remarkable in it ‚Äî setting up ports, initializing data, and an endless loop of handling keystrokes.  Well, the call to <code>sei()</code> is the resolution of interrupt handling, about them a little later. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ init_io(); init_data(); sound_off(); sei(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { handle_buttons(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Consider each function separately. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_io</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// set output DDRB = 0xFF; DDRD = 0xFF; // set input DDRC = 0b11100000; // pull-up resistors PORTC |= 0b00011111; // timer interrupts TIMSK = (1&lt;&lt;OCIE1A) | (1&lt;&lt;TOIE0); TCCR0 |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00); TCCR1B = (1&lt;&lt;CS12|1&lt;&lt;WGM12); //OCRn = (clock_speed / prescaler) * seconds - 1 OCR1A = (F_CPU / 256) * 1 -1; }</span></span></code> </pre><br><br>  Configuring I / O ports is very simple - a number is written to the DDRx register (where x is the letter designating the port), each bit of which means whether the corresponding pin is an input device (corresponds to 0) or an output (corresponds to 1).  Thus, by sending the number 0xFF to DDRB and DDRD, we made B and D output ports.  Accordingly, the <code>DDRC = 0b11100000;</code> command <code>DDRC = 0b11100000;</code>  turns the first 5 pins of port C into the input pins, and the rest on the weekend.  Team <code>PORTC |= 0b00011111;</code>  includes internal pull-up resistors at 5 controller inputs.  According to the diagram, buttons are connected to these inputs, which, when pressed, close them to the ground.  Thus, the controller understands that the button is pressed. <br><br>  The following is the setting of two timers, Timer0 and Timer1.  We use the first one to update the indicators, and the second one to count down the time, having previously configured it to operate every second.  A detailed description of all the constants and the method of setting the timer for a specific interval can be found in the documentation for ATmega8. <br><br>  <b>Interrupt handling</b> <br><br><pre> <code class="cpp hljs">ISR (TIMER0_OVF_vect) { display(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_buzzer &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { _buzzer--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_buzzer == <span class="hljs-number"><span class="hljs-number">0</span></span>) sound_off(); } } ISR(TIMER1_COMPA_vect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ActiveTimer == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; Timer1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Timer1--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Timer1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) process_timeoff(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ActiveTimer == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; Timer2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Timer2--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Timer2 == <span class="hljs-number"><span class="hljs-number">0</span></span>) process_timeoff(); } }</code> </pre><br><br>  When the timer is triggered, control is transferred to the corresponding interrupt handler.  In our case, this is the TIMER0_OVF_vect handler, which calls the procedure for outputting time to the indicators, and TIMER1_COMPA_vect, which handles the countdown. <br><br>  <b>Conclusion on indicators</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ display_number((Timer1/<span class="hljs-number"><span class="hljs-number">60</span></span>)/<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00001000</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer1/<span class="hljs-number"><span class="hljs-number">60</span></span>)%<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00000100</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer1%<span class="hljs-number"><span class="hljs-number">60</span></span>)/<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00000010</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer1%<span class="hljs-number"><span class="hljs-number">60</span></span>)%<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00000001</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer2/<span class="hljs-number"><span class="hljs-number">60</span></span>)/<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b10000000</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer2/<span class="hljs-number"><span class="hljs-number">60</span></span>)%<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b01000000</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer2%<span class="hljs-number"><span class="hljs-number">60</span></span>)/<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00100000</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); display_number((Timer2%<span class="hljs-number"><span class="hljs-number">60</span></span>)%<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0b00010000</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">0.25</span></span>); PORTD = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ PORTB = number_mask(number); PORTD = mask; }</code> </pre><br><br>  The <code>display</code> function uses the dynamic display method.  The fact is that each individual indicator has 9 contacts (7 for controlling segments, 1 for a point and 1 for power).  To manage 4 digits would need 36 contacts.  Too wasteful.  Therefore, the output of digits to the indicator with several numbers is organized according to the following principle: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/47d/93c/64e/47d93c64e1fe82795c545a87fa6d96f7.gif"></div><br><br>  The voltage is alternately applied to each of the common contacts, which allows you to highlight the desired number on the corresponding indicator using the same 8 control contacts.  At a sufficiently high output frequency, this looks to the eye as a static picture.  That is why all 8 power contacts of both indicators in the diagram are connected to 8 outputs of port D, and 16 control segments of contacts are connected in pairs and connected to 8 outputs of port B. Thus, the display function with a delay of 0.25 ms alternately outputs the required figure to each of the indicators .  At the end, all outputs that energize the indicators are disabled (command <code>PORTD = 0;</code> ).  If this is not done, the last displayed digit will continue to be lit until the next call to the display function, which will result in a brighter glow than the others. <br><br>  <b>Click processing</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_buttons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ handle_button(KEY_SETUP); handle_button(KEY_RESET); handle_button(KEY_PAUSE); handle_button(KEY_PLAYER1); handle_button(KEY_PLAYER2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_button</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_SETUP: bit = SETUP_BIT; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_RESET: bit = RESET_BIT; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_PAUSE: bit = PAUSE_BIT; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_PLAYER1: bit = PLAYER1_BIT; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_PLAYER2: bit = PLAYER2_BIT; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bit_is_clear(BUTTON_PIN, bit)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_pressed == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _delay_ms(DEBOUNCE_TIME); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bit_is_clear(BUTTON_PIN, bit)) { _pressed |= key; <span class="hljs-comment"><span class="hljs-comment">// key action switch (key) { case KEY_SETUP: process_setup(); break; case KEY_RESET: process_reset(); break; case KEY_PAUSE: process_pause(); break; case KEY_PLAYER1: process_player1(); break; case KEY_PLAYER2: process_player2(); break; } sound_on(15); } } } else { _pressed &amp;= ~key; } }</span></span></code> </pre><br><br>  This function in turn polls all 5 buttons and handles pressing if one happens.  The <code>bit_is_clear(BUTTON_PIN, bit)</code> registered by checking <code>bit_is_clear(BUTTON_PIN, bit)</code> , i.e.  a button is pressed if its corresponding input is connected to ground, which is what will happen, according to the diagram, when the button is pressed.  The delay of the <code>DEBOUNCE_TIME</code> duration and the re-check is needed to avoid multiple unnecessary operations due to contact bounce.  Storing the pressing status in the corresponding bits of the <code>_pressed</code> variable <code>_pressed</code> used to prevent repeated operation when the button is pressed for a long time. <br>  The functions of processing clicks are quite trivial and I suppose that they do not need additional comments. <br><br><div class="spoiler">  <b class="spoiler_title">Full text of the program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 4000000UL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;util/delay.h&gt; #include &lt;avr/interrupt.h&gt; #define DEBOUNCE_TIME 20 #define BUTTON_PIN PINC #define SETUP_BIT PC0 #define RESET_BIT PC1 #define PAUSE_BIT PC2 #define PLAYER1_BIT PC3 #define PLAYER2_BIT PC4 #define KEY_SETUP 0b00000001 #define KEY_RESET 0b00000010 #define KEY_PAUSE 0b00000100 #define KEY_PLAYER1 0b00001000 #define KEY_PLAYER2 0b00010000 volatile int ActiveTimer = 0; volatile int Timer1 = 0; volatile int Timer2 = 0; volatile int _buzzer = 0; volatile int _pressed = 0; // function declarations void init_io(); void init_data(); int number_mask(int num); void handle_buttons(); void handle_button(int key); void process_setup(); void process_reset(); void process_pause(); void process_timeoff(); void process_player1(); void process_player2(); void display(); void display_number(int mask, int number); void sound_on(int interval); void sound_off(); // interrupts ISR (TIMER0_OVF_vect) { display(); if (_buzzer &gt; 0) { _buzzer--; if (_buzzer == 0) sound_off(); } } ISR(TIMER1_COMPA_vect) { if (ActiveTimer == 1 &amp;&amp; Timer1 &gt; 0) { Timer1--; if (Timer1 == 0) process_timeoff(); } if (ActiveTimer == 2 &amp;&amp; Timer2 &gt; 0) { Timer2--; if (Timer2 == 0) process_timeoff(); } } int main(void) { init_io(); init_data(); sound_off(); sei(); while(1) { handle_buttons(); } return 0; } void init_io() { // set output DDRB = 0xFF; DDRD = 0xFF; // set input DDRC = 0b11100000; // pull-up resistors PORTC |= 0b00011111; // timer interrupts TIMSK = (1&lt;&lt;OCIE1A) | (1&lt;&lt;TOIE0); TCCR0 |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00); TCCR1B = (1&lt;&lt;CS12|1&lt;&lt;WGM12); //OCRn = (clock_speed / prescaler) * seconds - 1 OCR1A = (F_CPU / 256) * 1 -1; } void init_data() { Timer1 = 0; Timer2 = 0; ActiveTimer = 0; } int number_mask(int num) { switch (num) { case 0 : return 0xC0; case 1 : return 0xF9; case 2 : return 0xA4; case 3 : return 0xB0; case 4 : return 0x99; case 5 : return 0x92; case 6 : return 0x82; case 7 : return 0xF8; case 8 : return 0x80; case 9 : return 0x90; }; return 0; } void process_setup() { Timer1 += 60; Timer2 += 60; // overflow check (5940 seconds == 99 minutes) if (Timer1 &gt; 5940 || Timer2 &gt; 5940) { Timer1 = 0; Timer2 = 0; } } void process_reset() { init_data(); } void process_timeoff() { init_data(); sound_on(30); } void process_pause() { ActiveTimer = 0; } void process_player1() { ActiveTimer = 2; } void process_player2() { ActiveTimer = 1; } void handle_button(int key) { int bit; switch (key) { case KEY_SETUP: bit = SETUP_BIT; break; case KEY_RESET: bit = RESET_BIT; break; case KEY_PAUSE: bit = PAUSE_BIT; break; case KEY_PLAYER1: bit = PLAYER1_BIT; break; case KEY_PLAYER2: bit = PLAYER2_BIT; break; default: return; } if (bit_is_clear(BUTTON_PIN, bit)) { if (_pressed == 0) { _delay_ms(DEBOUNCE_TIME); if (bit_is_clear(BUTTON_PIN, bit)) { _pressed |= key; // key action switch (key) { case KEY_SETUP: process_setup(); break; case KEY_RESET: process_reset(); break; case KEY_PAUSE: process_pause(); break; case KEY_PLAYER1: process_player1(); break; case KEY_PLAYER2: process_player2(); break; } sound_on(15); } } } else { _pressed &amp;= ~key; } } void handle_buttons() { handle_button(KEY_SETUP); handle_button(KEY_RESET); handle_button(KEY_PAUSE); handle_button(KEY_PLAYER1); handle_button(KEY_PLAYER2); } void display() { display_number((Timer1/60)/10, 0b00001000); _delay_ms(0.25); display_number((Timer1/60)%10, 0b00000100); _delay_ms(0.25); display_number((Timer1%60)/10, 0b00000010); _delay_ms(0.25); display_number((Timer1%60)%10, 0b00000001); _delay_ms(0.25); display_number((Timer2/60)/10, 0b10000000); _delay_ms(0.25); display_number((Timer2/60)%10, 0b01000000); _delay_ms(0.25); display_number((Timer2%60)/10, 0b00100000); _delay_ms(0.25); display_number((Timer2%60)%10, 0b00010000); _delay_ms(0.25); PORTD = 0; } void display_number(int number, int mask) { PORTB = number_mask(number); PORTD = mask; } void sound_on(int interval) { _buzzer = interval; // put buzzer pin high PORTC |= 0b00100000; } void sound_off() { // put buzzer pin low PORTC &amp;= ~0b00100000; }</span></span></span></span></code> </pre><br></div></div><br><br>  The prototype was assembled on a breadboard: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/267/1cf/d40/2671cfd40ca07f5910d827dbdf937c1d.jpg"></div><br><br>  After testing the prototype, it's time to put all this stuff in the case, provide power, etc. <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/a6c/696/d3a/a6c696d3aee3c67320f154a78c546e24.jpg"></div><br><br>  Below is the final view of the device.  The clock is powered by a 9 volt ‚ÄúKrona‚Äù type battery.  Current consumption - 55 mA. <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage3/a6c/354/d32/a6c354d32fae0c7485b646174ac77b99.jpg"></div><br><br><h3>  Conclusion </h3><br>  Having spent $ 20-25 on equipment and a couple of evenings on the initial acquaintance with the microcontroller architecture and basic principles of work, you can start doing interesting DIY projects.  The article is dedicated to those who, like me at one time, think that it is difficult, long or expensive to start programming microcontrollers.  Believe me, starting is a lot easier than it sounds.  If there is interest and desire - try, you will not regret! <br><br>  Good luck to all programming! <br><br>  PS And finally, a small video demonstration of the prototype: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/KyOOOAfcelk%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700190,15700253&amp;usg=ALkJrhh3d3de9DG6i7NP6Hxe0Saq-c8NTA" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/205972/">https://habr.com/ru/post/205972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205960/index.html">Samsung Chord SDK for Android P2P games development</a></li>
<li><a href="../205962/index.html">Photo Contest Prize - a trip to the new laboratory of IBM Research Africa</a></li>
<li><a href="../205964/index.html">Daily backup of mysql-databases under windows</a></li>
<li><a href="../205966/index.html">If who else does not know how to use Google products correctly</a></li>
<li><a href="../205970/index.html">"The problem somehow agreed with the answer!"</a></li>
<li><a href="../205974/index.html">Altium Designer: the largest application (about 15,000,000 codelines) made in Delphi</a></li>
<li><a href="../205976/index.html">Megatrade: backup presentation, NetApp FAS and SyncSort storage integration</a></li>
<li><a href="../205978/index.html">DARPA plans to fix critical software vulnerabilities with gamers</a></li>
<li><a href="../205980/index.html">A passion for programming. Chapter 8. Be a Specialist</a></li>
<li><a href="../205982/index.html">The Pirate Bay has changed its location again.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>