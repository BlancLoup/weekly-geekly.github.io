<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SNAP Issues: Incomplete Object Paradigm and Premature Typing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! 


 In the previous article, we talked about the problem of the UNSN in general, in this article I would like to develop this topic ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SNAP Issues: Incomplete Object Paradigm and Premature Typing</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello colleagues! </p><br><p>  In the previous <a href="https://habrahabr.ru/post/321738">article,</a> we talked about the problem of the UNSN in general, in this article I would like to develop this topic and to show more specifically the problems of the UNSN. </p><br><p>  <strong>Main ideas</strong> : <em>SSSNs have two key problems: defective object paradigm and premature typing.</em>  <em>A defective object paradigm does not define the concept of an untyped object composition (composition is the most important element of any paradigm).</em>  <em>Premature typing limits the semantics of abstract concepts (semantic abstractions).</em> </p><a name="habracut"></a><br><h3 id="nepolnocennaya-obektnaya-paradigma">  Defective object paradigm </h3><br><p>  The object paradigm does not explicitly define the underlying mechanisms.  Any paradigm should define: </p><br><ol><li>  <strong>Primitive abstraction</strong> - defines the style of thinking of the paradigm and is the basic element of modeling. </li><li>  <strong>Composition of primitives</strong> - allows you to describe (model) systems of arbitrary complexity.  The composition itself must also be a primitive. </li><li>  <strong>An aggregative relationship</strong> is an abstract mechanism that links primitives in a composition.  Exactly the same mechanism manifests a primitive and in external interaction. </li><li>  <strong>Global state</strong> - where (but not how!) The abstract (observable) state of the system will be localized.  This property is not a paradigm, but a consequence of the computing architecture.  The result of the execution of any model can be detected only by a state change in the most general sense. </li></ol><br><p>  In principle, the <strong>paradigm is defined in an untyped form</strong> .  To use a paradigm (not to be confused with the use of PLs based on this paradigm), typing is not needed.  The paradigm should only determine how and on what mechanisms the model is built (that is, one or several compositions). </p><br><p>  More importantly, the composition, and not the primitive, is a "brick" in the simulation because of the complexity of the simulated systems.  <strong>Compositions are pure semantic abstractions</strong> , without tying types or any other "resources".  Semantic abstraction is a concept defined only by its name, and the name in any form, word or phrase. </p><br><p>  For example, the functional paradigm fully satisfies these properties (the same can be shown for the procedural / imperative paradigm): </p><br><ol><li>  Primitive abstraction: function - display of some input to some output. </li><li>  Functional composition: a chain of functions (mappings). </li><li>  Aggregation relation: the output of one function is fed to the input of another.  Those.  it is a connection in composition, and a function call as such. </li><li>  Global state: function arguments. </li></ol><br><p>  In OOP and the current definitions of the object paradigm, object composition is implied at best, at worst it does not exist.  The so-called <em>OOP postulates (abstraction / encapsulation / inheritance / polymorphism)</em> are an abstract set of concepts, the latter two generally refer to typing and have nothing to do with the object paradigm.  <em>Everything is an object.</em>  <em>Objects interact with each other.</em>  - here the object composition is at least implied, and somehow it can be logically derived. </p><br><p>  Of course, it is technically possible to see the compositions in one form or another in an OSNP, but the <strong>object composition should be the basic and basic mechanism of an NPNN, rather than an optional and secondary mechanism</strong> . </p><br><p>  What should the object paradigm look like (by analogy with the functional one): </p><br><ol><li>  Primitive abstraction: an object is an agent that supports some interaction protocol.  The protocol implies the rules and semantics of interaction for both parties. </li><li>  Object Composition: A graph of objects that support each other protocols.  The graph itself is an object with its own protocol. </li><li>  Aggregation relation: support for the object protocol (i.e., understanding and following the protocol).  The ability to support each other protocol links objects into a composition, as well as external interaction with a specific object is possible only if its protocol is supported. </li><li>  Global state: the internal state of the object. </li></ol><br><p>  A distinctive feature of the object paradigm is that the <strong>object, unlike the function and procedure, is not a purely transforming (ie, state-changing) primitive</strong> .  Since  the global state is distributed over objects (in SSNP this is encapsulation), the object protocol becomes a way to change state.  This should be reflected at the level of the object paradigm. </p><br><p>  For this, the object paradigm can use any paradigm with a transforming primitive, the actual functional and / or procedural paradigm for object protocols.  Both paradigms are used in the same abstract untyped form.  If the protocol of an object is based on a functional paradigm, we get a non-mutable object, and if on a procedural one, then it is mutable. </p><br><h3 id="prezhdevremennaya-tipizaciya">  Premature typing </h3><br><p>  Typification (type system) is ultimately necessary for a single purpose: <strong>formal verification of the correctness of</strong> programs.  The rules are set through the grammar of the PL, the translator based on the grammar performs the actual verification. </p><br><p>  The prematureness of typing lies in the fact that SSNPs (class-oriented) place a strong emphasis on the use of types, on the interpretation of classes as types.  The first thing that catches the eye (and both in practice when using NPNT and in textbooks / books when describing an NPNT) is the system of NPNT types, although in theory there should be an object paradigm with its composition and semantic abstractions.  Reference types and value types, polymorphism of subtypes, inheritance, Liskov substitution principle (LSP), method overloading, generics, abstract data types, functional type and FVP as elements of functional programming, type inference, type conversion, abstract classes and interfaces - All these concepts are a consequence of typing. </p><br><p>  On the one hand, typification is inevitable, since  Only correct programs can be executed.  But on the other hand, the emergence of typing imposes restrictions on the semantics of abstractions.  The idea is to postpone the appearance of typing as much later as possible.  In other words, a <strong>formal verification of correctness is carried out only after the object composition has been determined</strong> .  Ideally, the typing should be connected, its place somewhere before the compilation stage, and already at the compilation stage the verification itself is performed. </p><br><p>  If you look at typing more broadly, then <strong>premature typing in the SNAP is also manifested in the fixed interpretation of the abstract mechanisms of the object paradigm in the form of specific types of implementation</strong> .  A case in point is an object protocol (it is a contract) that is rigidly implemented as methods with fixed structure and behavior (parameters, return value) as one of the possible types of object protocol implementations.  The reason for adding modifiers of the async / wait methods in C # seems to have become clear that the rigid (synchronous) connection between the method call and the return value does not correspond to practical tasks.  In fact, this is the correction of the consequences of premature typing.  Again, ideally, a specific type of protocol implementation should be plug-in, with a specific implementation of any mechanism. </p><br><p>  The idea of ‚Äã‚Äãconnected typing seems to me in the form of several stages (this is not some kind of waterfall software development process, all stages occur while writing code without leaving the IDE). </p><br><p>  An object model is described (one / several untyped object compositions), which contains only semantic abstractions.  Objects, their protocols, composition of objects - everything is informally described in the form of semantic abstractions.  At this stage, the meaning of the object model follows from the concepts themselves. </p><br><p>  Then <strong>attribution</strong> occurs <strong>, i.e.</strong>  <strong>definition (binding) of untyped attributes for semantic abstractions</strong> .  As a result, attributed semantic abstractions are obtained.  Attributes are not data fields, properties, etc.  from the PLO / SNAP, the attributes define the <strong>semantic structure of the</strong> concept.  At the stage of attribution, there is no concept of state at all. </p><br><p>  The next stage is an <strong>abstract (untyped) implementation of object protocols</strong> (traditionally, the implementation of methods).  For object protocols, the implementation paradigm with transforming primitives is chosen (functional and / or procedural).  At this stage, attributes are already available, but they (like abstract functions and / or procedures) are still semantic abstractions.  The use of transforming paradigms at this stage implies an abstract state of objects (since there is something to transform), and the structure of this state derives precisely from the attributes of objects. </p><br><p>  Next comes a <strong>specific (typed) implementation</strong> - this is where the binding of types to objects and their attributes, as well as the parameters / arguments in the object protocols takes place.  Abstract procedures / functions of the abstract implementation of object protocols are concretized into traditional constructions such as class methods. </p><br><p>  Separately, I note that type binding occurs through the injection of expressions, and not an indication of the type name.  In other words, the type is derived from the type of the expression, which guarantees explicit initialization. </p><br><p>  After the concrete implementation stage, all concepts are typed, and formal verification can be carried out (as part of the broadcast). </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  The problems identified, in my opinion, are the reason why JSNF is fundamentally contradictory.  It is not surprising that the SOBNP and the PLO in their current form will always be the object of criticism. </p><br><p>  There is also a third problem, but it concerns not only SSNP, but also other languages: this is a syntax based on text grammar.  Currently, the support for text grammars in the IDE is so developed that the question arises: why do we need a textual representation of the code?  IDEs are manipulated by whole structural blocks such as methods or expressions that the text as such degenerates.  Compare versions in version control systems as text?  But this is only a question of the implementation of support in the IDE. </p><br><p>  Text-based grammar syntax limits meta-capabilities for the same reason that the meta-level requires additional support from the IDE, and there is little point in specifying them as text.  Those.  Meta-features are implemented only at the IDE level.  Essentially, an IDE is a grammar. </p><br><p>  Therefore, a global idea is to develop an object-oriented language (ie, IDE) based on a coherent object paradigm, without textual grammar and with developed meta-capabilities for transforming object compositions into readable code. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351424/">https://habr.com/ru/post/351424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351412/index.html">Logging in Adaptivist ScriptRunner</a></li>
<li><a href="../351414/index.html">Corporate IaaS digest: 25 materials on virtualization, infrastructure and information security</a></li>
<li><a href="../351416/index.html">TECO Editor: EMACS, I am your father</a></li>
<li><a href="../351418/index.html">FastTrack Training. "Network Basics". "Value of Collaboration Products from Cisco." Eddie Martin December 2012</a></li>
<li><a href="../351420/index.html">The digest of interesting materials for the mobile developer # 245 (March 12 - March 18)</a></li>
<li><a href="../351426/index.html">Restore Microsoft Money online features. Quotes</a></li>
<li><a href="../351428/index.html">Is it possible to teach artificial intelligence to joke?</a></li>
<li><a href="../351430/index.html">Auto Test Concepts</a></li>
<li><a href="../351432/index.html">Comparison of Material Design CSS frameworks</a></li>
<li><a href="../351434/index.html">Solving big problems with a small semantic analyzer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>