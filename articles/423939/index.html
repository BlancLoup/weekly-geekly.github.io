<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic programming or "Divide and Conquer"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses the similarities and differences between the two approaches to solving algorithmic problems: dynamic programming (dynamic progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic programming or "Divide and Conquer"</h1><div class="post__text post__text-html js-mediator-article">  This article discusses the similarities and differences between the two approaches to solving algorithmic problems: <b>dynamic programming</b> (dynamic programming) and the principle of <b>"divide and conquer"</b> (divide and conquer).  Comparison will be done using the example of two algorithms, respectively: <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search">binary search</a> (how to quickly find a number in a sorted array) and <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance">Levenshtein distance</a> (how to convert one line to another with the minimum number of operations). <br><br>  <i>I want to immediately note that this comparison and explanation does not claim exceptional accuracy.</i>  <i>And maybe even some university professors would like to deduct me :) This article is just my personal attempt to sort things out and understand what dynamic programming is and how the principle of ‚Äúdivide and conquer‚Äù participates.</i> <br><br>  So let's get started ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="image"><br><a name="habracut"></a><br><h3>  Problem </h3><br>  When I <a href="https://github.com/trekhleb/javascript-algorithms">began to study algorithms,</a> it was difficult <a href="https://github.com/trekhleb/javascript-algorithms">for</a> me to understand the basic idea of ‚Äã‚Äãdynamic programming (hereinafter <b>referred to</b> as <b>DP</b> , from Dynamic Programming) and how it differs from the divide and conquer approach (hereinafter <b>DC</b> , from divide-and-conquer).  When it comes to comparing these two paradigms, <a href="https://stackoverflow.com/questions/13538459/difference-between-divide-and-conquer-algo-and-dynamic-programming">many</a> usually <a href="https://stackoverflow.com/questions/13538459/difference-between-divide-and-conquer-algo-and-dynamic-programming">successfully use the Fibonacci function</a> to illustrate.  And this is a great illustration.  But it seems to me that when we use <b>the same</b> task to illustrate DP and DC, we lose one important detail that can help us catch the difference between the two approaches faster.  And this detail consists in the fact that these two techniques are best manifested in solving <b>various</b> types of problems. <br><br>  I am still in the process of studying DP and DC and cannot say that I fully understood these concepts.  But I still hope that this article will shed additional light and help to take another step in the study of such significant approaches as dynamic programming and divide-and-conquer. <br><br><h3>  DP and DC similarity </h3><br>  The way I see these two concepts now, I can conclude that <b>DP is an extended version of DC</b> . <br><br>  I would <b>not</b> consider them something completely different.  Because both of these concepts <b>recursively divide the problem into two or more subproblems of the same type</b> , until these subproblems are light enough to solve them head-on, directly.  Further, all solutions to subproblems are combined together in order to ultimately give an answer to the original, original problem. <br><br>  So why then do we still have two different approaches (DP and DC) and why I called dynamic programming an extension.  This is because dynamic programming can be applied to tasks that have certain <b>characteristics and limitations</b> .  And only in this case, DP expands DC with two techniques: <b>memoization</b> and <b>tabulation</b> . <br><br>  Let's get into the details a bit ... <br><br><h3>  Limitations and characteristics required for dynamic programming </h3><br>  As we have just figured out with you, there are two key characteristics that a task / problem must have in order for us to try to solve it using dynamic programming: <br><br><ol><li>  <a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal substructure</a> - it should be possible to make the optimal solution of the problem from the optimal solution of its subtasks. </li><li>  <a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Intersecting subproblems</a> - the problem must be broken down into subproblems, which in turn are reused many times.  In other words, a recursive approach to solving a problem would suggest a multiple ( <b>non</b> -one-time) solution of the same sub-problem, instead of producing new and unique sub-problems in each recursive cycle. </li></ol><br>  As soon as we can find these two characteristics in the problem we are considering, we can say that it can be solved using dynamic programming. <br><br><h3>  Dynamic programming as an extension of the divide and conquer principle </h3><br>  DP extends DC with the help of two techniques ( <b>memoization</b> and <b>tabulation</b> ), the purpose of which is to preserve sub-problem solutions for their further reuse.  Thus, solutions to subproblems are cached, which leads to a significant improvement in the performance of the algorithm.  For example, the time complexity of the ‚Äúnaive‚Äù recursive implementation of the Fibonacci function is <code>O(2 <sup>n</sup> )</code> .  At the same time, a solution based on dynamic programming is executed only in <code>(n)</code> . <br><br>  <b>Memoization (top-down cache filling)</b> is a caching technique that re-uses previously calculated subtask solutions.  The Fibonacci function using the memoization technique would look like this: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>Tabulation (filling the cache from bottom to top)</b> is a similar technique, but which is primarily focused on filling the cache, and not on finding a solution to sub-problems.  Calculation of values ‚Äã‚Äãthat need to be placed in the cache is easiest in this case to perform iteratively, and not recursively.  The Fibonacci function using the tabbing technique would look like this: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  You can read more about comparison of memoization and tabulation <a href="https://programming.guide/dynamic-programming-vs-memoization-vs-tabulation.html">here</a> . <br><br>  The basic idea that needs to be grasped in these examples is that since our DC problem has overlapping subproblems, we can use solution caching of subproblems using one of two caching techniques: memoization and tabulation. <br><br><h3>  So what is the difference between DP and DC in the end? </h3><br>  We familiarized with the limitations and prerequisites of using dynamic programming, as well as with the caching techniques used in the DP approach.  Let's try to summarize and portray the above thoughts in the following illustration: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="image"><br><br>  Let's try to solve a couple of problems using DP and DC to demonstrate both of these approaches in action. <br><br><h3>  An example of the principle of "divide and conquer": Binary search </h3><br>  <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">The binary</a> search algorithm is a search algorithm that finds the position of the requested item in a sorted array.  In binary search, we compare the value of the desired variable with the value of the element in the middle of the array.  If they are not equal, then half of the array in which the search element cannot be excluded from further search.  The search continues in that half of the array, in which the desired variable can be found until it is found.  If the next half of the array does not contain elements, the search is considered complete and we conclude that the array does not contain the desired value. <br><br>  <b>Example</b> <br><br>  The illustration below is an example of a binary search for the number 4 in an array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="image"><br><br>  Let's draw the same search logic, but in the form of a decision tree. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="image"><br><br>  You can see in this scheme a clear ‚Äúdivide and conquer‚Äù principle used to solve this problem.  We iteratively break our original array into sub-arrays and try to find the desired element already in them. <br><br>  Can we solve this problem using dynamic programming?  <b>No</b>  For the reason that this task <b>does not contain overlapping subproblems</b> .  Each time we break an array into parts, both parts are completely independent and not intersecting.  And according to the assumptions and limitations of dynamic programming that we discussed above, the subproblems must somehow intersect, they <b>must be repetitive</b> . <br><br>  Usually, whenever a decision tree looks exactly like a <b>tree</b> (and <b>not like a graph</b> ), it most likely means that there are no overlapping subproblems, <br><br>  <b>Algorithm implementation</b> <br><br>  <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/search/binary-search">Here</a> you can find the full source code of the binary search algorithm with tests and explanations. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Dynamic Programming Example: Edit Distance </h3><br>  Usually, when it comes to explaining dynamic programming, <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/fibonacci">the Fibonacci function is</a> used as an example.  But in our case, let's take a slightly more complex example.  The more examples, the easier it is to understand the concept. <br><br>  <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">The editing distance</a> (or Levenshtein distance) between two lines is the minimum number of operations to insert one character, delete one character, and replace one character with another, necessary to turn one line into another. <br><br>  <b>Example</b> <br><br>  For example, the editing distance between the words ‚Äúkitten‚Äù and ‚Äúsitting‚Äù is 3, since it is necessary to perform three editing operations (two replacements and one insert) in order to convert one line to another.  And it is impossible to find a faster conversion option with fewer operations: <br><br><ol><li>  kitten ‚Üí sitten (replacing "k" with "s") </li><li>  sitten ‚Üí sittin (replacing ‚Äúe‚Äù with ‚Äúi‚Äù) </li><li>  sittin ‚Üí sitting (insert ‚Äúg‚Äù completely). </li></ol><br>  <b>Algorithm application</b> <br><br>  The algorithm has a wide range of applications, for example, for spell checking, systems for correcting optical recognition, inaccurate string searches, etc. <br><br>  <b>Mathematical definition of the problem</b> <br><br>  Mathematically, the Levenstein distance between two lines <code>a, b</code> (with lengths | a | and <code>|b|</code> respectively) determines the <code>function lev(|a|, |b|)</code> , where: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="image"><br><br>  Notice that the first line in the <code>min</code> function corresponds to the <b>delete</b> operation, the second line corresponds to the <b>insert</b> operation, and the third line corresponds to the <b>replace</b> operation (in case the letters are not equal). <br><br>  <b>Explanation</b> <br><br>  Let's try to figure out what this formula tells us.  Take a simple example of finding the minimum editing distance between <b>ME</b> and <b>MY</b> lines.  Intuitively, you already know that the minimum editing distance equals one ( <b>1</b> ) replacement operation (replace ‚ÄúE‚Äù with ‚ÄúY‚Äù).  But let's formalize our solution and turn it into an algorithmic form in order to be able to solve more complex versions of this problem, such as transforming the word <b>Saturday</b> into <b>Sunday</b> . <br><br>  In order to apply the formula to the transformation ME ‚Üí MY, we first need to know the minimum editing distance between ME ‚Üí M, M ‚Üí MY and M ‚Üí M.  Next, we must choose the minimum distance from three distances and add one operation (+1) to the transformation E ‚Üí Y to it. <br><br>  So, we can already see the recursive nature of this solution: the minimum editing distance ME ‚Üí MY is calculated based on the three previous possible transformations.  Thus, we can already say that this is a divide-and-conquer algorithm. <br><br>  To further explain the algorithm, let's put two of our rows into the matrix: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="image"><br><br>  <b>The cell (0,1)</b> contains the red number 1. This means, then we need to perform 1 operation in order to convert M to the empty string - delete M. Therefore, we marked this number in red. <br><br>  <b>The cell (0,2)</b> contains the red number 2. This means that we need to perform 2 operations in order to transform the string ME into an empty string ‚Äî delete E, remove M. <br><br>  <b>The cell (1,0)</b> contains the green number 1. This means that we need 1 operation to transform the empty string into M - insert M. We marked the insert operation in green. <br><br>  <b>The cell (2,0)</b> contains the green number 2. This means that we need to perform 2 operations in order to convert the empty string to the string MY - insert Y, insert M. <br><br>  <b>Cell (1,1)</b> contains the number 0. This means that we do not need to do any operation in order to convert the string M to M. <br><br>  <b>The cell (1,2)</b> contains the red number 1. This means that we need to perform 1 operation in order to transform the string ME into M - delete E. <br><br>  And so on‚Ä¶ <br><br>  It does not look difficult for small matrices such as ours (only 3x3).  But how can we calculate the values ‚Äã‚Äãof all the cells for large matrices (such as for a 9x7 matrix with the transformation Saturday ‚Üí Sunday)? <br><br>  The good news is that, according to the formula, all we need to calculate the value of any cell with coordinates <code>(i,j)</code> is just the values ‚Äã‚Äãof 3 neighboring cells <code>(i-1,j)</code> , <code>(i-1,j-1)</code> , and <code>(i,j-1)</code> .  All we need to do is find the minimum value of the three neighboring cells and add one (+1) to this value if we have different letters in the i-th row and j-th column. <br><br>  So again, you can clearly see the recursive nature of this task. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="image"><br><br>  We also saw that we were dealing with a divide-and-conquer task.  But, can we apply dynamic programming to solve this problem?  Does this task satisfy the above-mentioned conditions of ‚Äú <b>overlapping problems</b> ‚Äù and ‚Äú <b>optimal substructures</b> ‚Äù?  <b>Yes</b>  Let's build a decision tree. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="image"><br><br>  First, you may notice that our decision tree looks more like a <b>decision graph</b> , rather <b>than</b> a <b>tree</b> .  You may also notice <b>several intersecting subtasks</b> .  It is also clear that it is impossible to reduce the number of operations and make it smaller than the number of operations from those three neighboring cells (subproblems). <br><br>  You may also notice that the value in each cell is calculated based on the previous values.  Thus, in this case, the <b>tabulation</b> technique is used (filling the cache in the bottom-up direction).  You will see this in the sample code below. <br><br>  Applying all these principles, we can solve more complex problems, for example, the transformation task Saturday ‚Üí Sunday: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="image"><br><br>  <b>Code example</b> <br><br>  <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/string/levenshtein-distance">Here</a> you can find the complete solution for finding the minimum editing distance with tests and explanations: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  findings </h3><br>  In this article, we compared two algorithmic approaches (‚Äúdynamic programming‚Äù and ‚Äúdivide and conquer‚Äù) to solving problems.  We found that dynamic programming uses the ‚Äúdivide and conquer‚Äù principle and can be applied to problem solving if the task contains intersecting subproblems and an optimal substructure (as is the case with Levenshtein distance).  Dynamic programming further uses memoization and tabulation techniques to save submissions for further reuse. <br><br>  I hope this article clarified rather than complicated the situation for those of you who tried to deal with such important concepts as dynamic programming and ‚Äúdivide and rule‚Äù :) <br><br>  You can find more algorithmic examples using dynamic programming with tests and explanations in the <a href="https://github.com/trekhleb/javascript-algorithms">JavaScript Algorithms and Data Structures</a> repository. <br><br>  Successful coding! </div><p>Source: <a href="https://habr.com/ru/post/423939/">https://habr.com/ru/post/423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423927/index.html">10 promising search engines to improve SEO</a></li>
<li><a href="../423931/index.html">How to bypass SMS-identification when connecting to public Wi-Fi networks?</a></li>
<li><a href="../423933/index.html">Microsoft Office Security: Embedded Objects</a></li>
<li><a href="../423935/index.html">Answers from the Embox stand to popular questions from the IT-festival TechTrain</a></li>
<li><a href="../423937/index.html">Privilege escalation in a Windows environment</a></li>
<li><a href="../423941/index.html">Reports from iOS mitap Redmadrobot</a></li>
<li><a href="../423943/index.html">Optimization of prices in offline retail</a></li>
<li><a href="../423945/index.html">The Supreme Court clarified the procedure for dealing with reposts and likes</a></li>
<li><a href="../423947/index.html">Our personal data is worth nothing.</a></li>
<li><a href="../423949/index.html">Universe corresponding to our current views may not be possible.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>