<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 8: Compile to Object Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents: 
 Part 1: Introduction and Lexical Analysis 
 Part 2: Implementing Parser and AST 
 Part 3: LLVM IR Code Generation 
 Part 4: Addin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 8: Compile to Object Code</h1><div class="post__text post__text-html js-mediator-article">  Table of contents: <br>  <a href="https://habrahabr.ru/post/119850/">Part 1: Introduction and Lexical Analysis</a> <br>  <a href="https://habrahabr.ru/post/120005/">Part 2: Implementing Parser and AST</a> <br>  <a href="https://habrahabr.ru/post/120424/">Part 3: LLVM IR Code Generation</a> <br>  <a href="https://habrahabr.ru/post/120516/">Part 4: Adding JIT and Optimizer Support</a> <br>  <a href="https://habrahabr.ru/post/120881/">Part 5: Language Expansion: Control Flow</a> <br>  <a href="https://habrahabr.ru/post/336080/">Part 6: Language Extension: User Defined Operators</a> <br>  <a href="https://habrahabr.ru/post/336468/">Part 7: Language Expansion: Variable Variables</a> <br>  <b>Part 8: Compile to Object Code</b> <br>  <a href="https://habrahabr.ru/post/336980/">Part 9: Add Debugging Information</a> <br>  <a href="https://habrahabr.ru/post/337240/">Part 10: Conclusion and other goodies LLVM</a> <br><br><img src="https://habrastorage.org/web/6e5/879/803/6e58798030874db09d00f2c502b3b104.png"><br><br><h3>  8.1.  Introduction </h3><br>  Welcome to chapter 8 of the guide ‚ÄúCreating a programming language using LLVM‚Äù.  This chapter describes how to compile programs in our language into object files. <br><a name="habracut"></a><br><h3>  8.2.  Target selection </h3><br>  LLVM has native support for cross-compiling.  You can compile into the architecture of your current machine, or compile for another architecture.  In this tutorial, we will aim the compiler at the current machine. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To determine the architecture that will serve the purpose, we use a string called the "target three".  It has the form &lt;arch&gt; &lt;sub&gt; - &lt;vendor&gt; - &lt;sys&gt; - &lt;abi&gt; (see the cross-compilation documentation). <br><br>  As an example, let's see what clang considers our current triple target: <br><br><pre><code class="bash hljs">$ clang --version | grep Target Target: x86_64-unknown-linux-gnu</code> </pre> <br>  Running this command on your machine may show something else, because you can use a different architecture or operating system. <br><br>  Fortunately, we don‚Äôt need to hardcode the target three so that it points to the current car.  LLVM provides the sys :: getDefaultTargetTriple function, which returns the target three for the current machine. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> TargetTriple = sys::getDefaultTargetTriple();</code> </pre> <br>  LLVM does not require us to use all the functions of the target platform (target).  For example, if we use only JIT, we do not need an assembler printer.  Similarly, if we target only a specific architecture, we can only use the functionality for this architecture. <br><br>  In this example, we initialize all the targets for generating the object code. <br><br><pre> <code class="cpp hljs">InitializeAllTargetInfos(); InitializeAllTargets(); InitializeAllTargetMCs(); InitializeAllAsmParsers(); InitializeAllAsmPrinters();</code> </pre><br>  Now we can use the top three targets to get the Target object: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Error; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Target = TargetRegistry::lookupTarget(TargetTriple, Error); <span class="hljs-comment"><span class="hljs-comment">//      ,      //   ,     // TargetRegistry      . if (!Target) { errs() &lt;&lt; Error; return 1; }</span></span></code> </pre><br><h3>  8.3.  Target Machine object </h3><br>  We also need an object of class TargetMachine.  This class provides a complete description of the machine we are targeting.  If we want to have specific capabilities on the target machine (for example, SSE), or a specific CPU (for example, Intel Sandylake), we must indicate this now. <br><br>  To see those features and CPUs that LLVM knows about, we can use llc.  For example, let's look at x86: <br><br><pre> <code class="bash hljs">$ llvm-as &lt; /dev/null | llc -march=x86 -mattr=<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre> <br>  Available CPUs for this target: <br><br>  amdfam10 <br>  athlon <br>  athlon-4 <br>  ... <br><br>  Available options for this target: <br><br>  16bit-mode - 16-bit mode (i8086). <br>  32bit-mode - 32-bit mode (80386). <br>  3dnow - Allow 3DNow instructions! <br>  3dnowa - Allow 3DNow instructions!  Athlon. <br>  ... <br><br>  For our example, we will use a regular CPU without additional features, options, or relocation model. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CPU = <span class="hljs-string"><span class="hljs-string">"generic"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Features = <span class="hljs-string"><span class="hljs-string">""</span></span>; TargetOptions opt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> RM = Optional&lt;Reloc::Model&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);</code> </pre> <br><h3>  8.4.  Module Object Configuration </h3><br>  Now we are ready to configure the module to determine the target and data model.  This is not strictly necessary, but the frontend manual recommends doing so.  Better optimization is possible if the target and data model are known. <br><br><pre> <code class="cpp hljs">TheModule-&gt;setDataLayout(TargetMachine-&gt;createDataLayout()); TheModule-&gt;setTargetTriple(TargetTriple);</code> </pre> <br><h3>  8.5.  Object Code Generation </h3><br>  We are ready to generate an object code!  Determine where we want to write the file: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Filename = <span class="hljs-string"><span class="hljs-string">"output.o"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code EC; <span class="hljs-function"><span class="hljs-function">raw_fd_ostream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Filename, EC, sys::fs::F_None)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EC) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Could not open file: "</span></span> &lt;&lt; EC.message(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Finally, we define a pass that generates the object code, and run it: <br><br><pre> <code class="cpp hljs">legacy::PassManager pass; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> FileType = TargetMachine::CGFT_ObjectFile; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TargetMachine-&gt;addPassesToEmitFile(pass, dest, FileType)) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"TargetMachine can't emit a file of this type"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } pass.run(*TheModule); dest.flush();</code> </pre> <br><h3>  8.6.  Putting it all together </h3><br>  Does the program work?  Let's try.  We need to compile our code, but note that the llvm-config arguments are different than in previous chapters. <br><br><pre> <code class="bash hljs">$ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy</code> </pre> <br>  Let's run, and define a simple averaging function.  Press Ctrl-D when it is finished. <br><br><pre> <code class="bash hljs">$ ./toy ready&gt; def average(xy) (x + y) * 0.5; ^D</code> </pre><br>  File output.o recorded <br>  We have an object file!  To check it, we will write a simple program and link it to this file.  Here is the source code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; extern "C" { double average(double, double); } int main() { std::cout &lt;&lt; "average of 3.0 and 4.0: " &lt;&lt; average(3.0, 4.0) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  We link our program with output.o and verify that the result is what we expect: <br><br><pre> <code class="bash hljs">$ clang++ main.cpp output.o -o main $ ./main average of 3.0 and 4.0: 3.5</code> </pre> <br><h3>  8.7.  Full code listing </h3><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/APFloat.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/Optional.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/STLExtras.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/BasicBlock.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Constants.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Function.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Instructions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/FileSystem.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/Host.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/raw_ostream.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/TargetRegistry.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetMachine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetOptions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;cassert&gt; #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;map&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;system_error&gt; #include &lt;utility&gt; #include &lt;vector&gt; using namespace llvm; using namespace llvm::sys; //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// //     [0-255]    ,    //  enum Token { tok_eof = -1, //  tok_def = -2, tok_extern = -3, //   tok_identifier = -4, tok_number = -5, //  tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, //  tok_binary = -11, tok_unary = -12, //   tok_var = -13 }; static std::string IdentifierStr; //   tok_identifier static double NumVal; //   tok_number /// gettok -       static int gettok() { static int LastChar = ' '; //   while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; if (IdentifierStr == "if") return tok_if; if (IdentifierStr == "then") return tok_then; if (IdentifierStr == "else") return tok_else; if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; if (IdentifierStr == "var") return tok_var; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   .   EOF. if (LastChar == EOF) return tok_eof; // ,     ascii-. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// //    ( ) //===----------------------------------------------------------------------===// namespace { /// ExprAST -    . class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST -      "1.0". class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST -   , , "a". class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;Name) : Name(Name) {} Value *codegen() override; const std::string &amp;getName() const { return Name; } }; /// UnaryExprAST -      class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr&lt;ExprAST&gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST -      class BinaryExprAST : public ExprAST { char Op; std::unique_ptr&lt;ExprAST&gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST -      class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; public: CallExprAST(const std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST -    if/then/else. class IfExprAST : public ExprAST { std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then, std::unique_ptr&lt;ExprAST&gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST -    for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body; public: ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start, std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step, std::unique_ptr&lt;ExprAST&gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// VarExprAST -    var/in class VarExprAST : public ExprAST { std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; std::unique_ptr&lt;ExprAST&gt; Body; public: VarExprAST( std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames, std::unique_ptr&lt;ExprAST&gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST -    "" , ///    ,    (, ,  /// ,  ),   . class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string &amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST -      class FunctionAST { std::unique_ptr&lt;PrototypeAST&gt; Proto; std::unique_ptr&lt;ExprAST&gt; Body; public: FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } //     //===----------------------------------------------------------------------===// //  //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -  /// ,    . getNextToken     ///     CurTok  . static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -     , ///   static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -       . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -     . std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) { fprintf(stderr, "Error: %s\n", Str); return nullptr; } std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr&lt;ExprAST&gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() { auto Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal); getNextToken(); //   return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() { getNextToken(); //  (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError("expected ')'"); getNextToken(); //  ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // //  . if (CurTok != '(') //     return llvm::make_unique&lt;VariableExprAST&gt;(IdName); //  getNextToken(); //  ( std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return llvm::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() { getNextToken(); //  if. // . auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError("expected then"); getNextToken(); //  then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError("expected else"); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return llvm::make_unique&lt;IfExprAST&gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() { getNextToken(); //  for. if (CurTok != tok_identifier) return LogError("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '=') return LogError("expected '=' after for"); getNextToken(); //  '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError("expected ',' after for start value"); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; //   . std::unique_ptr&lt;ExprAST&gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError("expected 'in' after for"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() { getNextToken(); //  var. std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; //      if (CurTok != tok_identifier) return LogError("expected identifier after var"); while (true) { std::string Name = IdentifierStr; getNextToken(); //  . //    std::unique_ptr&lt;ExprAST&gt; Init = nullptr; if (CurTok == '=') { getNextToken(); //  '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); //   ,   . if (CurTok != ',') break; getNextToken(); //  ','. if (CurTok != tok_identifier) return LogError("expected identifier list after var"); } //        'in'. if (CurTok != tok_in) return LogError("expected 'in' keyword after 'var'"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() { switch (CurTok) { default: return LogError("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr&lt;ExprAST&gt; ParseUnary() { //      ,     . if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); //    ,   int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return llvm::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS) { //    ,    while (true) { int TokPrec = GetTokPrecedence(); //    ,    //  ,   if (TokPrec &lt; ExprPrec) return LHS; //   ,     int BinOp = CurTok; getNextToken(); //    //       auto RHS = ParseUnary(); if (!RHS) return nullptr; //  BinOp    RHS,    RHS,  //    RHS   LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } //  LHS/RHS. LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr&lt;ExprAST&gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = , 1 = , 2 = . unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected unary operator"); FnName = "unary"; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected binary operator"); FnName = "binary"; FnName += (char)CurTok; Kind = 2; getNextToken(); //  ,    if (CurTok == tok_number) { if (NumVal &lt; 1 || NumVal &gt; 100) return LogErrorP("Invalid precedence: must be 1..100"); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP("Expected ')' in prototype"); // . getNextToken(); //  ')'. // ,     if (Kind &amp;&amp; ArgNames.size() != Kind) return LogErrorP("Invalid number of operands for operator"); return llvm::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() { getNextToken(); // //  def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { //    auto Proto = llvm::make_unique&lt;PrototypeAST&gt;("__anon_expr", std::vector&lt;std::string&gt;()); return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// static LLVMContext TheContext; static IRBuilder&lt;&gt; Builder(TheContext); static std::unique_ptr&lt;Module&gt; TheModule; static std::map&lt;std::string, AllocaInst *&gt; NamedValues; static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { //  ,       . if (auto *F = TheModule-&gt;getFunction(Name)) return F; //  ,         // . auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-&gt;second-&gt;codegen(); //    ,  null. return nullptr; } /// CreateEntryBlockAlloca -   alloca    /// .     . static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, const std::string &amp;VarName) { IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(), TheFunction-&gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), nullptr, VarName); } Value *NumberExprAST::codegen() { return ConstantFP::get(TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // ,       Value *V = NamedValues[Name]; if (!V) return LogErrorV("Unknown variable name"); //   return Builder.CreateLoad(V, Name.c_str()); } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-&gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string("unary") + Opcode); if (!F) return LogErrorV("Unknown unary operator"); return Builder.CreateCall(F, OperandV, "unop"); } Value *BinaryExprAST::codegen() { //    '=', ..     LHS   if (Op == '=') { //  ,  LHS   // ,     RTTI, .. LLVM   //  .    LLVM  RTTI     // dynamic_cast    . VariableExprAST *LHSE = static_cast&lt;VariableExprAST *&gt;(LHS.get()); if (!LHSE) return LogErrorV("destination of '=' must be a variable"); //   RHS. Value *Val = RHS-&gt;codegen(); if (!Val) return nullptr; //   Value *Variable = NamedValues[LHSE-&gt;getName()]; if (!Variable) return LogErrorV("Unknown variable name"); Builder.CreateStore(Val, Variable); return Val; } Value *L = LHS-&gt;codegen(); Value *R = RHS-&gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //  bool 0/1  double 0.0 or 1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp"); default: break; } //      ,     .  //    . Function *F = getFunction(std::string("binary") + Op); assert(F &amp;&amp; "binary operator not found!"); Value *Ops[] = {L, R}; return Builder.CreateCall(F, Ops, "binop"); } Value *CallExprAST::codegen() { //       Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV("Unknown function referenced"); // ,    . if (CalleeF-&gt;arg_size() != Args.size()) return LogErrorV("Incorrect # arguments passed"); std::vector&lt;Value *&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder.CreateCall(CalleeF, ArgsV, "calltmp"); } Value *IfExprAST::codegen() { Value *CondV = Cond-&gt;codegen(); if (!CondV) return nullptr; //          0.0. CondV = Builder.CreateFCmpONE( CondV, ConstantFP::get(TheContext, APFloat(0.0)), "ifcond"); Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //    then  else.   'then'  //   BasicBlock *ThenBB = BasicBlock::Create(TheContext, "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(TheContext, "else"); BasicBlock *MergeBB = BasicBlock::Create(TheContext, "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB); //  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;codegen(); if (!ThenV) return nullptr; Builder.CreateBr(MergeBB); //    'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock(); //   "else" TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;codegen(); if (!ElseV) return nullptr; Builder.CreateBr(MergeBB); //    'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock(); //    TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; } //  for-loop : // var = alloca double // ... // start = startexpr // store start -&gt; var // goto loop // loop: // ... // bodyexpr // ... // loopend: // step = stepexpr // endcond = endexpr // // curvar = load var // nextvar = curvar + step // store nextvar -&gt; var // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //   alloca      AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); //    ,  'variable'    Value *StartVal = Start-&gt;codegen(); if (!StartVal) return nullptr; //    alloca. Builder.CreateStore(StartVal, Alloca); //       ,     // . BasicBlock *LoopBB = BasicBlock::Create(TheContext, "loop", TheFunction); //        LoopBB. Builder.CreateBr(LoopBB); //    LoopBB. Builder.SetInsertPoint(LoopBB); //  ,    PHI-.   //   ,    ,   . AllocaInst *OldVal = NamedValues[VarName]; NamedValues[VarName] = Alloca; //   . ,    ,   //  BB. ,    ,   ,   //  . if (!Body-&gt;codegen()) return nullptr; //    Value *StepVal = nullptr; if (Step) { StepVal = Step-&gt;codegen(); if (!StepVal) return nullptr; } else { //   ,  1.0. StepVal = ConstantFP::get(TheContext, APFloat(1.0)); } //    Value *EndCond = End-&gt;codegen(); if (!EndCond) return nullptr; // , ,   alloca.   //        Value *CurVar = Builder.CreateLoad(Alloca, VarName.c_str()); Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, "nextvar"); Builder.CreateStore(NextVar, Alloca); //          0.0. EndCond = Builder.CreateFCmpONE( EndCond, ConstantFP::get(TheContext, APFloat(0.0)), "loopcond"); //   " "    BasicBlock *AfterBB = BasicBlock::Create(TheContext, "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB); //    . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //    0.0. return Constant::getNullValue(Type::getDoubleTy(TheContext)); } Value *VarExprAST::codegen() { std::vector&lt;AllocaInst *&gt; OldBindings; Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //       for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string &amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get(); //     ,   //      ,   // l  : // var a = 1 in // var a = a in ... #    'a'. Value *InitVal; if (Init) { InitVal = Init-&gt;codegen(); if (!InitVal) return nullptr; } else { //    ,  0.0. InitVal = ConstantFP::get(TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder.CreateStore(InitVal, Alloca); //    OldBindings.push_back(NamedValues[VarName]); //   NamedValues[VarName] = Alloca; } //       Value *BodyVal = Body-&gt;codegen(); if (!BodyVal) return nullptr; //    for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; //     return BodyVal; } Function *PrototypeAST::codegen() { //   : double(double,double) etc. std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); //    unsigned Idx = 0; for (auto &amp;Arg : F-&gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { //      FunctionProtos,   //    . auto &amp;P = *Proto; FunctionProtos[Proto-&gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; //   ,   if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); //        BasicBlock *BB = BasicBlock::Create(TheContext, "entry", TheFunction); Builder.SetInsertPoint(BB); //      NamedValues. NamedValues.clear(); for (auto &amp;Arg : TheFunction-&gt;args()) { //   alloca   AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); //     alloca. Builder.CreateStore(&amp;Arg, Alloca); //      NamedValues[Arg.getName()] = Alloca; } if (Value *RetVal = Body-&gt;codegen()) { //  . Builder.CreateRet(RetVal); //    verifyFunction(*TheFunction); return TheFunction; } //    ,   TheFunction-&gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// //     JIT //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { //    TheModule = llvm::make_unique&lt;Module&gt;("my cool jit", TheContext); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-&gt;codegen()) { fprintf(stderr, "Read function definition:"); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); } } else { //       getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-&gt;codegen()) { fprintf(stderr, "Read extern: "); FnIR-&gt;print(errs()); fprintf(stderr, "\n"); FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST); } } else { //       getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { FnAST-&gt;codegen(); } else { //       getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { switch (CurTok) { case tok_eof: return; case ';': //        getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,        //===----------------------------------------------------------------------===// #ifdef LLVM_ON_WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar,  double,  0. extern "C" DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf,  double   "%f\n",  0. extern "C" DLLEXPORT double printd(double X) { fprintf(stderr, "%f\n", X); return 0; } //===----------------------------------------------------------------------===// //  main //===----------------------------------------------------------------------===// int main() { //     // 1 -    BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . //    fprintf(stderr, "ready&gt; "); getNextToken(); InitializeModuleAndPassManager(); //    MainLoop(); //   InitializeAllTargetInfos(); InitializeAllTargets(); InitializeAllTargetMCs(); InitializeAllAsmParsers(); InitializeAllAsmPrinters(); auto TargetTriple = sys::getDefaultTargetTriple(); TheModule-&gt;setTargetTriple(TargetTriple); std::string Error; auto Target = TargetRegistry::lookupTarget(TargetTriple, Error); //    ,        //   ,     // TargetRegistry      if (!Target) { errs() &lt;&lt; Error; return 1; } auto CPU = "generic"; auto Features = ""; TargetOptions opt; auto RM = Optional&lt;Reloc::Model&gt;(); auto TheTargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM); TheModule-&gt;setDataLayout(TheTargetMachine-&gt;createDataLayout()); auto Filename = "output.o"; std::error_code EC; raw_fd_ostream dest(Filename, EC, sys::fs::F_None); if (EC) { errs() &lt;&lt; "Could not open file: " &lt;&lt; EC.message(); return 1; } legacy::PassManager pass; auto FileType = TargetMachine::CGFT_ObjectFile; if (TheTargetMachine-&gt;addPassesToEmitFile(pass, dest, FileType)) { errs() &lt;&lt; "TheTargetMachine can't emit a file of this type"; return 1; } pass.run(*TheModule); dest.flush(); outs() &lt;&lt; "Wrote " &lt;&lt; Filename &lt;&lt; "\n"; return 0; }</span></span></span></span></code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/336876/">https://habr.com/ru/post/336876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336866/index.html">Big Data and Odnoklassniki: what they do with the data in the 2nd most visited social network in Russia</a></li>
<li><a href="../336868/index.html">How to write a good SLA</a></li>
<li><a href="../336870/index.html">Joystick on AT91SAM7</a></li>
<li><a href="../336872/index.html">Creating an IT self-service portal using the example of MS SCCM and ServiceNow integration. Part 1</a></li>
<li><a href="../336874/index.html">Event digest for HR specialists in the IT field for September 2017</a></li>
<li><a href="../336878/index.html">We work on the Federal Law-54: How to automate couriers to meet the new requirements of the law?</a></li>
<li><a href="../336880/index.html">News online courses Mail.Ru Group: "Programming in Python"</a></li>
<li><a href="../336882/index.html">30 theses from a speech by Vitalik Buterin in Moscow</a></li>
<li><a href="../336884/index.html">Some useful improvements in the company profile on ‚ÄúMy Circle‚Äù</a></li>
<li><a href="../336886/index.html">All on the shelves: thematic web analytics on the Internet with Rambler / Top 100, part 2. Analytics of blocks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>