<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript start performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Web developers know how easily the sizes of web pages grow. But loading a page is not just transferring bytes over a wire. When the browser has loaded...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript start performance</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ebc/fb2/61f/ebcfb261feb64a00be6d073a1af6514f.jpg"><br><br>  Web developers know how easily the sizes of web pages grow.  But loading a page is not just transferring bytes over a wire.  When the browser has loaded the scripts, it needs to be parsed, interpreted, and run.  In the article, we will carefully look at this phase and find out why it may cause a slowdown in the launch of your application and how to fix it. <br><a name="habracut"></a><br>  Historically, we don‚Äôt spend much time optimizing JavaScript parsing / compiling.  We believe that the scripts will be instantly parsed and executed as soon as the parser reaches the <code>&lt;script&gt;</code> .  But it is not.  Here is a simplified diagram of how V8 works: <br><br><img src="https://habrastorage.org/files/35a/7d1/dbd/35a7d1dbdb5042209b2e9b47bb754d0a.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is an idealized representation of our working pipeline. <br><br>  Let's look at some key phases. <br><br><h2>  <i>What slows down the loading of our web apps?</i> </h2><br>  During startup, the JavaScript engine spends considerable time on parsing, compiling, and executing scripts.  This is important, because if the engine does this for quite a long time, the beginning of user interaction with our site <b>will be delayed</b> .  Suppose they see a button, but for a few seconds it does not respond to pressing.  This can lead to degradation of UX. <br><br><img src="https://habrastorage.org/files/eb1/409/eb6/eb1409eb60784ff7ac393f85174d491b.png"><br>  <i>The duration of parsing and compiling for a popular site using statistics runtime calls V8 in Chrome Canary.</i>  <i>Please note, as already slow on desktop computers parsing and compiling may become even slower on smartphones.</i> <br><br>  Runtime is important for <b>performance sensitive</b> code.  In fact, the JS V8 engine spends a lot of time parsing and compiling sites like Facebook, Wikipedia and Reddit: <br><br><img src="https://habrastorage.org/files/761/e22/236/761e22236e7c46fda6c219040facefa7.png"><br>  <i>Pink areas (JavaScript) reflect the time spent on V8 and Blink C ++, orange and yellow - the duration of the parsing and compiling</i> <br><br>  For many sites and frameworks, the duration of parsing and compiling is a weak point.  The following are cited by Sebastian Markbage (Facebook) and Rob Vormald (Google): <br><br><blockquote>  Parsing / compiling is a huge problem.  I will ask our guys to share the data.  However, you need to measure the disconnect. <br>  - <a href="https://twitter.com/sebmarkbage/status/804072069608525824">@sebmarkbage</a> <br><br>  I understand this data in such a way that the main startup costs in Angular are mainly in JS parsing, before we even deal with the DOM. <br>  - <a href="https://twitter.com/robwormald/status/808947196439601152">@robwormald</a> </blockquote><br><img src="https://habrastorage.org/files/a7c/d8a/3cb/a7cd8a3cb5e04adbbc504771d9456996.jpg"><br>  <i>Sam Sakkone reveals the cost of JS-parsing in " <a href="https://www.youtube.com/watch%3Fv%3DRWLzUnESylc">Planning for Performance</a> "</i> <br><br>  The ‚Äúmobility‚Äù of the web is increasing, and it is important to understand that on <b>smartphones, parsing / compiling can be 2-5 times longer than on desktop computers</b> .  And the performance of top-end smartphones is very different from any Moto G4.  This underlines the importance of testing on representative equipment (and not just on top-end equipment!) To check the quality of user experience. <br><br><img src="https://habrastorage.org/files/0a9/841/ac0/0a9841ac05174fb0b175b292e7f2eadd.jpg"><br>  <i><a href="https://docs.google.com/a/google.com/spreadsheets/d/1Zk0HDGvqNO_8jaudF2jwTItI-H0blD8_ShHfLsnp_Us/edit%3Fusp%3Dsharing">The duration of parsing</a> 1-package (bundle) JavaScript on desktop and mobile devices of different classes.</i>  <i>Please note that smart phones like the iPhone 7 are close in performance to the MacBook Pro, and compare the drop in performance on average devices</i> <br><br>  If our web applications use huge packages, then the use of modern delivery methods, such as code-splitting, tree-shaking and caching by the Service Worker, can have a very strong impact.  On the other hand, <b>even a small package, clumsily written or using mediocre libraries, can lead to the main thread being stuck for a long time on compiling or function calls</b> .  It is important to evaluate the picture holistically, knowing exactly where the bottlenecks are. <br><br><h2>  Is the duration of JavaScript parsing and compiling a bottleneck for an average site? </h2><br>  Surely now you are thinking: "But I'm not Facebook."  You may ask: ‚ÄúHow long is the parsing and compiling time for average sites?‚Äù Let's explore this question! <br><br>  I spent two months <a href="https://github.com/GoogleChrome/discovery/issues/1">measuring the</a> performance of a large number of working sites (more than 6 thousand), built using different libraries and frameworks - React, Angular, Ember and Vue.  Most of the tests were reproduced on WebPageTest, so you can easily run them yourself or carefully examine the results.  Here are some conclusions. <br><br>  <b>Applications become interactive after 8 seconds on desktops (cable connection) and after 16 seconds on smartphones (Moto G4 with 3G):</b> <br><br><img src="https://habrastorage.org/files/75b/e80/4de/75be804de4214dc7a126b38ed7c069f2.png"><br><br>  <b>What is the reason?</b>  <b>On desktops, the launch of most applications takes an average of about 4 seconds (parsing / compiling / execution).</b> <br><br><img src="https://habrastorage.org/files/b58/e9d/107/b58e9d10784c47d5b542ac8f5e87fc5c.png"><br><br>  On smartphones, the duration of parsing was about 36% higher than on desktops. <br><br><img src="https://habrastorage.org/files/eab/6dc/337/eab6dc337e3c402cbad720daad98a169.png"><br><br>  <b>Everyone used huge js packages?</b>  <b>Not as big as I expected, but there is still room for improvement.</b>  On average, developers used 410 KB packages for their pages, compressed with gzip.  This is consistent with HTTP Archive data - 420 Kb JS per page on average.  Some freaks transmitted by cable up to 10 MB. <br><br><img src="https://habrastorage.org/files/3f2/5a4/f0c/3f25a4f0c5c34d8bb1d470ce65a7f2e6.png"><br>  <i><a href="httparchive.org/trends.php%3Fs%3DAll%26minlabel%3DNov%2B15%2B2015%26maxlabel%3DNov%2B15%2B2016">HTTP Archive statistics</a> : an average of 420 Kb of javascript per page</i> <br><br>  <b>The size of the scripts is important, but not decisive.</b>  <b>The duration of parsing and compiling does not necessarily depend linearly on the size of the scripts.</b>  More compact JavaScript packages generally demonstrate faster loading (depending on the browser, device and connection), but 200 KB JS! == 200 KB of something else, so the duration of parsing and compiling can vary greatly. <br><br><h2>  Modern measurement of the duration of parsing and compiling JavaScript </h2><br>  <b>Developer Tools in Chrome</b> <br><br>  Go to the Timeline (Performance panel)&gt; Bottom-Up / Call and see the Tree / Event Log, from which you get an idea of ‚Äã‚Äãthe time spent parsing and compiling.  For the sake of a more detailed picture (for example, the duration of parsing, preparsing, or lazy compiling), you can include <b>statistics for V8 runtime calls</b> .  In Canary, this is done like this: Experiments&gt; V8 Runtime Call Stats on Timeline. <br><br><img src="https://habrastorage.org/files/706/648/043/7066480430374ec9b40eaef1ed8283e9.jpg"><br><br>  <b>Chrome Tracing</b> <br><br>  <b>about: tracing</b> - a low-level tracing tool in Chrome will allow you to use the category disabled-by-default-v8.runtime_stats to draw deeper conclusions about what the time spent running V8 is spent on.  In the engine there is a fresh <a href="https://docs.google.com/presentation/d/1Lq2DD28CGa7bxawVH_2OcmyiTiBn74dvC6vn2essroY/edit">step by step guide</a> to using the tool. <br><br><img src="https://habrastorage.org/files/bcb/cf4/794/bcbcf47940dc4731bf10114cac8711d5.jpg"><br><br>  <b>WebPageTest</b> <br><br><img src="https://habrastorage.org/files/480/54e/eb9/48054eeb958045339834cf30c8bd6e5f.png"><br><br>  The Processing Breakdown page on WebPageTest contains data on the compilation duration in V8, EvaluateScript and FunctionCall, when we perform tracing using the included Chrome&gt; Capture Dev Tools Timeline tool. <br><br>  You can also extract runtime call statistics by setting the custom trace category disabled-by-default-v8.runtime_stats (Pat Minen from WPT does this by default!). <br><br><img src="https://habrastorage.org/files/dcb/356/8a7/dcb3568a7a9a45c5940c350b5aea1b26.png"><br><br>  How can you benefit from this: <a href="https://gist.github.com/addyosmani/45b135900a7e3296e22673148ae5165b">https://gist.github.com/addyosmani/45b135900a7e3296e22673148ae5165b</a> . <br><br>  <b>User Timing</b> <br><br>  You can measure the duration of parsing using the <a href="https://w3c.github.io/user-timing/">User Timing API</a> : <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg);"></twitter-widget><blockquote class="twitter-tweet twitter-tweet-error" align="center" data-twitter-extracted-i155290009514871466="true"><p lang="en" dir="ltr">  Measuring this stuff is extremely tricky!  In short, this is the error I made: <a href="https://t.co/O1uisPXxEG">pic.twitter.com/O1uisPXxEG</a> </p>  - Nolan Lawson (@nolanlawson) <a href="https://twitter.com/nolanlawson/status/817077573012180992">January 5, 2017</a> </blockquote><script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  The third <code>&lt;script&gt;</code> is unimportant here.  But it becomes important, being the first <code>&lt;script&gt;</code> , separated from the second ( <i>performance.mark ()</i> starts before <code>&lt;script&gt;</code> ). <br><br>  <i>This approach can affect subsequent reboots by the V8 preparser.</i>  <i>This can be circumvented by adding a random string value at the end of the script, Nolan Lawson did something similar in his benchmarks.</i> <br><br>  To measure the effect of the duration of JavaScript parsing, I use a similar approach using Google Analytics: <br><br><img src="https://habrastorage.org/files/c34/203/225/c3420322595148918aa6bfee40e08eec.jpg"><br>  <i>Custom parse measurements allow you to measure the duration of JavaScript parsing for real users and devices visiting my pages</i> <br><br>  <b>DeviceTiming</b> <br><br>  <a href="https://github.com/danielmendel/DeviceTiming">DeviceTiming</a> tool will help in measuring the duration of parsing / compiling scripts in a controlled environment.  Local scripts are placed in an instrumental wrapper, and each time you access pages from different devices (laptops, smartphones, tablets), we can compare the duration of parsing / execution locally.  Daniel Especet‚Äôs ‚Äú <a href="http://talks.desp.in/unpacking-the-black-box">Benchmarking JS Parsing and Execution on Mobile Devices</a> ‚Äù talked about this tool in more detail. <br><br><img src="https://habrastorage.org/files/3f0/0d2/52d/3f00d252d3d44efda517ad1055118f25.jpg"><br><br><h2>  How can I reduce the duration of JavaScript parsing? </h2><br><ul><li>  <b>Less javascript.</b>  The fewer scripts you need to parse, the shorter the parsing / compiling phase. </li><li>  <b>Use the code-splitting technique only to deliver the code that is needed to direct the user through the page, and load the rest in lazy mode.</b>  In many cases this will help avoid parsing a large amount of js.  Patterns like <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL</a> , which Flipkart, Housing.com and Twitter use today, are useful in implementing this approach. </li><li>  <b>Use script streaming.</b>  Previously, V8 suggested that developers use async / defer to reduce parsing time by using <a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html">streaming scripts</a> by 10‚Äì20%.  At a minimum, this allows the HTML parser to detect the source earlier, pass the task to the streaming download stream and not slow down the parsing of the document.  Now this is done for parser-blocking scripts, and I do not think there are any other tasks.  <b>If you have one streamer stream, V8 recommends loading larger packages first.</b> </li><li>  <b>Measure the cost of parsing dependencies</b> - libraries and frameworks.  Wherever possible, switch to dependencies with faster parsing (for example, instead of React, it's better to use Preact or Inferno, which require less bytes for initial loading and faster parsing / compiling).  Paul Lewis recently in his article raised the issue of the cost of <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">bootstrap frameworks</a> .  Sebastian Markbager also <a href="https://twitter.com/sebmarkbage/status/829733454119989248">pointed out a</a> <b>good way to measure the cost of starting up frameworks ‚Äî first rendering the view, erasing and rendering again, this will give you an understanding of its scalability</b> .  The first rendering plays the role of warming up for lazily compiled code, a larger tree which can benefit from scaling. </li></ul><br>  If the JavaScript framework you have selected supports ahead-of-time compilation (AoT) compilation mode, this will significantly help reduce the duration of parsing / compiling.  For example, this benefits Angular applications: <br><br><img src="https://habrastorage.org/files/29a/f8d/662/29af8d6628f54530930f6650f10c1f51.png"><br>  <i>Speech by Nolan Lawson " <a href="https://channel9.msdn.com/Blogs/msedgedev/nolanlaw-web-perf-crisis">Solving the Web Performance Crisis</a> "</i> <br><br><h2>  What do <i>browsers</i> do to speed up parsing / compiling? </h2><br>  Not only the developers collect real statistics to find how to improve the launch speed.  Thanks to the V8, it was discovered that Octane, one of the oldest benchmarks, was a bad proxy for measuring the real performance of 25 popular sites.  Octane can be a proxy: <br><br><ol><li>  for JS frameworks (usually not a mono / polymorphic code), </li><li>  for launching paged applications (real-page app) (most of the code is ‚Äúcold‚Äù). </li></ol><br>  Both of these cases are quite important for the web, but still Octane is not suitable for all types of workload.  The V8 development team has spent a lot of effort on improving startup times: <br><br><blockquote>  Year after year, the performance of V8 when starting JavaScript is improved by about 25%.  Closer deal with the performance of real applications. <br>  - <a href="https://twitter.com/addyosmani/status/826519033683914753">@addyosmani</a> </blockquote><br>  Judging by Octane-Codeload, the performance of the V8 has improved by about 25% when parsing multiple pages: <br><br><img src="https://habrastorage.org/files/32d/2ad/3fb/32d2ad3fb7c0403ab31e96d95f756a83.jpg"><br><br>  In this respect, improved results and Pinterest.  Also in recent years, there are a number of other confirmations of the qualitative growth of the V8 in terms of the duration of parsing and compiling. <br><br>  <b>Code caching</b> <br><br><img src="https://habrastorage.org/files/3c1/362/928/3c1362928cc343deb70acc257bdc286e.png"><br>  <i>From the article " <a href="https://www.nativescript.org/blog/using-v8-code-caching-to-minimize-app-load-time-on-android">Using code caching in V8</a> ".</i> <br><br>  In Chrome 42, <a href="http://v8project.blogspot.com/2015/07/code-caching.html">code caching</a> appeared - a way to store a local copy of the compiled code, so that when you return to the page, the steps of extracting scripts, parsing and compiling are skipped.  On repeated visits, this gives Chrome an approximately 40 percent acceleration of compiling, but you need to clarify something: <br><br><ul><li>  Code caching is triggered for scripts that have been executed <b>twice within 72 hours.</b> </li><li>  For Service Worker scripts: <b>the same</b> condition. </li><li>  For scripts stored in the script storage by the Service Worker, caching is triggered when <b>first executed</b> . </li></ul><br>  So <b>if the code needs to be cached, then V8 will skip parsing and compiling from the third download</b> . <br><br>  You can play with this mechanism: <i>chrome: // flags / # v8-cache-strategies-for-cache-storage</i> .  You can also launch Chrome with flags <code>‚Äî js-flags=profile-deserialization</code> and see if objects are loaded from the cache (in the log they are presented as deserialization events). <br><br>  One explanation: only that code that is compiled eagerly compiled is cached.  In general, this is a top-level code that is executed only once, to configure global values.  Function definitions are usually compiled lazily and not always cached.  <b>IIFE</b> (for users of optimize-js;)) is also included in the V8 code cache, since they are already eagerly compiled. <br><br>  <b>Script Streaming Streaming</b> <br><br>  <a href="https://blog.chromium.org/2015/03/new-javascript-techniques-for-rapid.html">Streaming script loading</a> allows parsing scripts asynchronously or with a delay, moving them to a <b>separate background thread</b> with the start of loading.  This allows about 10% faster page loading.  As noted above, this mechanism now works to <b>synchronize</b> scripts. <br><br><img src="https://habrastorage.org/files/3cc/08f/0d4/3cc08f0d4b644903877c561c6dbf5239.png"><br><br>  Today V8 allows parsing in the background thread <b>all scripts</b> , <i>even</i> blocking the parser (parser blocking) <code>&lt;script src=‚Äù‚Äù&gt;</code> , so this will benefit everyone.  The caveat is that the background thread is unique, so it makes sense to handle large / critical scripts first.  <i>Be sure to take measurements to determine where improvements can be made.</i> <br><br>  <b>Because <code>&lt;script defer&gt;</code> in <code>&lt;head&gt;</code> , we can pre-define the resource and then parse it in the background thread.</b> <br><br>  With DevTools Timeline, you can also check if streaming has been applied to the right scripts.  If you have one big script that accounts for most of the parsing time, then it makes sense (usually) to check whether streaming is applied to it. <br><br><img src="https://habrastorage.org/files/12f/1aa/a52/12f1aaa528064d7ea3bc01da466f12c4.png"><br><br>  <b>Improved parsing and compiling</b> <br><br>  We continue to work with a more compact and fast parser that frees up memory and works more efficiently with data structures.  Today, the <b>main</b> reason for the mainstream delays in V8 is the non-linear dependence of the cost of parsing.  UMD example: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">global, module</span></span></span><span class="hljs-function">) </span></span>{ ‚Ä¶ })(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ my functions })</code> </pre> <br>  V8 does not know that the <b>module is</b> definitely needed, so we will not compile it during the compilation of the main script.  When we finally decide to compile the module, we will need to repack all internal functions.  This leads to non-linearity of the parsing duration in V8.  Each function at a depth of N is parsed N times, which leads to delays. <br><br>  V8 developers are already working on gathering information about internal functions during initial compilation, so any subsequent compilations can <i>ignore</i> their internal functions.  This should lead to a large increase in the performance of modular (module-style) functions. <br><br>  For more on this, see <a href="https://docs.google.com/presentation/d/1214p4CFjsF-NY4z9in0GEcJtjbyVQgU0A-UqEvovzCs/edit">The V8 Parser (s) - Design, Challenges, and Parsing JavaScript Better</a> . <br><br>  Also, V8 developers are exploring the possibility of transferring part of compiling JavaScript during launch into the <b>background</b> . <br><br>  <b>Precompiling javascript?</b> <br><br>  Every few years, the engines suggest ways to <i>precompile the</i> scripts so that we do not have to spend time parsing or compiling the resulting code (code pops up).  Instead, during assembly or on the server side, you can simply generate bytecode.  I believe that passing a bytecode to an application can slow down the load (bytecode takes up more space), and for the sake of security you will probably have to sign the code and process.  Today, V8 developers believe that precompiling does not give much benefit.  But they are open to discussing ideas that will speed up the launch phase.  Developers are trying to make V8 more aggressive in terms of compiling and caching scripts when you update the site in Service Worker. <br><br>  A discussion of precompiling with Facebook and Akamai, as well as my notes on this issue can be found <a href="https://gist.github.com/addyosmani/4009ee1238c4b1ff6f2a2d8a5057c181">here</a> . <br><br>  <b>Hack with parentheses Optimize JS for lazy parsing</b> <br><br>  JavaScript engines are equipped with lazy parsing heuristics: most of the functions in scripts are prepared before the completion of the full parsing cycle (for example, to search for syntax errors).  This approach is based on the idea that most pages contain JS functions, which, if executed, are lazy. <br><br><img src="https://habrastorage.org/files/5cf/449/0fc/5cf4490fc71149cdadcfef34ff9c75e5.png"><br><br>  Preparsing can speed up launch due to the fact that functions are checked only for the presence of the minimum information required by the browser.  This is contrary to the use of IIFE.  Although the engines try to skip preparsing for them, heuristics do not always work correctly, and in such situations tools like <a href="https://github.com/nolanlawson/optimize-js">optimize-js</a> are useful. <br><br>  optimize-js parses the scripts in advance and inserts parentheses if it knows (or assumes due to heuristics) that functions will be executed immediately there.  It <b>speeds up the execution</b> .  With some functions (for example, with IIFE!), Such a hack works correctly.  With others, everything depends on heuristics (for example, Browserify or Webpack assumes that all modules are loaded greedily, and this is not always the case).  V8 developers hope that in the future, the need for such hacks will disappear, but today it is a useful optimization, if you know what you are doing. <br><br>  The V8 authors are also working on reducing the cost of errors, which in the future should reduce the benefits of the hack with brackets. <br><br><h2>  Conclusion </h2><br>  <b>Starting performance matters</b> .  The combination of slow parsing, compiling and execution can be a bottleneck for pages that need to load quickly.  <b>Measure the</b> duration of these phases for your pages.  Find ways to speed them up. <br><br>  And we, for our part, will continue to work on improving the starting performance of the V8.  We promise;) <br><br><h2>  useful links </h2><br><ul><li>  <a href="https://www.youtube.com/watch%3Fv%3DRWLzUnESylc">Planning for Performance</a> </li><li>  <a href="https://twitter.com/MSEdgeDev/status/819985530775404544">Solving the Web Performance Crisis by Nolan Lawson</a> </li><li>  <a href="https://timkadlec.com/2014/09/js-parse-and-execution-time/">JS Parse and Execution Time</a> </li><li>  <a href="http://carlos.bueno.org/2010/02/measuring-javascript-parse-and-load.html">Measuring Javascript Parse and Load</a> </li><li>  <a href="https://www.safaribooksonline.com/library/view/velocity-conference-new/9781491900406/part78.html">Unpacking the Black Box: Benchmarking JS Parsing and Execution on Mobile Devices</a> ( <a href="https://speakerdeck.com/desp/unpacking-the-black-box-benchmarking-js-parsing-and-execution-on-mobile-devices">slides</a> ) </li><li>  <a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">When everything is important, nothing is!</a> </li><li>  <a href="http://benediktmeurer.de/2016/12/16/the-truth-about-traditional-javascript-benchmarks/">The truth about traditional JavaScript benchmarks</a> </li><li>  <a href="http://stackoverflow.com/questions/1096907/do-browsers-parse-javascript-on-every-page-load/">Do Browsers Parse JavaScript On Every Page Load</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/321748/">https://habr.com/ru/post/321748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321734/index.html">Heat equation in tensorflow</a></li>
<li><a href="../321736/index.html">How we sequenced the hackathons or ‚Äúthe harder the work, the easier it is to settle on it‚Äù</a></li>
<li><a href="../321738/index.html">OONP problem: there is no clear and obligatory core object-oriented modeling</a></li>
<li><a href="../321744/index.html">As I made the fastest resize of images. Part 0</a></li>
<li><a href="../321746/index.html">jQuery UI FadeSlide 4.0</a></li>
<li><a href="../321750/index.html">Foreign GPS monitoring services</a></li>
<li><a href="../321754/index.html">How to ‚Äúpunch‚Äù a person on the Internet: using Google operators and logic</a></li>
<li><a href="../321756/index.html">The success story of Yandex.Mail with PostgreSQL</a></li>
<li><a href="../321758/index.html">Introducing web single sign-on (Web SSO) and identity federation</a></li>
<li><a href="../321760/index.html">Do not trust SUDO, she can let you down</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>