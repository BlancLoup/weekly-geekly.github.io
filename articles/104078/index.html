<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel tasks. The case of "perfect parallelism." Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parallel code without dependencies 
 Introduction 
 In the first part of this article we will talk about approaches to parallel processing of cycles i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel tasks. The case of "perfect parallelism." Part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  Parallel code without dependencies </h4><br><h5>  Introduction </h5><br>  In the first part of this article we will talk about approaches to parallel processing of cycles in those successful cases when there are no dependencies between separate iterations and they can be correctly executed in parallel.  <a href="http://habrahabr.ru/blogs/net/104103/">In the second part</a> , we will consider the mechanisms that appeared in .NET 4.0 to control such parallelization, and identify the subtleties of the work of these mechanisms. <br><br><a name="habracut"></a><br><br>  Consider a cycle in which data is processed: <br><blockquote><ol><li> <code><font color="black"><font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> upperBound <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> <font color="#000000">{</font> <font color="#008080"><i>// ...  </i></font> <font color="#000000">}</font></font></code> </li> <li> <code><font color="black"><font color="#000000"><font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> upperBound <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> { <font color="#008080"><i>// ...  </i></font> <font color="#000000">}</font></font></font></code> </li> <li> <code><font color="black"><font color="#008080"><i><font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> upperBound <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> <font color="#000000">{</font> // ...   <font color="#000000">}</font></i></font></font></code> </li> <li> <code><font color="black"><font color="#000000"><font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> i <font color="#008000">&lt;</font> upperBound <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> <font color="#000000">{</font> <font color="#008080"><i>// ...  </i></font> }</font></font></code> </li> </ol></blockquote><br>  If the logic of the body of the cycle is such that the result of its calculations on a specific iteration does not depend on the result of the calculations of any other iteration, then this cycle refers to ‚Äúideally parallel‚Äù, since all its iterations can be performed in parallel, if necessary for This cores on the processor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The same definition can be attributed to a similar foreach cycle;  it also implies that the order of calculating iterations is unimportant. <br><br><h5>  Approaches to the implementation of the parallel loop </h5><br>  Let us try to implement the method ourselves for performing the cycle in parallel, and see what difficulties we face. <br><br>  So, we are going to create a method like this: <br><br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> <font color="#0600FF">void</font> ParallelFor <font color="#000000">(</font> <font color="#FF0000">int</font> from, <font color="#FF0000">int</font> to, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> <font color="#008000">;</font> </li></ol></blockquote><br><br>  It will have to perform body for all values ‚Äã‚Äãin the range from from to to (not including the latter), while parallelizing their execution into several threads in order to achieve maximum performance.  How far is it possible to parallelize it? <br><br><h6>  Determining the degree of parallelism </h6><br>  There is a sound judgment that it is logical to use as many threads as there are cores in the processor on this machine.  With this solution, each of the cores will be fully loaded.  With a larger number of threads, we will receive an increase in overhead costs for switching between them, with a smaller one, some of the cores will be idle. <br><br>  Such an approach is downstream to the core in many cases true, although it is based on an idealistic model of computation, when all the threads only deal with computations on the processor.  However, it can sometimes be useful to have more threads.  For example, if the threads in their work spend half the time waiting for resources, the processor still stands idle at this time, and an increase in the number of workflows can lead to improved performance. <br><br>  Thus, it turns out that it is worth starting with a simple ‚Äúone thread per core‚Äù option, but be prepared for consideration of other strategies. <br><br>  In order to get the number of available cores, we can use the System.Environment.ProcessorCount property.  It should be noted that it returns the number of cores taking into account Hyper-threading, that is, if it is present, the ‚Äúlogical‚Äù, already doubled number of cores will be returned. <br><br>  In view of the above, here is a logical (albeit somewhat naive) implementation: <br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> <font color="#0600FF">void</font> ParallelFor <font color="#000000">(</font> <font color="#FF0000">int</font> from, <font color="#FF0000">int</font> to, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#008080"><i>// determine the number of streams and the size of the data block for each stream</i></font> </li><li>  <font color="#FF0000">int</font> size <font color="#008000">=</font> to <font color="#008000">-</font> from <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> numProcs <font color="#008000">=</font> Environment.  <font color="#0000FF">ProcessorCount</font> <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> range <font color="#008000">=</font> size <font color="#008000">/</font> numProcs <font color="#008000">;</font> </li><li></li><li>  <font color="#008080"><i>// break the data, run all threads and wait for completion</i></font> </li><li>  var threads <font color="#008000">=</font> <font color="#008000">new</font> List <font color="#008000">&lt;</font> Thread <font color="#008000">&gt;</font> <font color="#000000">(</font> numProcs <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> p <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> p <font color="#008000">&lt;</font> numProcs <font color="#008000">;</font> p <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> start <font color="#008000">=</font> p <font color="#008000">*</font> range <font color="#008000">+</font> from <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> end <font color="#008000">=</font> <font color="#000000">(</font> p <font color="#008000">==</font> numProcs <font color="#008000">-</font> <font color="#FF0000">1</font> <font color="#000000">)</font> <font color="#008000">?</font> </li><li>  to <font color="#008000">:</font> start <font color="#008000">+</font> range <font color="#008000">;</font> </li><li>  threads.  <font color="#0000FF">Add</font> <font color="#000000">(</font> <font color="#008000">new</font> Thread <font color="#000000">(</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">=&gt;</font> <font color="#000000">{</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> start <font color="#008000">;</font> i <font color="#008000">&lt;</font> end <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> body <font color="#000000">(</font> i <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#0600FF">foreach</font> <font color="#000000">(</font> var thread <font color="#0600FF">in</font> threads <font color="#000000">)</font> thread.  <font color="#0000FF">Start</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#0600FF">foreach</font> <font color="#000000">(</font> var thread <font color="#0600FF">in</font> threads <font color="#000000">)</font> thread.  <font color="#0000FF">Join</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br><br>  An important disadvantage of this version is the creation / completion of new threads each time, since this is a rather expensive operation (in particular, each thread reserves 1M of memory on the stack, even if no function is currently running on it). <br><br>  Another problem also stems from creating new threads.  Suppose that we were given some code in body that also contains a ParallelFor call.  In this case, in the process of execution, it will not create two more numProcs streams, but two times more, and a situation may arise when the cost of switching between threads will be too high (‚Äúexcessive multithreading‚Äù). <br><br><h6>  Static distribution of iterations </h6><br>  Therefore, instead of creating threads manually, we would prefer to use the thread pool: <br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> <font color="#0600FF">void</font> ParallelFor <font color="#000000">(</font> <font color="#FF0000">int</font> from, <font color="#FF0000">int</font> to, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> size <font color="#008000">=</font> to <font color="#008000">-</font> from <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> numProcs <font color="#008000">=</font> Environment.  <font color="#0000FF">ProcessorCount</font> <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> range <font color="#008000">=</font> size <font color="#008000">/</font> numProcs <font color="#008000">;</font> </li><li></li><li>  <font color="#FF0000">int</font> remaining <font color="#008000">=</font> numProcs <font color="#008000">;</font> </li><li></li><li>  <font color="#008080"><i>// synchronization object to determine completion</i></font> </li><li>  <font color="#0600FF">using</font> <font color="#000000">(</font> ManualResetEvent mre <font color="#008000">=</font> <font color="#008000">new</font> ManualResetEvent <font color="#000000">(</font> <font color="#0600FF">false</font> <font color="#000000">)</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#008080"><i>// create all tasks</i></font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> p <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> p <font color="#008000">&lt;</font> numProcs <font color="#008000">;</font> p <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> start <font color="#008000">=</font> p <font color="#008000">*</font> range <font color="#008000">+</font> from <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> end <font color="#008000">=</font> <font color="#000000">(</font> p <font color="#008000">==</font> numProcs <font color="#008000">-</font> <font color="#FF0000">1</font> <font color="#000000">)</font> <font color="#008000">?</font>  to <font color="#008000">:</font> start <font color="#008000">+</font> range <font color="#008000">;</font> </li><li></li><li>  ThreadPool.  <font color="#0000FF">QueueUserWorkItem</font> <font color="#000000">(</font> <font color="#FF0000">delegate</font> <font color="#000000">{</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> start <font color="#008000">;</font> i <font color="#008000">&lt;</font> end <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  body <font color="#000000">(</font> i <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#008080"><i>// check if the last task completed</i></font> </li><li>  <font color="#0600FF">if</font> <font color="#000000">(</font> Interlocked. <font color="#0000FF">Decrement</font> <font color="#000000">(</font> <font color="#0600FF">ref</font> remaining <font color="#000000">)</font> <font color="#008000">==</font> <font color="#FF0000">0</font> <font color="#000000">)</font> </li><li>  mre.  <font color="#0000FF">Set</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#008080"><i>// Waiting for all tasks to be completed.</i></font> </li><li>  mre.  <font color="#0000FF">WaitOne</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br>  Such a solution is already devoid of problems with excessive multithreading and with the cost of creating threads.  What else can prevent in this situation the most rapid development of this cycle? <br><br>  In case all iterations are small in time and approximately equally costly, the above approach is close to optimal. <br><br>  And if we imagine that some iterations are completed quickly, and some - many times longer, then in that case that thread from the pool, which was not lucky to be the performer of more ‚Äúlong‚Äù iterations, will work several times longer than the others.  At the same time, since the operating time of the entire parallel operation is determined by the operating time of its slowest component, the remaining threads will eventually stand idle, having done all ‚Äútheir‚Äù work, while one ‚Äúunlucky‚Äù will delay everyone. <br><br>  In such a situation to ensure the minimum time, you need <ul><li>  either know the nature of the iterations, so that all threads equally distribute "long" iterations, </li><li>  or change the general approach to the division of tasks between threads. </li></ul><br><h6>  Dynamic distribution of iterations </h6><br>  From the static separation, you can go to the dynamic, that is, to give each thread some ‚Äúportion‚Äù of work, having done that, it will receive the next portion, if the unfinished work still remains by that time. <br><br>  This approach can be illustrated with this code: <br><br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> <font color="#0600FF">void</font> ParallelFor <font color="#000000">(</font> <font color="#FF0000">int</font> from, <font color="#FF0000">int</font> to, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> numProcs <font color="#008000">=</font> Environment.  <font color="#0000FF">ProcessorCount</font> <font color="#008000">;</font> </li><li>  <font color="#008080"><i>// amount remaining</i></font> </li><li>  <font color="#FF0000">int</font> remainingWorkItems <font color="#008000">=</font> numProcs <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> nextIteration <font color="#008000">=</font> from <font color="#008000">;</font> </li><li></li><li>  <font color="#0600FF">using</font> <font color="#000000">(</font> ManualResetEvent mre <font color="#008000">=</font> <font color="#008000">new</font> ManualResetEvent <font color="#000000">(</font> <font color="#0600FF">false</font> <font color="#000000">)</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#008080"><i>// create tasks</i></font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> p <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> p <font color="#008000">&lt;</font> numProcs <font color="#008000">;</font> p <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  ThreadPool.  <font color="#0000FF">QueueUserWorkItem</font> <font color="#000000">(</font> <font color="#FF0000">delegate</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> index <font color="#008000">;</font> </li><li>  <font color="#008080"><i>// select one item for execution</i></font> </li><li>  <font color="#0600FF">while</font> <font color="#000000">(</font> <font color="#000000">(</font> index <font color="#008000">=</font> Interlocked. <font color="#0000FF">Increment</font> <font color="#000000">(</font> <font color="#0600FF">ref</font> nextIteration <font color="#000000">)</font> <font color="#008000">-</font> <font color="#FF0000">1</font> <font color="#000000">)</font> <font color="#008000">&lt;</font> to <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  body <font color="#000000">(</font> index <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#0600FF">if</font> <font color="#000000">(</font> Interlocked. <font color="#0000FF">Decrement</font> <font color="#000000">(</font> <font color="#0600FF">ref</font> remainingWorkItems <font color="#000000">)</font> <font color="#008000">==</font> <font color="#FF0000">0</font> <font color="#000000">)</font> </li><li>  mre.  <font color="#0000FF">Set</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#008080"><i>// wait for all tasks to complete</i></font> </li><li>  mre.  <font color="#0000FF">WaitOne</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br><br>  This code is good for the case of long iterations with an unpredictable runtime, but for fast iterations it has too much synchronization costs. <br><br><h6>  Balanced approach </h6><br>  Thus, we see that, depending on the nature of the parallelized loop, both the static task sharing strategy between the threads and the dynamic one can be advantageous.  It is logical to assume that some balanced strategy may be successful for intermediate cases. <br><br>  Here is a variant of its code.  The idea is that the "portion" we do a little more than just one element, but less than in the case of static distribution. <br><br><blockquote><ol><li>  <font color="#0600FF">public</font> <font color="#0600FF">static</font> <font color="#0600FF">void</font> ParallelFor <font color="#000000">(</font> <font color="#FF0000">int</font> from, <font color="#FF0000">int</font> to, Action <font color="#008000">&lt;</font> <font color="#FF0000">int</font> <font color="#008000">&gt;</font> body <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> numProcs <font color="#008000">=</font> Environment.  <font color="#0000FF">ProcessorCount</font> <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> remainingWorkItems <font color="#008000">=</font> numProcs <font color="#008000">;</font> </li><li>  <font color="#FF0000">int</font> nextIteration <font color="#008000">=</font> from <font color="#008000">;</font> </li><li>  <font color="#008080"><i>// size of the data portion</i></font> </li><li>  <font color="#0600FF">const</font> <font color="#FF0000">int</font> batchSize <font color="#008000">=</font> <font color="#FF0000">3</font> <font color="#008000">;</font> </li><li>  <font color="#0600FF">using</font> <font color="#000000">(</font> ManualResetEvent mre <font color="#008000">=</font> <font color="#008000">new</font> ManualResetEvent <font color="#000000">(</font> <font color="#0600FF">false</font> <font color="#000000">)</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> p <font color="#008000">=</font> <font color="#FF0000">0</font> <font color="#008000">;</font> p <font color="#008000">&lt;</font> numProcs <font color="#008000">;</font> p <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  ThreadPool.  <font color="#0000FF">QueueUserWorkItem</font> <font color="#000000">(</font> <font color="#FF0000">delegate</font> <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> index <font color="#008000">;</font> </li><li>  <font color="#0600FF">while</font> <font color="#000000">(</font> <font color="#000000">(</font> index <font color="#008000">=</font> Interlocked. <font color="#0000FF">Add</font> <font color="#000000">(</font> <font color="#0600FF">ref</font> nextIteration, batchSize <font color="#000000">)</font> <font color="#008000">-</font> batchSize <font color="#000000">)</font> <font color="#008000">&lt;</font> to <font color="#000000">)</font> </li><li>  <font color="#000000">{</font> </li><li>  <font color="#FF0000">int</font> end <font color="#008000">=</font> index <font color="#008000">+</font> batchSize <font color="#008000">;</font> </li><li>  <font color="#0600FF">if</font> <font color="#000000">(</font> end <font color="#008000">&gt; =</font> to <font color="#000000">)</font> </li><li>  end <font color="#008000">=</font> to <font color="#008000">;</font> </li><li>  <font color="#0600FF">for</font> <font color="#000000">(</font> <font color="#FF0000">int</font> i <font color="#008000">=</font> index <font color="#008000">;</font> i <font color="#008000">&lt;</font> end <font color="#008000">;</font> i <font color="#008000">++</font> <font color="#000000">)</font> </li><li>  body <font color="#000000">(</font> i <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#0600FF">if</font> <font color="#000000">(</font> Interlocked. <font color="#0000FF">Decrement</font> <font color="#000000">(</font> <font color="#0600FF">ref</font> remainingWorkItems <font color="#000000">)</font> <font color="#008000">==</font> <font color="#FF0000">0</font> <font color="#000000">)</font> </li><li>  mre.  <font color="#0000FF">Set</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  mre.  <font color="#0000FF">WaitOne</font> <font color="#000000">(</font> <font color="#000000">)</font> <font color="#008000">;</font> </li><li>  <font color="#000000">}</font> </li><li>  <font color="#000000">}</font> </li></ol></blockquote><br><br>  Here the size of the data portion is set by a constant, and by changing it, we choose the level we need between the static and dynamic distribution of tasks. <br><br><h5>  Conclusion </h5><br>  In any case, the optimal settings for a particular case are determined by the nature of the calculations.  But a compromise with the dynamic distribution of more or less large "portions" of work may be quite acceptable for most situations.  This is exactly how library methods for parallel execution of loops in .NET 4 are implemented, which will be discussed in the second part of the article. <br><br>  PS This article is written under the impression of the book " <a href="http://www.microsoft.com/downloads/en/details.aspx%3Fdisplaylang%3Den%26FamilyID%3D86b3d32b-ad26-4bb8-a3ae-c1637026c3ee">PATTERNS OF PARALLEL PROGRAMMING: UNDERSTANDING AND APPLYING PARALLEL PATTERNS WITH THE .NET FRAMEWORK 4 AND VISUAL C #</a> " and can be considered its free translation with recycling. <br><br>  ______________________ <br><h6>  The text was prepared in the Blog <a href="http://www.softcoder.ru/blogeditor/">Editor</a> from ¬© SoftCoder.ru </h6><br><br>  <b>UPD: The second part is practical: <a href="http://habrahabr.ru/blogs/net/104103/">habrahabr.ru/blogs/net/104103</a></b> </div><p>Source: <a href="https://habr.com/ru/post/104078/">https://habr.com/ru/post/104078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../104072/index.html">Communicator on Windows Phone 7</a></li>
<li><a href="../104073/index.html">Want to take a car loan? Think about your health!</a></li>
<li><a href="../104075/index.html">HTC Desire: Trouble-free ‚ÄúOTA-update‚Äù to Froyo without WiFi / 3G connections</a></li>
<li><a href="../104076/index.html">LJ will not die. Facebook is not for content</a></li>
<li><a href="../104077/index.html">Happy Programmer's Day!</a></li>
<li><a href="../104079/index.html">My minimum set of applications for Android</a></li>
<li><a href="../104080/index.html">Vanity: a community for advertisers</a></li>
<li><a href="../104081/index.html">About persistent stirring in the right places</a></li>
<li><a href="../104083/index.html">What does the Chinese keyboard look like?</a></li>
<li><a href="../104084/index.html">Unusual congratulations on the day of the programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>