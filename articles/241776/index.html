<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive JavaScript: E-Life Project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive JavaScript: E-Life Project</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>The question of whether machines can be thought as relevant as the question of whether submarines can sail.</i> <i><br><br></i>  <i>Edsger Dijkstra, Threats to Computational Science</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the chapters, I will stop quitting theory with you, and will work with you on programs.  The theory is indispensable for teaching programming, but it must be accompanied by reading and understanding non-trivial programs. <br><br>  Our project is the construction of a virtual ecosystem, a small world inhabited by creatures that move and fight for survival. <br><a name="habracut"></a><br><h4>  Definition </h4><br>  To make the task feasible, we will fundamentally simplify the concept of the world.  Namely - the world will be a two-dimensional grid, where each entity occupies one cell.  On each turn, creatures will be able to perform some action. <br><br>  Thus, we will chop time and space into units of fixed size: cells for space and moves for time.  Of course, this is a rough and careless approach.  But our simulation should be entertaining, not neat, so we are free to ‚Äúcut corners‚Äù. <br><br>  We can define the world with the help of a plan - an array of strings, which decomposes the world grid, using one symbol per cell. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plan = [<span class="hljs-string"><span class="hljs-string">"############################"</span></span>, <span class="hljs-string"><span class="hljs-string">"# # # o ##"</span></span>, <span class="hljs-string"><span class="hljs-string">"# #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ##### #"</span></span>, <span class="hljs-string"><span class="hljs-string">"## # # ## #"</span></span>, <span class="hljs-string"><span class="hljs-string">"### ## # #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ### # #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# #### #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ## o #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# o # o ### #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# # #"</span></span>, <span class="hljs-string"><span class="hljs-string">"############################"</span></span>];</code> </pre> <br><br>  The ‚Äú#‚Äù symbol indicates walls and stones, ‚Äúo‚Äù - being.  Spaces - empty space. <br><br>  The plan can be used to create an object of the world.  He keeps track of the size and contents of the world.  It has a toString method that transforms the world into a display string (such as the plan on which it is based) so that we can observe what is happening inside it.  The world object has a turn method that allows all beings to make one move and update the state of the world according to their actions. <br><br><h4>  We depict the space </h4><br>  At the grid, simulating the world, given the width and height.  Cells are defined by x and y coordinates.  We use the simple Vector type (from the exercises in the previous chapter) to represent these pairs of coordinates. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } Vector.prototype.plus = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">other</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + other.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y + other.y); };</code> </pre><br><br>  Then we need an object type that simulates the mesh itself.  The grid is a part of the world, but we make a separate object out of it (which will be a property of the world object) in order not to complicate the world object.  The world must load itself with things belonging to the world, and the grid with things related to the grid. <br><br>  We have several options for storing a grid of values.  You can use an array of array strings, and use two-step access to properties: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = [[<span class="hljs-string"><span class="hljs-string">"top left"</span></span>, <span class="hljs-string"><span class="hljs-string">"top middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"top right"</span></span>], [<span class="hljs-string"><span class="hljs-string">"bottom left"</span></span>, <span class="hljs-string"><span class="hljs-string">"bottom middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"bottom right"</span></span>]]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(grid[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí bottom right</span></span></code> </pre><br><br>  Or we can take one array, the size of width √ó height, and decide that the element (x, y) is in the position x + (y √ó width). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = [<span class="hljs-string"><span class="hljs-string">"top left"</span></span>, <span class="hljs-string"><span class="hljs-string">"top middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"top right"</span></span>, <span class="hljs-string"><span class="hljs-string">"bottom left"</span></span>, <span class="hljs-string"><span class="hljs-string">"bottom middle"</span></span>, <span class="hljs-string"><span class="hljs-string">"bottom right"</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(grid[<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>)]); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí bottom right</span></span></code> </pre><br><br>  Since the access will be wrapped in the methods of the grid object, the external code doesn't care which approach will be chosen.  I chose the second one because it is easier to create an array with it.  When you call the Array constructor with one number as an argument, it creates a new empty array of a given length. <br><br>  The following code declares a Grid object (grid) with the main methods: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.space = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } Grid.prototype.isInside = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vector.x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vector.x &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width &amp;&amp; vector.y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vector.y &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height; }; Grid.prototype.get = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.space[vector.x + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * vector.y]; }; Grid.prototype.set = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vector, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.space[vector.x + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * vector.y] = value; };</code> </pre><br><br>  Elementary test: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grid(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(grid.get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí undefined grid.set(new Vector(1, 1), "X"); console.log(grid.get(new Vector(1, 1))); // ‚Üí X</span></span></code> </pre><br><br><h4>  Creature programming interface </h4><br>  Before we take on the constructor of the world World, we need to determine the objects of the creatures that inhabit it.  I mentioned that the world will ask beings what they want to do.  It will work like this: every creature object has an act method, which when called returns an action action.  Action - an object of type property, which names the type of action that a creature wants to perform, for example, ‚Äúmove‚Äù.  An action may contain additional information, such as driving direction. <br><br>  The creatures are terribly nearsighted and see only the cells directly adjacent to them.  But it can be useful when choosing actions.  When calling the act method, it is given a view object, which allows the creature to explore the surrounding terrain.  We call the eight neighboring cells their compass directions: ‚Äún‚Äù to the north, ‚Äúne‚Äù to the northeast, and so on.  Here is the object that will be used to convert from the names of directions to the displacement by coordinates: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> directions = { <span class="hljs-string"><span class="hljs-string">"n"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), <span class="hljs-string"><span class="hljs-string">"ne"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), <span class="hljs-string"><span class="hljs-string">"e"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"se"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"s"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"sw"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"w"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-string"><span class="hljs-string">"nw"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) };</code> </pre><br><br>  The view object has a look method that takes direction and returns a character, for example, "#" if there is a wall, or a space, if there is nothing there.  The object also provides convenient find and findAll methods.  Both accept one of the symbols representing things on the map as an argument.  The first returns the direction in which this item can be found next to the creature, or null if there is no such item.  The second returns an array with all possible directions where such an item is found.  For example, a creature to the left of the wall (in the west) will get [‚Äúne‚Äù, ‚Äúe‚Äù, ‚Äúse‚Äù] when calling findAll with argument ‚Äú#‚Äù. <br><br>  Here is a simple stupid creature that just goes on, until it hits an obstacle, and then bounces off in a random direction. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * array.length)]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BouncingCritter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.direction = randomElement(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(directions)); }; BouncingCritter.prototype.act = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view.look(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.direction) != <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.direction = view.find(<span class="hljs-string"><span class="hljs-string">" "</span></span>) || <span class="hljs-string"><span class="hljs-string">"s"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"move"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.direction}; };</code> </pre><br><br>  The helper function randomElement simply selects a random array element using Math.random and some arithmetic to get a random index.  We will continue to use chance, since it is a useful thing in simulations. <br><br>  The BouncingCritter constructor calls Object.keys.  We saw this function in the previous chapter ‚Äî it returns an array with all the object property names.  Here it gets all the names of the directions from the directions object specified earlier. <br><br>  The construction ‚Äú||  The ‚Äús‚Äù in the act method is needed so that this.direction does not get null if the creature huddles into a corner without free space around ‚Äî for example, surrounded by other creatures. <br><br><h4>  World Object </h4><br>  Now you can proceed to the world object World.  The constructor accepts a plan (an array of strings representing a mesh of the world) and a legend object.  This is an object that tells you what each of the map symbols means.  It has a constructor for each character - except for a space, which refers to null (representing empty space). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementFromChar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">legend, ch</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> legend[ch](); element.originChar = ch; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">World</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map, legend</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grid(map[<span class="hljs-number"><span class="hljs-number">0</span></span>].length, map.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.legend = legend; map.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; line.length; x++) grid.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(x, y), elementFromChar(legend, line[x])); }); }</code> </pre><br><br>  In elementFromChar, we first create an instance of the desired type, finding the character's constructor and applying new to it.  Then we add the originChar property so that it is easy to find out from which character the element was originally created. <br><br>  We will need this originChar property when making the world toString method.  The method builds a map in the form of a line from the current state of the world, passing a two-dimensional cycle through the grid cells. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">charFromElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element.originChar; } World.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(x, y)); output += charFromElement(element); } output += <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; };</code> </pre><br><br>  Wall wall is a simple object.  Used to occupy space and does not have the act method. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre><br><br>  By checking the World object, creating an instance using the plan specified at the beginning of the chapter, and then calling its toString method, we get a very similar string to this plan. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> world = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> World(plan, {<span class="hljs-string"><span class="hljs-string">"#"</span></span>: Wall, <span class="hljs-string"><span class="hljs-string">"o"</span></span>: BouncingCritter}); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(world.toString()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ############################ // # # # o ## // # # // # ##### # // ## # # ## # // ### ## # # // # ### # # // # #### # // # ## o # // # o # o ### # // # # # // ############################</span></span></code> </pre><br><br>  this and its scope <br><br>  In the World constructor there is a call forEach.  I want to note that inside the function passed in forEach, we are no longer directly in the scope of the constructor.  Each function call gets its own namespace, so this inside does not already refer to the object being created, which is referenced by this outside the function.  And in general, if the function is not called as a method, this will refer to the global object. <br><br>  This means that we cannot write this.grid to access the grid from within the loop.  Instead, the external function creates a local grid variable, through which the internal function accesses the grid. <br><br>  This is a miss in javascript design.  Fortunately, in the next version there is a solution to this problem.  In the meantime, there are workarounds.  Usually write <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span></code> </pre><br><br>  and then work with the self variable. <br><br>  Another solution is to use the bind method, which allows you to bind to a specific this object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">addPropTo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop + elt; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(test.addPropTo([<span class="hljs-number"><span class="hljs-number">5</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí [15]</span></span></code> </pre><br><br>  The function passed to map is the result of the call binding, and therefore its this is bound to the first argument passed in bind, that is, the variable to the external function (which contains the test object). <br><br>  Most standard higher-order methods for arrays, such as forEach and map, take an optional second argument, which can also be used to pass this when calling an iteration function.  You could write the previous example a little easier: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">addPropTo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop + elt; }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üê  bind } }; console.log(test.addPropTo([5])); // ‚Üí [15]</span></span></code> </pre><br><br>  This only works with higher-order functions that have such a context parameter.  If not, you have to use the other approaches mentioned. <br><br>  In our own higher order function, we can enable context parameter support using the call method to call the function passed as an argument.  For example, here is the forEach method for our Grid type, which calls the specified function for each grid element that is not null or undefined: <br><br><pre> <code class="javascript hljs">Grid.prototype.forEach = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.space[x + y * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) f.call(context, value, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector(x, y)); } } };</code> </pre><br><br><h4>  Reviving the world </h4><br>  The next step is to create a turn method (step) for a world object, giving creatures the opportunity to act.  It will bypass the grid with the forEach method, and look for objects that have the act method.  Finding an object, turn calls this method, getting an action object and performs this action if it is valid.  For now, we only understand the ‚Äúmove‚Äù action. <br><br>  There is one possible problem.  Can you see which one?  If we let the creatures move as we go through them, they can move to a cage that we haven‚Äôt processed yet, and then we will let them move again when the cage reaches that cage.  Thus, we need to store an array of creatures that have already made their move, and ignore them when re-passing. <br><br><pre> <code class="javascript hljs">World.prototype.turn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acted = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (critter.act &amp;&amp; acted.indexOf(critter) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { acted.push(critter); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.letAct(critter, vector); } }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre><br><br>  The second parameter of the forEach method is used to access the correct this variable in an internal function.  The letAct method contains logic that allows creatures to move. <br><br><pre> <code class="javascript hljs">World.prototype.letAct = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = critter.act(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, vector)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action &amp;&amp; action.type == <span class="hljs-string"><span class="hljs-string">"move"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dest = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkDestination(action, vector); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.get(dest) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(vector, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(dest, critter); } } }; World.prototype.checkDestination = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action, vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directions.hasOwnProperty(action.direction)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dest = vector.plus(directions[action.direction]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.isInside(dest)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dest; } };</code> </pre><br><br>  First, we simply ask the creature to act, passing it the view object, which knows about the world and the current position of the creature in the world (we will soon define the View).  The act method returns an action. <br><br>  If the action type is not ‚Äúmove‚Äù, it is ignored.  If ‚Äúmove‚Äù, and if it has a direction property that refers to a valid direction, and if the cell is empty in this direction (null), we assign the cell where the creature was just, null, and store the creature in the destination cell. <br><br>  Notice that letAct takes care of ignoring invalid input.  It does not assume by default that direction is valid, or that a type property makes sense.  This kind of security programming makes sense in some situations.  This is mainly done to validate input data coming from sources that you do not control (user input or file reading), but it is also useful for isolating subsystems from each other.  In our case, its goal is to consider that creatures can be programmed inaccurately.  They do not need to check whether their intentions make sense.  They simply request the possibility of action, and the world itself decides whether to allow it. <br><br>  These two methods do not belong to the world object's external interface.  They are parts of the internal implementation.  Some languages ‚Äã‚Äãprovide ways to declare certain methods and properties "private" and give an error when trying to use them outside the object.  JavaScript does not provide for this, so you have to rely on other ways to report that it is part of the object's interface.  Sometimes it helps to use the property naming scheme to distinguish between internal and external, for example, with special prefixes to internal names, such as underscore (_).  This will facilitate the identification of random use of properties that are not part of the interface. <br><br>  And the missing part, type View, looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">View</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">world, vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.world = world; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vector = vector; } View.prototype.look = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vector.plus(directions[dir]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.world.grid.isInside(target)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> charFromElement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.world.grid.get(target)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span>; }; View.prototype.findAll = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ch</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> found = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> directions) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.look(dir) == ch) found.push(dir); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found; }; View.prototype.find = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ch</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> found = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findAll(ch); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (found.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> randomElement(found); };</code> </pre><br><br>  The look method calculates the coordinates we are trying to look at.  If they are inside the grid, then get the character corresponding to the element there.  For the coordinates outside the grid, look simply pretend that there is a wall ‚Äî if you set the world without the surrounding walls, the creatures cannot get off the edge. <br><br><h4>  It moves </h4><br>  We have created a copy of the world object.  Now that all the necessary methods are ready, we should be able to make it move. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { world.turn(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(world.toString()); } <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ‚Ä¶  </span></span></code> </pre><br><br>  Simply displaying five copies of a map is not a very convenient way to observe the world.  Therefore, in the sandbox for the book (or <a href="">in files for download</a> ) there is a magical function animateWorld, which shows the world as an animation on the screen, taking three steps per second until you press the stop. <br><br><pre> <code class="javascript hljs">animateWorld(world); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ‚Ä¶ !</span></span></code> </pre><br><br>  The implementation of animateWorld will remain secret for now, but after reading the next chapters of the book discussing the integration of JavaScript into browsers, it will no longer look so mysterious. <br><br><h4>  More life forms </h4><br>  One of the interesting situations in the world happens when two creatures bounce off each other.  Can you come up with another interesting form of interaction? <br><br>  I came up with a creature moving along the wall.  It holds its left hand (paw, tentacle, whatever) on the wall and moves along it.  This, as it turned out, is not so easy to program. <br><br>  We will need to calculate using directions in space.  Since the directions are given by a set of strings, we need to specify our dirPlus operation to calculate the relative directions.  dirPlus (‚Äún‚Äù, 1) means turning clockwise 45 degrees to the north, which results in ‚Äúne‚Äù.  dirPlus ("s", -2) means turning counterclockwise from the south, that is, to the east. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> directionNames = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(directions); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dirPlus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir, n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = directionNames.indexOf(dir); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directionNames[(index + n + <span class="hljs-number"><span class="hljs-number">8</span></span>) % <span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallFollower</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir = <span class="hljs-string"><span class="hljs-string">"s"</span></span>; } WallFollower.prototype.act = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (view.look(dirPlus(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir, <span class="hljs-number"><span class="hljs-number">-3</span></span>)) != <span class="hljs-string"><span class="hljs-string">" "</span></span>) start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir = dirPlus(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (view.look(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir) != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir = dirPlus(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir == start) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"move"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dir}; };</code> </pre><br><br>  The act method only scans the creature‚Äôs environment, starting on the left side and further clockwise until it finds an empty cell.  Then he moves in the direction of this cell. <br><br>  Complicating the situation is that the creature may be far from the walls in empty space - either bypassing another creature, or initially there.  If we leave the algorithm described, the unfortunate creature will turn left every turn and run in a circle. <br><br>  So there is another check through if that the scan needs to be started if the creature just passed by any obstacle.  That is, if the space behind and to the left is not empty.  Otherwise, we start to scan ahead, so in empty space it will go straight. <br><br>  Finally, there is a check that this.dir and start match on each pass of the loop so that it does not get stuck in time when there is no place for the creature to go because of walls or other creatures and it cannot find an empty cell. <br><br>  This small world shows creatures moving along the walls .: <br><br><pre> <code class="javascript hljs">animateWorld(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> World( [<span class="hljs-string"><span class="hljs-string">"############"</span></span>, <span class="hljs-string"><span class="hljs-string">"# # #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ~ ~ #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ## #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ## o####"</span></span>, <span class="hljs-string"><span class="hljs-string">"# #"</span></span>, <span class="hljs-string"><span class="hljs-string">"############"</span></span>], {<span class="hljs-string"><span class="hljs-string">"#"</span></span>: Wall, <span class="hljs-string"><span class="hljs-string">"~"</span></span>: WallFollower, <span class="hljs-string"><span class="hljs-string">"o"</span></span>: BouncingCritter} ));</code> </pre><br><br><h4>  More life situation </h4><br>  To make life in our little world more interesting, add the concept of food and reproduction.  Every living creature has a new property, energy, which decreases when performing actions, and increases when eating food.  When a creature has enough energy, it can multiply, creating a new creature of the same type.  To simplify calculations, our creatures multiply by themselves. <br><br>  If creatures only move and eat each other, the world will soon succumb to increasing entropy, it will run out of energy and it will turn into a desert.  To prevent this ending (or delaying), we add plants to it.  They do not move.  They just do photosynthesis and grow (gain energy), and multiply. <br><br>  For this to work, we need peace with another letAct method.  We could just replace the World prototype method, but I‚Äôm used to our simulation of creatures walking along walls and wouldn‚Äôt want to destroy it. <br><br>  One solution is to use inheritance.  We are creating a new constructor, LifelikeWorld, whose prototype is based on the World prototype, but overrides the letAct method.  The new letAct passes the work of committing actions to different functions stored in the actionTypes object. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LifelikeWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map, legend</span></span></span><span class="hljs-function">) </span></span>{ World.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, map, legend); } LifelikeWorld.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(World.prototype); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionTypes = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); LifelikeWorld.prototype.letAct = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = critter.act(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, vector)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handled = action &amp;&amp; action.type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> actionTypes &amp;&amp; actionTypes[action.type].call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, critter, vector, action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!handled) { critter.energy -= <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (critter.energy &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(vector, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } };</code> </pre><br><br>  The new letAct method checks if at least some action has been passed, then if there is a function that processes it, and at the end whether this function returns true, indicating that the action was completed successfully.  Note the use of call to give functions access to the world object through this. <br><br>  If the action did not work for any reason, the default action for the creature will be waiting.  He loses 0.2 units of energy, and when his energy level drops below zero, he dies and disappears from the grid. <br><br><h4>  Action handlers </h4><br>  The simplest action is growth, it is used by plants.  When an action object of the type {type: "grow"} is returned, the following handler method will be called: <br><br><pre> <code class="javascript hljs">actionTypes.grow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter</span></span></span><span class="hljs-function">) </span></span>{ critter.energy += <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Growth is always successful and adds half the unit to the energy level of the plant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The movement is more complex.</font></font><br><br><pre> <code class="javascript hljs">actionTypes.move = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dest = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkDestination(action, vector); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || critter.energy &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.get(dest) != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; critter.energy -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(vector, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(dest, critter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This action first checks, using the checkDestination method previously declared, whether the action provides a valid direction. </font><font style="vertical-align: inherit;">If not, or in that direction is not an empty area, or the creature lacks energy - move returns false, indicating that the action did not take place. </font><font style="vertical-align: inherit;">Otherwise, he moves the creature and subtracts energy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to movement, creatures can eat.</font></font><br><br><pre> <code class="javascript hljs">actionTypes.eat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dest = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkDestination(action, vector); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atDest = dest != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.get(dest); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!atDest || atDest.energy == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; critter.energy += atDest.energy; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(dest, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eating another creature also requires the provision of a valid direction cell. </font><font style="vertical-align: inherit;">In this case, the cell must contain something with energy, such as a creature (but not a wall, they cannot be eaten). </font><font style="vertical-align: inherit;">If this is confirmed, the energy eaten goes to the feeder, and the victim is removed from the grid. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we allow creatures to multiply.</font></font><br><br><pre> <code class="javascript hljs">actionTypes.reproduce = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">critter, vector, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baby = elementFromChar(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.legend, critter.originChar); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dest = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkDestination(action, vector); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dest == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || critter.energy &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span> * baby.energy || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.get(dest) != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; critter.energy -= <span class="hljs-number"><span class="hljs-number">2</span></span> * baby.energy; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid.set(dest, baby); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reproduction takes up twice the energy that a newborn has. </font><font style="vertical-align: inherit;">Therefore, we create a hypothetical offspring using elementFromChar on the original creature. </font><font style="vertical-align: inherit;">As soon as we have a son, we can find out his energy level and check whether the parent has enough energy to give birth to him. </font><font style="vertical-align: inherit;">We also need a valid direction cell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If everything is in order, the offspring is placed on the grid (and ceases to be hypothetical), and energy is wasted.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We inhabit the world </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have a foundation for simulating creatures that look more like real ones. </font><font style="vertical-align: inherit;">We could put beings from the old world into the new world, but they would simply die, since they do not have the energy property. </font><font style="vertical-align: inherit;">Let's make new ones. </font><font style="vertical-align: inherit;">First, we write a plant that, in fact, is a fairly simple form of life.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Plant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energy = <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">4</span></span>; } Plant.prototype.act = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energy &gt; <span class="hljs-number"><span class="hljs-number">15</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> space = context.find(<span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"reproduce"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: space}; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energy &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"grow"</span></span>}; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plants start with a random level of energy from 3 to 7, so that they do not multiply all in one move. </font><font style="vertical-align: inherit;">When the plant reaches energy 15, and next is an empty cell - it multiplies into it. </font><font style="vertical-align: inherit;">If it cannot multiply, then it simply grows until it reaches the energy of 20. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we define the plant eater.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlantEater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energy = <span class="hljs-number"><span class="hljs-number">20</span></span>; } PlantEater.prototype.act = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> space = context.find(<span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energy &gt; <span class="hljs-number"><span class="hljs-number">60</span></span> &amp;&amp; space) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"reproduce"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: space}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plant = context.find(<span class="hljs-string"><span class="hljs-string">"*"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plant) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"eat"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: plant}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (space) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"move"</span></span>, <span class="hljs-attr"><span class="hljs-attr">direction</span></span>: space}; };</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For plants we will use the symbol * - that which the creature will look for in search of food. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breathe life </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now we have enough elements for the new world. </font><font style="vertical-align: inherit;">Imagine the next map as a grassy valley where a herd of herbivores grazes, several boulders lie and lush vegetation blooms.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valley = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LifelikeWorld( [<span class="hljs-string"><span class="hljs-string">"############################"</span></span>, <span class="hljs-string"><span class="hljs-string">"##### ######"</span></span>, <span class="hljs-string"><span class="hljs-string">"## *** **##"</span></span>, <span class="hljs-string"><span class="hljs-string">"# *##** ** O *##"</span></span>, <span class="hljs-string"><span class="hljs-string">"# *** O ##** *#"</span></span>, <span class="hljs-string"><span class="hljs-string">"# O ##*** #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# ##** #"</span></span>, <span class="hljs-string"><span class="hljs-string">"# O #* #"</span></span>, <span class="hljs-string"><span class="hljs-string">"#* #** O #"</span></span>, <span class="hljs-string"><span class="hljs-string">"#*** ##** O **#"</span></span>, <span class="hljs-string"><span class="hljs-string">"##**** ###*** *###"</span></span>, <span class="hljs-string"><span class="hljs-string">"############################"</span></span>], {<span class="hljs-string"><span class="hljs-string">"#"</span></span>: Wall, <span class="hljs-string"><span class="hljs-string">"O"</span></span>: PlantEater, <span class="hljs-string"><span class="hljs-string">"*"</span></span>: Plant} );</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the time, plants multiply and grow, but then an abundance of food leads to an explosive growth of the herbivore population, which eat up almost all the vegetation, which leads to a massive extinction from starvation. </font><font style="vertical-align: inherit;">Sometimes the ecosystem is restored and a new cycle begins. </font><font style="vertical-align: inherit;">In other cases, one of the species dies out. </font><font style="vertical-align: inherit;">If herbivores, then the whole space is filled with plants. </font><font style="vertical-align: inherit;">If the plants are the remaining creatures, they die of starvation, and the valley turns into an uninhabited wasteland. </font><font style="vertical-align: inherit;">Oh, the cruelty of nature ...</font></font><br><br><h4>  Exercises </h4><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Artificial idiot </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is sad when the inhabitants of our world die out in a few minutes. To deal with this, we can try to create a smarter plant eater. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our herbivores have several obvious problems. First, they are greedy - they eat every plant they find until they completely destroy all the vegetation. Secondly, their random movement (remember that the view.find method returns a random direction) causes them to dangle inefficiently and die of hunger if there are no plants nearby. Finally, they multiply too fast, which makes cycles from abundance to hunger too fast. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write a new type of creature that tries to cope with one or more problems and replace it with the old type PlantEater in the world of the valley. Follow them. Make the necessary adjustments.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function SmartPlantEater() {} animateWorld(new LifelikeWorld( ["############################", "##### ######", "## *** **##", "# *##** ** O *##", "# *** O ##** *#", "# O ##*** #", "# ##** #", "# O #* #", "#* #** O #", "#*** ##** O **#", "##**** ###*** *###", "############################"], {"#": Wall, "O": SmartPlantEater, "*": Plant} ));</span></span></code> </pre><br><br><h5>  Predators </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any serious ecosystem, the food chain is longer than one link. </font><font style="vertical-align: inherit;">Write another creature that survives by eating herbivores. </font><font style="vertical-align: inherit;">You will notice that stability is even harder to achieve when cycles occur at different levels. </font><font style="vertical-align: inherit;">Try to find a strategy that will allow the ecosystem to work smoothly for some time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increasing the world can help in this. </font><font style="vertical-align: inherit;">Then local demographic explosions or downsizing are less likely to completely destroy the population, and there is room for a relatively large population of victims that can support a small population of predators.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function Tiger() {} animateWorld(new LifelikeWorld( ["####################################################", "# #### **** ###", "# * @ ## ######## OO ##", "# * ## OO **** *#", "# ##* ########## *#", "# ##*** * **** **#", "#* ** # * *** ######### **#", "#* ** # * # * **#", "# ## # O # *** ######", "#* @ # # * O # #", "#* # ###### ** #", "### **** *** ** #", "# O @ O #", "# * ## ## ## ## ### * #", "# ** # * ##### O #", "## ** OO # # *** *** ### ** #", "### # ***** ****#", "####################################################"], {"#": Wall, "@": Tiger, "O": SmartPlantEater, //    "*": Plant} ));</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/241776/">https://habr.com/ru/post/241776/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241766/index.html">markdown-it - markdown / CommonMark parser on steroids</a></li>
<li><a href="../241768/index.html">3 moderation outsourcing options you need to know</a></li>
<li><a href="../241770/index.html">3 obvious ways to get into the tips of search engines</a></li>
<li><a href="../241772/index.html">Report from SQA Days - Automation testing: discarding too much and checking the essence</a></li>
<li><a href="../241774/index.html">Interactive site with post-hawk? Easy!</a></li>
<li><a href="../241778/index.html">How we did the school of mobile developers in Saransk</a></li>
<li><a href="../241784/index.html">Incompatibility between the String.split method in Java 8 and Java 7</a></li>
<li><a href="../241788/index.html">Subtleties nodejs. Part I: the notorious app.js</a></li>
<li><a href="../241792/index.html">E-mail marketing: about the frequency of mailings - bluntly</a></li>
<li><a href="../241796/index.html">HTML5 standard has reached W3C recommendation status</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>