<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dell Powervault MD3 Storage Arrays</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sooner or later, many companies are faced with the need to store an ever-increasing amount of working information. Thus, according to studies, in 2011...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dell Powervault MD3 Storage Arrays</h1><div class="post__text post__text-html js-mediator-article">  Sooner or later, many companies are faced with the need to store an ever-increasing amount of working information.  Thus, according to studies, in 2011 the total amount of data generated reached 1.8 trillion GB, and according to Gartner, the total data growth by 2016 will be 850%.  And almost everywhere, in addition to storing such data, the ability to promptly access them and / or modify them is required.  The average data growth per year can exceed the mark of 100% and therefore the requirements for storage systems grow faster than the computing power of the servers.  In addition, the increase in disk capacity sometimes leads to unsatisfactory results from the use of traditional RAID schemes. <br><br>  There is a one-stop solution for such cases in the Dell portfolio: PowerVault MD3 high density data storage systems. <br><br>  The PowerVault MD3 product line can be divided into groups according to the form factor of the disks used (2.5 "or 3.5"), their type of connection to the existing infrastructure (SAS, iSCSI, FC) and expansion options.  Due to the scalability of the solution, the total number of disks used by the system can reach 180 units in the embodiment of high density disk shelves (4U), or 192 - in configurations with disk shelves of normal density (2U). <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/89a/f7d/499/89af7d499982e61a0d0fd9d2b8e6e1f0.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All key components of the system (controllers, power supplies, disks, fans) are duplicated and can be replaced in hot-swap mode, and the controllers have backup power from high-capacity capacitors to write the contents of the cache memory to non-volatile memory in case of external power failure.  Among the undoubted advantages of this solution is the ability to keep cache memory data consistent for any long time, much longer life of capacitors compared with batteries and no need for their preventive replacement on average every three years.  High-density arrays (4U or MD3x60 models) have separate independent shelves with which you can replace or add disks without stopping application I / O. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/802/1f2/0fa/8021f20fa52fc1ce64c1b1a3107704d9.png"><br><br>  In addition to the standard for this kind of storage, support for RAID-groups of levels 0, 1, 10, 5, 6, the MD3 family of arrays offers the user a separate disk management option - dynamic pools or Dynamic Disk Pools (DDP).  The DDP pool dynamically distributes data, free capacity, and parity information (parity) in the disk pool.  The size of the pools can range from a minimum of 11 disks to all available disks in a PowerVault MD3 storage system, including disk expansion shelves.  In addition to creating one or more dynamic pools, storage administrators can create traditional disk RAID groups together with dynamic pools, which provides the highest level of flexibility. <br><br>  DDP pools greatly simplify storage system administration, since you do not need to manage idle resources or many separate RAID groups. <br><br>  Dynamic Disk Pools pools consist of several low-level elements.  The first one is called the D-Piece.  It consists of a continuous 512 MB partition on a physical disk containing 4096 segments of 128 KB each.  From the selected disks in the pool, 10 D-Piece components are selected using an intelligent optimization algorithm.  The 10 connected D-Piece elements form a 4 GB D-Stripe.  The content of the D-Stripe component is similar to the RAID 6 section in the 8 + 2 configuration, where 8 base segments can contain user data, 1 segment contains parity information (P) derived from user data segments, and the last segment contains the Q value according to RAID 6 <br>  Virtual logical disks or LUNs (Logical Unit Number) are created, in essence, by combining several D-Stripe elements of 4 GB in size to obtain a given size of the virtual disk within the maximum allowable amount in the Dynamic Disk Pool. <br><br>  When the storage system administrator has finished defining the Dynamic Disk Pool pool, which for the most part consists of setting the required number of disks in the pool, the D-Piece and D-Stripe structures are created, similar to traditional RAID blocks when creating a virtual disk.  After determining the Dynamic Disk Pool in the pool, you can create a virtual disk.  This disk will consist of several D-Stripe elements placed across all disks in the pool, with a total volume up to a predetermined value of the capacity of the virtual disk, for example, the number of D-Stripe = selected capacity / 4 GB.  You can define multiple virtual disks in the Dynamic Disk Pool, and you can create several pools in the storage system itself. <br><br>  The storage system administrator can also create traditional disk RAID groups along with Dynamic Disk Pools pools or any combination of them.  Like traditional RAID disk groups, the Dynamic Disk Pools pools can be expanded by adding disks to the pool during the Dynamic Capacity Expansion (DCE) process.  Up to 12 disks can be added to the pool at the same time.  When a DCE operation is initiated, some of the existing D-Piece elements that form logical volumes are actually transferred to new disks, thereby increasing the number of physical disks that host the logical volume and increasing performance. <br><br>  Another important advantage of Dynamic Disk Pool is that instead of using dedicated isolated components for hot-swappable failed disks, the pool itself contains an integrated backup capacity, on each disk included in the pool, in case of possible failures.  This simplifies management because it no longer needs to plan or control individual dedicated hot-swap drives.  At the same time, the recovery time is significantly reduced (two to three times using large volumes of disks), and the performance of logical volumes during recovery practically does not fall compared with traditional dedicated hot-swap disks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cec/9e8/98f/cec9e898fe4dfa418b67564dd25f1870.png"><br><br>  In addition, if you consider that virtual disks in pools of Dynamic Disk Pools can contain a very large number of disks compared to traditional RAID 5 or RAID 6 disk groups with a maximum of 30 disks per group, then in environments with mixed or non-parallel loads, you can achieve advantages from the point of view of performance, since all the resources of the pool are immediately accessible to all logical volumes. <br><br>  In addition to using DDP, due to the possibility of combining solid-state drives and traditional hard drives in one solution, it became possible to implement caching on solid-state drives.  SSD caching allows the PowerVault MD3 array to use solid state drives as an extended read cache, thereby improving the performance of applications with a large number of random read operations, for example, for file servers, web servers, databases, etc. <br><br>  The cache on a solid-state drive is optional and is used along with the main one to improve performance.  When creating a cache on an SSD, it is split into two internal RAID 0 virtual disks (one disk per controller).  This cache volume is not available for normal data storage. <br><br>  In duplex mode, each controller uses a separate virtual disk, accessing only half of the solid-state drive space, even in the event of a controller failure or its transition to maintenance mode.  In simplex mode, one controller manages the entire SSD space and uses both virtual disks.  The maximum allowed cache size on a solid-state drive in PowerVault MD3 arrays is 4 TB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/55a/541/71255a54101f15b6f554085c7d5c61fd.png"><br><br>  SSD caching provides benefits for workloads with the following characteristics: <br><ul><li>  Read performance is limited by I / O speed for hard drives. </li><li>  A high percentage of read operations relative to write operations. </li><li>  The size of the working dataset is less than the cache size on the solid-state drive. </li></ul><br>  SSD cash is recommended when a balanced, cost-effective approach is required, using a combination of hard drives and cache on a solid-state drive, and the cost of dedicated SSD drives for individual logical volumes is prohibitive. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b1/a5f/fb7/9b1a5ffb79021fd57ce250f957bed6be.png"><br><br>  Another feature of the PowerVault MD3 storage system is synchronous and asynchronous remote replication.  It allows you to effectively replicate data, protecting information from system failures and power failures.  This feature duplicates data between PowerVault MD3 storage systems to ensure their availability in case of failures, as well as for other purposes related to the migration of business data. <br><br>  In the synchronous model, one array stores the primary virtual disk, and the second, remote, the secondary virtual disk of the replication pair.  After establishing a connection between the primary and secondary arrays, the primary array processes server-initiated write operations on the secondary virtual disk, sending write requests to the secondary array, while simultaneously performing these operations on the local array.  The primary array returns a successful result to the server system only after both arrays have completed the write operation. <br><br>  The synchronous model has several advantages, the most important of which is the ability to restore application data from the secondary array, including the latest updates.  If a critical failure occurs on the primary array, then application data can be recovered from the secondary array, then only write requests that were executed during the failure will be lost.  Since the application on the side of the primary array expects a positive response to the completion of current requests, their loss will not cause data discrepancies in the event of a server crash or server reload during execution.  Applications with even the most basic recovery capabilities can, in such cases, restore the integrity of the data themselves.  Consequently, using the synchronous remote replication model allows applications to implement fault tolerance.  The disadvantages of synchronous replication include high demands on communication channels. <br><br>  Asynchronous remote replication is an excellent choice for those who need protection against failures, but who do not have the means to implement synchronous replication models.  It is assumed that such consumers do not need an absolutely reliable recovery plan until the moment of failure, they are more interested in the cost-effectiveness of the solution.  In other words, asynchronous replication allows the consumer to use slower and less expensive communication channels between the primary and secondary arrays, if certain delays are allowed that are not available when using the synchronous replication model.  The model of asynchronous replication allows adjusting the duration of delays depending on the needs of the client in accordance with the capabilities and characteristics of the communication channel.  One of the main advantages of asynchronous remote replication is that the application performance in the main array will not be connected to the communication channel.  Of course, channel performance will affect the delay time, but will not directly affect application performance. <br><br>  Asynchronous remote replication is designed to work with relatively slow and low-speed communication channels (for example, TCP / IP channels for iSCSI).  Its main mode of operation includes configurable periods of variance, during which no attempts are made to transfer data from the primary to the secondary array.  Instead, the use of a dirty map allows the array to track the changed portions of the primary virtual disk for subsequent selective transfer to the secondary array.  After the expiration of the time period specified in the settings, the primary array begins to transfer the corresponding data to the secondary array.  This approach offers several advantages, each of which is especially important when using slow, global communication channels. <br><br><ul><li>  <u>Performance</u> .  During the discrepancy interval, no attempts are made to transmit changes via the communication channel.  Accordingly, the performance on the primary array does not depend on the characteristics of the communication channel.  The only reason for affecting performance is the relatively low latency associated with tracking blocks that have changed.  This is done by updating the dirty map on the primary array.  During synchronization using a point-in-time image, it allows replication without significant dependence of the I / O speed on the primary virtual disk on the speed and delays of the communication channel. </li><li>  Efficiency.  Since during the accumulation of changes during the period of discrepancy, there may be a lot of updates in the same blocks, asynchronous remote replication avoids the transfer of intermediate results.  In fact, only the block content that exists at the time of synchronization is transmitted through the communication channel. </li><li>  <u>Reliability</u>  Much attention is paid to ensuring the admissibility of block contents on the primary virtual disk and the possibility of its restoration before starting synchronization with the secondary array.  In particular, asynchronous remote replication checks the contents of the block selected on the primary virtual disk for synchronization for the record order in the primary array.  As a result, the user can be sure that the data images on the secondary array will be suitable for recovery if it is necessary to make the secondary virtual disk active. </li><li> <u>Simplicity</u>  If the secondary virtual disk becomes active due to a primary failure, there are situations where the operability of the primary array can later be restored.  This may occur if the problem or failure on the primary side was caused by a power or link failure, but this problem was later corrected.  In such cases, asynchronous remote replication maintains an optimized reverse synchronization with the transfer of only data differences to the original primary side.  In other words, only those blocks that have changed since the transition of the secondary virtual disk to the active state will be transferred to the primary virtual disk.  Therefore, it is possible to restore the original primary array in its role without demanding full synchronization. </li><li>  <u>Distance</u>  Asynchronous remote replication supports FC and iSCSI networks.  The iSCSI interface uses standard IP networks to replicate data over much longer distances than typical FCs.  In addition, asynchronous remote replication does not require a dedicated server port to perform replication I / O operations; they are performed through the same iSCSI ports as the server I / O. </li></ul><br>  Asynchronous remote replication for Dell PowerVault MD3 storage systems is a valuable solution for those customers who need to provide fault tolerance to protect critical business data without the serious financial investment required by synchronous remote replication mechanisms.  Asynchronous remote replication can be used on relatively slow communication channels, allowing the user to provide a reasonable compromise between RPO (Return Point Objective) and the cost of communication lines.  Consequently, asynchronous remote replication allows data to be transmitted over long distances via TCP / IP networks, providing protection against disasters, but without significantly affecting the performance of applications on the primary node. <br><br>  In addition, the use of efficient MD Storage Manager software provides simple and easy-to-use tools for setting up and monitoring based on tasks.  Add to this the VMware vStorage APIs for array integration (support VAAI, VASA), support for the operating systems WS2008, Windows 2012, RHEL 5.8, 6.2, SLES 10.4, 11.2, Citrix XenServer, VMware ESXi 5.0, 5.1, MS Hyper-V 2008, work with thin volumes and you get a reliable system for using the most modern and most resource-intensive applications.  Based on the requirements for the system, you can use the 90-day trial license to use the following functionality: <br><ul><li>  work with snapshots and snepklonami; </li><li>  High Performance Tier configurations - using SSD cache on disks; </li><li>  use synchronous / asynchronous replication (between two arrays). </li></ul><br>  Activation is performed via a GUI (MD Storage Manager) and automatically turns off after 90 days of use.  At the same time, working data is not lost, but becomes unavailable until the license is purchased. <br><br>  Thus, PowerVault MD3 storage systems can find their application in a wide range of tasks.  From general class tasks (consolidation of business applications, virtualization projects, archival storage systems, etc.) to high-performance computing applications (computing clusters, video surveillance, distribution of digital content). <br><br>  <i>For more information on the configuration, capabilities, or terms of ordering PowerVault MD3 family storage systems, you can contact <a href="">Marat Rakayev</a> , Dell's Moscow office.</i> </div><p>Source: <a href="https://habr.com/ru/post/206180/">https://habr.com/ru/post/206180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206166/index.html">Private space - Per aspera ad astra</a></li>
<li><a href="../206168/index.html">Overview of switches with 24 10Gb optical ports</a></li>
<li><a href="../206170/index.html">Optimal storage architecture for virtual infrastructure backups</a></li>
<li><a href="../206172/index.html">Ten major events of 2013</a></li>
<li><a href="../206178/index.html">Cloud hosting for a simple site</a></li>
<li><a href="../206182/index.html">Transformation of threats in the information space: from technological to social. Part II</a></li>
<li><a href="../206186/index.html">Open Terminal Client - First Step</a></li>
<li><a href="../206188/index.html">Taskurotta or process management in a distributed system</a></li>
<li><a href="../206192/index.html">DIY mini-desktop</a></li>
<li><a href="../206198/index.html">A passion for programming. Chapter 10. Fall in Love or Throw It</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>