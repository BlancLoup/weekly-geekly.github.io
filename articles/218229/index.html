<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compile life</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is not about what to do while the project is going. 

 The phrase ‚ÄúPatterns is a full-fledged, turing-complete, language‚Äù is often perceiv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compile life</h1><div class="post__text post__text-html js-mediator-article">  <i>The article is not about what to do while the project is going.</i> <br><br>  The phrase ‚ÄúPatterns is a full-fledged, turing-complete, language‚Äù is often perceived with distrust.  This is just a generalizing possibility of modern programming languages, where does the computational capability come from?  I thought so too.  Now I want to convince the rest, along the way explaining how templates work for beginners, like me. <br><br>  My understanding of templates was first shaken after reading the chapter ‚ÄúMetaprogramming‚Äù from the book about C ++ from the creator of C ++ - it seemed that they could actually be a full-fledged programming language within the programming language.  Anyway, there definitely is a recursion.  But the best way to prove yourself is to try and do what we do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are many implementations of the legendary game "Life" of John Conway, insane and not.  But they all have a common fatal flaw: each iteration of Life is <i>calculated</i> directly during the program operation.  Let's try to fix it. <br><a name="habracut"></a><br><h4>  What are templates? </h4><br>  This is the mechanism of the language that creates specific functions \ data types for you, allowing you to write generalized algorithms, data structures, and the like - the programmer will substitute the desired parameter, and the compiler will create the corresponding entity from the template. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> {</span></span> T i; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">  ‚Äî   ,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class">! </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sum</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } SomeClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; obj_1; SomeClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; obj_1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> i = sum&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;( <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">15.9</span></span> );</code> </pre> <br>  The compiler will create two independent classes for the parameters int and double, and one function sum that will accept and return a double value. <br>  Therefore, templates are called templates ‚Äî you create a class / function, do not fill in some parts, leave labels instead of omissions, list the names of these labels before describing the class, and that's it.  Then, when using the template entity, enter the necessary parameters in the corner brackets and the compiler will substitute them into the necessary parts of the code. <br><br>  "Do not fill in" you can type the variable by specifying before the name of the missing place class \ typename, or some value, indicating its type directly, instead of class \ typename. <br><br>  Although the typename and class in the template language have exactly the same meaning, the difference in spelling can be used to simplify the understanding of the code ‚Äî for example, you can use the typename where as a parameter can be not only complex, but also simple data types (plain old data), and class - where extremely complex ‚Äúadult‚Äù classes are expected. <br><br><h4>  And all? </h4><br>  In general, yes, that is enough. <br><br>  It is also desirable that the compiler complies with the C ++ 11 standard and is able to calculate the results of constant expressions containing simple functions at the compilation stage. <br><br>  But to simplify the code, we need aliases for types.  C ++ provides 2 mechanisms for calling something complicated with something simple: typedef and using.  The latter appeared in C ++ 11 and differs from typedef (which is a remnant of C) with a more understandable syntax and support for templating: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  "" ‚Äî      typedef std::vector&lt;string&gt; Strings; //  using Strings = std::vector&lt;string&gt;; //  //     typedef void (*FunctionType)(double); //    using FunctionType = void (*)(double); // FunctionType ‚Äî   ,  double,  void // ,   ‚Äî   ,    T template &lt;typename T&gt; typedef Matrix&lt;T, 3&gt; Cube&lt;T&gt;; //   template &lt;typename T&gt; using Cube = Matrix&lt;T, 3&gt;; // </span></span></code> </pre> <br>  Consequently, using is a more understandable and extended version of typedef.  Know about typedef, but use using. <br><br><h4>  What is life </h4><br>  Game Life is a life simulator of cells on the field.  There are many variants of the rules of Life, but we use the classic ones.  The living cell dies of boredom, if there are less than two neighbors, or hunger, if there are more than three neighbors.  In an empty cell, life arises only when there are strictly 3 living cells next to it, i.e.  have parents and an obstetrician. <br><br>  Let us analyze the problem: for Life, cells are needed, the space on which they are located, the way to determine the next state of each cell, based on the number of its neighbors. <br><br>  This means that the templates in C ++ should allow: setting the initial field, selecting each cell of a field, determining its neighbors, counting their number, determining the future state, forming the next field and looping the algorithm a certain number of times.  In addition, you need not forget about the output of all iterations of the algorithm. <br><br><h4>  Birth life </h4><br>  In the beginning was the cell: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// dead struct X { }; // alive</span></span></code> </pre><br>  And the binding of the cell type to the value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-comment"><span class="hljs-comment">//   ‚Äî   constexpr bool is_alive(); template&lt;&gt; //      constexpr bool is_alive&lt;O&gt;() { return false; } template&lt;&gt; //     X constexpr bool is_alive&lt;X&gt;() { return true; }</span></span></code> </pre> <br>  It should be clarified that the template language can operate only with data types and constant values ‚Äã‚Äãthat can be calculated at compile time. <br><br>  The word "constexpr" indicates to the compiler that the function should be able to be executed at the compilation stage.  If the compiler seems to be unable to provide this for this function, it will generate an error. <br><br>  Still here a new feature of the template language is found - specialization.  This allows you to create special kinds of entities for specific parameters.  In the extreme case, with full specialization, as in the example above, only angle brackets remain from the list of templates. <br><br>  Specialization is the same opportunity that gives patterns a way out of recursion.  About her - a little later. <br><br><h5>  Starting conditions </h5><br>  We will not reinvent the wheel and set the playing field using the tuple from STL, the game parameters - by constants: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> start = tuple&lt; O, O, O, O, O, O, O, X, O, O, O, O, O, X, O, O, X, X, X, O, O, O, O, O, O &gt;; <span class="hljs-comment"><span class="hljs-comment">//   const int width = 5; const int height = 5; const int iterations = 20;</span></span></code> </pre> <br>  tuple - a data structure that can contain various types of data - a kind of heterogeneous array.  We will not store anything in it - we are only interested in the tuple type, consisting of the previously defined types O and X. It is important to understand that there are no values ‚Äã‚Äãthat fall into the assembled program, we are only interested in the type and work we are only with type. <br><br><h5>  Recursive counting of living cells </h5><br>  We turn to magic.  We remember that we need to count the living neighbors of the cell.  Let the neighbors of types O and X have already appeared in the tuple and we know their number: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple_counter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = is_alive&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_element&lt;N, tuple&gt;::type&gt;() + tuple_counter&lt;tuple, N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple&gt; <span class="hljs-comment"><span class="hljs-comment">//      N = 0 struct tuple_counter&lt;tuple, 0&gt; { constexpr static int value = is_alive&lt;typename tuple_element&lt;0, tuple&gt;::type&gt;(); };</span></span></code> </pre> <br>  What's going on here?  Recursion!  Let's take a closer look: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = is_alive&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_element&lt;N, tuple&gt;::type&gt;() + <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶</span></span></code> </pre> <br>  constexpr we have already met - the value is guaranteed to be calculated at the compilation stage and is constant. <br>  tuple_element &lt;N, tuple&gt; - obviously, the selection of the Nth element from the tuple, an option provided in STL. <br><br>  Why are there typename and :: type?  type - a tuple_element structure field, which is a typedef-alias of another type, and typename, roughly speaking, specifically indicates to the compiler that this is exactly the name of the template type. <br>  For more information about typename - <a href="http://pages.cs.wisc.edu/~driscoll/typename.html">here</a> . <br><br><pre> <code class="cpp hljs">‚Ä¶ + tuple_counter&lt;tuple, N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::value;</code> </pre> <br>  And here is the recursion itself.  To calculate the value, in the tuple_counter, the value of the same tuple_counter is used, only with the iteration number 1 less.  The exit from recursion will occur when N becomes equal to 0. The compiler will come across the tuple_counter pattern specialized for N = 0, in which there is no recursion, and calculate the final value.  Is done. <br><br>  All other calculations in the game, as well as the output of the result, are performed on the same principle - recursively. <br><br><h5>  Determining the next state of the cell </h5><br>  Well, suppose we have considered living neighbors - how can we know from this the next state of the cell?  It‚Äôs very simple if you don‚Äôt reinvent the wheel and use conditional from STL: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> point, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> neighbors&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">calc_next_point_state</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbor_cnt = tuple_counter&lt;neighbors, tuple_size&lt;neighbors&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> conditional &lt; is_alive&lt;point&gt;(), <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> conditional &lt; (neighbor_cnt &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) || (neighbor_cnt &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>), O, X &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> conditional &lt; (neighbor_cnt == <span class="hljs-number"><span class="hljs-number">3</span></span>), X, O &gt;::type &gt;::type; };</code> </pre> <br>  conditional - a template analogue of the ternary operator X?  Y: Z. If the condition in the first parameter is true - then the second parameter, otherwise - the third.  The rest of the code, I think, no longer needs explanations. <br><br><h5>  Playing field </h5><br>  Great - we have an initial playing field and a way to determine the next state for any cell on it.  Let us ease our life and combine all the main functions of Life in one place: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> initial_state&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">level</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">//     using point = typename tuple_element&lt;N, initial_state&gt;::type; template &lt;int N&gt; // (  )     using neighbors = tuple&lt; point&lt; /* */ &gt;, ... &gt;; template &lt;int N&gt; //     using next_point_state = typename calc_next_point_state&lt;point&lt;N&gt;, neighbors&lt;N&gt;&gt;::type; };</span></span></code> </pre> <br>  Try not to make mistakes when calculating the neighbor's index - in case of going beyond the tuple, you will get about 56 incomprehensible compilation errors, depending on the size of the field and the number of iterations. <br><br><h5>  Calculating the next field state </h5><br>  The further solution is obvious - let's go through all the cells, save the next state of each into an array, display the result, repeat for all iterations ... Array?  We do not have an array.  It is impossible to simply take and insert individual values ‚Äã‚Äãin a tuple - we work only with types, and changing the type of an individual element in a tuple is impossible. <br><br>  What to do?  Use tuple_cat - a language mechanism for combining several tuples into one.  Unfortunately, tuple_cat accepts tuple values, and we, again, are only interested in types.  You can follow the STL sources and find out how tuple_cat determines the type, invent your own tuplesiped, or use existing language tools. <br><br>  Fortunately, the decltype operator appeared in C ++ 11, which literally means ‚Äúwhat type would the function return if we called it‚Äù.  Apply it to tuple_cat and ... make sure that tuple_cat still accepts not the bare type ‚Äútuple‚Äù, with which we operate everywhere, but the value tuple.  Fortunately, in C ++ there is a declval class that allows us to pretend that the value does exist, but it cannot be used anywhere as a value.  It's enough. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_2&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_tuple_cat</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     tuple_cat,        tuple,    ? using result = decltype( tuple_cat( declval&lt;tuple_1&gt;(), declval&lt;tuple_2&gt;() ) ); };</span></span></code> </pre> <br>  Done!  Now you can recursively collect all the following states in a new state by adding cells one by one: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> field, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_field_state</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> point = level&lt;field&gt;::next_point_state&lt;N&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> next_field = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> my_tuple_cat &lt; tuple&lt; point&lt;point_count - iter&gt; &gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> next_field_state&lt;field, iter<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::next_field &gt;::result; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> field&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_field_state</span></span></span><span class="hljs-class">&lt;field, 1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> point = level&lt;field&gt;::next_point_state&lt;N&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> next_field = tuple&lt; point&lt;point_count - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; &gt;; };</code> </pre> <br>  Strange point indexing is needed for the correct order of the result.  Is done.  We considered the next state of Life in such a form in which it can be sent to the next cycle of calculations.  It remains only to display the result. <br><br><h5>  Output </h5><br>  The output functions do not carry any new knowledge, so I cite them under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Output functions</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> print&lt;O&gt;() { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"O"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> print&lt;X&gt;() { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"X"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Printer&lt;tuple, N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::print_tuple(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( N % width == <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; print&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_element&lt;N, tuple&gt;::type&gt;(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span><span class="hljs-class">&lt;tuple, 0&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ print&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, tuple&gt;::type&gt;(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> field, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iters&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game_process</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Printer&lt; field, point_count - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;::print_tuple(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; game_process&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> next_field_state&lt;field, point_count&gt;::next_field, iters<span class="hljs-number"><span class="hljs-number">-1</span></span> &gt;::print(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> field&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game_process</span></span></span><span class="hljs-class">&lt;field, 0&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Printer&lt; field, point_count - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;::print_tuple(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre> <br></div></div><br><h4>  In conclusion </h4><br>  It remains to set the initial field in the source code, the number of iterations and breathe life into life, fully defined before the beginning of its life. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ game_process&lt; start, iterations &gt;::print(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  By creating Life, we proved to ourselves the usefulness of C ++ templates as a language, and also got a way to kill compilers who are too lazy to clean memory after recursive calls to template functions. <br><br>  Life is in itself a full-fledged language.  So, in the game Life, it is theoretically possible to build a C ++ 11 compiler for the source of Life with a C ++ 11 compiler ... I leave this task to bored immortal readers for an independent decision. <br><br>  The page of the working project on <a href="https://github.com/sirgal/compile-time-game-of-life">GitHub</a> . <br>  References: <a href="http://www.amazon.com/The-Programming-Language-4th-Edition/dp/0321563840">The C ++ Programming Language, 4th Edition</a> . </div><p>Source: <a href="https://habr.com/ru/post/218229/">https://habr.com/ru/post/218229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218215/index.html">Web application evolution</a></li>
<li><a href="../218217/index.html">[video] How to put a person in place: 10 real questions about the pressure in the negotiations</a></li>
<li><a href="../218221/index.html">April 4 - the Day of St. Isidore of Seville and the day of the webmaster</a></li>
<li><a href="../218225/index.html">Micro ORM one class</a></li>
<li><a href="../218227/index.html">Autoconfiguration (Auto Setup) of Polycom Phones Using Asterisk</a></li>
<li><a href="../218231/index.html">SaltStack: managing an arbitrary number of configuration files</a></li>
<li><a href="../218233/index.html">LPC1102 and warm lamp indicator</a></li>
<li><a href="../218237/index.html">Creating a hosting site based on Proxmox + HP ProLiant</a></li>
<li><a href="../218241/index.html">Happy webmasters!</a></li>
<li><a href="../218243/index.html">Big data and their storage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>