<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CSS is not black magic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All web programmers have to write CSS from time to time. When confronted with it for the first time, you will most likely find that understanding CSS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CSS is not black magic</h1><div class="post__text post__text-html js-mediator-article">  All web programmers have to write CSS from time to time.  When confronted with it for the first time, you will most likely find that understanding CSS is nonsense.  And the truth is - they added borders here, they changed the color there ... JavaScript - this is a really complicated thing.  CSS is a toy compared to it. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/333506/"><img src="https://habrastorage.org/web/91c/c91/3fe/91cc913fe47641459792318d3aa9c063.jpg"></a> <br><br>  However, as you improve on web development, a frivolous attitude to CSS will be a thing of the past.  Faced with something indescribably strange, you realize that you simply can‚Äôt imagine how CSS works, what is being done in its depths.  Something similar was with me.  The first couple of years after my studies, I was engaged in JavaScript-development of a full cycle, occasionally referring to CSS.  I have always believed that my bread is JavaScript, I gave him all my time. <br><a name="habracut"></a><br>  For example, participated in discussions on <a href="https://devchat.tv/js-jabber/my-js-story-aimee-knight">JavaScript Jabber</a> .  In the last year, I decided to focus on the frontend and only then I realized that I could not, for example, debug style sheets in the same way as JS code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About CSS, they often joke, but few took it seriously enough and tried to understand it.  Who, when confronted with a problem, thoughtfully engaged in the search for errors, given the way CSS handles browsers?  Instead, we grab the code from the first answer to the Stack Overflow, do not disdain all sorts of hacks, or simply ignore the problems. <br><br>  As a result, too often, developers simply shrug their shoulders when the browser creates incomprehensible things with styles.  It‚Äôs time to think that CSS is like black magic.  However, any programmer knows that a computer is a machine for parsing and executing human-written commands, and CSS, in this regard, is no different from our favorite JS.  And if so - CSS is quite possible to learn and use it meaningfully and productively. <br><br>  Knowledge of the internal mechanisms of the CSS is useful in different situations.  For example - with serious debugging and optimizing the performance of web pages.  Often, when they talk and write about CSS, they focus on solving common problems.  I want to talk about how it all works. <br><br><h2>  <font color="#3AC1EF">DOM and CSSOM</font> </h2><br>  For a start, it is important to understand that in browsers, among other subsystems, there is a JavaScript-engine and a rendering engine.  We, in this case, are interested in the latter.  For example, we discuss the details that relate to WebKit (Safari), Blink (Chrome), Gecko (Firefox), and Trident / EdgeHTML (IE / Edge). <br><br>  The browser, in the course of displaying a web page on the screen, performs a specific sequence of actions leading to the construction of an object model document (DOM, Document Object Model) and a style sheet object model (CSSOM, CSS Object Model).  This sequence of actions, simply, can be represented as follows: <br><br><ul><li>  <b>Conversion</b> : reading bytes of HTML and CSS code from disk or downloading them from the network. <br><br></li><li>  <b>Tokenization</b> : <b>splitting</b> the input data stream into fragments (for example: start tags, end tags, attribute names, attribute values), deleting unnecessary characters, such as spaces and line breaks. <br><br></li><li>  <b>Lexing</b> : this step is similar to tokenization, but here the type of each token is determined (for example: this token is a number, the one is a string literal, another one is the equality operator). <br><br></li><li>  <b>Syntax analysis</b> : here the system accepts a stream of tokens after lexing, interprets them using a specific grammar, and turns this stream into an abstract syntax tree. </li></ul><br>  After creating similar tree structures for CSS and HTML, the rendering engine generates, based on them, what is called a rendering tree.  This is part of the document layout process. <br><br>  The rendering tree is a model of the visual presentation of the document, which allows you to display the graphic elements of the document in the correct order.  The rendering tree is constructed using the following algorithm: <br><br><ul><li>  Starting at the root of the DOM tree, bypass all visible nodes. <br></li><li>  Skip the invisible nodes. <br></li><li>  For each visible node, find the corresponding rules in CSSOM and apply them. <br></li><li>  Generate visible nodes with content and styles computed for them. <br></li><li>  And finally, create a rendering tree, which includes, for all page elements visible on the screen, and their contents, and information about styles. <br></li></ul><br>  CSSOM can have a major impact on the rendering tree, but not on the DOM tree. <br><br><h2>  <font color="#3AC1EF">Rendering</font> </h2><br>  After the rendering tree and page layout have been created, the browser can proceed to displaying elements on the screen.  This is what this process looks like. <br><br><ul><li>  <b>Creating a page layout</b> .  This step involves calculating the size of the element and its position on the screen.  Parent elements can affect children.  Sometimes child elements can affect the parent. <br><br></li><li>  <b>Rendering</b> .  During this stage, the rendering tree is converted into images that are the basis of what will be displayed on the screen.  This includes text, colors, images, borders, and shadows.  Rendering is usually done on several layers, while if the page's JavaScript code affects the DOM, the page can be redrawn several times. <br><br></li><li>  <b>Layering</b>  At this stage, the layers are combined and the final image is formed, which will be visible on the screen.  In this case, since the elements of the page can be displayed on different layers, the layers need to be brought together in the correct order. <br></li></ul><br>  Page rendering time depends on the characteristics of the rendering tree.  In addition, the greater the width and height of the element - the longer the rendering time will be. <br><br>  Adding various effects can increase the page rendering time.  The output of graphic representations of elements is made in accordance with the context of the overlay, in the order in which they are located relative to each other.  First, those elements that are located below are displayed, then those that are located above.  Later, speaking about the <code>z-index</code> property, we will focus on this in more detail.  For those who are well aware of visual information, here is a great <a href="https://www.youtube.com/watch%3Fv%3DZTnIxIA5KGw">demonstration of the</a> process of forming a graphic representation of the page. <br><br>  Speaking about the output of a graphical representation of pages in browsers, hardware acceleration of graphics is often mentioned.  In such cases, they usually mean the acceleration of mixing layers.  We are talking about the use of video card resources to prepare for the output of web pages. <br><br>  Mixing layers using hardware acceleration can significantly increase the rendering speed compared to the traditional approach, which uses only the processor.  In connection with all this, it is impossible not to recall the <code>will-change</code> CSS property, the skillful use of which allows you to speed up the output of pages.  For example, when using CSS transformations, the <code>will-change</code> property allows the browser to be prompted that the DOM element will be transformed in the near future.  It looks like <code>will-change: transform</code> .  This allows the GPU to transfer some operations for drawing and flattening layers, which can significantly improve the performance of pages containing many animated elements.  You can improve performance with <code>will-change</code> by using the <code>will-change</code> constructs <code>will-change: scroll-position</code> , <code>will-change: contents</code> , <code>will-change: opacity</code> , <code>will-change: left, top</code> . <br><br>  It is important to understand that some properties can cause a change in the page layout, while changing others only redraws it.  Of course, from the point of view of performance, it is better if you can do only by redrawing the page with a constant layout. <br><br>  For example, changing the color of an element will leave the layout unchanged, resulting in only a redrawing of the element.  But a change in the position of an element will lead to a change in the layout, and to a redrawing of the element itself, its child elements, and, possibly, adjacent elements.  Adding a DOM node will also result in layout recalculation and page redrawing.  Serious changes, such as increasing the font size of an HTML element, change the layout and redraw the entire rendering tree. <br><br>  If you are like me, then you are probably more familiar with DOM than with CSSOM, so let's pay some attention to CSSOM.  It is important to note that by default, CSS is considered as a rendering blocking resource.  This means that the browser will not render until CSSOM is fully available. <br><br>  In addition, we must understand that there is no full compliance between DOM and CSSOM.  The differences in these structures are due to the presence in the DOM of invisible elements, scripts, meta tags, tags with proprietary information that is not displayed on the screen, and so on.  All this is not taken into account when building CSSOM, since it does not affect the graphical representation of the page. <br><br>  Another difference between DOM and CSSOM is that context-independent grammar is used in CSS analysis.  In other words, in the rendering engine there is no code that would bring CSS to some acceptable form, as is done when parsing HTML to create a DOM. <br><br>  When analyzing characters that form HTML elements, the browser is forced to take into account the surrounding characters, it needs more than just the language specification, since some elements in the markup may be missing, however, the engine, by all means, needs to be displayed page.  Hence the need for more complex data processing algorithms. <br><br>  Finishing the talk about rendering, we briefly consider the path of the web page from the set of bytes stored on the server to the data structures on the basis of which its graphical representation is formed. <br><br>  The browser performs an HTTP request by requesting a page from the server.  The web server sends the response.  The browser converts the data received from the server into tokens, which are then converted into DOM and CSSOM tree nodes.  After these trees are ready, the rendering tree is built, on the basis of which the page layout is formed, layer-by-layer rendering of elements and layer blending are performed.  The result is a web page that we see on the screen. <br><br><h2>  <font color="#3AC1EF">Selector Specificity</font> </h2><br>  Now that we‚Äôve gotten a little understanding of how the browser works, take a look at some of the most common moments that developers are confused about.  To begin, let's talk about the specificity of selectors. <br><br>  Very simply, the specificity of the selectors means applying cascading CSS rules in the correct order.  However, there are many ways to select a tag using a CSS selector, and the browser needs a way to decide which style to assign to a particular tag.  Browsers make similar decisions, calculating the specificity value for each selector. <br><br>  Calculating indicators of the specificity of selectors confuses many JavaScript developers, so let's look at this in more detail.  We will use the following example.  There is a <code>div</code> tag with the class <code>container</code> .  This tag has another <code>div</code> , the <code>id</code> which is <code>main</code> .  Inside <code>main</code> there is a tag <code>p</code> , which contains the tag <code>a</code> . <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span>Hello!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Now, without looking back, try to analyze the CSS below and say what color the link text will be in the <code>a</code> tag. <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">pa</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: yellow; } <span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: pink; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">pa</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: orange; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br>  Maybe red?  Or green?  Not.  The link will be pink with a specificity value of 1.1.1.  Here are the remaining results: <br><br><ul><li> <code>div #main pa: 1,0,3</code> </li> <li> <code>#main a: 1,0,1</code> </li> <li> <code>pa: 2</code> </li> <li> <code>a: 1</code> </li> </ul><br>  To find these numbers you need to perform the following calculations: <br><br><ul><li>  <b>The first number</b> is the number of ID selectors. <br><br></li><li>  <b>The second number</b> : the number of class selectors, attribute selectors (for example: <code>[type="text"]</code> , <code>[rel="nofollow"]</code> ) and pseudo-classes ( <code>:hover, :visited</code> ). <br><br></li><li>  <b>Number of the number</b> : the number of type selectors and pseudo-elements ( <code>::before, ::after</code> ) <br></li></ul><br>  For example, take a look at this selector: <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.navbar</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">li</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:visited</span></span></code> </pre> <br>  The value of specificity for it will be 1,2,2.  There is one ID, one class, one pseudo-class, and two element type selectors ( <code>li</code> and <code>a</code> ).  This value can also be read as if there are no commas in it, instead of 1,2,2‚Äì122. Commas are only here to emphasize that we are confronted with not three-digit decimal number, but three numbers.  This is especially important for theoretically possible results like 0.1,13.  If you rewrite it in the form of 0113, it will be unclear how to return it to its original state. <br><br><h2>  <font color="#3AC1EF">Positioning elements</font> </h2><br>  Now I would like to talk about positioning.  Positioning elements and creating a page layout, as we have already seen, go hand in hand. <br><br>  Layout design is a recursive process that can be invoked for the entire rendering tree as a result of a global change in styles, or only for a part of the tree, when the changes touch only certain elements that need to be redrawn.  Here is one interesting observation that can be made by referring to the rendering tree and imagining that it uses absolute positioning.  With this approach, the objects from which the page layout is built are not placed in the rendering tree in the same places as in the DOM tree. <br><br>  Often people ask me about the advantages and disadvantages of using flexbox and float.  Of course, flexbox is, in terms of usability, very well, being applied to the same element, the flexbox layout is rendered in about 3.5 ms, while rendering the float layout can take about 14 ms.  Thus, in order to take into account small but important details, it makes sense for JS developers to maintain their knowledge in the field of CSS in the same good condition as the knowledge in the field of JavaScript. <br><br><h2>  <font color="#3AC1EF">Z-index property</font> </h2><br>  And finally, I would like to talk about the <code>z-index</code> property.  At first glance it seems that there‚Äôs nothing to talk about here.  Each element in an HTML document may either be in front of or behind the others.  In addition, it only works for positioned elements.  If you set the <code>z-index</code> property for an element whose positioning is not explicitly specified, it will not change anything. <br><br>  The key to finding and fixing <code>z-index</code> issues is to understand the concept of overlay contexts.  Troubleshooting always begins with the root element of the overlay context.  The overlay context is the concept of placing HTML elements in three-dimensional space, in particular along the Z axis, relative to the user in front of the monitor.  In other words, it is a group of elements with a common parent, which together move along the Z axis, either closer to or further from the user. <br><br>  Each overlay context has one HTML element as the root element.  When the positioning and <code>z-index</code> properties are not used, the rules for interaction between elements are simple.  The order of the overlay elements corresponds to the order of their appearance in HTML. <br><br>  However, you can create new overlay contexts using properties that are different from the <code>z-index</code> , and here everything becomes more complicated.  Among them is the <code>opacity</code> property, when this value is less than one, <code>filter</code> , when the value of this property is different from <code>none</code> , and <code>mix-blend-mode</code> , whose value is not <code>normal</code> .  These properties actually create new overlay contexts.  Just in case, I want to remind you that blend mode allows you to specify how the pixels on a certain layer interact with the visible pixels on the layers below this layer. <br><br>  The <code>transform</code> property also triggers the creation of a new overlay context in cases where it is different from <code>none</code> .  For example, <code>scale(1)</code> and <code>translate3d(0,0,0)</code> .  Again, as a reminder, the <code>scale</code> property is used to resize an element, and <code>translate3d</code> allows the GPU to be used for CSS transitions, improving the quality of the animation. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  If for you this material has become the first step to a serious mastering of CSS, we hope you will very soon learn how to solve problems with styles yourself.  And <a href="https://gist.github.com/AimeeKnight/77b36738ec876965c6db5c6d39f4ef4f">here</a> you can find a list of additional materials that will help you deepen and expand your knowledge. <br><br>  Dear readers!  If you know CSS well, please tell us about how you dealt with it.  Share your experience.  We are sure it will be useful to many. </div><p>Source: <a href="https://habr.com/ru/post/333506/">https://habr.com/ru/post/333506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333496/index.html">Australian government hints at a possible ban on end-to-end encryption</a></li>
<li><a href="../333498/index.html">The book "Hitchhiker's Guide to Python"</a></li>
<li><a href="../333500/index.html">How we decided to build CosmoZoo</a></li>
<li><a href="../333502/index.html">Automatic serialization of Java objects in ASN.1</a></li>
<li><a href="../333504/index.html">Load testing of Web-systems. We continue training</a></li>
<li><a href="../333510/index.html">Paradigm - Mail.Ru Group design system, part 1: visual language</a></li>
<li><a href="../333512/index.html">Let's Encrypt: distribute video over HTTPS in one click</a></li>
<li><a href="../333514/index.html">Apply Fourier transform to create a guitar tuner on Android. Part 1</a></li>
<li><a href="../333518/index.html">React Native from the bell tower of Android development part 2</a></li>
<li><a href="../333522/index.html">Yandex opens CatBoost machine learning technology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>