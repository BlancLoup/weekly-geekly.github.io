<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Versioned migration of database structure: main approaches</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The problems of database version control and migration between versions have been raised more than once both in Habr√© ( 1 , 2 , 3 , etc.) and on the I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Versioned migration of database structure: main approaches</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/4e3e4698/cf047705/b8105e8b/f5e67492.jpg" align="left">  The problems of database version control and migration between versions have been raised more than once both in Habr√© ( <strong><a title="A simple approach to versioning MS SQL Server databases" href="http://habrahabr.ru/blogs/sql/89181/">1</a></strong> , <strong><a title="Versioning the database structure in MySQL: MySQL Migration with PHP" href="http://habrahabr.ru/blogs/php/90052/">2</a></strong> , <strong><a title="Database Migrations for .NET" href="http://habrahabr.ru/blogs/net/56175/">3</a></strong> , etc.) and on the Internet (mostly English). <br><br>  In the first section of this article, I consider the main problems that arise in the teams of programmers when making any changes to the database structure.  In the second section, I tried to identify the main general approaches to the form in which changes in the database structure can be stored and maintained during the development process. <br><a name="habracut"></a><br><h1>  Terminology </h1>  <strong><em>Database</em></strong> - a set of all database objects (tables, procedures, triggers, etc.), static data (immutable data stored in lookup tables) and user data (which change during the work with the application). <br><br>  <strong><em>Database structure</em></strong> is a collection of all database objects and static data.  User data are not included in the concept of database structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong><em>Database version</em></strong> - a specific state of the database structure.  Usually the version has a number associated with the version number of the application. <br><br>  <strong><em>Migration</em></strong> , in this context, is updating the database structure from one version to another (usually newer). <br><br>  In this sense, the term migration seems to be used in many sources (this was especially due to the <a title="Ruby on Rails Active Record Migrations" href="http://guides.rubyonrails.org/migrations.html">migration</a> from the Active Record gem, which is part of Ruby on Rails).  However, when using this term, ambiguity arises: a person who does not know the context would rather think that it is a matter of transferring a database from one DBMS to another (MySQL =&gt; Oracle), or even process / data migration between cluster nodes.  Therefore, I suggest, in cases where the context is not obvious, to use a more precise term: <strong><em>versional</em> migration</strong> of databases. <br><br><h1>  Why do you need it? </h1>  Developers who have already encountered the problem of out-of-sync versions of the database and applications can skip this section.  Here I will remind you why it is necessary to respect the parity of the versions of the application and the database and what a common problem arises. <br><br><h3>  The database version must match the application version. </h3><br>  So, imagine the following situation: a team of several programmers is developing an application that actively uses the database.  From time to time, the application is delivered in production - for example, this is a website that is deposited on a web server. <br>  Any programmer in the process of writing application code may need to change the database structure, as well as the data itself, which is stored in it.  I will give a simple example: let's say there is a non-nullable string field in one of the tables.  This field does not always have data, in which case an empty string is stored there.  At some point you decided that storing empty lines is semantically incorrect in some cases (see <strong><a title="MySQL, better to insert NULL or empty string?" href="http://stackoverflow.com/questions/1267999/mysql-better-to-insert-null-or-empty-string">1</a></strong> , <strong><a title="Handling null values" href="http://msdn.microsoft.com/en-us/library/ms172138(VS.80).aspx">2</a></strong> ), and it is correct to store NULLs.  In order to implement this, you will need the following steps: <br><br>  1. Change the field type to nullable: <br><blockquote> <code><font color="#0000ff">ALTER</font> myTable <font color="#0000ff">CHANGE COLUMN</font> myField myField <font color="#0000ff">VARCHAR</font> (255) <font color="#0000ff">NULL DEFAULT</font> <font color="#A31515">NULL</font></code> ; </blockquote><br>  2. Since in this table production database probably already contains empty lines, you make a volitional decision and treat them as a lack of information.  Therefore, you will need to replace them with NULL: <br><blockquote>  <code><font color="#0000ff">UPDATE</font> myTable <font color="#0000ff">SET</font> myField = <font color="#A31515">NULL</font> <font color="#0000ff">WHERE</font> myField = <font color="#A31515">''</font></code> ; </blockquote><br>  3. Modify the application code so that when it receives data from the database stored in this field, it will adequately respond to NULLs.  Writing to this field now also requires NULLs instead of empty strings. <br><br>  From point 3 it can be seen that the application and the database are inseparable parts of one whole.  This means that when delivering a new version of the application to the production, it is necessary to update the database version as well, otherwise the application will simply not be able to work correctly.  In this example, if only the application is updated to the new version, then at some point NULL will be inserted into the non-resettable field, and this is an obvious error. <br><br>  Thus, <strong>updating the application version requires correct versioned database migration</strong> . <br><br><h3>  Is it that simple? </h3><br>  Realizing that parity of database versions and applications is necessary, you need to make sure that database migrations to the required version will always be performed correctly.  But what is the problem here?  After all, at first glance, there is nothing complicated here! <br><br>  Here again we turn to a living example.  Suppose programmers in the development process write their changes to the structure and database data in a separate file in the form of SQL queries (both <a title="Data Definition Language" href="http://ru.wikipedia.org/wiki/Data_Definition_Language">DDL</a> and <a title="Data Modification Language" href="http://ru.wikipedia.org/wiki/DML">DML</a> queries).  And every time you update the latest version of the application, you simultaneously update the database to the latest version by executing queries from the SQL file itself ... But wait, <strong>from which version</strong> do you update the database to the latest version?  "From the past"?  But do you remember so well what exactly was the previous version (it was released 2 months ago)?  If not, how are you going to update it?  Indeed, without accurate information on the state of the structure and data, it is impossible to perform a correct migration: if you inadvertently execute queries that have already been executed once, this can lead to data loss or violation of their integrity. <br>  A simple example is replacing passwords with their MD5 sums.  If you re-execute such a request, the data can be restored only from the backup.  Anyway, any <code>UPDATE</code> 's, <code>DELETE</code> ' s, and even <code>INSERT</code> 's, executed repeatedly, can lead to extremely undesirable consequences.  Not to mention the late <code>TRUNCATE</code> 'ah and <code>DROP</code> ' ah (although such cases are much less likely). <br>  By the way, from this point of view, underperformance is no less dangerous for the performance of the application than overfulfilling. <br><br>  Thus, it can be concluded that in the process of versioned migration all requests should be executed <strong>only once</strong> and, moreover, <strong>in the correct sequence</strong> .  Consistency is important because some changes may depend on others (as in the example with a nullable field). <br><br><br><h1>  General principles of versioned migration </h1>  In the previous section, we outlined important criteria that show what is required of the version migration process.  It: <br><ul><li>  one-time execution of each change (SQL query); </li><li>  strictly pre-order changes. </li></ul>  Now we will single out more practical criteria in order to understand what to require from the process of creating and storing migrations.  In my opinion, for most development teams it will be important: <br><ul><li>  so that any version of the database can be updated to any (usually the latest) version; </li><li>  so that the set of SQL queries that implement the migration between any two versions can be obtained as quickly and easily as possible; </li><li>  so you can always create from scratch a database with the structure of the latest version.  This is very useful both in the development and testing process and in the deployment of a new production server; </li><li>  so that in case of working on different branches, during their subsequent merging, manual editing of the database files is minimized; </li><li>  to roll back the database to an earlier version was as easy as updating to a newer version. </li></ul><br><h3>  Base migration </h3><br>  As it turned out, most approaches have a general principle: they need a <strong><em>base</em></strong> (baseline) - a certain reference state of the database, from which one can make a start.  This concept is pretty well described in Scott Allen <a title="Versioning Databases - The Baseline" href="http://odetocode.com/blogs/scott/archive/2008/01/31/versioning-databases-the-baseline.aspx">'s Versioning Databases - The Baseline</a> article. <br><br>  Simply put, the base is a dump of the database structure for the version that is taken as the base version.  Having a <em>base</em> on hands, afterwards it will always be possible to create a database from scratch.  After applying to this database all migrations created during the development process, we will obtain a database with the latest version structure. <br><br>  Next, we will consider three approaches to the organization of versioned database migration. <br><br><br><h1>  Incremental change method </h1>  This method is well described in the article <a title="Versioning Databases - Change Scripts" href="http://odetocode.com/blogs/scott/archive/2008/02/02/versioning-databases-change-scripts.aspx">"Versioning Databases - Change Scripts" by</a> Scott Allen.  A similar approach is also described in the article <a title="Managing SQL scripts and continuous integration" href="https://michaelbaylon.wordpress.com/2011/04/13/managing-sql-scripts-and-continuous-integration/">‚ÄúManaging SQL scripts and continuous integration‚Äù by</a> Michael Baillon. <br><br><h3>  File structure </h3><br>  An example of how a folder with migration files might look like in this case: <br><blockquote> <code>Database <br> |- Baseline.sql <br> |- 0001. <strong>03</strong> .01.sql <br> |- 0002. <strong>03</strong> .01.sql <br> |- 0003. <strong>03</strong> .01.sql <br> |- 0004. <strong>03</strong> .02.sql <br> |- 0005. <strong>03</strong> .02.sql <br> |- 0006. <strong>03</strong> .02.sql <br> '- 0007. <strong>03</strong> .02.sql</code> </blockquote> <br>  In this example, all files created during the development of version <strong>03</strong> are stored in a folder.  However, the folder may be common to all versions of the application. <br><br>  In any case, the very first file to appear in such a folder is the <strong>base</strong> (Baseline.sql).  After that, any change in the database is submitted to the repository as a new migration file with the name of the form <code>[ ].[].[].sql</code> . <br><br>  In fact, in this example, the file name contains the full version number of the database.  That is, after the migration file with the name <code><b>0006</b> .03.02.sql</code> the database will be updated from the state corresponding to version <code>03.02. <b>0005</b></code>  <code><b>03.02. 0005</b></code> , up to version <code>03.02. <b>0006</b></code>  <code><b>03.02. 0006</b></code> . <br><br><h3>  Version history storage </h3><br>  The next step is to add a special table to the database in which the history of all changes in the database will be stored. <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE TABLE</font> MigrationHistory <br> ( <br> Id <font color="#0000ff">INT</font> , <br> MajorVersion <font color="#0000ff">VARCHAR</font> (2), <br> MinorVersion <font color="#0000ff">VARCHAR</font> (2), <br> FileNumber <font color="#0000ff">VARCHAR</font> (4), <br> Comment <font color="#0000ff">VARCHAR</font> (255), <br> DateApplied <font color="#0000ff">DATETIME</font> , <br> <br> <font color="#0000ff">PRIMARY KEY</font> (Id) <br> )</font> <br></code> </blockquote><br>  This is just an example of how a table might look.  If necessary, it can be both simplified and supplemented. <br><br>  In the <code>Baseline.sql</code> file, you will need to add the first entry to this table: <br><blockquote> <code><font color="black"><font color="#0000ff">INSERT</font> <font color="#0000ff">INTO</font> <br> MigrationHistory ( MajorVersion, MinorVersion, FileNumber, Comment,    DateApplied ) <br> <font color="#0000ff">VALUES</font> ( <font color="#A31515">'03'</font> , <font color="#A31515">'01'</font> , <font color="#A31515">'0000'</font> , <font color="#A31515">'Baseline'</font> , NOW() )</font> <br></code> </blockquote><br>  After each migration file is executed, an entry with all the migration data will be recorded in this table. <br>  The current version of the database can be obtained from the record with the maximum date. <br><br><h3>  Automatic migration </h3><br>  The final touch in this approach is a program / script that will update the database from the current version to the latest. <br><br>  Performing database migration is automatically quite simple, because  The last migration number can be obtained from the MigrationHistory table, and then all that is needed is to apply all files with higher numbers.  You can sort files by number, so there will be no problems with the order of migration. <br><br>  Such a script also has the task of adding records of completed migrations to the MigrationHistory table. <br><br>  As an added convenience, such a script can be able to create the current version of the database from scratch, first rolling the <em>base</em> onto the database, and then performing a standard migration operation to the latest version. <br><br><h3>  Pros, Cons, Conclusions </h3><br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  Quick and easy migration to the latest version; <br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  Version numbering mechanism.  The current version number is stored directly in the database; <br><img src="https://habrastorage.org/storage/0d0d6896/f4fc1d25/e437c3ba/a4e8274f.png">  For maximum convenience, we need automation tools for migrations; <br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png">  It is inconvenient to add comments to the database structure.  If you add them to Baseline.sql, then in the next version they will be lost, because  the base will be generated from scratch again, as a dump of the new version of the structure.  In addition, such comments will quickly become obsolete; <br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png">  There are problems in the process of parallel development in several branches of the repository.  Since the numbering of the migration files is sequential, files with different DDL / DML queries may occur under the same numbers in different branches.  As a result, when merging branches, you will have to either manually edit the files and their sequence, or start a new, ‚Äúmerged‚Äù branch with a new Baseline.sql, which takes into account changes from both branches. <br><br>  This method in various forms is quite widespread.  In addition, it is easy to simplify and modify to the needs of the project. <br>  On the Internet, you can find ready-made variants of scripts for incremental migration and embed them in your project. <br><br><br><h1>  Idempotent change method </h1>  This method is described in the Phil Heck <a title="Bulletproof Sql Change Scripts Using INFORMATION_SCHEMA Views" href="http://haacked.com/archive/2006/07/05/bulletproofsqlchangescriptsusinginformation_schemaviews.aspx">Bulletproof Sql Change Scripts Using INFORMATION_SCHEMA Views</a> article.  A description of the similar approach is also set forth in the answer to <a title="Database management code" href="http://stackoverflow.com/questions/340614/what-are-the-best-practices-for-database-scripts-under-code-control">this question</a> on StackOverflow. <br><br>  Under <a title="Idempotency - Wikipedia" href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B4%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">idempotency</a> refers to the property of an object to remain unchanged when you try to change it again. <br>  <font color="#aaaaaa">The theme comes to mind a funny <a title="Joey - omnipotent" href="http://www.youtube.com/watch%3Fv%3DMz0diDqM3Z0">scene</a> from ‚ÄúFriends‚Äù :)</font> <br><br>  The main idea of ‚Äã‚Äãthis approach is to write migration files so that they can be executed on the database more than once.  The first time you try to execute any of the SQL commands, the changes will be applied;  for all subsequent attempts, nothing will happen. <br><br>  This idea is easiest to understand by example.  Suppose you need to add a new table to the database.  If you want, in the event that it already exists, there was no error when executing the query, MySQL has a short syntax for this purpose: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> <font color="#ff0000"><strong>IF NOT EXISTS</strong></font> myTable <br> ( <br> id <font color="#0000ff">INT</font> (10) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> myField <font color="#0000ff">VARCHAR</font> (255) <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (id) <br> );</font></code> </blockquote> <br>  Due to the key phrase <code>IF NOT EXISTS</code> , MySQL will only try to create a table if a table with that name does not already exist.  However, this syntax is not available in all DBMS;  besides, even in MySQL it can be used not for all commands.  Therefore, we consider a more universal way: <br><blockquote> <code><font color="black"><font color="#0000ff">IF NOT EXISTS</font> <br> ( <br> <font color="#0000ff">SELECT</font> * <br> <font color="#0000ff">FROM</font> information_schema.tables <br> <font color="#0000ff">WHERE</font> table_name = <font color="#A31515">'myTable'</font> <br> <font color="#0000ff">AND</font> table_schema = <font color="#A31515">'myDb'</font> <br> ) <br> <font color="#0000ff">THEN</font> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">TABLE</font> myTable <br> ( <br> id <font color="#0000ff">INT</font> (10) <font color="#0000ff">NOT</font> <font color="#0000ff">NULL</font> , <br> myField <font color="#0000ff">VARCHAR</font> (255) <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (id) <br> ); <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ;</font></code> </blockquote> <br>  In the last example, the role of the conditional parameter parameter is a query that checks whether the table <code>myTable</code> in the database <code>myDb</code> .  And only if the table is missing, in fact, its creation will occur.  Thus, the above query is idempotent. <br><br>  It is worth noting that in MySQL for some reason it is forbidden to execute <a title="Data Definition Language" href="http://ru.wikipedia.org/wiki/Data_Definition_Language">DDL</a> queries within conditional expressions.  But this prohibition is easy to get around - it is enough to include all such requests in the body of the stored procedure: <br><blockquote> <code><font color="black">DELIMITER $$ <br> <br> <font color="#0000ff">CREATE</font> <font color="#0000ff">PROCEDURE</font> sp_tmp() <font color="#0000ff">BEGIN</font> <br> <br> <font color="#0000ff">IF</font> <font color="#0000ff">NOT</font> <font color="#0000ff">EXISTS</font> <br> ( <br> <font color="#008000">--</font> <br> <font color="#008000">-- .</font> <br> <font color="#008000">--</font> <br> ) <br> <font color="#0000ff">THEN</font> <br> <font color="#008000">--</font> <br> <font color="#008000">-- ,   .</font> <br> <font color="#008000">--</font> <br> <font color="#0000ff">END</font> <font color="#0000ff">IF</font> ; <br> <br> <font color="#0000ff">END</font> ; <br> $$ <br> <br> DELIMITER; <br> <br> <font color="#0000ff">CALL</font> sp_tmp(); <br> <br> <font color="#0000ff">DROP</font> <font color="#0000ff">PROCEDURE</font> sp_tmp;</font></code> </blockquote> <br><br><h3>  What kind of bird is information_schema? </h3><br>  Complete information about the database structure can be obtained from special system tables located in the database named <code>information_schema</code> .  This database and its tables are part of the SQL-92 standard, so this method can be used on any of the modern DBMSs.  The previous example uses the <code>information_schema.tables</code> table, which stores data about all the tables.  Similarly, one can check the existence and metadata of table fields, stored procedures, triggers, schemas, and, in fact, any other objects in the database structure. <br><br>  A complete list of tables with detailed information on their purpose can be found <a title="SQL-92 Standard" href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">in the text of the standard</a> .  A short list can be seen in the <a title="Bulletproof Sql Change Scripts Using INFORMATION_SCHEMA Views" href="http://haacked.com/archive/2006/07/05/bulletproofsqlchangescriptsusinginformation_schemaviews.aspx">Phil Hack article</a> already mentioned above.  But the easiest way, of course, is to simply open this database on any working database server and see how it works. <br><br><h3>  Usage example </h3><br>  So, you know how to create idempotent SQL queries.  Now we will consider how this approach can be used in practice. <br><br>  An example of how a folder with sql files might look like in this case: <br><blockquote> <code>Database <br> |- 3.01 <br> |   |- Baseline.sql <br> |   '- Changes.sql <br> | <br> '- 3.02 <br> |- Baseline.sql <br> '- Changes.sql</code> </blockquote> <br>  In this example, a separate folder is created for each minor version of the database.  When creating each new folder, a base is generated and recorded in Baseline.sql.  Then, in the development process, all necessary changes are written to the Changes.sql file in the form of idempotent queries. <br><br>  Suppose that during the development process at different times programmers needed the following changes in the database: <br>  a) create a table myTable; <br>  b) add a newfield field to it; <br>  c) add some data to the myTable table. <br><br>  All three changes are written so as not to be re-executed.  As a result, no matter which intermediate state the database is in, executing the Changes.sql file will always migrate to the latest version. <br><br>  For example, one of the developers created a table myTable on his local copy of the database, recorded the change a) in the file Changes.sql stored in the code common repository, and for a while forgot about it.  Now, if it executes this file on its local database, the change a) will be ignored and the changes b) and c) will be applied. <br><br><h3>  Pros, Cons, Conclusions </h3><br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  Very convenient migration from any intermediate version to the last - you just need to execute one file on the database (Changes.sql); <br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png">  Potential situations are possible in which data will be lost, this will have to be monitored.  An example would be deleting a table, and then creating another table with the same name.  If during deletion only the name is checked, then both operations (deletion and creation) will occur every time the script is executed, despite the fact that they were once performed; <br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png">  In order for the changes to be idempotent, you need to spend more time (and code) to write them. <br><br>  Due to the fact that updating the database to the latest version is very simple, and it can be done manually, this method shows itself in a favorable light if you have many production servers and need to update them frequently. <br><br><br><h1>  Method of simulating database structure to source code </h1>  Separate articles on this approach, I unfortunately did not find.  I would be grateful for links to existing articles, if any.  <b>UPD:</b> In <a href="http://habrahabr.ru/blogs/sql/121909/">his article,</a> <a href="https://habrahabr.ru/users/absent/" class="user_link">Absent</a> talks about his experience in implementing a similar approach using a handwritten diff-utility. <br><br>  The main idea of ‚Äã‚Äãthis method is reflected in the header: the database structure is the same source code as PHP, C #, or HTML code.  Therefore, instead of storing the migration files in the code repository (with queries that change the database structure), you need to store only the current database structure - in a declarative form. <br><br><h3>  Implementation example </h3><br>  For simplicity of the example, we will assume that in each revision of the repository there will always be only one SQL file: CreateDatabase.sql.  In parentheses, I note that in the analogy with the source code, you can go even further and store the structure of each database object in a separate file.  Also, the structure can be stored in the form of XML or other formats that are supported by your DBMS. <br><br>  The CreateDatabase.sql file will store the <code>CREATE TABLE</code> , <code>CREATE PROCEDURE</code> , etc. commands that create the entire database from scratch.  If necessary, changes to the structure of the tables, these changes are made directly to existing DDL-requests to create tables.  The same applies to changes in stored procedures, triggers, etc. <br><br>  For example, in the current version of the repository, there is already a table myTable, and in the CreateDatabase.sql file it looks like this: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE TABLE</font> myTable <br> ( <br> id <font color="#0000ff">INT</font> (10) <font color="#0000ff">NOT NULL</font> , <br> myField <font color="#0000ff">VARCHAR</font> (255) <font color="#0000ff">NULL</font> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (id) <br> );</font></code> </blockquote> <br>  If you need to add a new field to this table, you simply add it to the existing DDL query: <br><blockquote> <code><font color="black"><font color="#0000ff">CREATE TABLE</font> myTable <br> ( <br> id <font color="#0000ff">INT</font> (10) <font color="#0000ff">NOT NULL</font> , <br> myField <font color="#0000ff">VARCHAR</font> (255) <font color="#0000ff">NULL</font> , <br> <strong><font color="#ff0000">newfield INT(4) NOT NULL</font></strong> , <br> <font color="#0000ff">PRIMARY</font> <font color="#0000ff">KEY</font> (id) <br> );</font></code> </blockquote> <br>  After that, the modified sql file is submitted to the code repository. <br><br><h3>  Performing migrations between versions </h3><br>  In this method, the procedure for updating the database to a newer version is not as straightforward as in other methods.  Since for each version only the declarative description of the structure is stored, for each migration it is necessary to generate a difference in the form of <code>ALTER</code> -, <code>DROP</code> - and <code>CREATE</code> queries.  This will help you automatic diff-utilities, such as the Schema Synchronization Tool, part of <a title="SQLyog home page" href="http://www.webyog.com/en/">SQLyog</a> , <a title="TOAD for MySQL home page" href="http://toadformysql.com/index.jspa">TOAD</a> , available for many DBMS, <a href="http://dklab.ru/lib/dklab_pgmigrator/">Dklab_pgmigrator</a> for PostgreSQL from <a href="https://habrahabr.ru/users/dmitrykoterov/" class="user_link">DmitryKoterov</a> , as well as <a title="SQL Home Page Comparison SDK" href="http://www.red-gate.com/products/SQL_Comparison_SDK/index.htm">SQL Comparison SDK</a> from RedGate. <br><br>  To migrate from one database version to another, you will have to restore the structure of the original and final versions on two temporary databases, and then generate a migration script.  However, this procedure can be automated and should not take much time. <br><br><h3>  How to deal with data changes? </h3><br>  From time to time, when updating the database version on production servers, it is necessary to update not only the database structure, but also the data stored in it.  As an example, the transfer of data from a table with the old structure to new tables can be given for the purpose of normalization.  Since the data on the production servers already exist and are used, it is not enough just to create new tables and delete old ones, you also need to transfer the existing data. <br><br>  In previous methods, in the context of storing and executing migrations, the data differed little from the database structure.  But in this method, changes in the data stand apart, because it is impossible to store them in the code repository in a declarative form: the data on all servers is different.  And it is also impossible to automatically generate such requests for changing data: it requires human intervention. <br><br>  This problem has several more or less acceptable solutions: <br><ul><li>  store data changes according to the incremental change method (perhaps in a simplified form) and add them to the resulting diff script after it has been generated, manually; </li><li>  never store request-data changes, and when the diff script is generated, analyze it and add all the necessary <a title="Data Modification Language" href="http://ru.wikipedia.org/wiki/DML">DML</a> requests in place.  I cite this decision here only because my colleague insists that it is working and has no flaws;  I find him too dangerous, because  The generation of the diff script can potentially occur several months after working on the application-related change area, and the details necessary for the correct migration of data may already be forgotten. </li></ul><br><h3>  Pros, Cons, Conclusions </h3><br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  It is convenient to observe changes in the structure between versions using the means of the version control system; <br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  Like any source code, the structure of the database is convenient to comment; <br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png">  In order to create from scratch a clean database of the latest version, you need to execute just one file; <br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Migration scripts are more reliable than other methods, since they are automatically generated; </font></font><br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Migrating from new versions to old is almost as easy as from old to new (problems can only arise with notorious data changes); </font></font><br><img src="https://habrastorage.org/storage/1476ed2e/4b966194/5b5ad7ca/a79a7f32.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of merging of two repository branches, the merge structure of the database is simpler than when using other approaches; </font></font><br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data changes will have to be stored separately, and then manually inserted into the generated migration scripts; </font></font><br><img src="https://habrastorage.org/storage/133eaec8/2c3b8eb5/449a20b1/e6c3e0b8.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manually performing migrations is very inconvenient; automated tools are needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method has many positive qualities. If you are not afraid of the described problems with data changes, and if production server updates are rare, I recommend using this method.</font></font><br><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ready solutions for database versioning migration </font></font></h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The methods described above can be used without third-party solutions; however, there are ready-to-use products, each with its own ideology and original approach, worthy of a separate article. </font><font style="vertical-align: inherit;">When choosing a version migration solution, be sure to consider such products. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some of them are discussed in a recent article </font></font><a title="    " href="http://outcoldman.ru/ru/blog/show/283"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúApproaches for versioning databases‚Äù by </font></font></a> <a href="http://outcoldman.habrahabr.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denis Gladkikh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a list of only a small part of ready-to-use version migration systems:</font></font><br><ul><li> <a title="Migrator.NET" href="http://code.google.com/p/migratordotnet/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Migrator.NET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="ECM7.Migrator" href="http://code.google.com/p/ecm7migrator/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECM7.Migrator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fork Migrator.NET by </font></font><a href="https://habrahabr.ru/users/dima117/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dima117</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a title="    .NET" href="http://habrahabr.ru/blogs/net/70884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">His article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Habr√©;</font></font></li><li> <a title="Ruby on Rails Active Record Migrations" href="http://guides.rubyonrails.org/migrations.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Active Record Migrations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> included in Ruby on Rails;</font></font></li><li> <a title="SQL Source Control" href="http://www.red-gate.com/products/sql-development/sql-source-control/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Source Control</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from RedGate;</font></font></li><li> <a title="DotNetMigrations" href="http://github.com/jpoehls/dotnetmigrations/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetMigrations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="Fluent Migrator" href="https://github.com/schambers/fluentmigrator/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluent Migrator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://habrahabr.ru/blogs/net/129242/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Habr√© for authorship of </font></font><a href="https://habrahabr.ru/users/tabushi/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabushi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who created the </font></font><a href="http://github.com/tabushi/fluentmigrator"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fork of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project;</font></font></li><li> <a title="DbDeploy.NET" href="http://dbdeploy.com/software/net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DbDeploy.NET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="Tarantino" href="http://code.google.com/p/tarantino/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantino</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="Mygrate" href="http://code.google.com/p/mygrate/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mygrate</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="DBUpdater" href="http://sourceforge.net/projects/dbupdater/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBUpdater</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li> <a title="Wizardby" href="http://code.google.com/p/octalforty-wizardby/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wizardby</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by </font></font><a href="https://habrahabr.ru/users/ostapbender/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ostapbender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://habrahabr.ru/blogs/net/56175/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">His article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Habr√©</font></font></li></ul><br><h1>  Finally </h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many different ways to store and apply changes to databases. </font><font style="vertical-align: inherit;">Which one of them you choose for your project is not so important, the main thing is to adopt one of the methods and follow it unswervingly.</font></font> The rest is details.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It was this idea that I tried to convey with this article by adding a classification of the simplest methods with my thoughts - in the hope that they will help you choose the most suitable solution for you. </font></font></div><p>Source: <a href="https://habr.com/ru/post/121265/">https://habr.com/ru/post/121265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121258/index.html">Snot blistering</a></li>
<li><a href="../121259/index.html">Facebook is preparing for the one hundred billion IPO in early 2012</a></li>
<li><a href="../121260/index.html">Are you still suffering without flash? Express review of Flash browsers for iPhone and iPad</a></li>
<li><a href="../121262/index.html">Traffic Signs Alert in Navigator</a></li>
<li><a href="../121264/index.html">Security and problems with it in MODx Revolution</a></li>
<li><a href="../121266/index.html">Do you have all the moves recorded? Pro GPS Logger</a></li>
<li><a href="../121268/index.html">EP is an easy and fast way to access public services</a></li>
<li><a href="../121270/index.html">Hacker group Lulz Security reached the sites of Bethesda Softworks and the US Senate</a></li>
<li><a href="../121272/index.html">Game section on the 27th Point in Moscow in conjunction with Alawar Entertainment</a></li>
<li><a href="../121273/index.html">Let me go out!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>