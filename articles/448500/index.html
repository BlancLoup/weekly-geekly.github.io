<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solve a simple crackme for Sega Mega Drive</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all, 





 Despite my great experience in the reverse of games under the Sega Mega Drive , I never solved cracks for it, and they did not co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solve a simple crackme for Sega Mega Drive</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello to all, </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> Despite my great experience in the reverse of games under the <code>Sega Mega Drive</code> , I never solved cracks for it, and they did not come across to me on the Internet.  But the other day there was a funny crack, which I wanted to solve.  I share with you the decision ... <a name="habracut"></a></p><br><h2 id="opisanie">  Description </h2><br><p>  The task description and the rum itself can be <a href="https://github.com/zznop/jump">downloaded here</a> . </p><br><p>  Despite the fact that the list of resources it says about Hydra, the standard de facto among the tools for debugging and reverse games on the Segou is <a href="https://github.com/lab313ru/smd_ida_tools">Smd Ida Tools</a> .  It has everything you need to solve this crack: </p><br><ul><li>  Roma Loader for Ida </li><li>  Debugger </li><li>  View and change RAM / VDP memory </li><li>  Displays almost complete information on VDP </li></ul><br><p>  We throw in the plug-ins for Ida the latest release, and start looking at what we have. </p><br><h2 id="reshenie">  Decision </h2><br><p>  The launch of any game on Segou begins with the execution of the vector <code>Reset</code> .  A pointer to it can be found in the second DWORD from the beginning of the rum. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  We see a couple of unidentified functions starting at address <code>0x27A</code> .  Let's take a look at what's there. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  From my own experience I will say that this is how the function of waiting for the completion of a <code>VBLANK</code> interrupt usually looks.  Let's see where else there is an access to the variable <code>byte_FF0026</code> : </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  We see that the zero bit is set in the <code>VBLANK</code> interrupt.  So the variable is called <code>vblank_ready</code> , and the function where it is checked is <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  Further, the function <code>sub_60E</code> is called by code.  Let's see what is there: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  What the first command writes to the <code>VDP_CTRL</code> is the <code>VDP</code> control command.  To find out what she does, we get on this command and press the <code>J</code> key: </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  We see that the entry in <code>CRAM</code> initialized (the place where the palettes are stored).  So, all the subsequent function code simply sets some initial palette.  Accordingly, the function can be called <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  We see that some command is <code>VDP_CTRL</code> again to <code>VDP_CTRL</code> , then we press <code>J</code> again and we learn that this command initializes the recording in the video memory: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Next, understand what is transferred to the video memory, it makes no sense.  So just call the load_vdp_data function. </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Here, almost the same thing happens as in the previous function, so without going into details, we simply call the function <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  There is already more code.  And, besides, in this function one more is caused.  Look right there - in <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  We see that in the <code>D0</code> register the command for <code>VDP_CTRL</code> , in <code>D1</code> - the value with which <code>VRAM</code> will be filled, and in <code>D2</code> and <code>D3</code> - the width and height of the fill (since two cycles are obtained: internal and external).  Call the function <code>fill_vram_by_addr</code> . </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  We return to the previous function.  Once the value in the <code>D0</code> register is transmitted as a command for <code>VDP_CTRL</code> , we press the <code>J</code> key on the value.  We get: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Again, from the experience of reverse games on the Segou, I can say that this command initializes the record of the mapping of tiles.  Addresses that begin with <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> in 90% of cases will be addresses of the regions with these same mappings.  What are mappings: <br>  these are values ‚Äã‚Äãthat can be used to indicate where to display a particular tile on the screen (a tile is a square of <code>8x8</code> pixels). </p><br><p>  So the function can be called as <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  The first command initializes the entry at <code>$F000</code> .  One note: among the <em>mapping</em> addresses, there is another region where the sprite table is stored (these are their positions, the tiles to which they point, etc.) Find out which region is responsible for what can be debugged.  But so far we don‚Äôt need it, so we <code>init_other_mappings</code> call the function just <code>init_other_mappings</code> . </p><br><p>  Also, we see that two variables are initialized in this function: <code>word_FF000A</code> and <code>word_FF000C</code> .  From my experience (yes, he decides) I will say that if some two variables are near in the address space and are associated with mappings, then in most cases these will be the coordinates of some object (for example, a sprite).  Therefore, I suggest calling them as <code>sprite_pos_x</code> and <code>sprite_pos_y</code> .  Error in <code>x</code> and <code>y</code> valid, because  Further under debugging it will be easy to fix. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Since the loop goes on through the code, it can be assumed that we have completed the main initialization.  Now you can look at <code>VBLANK</code> interruption. </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  We see that two variables are incremented (which is strange, in the list of links to each of them is absolutely empty).  But, since they are updated once per frame, you can call them <code>timer1</code> and <code>timer2</code> . </p><br><p>  Next, the <code>sub_2FE</code> function is <code>sub_2FE</code> .  Let's see what is there: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  And there - work with <code>IO_CT1_DATA</code> port (responsible for the first joystick).  The port address is loaded into the <code>A0</code> register, and passed to the <code>sub_310</code> function.  Go there: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  My experience helps me again.  If you see the code that works with the joystick and two variables in memory, then one stores the <code>pressed keys</code> , and the second holds the <code>held keys</code> , i.e.  just pressed and held keys.  So let's call these variables: <code>pressed_keys</code> and <code>held_keys</code> .  And then the function can be called as <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Call the function as <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Handler loop </h2><br><p>  Now everything looks much clearer: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  So this cycle responds to keystrokes, and performs the corresponding actions.  Let's go through each of the functions called in the loop. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  There is a lot of code here.  Let's start with the first function to be called: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  She does nothing - so it may seem at first.  Just return from the current function - <code>rts</code> .  But, since  on it only jumps occur ( <code>bsr</code> ), which means <code>rts</code> will take us back to the handler loop.  I would call this function as <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  Further we see the call to the <code>word_FF000E</code> variable.  It is not used anywhere except for the current function and, at first, I did not understand its purpose.  But, if you look closely, you can assume that this variable is needed only for a small delay between the processing of keystrokes.  ( <em>It is already poorly implemented in this rum, but I think it would have been much worse without this variable</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  Next we have a large amount of code that somehow processes the <code>sprite_pos_x</code> and <code>sprite_pos_y</code> , which can only say one thing - this is needed to display the selection sprite around the selected character in the alphabet. </p><br><p>  So now you can safely call the function as <code>update_selection</code> .  Go ahead. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  The code checks whether the bits of any keystrokes are set and calls certain functions.  Let's look at them. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Some kind of shaman magic.  First, <code>WORD</code> is taken from the <code>word_FF0018</code> variable, then one interesting instruction is executed: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  This command simply jumps to the instruction following it. </p><br><p>  Next is another magic: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  The value in register <code>D0</code> is put on top of the stack.  It is worth noting that in Segi, like in any <code>x86</code> , the return address from the function when it is called is placed on the top of the stack.  Accordingly, the first instruction puts some address on the top, and the second one picks it up from the stack and makes a transition on it.  <u>Good trick</u> . </p><br><p>  Now you need to understand what is the value in the variable, which then goes the transition.  But, for starters, let's call this variable <code>jmp_addr</code> . </p><br><p>  And the function is called: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Find out where this variable fills.  See the list of references: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  There is only one entry in this variable.  Let's look at it. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Here, depending on the coordinates of the sprite (remember that this is most likely the address of the selected character), this or that value is entered.  We see the following piece of code: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  The existing value is shifted to the right by 4 bits, the new value is placed in the lower byte, and the result is entered into the variable again.  In theory, our <code>jmp_addr</code> variable stores the characters that we can enter on the key entry screen.  Note also that the size of the variable is <code>WORD</code> . </p><br><p>  In fact, the function <code>sub_3A4</code> can be called as <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Now we have only one function left in the loop, which is not recognized.  And it is called <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Its code resembles the code of the <code>update_jmp_addr</code> function, only at the end we call the <code>sub_45E</code> function.  Look in there. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  We see that the number <code>#$4B1E2003</code> entered in the <code>D0</code> register, which is then sent to <code>VDP_CTRL</code> , which means that we are dealing with another <code>VDP</code> control command.  We press <code>J</code> , we receive a command of record to the region with <code>$Cxxx</code> . </p><br><p>  Next, the code is used to work with the variable <code>byte_FF0014</code> , which is not used anywhere except for the current function.  If you look at how it is used, you will notice that the maximum number that can be set in it is <code>4</code> .  I have the assumption that this is the current length of the key entered.  Let's check it out. </p><br><h4 id="zapuskaem-otladchik">  Run the debugger </h4><br><p>  I will use the <code>Smd Ida Tools</code> debugger, but, in fact, some <a href="https://gendev.spritesmind.net/page-gensK.html">Gens KMod</a> or <a href="https://github.com/TASVideos/gens-rerecording">Gens ReRecording</a> will be enough.  The main thing is to have a feature with the display of addresses in memory. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  My theory is confirmed.  So the variable <code>byte_FF0014</code> can now be <code>key_length</code> . </p><br><p>  There is one more variable: <code>dword_FF0010</code> , which is also used only in the current function, and its contents, after adding with the initial command in <code>D0</code> (remember, this was the number <code>#$4B1E2003</code> ) is sent to <code>VDP_CTRL</code> .  <code>add_to_vdp_cmd</code> think, I called the variable <code>add_to_vdp_cmd</code> . </p><br><p>  So what does this feature do?  I have an assumption that it draws the entered character.  It‚Äôs easy to check this by running the debugger, and comparing the state before calling the <code>sub_45E</code> function and after: </p><br><p>  Before: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  After: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  I was right - this function draws the entered character.  <code>do_draw_input_char</code> call it <code>do_draw_input_char</code> , and the function that calls it ( <code>sub_414</code> ) is <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Now what? </h2><br><p>  Let's check for now that the variable we called <code>jmp_addr</code> actually stores the key entered.  Let's use the same <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  As you can see, the guess was true.  What does this give us?  We can jump to any address.  Just what?  In the list of functions, all are dismantled because: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Then I started to simply scroll through the code until I discovered this: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  The trained eye saw the sequence <code>$4E, $75</code> at the end of the unbundled bytes.  This is the <code>rts</code> instruction opcode, i.e.  return from function.  So these unpartitioned bytes can be the code of some function.  Let's try to designate them as a code, click <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Obviously, this is the function code.  You can also click on it <code>P</code> , so that the code becomes a function.  Remember this name: <code>sub_D3C</code> . </p><br><p>  Then a thought arises: what if you jump on <code>sub_D3C</code> ?  It sounds good, though a single jump here will obviously not be enough, because  <code>word_FF0020</code> no more references to the <code>word_FF0020</code> variable. </p><br><p>  Then another thought came to me: what if I looked for another such unallocated code?  Open the <code>Binary search</code> (Alt + B) dialog, enter the <code>4E 75</code> sequence in it, put the <code>Find all occurrences</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Click <code></code> to start the search, we get the following results. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  At least two more places in the Roma may contain the function code, you need to check them.  We click on the first of the options, scroll slightly up, and again we see a sequence of undefined bytes.  Denote them as a function?  Yes!  Hit <code>P</code> where the bytes begin: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Cool!  Now we have a <code>sub_34C</code> function.  We try to repeat the same thing with the last of the options found, and ... we get a bummer.  There is such a large number of bytes before <code>4E 75</code> , which is not clear where the function begins.  And, obviously, not all of these bytes above are code, since  a lot of duplicate bytes. </p><br><h3 id="opredelyaem-nachalo-funkcii">  Determine the beginning of the function </h3><br><p>  It will be easiest for us to find the beginning of a function if we find where the data ends.  How to do it?  In fact, absolutely not difficult: </p><br><ol><li>  We turn to the beginning of the data (there will be a link to them from the code) </li><li>  We follow the link and look for a cycle in which the size of this data will have to appear. </li><li>  Mark up the array </li></ol><br><p>  So, we carry out the first item ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... and immediately see that the loop from our array is copied 4 data bytes at a time (because <code>move.l</code> ) into <code>VDP_DATA</code> .  Next we see the number <code>2047</code> .  It may first appear that the total size of the array is <code>2047 * 4</code> , but the loop based on <code>dbf</code> is performed by <code>+1</code> iteration more, since  The last compared value is not <code>0</code> , but <code>-1</code> . </p><br><p>  Total: the size of the array is equal to <code>2048 * 4 = 8192</code> .  Denote bytes as an array.  To do this, click <code>*</code> and specify the size: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  We turn to the end of the array, and we see there bytes, which are code bytes: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Now we have a <code>sub_2D86</code> function, and we have everything to solve this crack!  Let's see what the new function does. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  And it only enters the value of <code>#$4147</code> in the <code>D1</code> register and calls the <code>sub_34C</code> function.  Take a look at her. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  We see that the value of the <code>word_FF0020</code> variable is read here.  If you look at the links to it, you will see another place where the variable is written to this variable, and this will be exactly the place where I wanted to jump through the variable <code>jmp_addr</code> .  This confirms the guess that it is definitely necessary to jump on <code>sub_D3C</code> . </p><br><p>  But what was happening next I was too lazy to understand, so I threw rum in <a href="https://ghidra-sre.org/">GHIDRA</a> , found this function, and looked at the decompiled code: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  We see that the variable with the strange name <code>in_D1w</code> , and also the variable <code>DAT_00ff0020</code> , which reminds with its address the previously mentioned <code>word_FF0020</code> . </p><br><p>  <code>in_D1w</code> tells us that this value is taken from the <code>D1</code> register, or rather from its younger WORD half, and sets the <code>D1</code> register to the function that passes it.  Remember <code>#$4147</code> ?  So you need to designate this register as the input argument of the function. </p><br><p>  To do this, in the window with decompiled code, right-click on the function name, and select the <code>Edit Function Signature</code> menu item: </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  In order to indicate that the function takes an argument through a specific register, namely, not in the standard way for the current convention of calls, check the <code>Use Custom Storage</code> and click on the <u>green plus</u> icon: </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  The position for the new input argument appears.  We click on it twice, and we get the dialog indicating the type and carrier of the argument: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  In the decompiled code, we see that <code>in_D1w</code> is of type <code>ushort</code> , which means we will specify it in the field with type.  Then click the <code>Add</code> button: </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  A position will appear to indicate the carrier of the argument, we need to specify the <code>D1w</code> register in the <code>Location</code> , and click <code>OK</code> : </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  The decompiled code will look like: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  We know that the value of <code>param_1</code> is constant, transmitted by the calling function and is <code>#$4147</code> .  Then what should be the value of <code>DAT_00ff0020</code> ?  We consider: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Because  <code>xor</code> is a reversible operation, all constant numbers can be poked with each other and get the desired value of the variable <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  It turns out that the value of the variable should be <code>0x4553</code> .  It seems that I have already seen the place where this value is set ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Conclusions and solutions </h2><br><p>  We arrive at the following results: </p><br><ol><li>  First you need to jump to the address <code>0x0D3C</code> , for this you need to enter the code <code>0D3C</code> </li><li>  Jump to the function at address <code>0x2D86</code> , which sets the value of <code>#$4147</code> in register <code>D1</code> , for this you need to enter the code <code>2D86</code> </li></ol><br><p>  Experimentally, we find out the key that needs to be pressed to verify the entered key: <code>B</code>  We try: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Thank! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/448500/">https://habr.com/ru/post/448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448482/index.html">Factory testing of modular data center</a></li>
<li><a href="../448484/index.html">Aboriginal microbes</a></li>
<li><a href="../448486/index.html">‚ÄúIn November of 2018, we accidentally fell into spam on all fronts.‚Äù How I saved mailing with the company with a million base</a></li>
<li><a href="../448488/index.html">Fear and Loathing DevSecOps</a></li>
<li><a href="../448498/index.html">"Russia 404": How much is left to live free Internet</a></li>
<li><a href="../448504/index.html">Collected all "Habrom" directory "Issued by whom ..." for passports. Download to health</a></li>
<li><a href="../448506/index.html">‚ÄúThe Matrix‚Äù is 20 years old: how Wachowski made the cyberpunk that set the agenda for a whole generation</a></li>
<li><a href="../448510/index.html">Acer in 2019: what if you remove all the trinkets from the gaming laptops</a></li>
<li><a href="../448516/index.html">Evolving or making a base for a rote cart on the ARDUINO platform, while sensors and video are being driven to a computer via a smartphone</a></li>
<li><a href="../448518/index.html">How to see a black hole?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>