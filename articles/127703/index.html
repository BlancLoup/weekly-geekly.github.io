<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of the speed of backups using the file system (read ahead, read ahead)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is addressed to engineers and consultants working with productivity operations related to the sequential reading of files. Basically, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of the speed of backups using the file system (read ahead, read ahead)</h1><div class="post__text post__text-html js-mediator-article">  This article is addressed to engineers and consultants working with productivity operations related to the sequential reading of files.  Basically, these are of course backups.  Here you can also enable reading large files from file storages, some database operations, for example, full table scans (depending on the placement of data). <br><a name="habracut"></a><br>  Examples are given for the VxFS file system (Symantec).  This file system is widely used in server systems and is supported on HP-UX, AIX, Linux, Solaris. <br><br><h5>  Why do you need it? </h5><br>  The question is how to get the maximum speed while sequentially reading data into one stream (!) From a large file (backup of a large number of small files beyond the scope of this article).  We consider such sequential reading when data blocks from physical disks are requested one by one, in order.  We believe that file system fragmentation is absent.  This is justified, since if there are some large files on the file system and they are rarely re-created, then they are practically not fragmented.  This is a common situation for databases such as Oracle.  Reading from a file in this case differs little from reading from a raw device. <br><br><h5>  What is the speed of single-threaded reading? </h5><br>  The fastest of modern disks (15K rpm) have an access time (service time) of about 5.5 ms (for queuing theory fans, we assume the wait time is 0). <br>  Determine the number of I / O operations that the process can perform (backup): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1 / 0.0055 = 182 IO per second (iops). <br><br>  If the process sequentially performs operations, each of which lasts 5.5 ms, it will execute 182 pieces in a second.  Suppose the block size is 256KB.  Thus, the maximum throughput of this process will be: 182 * 256 = 46545 KB / s.  (46 MB / s).  Modest, right?  It looks especially modest for systems with hundreds of physical spindles when we count on a much higher reading speed.  The question arises how to optimize it.  Reduce the time to access the disk can not be, because it is technological limitations.  Parallelizing backup is also not always possible.  To remove this restriction on file systems, a read ahead mechanism is implemented. <br><br><h5>  How does read ahead work </h5><br>  In modern * nix systems, there are two types of I / O requests: synchronous and asynchronous.  With a synchronous request, the process is blocked until a response is received from the disk subsystem.  With asynchronous, it is not blocked and can do anything else.  When reading sequentially, we read the data synchronously.  When the read-ahead mechanism is enabled, the file system code, immediately after a synchronous request, makes some more asynchronous.  Suppose the process requested block number 1000. With read ahead turned on, in addition to block 1000, 1001,1002,1003,1004 will also be requested.  Thus, when requesting the block 1001, we do not need to wait 5.5 ms.  With the help of the read ahead setting, you can significantly (at times) increase the speed of sequential reading. <br><br><h5>  How is it configured? </h5><br>  The key to setting up a read ahead is its size.  Looking ahead, I‚Äôll say that there are two major problems with read ahead: insufficient read ahead and excessive.  So, on VxFS, read ahead is configured using the ‚Äúread_pref_io‚Äù and ‚Äúread_nstream‚Äù parameters of the vxtunefs command.  When forward reading is enabled on the VxFS, 4 blocks of read_pref_io are initially requested.  If the process continues to read sequentially, then 4 * read_pref_io * read_nstream is read. <br><br><h5>  Example </h5>  : <br>  Let read_pref_io = 256k and read_nstream = 4 <br><br>  Thus, the initial read ahead will be: 4 * 256KB = 1024KB. <br>  If the sequential reading continues, then: 4 * 4 * 256KB = 4096KB <br><br>  It should be noted that in the latter case, 16 requests with a 256KB block will be sent to the disk subsystem almost simultaneously.  This is not small and can load the array well for a short time.  In general, it is difficult to give some general advice in setting up read_pref_io and read_nstream.  Specific solutions always depend on the number of disks in the array and the nature of the load.  For some loads, read_pref_io = 256k and read_nstream = 32 work fine (a lot).  Sometimes, read_ahead is better off completely.  Since the setting is simple and it is set on the fly, the easiest way is to select the optimal value.  The only thing that can be advised is to always put read_pref_io in powers of 2. Or at least so that they are multiples of the size of the data block in the OS cache.  Otherwise, the consequences may be unpredictable. <br><br><h5>  OS buffer cache effect </h5><br>  When read ahead reads data asynchronously, it must be stored somewhere in memory.  To do this, use the file cache of the operating system.  In some cases, the file system can be mounted with the file cache disabled (direct IO).  Accordingly, the read ahead functionality is disabled in this case. <br><br><h5>  The main problems with advanced reading: </h5><br>  1) Insufficient read ahead.  The size of the block that requested the application is larger than the block read through read ahead.  For example, the command 'cp' can read 1024 KB block, and the read ahead is configured to read 256KB.  That is, there is simply not enough data to satisfy the application and another synchronous I / O request is needed.  In this case, turning on read ahead will not bring an increase in speed. <br><br>  2) Excessive read ahead <br>  - too aggressive read ahead can simply overload the disk subsystem.  Especially if there are few spindles in the backend.  A large number of almost parallel requests dropped from the host can flood the disk array.  In this case, instead of acceleration, you will see slowdowns in work. <br>  - another problem with read ahead may be misses when the file system erroneously determines the sequential reading, reads unnecessary data in the cache.  This leads to spurious I / O operations, and creates additional load on the disks. <br>  - since the read ahead data is stored in the cache of the file system, a large amount of read ahead can lead to more valuable blocks being flushed out of the cache.  These blocks then have to read from the disk again. <br><br>  3) Conflict between file system read ahead and disk array read ahead <br>  Fortunately, this is an extremely rare case.  Most modern disk arrays, equipped with cache memory and logic, implement their own read ahead mechanism at the hardware level.  The logic of the array itself determines the sequential read and the controller wholesale reads data from physical disks to the cache of the array.  This can significantly reduce the response time from the disk subsystem and increase the speed of sequential reading.  Ahead reading of the file system is slightly different from the usual synchronous reading and can confuse the controller of the disk array.  It may not recognize the nature of the load and not include hardware read ahead.  For example, if a disk array is connected via a SAN (Storage Area Networking) and there are several paths to it.  Due to load balancing, asynchronous requests can arrive at different ports of the disk array almost simultaneously.  In this case, requests can be processed by the controller in the wrong order as they are sent from the server.  As a result, the array does not recognize sequential reads.  Solving such problems may be the most time consuming and laborious.  Sometimes the solution lies in the configuration area, sometimes it helps to disable one of the read ahead (if possible), sometimes you need to change the code of one of the components. <br><br><h5>  An example of the effect of read ahead </h5><br>  The customer was not satisfied with the database backup time.  As a test, a single 50 GB file backup was performed.  Below are the results of three tests with different file system settings. <br><br>  Directories ... 0 <br>  Regular files ... 1 <br>  - Objects Total ... 1 <br>  Total Size ... 50.51 GB <br><br>  1. Advance read disabled (Direct IO) <br><br>  Run Time ... 0:17:10 <br>  Backup Speed ‚Äã‚Äã... 71.99 MB / s <br><br>  2. Standard read ahead settings (read_pref_io = 65536, read_nstream = 1) <br><br>  Run Time ... 0:05:17 <br>  Backup Speed ‚Äã‚Äã... 163.16 MB / s <br><br>  3. Increased (strongly) read ahead size (read_pref_io = 262144, read_nstream = 64) <br><br>  Run Time ... 0:02:27 <br>  Backup Speed ‚Äã‚Äã... 222.91 MB / s <br><br>  As you can see from the example, read ahead allowed to significantly reduce backup time.  Further operation showed that all other tasks on the system worked normally with such a large size read ahead (test 3).  No problems due to excessive read ahead were noticed.  As a result, these settings and left. </div><p>Source: <a href="https://habr.com/ru/post/127703/">https://habr.com/ru/post/127703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127696/index.html">Node: Scaling in small versus scaling in general</a></li>
<li><a href="../127697/index.html">Turning off the internal screen of the laptop in the Lion</a></li>
<li><a href="../127700/index.html">Intuition, puzzles and computability</a></li>
<li><a href="../127701/index.html">The next update of the issue interface with Yandex</a></li>
<li><a href="../127702/index.html">Google reports on "serious progress" in the fight against piracy</a></li>
<li><a href="../127707/index.html">How many computers do you have at home? (tablets and smartphones are not considered)</a></li>
<li><a href="../127708/index.html">Successfully implemented bearded idea</a></li>
<li><a href="../127709/index.html">Ask the most important thing in QIWI Wallet</a></li>
<li><a href="../127710/index.html">HP will keep the webOS business by dividing it into two divisions</a></li>
<li><a href="../127711/index.html">Iterator, ArrayAccess, Countable: Object as an array</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>