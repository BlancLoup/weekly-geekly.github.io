<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explicit JavaScript features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Reading another article about little-known features of the JavaScript language and quietly writing some irresponsible decisions in the browser console...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explicit JavaScript features</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/f_/vy/_s/f_vy_sw3-w-pyxs4zrpqejzpkq4.jpeg" alt="Image"></p><br><p>  Reading another article about little-known features of the <strong>JavaScript</strong> language and quietly writing some irresponsible decisions in the browser console, I often say in my head saying, well, on the fly, then of course everything is wrong !?  After all, the language has long acquired a huge community and has a surprisingly wide coverage of industrial development.  If so, then why do we often forget about its ability to be understandable for everyone and literally propagandize all these specific and ‚Äúremembered‚Äù constructions?  <em>Just make it Obvious!</em> </p><a name="habracut"></a><br><h2 id="rassuzhdeniya-na-temu">  Reasoning on the topic </h2><br><p>  <em>You can skip this graphomania.</em> </p><br><p>  If we talk about industrial development, in most cases the requirement for the code to be supported is even more important than solving the problem posed by the business.  For many, this is obvious, for some - partly (there are of course rare D'Artagnan).  The clearer our code, the less risk for it - to get to the dusty shelf, and for us and our successors - to earn problems with the nervous system. </p><br><p>  It's no secret that JavaScript is amazing in its flexibility, which is both its greatest virtue and an annoying curse.  The way of the JavaScript-developer is long and extremely interesting: we absorb book by book, article by article and we gain unique experience, but in some places it is really language-specific.  The widest distribution of the language and at the same time the rich number of accumulated and fed up non-obviousness contribute to the formation of two fronts: those who almost worship the language and those who look at it as an awkward and swinging duck. </p><br><p>  And everything would be fine, but often representatives of both fronts work on the same project.  And the usual, accepted practice is misunderstanding (unwillingness to understand and even ignoring) each other‚Äôs code.  And in the case itself, <em>"I was settling for a Java developer, and not this is yours!"</em>  .  JavaScript followers themselves say that <em>"no one really knows JavaScript!"</em>  yes <em>"I can write it in one line on js!"</em>  .  I confess that I myself am abusing abnormal programming at my leisure ... </p><br><p>  You start to feel this problem when you take the place of a marginal and gain some experience with people and their code on both sides of the barricades.  Planing and other meetings are more productive when all developers understand each other not only at the level of business parties, but at least a little at the level of their implementation.  The notorious <a href="https://medium.com/tech-tajawal/the-bus-factor-6ea1a3ede6bd">bass factor has</a> less impact on the project, when in the case of illness of a single front-end, the rest of the team do not disdain to correct some line of the <em>.js</em> file.  The process of sharing knowledge in a team and beyond it becomes more transparent for everyone when everyone has a more detailed picture.  Well, all in the same vein. </p><br><p>  I don‚Äôt urge anyone to ‚Äúfull-stack‚Äù or ‚ÄúT-shuffle‚Äù (how to say it right now?), But why don't we raise this curtain a little even from the JavaScript community?  To do this, you just need to add a little bit more explicitness to our code, using the flexibility of the language, not to show off, but to understand us. </p><br><h2 id="vzroslenie-i-prinyatie-otvetstvennosti">  Growing up and taking responsibility </h2><br><p>  For its part, JavaScript has long recognized its role not as a language for the interactivity of Internet pages and the ‚Äúgluing together‚Äù of their resources, but as a powerful and sufficient tool for creating full-fledged cross-platform and often very scalable applications. </p><br><p>  Originally developed for web designers, this ‚Äúmost misunderstood programming language‚Äù has been trampling for a long time, despite the rapidly growing popularity and importance.  For 13-14 years preceding the edition of ECMAScript 5.1, it is difficult to recall some important changes in the standard or to understand the vector of its development.  At that time, the community contributed a lot to the formation of the language ecosystem: Prototype, jQuery, MooTools, and so on.  Having received this feedback from the developers, JavaScript has done a lot of work on the bugs: the loud 6-year release of ES6 in 2015 and now the annual ECMAScript releases, thanks to the TC39 revised by the committee the process of <a href="https://frontender.info/tc39-process/">introducing new features</a> into the specification. </p><br><p>  Well, when our applications became quite large, the prototype OOP model for describing user types ceased to justify itself due to an unusual approach.  Well seriously, what is it? </p><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Call me via new and I will be the constructor ;) */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} Rabbit.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Animal.prototype); Rabbit.prototype.constructor = Rabbit;</code> </pre> <br><p>  No classes appeared in the language, but their syntax appeared.  And the code has become available for adherents of the traditional class-oriented paradigm: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">/* Obviously, the constructor is here! */</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rabbit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Now at the stage of the candidate for release are <a href="https://github.com/tc39/proposal-class-fields">private</a> class <a href="https://github.com/tc39/proposal-class-fields">fields</a> .  It is hard to believe that sooner or later we will cease to make one another laugh at the agreement on the naming of private properties through the underscore. </p><br><p>  At the same time, in a language where a function is an object of the first order and constant eventfulness takes place, it is quite common: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.n += <span class="hljs-number"><span class="hljs-number">1</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  And here begins the explanation about <em>this</em> contexts and closures in JavaScript, which scares every second external developer.  But in many cases, the language allows you to avoid unnecessary surprises, obviously using <em>Function.prototype.bind</em> or just like this: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n += <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  We also had pointer functions, and these are really functions, not functional interfaces (yes, Java?).  Together with an extended set of methods for working with an array, they also help to write the usual declarative pipeline calculations: </p><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, x)) .reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s, x</span></span></span><span class="hljs-function">) =&gt;</span></span> s + x, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Language rightfully considers itself a multi-paradigm.  But here is a simple example about the signature of a function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* send ping to host count times */</span></span> }</code> </pre> <br><p>  At first, passing by will ask a question that the function probably takes only the first argument, and then what the hell is that in this case, the <em>count</em> becomes a boolean !?  Indeed, the function has two uses: with and without <em>counting</em> .  But this is absolutely not obvious: you have to look into the implementation and understand.  Using <a href="http://usejsdoc.org/">JSDoc</a> can help you <a href="http://usejsdoc.org/">figure it out</a> , but this is not common practice.  And here JavaScript went to meet, adding support for not overloading, but at least default parameters: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Summarizing, JavaScript acquired a huge number of familiar things: generators, iterators, <em>Set</em> collections and <em>Map</em> dictionaries, typed arrays, and even regular expressions began to delight with the support of <em>lookbehind</em> !  Language does everything to be suitable for many things and to become friendly for everyone. </p><br><h2 id="blagopriyatnyy-put-k-ochevidnomu">  Auspicious way to the obvious </h2><br><p>  The language itself is certainly well done, and it is difficult to argue with that!  But what is wrong with us?  Why do we constantly remind the world that JavaScript is somehow not so?  Let's look at the examples of some widely used techniques and ask them their feasibility. </p><br><h3 id="privedenie-tipov">  Cast </h3><br><p>  Yes, JavaScript has a dynamic and weak type system and allows you to perform operations on anything, implicitly performing transformations for us.  But often, an explicit type conversion is necessary and we can observe the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = !!(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = +(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-string"><span class="hljs-string">''</span></span>+(expr);</code> </pre> <br><p>  These tricks are known to every JavaScript developer, and they are motivated by the fact that they say that you can ‚Äúquickly‚Äù turn something into something: speed here is a short entry.  Can it also write <em>false</em> as <em>! 1</em> ?  If the developer is so worried about the printed characters, then in his favorite IDE, you can easily set up the necessary <em>live template</em> or autocomplete.  And if - for the size of the published code, then we always run it through the obfuscator, who knows better than us how to deactivate all this.  Why not so: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bool = <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numb = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(expr); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> str = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(expr);</code> </pre> <br><p>  The result is the same, only understandable to everyone. </p><br><p>  For string conversions, we have <em>toString</em> , but for numeric ones there is an interesting <em>valueOf</em> , which can also be overridden.  A classic example that introduces the "uninitiated" into a stupor: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>;</code> </pre> <br><p>  But after all <em>Date has a</em> known <em>getTime</em> method, let's use it: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).getTime();</code> </pre> <br><p>  or finished function: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();</code> </pre> <br><p>  There is absolutely no reason to exploit implicit type conversions. </p><br><h3 id="logicheskie-operatory">  Logical operators </h3><br><p>  Logical operators AND (&amp;&amp;) and OR (||), which in JavaScript are not entirely logical, deserve special attention: they accept and return values ‚Äã‚Äãof any type.  We will not go into the <a href="https://learn.javascript.ru/logical-ops">details of the operation of the</a> logical expression evaluator, consider examples.  Previously presented option with the function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ count = count || <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  It may well look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ping</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">host, count</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// OR arguments.length? if (typeof count == 'undefined') { count = 5; } /* ... */ }</span></span></code> </pre> <br><p>  Such a check is also customary, and in some cases can help to avoid mistakes. </p><br><p>  This seems rather wild for a developer who initially chose the JavaScript path.  But for most of the others, this code is really wild: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; self.self === self &amp;&amp; self) || (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; global.global === global &amp;&amp; global);</code> </pre> <br><p>  Yes, it is compact, and yes, popular libraries can afford it.  But please, let's not abuse this, since our code will be read not by the contributors in JavaScript, but by the developers who solve business problems for the allotted time frame. </p><br><p>  There may be such a pattern: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> opts == <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; opts.count || <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  This is definitely shorter than the usual ternary operator, but when reading such a code, first of all you remember the priorities of the operations used. </p><br><p>  If we write a predicate function, which is <em>passed</em> to the same <em>Array.prototype.filter</em> , then wrapping the return value in <em>Boolean</em> is a good tone.  The purpose of this function becomes obvious immediately and there is no dissonance among developers whose languages ‚Äã‚Äãhave the ‚Äúcorrect‚Äù logical operators. </p><br><h3 id="pobitovye-operacii">  Bitwise operations </h3><br><p>  A common example of checking for an element in an array or a substring in a string is using bitwise NOT (NOT), which is offered even by some textbooks: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'yes'</span></span>); }</code> </pre> <br><p>  What problem does it solve?  we don‚Äôt have to check <em>! == -1</em> , because <em>indexOf</em> will get the index of the element or -1, and the tilde will add 1 and change the sign.  Thus, the expression will turn into a "lie" in the case of the index -1. </p><br><p>  But avoiding duplication of code can be done differently: to put the check into a separate function of some utils-object, as it is done by all, than to use bitwise operations for other purposes.  In lodash, there is an <a href="">includes</a> function for this, and it does not work through <del>  asshole </del>  tilde  You can rejoice, because in ECMAScript 2016 the method <em>Array.prototype.includes was fixed</em> (there are also lines). </p><br><p>  But it was not there!  Another tilde (along with XOR) is used to round the number, discarding the decimal part: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(~~<span class="hljs-number"><span class="hljs-number">3.14</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3 console.log(2.72^0); // 2</span></span></code> </pre> <br><p>  But there is a <em>parseInt</em> or <em>Math.floor</em> for this purpose.  Bitwise operations here are convenient for speed dialing in the console, as they also have a low priority over the rest of the arithmetic.  But on the code review it is better not to miss. </p><br><h3 id="sintaksis-i-konstrukcii-yazyka">  Syntax and language constructs </h3><br><p>  Some strange practices are difficult to attribute to any particular section.  For example, they say that parentheses are optional when calling a constructor and the following two expressions are identical: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rabbit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rabbit;</code> </pre> <br><p>  And indeed it is!  but why create a question from scratch?  Not every language can boast such a "feature".  And if you still want, then let it be an agreement on the entire project.  Otherwise, there is a false feeling that there is some difference. </p><br><p>  A similar situation with the declaration of a set of variables.  The syntax of the <em>var</em> and <em>let</em> directives allows you to declare (and define) several variables at once, listed separated by commas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>, host, retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Someone uses line breaks for readability, but in any case such syntax is not a frequent occurrence in popular languages.  No one will give a hand and ask if you write this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retry = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> host;</code> </pre> <br><p>  Again, if there is an agreement on a good style at the project / company level, then there are no questions.  You just don‚Äôt have to overly combine syntax options by mood. </p><br><p>  There are specific constructions in the language, such as, for example, IIFE - it allows you to call a function immediately at the place of its definition.  The trick is that the parser recognizes a functional expression, not a function declaration.  And this can be done in lots of different ways: classically wrapping parentheses, through <em>void</em> or any other unary operator.  And this is nothing wonderful!  It is necessary to choose the only option and not to depart from it unnecessarily: </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }());</code> </pre> <br><p>  No need to use operators to hack a parser.  When a newcomer comes to the project, I want to immerse him in the business logic of the application, and not to give explanations from where all these exclamation marks and voids were spied.  There is also a second classic bracket entry and an interesting <a href="https://www.youtube.com/watch%3Fv%3DeGArABpLy0k%26t%3D1m10s">comment from Crockford</a> about this. </p><br><p>  The appearance of class syntax in ES6 was not accompanied by the usual access modifiers.  And sometimes the developer wants to pee on classrooms, and observe privacy.  Which leads to this code of Frankenstein: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } } toString() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.getName()}</span></span></span><span class="hljs-string">`</span></span>; } }</code> </pre> <br><p>  That is, accessors are created for the instance in the constructor, and privacy is achieved by accessing the local property variables through the closure.  This example looks quite concise, but this is a completely unscalable approach, unless a documented framework solution is built around it.  Gentlemen, let's use either the existing classes (and wait for the standardization of private fields) or the popular pattern module.  To create some kind of intermediate mix solution here is such as the classes cease to be classes, and the code is intelligible. </p><br><p>  To summarize, common sense will be to share the style-guide adopted in the project, the config for the linter, or just code fragments with colleagues who contribute its non-JavaScript component to the project.  The language offers several options literally for each typical task, therefore, to improve one another‚Äôs understanding and to get under the common denominator is not difficult (or almost). </p><br><h2 id="zloklyuchenie">  Misadventure </h2><br><p>  This topic is of course holivar and examples can be cited much more, but the main message of the article is that non-obviousness in JavaScript should not be misused where this can be avoided.  The nature of the language is unique: it allows you to write both elegant and expressive (moderately ‚Äústubborn‚Äù) solutions, as well as understandable and accessible to all.  I fundamentally disagree with the common opinion that JavaScript "punished itself" or "was buried under a pile of good intentions and errors."  Because now most of the strangeness is demonstrated not by the language, but by the culture of developers and (not) indifferent that has developed around it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432102/">https://habr.com/ru/post/432102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432092/index.html">Unpleasant errors while writing unit tests</a></li>
<li><a href="../432094/index.html">Joint online hackathon from OpenGift and Credits Blockchain Platform</a></li>
<li><a href="../432096/index.html">The complete guide to CMake. Part Two: Build System</a></li>
<li><a href="../432098/index.html">Autopilots on road transport, how to interact with the specials. transport?</a></li>
<li><a href="../432100/index.html">How we improved the conversion of the payment form</a></li>
<li><a href="../432104/index.html">IT digest of December events (part one)</a></li>
<li><a href="../432106/index.html">Product Design Digest November 2018</a></li>
<li><a href="../432108/index.html">Registration is open for intensive on Kubernetes on February 1-3 in St. Petersburg</a></li>
<li><a href="../432110/index.html">Web technologies for designers - I return the debt</a></li>
<li><a href="../432112/index.html">Intel XMM 8160 - Universal Multi-Mode 5G Modem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>