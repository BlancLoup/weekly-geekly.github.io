<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kubernetes: an amazingly affordable solution for personal projects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! 

 In January, we finally have a long-awaited book on Kubernetes. Speech on the "Mastering Kubernetes 2nd Edition" Gigi Sayfana: 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kubernetes: an amazingly affordable solution for personal projects</h1><div class="post__text post__text-html js-mediator-article">  Hello colleagues! <br><br>  In January, we finally have a long-awaited book on Kubernetes.  Speech on the "Mastering Kubernetes 2nd Edition" Gigi Sayfana: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/6r/pc/mp6rpcu9hby7scugehhegmzmtrs.jpeg"></div><br>  We did not dare to publish a book on Kubernetes about a year ago, since at that time the technology definitely looked like a dreadnought for supercorporations.  However, the situation is changing, in confirmation of what we suggest reading a great article by Caleb Doxsey, who, by the way, wrote a <a href="https://losst.ru/wp-content/uploads/2016/08/Vvedenie-v-programmirovanie-na-Go-Keleb-Doksi.pdf">book</a> about the Go language.  Mr. Doxy's arguments are very interesting, and we hope that after reading them, you really want to try Kubernetes in practice. <br><a name="habracut"></a><br>  A few months earlier this year I spent on in-depth study of Kubernetes: I needed it for one project at work.  Kubernetes is a complex technology for infrastructure management, ‚Äúeverything is included, even batteries‚Äù.  Kubernetes solves a number of problems that you are destined to face when developing for large enterprises.  However, there is a widespread belief that Kubernetes is an overly complicated technology that is relevant only when driving a large cluster of machines.  Allegedly, the operational load when working with Kubernetes is so great that using it for small infrastructures, where the machines are not counted in dozens, this is shooting from a cannon on sparrows. <br>  Beg not agree with this.  Kubernetes is good for small projects, and today you can already afford your own Kubernetes cluster for less than <b>$ 5</b> a month. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Kubernetes Defense Word</b> <br><br>  Below, I will show you how to set up your own Kubernetes cluster, but first I will try to explain why Kubernetes should be used in small projects: <br><br>  <i>Kubernetes is thorough</i> <br><br>  Yes, at first glance Kubernetes seems to be a somewhat redundant solution.  It seems, is not it easier to take and acquire a virtual machine and not configure your own application as a service, why not?  Having chosen this path, you will have to decide on some decisions, in particular: <br><br><ol><li>  How to deploy the application?  Just rsync it to the server? </li><li>  What about addictions?  If you are working with Python or Ruby, then they will have to be installed on the server.  Are you going to just run the commands manually? </li><li>  How are you going to run the app?  Just run the binary in the background and then nohup it?  This is probably not too good, so if you organize the application as a service, you will have to learn systemd? </li><li>  How are you going to cope with the operation of many applications, when all of them have different domain names or http-paths?  (you probably need to configure haproxy or nginx for this) </li><li>  Let's say you have updated your application.  How in that case will roll out changes?  Stop the service, deploy the code, restart the service?  How to avoid downtime? </li><li>  What if you screw up the deployment?  Are there opportunities to roll back?  (Symlink directory ...? This simple script no longer seems particularly simple) </li><li>  Do you use other services in your application, for example, redis?  How to configure all these services? </li></ol><br>  Kubernetes solves all these problems.  Naturally, all of them can be solved in other ways, among which there are better options Kubernetes;  however, how much better is it not to think about all this at all and concentrate on developing the application. <br><br>  <i>Kubernetes is reliable</i> <br><br>  A single server is bound to collapse.  Yes, it happens rarely, maybe once a year, but after such an event a real headache begins: how to get everything back into working condition.  This is especially true if you have manually configured the entire configuration.  Remember all the commands that ran last time?  Do you even remember what worked on the server?  I recall one quote from the bashorga: <br><blockquote>  erno: Hmm.  I lost my computer ... seriously, I lost it.  He pings, works fine, I just won‚Äôt know where he went in the apartment. <br>  <a href="http://bash.org/%3F5273">bash.org/?5273</a> </blockquote>  Exactly the same thing happened to me recently, on my own blog.  I just needed to update the link, but I completely forgot how to deploy a blog.  Suddenly, a ten-minute fix turned into a piece of work the whole weekend long. <br><br>  Kubernetes uses a <b>descriptive</b> format, so you always know what things were supposed to run when and where;  In addition, all components of the system you have deployed are much clearer.  Moreover, in the control plane, the failure of nodes is handled carefully, and the hearths are automatically redistributed.  When working with a stateless service, for example, with a web application, you can probably forget about failures altogether. <br><br>  <i>Kubernetes is as easy to learn as alternatives are.</i> <br><br>  Kubernetes does not follow the Unix model.  It does not fit into the ecosystem of tools.  He is not one of those decisions that "do only one thing and do it well."  Kubernetes is a comprehensive solution for many problems, it can replace a variety of techniques and tools that developers have already got used to. <br><br>  Kubernetes has its own terminology, its own toolkit, its own paradigm of dealing with servers, which differs significantly from the traditional unix approach.  When you navigate these systems, many of the characteristic features of Kubernetes may seem random and overcomplicated, perhaps even cruel.  I suppose there are compelling reasons why such complexity arose, but here I don‚Äôt say that Kubernetes is simple and elementary to understand;  I say that Kubernetes knowledge is enough to create and support any infrastructure. <br><br>  It is impossible to say that any sysadmin has sufficient unix background.  For example, after graduating from college, I worked for 5 years in the Windows ecosystem.  I can say that my first job at a startup, where it took to deal with linux, required a difficult transformation.  I did not know the memory by command, I was not used to using the command line for almost all occasions.  It took me some time to learn how to work with the new platform (although, by that time I already had some programming experience), but I clearly remember how much I had suffered then. <br><br>  With Kubernetes, you can start all the work literally from scratch.  In Kubernetes, you can easily allocate services, even without an SSH connection to the server.  You do not have to learn systemd;  it is not necessary to understand the launch levels or to know which command was used: <code>groupadd</code> or <code>addgroup</code> ;  you do not have to learn how to deal with <code>ps</code> or, God forbid, vim.  All this materiel is useful and important, nothing from it disappears anywhere.  I have great respect for system administrators who are able to navigate their way through any unix environment.  But how cool would it be if developers could productively acquire all such resources without delving into such subtleties of administration? <br><br>  Is this really: <br><br><pre> <code class="plaintext hljs">[Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/usr/sbin/nginx -s reload ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target</code> </pre> <br>  Much harder this one? <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: my-nginx spec: selector: matchLabels: run: my-nginx replicas: 1 template: metadata: labels: run: my-nginx spec: containers: - name: my-nginx image: nginx ports: - containerPort: 80</code> </pre> <br>  And this is a relatively successful case.  If you manage the infrastructure 100% remotely, you will not be able to provide server support manually.  For this you need some tool: ansible, salt, chef, puppet, etc.  Naturally, to master Kubernetes and work effectively with it, you need to learn a lot, but this is no more difficult than dealing with alternatives. <br><br>  <b>Kubernetes open source</b> <br><br>  In an era of huge popularity of serverless technologies, Kubernetes is notable for its independence from specific suppliers.  There are at least 3 popular and easy-to-manage Kubernetes providers (Google, Amazon, Microsoft) that will not disappear in the foreseeable future.  There are also many companies that successfully cope with their own clusters of Kubernetes, and every day the number of such companies is multiplying.  Today, working with Kubernetes from the first day is an obvious solution for most startups. <br>  Kubernetes, being an open-source project, is well documented, stable and popular, and any problems can be as detailed as possible on stackoverflow.  Of course, Kubernetes has its own bugs and technical challenges, but I assure you: there are guys in the world who sharpen Kubernetes with inconceivable skill.  Their work is your dividend;  In the next few years, this technology will only be improved. <br><br>  <b>Kubernetes scaled</b> <br><br>  One of the challenges associated with supporting the infrastructure is the following: techniques that are useful when deploying small systems are rarely successfully reproduced in larger systems.  It is definitely convenient to SCP-noob a binary file to the server, kill the process and restart it if you have only one server.  But when you need to support multiple servers and simultaneously monitor them, this task can be overwhelmingly complex.  That's why when managing such an infrastructure you can't do without tools like chef or puppet. <br><br>  However, if you choose the wrong tool, over time this can get you into a corner.  Suddenly, it turns out that the lead chef server is not coping with the 1000-server load, the blue-green deployment does not fit into your model, and it takes hours to complete the capistrano tasks.  When the infrastructure reaches a certain size, you will be forced to tear down everything that has already been done and start over.  How great would it be if you managed to break out of this eternal squirrel wheel with infrastructure and switch to technology that will scale according to your needs? <br><br>  Kubernetes is a lot like a SQL database.  SQL is the product of many years of hard lessons about data storage and efficient query.  Probably, you will never need a tenth of the possibilities that are provided in a suitable SQL database.  You might even be able to design a more efficient system based on your own database.  But in the absolute majority of situations, the SQL database will not only satisfy all your needs, but will also drastically expand your ability to quickly issue ready-made solutions.  SQL schemas and indexing are much easier to use than your own file-based data structures, since your own data structures will almost certainly become obsolete as your product grows and evolves over time.  But the SQL database is likely to survive any inevitable refactoring. <br><br>  Kubernetes will survive too.  Perhaps your side project will never grow to such a scale where its problems can be solved only by means of Kubernetes, but in Kubernetes there are absolutely all the tools for dealing with any problems, and the skills that you will get when handling this toolkit can turn out to be invaluable in future projects. <br><br>  <b>Build your own cluster Kubernetes</b> <br><br>  So, I believe that it is advisable to use Kubernetes in small projects, but only if setting up the cluster is easy and inexpensive.  It turns out that both are achievable.  There are managed Kubernetes providers that independently resolve all confusion with the support of the control plane of the Kubernetes master node.  And the recent dumping wars in the cloud infrastructure environment have led to a striking cheapening of such services. <br>  We will analyze the next case using the example of Google's Kubernetes engine (GKE), however, you can also look at offers from Amazon (EKS) or Microsoft (AKS), if Google is not satisfied with you.  To build our own Kubernetes cluster, we need: <br><br><ul><li>  Domain name (~ $ 10 / year, depending on the domain) </li><li>  Cloudflare DNS hosting (free) </li><li>  GKE Kubernetes cluster consisting of three nodes (~ $ 5 / month) </li><li>  Web application uploaded as a docker container to Google Container Registry (GCR) (free) </li><li>  Some yaml files for Kubernetes configuration </li></ul><br>  For additional savings, we will try to do without the Google input controller.  Instead, we will use Nginx on each node as a daemon and create our own operator, which will provide us with synchronization of the external IP addresses of the working node with Cloudflare. <br><br>  <b>Google configuration</b> <br><br>  First, go to console.cloud.google.com and create a project, if you have not already done so.  You will also need to create a billing account.  Then through the hamburger menu we go to the Kubernetes page and create a new cluster.  Here's what to do next: <br><br><ul><li>  Select Zonal for the location type (Location). </li><li>  I indicated my location as us-central1-a </li><li>  Choose your version of kubernetes </li><li>  Create a pool of 3 nodes using the cheapest instance type (f1-micro). </li><li>  For this pool of nodes, on the ‚Äúadvanced‚Äù (advanced) screen, set the size of the boot disk to 10GB, turn on the nodes being pushed out (they are cheaper), turn on auto-update and autotreatment. </li><li>  Under the pool of nodes will find a number of additional options.  We want to disable HTTP load balancing (load balancing in GCP is expensive), as well as shutting down all the facilities associated with StackDriver (it can also be expensive and, in my experience, not very reliable).  Also turn off the kubernetes display panel. </li></ul><br>  Putting all these options, you can proceed to the next step: create a cluster.  Here's how to save it: <br><br><ul><li>  Kubernetes control plane: free because Google does not charge leading nodes </li><li>  Working Kubernetes nodes: $ 5.04 / month, as a rule, 3 micro-nodes will cost you $ 11.65 / month, and, having made them crowded out, we will reduce this rate to $ 7.67 / month, and at the ‚ÄúAlways Free‚Äù level - to $ 5.04. </li><li>  Storage costs: free.  We get a free 30GB of permanent disk space, so we chose the size 10GB above. </li><li>  Load balancing costs: free of charge, we have disabled HTTP load balancing, since only it would cost us $ 18 / month.  Instead, we will run our own HTTP proxies on each node and direct the DNS to public IP. </li><li>  Network costs: free, the egress function remains free until you choose 1GB per month.  (then each next gigabyte costs 8 cents) </li></ul><br>  So we set up a cluster of Kubernetes of 3 nodes, it cost us the same price as the only Digital Ocean machine. <br><br>  Above the GKE settings, you also need to configure a couple of firewall rules so that the HTTP ports of our sites can be reached from the outside world.  Find the VPC Network entry in the hamburger menu, then go to Firewall Rules and add rules for TCP ports 80 and 443, with the IP address range 0.0.0.0/0. <br><br><img src="https://habrastorage.org/webt/if/ag/gz/ifaggzw5xpzfosqf_lxon8bqsdo.jpeg"><br><br>  Firewall rules <br><br>  <b>Local setting</b> <br><br>  So, we raised and launched a cluster, and now let's configure it.  Install the <code>gcloud</code> tool by following the instructions at <a href="https://cloud.google.com/sdk/docs/">cloud.google.com/sdk/docs</a> .  By installing it, you can proceed to the configuration by doing this: <br><br><pre> <code class="plaintext hljs">gcloud auth login</code> </pre> <br>  Of course, you still have to install the docker, and then bind it to the GCR, so that you can send containers: <br><br><pre> <code class="plaintext hljs">gcloud auth configure-docker</code> </pre> <br>  You can also install and configure <code>kubectl</code> by following the instructions outlined here. <br><br>  Simplified: <br><br><pre> <code class="plaintext hljs">gcloud components install kubectl gcloud config set project PROJECT_ID gcloud config set compute/zone COMPUTE_ZONE gcloud container clusters get-credentials CLUSTER_NAME</code> </pre> <br>  By the way, just a fairy tale that all this toolkit works on Windows, OSX or Linux.  As a person who sometimes did such things under Windows, I confess that this is a pleasant surprise. <br><br>  <b>Build a web application</b> <br><br>  You can write a web application in any programming language.  The container allows you to abstract particulars.  We need to create an HTTP application that listens to the port.  I prefer the Go language for such purposes, but for a change, let's try crystal.  Create the <code>main.cr</code> file: <br><br><pre> <code class="plaintext hljs"># crystal-www-example/main.cr require "http/server" Signal::INT.trap do exit end server = HTTP::Server.new do |context| context.response.content_type = "text/plain" context.response.print "Hello world from crystal-www-example! The time is #{Time.now}" end server.bind_tcp("0.0.0.0", 8080) puts "Listening on http://0.0.0.0:8080" server.listen</code> </pre> <br>  We also need the Dockerfile: <br><br><pre> <code class="plaintext hljs"># crystal-www-example/Dockerfile FROM crystallang/crystal:0.26.1 as builder COPY main.cr main.cr RUN crystal build -o /bin/crystal-www-example main.cr --release ENTRYPOINT [ "/bin/crystal-www-example" ]</code> </pre> <br>  To build and test our application, run: <br><br><pre> <code class="plaintext hljs">docker build -t gcr.io/PROJECT_ID/crystal-www-example:latest . docker run -p 8080:8080 gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  And then go to the browser at localhost: 8080.  Having adjusted this mechanism, we can send our application to the GCR by running: <br><br><pre> <code class="plaintext hljs">docker push gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  <b>Configuring Kubernetes</b> <br><br>  My configuration of Kubernetes is <a href="https://github.com/calebdoxsey/kubernetes-config">here</a> . <br><br>  For this example, we will have to create several files in yaml format, where our various services will be presented, and then run kubectl apply to configure them in a cluster.  The Kubernetes configuration is descriptive, and all these yaml files tell Kubernetes what state we want to get.  In a broad sense, this is what we are going to do: <br><br><ul><li>  Create a Deployment and Service for our crystal-www-example web application. </li><li>  Create a Daemon Set (service set) and Config Map (configuration map) for nginx </li><li>  Run our own application to synchronize the IP nodes with Cloudflare for DNS </li></ul><br>  <b>Web Application Configuration</b> <br><br>  First, let's configure our web application: (be sure to replace the <code>PROJECT_ID</code> with the id of your project) <br><br><pre> <code class="plaintext hljs"># kubernetes-config/crystal-www-example.yaml apiVersion: apps/v1 kind: Deployment metadata: name: crystal-www-example labels: app: crystal-www-example spec: replicas: 1 selector: matchLabels: app: crystal-www-example template: metadata: labels: app: crystal-www-example spec: containers: - name: crystal-www-example image: gcr.io/PROJECT_ID/crystal-www-example:latest ports: - containerPort: 8080 --- kind: Service apiVersion: v1 metadata: name: crystal-www-example spec: selector: app: crystal-www-example ports: - protocol: TCP port: 8080 targetPort: 8080</code> </pre> <br>  This is how Deployment (deployed configuration) is created, according to which Kubernetes should create a single container with a single container (our docker container will work there) and a service that we will use to discover services in our cluster.  To apply this configuration, run (from the <code>kubernetes-config</code> directory): <br><br><pre> <code class="plaintext hljs">kubectl apply -f</code> </pre> <br>  You can test it like this: <br><br><pre> <code class="plaintext hljs">kubectl get pod #     : # crystal-www-example-698bbb44c5-l9hj9 1/1 Running 0 5m</code> </pre> <br><br>  We can also create a proxy API for access: <br><br><pre> <code class="plaintext hljs">kubectl proxy</code> </pre> <br>  And then go: <a href="http://localhost/">localhost</a> : 8001 / api / v1 / namespaces / default / services / crystal-www-example / proxy / <br><br>  <b>NGINX configuration</b> <br><br>  As a rule, when working with HTTP services, Kubernetes uses an input controller.  Unfortunately, the HTTP load balancer from Google is too expensive, so we will not use it, but use our own HTTP proxy and configure it manually (it sounds scary, but in reality everything is very simple). <br><br>  To do this, use the Daemon Set and Config Map.  Daemon Set is an application running on each node.  Config Map is, in principle, a small file that we can mount in a container;  This file will store the nginx configuration. <br>  The yaml file looks like this: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: hostNetwork: true dnsPolicy: ClusterFirstWithHostNet containers: - image: nginx:1.15.3-alpine name: nginx ports: - name: http containerPort: 80 hostPort: 80 volumeMounts: - name: "config" mountPath: "/etc/nginx" volumes: - name: config configMap: name: nginx-conf --- apiVersion: v1 kind: ConfigMap metadata: name: nginx-conf data: nginx.conf: | worker_processes 1; error_log /dev/stdout info; events { worker_connections 10; } http { access_log /dev/stdout; server { listen 80; location / { proxy_pass http://crystal-www-example.default.svc.cluster.local:8080; } } }</code> </pre> <br>  This is how we mount the nginx.conf file of the configuration card in the nginx container.  We also set values ‚Äã‚Äãfor two more fields: <code>hostNetwork: true</code> , so that you can bind the port host and reach nginx from the outside and <code>dnsPolicy: ClusterFirstWithHostNet</code> , so that you can access services within the cluster.  If this is not done, then we will have a completely standard configuration. <br><br>  Apply these expressions - and you can go to nginx using the public ip of your nodes. <br><br>  Here's how to verify this: <br><br><pre> <code class="plaintext hljs">kubectl get node -o yaml # look for: # - address: ... # type: ExternalIP</code> </pre><br>  So now our web application is accessible from the Internet.  It remains to come up with a beautiful name for the application. <br><br>  <b>DNS connection</b> <br><br>  It is required to set 3 A DNS records for nodes of our cluster: <br><br><img src="https://habrastorage.org/webt/1l/0t/xx/1l0txxf6dye-lyuxpbndghsw_ta.png"><br><br>  Entries in the UI Cloudflare <br><br>  Then we add a CNAME record to point to these A-records.  (eg <a href="http://www.example.com/">www.example.com</a> CNAME for kubernetes.example.com).  This can be done manually, but better - automatically, so that if someday we have to scale or replace the nodes in the DNS records, this information is also updated automatically. <br><br>  I think this example also illustrates well how Kubernetes can delegate part of your work, and not try to overcome it.  Kubernetes understands scripts perfectly and has a powerful API, and you can fill in the existing spaces with your own components, which are not so difficult to write.  For this, I made a small application on Go, available at this address: <a href="https://github.com/calebdoxsey/kubernetes-cloudflare-sync">kubernetes-cloudflare-sync</a> . <br><br>  To start, created the informant <br><br><pre> <code class="go hljs">factory := informers.NewSharedInformerFactory(client, time.Minute) lister := factory.Core().V1().Nodes().Lister() informer := factory.Core().V1().Nodes().Informer() informer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, UpdateFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldObj, newObj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, DeleteFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, }) informer.Run(stop)</code> </pre> <br>  It will call my resynchronization function whenever a node changes.  Then I synchronize the API using the <a href="https://github.com/cloudflare/cloudflare-go">Cloudflare API</a> library, like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ips []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> nodes { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addr := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Status.Addresses { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr.Type == core_v1.NodeExternalIP { ips = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ips, addr.Address) } } } sort.Strings(ips) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, ip := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ips { api.CreateDNSRecord(zoneID, cloudflare.DNSRecord{ Type: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, Name: options.DNSName, Content: ip, TTL: <span class="hljs-number"><span class="hljs-number">120</span></span>, Proxied: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }) }</code> </pre> <br>  Then, as is the case with our web application, we run this application in Kubernetes as a Deployment: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: kubernetes-cloudflare-sync labels: app: kubernetes-cloudflare-sync spec: replicas: 1 selector: matchLabels: app: kubernetes-cloudflare-sync template: metadata: labels: app: kubernetes-cloudflare-sync spec: serviceAccountName: kubernetes-cloudflare-sync containers: - name: kubernetes-cloudflare-sync image: gcr.io/PROJECT_ID/kubernetes-cloudflare-sync args: - --dns-name=kubernetes.example.com env: - name: CF_API_KEY valueFrom: secretKeyRef: name: cloudflare key: api-key - name: CF_API_EMAIL valueFrom: secretKeyRef: name: cloudflare key: email</code> </pre> <br>  We will need to create a secret Kubernetes, specifying the key <code>cloudflare api</code> and mailing address: <br><br><pre> <code class="plaintext hljs">kubectl create secret generic cloudflare --from-literal=email='EMAIL' --from-literal=api-key='API_KEY'</code> </pre> <br>  We will also need to create a service account (which opens our Deployment access to the Kubernetes API to retrieve nodes).  First run (especially for GKE): <br><br><pre> <code class="plaintext hljs">kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user YOUR_EMAIL_ADDRESS_HERE</code> </pre> <br><br>  And then apply: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ServiceAccount metadata: name: kubernetes-cloudflare-sync --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubernetes-cloudflare-sync rules: - apiGroups: [""] resources: ["nodes"] verbs: ["list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubernetes-cloudflare-sync-viewer roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubernetes-cloudflare-sync subjects: - kind: ServiceAccount name: kubernetes-cloudflare-sync namespace: default</code> </pre> <br>  Working with RBAC is a bit of a chore, but I hope everything is clear.  When the configuration is ready, and our application works with Cloudflare, this application can be updated with any changes to any of the nodes. <br><br>  <b>Conclusion</b> <br><br>  Kubernetes is destined to become the flagship technology for managing large systems. ,   Kubernetes     ,    Kubernetes    ,    Kubernetes   ,      Kubernetes   . <br><br>    ,  Kubernetes       :      ,  .       ‚Äì   ! </div><p>Source: <a href="https://habr.com/ru/post/433192/">https://habr.com/ru/post/433192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433180/index.html">Solving data type problems in Ruby or Make data reliable again</a></li>
<li><a href="../433182/index.html">Is it possible to train with reinforcements agent for trading in the stock market? R language implementation</a></li>
<li><a href="../433184/index.html">ASP.NET Core 2.2 has been released. What's new? (2 of 3)</a></li>
<li><a href="../433186/index.html">It is not enough to count polygons to optimize 3D models.</a></li>
<li><a href="../433188/index.html">The State Duma submitted a bill on the autonomous work of the RuNet</a></li>
<li><a href="../433194/index.html">Night light with scheduled shutdown</a></li>
<li><a href="../433196/index.html">New Year Gift Guide</a></li>
<li><a href="../433198/index.html">10 dollars on hosting: 20 years ago and today</a></li>
<li><a href="../433202/index.html">The choice of architecture solutions for the marketplace of freight services</a></li>
<li><a href="../433204/index.html">How to learn Java development? The experience of Nikita Chernetsov GeekUniversity student</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>