<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Secure crypto programming. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post, we would like to acquaint Habr's users with the basic rules of programming cryptographic algorithms. This set of rules, called the ‚ÄúCryp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Secure crypto programming. Part 1</h1><div class="post__text post__text-html js-mediator-article">  In this post, we would like to acquaint Habr's users with the basic rules of programming cryptographic algorithms.  This set of rules, called the ‚ÄúCryptography coding standard‚Äù, was created in 2013 at the initiative of one of the modern cryptography gurus <a href="https://131002.net/">Jean-Philippe Omasson</a> .  Despite the fact that the approaches described in it are well known to those who are professionally engaged in the development of protection systems, beginners and students, we think, it will be interesting to get acquainted with the proposed text, which is a translation of the rule set from <a href="https://cryptocoding.net/">cryptocoding.net</a> . <br><a name="habracut"></a><br><h1>  1. Compare the lines of secret data for a constant time. </h1><br><h3>  Problem </h3><br>  A byte string comparison can be used to implement attacks that use information about the execution time of a program (so-called timing attacks), for example, to fake MAC message authentication codes (see <a href="http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/">Google Keyczar</a> vulnerability in the <a href="http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/">crypto library</a> ). <br><br>  Built-in implementations of comparison functionality, such as the memcmp function, the Arrays.equals method (Java), or the == (Python) operator, are usually not executed in constant time.  Consider, for example, the implementation of [memcmp] from <a href="http://research.microsoft.com/en-us/um/redmond/projects/invisible/src/crt/memcmp.c.htm">Microsoft CRT</a> : <br><br><pre><code class="hljs cpp">EXTERN_C <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">cdecl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Ptr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Ptr2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Count)</span></span></span><span class="hljs-function"> </span></span>{ INT v = <span class="hljs-number"><span class="hljs-number">0</span></span>; BYTE *p1 = (BYTE *)Ptr1; BYTE *p2 = (BYTE *)Ptr2; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Count-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; v == <span class="hljs-number"><span class="hljs-number">0</span></span>) { v = *(p1++) - *(p2++); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; }</code> </pre> <br><h3>  Decision </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Use comparison functions performed in a fixed time, such as the one offered in the NaCL library: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crypto_verify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> differentbits = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F(i) differentbits |= x[i] ^ y[i]; F(0) F(1) F(2) F(3) F(4) F(5) F(6) F(7) F(8) F(9) F(10) F(11) F(12) F(13) F(14) F(15) return (1 &amp; ((differentbits - 1) &gt;&gt; 8)) - 1; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* returns 0 if equal, 0xFF..FF otherwise */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  A more general version of this approach is as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">util_cmp_const</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_a = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) a; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_b = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) b; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { result |= _a[i] ^ _b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-comment"><span class="hljs-comment">/* returns 0 if equal, nonzero otherwise */</span></span> }</code> </pre><br>  Consider examples of the implementation of the comparison functions and tests for 32-bit values ‚Äã‚Äãperformed in a fixed time: <br><br><pre> <code class="hljs kotlin">#include &lt;stdint.h&gt; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  1   , 0   */</span></span> int ct_isnonzero_u32(uint32_t x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x|-x)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_iszero_u32(uint32_t x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_isnonzero_u32(x); } int ct_neq_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((xy)|(yx))&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_eq_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_neq_u32(x, y); } int ct_lt_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x^((x^y)|((xy)^y)))&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_gt_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ct_lt_u32(y, x); } int ct_le_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_gt_u32(x, y); } int ct_ge_u32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_lt_u32(x, y); } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  1   , 0   */</span></span> int ct_isnonzero_s32(uint32_t x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x|-x)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_iszero_s32(uint32_t x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_isnonzero_s32(x); } int ct_neq_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((xy)|(yx))&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_eq_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_neq_s32(x, y); } int ct_lt_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x^((x^(xy))&amp;(y^(xy))))&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; } int ct_gt_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ct_lt_s32(y, x); } int ct_le_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_gt_s32(x, y); } int ct_ge_s32(uint32_t x, uint32_t y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ^ ct_lt_s32(x, y); } <span class="hljs-comment"><span class="hljs-comment">/* Generate a mask: 0xFFFFFFFF if bit != 0, 0 otherwise */</span></span> uint32_t ct_mask_u32(uint32_t bit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(uint32_t)ct_isnonzero_u32(bit); } <span class="hljs-comment"><span class="hljs-comment">/*  x  y      bit*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* : return bit ? x : y */</span></span> uint32_t ct_select_u32(uint32_t x, uint32_t y, uint32_t bit) { uint32_t m = ct_mask_u32(bit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x&amp;m) | (y&amp;~m); <span class="hljs-comment"><span class="hljs-comment">/* return ((x^y)&amp;m)^y; */</span></span> }</code> </pre><br>  These approaches offer no guarantees: C and C ++ use the <a href="http://en.cppreference.com/w/cpp/language/as_if">‚Äúas if‚Äù</a> rule, which allows the compiler to implement operations in an arbitrary manner if the observed behavior of the program (execution time is not considered to be observed in both languages) remains unchanged.  For example, consider the following ct_select_u32 variant: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ct_select_u32(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> bit) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m = ct_mask_u32(bit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x&amp;m) | (y&amp;~m); }</code> </pre><br>  If we now compile this code with the parameters clang-3.5 -O2 -m32 -march = i386, we get the result: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ct_select_u32</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[esp + 12]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">al</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jne</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LBB0_1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[esp + 8]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[eax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LBB0_1</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">lea</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[esp + 4]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[eax]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  Due to the uneven speed of execution of conditional jump instructions, this code can potentially reveal the selected secret value.  Since the compiler has almost unlimited freedom in generating code that can be executed in different times, it is necessary to check the final assembly for execution in a fixed time. <br><br><h1>  Avoid branching the program depending on secret data. </h1><br><h3>  Problem </h3><br>  If the conditional branch of the program (if, switch, while, for) depends on the secret data, then the executable code, as well as the time it is executed, depends on the secret data. <br><br>  A classic example of the use of this vulnerability is timing attacks on exponentiation algorithms based on squaring and multiplication (or doubling and addition for algorithms that use elliptic curves). <br><br>  A particular case of this problem is the cycles in which the limit value of the counter depends on the secret value. <br><br><h3>  Decision </h3><br>  Leaks in program execution time can be counteracted by inserting dummy operations into program branches in order to guarantee a fixed time for its execution.  However, it is much more reliable to completely avoid branching, for example, by implementing conditional statements in the form of a straight-line program.  For example, the choice of two inputs | a |  and | b |  depending on the control bit | bit |  can be implemented as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* -0 = 0, -1 = 0xff....ff */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> mask = - bit; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> ret = mask &amp; (a^b); ret = ret ^ a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  For Intel processors, a faster solution is possible, which is based on using <a href="http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc35.htm">CMOV</a> conditional branch <a href="http://www.jaist.ac.jp/iscenter-new/mpc/altix/altixdata/opt/intel/vtune/doc/users_guide/mergedProjects/analyzer_ec/mergedProjects/reference_olh/mergedProjects/instructions/instruct32_hh/vc35.htm">instructions</a> . <br><br><h1>  Avoid referring to a table with addressing depending on secret data. </h1><br><h3>  Problem </h3><br>  The time to access a table element may vary depending on the value of its index (for example, if the element is not in the cache).  This effect has been used in a number of cache attacks on AES. <br><br><h3>  Decision </h3><br>  Replace table references with a sequence of logical operations with constant execution time, for example, using the bit-slice technique. <br><br><h1>  Avoid cycles in which the limit value of the counter depends on the secret value. </h1><br><h3>  Problem </h3><br>  A loop with a counter value of a counter that depends on a secret value directly makes the program vulnerable to execution time attacks.  For example, the implementation of the Montgomery ladder (exponentiation algorithm) in OpenSSL 0.9.8o allowed for the leakage of logarithm (secret random number) information in the ECDSA algorithm, which could be used to obtain the server's TLS secret key.  The corresponding program code is presented below.  Here | scalar |  - secret random number, and | scalar-&gt; d |  - pointer to array of its bits: <br><br><pre> <code class="hljs vbscript">/* find top most bit <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> go one past it */ i = scalar -&gt; top - <span class="hljs-number"><span class="hljs-number">1</span></span>; j = BN_BITS2 - <span class="hljs-number"><span class="hljs-number">1</span></span>; mask = BN_TBIT ; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!( scalar -&gt; d[i] &amp; mask )) { mask &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; j --; } mask &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; j - -; /* <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> top most bit was at word break , go <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> word */ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! mask ) { i - -; j = BN_BITS2 - <span class="hljs-number"><span class="hljs-number">1</span></span>; mask = BN_TBIT ; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i - -) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; j - -) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( scalar -&gt;d[ i] &amp; mask ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! gf2m_Madd ( group , &amp; point -&gt;X , x1 , z1 , x2 , z2 , ctx )) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! gf2m_Mdouble ( group , x2 , z2 , ctx )) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! gf2m_Madd ( group , &amp; point -&gt;X , x2 , z2 , x1 , z1 , ctx )) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! gf2m_Mdouble ( group , x1 , z1 , ctx )) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> ; } mask &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } j = BN_BITS2 - <span class="hljs-number"><span class="hljs-number">1</span></span>; mask = BN_TBIT; }</code> </pre><br><h3>  Decision </h3><br>  Make sure that the number of iterations in all cycles is limited to a constant (or at least some non-secret variable). <br><br>  In particular, make sure, as far as possible, that the boundaries of cycles and situations in which the counter values ‚Äã‚Äãexceed these boundaries or do not reach them, do not depend on user-controlled input data (does anyone really need their own <a href="http://heartbleed.com/">Heartbleed</a> ?). <br><br>  To be continued‚Ä¶ </div><p>Source: <a href="https://habr.com/ru/post/268113/">https://habr.com/ru/post/268113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268103/index.html">A little about the development of technology and the Internet</a></li>
<li><a href="../268105/index.html">New Exchange Server 2016 has been released</a></li>
<li><a href="../268107/index.html">Fantasy on WebDAV</a></li>
<li><a href="../268109/index.html">jQuery plugin for organizing components on the page</a></li>
<li><a href="../268111/index.html">Selection of useful articles for iOS developers for the current week</a></li>
<li><a href="../268115/index.html">A simple graphic editor using OpenCV</a></li>
<li><a href="../268117/index.html">IntelliJ IDEA 15 Preview available</a></li>
<li><a href="../268119/index.html">Creating loadable Zabbix modules on the example of adding the Modbus protocol</a></li>
<li><a href="../268123/index.html">Fantasy on WebDAV. Regular Client</a></li>
<li><a href="../268125/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 15. "UBuyWeRush"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>