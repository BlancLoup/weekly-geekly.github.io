<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript Decorators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Given the introduction of the ES2015 + standard, and the fact that nowadays transfiguration is common, many programmers are faced with new JavaScript ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript Decorators</h1><div class="post__text post__text-html js-mediator-article">  Given the introduction of the ES2015 + standard, and the fact that nowadays transfiguration is common, many programmers are faced with new JavaScript features in real code and in training materials.  One of these possibilities is decorators.  In all these innovations it is not surprising and confused, so today we will talk about what decorators are and how to use them to make the code cleaner and clearer. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/330812/"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/9f1/366/1d19f1366b29e6883647ac9c0b8909be.jpg" alt="image"></a> <br><br>  Decorators have gained popularity due to their use in Angular 2+.  In Angular, this functionality is implemented by means of TypeScript.  Now the proposal for the introduction of decorators in JavaScript is in a state of <a href="https://tc39.github.io/proposal-decorators/">Stage 2 Draft</a> .  This means that work on them has been largely completed, but they are still subject to change.  Decorators should be part of the next language update. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">What is a decorator?</font> </h2><br>  In its simplest form, a decorator is a way of wrapping one code fragment into another.  Literally - ‚Äúdecorating‚Äù a snippet of code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You may have heard about this concept earlier, as ‚ÄúFunctional Composition‚Äù or ‚ÄúHigher Order Functions‚Äù. <br><br>  This is quite realizable by standard JavaScript tools.  It looks like a call to some function that wraps another: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> doSomething(<span class="hljs-type"><span class="hljs-type">name</span></span>) {  console.log(<span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + <span class="hljs-type"><span class="hljs-type">name</span></span>); }</code> </pre> <br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loggingDecorator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wrapped</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Starting'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = wrapped.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Finished'</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br><pre> <code class="hljs lisp">const wrapped = loggingDecorator(<span class="hljs-name"><span class="hljs-name">doSomething</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  This example shows how to create a new function that is assigned to the <code>wrapped</code> constant.  This function can be called in the same way as the function <code>doSomething</code> , and it will do the same.  The difference is that before and after calling the wrapped function will be logged.  This is what happens if you experiment with the <code>doSomething</code> and <code>wrapped</code> functions. <br><br><pre> <code class="hljs ruby">doSomething(<span class="hljs-string"><span class="hljs-string">'Graham'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Hello, Graham wrapped(<span class="hljs-string"><span class="hljs-string">'Graham'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Starting /<span class="hljs-regexp"><span class="hljs-regexp">/ Hello, Graham /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Finished</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">How to use decorators in javascript?</font> </h2><br>  JavaScript decorators use a special syntax, they have a prefix in the form of an <code>@</code> symbol, they are placed immediately before the code they want to decorate. <br><br>  You can apply as many decorators as you need to one fragment of code, they will be used in the order in which they appear in the code. <br><br>  For example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@log()</span></span> <span class="hljs-meta"><span class="hljs-meta">@immutable()</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@time(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'demo'</span></span></span><span class="hljs-meta">)</span></span> doSomething() { } }</code> </pre> <br>  Here is the class declaration and the use of three decorators.  Two of them belong to the class itself, and one to the class property.  Here are the roles of these decorators: <br><br><ul><li>  <code>@log</code> can <code>@log</code> all calls to the class. <br></li><li>  <code>@immutable</code> is capable of making the class immutable - perhaps it will call <code>Object.freeze</code> for new instances of the class. <br></li><li>  <code>@time</code> records the duration of the execution of the methods and outputs this information to the log with a unique tag. <br></li></ul><br>  Today, the use of decorators requires the use of a transpiler, since neither browsers nor Node.js yet support them. <br><br>  If you use Babel, you can refer to the <a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">transform-decorators-legacy</a> plugin for working with decorators. <br><br>  Please note that the name of this plugin uses the word "legacy", which can be interpreted as an indication of some outdated technology.  The point here is that it supports the way the decorators process Babel 5. This approach may differ from the form which, as a result, will be standardized. <br><br><h2>  <font color="#3AC1EF">Why do we need decorators?</font> </h2><br>  Functional composition in JavaScript is implemented without any problems by standard means.  However, the same approach is either very difficult or impossible to apply to other software constructs, for example, to classes and their properties.  The proposed innovations allow the use of decorators and with classes, and with their properties.  Probably, in future versions of JavaScript, we can expect further development of decorators. <br><br>  The use of decorators, among other things, means a clearer syntax, this leads to a clearer expression of the intentions of the programmer using this technique. <br><br><h2>  <font color="#3AC1EF">Different types of decorators</font> </h2><br>  Currently supported decorator types are decorators of classes and class members ‚Äî properties, methods, getters, and setters.  In fact, decorators are just functions that are called with some information about the elements to be decorated and return other functions. <br><br>  Decorators are executed once when the program is started, the code being decorated is replaced with the return value. <br><br><h3>  <font color="#3AC1EF">‚ñç Class Members Decorators</font> </h3><br>  Class member decorators are applied to properties, methods, getters, and setters. <br><br>  These decorator functions are called with three parameters: <br><br><ul><li>  <code>target ‚Äî</code> class in which the class member to be decorated is located. </li><li>  <code>name ‚Äî</code> name of the class member. <br></li><li>  <code>descriptor ‚Äî</code> the class member descriptor.  This is essentially an object that would be passed to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> method. <br></li></ul><br>  Here is a classic example that demonstrates the use of the <code>@readonly</code> decorator.  This decorator is implemented as follows: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readonly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, name, descriptor)</span></span></span><span class="hljs-function"> </span></span>{ descriptor.writable = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> descriptor; }</code> </pre> <br>  The decorator sets the <code>writable</code> flag of the <code>writable</code> descriptor to <code>false</code> . <br><br>  This decorator is then used with class members as follows: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Example</span></span> { a() {} @<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">b</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} }</code> </pre> <br><pre> <code class="hljs pgsql">const e = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Example(); ea = <span class="hljs-number"><span class="hljs-number">1</span></span>; eb = <span class="hljs-number"><span class="hljs-number">2</span></span>; // TypeError: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'b'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-string"><span class="hljs-string">'#&lt;Example&gt;'</span></span></code> </pre> <br>  As seen in the error message, the decorator worked as expected.  We can go further, for example, by changing the behavior of the function being decorated, in fact, replacing it with a new function.  Let's, using the decorator, log the function arguments and what it returns: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, name, descriptor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> original === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) {   descriptor.value = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{     console.log(`Arguments: ${args}`);     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = original.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, args);       console.log(`Result: ${result}`);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result;     } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {       console.log(`Error: ${e}`);       <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e;     }   } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> descriptor; }</code> </pre> <br>  This construct replaces the method with a new one, which logs the arguments, calls the original method, and then logs what it returns. <br><br>  Note that here we used <a href="https://www.sitepoint.com/preparing-ecmascript-6-destructuring-assignment/">the extension operator</a> to automatically create an array with all the arguments passed to the method.  This is a modern alternative to the property of the <code>arguments</code> function. <br><br>  Let's look at all this in action: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@log</span></span>   sum(a, b) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b;   } }</code> </pre> <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Example(); e.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Arguments: 1,2 // Result: 3</span></span></code> </pre> <br>  You may notice that the text of the function decorator has to use an unusual syntax for the execution of the decorated method.  About this, in fact, you can write a whole article, but, briefly, the <code>apply</code> method allows you to call a function, setting the value to <code>this</code> and the arguments that will be passed to it. <br><br>  Going further, you can arrange everything so that the decorator takes the arguments for their own purposes.  For example, rewrite the <code>log</code> decorator as follows: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decorator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t, n, descriptor</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value;   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> original === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) {     descriptor.value = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Arguments for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${args}</span></span></span><span class="hljs-string">`</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = original.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, args);         <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Result from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${result}</span></span></span><span class="hljs-string">`</span></span>);         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result;       } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {         <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Error from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e}</span></span></span><span class="hljs-string">`</span></span>);         <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e;       }     }   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> descriptor; }; }</code> </pre> <br>  The code is complicated, but if you look at it, it turns out that the following happens here: <br><br><ul><li>  There is a <code>log</code> function that takes a single argument, <code>name</code> . </li><li>  This function returns another function, which is the decorator. </li></ul><br>  The returned function is identical to the <code>log</code> decorator, which we described above, except that it uses the <code>name</code> parameter from the external function. <br><br>  You can use all this like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@log(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some tag'</span></span></span><span class="hljs-meta">)</span></span> sum(a, b) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } }</code> </pre> <br><pre> <code class="hljs pgsql">const e = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Example(); e.sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); // Arguments <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> tag: <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> // Result <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> tag: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  It is immediately evident that this approach allows us to distinguish log lines due to the assigned tag. <br><br>  Here you call a function of the form <code>log('some tag')</code> , and then what was returned from this call is used as a decorator for the <code>sum</code> method. <br><br><h3>  <font color="#3AC1EF"> Class Decorators</font> </h3><br>  Class decorators apply to the entire class definition.  The decorator function is called with a single parameter, which is the class's constructor function being decorated. <br><br>  Notice that the decorator is applied to the constructor function, and not to each instance of the class at the time of its creation.  Therefore, in order to decorate different instances of the same class in different ways, it will be necessary, before creating them, to take care of decorating the constructor yourself. <br><br>  In general, class decorators are less useful than class member decorators, since all that can be done here comes down to replacing the class constructor. <br><br>  Returning to the logging example, we will write a decorator, which will display the parameters of the constructor: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Class</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class(...args); }; }</code> </pre> <br>  Here, as an argument, the class is accepted and a new function is returned, which will act as a constructor.  In our case, it simply logs the arguments and returns a new instance of the class created with these arguments. <br><br>  For example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@log</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, age) { } }</code> </pre> <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Example(<span class="hljs-string"><span class="hljs-string">'Graham'</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [ 'Graham', 34 ] console.log(e); // Example {}</span></span></code> </pre> <br>  As you can see, when the <code>Example</code> class constructor is executed, the constructor arguments will be logged, which are used when creating an instance of this class.  This is exactly what we wanted. <br><br>  To pass the parameters to the class decorators, you can use the approach already described: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decorator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Class</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Arguments for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">: args`</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class(...args);   }; } }</code> </pre> <br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@log(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'Demo'</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, age) {} }</code> </pre> <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Example(<span class="hljs-string"><span class="hljs-string">'Graham'</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Arguments for Demo: args console.log(e); // Example {}</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Decorators in real projects</font> </h2><br>  Here are some examples of using decorators in popular libraries. <br><br><h3>  <font color="#3AC1EF">Core Core Decorators Library</font> </h3><br>  There is an excellent library of <a href="https://www.npmjs.com/package/core-decorators">Core Decorators</a> , which provides ready-to-use decorators for general use.  Among the functionality they support is the timing of method calls, notification of obsolete constructs, and checking whether an object is immutable. <br><br><h3>  <font color="#3AC1EF">Library React</font> </h3><br>  <a href="https://www.sitepoint.com/getting-started-react-jsx/">React has</a> found a good use of the concept of higher order components.  These are React components, written as functions and serving as wrappers for other components. <br><br>  They are ideal candidates for use as decorators, since it will take minimal effort to use them as such.  For example, the Redux library has a <code>connect</code> function, which is used to connect React components.  Without decorators, working with this function may look like this: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyReactComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{} export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> connect(mapStateToProps, mapDispatchToProps)(<span class="hljs-type"><span class="hljs-type">MyReactComponent</span></span>);</code> </pre> <br>  If you rewrite it using decorators, you get the following: <br><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@connect</span></span>(mapStateToProps, mapDispatchToProps) export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyReactComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  The functionality turned out to be the same, but it all looks much nicer. <br><br><h3>  <font color="#3AC1EF">Mo MobX Library</font> </h3><br>  Decorators are widely used in the <a href="https://www.sitepoint.com/manage-javascript-application-state-mobx/">MobX</a> library.  For example, to ensure the desired behavior of the system, you simply add <code>Observable</code> or <code>Computed</code> decorators to the fields, and use the <code>Observers</code> decorator with classes. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We talked about how to create and use decorators in JavaScript, in particular - examined the features of working with decorators of class members.  This approach allows you to write auxiliary code, represented by decorator functions, which can be used to change the behavior of methods of different classes.  The syntax of the decorators allows you to simplify the texts of programs, make them cleaner and clearer.  It is possible to work with decorators in JavaScript today, they have found application in popular libraries.  However, we believe that after browsers and Node.js directly support them, they will have many new fans. <br><br>  Dear readers!  Do you already use decorators in your JS projects? </div><p>Source: <a href="https://habr.com/ru/post/330812/">https://habr.com/ru/post/330812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330794/index.html">LXC aka Linux Container: simplicity and reliability</a></li>
<li><a href="../330796/index.html">Why you should completely switch to Ceylon or Kotlin (part 2)</a></li>
<li><a href="../330800/index.html">Internship in geymdev: to be or not to be? The first experience of the Krasnodar studio Plarium</a></li>
<li><a href="../330802/index.html">If you are reading this, then your work is probably not hard.</a></li>
<li><a href="../330810/index.html">What determines the interesting gameplay?</a></li>
<li><a href="../330814/index.html">Dropout - a method for solving the problem of retraining in neural networks</a></li>
<li><a href="../330816/index.html">Tips for a novice rocker (part 2)</a></li>
<li><a href="../330818/index.html">Quake III source code</a></li>
<li><a href="../330820/index.html">Support for Deep Learning Researchers</a></li>
<li><a href="../330822/index.html">RESTForms - REST API for your InterSystems Cach√© classes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>