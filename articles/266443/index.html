<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do closures (under the hood) in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 We in Hexlet use JavaScript not only for obvious tasks in the frontend, but also, for example, to implement a browser-based development e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How do closures (under the hood) in JavaScript</h1><div class="post__text post__text-html js-mediator-article">  <i>Hi, Habr!</i> <i><br><br></i>  <i>We in Hexlet use JavaScript not only for obvious tasks in the frontend, but also, for example, to implement a browser-based development environment (our open-source <a href="https://github.com/Hexlet/hexlet-ide">hexlet-ide</a> ) on React.</i>  <i>We have a <a href="https://ru.hexlet.io/courses/javascript_101/%3Futm_medium%3Dblog%26utm_source%3Dhabr%26utm_campaign%3Djs">hands-on course on JavaScript</a> , and one of the lessons there is devoted to closures.</i>  <i>This is an important topic not so much in the framework of JS, as in programming in general.</i>  <i>We cover it in <a href="https://ru.hexlet.io/courses/%3Futm_medium%3Dblog%26utm_source%3Dhabr%26utm_campaign%3Djs">other courses</a> .</i> <i><br><br></i>  <i>In general, there are many articles and tutorials about the use of closures in JS, but there are few explanations of how everything works inside.</i>  <i>Today's translation is dedicated to this particular topic.</i>  <i>How and why closures work in JS, when they are created and destroyed, and why each function in JS is closure.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I have been using closures for quite some time.  I learned how to use them, but did not fully understand how they actually work, what is happening ‚Äúunder the hood‚Äù.  What is it all about?  <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BC%25D1%258B%25D0%25BA%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">Wikipedia</a> doesn't really help.  When is a closure created and destroyed?  What does the implementation look like? <br><br><pre><code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myClosure = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outerFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hidden = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">inc</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hidden++; } }; }()); myClosure.inc(); <span class="hljs-comment"><span class="hljs-comment">//  1 myClosure.inc(); //  2 myClosure.inc(); //  3 // , .    ? //     ?</span></span></code> </pre> <a name="habracut"></a><br>  When I finally found out, I wanted to share with everyone.  At least, so I will not forget.  After all <br><br><blockquote>  Tell me - and I will forget, show me - and I will remember, let me do it - and I will understand. </blockquote><br>  - Confucius and Benjamin Franklin <br><br>  In the process of learning, I tried to visualize the interaction of entities: how objects refer to each other, how one is inherited from another, and so on.  I could not find the illustrations, so I drew my own. <br><br>  I assume that the reader is familiar with JavaScript, knows about the global object, knows that the functions in JS are functions of a higher order, etc. <br><br><h4>  Chain of sight </h4><br>  When the JS code works, it needs space to store local variables.  Let's call this space an object of scope (aka LexicalEnvironment ‚Äî the lexical environment) or simply a scope-object.  For example, when you call a function, and it sets a local variable, this variable is stored in the scope object.  It can be considered a regular JavaScript object, with one important difference: it cannot be directly accessed.  You can change its properties, but you cannot access the object itself. <br><br>  The concept of such an object for scope is very different from, say, C or C ++, where local variables are stored on the stack.  In JavaScript, such objects are stored in heap, and they can remain in memory even after the function returns a value.  We will talk about this later. <br><br>  As you might expect, the scope object may have a parent.  When code tries to access a variable, the interpreter searches for a property on the current scope object.  If the property does not exist, the interpreter moves up the chain of scope objects and continues searching.  And so on, until the property is found or until the parents run out.  Let's call this scope scope order a ‚Äúscope chain‚Äù or a ‚Äúscope chain‚Äù. <br><br>  This mechanism is very similar to prototype inheritance, but, again, there is one important difference: if you try to access the non-existing property of a regular object, and there is no such property anywhere in the prototype chain, it will simply be returned undefined.  But if you refer to a non-existent property in the scop chain (that is, refer to a variable that does not exist), there will be a ReferenceError error. <br><br>  The last element in the scope chain is always a global object (Global Object).  In the highest level JavaScript code, a chain of scope objects consists of just one element: a global object.  So when you create variables in the top level of the code, they are set in the global object.  When a function call occurs, there is more than one object in the scope chain.  You might think that if the function is called from the top level, then there are exactly two objects in the scope chain, but this is not always the case.  There may be 2 or more objects, it depends on the function.  About this, too, later. <br><br><h4>  Upper level </h4><br>  Enough theory, here is an example: <br><br>  <b>my_script.js</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  We simply created two variables at the top level.  As I explained above, in this case, the scope object is a global object: <br><br><img src="https://habrastorage.org/files/bf7/c86/e80/bf7c86e807db4b03afd8c12e0825d55c.png"><br><br>  Here we have a launch area (this is my top level code from my_script.js), and the corresponding scope object.  Of course, in reality, the global object also contains a bunch of standard and host-specific pieces, but we will not show them here. <br><br><h4>  Non-nested functions </h4><br>  Take a look at this script: <br><br>  <b>my_script.js</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//--  ,    var a = 1; var b = 2; var foo = 3; console.log("inside myFunc"); } console.log("outside"); //--    myFunc();</span></span></code> </pre><br>  When the function myFunc is defined, the identifier myFunc is added to the current scope-object (in this case, to the global object), and this identifier refers to the function.  As you know, a function is an object, so further when we say ‚Äúfunction-object‚Äù, we mean an object, which is a function. <br><br>  The function object contains the function code and other properties.  One of the properties we are interested in is the internal property [[scope]];  it refers to the current scope object, that is, the scope object that is active at the time the function is defined (again, in this case, it is a global object). <br><br>  When we call console.log (‚Äúoutside‚Äù), we get the following scheme: <br><br><img src="https://habrastorage.org/files/e89/bf2/564/e89bf2564dc14bc8acb8c6a5b1497c5a.png"><br><br>  The object function referenced by the variable myFunc stores the function code and refers to the scope object that was relevant at the time of the function definition.  It is very important. <br><br>  When a function is called, a new scope-object is created that stores local variables for myFunc (and the values ‚Äã‚Äãof its arguments), and this new scope-object inherits from the scope-object that the function being called refers to. <br><br>  So, when calling myFunc, the scheme looks like this: <br><br><img src="https://habrastorage.org/files/fea/0a8/aab/fea0a8aab4064dbea27c1ce45fad4c82.png"><br><br>  This is a chain of scope objects.  If you refer to any variable inside myFunc, JavaScript will try to find it in the first object of the chain ‚Äî the scope of the myFunc () function.  If there is no such variable, then you need to go higher (in this case, there is a global object).  If it fails to find anything in the whole chain, there will be a Reference Error error. <br><br>  For example, if we call a inside myFunc, then we get 1 from the first object, the scope object myFunc ().  If we turn to foo, we get 3 from the same object: we can say it hides the foo property of the global object.  If we turn to bar, we get 2 of the global object.  This works almost like prototype inheritance. <br><br>  It is important to remember that these scope objects continue to exist as long as they are referenced.  When the last link to such an object disappears, the object will be processed by the garbage collector. <br><br>  After myFunc () returns a value, there are no more references to the scope of myFunc (), the garbage collector does its job and it turns out: <br><br><img src="https://habrastorage.org/files/dda/19c/626/dda19c62679b498d87fa76c110f41a67.png"><br><br>  Further I will not include the function objects in the diagrams in order not to overload the illustrations.  As you already know, the chain looks like this: function ‚Üí function-object ‚Üí scope-object. <br><br>  Do not forget about it. <br><br><h4>  Nested functions </h4><br>  From the moment the function returns a value, no one else refers to its scope object, so the garbage collector collects it.  But what if you define a nested function and return it (or save somewhere outside the current scope-object) you already know the answer: the function-object always refers to the scope-object in which it was created.  So when we set a nested function, it gets a link to the current scope of the external function.  And if we save the nested function elsewhere, the scope object will not be processed by the garbage collector even when the external function returns a value: there is still a link to this scope object!  Take a look at this code: <br><br>  <b>my_script.js</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initial</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//-- ,    var counter = initial; //--  .    //    scope- (  ) /** *      . *       1 ‚Äî  1. */ function increment(value) { if (!isFinite(value) || value &lt; 1){ value = 1; } counter += value; } /** *    . */ function get() { return counter; } //--  ,   //    return { increment: increment, get: get }; } //--    var myCounter = createCounter(100); console.log(myCounter.get()); //--  "100" myCounter.increment(5); console.log(myCounter.get()); //--  "105"</span></span></code> </pre><br>  When calling createCounter (100);  It turns out such a scheme: <br><br><img src="https://habrastorage.org/files/80b/5eb/50b/80b5eb50bc5f40f5a2b9f3c9edb8c5c7.png"><br><br>  Note that the createCounter (100) scope has references from the nested functions increment and get.  If createCounter () does not return anything, then of course these internal references to themselves will not be considered, and the scope object will be collected by the garbage collector.  But since createCounter () returns an object that contains references to these functions, it turns out like this: <br><br><img src="https://habrastorage.org/files/a06/22f/8a9/a0622f8a92a047ecb1852ff0b7e95eba.png"><br><br>  So, the createCounter (100) function has already returned a value, but its scope still exists, it is accessible from internal functions and only from them.  There is no way to access the createCounter (100) scope directly, you can only call myCounter.increment () or myCounter.get ().  These functions have unique, private access to the createCounter area. <br><br>  Let's try calling myCounter.get ().  Remember - when calling a function, a new scope is created, and a new object is added to the scope chain that is used for this new function.  It turns out like this: <br><br><img src="https://habrastorage.org/files/23f/a54/9b0/23fa549b083b4b2b937e39d48cd4fe2c.png"><br><br>  The first scope-object in the get () function chain is the empty scope-object of the function itself.  When inside a get () a call is accessed, JavaScript cannot find anything in the first chain object, moves to the next object and uses the createCounter (100) in-scope counter.  And the get () function simply returns it. <br><br>  You may notice that the myCounter object is also available to the myCounter.get () function as 'this' (the red arrow in the diagram).  This is not part of a chain of scope objects, but you need to remember about it.  About this, too, later. <br><br>  Calling increment (5) is a bit more interesting, because the argument is here: <br><br><img src="https://habrastorage.org/files/cb6/ddc/651/cb6ddc651e7f4a82b3839499633a4280.png"><br><br>  The value of the argument is stored in the scope-object created for this call.  When a function accesses the value of a variable, JavaScript immediately finds it in the first object in the chain.  However, when the function accesses the counter, JavaScript cannot find it in the first object of the chain of scope-objects, moves higher and finds it there.  So increment () changes the value in the createCounter (100) scope.  And practically nothing else can change this value.  Therefore, closures are so important: the myCounter object cannot be opened.  Closures are well suited for storing sensitive information. <br><br>  It is important to understand that scopes are ‚Äúliving‚Äù.  When a function is called, the current chain is not copied to the function, but in fact is supplemented with a new object.  And when any object of the chain changes, this change immediately becomes available to all functions in which this object consists of chains.  After increment () changes the value of the counter, the next get () call will return the updated value. <br><br>  Therefore, this famous example does not work: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elems = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(<span class="hljs-string"><span class="hljs-string">"myClass"</span></span>), i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elems.length; i++) { elems[i].addEventListener(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.innerHTML = i; }); }</code> </pre><br>  Several functions are created in a loop, and all of them contain a reference to the same scope object.  Therefore, they use the same variable i, not a personal copy.  You can read more about this example at the link <a href="http://jslinterrors.com/dont-make-functions-within-a-loop">Don't make functions within a loop</a> . <br><br><h4>  Similar object functions, different scope objects </h4><br>  And now let's expand our example a little and <i>have a good time</i> ( <i>yes, I have fun - approx. Lane</i> ).  What if you create multiple counter objects? <br><br>  <b>my_script.js</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initial</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... .     ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">//--   var myCounter1 = createCounter(100); var myCounter2 = createCounter(200);</span></span></code> </pre><br>  After creating myCounter1 and myCounter2, we get the following scheme: <br><br><img src="https://habrastorage.org/files/f2a/f38/d0e/f2af38d0ebbe4b7a968dad195d87ba0d.png"><br><br>  Don't forget: each object function contains a reference to a scope object.  In this example, myCounter1.increment and myCounter2.increment refer to function objects that contain the same code and the same property values ‚Äã‚Äã(name, length, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">others</a> ), but their [scope] refers to <b>different scope- objects</b> . <br><br>  There are no separate function objects in the diagram (to simplify visualization), but they still exist. <br><br>  Examples: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b; a = myCounter1.get(); <span class="hljs-comment"><span class="hljs-comment">// a == 100 b = myCounter2.get(); // b == 200 myCounter1.increment(1); myCounter1.increment(2); myCounter2.increment(5); a = myCounter1.get(); // a == 103 b = myCounter2.get(); // b == 205</span></span></code> </pre><br>  This is how it works.  The concept of closures is power. <br><br><h4>  Chain of scope objects and this </h4><br>  Like it or not, this is not part of a chain of scope objects.  The value of this depends on the function call pattern.  That is, you can call the same function, but have different values ‚Äã‚Äãfor this inside. <br><br><h5>  Call patterns </h5><br>  On this topic is to write a separate article, so now I just go over the topic superficially.  There are four patterns.  Here is: <br><br>  <b>Method invocation pattern</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myObj = { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">myFunc</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myProp; } }; myObj.myFunc(); <span class="hljs-comment"><span class="hljs-comment">//--  100</span></span></code> </pre><br>  If the call contains a dot or [subscript], then the function is called as a method.  In the example above, this refers to myObj. <br><br>  <b>Function invocation pattern (function call)</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } myFunc(); <span class="hljs-comment"><span class="hljs-comment">//--  undefined</span></span></code> </pre><br>  In this case, the value of this depends on whether the code is running in strict mode. <br><br><ul><li>  In strict mode, this is undefined </li><li>  In non-strict mode, this refers to the global object (Global Object). </li></ul><br><br>  In the example above - strict mode, so myFunc () will return undefined. <br><br>  <b>Constructor invocation pattern (constructor call)</b> <br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyObj</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = <span class="hljs-string"><span class="hljs-string">'b'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyObj();</code> </pre><br>  When the function is called with the prefix new, JavaScript sets a new object that inherits from the prototype property of the specified function.  And this newly created object is passed to the function as this. <br><br>  <b>Apply invocation pattern</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myArg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myProp + <span class="hljs-string"><span class="hljs-string">" "</span></span> + myArg; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = myFunc.apply( { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"prop"</span></span> }, [ <span class="hljs-string"><span class="hljs-string">"arg"</span></span> ] ); <span class="hljs-comment"><span class="hljs-comment">//--  ‚Äî "prop arg"</span></span></code> </pre><br>  You can pass any value like this.  In this example, Function.prototype.apply () is used for this.  Other options: <br><br><ul><li>  Function.prototype.call () </li><li>  Function.prototype.bind () </li></ul><br><br>  The following examples mainly use the Method invocation pattern. <br><br><h4>  Using this in nested functions </h4><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myObj = { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"outer-value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">createInnerObj</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInnerObj</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hidden = <span class="hljs-string"><span class="hljs-string">"value-in-closure"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"inner-value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">innerFunc</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hidden: '"</span></span> + hidden + <span class="hljs-string"><span class="hljs-string">"', myProp: '"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myProp + <span class="hljs-string"><span class="hljs-string">"'"</span></span>; } }; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInnerObj = myObj.createInnerObj(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( myInnerObj.innerFunc() );</code> </pre><br>  Output: hidden: 'value-in-closure', myProp: 'inner-value' <br><br>  By the time myObj.createInnerObj () is called, the following structure is obtained: <br><br><img src="https://habrastorage.org/files/739/351/f2d/739351f2d4974cc08223649a05eced53.png"><br><br>  And at the time of the call, myInnerObj.innerFunc () is: <br><br><img src="https://habrastorage.org/files/286/02e/106/28602e106e74444f88bd5b139766e416.png"><br><br>  You can see that this in myObj.createInnerObj () refers to myObj, but this in myInnerObj.innerFunc () refers to myInnerObj: both functions are called as methods.  Therefore, this.myProp inside innerFunc () returns an internal value, not an external one. <br><br>  You can trick innerFunc () to use myProp like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInnerObj = myObj.createInnerObj(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeObject = { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"fake-inner-value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">innerFunc</span></span>: myInnerObj.innerFunc }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( fakeObject.innerFunc() );</code> </pre><br>  Output: hidden: 'value-in-closure', myProp: 'fake-inner-value' <br><br><img src="https://habrastorage.org/files/cd5/4a6/234/cd54a623493f4cd4865d41d339f8dcdf.png"><br><br>  Or with apply () or call (): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInnerObj = myObj.createInnerObj(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( myInnerObj.innerFunc.call( { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"fake-inner-value-2"</span></span>, } ) );</code> </pre><br>  Output: hidden: 'value-in-closure', myProp: 'fake-inner-value-2' <br><br>  However, sometimes the inner function actually needs access to this, which is available in the outer function, regardless of how the inner function is called.  To do this, you need to specifically save the desired value in the closure (that is, in the current scope-object) like this: var self = this;  and use self in the inner function instead of this. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myObj = { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"outer-value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">createInnerObj</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createInnerObj</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hidden = <span class="hljs-string"><span class="hljs-string">"value-in-closure"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">myProp</span></span>: <span class="hljs-string"><span class="hljs-string">"inner-value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">innerFunc</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hidden: '"</span></span> + hidden + <span class="hljs-string"><span class="hljs-string">"', myProp: '"</span></span> + self.myProp + <span class="hljs-string"><span class="hljs-string">"'"</span></span>; } }; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInnerObj = myObj.createInnerObj(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( myInnerObj.innerFunc() );</code> </pre><br>  Output: hidden: 'value-in-closure', myProp: 'outer-value' <br><br>  It turns out like this: <br><br><img src="https://habrastorage.org/files/c72/2b2/dac/c722b2dacf4347579eec1c7f573a5d29.png"><br><br>  Now it is clear that innerFunc () has access to the value of this external function, through self, which lies in the closure. <br><br><h4>  Conclusion </h4><br>  Now we can answer those questions from the first paragraph. <br><br>  <b>What is a closure?</b>  This is an object associated with both the object function and the scope object.  In fact, all functions in JavaScript are closures: it is impossible to have a reference to a function object without a scope object. <br><br>  <b>When is a closure created?</b>  Since all functions in JavaScript are closures, the answer is obvious: when a function is specified, a closure is specified.  So the closure is created when the function is defined.  But you need to understand the difference between creating a closure and creating a new scope object: closure (a function + link to the current scope-chain functions. <br><br>  <b>When is a closure destroyed?</b>  Like any other object in JavaScript, the garbage collector handles a closure when there are no more references to it. </div><p>Source: <a href="https://habr.com/ru/post/266443/">https://habr.com/ru/post/266443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266431/index.html">Extortionist Android / Lockerpin.A attacks US users</a></li>
<li><a href="../266433/index.html">Developing a metamodel using the Eclipse Modeling Framework (and a little about data modeling)</a></li>
<li><a href="../266435/index.html">How to learn to make games: useful resources</a></li>
<li><a href="../266437/index.html">Says Gartner: Overheated IoT and Practical Clouds</a></li>
<li><a href="../266441/index.html">Assistant program for mastering blind typing on a keyboard in Linux</a></li>
<li><a href="../266447/index.html">LinkedIn's brief history of scaling</a></li>
<li><a href="../266449/index.html">A little about the implementation of the puzzle "Soma Cubes" (Swift & SceneKit)</a></li>
<li><a href="../266453/index.html">As I wrote the rainy map</a></li>
<li><a href="../266455/index.html">Backstage at CyberSoft</a></li>
<li><a href="../266457/index.html">Making a Real Forex Robot Idea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>