<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Releasing Predator - Precompiled Data Repositories</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, the Micronaut team at Object Computing Inc (OCI) introduced Predator , a new open source project whose goal is to significantly improve the run...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Releasing Predator - Precompiled Data Repositories</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/zy/lo/n1/zylon1nrzso3rt7yshzjaia3krg.jpeg"></p><br><p>  Today, the <a href="https://micronaut.io/">Micronaut</a> team at Object Computing Inc (OCI) introduced <a href="https://github.com/micronaut-projects/micronaut-predator">Predator</a> , a new open source project whose goal is to significantly improve the runtime and performance (from memory) of data access for microservices and serverless applications, without losing productivity compared to tools like GORM and Spring Data. </p><a name="habracut"></a><br><h2 id="istoriya-instrumentov-dostupa-k-dannym">  Data Access Tools History </h2><br><p>  We can track the history of the data repository template since 2004, when Ruby on Rails came out with the ActiveRecord subsystem, an API that revolutionized our understanding of data access in terms of developer productivity. </p><br><p>  In 2007, the Grails team first introduced an ActiveRecord-like API for the JVM - GORM (part of Grails).  GORM relied on the dynamic nature of Groovy to implement search methods on top of Hibernate and provided the same productivity benefits to JVM users. </p><br><p> Because GORM depends on the Groovy language, a Spring Data project was created in 2011 that allowed Java developers to define search methods, such as <code>findByTitle</code> , in the interface, and automatically implement query logic at run time. </p><br><h2 id="kak-rabotayut-instrumenty-dostupa-k-dannym">  How data access tools work </h2><br><p>  All the mentioned implementations use the same template, which consists in building a metamodel of project entities at runtime that models the relationships between your entity classes.  In Spring Data it is a MappingContext, and in GORM it is also called a MappingContext.  They are constructed by scanning classes using reflection.  (The similarity in naming is not accidental here. In 2010, I worked with the Spring Data team to try to recreate GORM for Java, on a project that eventually turned into what is called Spring Data today) </p><br><p>  This metamodel is then used to transform a search expression, such as <code>bookRepository.findByTitle("The Stand")</code> , into an abstract query model at runtime using a combination of regular expression parsing and framework logic.  We need an abstract query model, because the target query dialect is different for each database (SQL, JPA-QL, Cypher, Bson, etc.) </p><br><h2 id="podderzhka-repozitoriev-v-micronaut">  Micronaut Repository Support </h2><br><p>  Since launching <a href="https://habr.com/ru/post/418117/">Micronaut a</a> little over a year ago, the main missing feature we were asked about was "GORM for Java" or Spring Data support.  So many developers are in love with the productivity that these tools provide, as well as the ease of defining the interfaces that the framework implements.  I would say that most of the success of Grails and Spring Boot can be attributed to GORM and Spring Data respectively. </p><br><p>  For Micronaut users using Groovy, we had GORM support from day one, and Java and Kotlin users were left with nothing, because they needed to implement repositories on their own. </p><br><p>  It would be technically possible, and frankly easier, to simply add a module for Micronaut that would configure Spring Data.  However, following this path, we would provide a subsystem implemented using all the methods that Micronaut tried to avoid: widespread use of proxies, reflection and high memory consumption. </p><br><h2 id="predstavlyaem-predator">  Introducing Predator! </h2><br><p>  Predator, short for Precomputed Data Repositories, uses the Micronaut API to compile before execution (AoT, ahead-of-time) to transfer a meta-model of entities and transform search expressions (such as <code>findByTitle</code> ) into the appropriate SQL or JPA-QL in your compiler .  As a result, the query executes a very thin program runtime layer without reflection, and it only remains for it to run the query and return the results. </p><br><p>  The result is overwhelming ... the cold start is significantly reduced, we get an amazingly low memory consumption and a sharp improvement in performance. </p><br><p>  Today we open the source code for Predator under the Apache 2 license, it will come with two initial implementations (more features planned for the future) for JPA (based on Hibernate) and for SQL with JDBC. </p><br><p>  The JDBC implementation pleases me the most, as it is completely independent of reflection, does not use proxies and dynamic class loading for your level of data access, which leads to improved performance.  The runtime layer is so light that even the equivalent repository code written by hand will not execute faster. </p><br><h2 id="proizvoditelnost-predator">  Performance Predator </h2><br><p>  Since Predator does not need to perform any query transformations at run time, the performance gain is significant.  In the world of cloud computing utilization, where you pay for the amount of time your application runs or for the execution of a single function, developers often overlook the performance of their data access mechanisms. </p><br><p>  The following table summarizes the performance differences that can be expected for a simple search expression such as <code>findByTitle</code> compared to other implementations.  All tests were performed using a test bench on the 8-core Xeon iMac Pro under the same conditions, the tests are open and can be found <a href="https://github.com/micronaut-projects/micronaut-predator/tree/master/benchmarks">in the repository</a> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Implementation </th><th>  Operations per second </th></tr></thead><tbody><tr><td>  Predator JDBC </td><td>  225K ops / sec </td></tr><tr><td>  Predator jpa </td><td>  130K ops / sec </td></tr><tr><td>  Spring data jpa </td><td>  90K ops / sec </td></tr><tr><td>  GORM JPA </td><td>  50K ops / sec </td></tr><tr><td>  Spring Data JDBC </td><td>  Finders not supporteded </td></tr></tbody></table></div><br><p>  Yes, you read it right.  With Predator JDBC, you can expect an almost 4X performance increase over GORM and 2.5X over Spring Data. </p><br><p>  And even if you use Predator JPA, you can count on more than 2X performance improvements compared to GORM and up to 40% increase compared to Spring Data JPA. </p><br><p>  Look at the difference in the size of the execution stack when using Predator compared to alternatives: </p><br><p>  <strong>Predator:</strong> </p><br><p><img src="https://habrastorage.org/webt/6_/5l/ns/6_5lnsvtlyng0zisy5updpoii30.png"></p><br><p>  <strong>Predator JPA:</strong> </p><br><p><img src="https://habrastorage.org/webt/dw/us/bc/dwusbcyeubxeu8l-glmhgq0r7me.png"></p><br><p>  <strong>Spring Data:</strong> </p><br><p><img src="https://habrastorage.org/webt/di/m2/uv/dim2uvimrgxvs4ksszq0gsxujkq.png"></p><br><p>  <strong>GORM:</strong> </p><br><p><img src="https://habrastorage.org/webt/ad/7z/rs/ad7zrsyjfc1-fpr-cm3vqp9cmle.png"></p><br><p>  Predator JDBC uses only 15 frames until the moment your request is completed, while Predator JPA uses 30 (mainly because of Hibernate), compared to 50+ stack frames in Spring Data or GORM.  And all thanks to AOP Micronaut mechanisms that do not use reflection. </p><br><p>  Shorter stackraces also simplify application debugging.  One of the advantages of doing most of the work during compilation is that errors can be detected before the application launches, which greatly improves the developer's experience.  We get compilation errors immediately instead of runtime errors for the most common errors. </p><br><h2 id="proverki-vremeni-kompilyacii">  Compile time checks </h2><br><p>  Most implementations of the repository template rely solely on performing all operations at runtime.  This means that if the developer makes a mistake in defining the interface of the repository, errors will not be visible until the application is actually launched. </p><br><p>  This robs us of some of the benefits of Java for type checking and we have poor data experience.  With Predator, this is not so.  Consider the following example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JdbcRepository</span></span>(dialect = Dialect.H2) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Book </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span></span>; }</code> </pre> <br><p>  Here <code>BookRepository</code> we declared a request to an object named <code>Book</code> , which has a <code>title</code> property.  Unfortunately, there is an error in this declaration: we named the <code>findByTile</code> method instead of <code>findByTitle</code> .  Instead of running this code, Predator will not allow your code to compile with an informative error message: </p><br><pre> <code class="plaintext hljs">Error:(9, 10) java: Unable to implement Repository method: BookRepository.findByTile(String title). Cannot use [Equals] criterion on non-existent property path: tile</code> </pre> <br><p>  Many aspects of Predator are checked at compile time, when possible, to ensure that a runtime error is not caused by an incorrect repository declaration. </p><br><h2 id="predator-jdbc-i-graalvm-substrate">  Predator JDBC and GraalVM Substrate </h2><br><p>  Another reason Predator should be happy is that it is out of the box compatible with native GraalVM Substrate images and does not require complex bytecode conversions during build, unlike those for Hibernate on GraalVM. </p><br><p>  By completely eliminating reflection and dynamic proxies from the data access layer, Predator greatly simplifies the creation of applications that work with data running on GraalVM. </p><br><p>  <a href="https://github.com/micronaut-projects/micronaut-predator/tree/master/examples/example-jdbc">The Predator JDBC sample application</a> runs on Substrate without problems and allows you to create a much smaller native image (25 MB less!) Than Hibernate needs to work, thanks to a much thinner runtime layer. </p><br><p>  We saw the same result when we implemented the <a href="https://docs.micronaut.io/1.2.x/guide/index.html">Bean Validation rule compilation</a> for Micronaut 1.2.  The native image size decreased by 10 MB, as soon as we removed the dependency on the Hibernate Validator, and the JAR size by 2 MB. </p><br><p>  The advantage here is obvious: by doing more work at compile time and creating more compact runtimes, you get a smaller native image and a JAR file, which leads to smaller and easier to deploy microservices when deploying through Docker.  The future of Java frameworks is more powerful compilers and smaller, lighter runtimes. </p><br><h2 id="predator-i-buduschee">  Predator and the future </h2><br><p>  We are just starting to work with Predator and are extremely pleased with the opportunities that it opens up. </p><br><p>  Initially, we start with support for JPA and SQL, but in the future you can expect support for MongoDB, Neo4J, Reactive SQL and other databases.  Fortunately, this job is a lot simpler because most of Predator is actually based on the GORM source code, and we can reuse the GORM logic for Neo4J and GORM logic for MongoDB to release these implementations faster than you expect. </p><br><p>  Predator is the culmination of combining the various building blocks in Micronaut Core that made it possible to implement it, from the AoT APIs, which are also used to generate Swagger documentation, to the relatively new Bean Introspection support, which lets you analyze objects at runtime without reflection. </p><br><p>  Micronaut provides building blocks for amazing things.  Predator is one such thing, and we are just starting to work on some of the promising features of Micronaut 1.0. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460839/">https://habr.com/ru/post/460839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460825/index.html">Introduction to Screen Capture API - Scan QR codes in a browser</a></li>
<li><a href="../460827/index.html">PGP problem</a></li>
<li><a href="../460831/index.html">The dangers of designers</a></li>
<li><a href="../460833/index.html">Physics and Economics. Gnoseological difference and its manifestation in IT</a></li>
<li><a href="../460837/index.html">Beginner Podcast Handbook</a></li>
<li><a href="../46084/index.html">Zend Framework Tuning + Doctrine</a></li>
<li><a href="../460843/index.html">Introducing the New 3CX Call Flow Designer and 3CX CRM Template Generator</a></li>
<li><a href="../460845/index.html">Fernando Corbato, the father of your computer (and password), died at 93</a></li>
<li><a href="../460849/index.html">Part 4. A graph model for calculating logical functions for asynchronous parallel processes</a></li>
<li><a href="../460851/index.html">SamsPcbGuide Part 10: Technology, Lead-Free Soldering</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>