<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Keyword volatile and time attack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The OpenSSL library has a rather curious function with a promising name CRYPTO_memcmp () . Comments to it explain that the usual memcmp () has a fatal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Keyword volatile and time attack</h1><div class="post__text post__text-html js-mediator-article"><img align="right" alt="These watches are poorly suited to attack in time." src="https://habrastorage.org/getpro/habr/post_images/b09/4c3/827/b094c3827072e9a78a1b87d17f052ccb.jpg">  The OpenSSL library has a <a href="">rather curious function with a promising name <i>CRYPTO_memcmp ()</i></a> .  Comments to it <a href="">explain</a> that the usual <i>memcmp ()</i> has a fatal flaw - the time of its work depends not only on the size of the compared blocks, but also on their contents, and this can help the attacker to carry out the so-called <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8">time attack</a> . <br><br>  There are similar functions in a number of other projects - searching for the request <i>constant time memcmp</i> gives several thousand results. <br><br>  We will not question the need to use the function <i>CRYPTO_memcmp ()</i> , but instead consider whether it solves the problem posed to it. <br><a name="habracut"></a><br>  First, we compare the ‚Äúnormal‚Äù and ‚Äúprotected‚Äù implementation of <i>memcmp ()</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      "Normal" is arranged as follows: <br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* first = f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* second = s; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( length != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( *first &gt; *second ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( *first &lt; *second ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-5</span></span>; length--; first++; second++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre>  The function can return zero, negative integer and positive integer (not necessarily 1 and -1).  Naturally, as soon as the first difference is found, it does not make sense to continue the cycle, so the cycle is interrupted and the function returns. <br><br>  For comparison, this is how <i>CRYPTO_memcmp () works</i> : <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CRYPTO_memcmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* first = f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* second = s; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> magic = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++ ) { magic |= (first[i] ^ second[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic; }</code> </pre>  The first difference is that it returns only ‚Äúzero‚Äù and ‚Äúnon-zero‚Äù, so <i>memcmp () is</i> not suitable for direct replacement.  In all cases of using this function in OpenSSL, this difference is taken into account - the function is used only to check the equality of blocks. <br><br>  The second difference is that there is no exit from the loop except after passing both blocks of data entirely.  For the sake of this difference, the function is made. <br><br>  ALAS. <br><br>  The optimizing compiler has the right to ‚Äúbreak‚Äù <i>CRYPTO_memcmp ()</i> and generate the same machine code for it as for the usual <i>memcmp ()</i> (of course, corrected for a slight difference in the semantics of their return values).  Further, it will be considered in detail what possibilities the compiler has for such optimization.  At the time of writing the post, no common compiler presented on <a href="http://gcc.godbolt.org/">gcc.godbolt.org</a> does not make such optimizations.  The more interesting - you can stock up on popcorn and follow their development. <br><br>  Now look again at the implementation of <i>CRYPTO_memcmp ()</i> .  At the same time look at the Standard C99.  It does not contain such a definition of ‚Äúobservable behavior‚Äù as in 1.9 / 6 of the C ++ 03 Standard, but in 5.1.2.3/3 it is said that the compiler can delete code that does not lead to ‚Äúthe necessary side effects‚Äù.  Further, in 5.1.2.3/6, the minimum requirements are listed, which include the requirements of ‚Äústability of <i>volatile</i> objects at points of sequence in the sense that previous access operations were completed at the point of sequence, and the subsequent ones did not start‚Äù.  In fact, this requirement is similar to the requirements of 1.9 / 6 from C ++ 03 - nothing is said about access to objects that do not have <i>volatile</i> qualifiers. <br><br>  Looking closely at this wonderful cycle: <br><pre> <code class="hljs vbscript">/* i variable value <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> used after the <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> */ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++ ) { magic |= (first[i] ^ <span class="hljs-built_in"><span class="hljs-built_in">second</span></span>[i]); }</code> </pre>  It is conceived that it will force the compiler to generate code that completely passes both data blocks.  But the Standard does not require anything like that.  Here is just a way to calculate the value of the magic variable.  From the standpoint of the Standard, this code is completely equivalent to such a code (the value of the variable <i>i</i> after exiting the loop may differ from the first variant of the code, but this value after the loop is not used, therefore, optimization is permissible): <br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/* i variable value not used after the loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++ ) { magic |= (first[i] ^ second[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( magic == UCHAR_MAX ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre>  The compiler has enough data for this optimization.  Obviously, the operation <i>| =</i> can either leave the digits of the <i>magic</i> variable unchanged, or put them in 1. It cannot put them in 0.  Once all the digits are set, no further changes to the value of the <i>magic</i> variable are possible. <br><br>  Can the compiler decide on this optimization?  The second variant of the code may be slower in cases when the data in the compared blocks are the same or the first difference is far from the beginning.  And we will check - we will compile both versions of the code with the Visual C ++ 9 compiler, and first we will make sure that the machine code is different as we expected. <br><br>  This is how the machine code of the cycle without <i>break</i> looks <br><pre> <code class="hljs lua"><span class="hljs-number"><span class="hljs-number">00</span></span>AF10D3 mov bl,<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [eax+edi] <span class="hljs-number"><span class="hljs-number">00</span></span>AF10D6 xor bl,<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [eax] <span class="hljs-number"><span class="hljs-number">00</span></span>AF10D8 inc eax <span class="hljs-number"><span class="hljs-number">00</span></span>AF10D9 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> dl,bl <span class="hljs-number"><span class="hljs-number">00</span></span>AF10DB <span class="hljs-built_in"><span class="hljs-built_in">sub</span></span> ebp,<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>AF10DE jne wmain+<span class="hljs-number"><span class="hljs-number">0</span></span>D3h (<span class="hljs-number"><span class="hljs-number">0</span></span>AF10D3h)</code> </pre>  So - in the case of a cycle with <i>break</i> : <br><pre> <code class="hljs lua"><span class="hljs-number"><span class="hljs-number">00</span></span>AF1116 mov edx,dword ptr [esp+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] <span class="hljs-number"><span class="hljs-number">00</span></span>AF111A mov dl,<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [eax+edx] <span class="hljs-number"><span class="hljs-number">00</span></span>AF111D xor dl,<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [eax] <span class="hljs-number"><span class="hljs-number">00</span></span>AF111F <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> bl,dl <span class="hljs-number"><span class="hljs-number">00</span></span>AF1121 cmp bl,<span class="hljs-number"><span class="hljs-number">0</span></span>FFh <span class="hljs-number"><span class="hljs-number">00</span></span>AF1124 je wmain+<span class="hljs-number"><span class="hljs-number">12</span></span>Ch (<span class="hljs-number"><span class="hljs-number">0</span></span>AF112Ch) <span class="hljs-number"><span class="hljs-number">00</span></span>AF1126 inc ecx <span class="hljs-number"><span class="hljs-number">00</span></span>AF1127 inc eax <span class="hljs-number"><span class="hljs-number">00</span></span>AF1128 cmp ecx,esi <span class="hljs-number"><span class="hljs-number">00</span></span>AF112A jl wmain+<span class="hljs-number"><span class="hljs-number">116</span></span>h (<span class="hljs-number"><span class="hljs-number">0</span></span>AF1116h)</code> </pre>  In the second case, there are 10 instructions instead of 6, and the comparison is honestly added (the <i>cmp</i> instruction) and the conditional transition (following the <i>cmp</i> <i>je</i> instruction). <br><br>  It should be tens of percent slower and no one will do this, right? <br><br>  But in the worst case (with byte equal blocks) on Intel Core i5 660 the second code is slower than the first one by no more than 3 percent (of course, the result may differ on other processors) - branch prediction works well on the second code, it allows you to do without processor pipeline reset, almost no speed reduction.  If the differences between the elements are typed in <i>UCHAR_MAX</i> , and for this only one pair of bytes is enough, in which the value of one byte is a bit negative of the value of the other byte, you can count on acceleration (if the difference is not too far from the beginning, of course, but with differences on 3 percent in the worst case ‚Äúnot too far‚Äù is somewhere around 97% of the time). <br><br>  Compiler developers can add heuristics, which in such cases will always compile the first version of the code as the second. <br><br>  Even in the compiler, there may be code profiling technology (something like PGO in Visual C ++), which allows you to run the code on a test package and then optimize it for the most typical scenarios.  In this case, the compiler will have objective data that allows you to assess whether there is a benefit from code conversion. <br><br>  And remember that the code for the Intel Core i5 is shown above, and its architecture is not the only one in the world, there may be instructions on some other processor, for example, combining <i>| =</i> , comparison and transition, with zero overhead compared to with <i>| =</i> .  The compiler, well sharpened for such an architecture, certainly uses such an instruction and compiles the first version of the code as the second. <br><br>  The above are three obvious ways to optimize the code, using only the code itself. <br><br>  Slowly stirring, add LTO, LTCG or whatever it is called optimization of several translation units in your compiler.  Using this technology, the compiler can simultaneously analyze both the code of the function itself and the calling code.  The calling code will look something like this: <br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( CRYPTO_memcmp( first, second, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> ) != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">/* blahblhablah */</span></span> }</code> </pre><br>  And here it is completely obvious that a cycle in a function is equivalent to this: <br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">length</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( first[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] != second[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre>  With this knowledge, it is much easier for the compiler to apply the three optimizations listed above. <br><br>  Such a code as in <i>CRYPTO_memcmp ()</i> is intolerable.  It works as expected only on specific compilers with specific build parameters. <br><br>  As usual, you need to use the keyword <i>volatile</i> . <br><br>  A completely standard-compliant way is to add the <i>volatile</i> qualifier to the <i>magic</i> variable.  In this case, the compiler will be obliged to generate code that ensures the execution of <i>| =</i> operations on each of the specified number of loop iterations.  The compiler is forced to place the magic variable in the automatic memory and for each iteration to generate the corresponding update code of the variable value.  From this on the Intel Core i5 660, the loop code slows down by about half.  How essential it is for the rest of the code to work can not be said without careful profiling. <br><br>  If it is determined that adding the <i>volatile</i> qualifier to the <i>magic</i> variable leads to an unacceptable deceleration of the code, subject to the reservations below, try using ‚Äú <i>volatile</i> pointers‚Äù: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CRYPTO_memcmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* first = f; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* second = s; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> magic = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++ ) { magic |= (first[i] ^ second[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic; }</code> </pre>  If <i>const volatile puzzles</i> you - in vain.  <i>const</i> indicates that the data cannot be changed from your code, and <i>volatile</i> indicates that it can in principle be changed without your code, so you cannot optimize the reads. <br><br>  As in the <a href="http://habrahabr.ru/company/abbyy/blog/161607/">previous post</a> , this does not guarantee optimization, because the data itself may not have a <i>volatile</i> qualifier (accessing the pointer gives lvalue, the type of which does not affect the data itself), but there are chances - usually compilers pay attention to the code with such pointers and code readings are not optimized. <br><br>  Using <i>volatile</i> in this case makes the code a bit more portable. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/223769/">https://habr.com/ru/post/223769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223753/index.html">Facebook mobile application knows you are listening and watching</a></li>
<li><a href="../223755/index.html">DevConf 2014: Writing a functional, reliable and fast web application on Go</a></li>
<li><a href="../223759/index.html">Published code engine for rendering PDF in Chrome browser</a></li>
<li><a href="../223761/index.html">Impressions of Lenovo Miix 2 8: a week with a tablet on Windows 8.1</a></li>
<li><a href="../223767/index.html">Multilingual Badoo: "translation difficulties"</a></li>
<li><a href="../223771/index.html">Dauria gets involved in a large microsatellite race</a></li>
<li><a href="../223773/index.html">Add gas: + 200% performance</a></li>
<li><a href="../223777/index.html">Our checklist for forms on sites</a></li>
<li><a href="../223779/index.html">Guinea pig, or one of the domestic production of MK</a></li>
<li><a href="../223783/index.html">Flask Mega-Tutorial, Part 7: Unit Testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>