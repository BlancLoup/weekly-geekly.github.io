<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The story about realloc (and laziness)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Simple macro 
 It all started with a simple macro: (approximate code) 


#define ADD_BYTE(C) do { \ if (offset == capa) { \ if (capa < 16) { \ capa = ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The story about realloc (and laziness)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/bd5/f3f/f3a/bd5f3ff3ad854ad4b7692ab52e1875ce.jpg" align="right"><h4>  Simple macro </h4><br>  It all started with a simple macro: (approximate code) <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ADD_BYTE(C) do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (offset == capa) { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (capa &lt; 16) { \ capa = 16; \ } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { \ capa &lt;&lt;= 1; \ } \ buffer = realloc(buffer, capa); \ assert(buffer != NULL); \ } \ buffer[offset++] = (C); \ } while(0)</span></span></code> </pre> <br><br>  For those who are not familiar with the C programming language, I will explain: this simple macro adds the ‚ÄúC‚Äù byte to the dynamically allocated buffer (buffer), the size of which (in bytes) is equal to capa.  <i>The next write position is</i> determined by the offset parameter.  Each time the buffer is filled, it doubles its size (starting with a minimum size of 16 bytes). <br><br>  We add bytes to the dynamic buffer - this is one of the most common operations in almost any program (for working with strings, arrays, etc.). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But how to understand how effective the strategy of redistribution? <a name="habracut"></a>  If you look at this problem from the point of view of <b>complexity</b> , assuming the complexity of realloc () is <a href="http://en.wikipedia.org/wiki/Big_O_notation">O (N)</a> , you will immediately realize that adding one byte has <i>an average</i> complexity of O (1), which is quite good. <br><br>  But what is the difficulty in the worst case - if you need a redistribution of memory under the buffer? <br><blockquote>  <b>Anonymus</b> : Sure that this is a good strategy?  You will run into serious performance problems if you increase the size of a large array, say one gigabyte.  Just imagine the consequences, especially if the buffer needs to be moved out of the paging file. <br><br>  <b>Me</b> : Hmm ... Honestly, I never thought about it ... But I am sure that everything is not so bad.  The system must successfully cope with this task. <br><br>  <b>Anonimus</b> : And it seems to me that the associated structure is a better option, even with the same exponential strategy. <br><br>  <b>Me</b> : No, it's a waste of time. <br><br>  <b>Anonymus</b> : Proof? <br></blockquote><br><h4>  Oh, so it means? </h4><br>  Well, you have to justify their position.  Like all programmers, I am very lazy.  More precisely: " <i>As befits a programmer</i> , I am very lazy."  Laziness is a great incentive to become smarter and more efficient.  You are <i>too lazy</i> to perform repetitive or routine tasks;  you need <i>something more intelligent</i> , something <i>as fast as possible</i> .  Yes, that is what is sometimes called <i>laziness</i> .  But, in my opinion, this is nothing but <b>efficiency</b> . <br><br>  A linked list of buffer storage blocks is a somewhat cumbersome solution.  I do not say that it is <i>impossible</i> .  ‚Äú <a href="http://fr.wikipedia.org/wiki/Impossible_n%2527est_pas_fran%25C3%25A7ais">Impossible is not a French word,</a> ‚Äù Napoleon used to say (though he ended badly).  The solution is possible, but it is cumbersome.  Copying a subarray or saving it to disk will require some effort.  We probably would have to maintain the index of pointers to the beginning of each array, take the logarithm of base two to get the address of the beginning of the block and many more nudyatiny ... Wow, I'm already tired ... <br><br>  Something tells me that my laziness will be most welcome here.  After all, you should not worry about small blocks at all, but the virtual memory of the system will take care of large blocks. <br><br>  Let's see. <br><br><img src="//habrastorage.org/files/eab/712/b90/eab712b9011642fa8aee9c4026be1ec8.jpg" align="right"><h4>  By the way, what is realloc ()? </h4><br>  This is a common <a href="http://pubs.opengroup.org/onlinepubs/009695299/functions/realloc.html">POSIX compliant</a> function, which is implemented in <a href="http://en.wikipedia.org/wiki/C_POSIX_library">the C library</a> .  In the case of Linux, this is the libc.so library, and there are related realloc functions malloc and free in it: <br><br><pre> <code class="cpp hljs">nm -D /lib/x86_64-linux-gnu/libc.so<span class="hljs-number"><span class="hljs-number">.6</span></span> | grep -E <span class="hljs-string"><span class="hljs-string">"T (malloc|realloc|free)$"</span></span> <span class="hljs-number"><span class="hljs-number">000000000007e450</span></span> T <span class="hljs-built_in"><span class="hljs-built_in">free</span></span> <span class="hljs-number"><span class="hljs-number">000000000007e030</span></span> T <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> <span class="hljs-number"><span class="hljs-number">000000000007e4</span></span>e0 T <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span></code> </pre><br><br>  For those to whom it is really interesting: ‚ÄúT‚Äù means ‚Äútext symbol‚Äù (text symbol), the capital letter is used to show that the symbol is public and visible;  <a href="http://en.wikipedia.org/wiki/Code_segment">the</a> program <a href="http://en.wikipedia.org/wiki/Code_segment">text segment</a> is the <i>code</i> , <a href="http://en.wikipedia.org/wiki/Data_segment">the data segment</a> is the initialized data (variables), and <a href="http://en.wikipedia.org/wiki/.bss">the bss segment</a> is the uninitialized data (variables), or rather the data (variables) that received <i>zero</i> as the initial value). <br><br>  A memory allocator is used to allocate, redistribute, and free memory (thanks, Captain Obvious!).  There are many such distributors (the most famous one is the <a href="http://en.wikipedia.org/wiki/Buddy_memory_allocation">buddy allocator</a> ). <br><br>  We can implement our own simplest allocator using the great and terrible sbrk call, which simply adds empty space to the end of <i>the data segment</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; void *malloc(size_t size) { return sbrk(size); } void free(void *ptr) { /*   ? */ } /* :    (,  ) */ void *realloc(void *ptr, size_t size) { void *nptr = malloc(size); if (nptr == NULL) { return NULL; } // ¬´old_size¬ª    :) // (,      ) memcpy(nptr, ptr, old_size); free(ptr); return nptr; }</span></span></span></span></code> </pre><br><br>  <i>[Note.</i>  <i>As one of the Hacker News readers rightly noted, here you need the value of old_size, which, for example, could be written to the beginning of a block after the block was allocated.</i>  <i>But no, we should not have released the source block in case of errors in realloc :)]</i> <br><br><img src="//habrastorage.org/files/c2e/944/7d5/c2e9447d5a4441d78b8cffeedb52cbac.jpg" align="right">  Of course, a real allocator will be a <i>little</i> more complicated, complex data structures will be required to limit the number of memcpy calls. <br><br>  To understand what is happening with large blocks, we will have to get a closer <a href="http://www.gnu.org/software/libc/libc.html">look</a> at <a href="http://www.gnu.org/software/libc/libc.html">Glibc</a> on Linux. <br><br><h4>  Meet Glibc </h4><br>  Just <a href="https://www.gnu.org/software/libc/download.html">download the</a> latest version of glibc and explore the source tree. <br>  There is one interesting directory malloc.  Find the file malloc.c in it and open it in the editor. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   : *        (&gt;= 512 ),      FIFO (. .    ). *    (&lt;= 64   )   ,      . *    ,        ,          ,   . *     (&gt;= 128   )     ,   .  ,    ,    : http://gee.cs.oswego.edu/dl/html/malloc.html */</span></span></code> </pre><br><br>  We are most interested in this part: ‚Äú <i>For very large queries (&gt; = 128 KB by default), system memory mapping tools are used if they are supported</i> .‚Äù <br><br>  The 128 KB threshold is configured by the mallopt () function: <br><br><pre> <code class="cpp hljs">M_MMAP_THRESHOLD    ,   ,     ( ),   M_MMAP_THRESHOLD,     mmap(<span class="hljs-number"><span class="hljs-number">2</span></span>),          sbrk(<span class="hljs-number"><span class="hljs-number">2</span></span>).</code> </pre><br><br>  So, as I said, the virtual memory service of the system will take care of <i>large blocks</i> . <br><br>  In essence, this means that: <br><ul><li>  malloc will be implemented using mmap; </li><li>  free will be implemented using munmap; </li><li>  realloc will be implemented using mremap (What ?! There is no such thing in POSIX yet? Seriously?) </li></ul><br>  All right, let's slightly expand the knowledge about mremap. <br><br>  So, what we know about man mremap: <br><br><pre> <code class="cpp hljs">mremap()      Linux. mremap()       .  ,     <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>).</code> </pre><br><br>  Aha, <i>very effective realloc</i> .  How effective? <br><br>  First, mmap, munmap and mremap are described in the glibc library.  In fact, only entry points: <br><pre> <code class="cpp hljs">nm -D /lib/x86_64-linux-gnu/libc.so<span class="hljs-number"><span class="hljs-number">.6</span></span> | grep -E <span class="hljs-string"><span class="hljs-string">"(mmap|munmap|mremap)$"</span></span> <span class="hljs-number"><span class="hljs-number">00000000000e4350</span></span> W mmap <span class="hljs-number"><span class="hljs-number">00000000000e9080</span></span> W mremap <span class="hljs-number"><span class="hljs-number">00000000000e4380</span></span> W munmap</code> </pre><br><br>  Please note that the default entry points are in this case <i>‚Äúweak‚Äù characters</i> .  That is, they can be redefined by <i>someone else</i> during dynamic linking.  For example: <br><br><pre> <code class="cs hljs">ldd /tmp/sample linux-vdso.so<span class="hljs-number"><span class="hljs-number">.1</span></span> (<span class="hljs-number"><span class="hljs-number">0x00007584a8aaa000</span></span>) libc.so<span class="hljs-number"><span class="hljs-number">.6</span></span> =&gt; /lib/x86_64-linux-gnu/libc.so<span class="hljs-number"><span class="hljs-number">.6</span></span> (<span class="hljs-number"><span class="hljs-number">0x00007584a86e6000</span></span>) /lib64/ld-linux-x86<span class="hljs-number"><span class="hljs-number">-64.</span></span>so<span class="hljs-number"><span class="hljs-number">.2</span></span> (<span class="hljs-number"><span class="hljs-number">0x00007584a8aac000</span></span></code> </pre><br><br>  ... characters <i>can</i> be redefined by the linux-vdso.so.1 library - this is a <a href="http://man7.org/linux/man-pages/man7/vdso.7.html">magic library</a> that is displayed in all programs under Linux and allows you to speed up some calls, including <a href="http://en.wikipedia.org/wiki/System_call">system calls</a> . <br>  In any case, our characters in the glibc library are only channels to system core calls (syscall), be it glibc or vdso (see the default implementation: sysdeps / unix / sysv / linux / mmap64.c).  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * __mmap64 (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *addr, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prot, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd, <span class="hljs-keyword"><span class="hljs-keyword">off64_t</span></span> offset) { <span class="hljs-comment"><span class="hljs-comment">//    void *result; result = (void *) INLINE_SYSCALL (mmap2, 6, addr, len, prot, flags, fd, (off_t) (offset &gt;&gt; page_shift)); return result; }</span></span></code> </pre><img src="//habrastorage.org/files/edf/843/d69/edf843d696f54aefa844380632e4603a.jpg" align="right"><br><br>  So, our initial question is already connected not with glibc, but with the Linux kernel. <br><br><h4>  Introducing the kernel </h4><br>  <a href="https://www.kernel.org/">Download the</a> latest version of the kernel, and let's briefly look at how mremap works. <br><br>  Looking in the manual ( <a href="http://www.tldp.org/LDP/tlk/sources/sources.html">The Linux Kernel Howto</a> ), you will find a very interesting directory: <br><br><blockquote>  The mm directory contains all the necessary code for working with memory.  An architecture-specific memory management code is placed in arch / * / mm / type directories, for example, arch / i386 / mm / fault.c. </blockquote><br><br>  Fine.  We need them! <br>  Here is an interesting file: mm / mremap.c.  In it you will find the entry point for the system call of the mremap function.  Here: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *  ( )  , ,    * (    MREMAP_MAYMOVE    VM) * *  MREMAP_FIXED  5  1999 .   (Benjamin LaHaise) *     MREMAP_MAYMOVE. */</span></span> SYSCALL_DEFINE5(mremap, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, addr, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, old_len, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, new_len, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, flags, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, new_addr) {</code> </pre><br><br>  It is here that we <i>enter</i> the kernel when executing the corresponding system call in the user code (via glibc or the corresponding vdso channel). <br><br>  After examining the code of this function, you will see various argument checks and handling of trivial cases (for example, <i>reducing</i> a memory block ‚Äî you just need to free the pages at the end of the block). <br><br>  Then the kernel will try to expand the mapped area by increasing it (the distributor in the C library would do the same with sbrk).  In case of successful expansion, the function returns the result. <br><br>  All these trivial cases are implemented with O (1) complexity (even if we take into account the cost of entering the kernel, they will be less, since interrupts are no longer used, but they will still be). <br><br>  And what's the <i>worst case</i> ? <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* *         *       . */</span></span> ret = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; MREMAP_MAYMOVE) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> map_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vma-&gt;vm_flags &amp; VM_MAYSHARE) map_flags |= MAP_SHARED; new_addr = get_unmapped_area(vma-&gt;vm_file, <span class="hljs-number"><span class="hljs-number">0</span></span>, new_len, vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT), map_flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_addr &amp; ~PAGE_MASK) { ret = new_addr; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; } map_flags = vma-&gt;vm_flags; ret = move_vma(vma, addr, old_len, new_len, new_addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(ret &amp; ~PAGE_MASK)) { track_exec_limit(current-&gt;mm, addr, addr + old_len, <span class="hljs-number"><span class="hljs-number">0U</span></span>L); track_exec_limit(current-&gt;mm, new_addr, new_addr + new_len, map_flags); } }</code> </pre><br><br>  At first glance, the core does the same thing that we do in our simple allocator: <br><ul><li>  highlights a new area; </li><li>  copies the source area to a new one, and then releases it (i.e., a move operation is performed). </li></ul><br>  But let's <i>take a closer</i> look. <br><br>  Here is the call to move_vma: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_vma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct vm_area_struct *vma, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> old_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> old_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_addr)</span></span></span><span class="hljs-function"> </span></span>{ ... new_pgoff = vma-&gt;vm_pgoff + ((old_addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT); new_vma = copy_vma(&amp;vma, new_addr, new_len, new_pgoff, &amp;need_rmap_locks); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!new_vma) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; moved_len = move_page_tables(vma, old_addr, new_vma, new_addr, old_len, need_rmap_locks);</code> </pre><br><img src="//habrastorage.org/files/a8d/ac5/0ac/a8dac50acb2a4dfbad680514cbe3febc.jpg" align="right"><br>  There are two interesting challenges: <br><ul><li>  copy_vma; </li><li>  move_page_tables. </li></ul><br>  The copy_vma function is described in the mm / mmap.c file;  it moves a structure of type vm_area_struct - this is the internal structure of the kernel, describing a block of memory. <br><br>  The definition can be found here: include / linux / mm_types.h.  This <i>small</i> structure contains all the information about the region: the starting and ending addresses, the file on the disk (if the memory area is used to display the file), etc. <br><br>  So, this move operation is quite simple - O (1). <br><br>  And what does the move_page_tables function do? <br><br>  The most interesting, it seems, here in this cycle: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; old_addr &lt; old_end; old_addr += extent, new_addr += extent) { ... move_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks); ...</code> </pre><br><br>  This code is <i>somewhat</i> complicated (besides, there are no comments), but basically these are basic arithmetic operations and calculations. <br><br>  The move_ptes function contains the innermost loop of the lowest level: <br><br><pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; old_addr &lt; old_end; old_pte++, old_addr += PAGE_SIZE, new_pte++, new_addr += PAGE_SIZE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pte_none(*old_pte)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pte = ptep_get_and_clear(mm, old_addr, old_pte); pte = move_pte(pte, new_vma-&gt;vm_page_prot, old_addr, new_addr); ... set_pte_at(mm, new_addr, new_pte, pte); } ...</code> </pre><br><br>  So what happens in this cycle ?!  We simply move the rows of the page table ( <b>PTE</b> , <a href="https://www.kernel.org/doc/gorman/html/understand/understand006.html">Page Table Entries</a> ) corresponding to the memory area to another place.  In essence, these are the integers assigned to each page. <br><br>  So, what we have: in fact, the core <i>did not touch</i> the data from our associated block;  to move the whole area, it was enough to swap a few bits. <br>  Formally, the complexity <i>is still</i> O (N), but <br><ul><li>  instead of copying whole 4 KB pages (or 2 MB for very large pages), we swap whole numbers inside the core structure; </li><li>  we work with the ‚Äúhot‚Äù memory of the kernel, without touching the ‚Äúcold‚Äù and especially the data pushed into the paging file. </li></ul><br>  Therefore, we use O (N), but with a huge difference. <br><br>  Oh, by the way, do you know that O (N) is confusing in many cases? <br><br>  In our case, the maximum value of N is 2 <sup>48</sup> (the maximum size of the virtual space).  Most computers work with only a few gigabytes of memory - no more than 64 GB for most architectures (that is, 2 <sup>36</sup> bytes).  The big page is 2 <sup>21</sup> bytes, the maximum number of operations is 2 <sup>15</sup> for move_ptes (yes, it <i>is only</i> 32 768 operations). <br><br>  So, in the worst case, the costs are always extremely low, and for some reason I did not doubt it from the very beginning. <br><br>  <i>I also recommend reading: the book <a href="https://www.kernel.org/doc/gorman/pdf/understand.pdf">Understanding the Linux Virtual Memory Manager by</a> Mel Gorman (Mel Gorman).</i> <br><br>  "Niasilil mnogabukaf"?  Do not worry.  Laziness and realloc are our everything. </div><p>Source: <a href="https://habr.com/ru/post/238739/">https://habr.com/ru/post/238739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238727/index.html">Lost data among the "clouds"?</a></li>
<li><a href="../238731/index.html">Unmanned flights over the North Sea</a></li>
<li><a href="../238733/index.html">Microsoft Windows 10 Presentation in San Francisco</a></li>
<li><a href="../238735/index.html">Payoneer changes color. Our new brand</a></li>
<li><a href="../238737/index.html">CRUD Operations Using MVC</a></li>
<li><a href="../238741/index.html">HTML minimization in Web Essentials 2013: What has changed over the year?</a></li>
<li><a href="../238743/index.html">Redfish - IPMI alternative is around the corner.</a></li>
<li><a href="../238745/index.html">Vulnerability in Akeeba Backup and Joomla!</a></li>
<li><a href="../238747/index.html">Philips introduced a wearable gadget that relieves the symptoms of psoriasis with light</a></li>
<li><a href="../238749/index.html">Bioluminescent lamp with luminous bacteria inside</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>