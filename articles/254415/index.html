<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Become the master of loading Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="First, we will introduce udev and learn how to use it to examine the devices installed on the computer right at boot time: as an example, we will auto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Become the master of loading Linux</h1><div class="post__text post__text-html js-mediator-article">  First, we will introduce udev and learn how to use it to examine the devices installed on the computer right at boot time: as an example, we will automatically select the video card settings for Xorg.  Then we will solve the problem of working with one image on dozens of computers at the same time by implementing our own handler in the initramfs, and at the same time we optimize the system for network boot.  To further reduce the load time and reduce the load on the network, try replacing NFS with NBD, and help TFTP using HTTP.  In the end, we will return to the beginning - to the boot server, which will also be switched to read-only mode. <br><br><img src="https://habrastorage.org/files/7a7/b69/abc/7a7b69abca3b47c69975721d79c531f9.jpg"><br><br>  This article is more a study, not a ready-made guide (all solutions work, they just are not always optimal).  In the end, you will have enough knowledge to do everything the way you want it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Start look here: <br>  <a href="http://habrahabr.ru/post/253256/">Initial server setup</a> <br>  <a href="http://habrahabr.ru/post/253573">Preparing the image for network boot</a> <br><a name="habracut"></a><br>  We stopped at the fact that we downloaded the VirtualBox machine over the network and launched Firefox.  If you now try to do the same with a real computer, then the screen will show the cyclical authorization of the user username and unsuccessful attempts to start the graphical environment - <a href="https://wiki.archlinux.org/index.php/Xorg">Xorg</a> does not find the necessary driver. <br><br><h2>  We start video cards </h2><br>  For the graphics mode to work in VirtualBox, we have installed everything you need.  It was originally planned that our diskless system will function on any hardware, but <s>due to laziness</s> we will not try to embrace the immense, so we limit ourselves to supporting graphics solutions from the following dominant manufacturers: nVidia, Intel and AMD. <br><br>  Switch on the client machine to the second terminal by pressing Ctrl + Alt + F2 and install open drivers: <br><pre><code class="bash hljs">pacman -S xf86-video-ati xf86-video-nouveau xf86-video-intel</code> </pre> <br>  Most likely, this time Xorg will not be able to choose the appropriate settings for each case on its own, and judging from the screen of the downloaded client, it will seem that nothing has changed at all. <br><br>  The easiest way to find out which video devices are in the system is to enter a command in the console: <br><pre> <code class="bash hljs">lspci | grep -i vga 00:02.0 VGA compatible controller: InnoTek Systemberatung GmbH VirtualBox Graphics Adapter</code> </pre> <br>  But we will not look for easy ways, and as a reward we will receive a new portion of knowledge. <br><br><h3>  Take a closer look at udev </h3><br>  I mentioned earlier that <b>the device manager</b> in Archlinux is called <a href="https://wiki.archlinux.org/index.php/Udev">udev</a> .  It is included in the systemd package under the name systemd-udevd. <br><br>  As new devices are discovered in the boot system, the kernel creates their hierarchy in the / devices directory.  First, the PCI system itself appears, then it detects the tires on which the end devices ‚Äúsit‚Äù, and their drivers sort the devices into classes.  Devices within classes are detected in parallel, just as systemd runs services in parallel to achieve the next goal. <br><br>  Asynchronous search for devices leads to the fact that if several devices belonging to the same class are present on the computer at the same time, they can be found in a different order from switching to switching on, for example, first one video card and then the other, and their names will be change between themselves.  Fortunately, the emergence of a new element in the device hierarchy is a udev event that can be tracked and actions taken. <br><br>  For the udev manager, rules were designed to streamline chaos and simplify the life of installed programs.  The rules are stored in the folders /usr/lib/udev/rules.d/ and /etc/udev/rules.d/ (the latter, as in the case of hooks, has a higher priority and the files from there are checked first).  The appearance of a new element in the device hierarchy is accompanied by checking all established udev rules, and automatically performing the actions specified there, in the event of a match.  Usually these steps consist in renaming devices and setting up links to them in directories inside / dev and / sys for ease of use in programs. <br><br>  Video card drivers refer them to the drm subsystem (class), so information about such devices is duplicated in the / sys / class / drm directory.  The first video card found in the system, by default, gets the name "card0", if it has several video outputs, then they get names like "card0-CON-n", where "CON" is the connector type (VGA, HDMI, DVI and etc.), and ‚Äún‚Äù is the serial number of the connector (moreover, some manufacturers number the connectors starting with ‚Äú0‚Äù and others with ‚Äú1‚Äù).  The next video card becomes ‚Äúcard1‚Äù, etc. <br><br>  If nothing is done, in view of the parallelism of detection, the next time card1 is turned on, it can become card0 and vice versa.  Udev will add such devices to / dev with one or another name.  Cases where this udev behavior is undesirable are described in detail on the Internet, and they mainly discuss various USB devices.  We also need to run a certain program when detecting video cards, which we will write later, but for now we‚Äôll find out what udev is known for. <br><br>  To find out the same thing that knows about the udev video card, enter the command on the client: <br><pre> <code class="bash hljs">udevadm info -a -p /sys/class/drm/card0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">command output</b> <div class="spoiler_text">  Udevadm info <br>  walks up the chain of parent devices.  It prints for every device <br>  found, all possible attributes in the udev rules key format. <br>  The rule is to match. <br>  one single parent device. <br><br>  looking at device '/devices/pci0000:00/0000:00:02.0.0/drm/card0': <br>  KERNEL == "card0" <br>  SUBSYSTEM == "drm" <br>  DRIVER == "" <br><br>  looking at parent device '/devices/pci0000:00/0000:00:02.0': <br>  KERNELS == "0000: 00: 02.0" <br>  SUBSYSTEMS == "pci" <br>  DRIVERS == "" <br>  ATTRS {irq} == "18" <br>  ATTRS {subsystem_vendor} == "0x0000" <br>  ATTRS {broken_parity_status} == "0" <br>  ATTRS {class} == "0x030000" <br>  ATTRS {driver_override} == "(null)" <br>  ATTRS {consistent_dma_mask_bits} == "32" <br>  ATTRS {dma_mask_bits} == "32" <br>  ATTRS {local_cpus} == "00000000,00000000,00000000,00000001" <br>  ATTRS {device} == "0xbeef" <br>  ATTRS {enable} == "1" <br>  ATTRS {msi_bus} == "1" <br>  ATTRS {local_cpulist} == "0" <br>  ATTRS {vendor} == "0x80ee" <br>  ATTRS {subsystem_device} == "0x0000" <br>  ATTRS {boot_vga} == "1" <br>  ATTRS {numa_node} == "- 1" <br>  ATTRS {d3cold_allowed} == "0" <br><br>  looking at parent device '/ devices / pci0000: 00': <br>  KERNELS == "pci0000: 00" <br>  SUBSYSTEMS == "" <br>  DRIVERS == "" <br></div></div><br>  Notice the tree structure using the paradigm of the parent and child devices.  In the lines beginning with ‚Äúlooking at ...‚Äù the path to this device is relative to the / sys directory, i.e. by accessing the video card along the path / sys / class / drm / card0, we found that this is actually a link to /sys/devices/pci0000:00/0000:00:02.0/drm/card0. <br><br>  The parent device /devices/pci0000:00/0000:00:02.0 has a vendor attribute with a manufacturer ID.  Udev has access to an extensive database and can translate this code into a digestible form: <br><pre> <code class="bash hljs">udevadm info -q property -p /sys/devices/pci0000:00/0000:00:02.0 DEVPATH=/devices/pci0000:00/0000:00:02.0 ID_MODEL_FROM_DATABASE=VirtualBox Graphics Adapter ID_PCI_CLASS_FROM_DATABASE=Display controller ID_PCI_INTERFACE_FROM_DATABASE=VGA controller ID_PCI_SUBCLASS_FROM_DATABASE=VGA compatible controller ID_VENDOR_FROM_DATABASE=InnoTek Systemberatung GmbH MODALIAS=pci:v000080EEd0000BEEFsv00000000sd00000000bc03sc00i00 PCI_CLASS=30000 PCI_ID=80EE:BEEF PCI_SLOT_NAME=0000:00:02.0 PCI_SUBSYS_ID=0000:0000 SUBSYSTEM=pci USEC_INITIALIZED=24450</code> </pre> <br>  Compare with the command output: <br><pre> <code class="bash hljs">lspci | grep -i vga 00:02.0 VGA compatible controller: InnoTek Systemberatung GmbH VirtualBox Graphics Adapter.</code> </pre> <br><br><h3>  Dynamic video card configuration with udev </h3><br>  Connect to the boot server.  And create a file with the rules: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> root=/srv/nfs/diskless nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/udev/rules.d/10-graphics.rules KERNEL==<span class="hljs-string"><span class="hljs-string">"card[0-9]*"</span></span>, SUBSYSTEM==<span class="hljs-string"><span class="hljs-string">"drm"</span></span>, RUN+=<span class="hljs-string"><span class="hljs-string">"/etc/default/xdevice %n"</span></span> KERNEL==<span class="hljs-string"><span class="hljs-string">"card*"</span></span>, SUBSYSTEM==<span class="hljs-string"><span class="hljs-string">"drm"</span></span>, ATTR{enabled}==<span class="hljs-string"><span class="hljs-string">"enabled"</span></span>, ATTR{status}==<span class="hljs-string"><span class="hljs-string">"connected"</span></span>, RUN+=<span class="hljs-string"><span class="hljs-string">"/etc/default/xdevice %n %k"</span></span></code> </pre> <br>  Each rule is written in a new line.  The first part is to identify the udev event to which you want to apply the action specified at the end of the line.  To identify the event, data is used that can be obtained from the output of the command ‚Äúudevadm info -a -p / sys ...‚Äù. <br><br>  The rule from the first line works for all devices with the name (core) card0, card1 ... of the drm subsystem.  The second rule will work only for active devices from the drm subsystem to which the monitor is currently connected (it will not work for card0, card1, but only for names like card0-HDMI-1, since only such devices have enabled attributes and status).  When an event coincides with its description, the same program is executed, in which in the first case one parameter% n is sent (the kernel sequence number, which for card0 will be ‚Äú0‚Äù), and in the second - the additional parameter% k (the kernel name itself ‚Äú card0 "). <br><br>  The / etc / default / xdevice program will change the contents of the file in the /etc/X11/xorg.conf.d/ folder, which contains information about the video adapter settings for xorg.  For different manufacturers, we will prepare different templates that take into account the specifics of the implementation.  It is enough to specify the minimum necessary information to uniquely identify the device, and xorg will do the rest on its own: <br><pre> <code class="bash hljs">Section <span class="hljs-string"><span class="hljs-string">"Device"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"  "</span></span> Driver <span class="hljs-string"><span class="hljs-string">" "</span></span> Option <span class="hljs-string"><span class="hljs-string">"AccelMethod"</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span> BusID <span class="hljs-string"><span class="hljs-string">"PCI:  PCI,    "</span></span> EndSection</code> </pre> <br>  We will indicate the necessary data in the template itself, or we will obtain by examining the output of the udevadm info command. <br><br>  The program will be triggered for each output of each video card to which the monitor is connected.  To simplify the task, let's make the last discovered option work so that at least one monitor works on multimonitor systems.  This is not the best way to configure, and it would be better to check the graphics subsystem once before reaching the graphical.target, but our option is working and is suitable for learning the udev rules in action. <br>  Create a program file with the following content: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/default/xdevice</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #         xorg CONF_FILE=/etc/X11/xorg.conf.d/20-device.conf #        ""  #     ,       get_vendor(){ local card=$(get_path $1) udevadm info -q property -p ${card%\/drm*} | \ awk '/^ID_VENDOR_FROM_DATABASE/{split($1,a,"=");print tolower(a[2])}' } #    PCI         x:y:z get_bus(){ local bus=$(get_path $1) echo ${bus%\/drm*} | \ sed 's\:\.\g' | \ awk '{n=split($0,a,".");printf "%i:%i:%i",a[n-2],a[n-1],a[n]}' } #      get_path(){ udevadm info -q path -p /sys/class/drm/$1 } #          . make_conf(){ local filename="xorg-device-$(get_vendor $1).conf" cat /etc/X11/$filename | \ sed 's\%BUS%\'$(get_bus $1)'\g'| \ sed 's\%ID%\'$1'\g' &gt; $CONF_FILE } #    virtualbox,      check_vbox(){ local vendor=$(get_vendor $1) [ "$vendor" == "innotek" ]] &amp;&amp; systemctl start vboxservice } #  card_numb=$1 if [ -z "$2" ] #    virtualbox then card_name="card$card_numb" check_vbox $card_name &amp;&amp; make_conf $card_name else card_name=$2 make_conf $card_name fi</span></span></code> </pre><br></div></div><br>  Make the file executable: <br><pre> <code class="bash hljs">chmod +x <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/default/xdevice</code> </pre> <br>  Turning off the automatic loading of the VirtualBox service, since now it will be launched by our program only when necessary: <br><pre> <code class="bash hljs">systemctl <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> vboxservice</code> </pre> <br>  Add xorg configuration file templates with settings optimized for the main manufacturers: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xorg-device-intel.conf Section <span class="hljs-string"><span class="hljs-string">"Device"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"Intel %ID%"</span></span> Driver <span class="hljs-string"><span class="hljs-string">"intel"</span></span> Option <span class="hljs-string"><span class="hljs-string">"AccelMethod"</span></span> <span class="hljs-string"><span class="hljs-string">"uxa"</span></span> BusID <span class="hljs-string"><span class="hljs-string">"PCI:%BUS%"</span></span> EndSection</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">AMD, nVidia, VirtualBox</b> <div class="spoiler_text"><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xorg-device-innotek.conf Section <span class="hljs-string"><span class="hljs-string">"Device"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"VirtualBox %ID%"</span></span> Driver <span class="hljs-string"><span class="hljs-string">"vboxvideo"</span></span> BusID <span class="hljs-string"><span class="hljs-string">"PCI:%BUS%"</span></span> EndSection</code> </pre> <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xorg-device-advanced.conf Section <span class="hljs-string"><span class="hljs-string">"Device"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"AMD %ID%"</span></span> Driver <span class="hljs-string"><span class="hljs-string">"radeon"</span></span> Option <span class="hljs-string"><span class="hljs-string">"AccelMethod"</span></span> <span class="hljs-string"><span class="hljs-string">"exa"</span></span> BusID <span class="hljs-string"><span class="hljs-string">"PCI:%BUS%"</span></span> EndSection</code> </pre> <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xorg-device-nvidia.conf Section <span class="hljs-string"><span class="hljs-string">"Device"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"nVidia %ID%"</span></span> Driver <span class="hljs-string"><span class="hljs-string">"nouveau"</span></span> Option <span class="hljs-string"><span class="hljs-string">"AccelMethod"</span></span> <span class="hljs-string"><span class="hljs-string">"exa"</span></span> BusID <span class="hljs-string"><span class="hljs-string">"PCI:%BUS%"</span></span> EndSection</code> </pre> <br><br>  Add your templates and do not forget to install drivers for these devices.  Specify in the comments proven combinations. <br></div></div><br>  At the end of the xorg configuration, we will do the ‚ÄúWindows like‚Äù switch of the keyboard layout with the Alt + Shift combination: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/X11/xorg.conf.d/50-keyboard.conf Section <span class="hljs-string"><span class="hljs-string">"InputClass"</span></span> Identifier <span class="hljs-string"><span class="hljs-string">"keyboard-layout"</span></span> MatchIsKeyboard <span class="hljs-string"><span class="hljs-string">"on"</span></span> Option <span class="hljs-string"><span class="hljs-string">"XkbLayout"</span></span> <span class="hljs-string"><span class="hljs-string">"us,ru"</span></span> Option <span class="hljs-string"><span class="hljs-string">"XkbVariant"</span></span> <span class="hljs-string"><span class="hljs-string">",winkeys"</span></span> Option <span class="hljs-string"><span class="hljs-string">"XkbOptions"</span></span> <span class="hljs-string"><span class="hljs-string">"grp:alt_shift_toggle"</span></span> EndSection</code> </pre> <br><br><h2>  We optimize the system </h2><br>  <b>Logs of work of</b> all components of Archlinux are saved in the <a href="https://wiki.archlinux.org/index.php/Systemd">log</a> .  If everything is left as it is, the journal can be quite inflated, so we will limit its size, say 30 MB (add or uncomment the line): <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/journald.conf ... SystemMaxUse=30M ...</code> </pre> <br>  Each action is logged in the / var / log / journal folder.  In our case, the data transfer is carried out over the network, which in practice has a low bandwidth.  You can delete the folder with the magazine, it will only be saved in RAM, which is ideal for a diskless client: <br><br><pre> <code class="bash hljs">rm -r <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/journal</code> </pre> <br>  With various errors in the operation of applications, automatic <b>kernel dumps</b> are created in the / var / lib / systemd / coredump folder.  We will turn them off for the same reason: <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/systemd/coredump.conf ... Storage=none ...</code> </pre> <br><br>  Disable <b>SWAP</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -e <span class="hljs-string"><span class="hljs-string">'vm.swappiness=0\nvm.vfs_cache_pressure=50'</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/sysctl.d/99-sysctl.conf</code> </pre> <br><br>  Remove unnecessary <b>localization</b> .  This simple action will save over 65 MB.  At the same time, let's see how programs are installed from <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository">AUR</a> (in fact, they are built from source).  Log on to the boot server with standard user rights and follow these steps: <br><pre> <code class="bash hljs">curl -o localepurge.tar.gz https://aur.archlinux.org/packages/lo/localepurge/localepurge.tar.gz tar -xvvzf localepurge.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> localepurge makepkg -s</code> </pre> <br>  Package is ready.  Install it from the file, not from the repository, so the S key is replaced with U (correct the file name if the version of the program you have compiled does not match mine): <br><pre> <code class="bash hljs">sudo pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -U localepurge-0.7.3.4-1-any.pkg.tar.xz</code> </pre> <br>  Now set up.  Comment out the ‚ÄúNEEDCONFIGFIRST‚Äù line at the beginning of the file and indicate the localizations used at the very end: <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/locale.nopurge ... <span class="hljs-comment"><span class="hljs-comment"># NEEDSCONFIGFIRST ... ru ru_RU ru_RU.UTF-8 en en_US en_US.UTF-8</span></span></code> </pre> <br>  Configure and run the program: <br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> /usr/bin/localepurge-config arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> localepurge</code> </pre> <br><br><h2>  Go to read-only </h2><br>  If we try to load the existing system on several computers at the same time, then all copies will change the same folders on the server.  If one client deletes a file, it will suddenly disappear from the other.  The surest way to guard against change is to go into read-only mode. <br><br>  The problem is that for the normal operation of the system, it is necessary to write data to some folders.  The solution on the surface ‚Äî connecting these folders via fstab like tmpfs ‚Äî is great for / var / log, for example.  But what to do, for example, with the / etc directory, because our udev rule changes files there, and other programs work with it actively?  You can save information somewhere before mounting, and then rewrite it back.  Or immediately move everything somewhere else, and then return.  One thing is clear: you have to test for a long time and monitor the operation of the system in order to understand what other folders to make available for recording, or to set up all the programs so that they leave the products of their livelihoods strictly in the space provided.  Too tricky.  I propose to deploy the entire system in RAM.  It remains only to pre-rewrite into it all the most necessary for work. <br><br>  There is one folder in which nothing is recorded during the work, if we do not install anything - this is / usr.  If you mount it at a later stage in initramfs with read-only access, then Firefox‚Äôs work will not be affected in any way.  Be sure to compare the size of the / usr directory with the size of everything else, and it turns out that there will be not much to copy, and if you exclude everything that is superfluous ... Did you also think about <a href="https://wiki.archlinux.org/index.php/Rsync">rsync</a> ? <br><br><h3>  Redoing the file system on the fly </h3><br>  Install rsync on the client: <br><br><pre> <code class="bash hljs">pacman -S rsync</code> </pre> <br>  Copying is to be done at the stage of intramfs, therefore, we need a new handler, let's call it ‚Äúlive‚Äù.  First, we will save all the necessary mount parameters for the original root directory by analyzing the / etc / fstab file using the findmnt utility.  Then unmount the root directory from the / new_root folder, where it is always located inside the initramfs.  In its place, create a ramfs with the ability to write and prepare a mount point / srv / new_root, where we will return the original root directory.  All that is needed is to rewrite all the most needed files and directories, with the exception of the / usr folder, which we will read in read-only mode.  Copies of files in ramfs will be available for reading and writing. <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/hooks/live</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">cat $ root / etc / initcpio / hooks / live</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/bash run_latehook() { local source options fstype local target="/" local fstab=/new_root/etc/fstab local place=/new_root/srv/new_root local filter=${place}/etc/default/live_filter if source=$(findmnt -snero source --tab-file=$fstab -T $target); then options=$(findmnt -snero options --tab-file=$fstab -T $target) fstype=$(findmnt -snero fstype --tab-file=$fstab -T $target) umount /new_root mount -t ramfs none /new_root -o rw,defaults [ ! -d "$place" ] &amp;&amp; mkdir -p $place mount ${fstype:+-t ${fstype}} ${options:+-o ${options}} $source $place mount -o remount,ro${options:+-,${options}} $source $place rsync -aAX ${place}/* /new_root --filter="merge $filter" ! findmnt -snero source --tab-file=$fstab -T /usr &amp;&amp; bind_usr $place #     "/"   , #      fstab cat ${place}/etc/fstab | grep -v $source &gt; $fstab fi } bind_usr(){ local place=$1 mount --bind ${place}/usr /new_root/usr mount -o remount,ro,bind ${place}/usr /new_root/usr }</span></span></code> </pre> <br></div></div><br>  We refer to the file / etc / fstab twice: the first time we get information on the mount parameters of the root directory, and the second time we check if there is any information on / usr in fstab.  For late mounting of / usr in Archlinux there is a special usr handler, which we will not interfere with doing our work.  If / usr is mounted in some special way, then our handler skips it. <br><br>  The text mentions the / etc / default / live_filter file with filtering rules intended for rsync, we need to remember to prepare it.  We do this automatically from the handler installer: <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/install/live <span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/bash build() { make_filter &gt; /etc/default/live_filter add_binary "/usr/bin/rsync" "/bin/rsync" add_binary findmnt add_runscript } make_filter() { cat &lt;&lt;EOF + /etc/* + /home/* + /home/*/.config - /home/*/*/ + /var/* - /var/cache/*/* - /var/lib/pacman/*/* - /var/lib/systemd/*/* + /var/log/*/ - /var/log/* - /var/tmp/* - /*/* EOF }</span></span></code> </pre> <br>  Rsync "does not see" more than one directory.  Files and folders in the directory are checked by each rule in order to the first match ("+" - the object is copied, "-" - the object is not copied).  If there is no match, the file is copied, and the directory is created empty.  Next, rsync enters the "surviving" directory and again applies the rules to its contents.  This is repeated until there is absolutely nothing left. <br><br>  In our case, the root directory does not fall under any rule, so its structure is completely transferred (all files are copied and empty directories are created).  The directories / boot, / dev, / lost + found, / mnt, / opt, / proc, / root, / run, / srv, / sys, / tmp fall under the effect of the last rule "- / * / *", m. e.  none of their contents is copied anywhere, but they themselves are created.  The / etc directory immediately falls under the "+ / etc / *" rule, and all its contents are copied, but first only within one directory (later on, its entire structure will be transferred in order, because for the nesting levels / etc / * / and then there are no rules).  A similar beginning is waiting for the directory / home - folders of all users fall under the rule "+ / home / *" and will be recreated in a copy (empty for now).  The following rule "+ /home/*/.config" copies the .config directories that are attached to the home folders of each user, and "- / home / * / * /" excludes all other directories (the rule comes after the "rescue", so for /home/*/.config does not work).  About the files themselves from the home directory says nothing, so they are completely transferred.  Files from excluded subdirectories are not copied, because these directories were not created.  The "- / var / cache / * / *" rule retains the entire directory structure in / var / cache, but their contents are not migrated.  The remaining rules are similar. <br><br><div class="spoiler">  <b class="spoiler_title">Remarks</b> <div class="spoiler_text">  You can change the rsync rules in the external / etc / default / live_filter file as you like, without having to re-create the initramfs.  I would be glad to see your version of the rules in the comments. <br><br>  There are a lot of opportunities for rsync (man rsync - almost 3000 lines).  In the comments, suggest some exotic way to use rsync inside initramfs? <br><br>  Theoretically, rsync can be replaced with some kind of torrent, and build the root file system with it. </div></div><br>  Add a handler to the initramfs: <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.conf ... HOOKS=<span class="hljs-string"><span class="hljs-string">"base udev net_nfs4 live"</span></span></code> </pre> <br>  Generate initramfs: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> mkinitcpio -p habr</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">nfs4 + live</b> <div class="spoiler_text">  The server and client work in VirtualBox. <br>  Source File System: <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab <span class="hljs-comment"><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; 192.168.1.100:/diskless / nfs4 defaults,noatime 0 0</span></span></code> </pre> <br>  The state of the file system on the downloaded client after the execution of the live processor: <br><br><pre> <code class="bash hljs">mount ... none on / <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ramfs (rw,relatime) 192.168.1.100://diskless on /srv/new_root <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> nfs4 (ro,noatime,vers=4.1,rsize=131072,wsize=131072,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.1.131,local_lock=none,addr=192.168.1.100) 192.168.1.100://diskless/usr on /usr <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> nfs4 (ro,noatime,vers=4.1,rsize=131072,wsize=131072,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.1.131,local_lock=none,addr=192.168.1.100) ...</code> </pre> <br>  During client download, the following data was collected on the server: <br><br><pre> <code class="bash hljs">vnstat -l ... eth0 / traffic statistics rx | tx --------------------------------------+------------------ bytes 7,23 MiB | 252,33 MiB --------------------------------------+------------------ max 5,11 Mbit/s | 235,23 Mbit/s average 1,48 Mbit/s | 51,68 Mbit/s min 0 kbit/s | 1 kbit/s --------------------------------------+------------------ packets 82060 | 199036 --------------------------------------+------------------ max 6550 p/s | 21385 p/s average 2051 p/s | 4975 p/s min 0 p/s | 0 p/s --------------------------------------+------------------ time 40 seconds</code> </pre> <br></div></div><br><br><h3>  We overclock the network </h3><br>  Physically, of course, network overclocking is now impossible without changing equipment, but software optimizations are not prohibited.  We need to transfer the contents of the associated / usr folder over the network.  We are not able to send this data, but we are able to reduce the amount of space they occupy - to archive.   ,    ‚Äî ,             . <br><br>   squashfs          fstab,    .      ‚Äî      (  ) ‚Äî     : <br><br><pre> <code class="bash hljs">pacman -S squashfs-tools &amp;&amp; mksquashfs <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/usr <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/srv/source_usr.sfs -b 4096 -comp xz</code> </pre> <br><br>   : <br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab <span class="hljs-comment"><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; 192.168.1.100:/diskless / nfs4 defaults,noatime 0 0 /srv/new_root/srv/source_usr.sfs /usr squashfs loop,compress=xz 0 0</span></span></code> </pre> <br>     initramfs   /usr   usr,    : <br><br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/{usr/lib,etc}/initcpio/install/usr &amp;&amp; cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/{usr/lib,etc}/initcpio/hooks/usr</code> </pre> <br> ,     : <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/hooks/usr mount <span class="hljs-string"><span class="hljs-string">"/new_root</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$usr_source</span></span></span><span class="hljs-string">"</span></span> /new_root/usr -o <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$mountopts</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title">   usr?</b> <div class="spoiler_text">     ¬´file system¬ª   fstab   "/new_root/srv/new_root/usr/source_usr.sfs".    systemd      ,       .  /new_root c      initrams,  systemd  .      ,     . </div></div><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.conf HOOKS=<span class="hljs-string"><span class="hljs-string">"base udev net_nfs4 live usr"</span></span> arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> mkinitcpio -p habr</code> </pre> <br><div class="spoiler"> <b class="spoiler_title">nfs4+live+squashed /usr</b> <div class="spoiler_text">   : <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab <span class="hljs-comment"><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; 192.168.1.100:/diskless / nfs4 defaults,noatime 0 0 /srv/new_root/srv/source_usr.sfs /usr squashfs ro,loop,compress=xz 0 0</span></span></code> </pre> <br>          live  usr: <br><br><pre> <code class="bash hljs">mount ... none on / <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ramfs (rw,relatime) 192.168.1.100://diskless on /srv/new_root <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> nfs4 (ro,noatime,vers=4.1,rsize=131072,wsize=131072,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.1.131,local_lock=none,addr=192.168.1.100) /srv/new_root/srv/source_usr.sfs on /usr <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> squashfs (ro,relatime) ...</code> </pre> <br>          : <br><br><pre> <code class="bash hljs">vnstat -l ... eth0 / traffic statistics rx | tx --------------------------------------+------------------ bytes 5,07 MiB | 205,67 MiB --------------------------------------+------------------ max 4,02 Mbit/s | 191,82 Mbit/s average 1,04 Mbit/s | 42,12 Mbit/s min 0 kbit/s | 1 kbit/s --------------------------------------+------------------ packets 65524 | 159941 --------------------------------------+------------------ max 5954 p/s | 17170 p/s average 1638 p/s | 3998 p/s min 0 p/s | 0 p/s --------------------------------------+------------------ time 40 seconds</code> </pre><br></div></div><br><br>      20% ,    .        ,   live   ramfs        . <br><br>    /srv/source_usr.sfs  ramfs     rsync,      fstab   , ,       RAM,     . <br><br><h3>  We remove too much </h3><br>    <a href="https://wiki.archlinux.org/index.php/Diskless_system"></a> ,      : ¬´      ?¬ª. , ,   squashfs  NFS (   ),      <a href="http://en.wikipedia.org/wiki/Network_block_device">Network Block Device</a> ,        .   ¬´ ¬ª,   ¬´ ¬ª,            .        btrfs   zlib,       squashfs  . <br><br>   initramfs     NBD-      AUR  mkinitcpio-nbd (       ): <br><br><pre> <code class="bash hljs">curl -o mkinitcpio-nbd.tar.gz https://aur.archlinux.org/packages/mk/mkinitcpio-nbd/mkinitcpio-nbd.tar.gz tar -xvvzf mkinitcpio-nbd.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> mkinitcpio-nbd makepkg -s sudo pacman --root <span class="hljs-variable"><span class="hljs-variable">$root</span></span> --dbpath <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/var/lib/pacman -U mkinitcpio-nbd-0.4.2-1-any.pkg.tar.xz</code> </pre> <br><br>     $root/boot/grub/grub.cfg   : <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot/grub/grub.cfg menuentry <span class="hljs-string"><span class="hljs-string">"NBD"</span></span> { load_video <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gfxpayload=keep insmod gzio <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" ..."</span></span> linux vmlinuz-linux \ add_efi_memmap \ ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_ip</span></span></span><span class="hljs-string">"</span></span>:<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_server</span></span></span><span class="hljs-string">"</span></span>:192.168.1.1:255.255.255.0::eth0:none \ nbd_host=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_server</span></span></span><span class="hljs-string">"</span></span> nbd_name=habrahabr root=/dev/nbd0 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"  ..."</span></span> initrd initramfs-linux.img }</code> </pre> <br>  ,    : <br><br><pre> <code class="bash hljs">nbd_host=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$net_default_server</span></span></span><span class="hljs-string">"</span></span> nbd_name=habrahabr root=/dev/nbd0</code> </pre> <br>    NBD         /dev/nbd0,        : <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab <span class="hljs-comment"><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; /dev/nbd0 / squashfs ro,loop,compress=xz 0 0</span></span></code> </pre> <br><br>    NBD     (   ).   NBD    ,        ,    ¬´¬ª      .         NBD ,   ,          .      NBD   IP   netcat  ,     ,    IP : <br><br><pre> <code class="bash hljs">cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/{usr/lib,etc}/initcpio/install/nbd cp <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/{usr/lib,etc}/initcpio/hooks/nbd</code> </pre> <br>     .     : <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/initcpio/hooks/nbd modprobe nbd <span class="hljs-comment"><span class="hljs-comment">#     msg "closing old connections..." echo ${ip} | nc ${nbd_host} 45678 local ready=$(nc -l -p 45678) [ "$ready" -ne 1 ] &amp;&amp; reboot msg "connecting..." #    </span></span></code> </pre> <br>  initramfs  -    net_nfs4,    nbd: <br><br><pre> <code class="bash hljs">nano <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/mkinitcpio.conf MODULES=<span class="hljs-string"><span class="hljs-string">"loop squashfs"</span></span> HOOKS=<span class="hljs-string"><span class="hljs-string">"base udev net_nfs4 keyboard nbd live"</span></span></code> </pre> <br>  initramfs: <br><br><pre> <code class="bash hljs">arch-chroot <span class="hljs-variable"><span class="hljs-variable">$root</span></span> mkinitcpio -p habr</code> </pre> <br>         $root/srv/source_usr.sfs   $root ‚Äî      /usr  ,   /usr: <br><br><pre> <code class="bash hljs">mksquashfs <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/* /srv/new_root.sfs -b 4096 -comp xz</code> </pre> <br>     <br><br>  : <br><pre> <code class="bash hljs">pacman -S nbd</code> </pre> <br>  NBD : <br><br><pre> <code class="bash hljs">mv /etc/nbd-server/{config,config.old} &amp;&amp; nano /etc/nbd-server/config [generic] user = nbd group = nbd [habrahabr] exportname = /srv/new_root.sfs timeout = 30 <span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> multifile = <span class="hljs-literal"><span class="hljs-literal">false</span></span> copyonwrite = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>   .      habrahabr,    ,   ,    ¬´  ¬ª,       copyonwrite   . Copyonwrite          ,       ,         .        .     .   NBD     ,  man' . <br><br>    ,        : <br><br><pre> <code class="bash hljs">nano /etc/default/close_passive_NBD_connections.sh <span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #      PID _kill(){ local PID for PID in $* do kill $PID done } main(){ local rIP PIDs #       ip     grub.cfg rIP=$(netcat -l -p 45678 | cut -d: -f1) #     IP     PID PIDs=$(netstat -np | grep $rIP | awk '/^tcp.*nbd-server/{split($NF,a,"/");print a[1]}') _kill $PIDs &amp;&amp; echo "1" | netcat -z $rIP 45678 } #     while [ 0 ] do main done</span></span></code> </pre> <br>   : <br><br><pre> <code class="bash hljs">chmod +x /etc/default/close_passive_NBD_connections.sh</code> </pre> <br>  ,     netcat  netstat: <br><br><pre> <code class="bash hljs">pacman -S gnu-netcat net-tools</code> </pre> <br>    NBD: <br><br><pre> <code class="bash hljs">mkdir -p /etc/systemd/system/nbd.service.d &amp;&amp; nano /etc/systemd/system/nbd.service.d/close_passive.conf [Service] Type=oneshot ExecStart=/etc/default/close_passive_NBD_connections.sh</code> </pre> <br> ,     ,       . <br><br><div class="spoiler"> <b class="spoiler_title">nbd + squashed live</b> <div class="spoiler_text">   : <br><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$root</span></span>/etc/fstab <span class="hljs-comment"><span class="hljs-comment"># &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt; /dev/nbd0 / squashfs ro,loop,compress=xz 0 0</span></span></code> </pre> <br>          live  usr: <br><br><pre> <code class="bash hljs">mount ... none on / <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ramfs (rw,relatime) /dev/nbd0 on /srv/new_root <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> squashfs (ro,relatime) /dev/nbd0 on /usr <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> squashfs (ro,relatime) ...</code> </pre> <br>          : <br><br><pre> <code class="bash hljs">vnstat -l ... eth0 / traffic statistics rx | tx --------------------------------------+------------------ bytes 1,97 MiB | 198,92 MiB --------------------------------------+------------------ max 2,81 Mbit/s | 138,60 Mbit/s average 575,63 kbit/s | 58,20 Mbit/s min 2 kbit/s | 1 kbit/s --------------------------------------+------------------ packets 32473 | 100874 --------------------------------------+------------------ max 5991 p/s | 7576 p/s average 1159 p/s | 3602 p/s min 4 p/s | 1 p/s --------------------------------------+------------------ time 28 seconds</code> </pre><br></div></div><br>         3%  (  ).      ,    NFS         10 ,     NBD   . <br><br><h2>    </h2><br>    .        ‚Äî TFTP .      ,         <a href="http://ipxe.org/">iPXE</a> ,   <a href="http://habrahabr.ru/users/kvaps/" class="user_link">kvaps</a>     . <br><br>       username. <br><br>        ,         : <br><br><pre> <code class="bash hljs">nano ~/myscript.ipxe <span class="hljs-comment"><span class="hljs-comment">#!ipxe ifopen net0 set server_ip 192.168.1.100 set http_path http://${server_ip} set kern_name vmlinuz-linux kernel ${http_path}/${kern_name} || read void initrd ${http_path}/initramfs-linux.img || read void imgargs ${kern_name} add_efi_memmap ip=${net0/ip}:${server_ip}:${net0/gateway}:${net0/netmask}::eth0:none nbd_host=${server_ip} nbd_name=habrahabr root=/dev/nbd0 || read void boot || read void</span></span></code> </pre> <br>     vmlinuz-linux  initramfs   HTTP.     : <br><br><pre> <code class="bash hljs">sudo pacman -S git &amp;&amp; git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.ipxe.org/ipxe.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ipxe/src/ make bin/undionly.kpxe EMBED=/home/username/myscript.ipxe</code> </pre> <br>   root     : <br><br><pre> <code class="bash hljs">cp {/home/username/ipxe/src/bin,<span class="hljs-variable"><span class="hljs-variable">$root</span></span>/boot}/undionly.kpxe</code> </pre> <br>  DHCP   ,      : <br><br><pre> <code class="bash hljs">nano /etc/dhcpd.conf <span class="hljs-comment"><span class="hljs-comment">#if option architecture = 7 { # filename "/grub/x86_64-efi/core.efi"; # } else { # filename "/grub/i386-pc/core.0"; #} filename "/undionly.kpxe"; systemctl restart dhcpd4</span></span></code> </pre> <br><br>  HTTP : <br><br><pre> <code class="bash hljs">pacman -S apache</code> </pre> <br>        : <br><br><pre> <code class="bash hljs">mount --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /srv/nfs/diskless/boot/ /srv/http/</code> </pre> <br>     ¬´  ¬ª: <br><br><pre> <code class="bash hljs">mount -o remount,ro,<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> /srv/nfs/diskless/boot/ /srv/http/</code> </pre> <br>  : <br><br><pre> <code class="bash hljs">systemctl start httpd</code> </pre> <br><br> ,    : <br><br><pre> <code class="bash hljs">vnstat -l ... rx | tx --------------------------------------+------------------ bytes 1,50 MiB | 206,73 MiB --------------------------------------+------------------ max 2,96 Mbit/s | 191,95 Mbit/s average 684,08 kbit/s | 94,08 Mbit/s min 5 kbit/s | 1 kbit/s --------------------------------------+------------------ packets 22762 | 90737 --------------------------------------+------------------ max 5735 p/s | 9871 p/s average 1264 p/s | 5040 p/s min 3 p/s | 1 p/s --------------------------------------+------------------ time 18 seconds</code> </pre> <br><br>       TFTP  HTTP          iPXE. , <a href="https://releng.archlinux.org/pxeboot/"></a> ,                        . ,            . <br><br><h2>  We return to the server </h2><br>    live    .   rsync    /srv,      .          systemd: <br><br><pre> <code class="bash hljs">nano /etc/fstab LABEL=HABR / ext4 rw,relatime,data=ordered 0 1 /srv/new_root/srv /srv none <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 0 1</code> </pre> <br>     /srv/new_root/srv  /srv         ,    . <br><br>  ,        ¬´  ¬ª,     ,    USB .      ,     .      ,     . ,    VPN ,       ‚Ä¶ <br><br>      (      ),         VirtualBox (  &gt;  USB     ).       lsblk,    <a href="http://habrahabr.ru/post/253256/"> </a> .    ,      HABR    /mnt. <br><br>       rsync: <br><br><pre> <code class="bash hljs">nano /root/clone_filter + /boot/* + /etc/* + /home/* + /srv/* + /usr/* + /var/* - /*/*</code> </pre> <br>   : <br><br><pre> <code class="bash hljs">rsync -aAXv /* /mnt --filter=<span class="hljs-string"><span class="hljs-string">"merge /root/clone_filter"</span></span></code> </pre> <br>     ‚Äî /dev/sdb <br><pre> <code class="bash hljs"> arch-chroot /mnt grub-install --target=i386-pc --force --recheck /dev/sdb</code> </pre> <br>   /mnt     . <br><br> PS      .            .          .                . <br><br>    . </div><p>Source: <a href="https://habr.com/ru/post/254415/">https://habr.com/ru/post/254415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254399/index.html">Top 10 myths of cloud technologies according to Gartner</a></li>
<li><a href="../254403/index.html">SaltStack: Pre-generation of passwords for use in services</a></li>
<li><a href="../254407/index.html">White paper on the availability of PhoneGap</a></li>
<li><a href="../254409/index.html">Payler 2.0 - work on the creation of a new site</a></li>
<li><a href="../254413/index.html">Grid, Data Grouping and OData</a></li>
<li><a href="../254417/index.html">How to get a neighbor or Karaoke on GStreamer</a></li>
<li><a href="../254419/index.html">Assembler for simulation tasks. Part 1: guest assembler</a></li>
<li><a href="../254423/index.html">How to create and earn SaaS | Part 17 | Personal data and medical secrets in the cloud</a></li>
<li><a href="../254425/index.html">JSONB requests in PostgreSQL</a></li>
<li><a href="../254429/index.html">Driver packs and their indices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>