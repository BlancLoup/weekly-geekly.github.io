<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple container</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yes, you understood correctly, this is an article about another bike - about my Dependency Injection (DI) container. It is already 2015 outside the wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple container</h1><div class="post__text post__text-html js-mediator-article">  Yes, you understood correctly, this is an article about another bike - about my <a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> (DI) container.  It is already 2015 outside the window, and there are a lot of different containers for every taste and color.  Why might need another one? <br><br>  Firstly, it can simply form by itself!  We in <a href="http://www.e-kontur.ru/">Elba</a> used <a href="https://code.google.com/p/robo-container">this container for</a> quite a long time, and some of the ideas described in the article (Factory Injection, Generics Inferring, Configurators) were initially implemented on top of it through a public API. <br><br>  Secondly, for a large project, the DI-container is an essential part of the infrastructure, which largely determines the organization of the code.  A simple, flexible and easily modified container often allows you to find an elegant solution to a specific problem, to avoid the coherence of individual components, verbose and patterned application code.  When solving a specific task, you can derive some pattern, implement it at the container level and then reuse it in other tasks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thirdly, a DI container is a relatively simple thing.  It is very well designed to develop in <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> mode, due to which it becomes fun and enjoyable to do it. <br><br>  This article is not an introduction to DI.  On this subject there are many other excellent publications, including on Habr√©.  Rather, here is a set of recipes for cooking DI, so that the resulting dish was tasty, but not spicy.  If you have a DI-container in production or you have written your own best container, then this is a great place for holivars about whose container is better! <br><a name="habracut"></a><br><h2>  Motivation and Api </h2><br>  The main message of the container is <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">Convention Over Configuration</a> .  What is the point of torturing the user by requiring him to explicitly indicate the interface's compliance with the implementation, if that interface has only one implementation available?  Why not just substitute it, saving time to solve more important issues?  As it turned out, a similar principle applies in many other situations.  What, for example, could a container substitute in a constructor parameter of type IEnumerable or Func to bring the greatest benefit?  We will talk about this a little later. <br><br>  Container code was written exclusively for specific practical tasks.  This allowed us to concentrate on a small number of the most useful features and to ignore all the rest.  For example, a container supports only one lifestyle - singletone.  This means that instances of all classes are created on demand and stored in the internal cache of the container until it is destroyed.  The container implements IDisposable, re-invoking Dispose on its supporting cached objects.  The order of calling Dispose on different services is determined by the dependencies between them: if service A depends on service B, then Dispose on A will be called before Dispose on B. To create a tree of services for a while and then destroy it, you can use the Clone method on the container.  It returns a new container with the same configuration as the original container, but with an empty instance cache. <br><br>  The main container methods are Resolve and BuildUp.  The first returns an instance by type using constructor injection, the second uses property injection to initialize an already created object.  The BuildUp method <a href="http://martinfowler.com/articles/injection.html">makes sense to</a> use only if the application Resolve <a href="http://stackoverflow.com/questions/589374/how-to-use-dependency-injection-with-asp-net-web-forms">difficult</a> . <br><br>  Given that the container makes many decisions on its own, for debugging purposes, it supports the GetConstructionLog method.  Using it, you can get a description of the creation process for any service at any time.  This description is a tree whose leaves are either services that do not have constructor parameters, or specific primitive values ‚Äã‚Äãsuggested to the container via the configuration API. <br><br><h2>  Sequence injection </h2><br>  This is the simplest and at the same time quite powerful technique: if the class in the constructor parameter accepts an array or IEnumerable, then the container will substitute in this parameter all the suitable implementations that it can find.  In its further work, a class can at any moment select a certain implementation from the list and delegate to it a part of its functions.  Or, for example, to inform all realizations about the occurrence of a specific event. <br><br>  Consider an example.  Suppose we need to raise the http-server that serves some fixed set of addresses.  A separate block of code that is conveniently presented with this interface is responsible for processing each address: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IHttpHandler</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UrlPrefix { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Then the dispatching logic of the request-handler can be very simply expressed as follows: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HttpDispatcher</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;IHttpHandler&gt; handlers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpDispatcher</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;IHttpHandler&gt; handlers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handlers = handlers; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context</span></span></span><span class="hljs-function">)</span></span> { handlers.Single(h =&gt; context.Url.StartsWith(h.Prefix)).Handle(context); } }</code> </pre><br>  The container finds all available IHttpHandler implementations, creates one instance of each of them, and substitutes the resulting list in the handlers parameter.  Note that to add a new handler, simply create a new class that implements IHttpHandler ‚Äî the container will find it itself and pass it to the HttpDispatcher constructor.  This is quite easy to achieve <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258F%25D0%25B7%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">SRP</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8/%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">OCP</a> compliance. <br><br>  Another use of Sequence Injection is event notification: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDatabase database; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IEnumerable&lt;IUserDeletedHandler&gt; handlers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserService</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDatabase database, IEnumerable&lt;IUserDeletedHandler&gt; handlers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.database = database; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handlers = handlers; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid userId</span></span></span><span class="hljs-function">)</span></span> { database.DeleteUser(userId); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> handlers) handler.OnUserDeleted(userId); } }</code> </pre><br>  Deleting a user can affect a number of system components.  For example, some of them may have entities that refer to a remote user.  To handle this situation correctly, it is enough for such a component to simply implement the IUserDeletedHandler interface.  At the same time, if a new such component or entity appears, there is no need to edit the UserService code - it is enough, in accordance with <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8/%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">OCP</a> , to simply add the IUserDeletedHandler handler. <br><br><h2>  Factory Injection </h2><br>  Sometimes you need to create a new instance of the service.  There may be various reasons for this.  An obvious example is that a service in the constructor takes a parameter whose value becomes known only at the execution stage.  Or, perhaps, the service should be recreated for some architectural reasons.  For example, the DataContext class from the standard ORM Linq2Sql is recommended to recreate for each http request, since  otherwise it starts eating too much memory.  In any case, you can act like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Calculator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SomeService someService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SomeService someService, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> factor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.someService = someService; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.factor = factor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someService.SomeComplexCalculation() * factor; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Client</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, Calculator&gt; createCalculator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Client</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Calculator&gt; createCalculator</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createCalculator = createCalculator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance = createCalculator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { factor = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance.Calculate(); } }</code> </pre><br>  The mechanics of creation is implemented through the delegate accepted in the constructor.  This delegate is generated by the container in such a way that when it is called, a new Calculator instance will always be created.  Through an object-argument, using an anonymous type, you can pass the parameters of the created service.  Matching of parameters occurs by name - a member of the anonymous type factor falls into the factor parameter of the Calculator constructor.  The constructor parameter someService does not specify a value in the anonymous type, so the container will follow standard rules when it is received. <br><br>  The main disadvantage here is that checking the name / type of parameters is postponed from the compilation stage to the execution stage.  Similar to the dynamic keyword, this requires separate attention when adding / removing / renaming parameters and additional integration tests.  However, in practice this does not lead to significant problems.  Mainly due to the fact that the use of Factory Injection is not very common.  In our projects there are only a few pieces of code in the entire base of thousands of classes of such situations.  Secondly, even in these cases, errors with parameter passing are usually very simple and easily detected - when a delegate is invoked, the container does parameter checking in the same way as the compiler does when compiling. <br><br><h2>  Generics Inferring </h2><br>  Quite often, the container itself can choose not only the interface implementation, but also generic arguments.  For example, consider the simple message bus interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBus</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Publish&lt;TMessage&gt;(TMessage message); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action); }</code> </pre><br>  Through IBus, you can post messages and subscribe to process them.  The mechanics of message delivery are not important here, but usually this or that queue system (RabbitMQ, MSMQ, etc.).  A specific message handler is conveniently presented with this interface: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IHandleMessage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMessage</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TMessage message)</span></span></span></span>; }</code> </pre><br>  To handle a new message type, you simply implement IHandleMessage with the corresponding generic argument: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRegistered</span></span></span><span class="hljs-class"> {</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRegisteredHandler</span></span></span><span class="hljs-class"> :</span></span> IHandleMessage&lt;UserRegistered&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserRegistered message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//whatever } }</span></span></code> </pre><br>  Now we need to call Subscribe for each implementation of IHandleMessage.  Make it easy for a specific IHandleMessage: <br><br><pre> <code class="hljs ruby">public static <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageHandlerHelper</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscribeHandler</span></span></span><span class="hljs-class">&lt;TMessage&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBus</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bus</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IHandleMessage</span></span></span><span class="hljs-class">&lt;TMessage&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bus</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-class">&lt;TMessage&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle</span></span></span><span class="hljs-class">);</span></span> } }</code> </pre><br>  But with what generic argument should we call the SubscribeHandler method?  And where to get all such valid arguments and corresponding implementations of IHandleMessage?  Ideally, I would like to reduce the situation to, for example, from Sequence Injection, just injecting an IEnumerable from something, thereby instructing the container to search for all implementations of IHandleMessage. <br><br>  To do this, let's move the generic argument from the method level to the class level, and hide what we have behind the non-generic interface: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMessageHandlerWrap</span></span></span><span class="hljs-class"> </span></span>{ void Subscribe(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageHandlerWrap</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TMessage</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IMessageHandlerWrap { private readonly IHandleMessage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TMessage</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBus</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bus</span></span></span><span class="hljs-class">; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageHandlerWrap</span></span></span></span>(IHandleMessage&lt;TMessage&gt; handler, IBus bus) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handler = handler; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bus = bus; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void Subscribe() { bus.Subscribe&lt;TMessage&gt;(handler.Handle); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessagingHost</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly IEnumerable&lt;IMessageHandlerWrap&gt; handlers; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MessagingHost(IEnumerable&lt;IMessageHandlerWrap&gt; handlers) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handlers = handlers; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void Subscribe() { foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> handlers) handler.Subscribe(); } }</code> </pre><br>  How it works?  To create a MessagingHost container, you need to get all the implementations of IMessageHandlerWrap.  There is only one class that implements this interface - MessageHandlerWrap &lt;TMessage&gt;, but to create it, you need to specify the specific value of the generic argument.  To do this, the container considers the parameter of the IHandleMessage &lt;TMessage&gt; type constructor - the existence of a suitable IHandleMessage &lt;X&gt; implementation is a necessary condition for creating a MessageHandlerWrap &lt;X&gt;.  For IHandleMessage &lt;TMessage&gt;, there is an implementation ‚Äî this is the UserRegisteredHandler class, which closes IHandleMessage through UserRegistered.  Thus, the container will substitute an instance of MessageHandlerWrap &lt;UserRegistered&gt; into the handlers MessagingHost parameter. <br><br>  This option of closing generics is based on dependency analysis.  The above reasoning chain easily extends to the case of an arbitrary number of generic arguments and an arbitrary nesting of some generic services into others.  The current container implementation correctly handles these common cases. <br><br>  Another option for closing generics is based on generic constraints.  It can be useful in cases where the generic service has no generic dependencies.  In the example from Sequence Injection, let the user-dependent entities implement the following interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IUserEntity</span></span> { Guid UserId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br>  Then, to delete all such entities, a single generic handler is enough: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DeleteDependenciesWhenUserDeleted&lt;TEntity&gt;: IUserDeletedHandler <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEntity : IUserEntity { private readonly IDatabase <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> DeleteDependenciesWhenUserDeleted(IDatabase <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) { this.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> OnDeleted(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> entity) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>&lt;TEntity&gt;(x =&gt; x.UserId == entity.id)) <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span>(child); } }</code> </pre><br>  The container will create one instance of DeleteDependenciesWhenUserDeleted for each of the classes that implement IUserEntity. <br><br><h2>  Configurators </h2><br>  The container provides a configuration API through which you can tell him how to behave in a certain situation: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface INumbersProvider { IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ReadAll(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProvider</span></span></span><span class="hljs-class"> :</span></span> INumbersProvider { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> fileName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileNumbersProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileName = fileName; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ReadAll() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> File.ReadAllLines(fileName).Select(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse).ToArray(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;FileNumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext context, ServiceConfigurationBuilder&lt;FileNumbersProvider&gt; builder)</span></span></span><span class="hljs-function"> </span></span>{ builder.Dependencies(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { fileName = <span class="hljs-string"><span class="hljs-string">"numbers.txt"</span></span> }); } }</code> </pre><br>  Here, using the Dependencies method, we specify the specific value of the constructor parameter.  As in Factory Injection, the binding occurs by the name of the parameter. When the container is created, it scans the assemblies passed to it and calls the Configure method on all found IServiceConfigurator implementations.  By convention, the X class configuration must be in the XConfigurator class located in the Configuration folder of the same assembly, although this is not required.  In addition to the constructor parameters, using the ServiceConfigurationBuilder methods, you can select a specific interface implementation or, for example, specify the delegate that the container should use to create the class: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogConfigurator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IServiceConfigurator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILog</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void <span class="hljs-type"><span class="hljs-type">Configure</span></span>(<span class="hljs-type"><span class="hljs-type">ConfigurationContext</span></span> context, <span class="hljs-type"><span class="hljs-type">ServiceConfigurationBuilder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">ILog</span></span>&gt; builder) { builder.<span class="hljs-type"><span class="hljs-type">Bind</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.target == null ? <span class="hljs-type"><span class="hljs-type">LogManager</span></span>.<span class="hljs-type"><span class="hljs-type">GetLogger</span></span>(<span class="hljs-string"><span class="hljs-string">"root"</span></span>) : <span class="hljs-type"><span class="hljs-type">LogManager</span></span>.<span class="hljs-type"><span class="hljs-type">GetLogger</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.target)); } }</code> </pre><br>  The parameter for this delegate contains a target property ‚Äî the type of ILog client class being created.  This type will be null if there is no client, i.e.  The Resolve () method on the container was called. <br><br>  Hardcoding the concrete values ‚Äã‚Äãof the parameters of the constructor in the code may seem to some people a dubious solution.  In practice, however, most of the settings (cache size, queue length, timeout values, tcp port numbers) change extremely rarely.  They are tightly bound to the code using them.  Their change is a crucial step that requires an understanding of the nuances of the operation of this code and therefore is not much different from changing the code itself. <br><br>  Another atypical solution is to create a separate configurator class for each service.  The main profit from this is a very simple configuration code structure.  This greatly simplifies life.  So, first, to understand exactly how class X is created, it is enough to search for the XConfigurator class with a resharper ‚Äî an action that takes seconds.  Secondly, if you describe the configuration of different services in the same class (modules in Ninject or Autofac, for example), then the likelihood of a landfill is high, because  lines of code that configure different classes are often unrelated to each other.  In a production project with tens of thousands of classes, hundreds of which need to be configured, such a module can become unreadable.  Third, the module abstraction itself is often not obvious - it may not always be possible to simply outline the framework where one module ends and another begins.  Especially thinking about it only for organizing the configuration code seems redundant. <br><br><h4>  PrimaryAssembly </h4><br>  Consider a fairly typical situation: FileNumbersProvider and its configurator from the example above are in some common Class Library Lib.dll and are used in a large number of console applications.  In each of them, FileNumbersProvider works with the file ‚Äúnumbers.txt‚Äù - and this is exactly what you need.  But what if a new console A.exe suddenly appears, in which the file name should be ‚Äúa.txt‚Äù?  You can, of course, remove FileNumbersProviderConfigurator from Lib.dll and unzip it in each of the consoles, indicating the correct value of the file name.  Or, inside the general configurator, read the file name from another settings file (for this, the container provides the Settings method on ConfigurationContext).  But you can do otherwise - just add to A.exe a configurator for FileNumbersProvider with the correct file name.  This will work because the container first starts the configurator from Lib.dll, and then the configurator from A.exe, and the latter interrupts the action of the first.  This startup order is provided by a simple rule: all non-PrimaryAssembly configurators are run before all configurators from PrimaryAssembly.  The specific assembly that should be considered PrimaryAssembly is specified when the container is created. <br><br><h4>  Profiles </h4><br>  Quite often, the way to create a service depends on the environment.  For example, in unit testing mode for INumbersProvider it is natural to use some inmemory implementation, InMemoryNumbersProvider, when running on combat servers, FileNumbersProvider with one file name value, and in manual testing mode with another.  The solution to this problem is the concept of profiles.  A profile is any class that implements the IProfile marker interface exported by the container.  The profile type can be transferred when the container is created, and its current value will be available inside the configurator via the ConfigurationContext.  Usually profiles are used like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryProfile</span></span></span><span class="hljs-class"> :</span></span> IProfile { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegrationProfile</span></span></span><span class="hljs-class"> :</span></span> IProfile { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductionProfile</span></span></span><span class="hljs-class"> :</span></span> IProfile { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;INumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext context, ServiceConfigurationBuilder&lt;INumbersProvider&gt; builder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.ProfileIs&lt;InMemoryProfile&gt;()) builder.Bind&lt;InMemoryNumbersProvider&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> builder.Bind&lt;FileNumbersProvider&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;FileNumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext context, ServiceConfigurationBuilder&lt;FileNumbersProvider&gt; builder)</span></span></span><span class="hljs-function"> </span></span>{ var fileName = context.ProfileIs&lt;ProductionProfile&gt;() ? <span class="hljs-string"><span class="hljs-string">"productionNumbers.txt"</span></span> : <span class="hljs-string"><span class="hljs-string">"integrationNumbers.txt"</span></span>; builder.Dependencies(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { fileName }); } }</code> </pre><br>  Different applications may define their own profile sets, but usually these three are sufficient. <br><br><h2>  Contracts </h2><br>  It has already been mentioned above that, in practice, Factory Injection is rather rarely needed in practice.  Most of the system can usually be described in the form of a service tree whose elements are cached at the container level.  Such a "singleton" model is very convenient for its simplicity.  To use some service to a client class, you just need to accept it in the constructor.  He does not need to worry about how this service will be created and at what point is destroyed - in all of this he can rely on the container. <br><br>  However, quite often the service can be conventionally called a singleton "locally", but not "globally."  A large service tree that implements complex business logic and has some abstraction over its data source among its leaves does not need to be aware that the container will create it in duplicate, substituting one file for this source and other.  Cause and effect here are separated from each other by several levels of abstractions with which this tree operates.  The reason is a specific constructor parameter in some service where, according to the application logic, you need to substitute an instance of a tree with a specific file name.  The consequence is the use of this file name by the corresponding leaves of the tree. <br><br>  The above is usually achieved either by dragging a parameter through the entire tree, or by creating factories that substitute this parameter into the correct elements of the tree.  The container offers a more natural solution: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatCalculator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly FileNumbersProvider numbers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatCalculator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileNumbersProvider numbers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.numbers = numbers; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Average</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numbers.ReadAll().Average(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly StatCalculator historyCalculator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly StatCalculator mainCalculator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([HistoryNumbersContract] StatCalculator historyCalculator, [MainNumbersContract] StatCalculator mainCalculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.historyCalculator = historyCalculator; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mainCalculator = mainCalculator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HistoryAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> historyCalculator.Average(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mainCalculator.Average(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;FileNumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext context, ServiceConfigurationBuilder&lt;FileNumbersProvider&gt; builder)</span></span></span><span class="hljs-function"> </span></span>{ builder.Contract&lt;HistoryNumbersContract&gt;().Dependencies(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { fileName = ‚Äúhistory‚Äù }); builder.Contract&lt;MainNumbersContract&gt;().Dependencies(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { fileName = ‚Äúmain‚Äù }); } }</code> </pre><br>  The attributes [InMemoryNumbersContract] and [FileNumbersContract] must be inherited from the [RequireContractAttribute] provided by the container.  In essence, such an attribute is simply a label with which you can declare some named context.  This declaration can be made at once in several places in the tree, either at the level of the constructor parameter or at the class level.  Determining the contract on the structure is no different from the usual configuration code - the Contract method on the builder returns a new builder, with which you can supply the contract with a certain meaning.  The configuration specified in this way acts on the parameter marked by the atrubite-contract and on all the subtree located under it.  For this, the container automatically creates a new instance of the service, if it substantially depends on the configuration of the current contract.  The process of re-creating instances rises recursively until it reaches a parameter marked with a contract. <br><br>  A service tree may contain several contracts from the root to the leaves.  In this case, if several of these contracts determine the configuration of the same service, then a simple stack rule applies ‚Äî the configuration of the contract closest to the point of use of the service is used.  If some service from the contract-marked subtree does not use the contract configuration, then it is guaranteed that the instance used for it will be exactly the same as if the labels of the contract did not exist.  In other words, if somewhere in another branch of the dependency tree this service meets without a contract, then the same instance of the corresponding class will be used for it. <br><br>  The configuration can be hung on a sequence of contracts: <br><br><pre> <code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProviderConfigurator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IServiceConfigurator</span></span></span><span class="hljs-class">&lt;FileNumbersProvider&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Configure</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurationContext</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfigurationBuilder</span></span></span><span class="hljs-class">&lt;FileNumbersProvider&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builder</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builder</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contract</span></span></span><span class="hljs-class">&lt;HistoryNumbersContractAttribute&gt;() .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contract</span></span></span><span class="hljs-class">&lt;ArchiveContractAttribute&gt;() .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dependencies</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> { "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">archiveHistoryNumbers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">txt</span></span></span><span class="hljs-class">" });</span></span> } }</code> </pre><br>  In this case, ‚ÄúarchiveHistoryNumbers.txt‚Äù will be used only if the sequence of contracts declared on the way from the root contains HistoryNumbersContractAttribute and ArchiveContractAttribute in the specified order. <br><br>  You can also define a contract as combining other contracts: <br><br><pre> <code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNumbersConfigurator</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IContainerConfigurator</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Configure</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurationContext</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContainerConfigurationBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builder</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">builder</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contract</span></span></span><span class="hljs-class">&lt;AllNumbersContractAttribute&gt;() .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Union</span></span></span><span class="hljs-class">&lt;HistoryNumbersContract&gt;() .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Union</span></span></span><span class="hljs-class">&lt;MainNumbersContract&gt;() } }</span></span></code> </pre><br>  The point of such a union is that sometimes it is necessary to process several contexts defined by contracts at once: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StatController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IEnumerable&lt;StatCalculator&gt; statCalculators; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[AllNumbersContract] IEnumerable&lt;StatCalculator&gt; statCalculators</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statCalculators = statCalculators; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> statCalculators.Sum(c =&gt; c.Sum()); } }</code> </pre><br>  The container will select all the contracts from the union, and the resulting StatCalculator instance for each of them will substitute a statCalculators into the sequence. <br><br>  Contracts allow you to describe service states only for a static, finite set of configurations, when all possible variants of a dependency tree are known at the configuration stage.  If the file name for the FileNumbersProvider is entered by the user, then it is much more natural to simply transfer it by parameter via the StatController -&gt; StatCalculator -&gt; FileNumbersProvider chain. <br><br><h2>  Optional injection </h2><br>  Configurators allow to prohibit the use of some interface implementation or a specific instance of a class: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;FileNumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext c, ServiceConfigurationBuilder&lt;FileNumbersProvider&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ b.WithInstanceFilter(p =&gt; p.ReadAll().Any()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InMemoryNumbersProviderConfigurator</span></span></span><span class="hljs-class"> :</span></span> IServiceConfigurator&lt;InMemoryNumbersProvider&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurationContext c, ServiceConfigurationBuilder&lt;InMemoryNumbersProvider&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ b.DontUse(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The WithInstanceFilter method imposes a filter on all FileNumbersProvider instances created by the container ‚Äî clients will receive only those that can return at least one number. The DontUse method completely prohibits the use of InMemoryNumbersProvider. The class constructor can also decide that, in a certain situation, the instance it creates should not be used by container clients. To report this to the container, the constructor must throw a special exception - ServiceCouldNotBeCreatedException. This will be equivalent to using the WithInstanceFilter method in the configurator.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the creation of a service dependency was prohibited by one of the methods described above, the creation of the service itself would also be considered prohibited. Such a process of gradual exclusion of services will climb recursively up the dependency tree until it reaches the Resolve call on the container. At this point, an exception will be generated stating that no implementation has been possible for this service. Another way to stop this process is if you encounter a constructor parameter that has a sequence type (Sequence Injection) on its path. In this case, this element of the sequence will simply be skipped. There is a third option to stop - when the parameter is marked as optional:</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StatController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StatCalculator statCalculator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StatController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[Optional] StatCalculator statCalculator</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statCalculator = statCalculator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InMemorySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> statCalculator == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : statCalculator.Sum(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The optional attribute provided by the container declares that if it is impossible to create the corresponding service, null should be passed to the parameter. </font><font style="vertical-align: inherit;">The same effect can be achieved by using the default value of the parameter (= null) or by marking the parameter with the [CanBeNull] attribute from the JetBrains.Annotations library.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose now that service A has two non-optional dependencies B and C. Suppose also that the container successfully created B, but the creation of C was prohibited. </font><font style="vertical-align: inherit;">Then the creation of A will also be prohibited and a copy of B will be unused. </font><font style="vertical-align: inherit;">This is not a problem, if creating B was a cheap operation, but if B requires complicated initialization (going to the database, opening large files, initializing the cache), then before launching it, I would like to have confidence that it is not useless. </font><font style="vertical-align: inherit;">For this, the container provides the following interface:</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IComponent</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All the heavy logic of raising the service should be located in the implementation of the Run method of this interface. The point here is that the container will call Run as a separate stage, after it has completely created the entire dependency tree in the Resolve method. Knowing the composition of the tree, the container simply runs through it and consistently causes Run in order from leaf to root. For each service, the call is made only once - at the first receipt. If the service is used in several subtrees, each of which was created by a separate Resolve call, then Run on this service (if any) will also be called only for the first time.</font></font><br><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in any of the above, source codes are available on </font></font><a href="https://github.com/gusev-p/simple-container"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We haven't gotten to the documentation yet, so for answers to questions about the API it is most convenient to turn to tests. </font><font style="vertical-align: inherit;">If you feel that you are missing some kind of feature or convention, then Fork and Pull Requests are very welcome.</font></font></div><p>Source: <a href="https://habr.com/ru/post/248585/">https://habr.com/ru/post/248585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248573/index.html">PHP output buffer</a></li>
<li><a href="../248575/index.html">One ring to rule them all or TeddyID authentication</a></li>
<li><a href="../248579/index.html">RAD Studio XE7 World Tour in Rostov-on-Don, Almaty and Orenburg</a></li>
<li><a href="../248581/index.html">(Kiev) On January 28-30, the course ‚ÄúIntroduction to OpenStack. Basics</a></li>
<li><a href="../248583/index.html">(Kiev) February 16-17, the course "Infrastructure Management through HP OneView"</a></li>
<li><a href="../248587/index.html">Reports for NORD POS. Part 2</a></li>
<li><a href="../248589/index.html">The first step on the path to daily planning, or where does the meat grinder?</a></li>
<li><a href="../248591/index.html">Using the DSP coprocessor DM8168 using the C6Accel framework</a></li>
<li><a href="../248593/index.html">Opensource lifeguard for cats, dogs and other animals in PHP</a></li>
<li><a href="../248597/index.html">Parsing the Microsoft Office localization file format</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>