<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effective calculation of the field of view and the line of sight in games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In strategic games, it is usually required to know the scope of the NPC so that the player can think through the strategy and make the next move. We c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effective calculation of the field of view and the line of sight in games</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/cad/9a8/ec1/cad9a8ec147af07461b9db01b3fa0fba.gif" alt="image"><br><br>  In strategic games, it is usually required to know the scope of the NPC so that the player can think through the strategy and make the next move.  We consider the mathematics and the implementation of a rational model, not dropping the speed of the game with a large number of NPCs on the map.  If you want to see the finished interactive demo model, go <a href="https://legends2k.github.io/2d-fov/">here</a> and play right in the browser!  Here is a screenshot of the demonstration: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05b/603/b54/05b603b54d939fe2e3b0137eb52c7296.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having the parameters of visibility of the observer (direction of sight, distance of visibility and angle of the field of view), we need to find the area visible to him, i.e.  determine the field of view (FoV).  If there are no obstacles, it will be a sector of a circle consisting of two faces (radii) and an arc connecting them (see Fig. 1).  In addition, having a given point of the world, we must quickly determine whether it is visible to the observer, i.e.  it is necessary to process line of sight requests (line of sight, LOS) for a given point.  Both of these operations can be performed quite effectively for use in real-time rendering. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d40/6f4/576/d406f45761779683aad3a3a06b7e7144.png" alt="image"><br>  <i>Fig.</i>  <i>one</i> <br><br>  The position of the observer is represented by a red dot, the arrow indicates the direction of gaze, <i>r</i> is the distance of visibility, and <i>Œ∏</i> is half the angle of the field of view. <br><br><h2>  1 Input </h2><br><ul><li>  A set of polygons, including the borders of the world </li><li>  FoV parameters <br><ul><li>  Observer position </li><li>  Direction of view, <i>V</i> </li><li>  Field of view, <i>2Œ∏ &lt;180 ¬∞</i> </li><li>  Visibility distance <i>r</i> </li></ul></li></ul><br>  Note: here and below, lowercase letters represent scalar values, and uppercase vector characters. <br><br><h4>  1.1 Polygons and edges </h4><br>  When describing the world in 2D, buildings naturally break up into polygons and thus become input to the algorithm.  However, technically, the field of view is limited to the walls, i.e.  polygon edges.  In addition, working with edges of polygons provides improved detail and control, because when checking intersections, we will mainly deal with geometric primitives.  Therefore, in most cases, the algorithm works directly with the edges and does not apply to higher-level abstractions (polygons). <br><br><h2>  2 Basic algorithm </h2><br>  The first interesting idea that comes to mind is cropping the sector of visibility by the contours of polygons.  But we consider the appearance, and an attempt to solve this problem by cutting along the contour will not work, the end result will be wrong.  This is understandable, since cropping only cuts off the intersection of two areas, and for visibility we need to cut off not only the intersection, but everything behind it according to the principle of radiality.  In Fig.  2 shows the result of trimming (left) and the expected result for this configuration (right). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3da/1f6/8ba/3da1f68ba51c0e48a05af58fef0f7f77.png" alt="image"><br>  <i>Fig.</i>  <i>2</i> <br><br>  In the real world, we see objects when light rays freely enter the eye.  Intuitively, visibility can be defined by an inverse operation, i.e.  Beaming of the eye into the world.  In the case of a light source, rays are emitted in all directions.  In practical implementation, rays are emitted radially at a predetermined interval, for example, one beam every 5 ¬∞ and 72 rays for the entire circumference.  The beam should move until it is blocked by an edge.  The emission of rays at all 360 ¬∞ and the determination of the region illuminated by the light source in 2D is a solved problem [1].  The accuracy of this method depends on the interval between the emitted rays.  Shorter intervals provide greater density distribution of the rays. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/622/49e/e9a/62249ee9a941ea15e64cfbcb67052b72.png" alt="image"><br>  <i>Fig.</i>  <i>3</i> <br><br>  The emission of rays is, in other words, a check for the intersection of rays with segments of straight lines.  For a given ray with <strong>m</strong> segments, <strong>m</strong> checks are performed to determine the edge nearest to the beam that blocks it.  Therefore, in any ray tracking algorithm, to emit <strong>n</strong> rays to <strong>m</strong> edges, <strong>n √ó m</strong> checks must be performed.  However, no matter how small the resource-intensiveness of checking the intersection of rays and straight segments (edges), in an enormous world with many light sources, this approach can become too costly. <br><br>  Let's call the beam <em>blocking</em> edge <em>blocking edge</em> .  In Fig.  3, they are highlighted in red.  The point at which the ray intersects the blocking edge is called <em>the hit point</em> .  After finding all the points of impact, they must be circularly connected, i.e.  All points of contact are ordered by angle and are connected by lines to determine the area illuminated by the light source.  The result will be an incorrect closed loop.  It should be noted that when connecting the intersection points in this way, some corners or parts of the polygons are cut off, which leads to an incorrect or less accurate illuminated area.  It can be improved by reducing the interval of emission of rays.  The smaller the interval, the more rays and better coverage.  The result is improving, but at the cost of reduced productivity. <br><br>  With this problem of determining the illumination area, we considered the main approach that we will use to solve our problem: the ray casting method.  Notice that the rays of light emanate from the source of light in all directions until they intersect with the obstacle.  The absence of restrictions makes the problem simpler compared to our problem, in which the angle and distance of visibility are limited.  We will discuss why this is the case later in section 3. <br><br><h4>  2.1 Optimization </h4><br>  Instead of emitting rays in all directions (at a certain interval), the task is usually optimized by emitting rays only in those directions in which the edges of the edges are located.  This significantly reduces the number of intersection checks required.  The above <strong>n</strong> value should be less.  Another advantage of this method is greater accuracy: now, for the accuracy of the designated scope, we do not rely on the selected interval. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/7c1/344/3f67c1344d9775a7410017f215438ccf.png" alt="image"><br>  <i>Fig.</i>  <i>four</i> <br><br>  We will call these edge ends, which give us the angle of emission of rays, the corner points.  This name may instead seem redundant and meaningless, but later it will come in handy to us.  Corner points are points at which rays of visibility are emitted.  In Fig.  4 corner points are marked in red, blue and black.  Rays are emitted at all these points.  Points closest to the beam are converted to hit points marked in red.  Points that their ray does not reach are marked with black.  These rays intersect with the closer edges and create hit points marked with blue. <br><br><h4>  2.2 Vision without angles </h4><br>  Although emitting rays only at the ends of the ribs suits us, it has a slight drawback.  Notice in Fig.  4, the beam emitted to the corner of the polygon intersects one of the edges that create the angle, and does not move further.  However, visibility should in some cases be beyond the angle.  A clever approach to solving this problem is shown in an interactive article [2]. <br><br>  The idea is to divide the primary beam (the beam at the end of the edge) into two auxiliary ones, rejecting them by the angle ‚Äúiota‚Äù clockwise and counterclockwise.  If visibility should extend beyond the corner, one of these auxiliary rays will pass through the corner, thus determining the visibility behind it.  The disadvantage of this approach is: instead of a single beam, we now need to emit three for each corner point, which affects the speed three times more.  It would be nice to minimize the number of corner points we need to process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0a/067/713/f0a0677136bc8b8ee6a52925fda7e7f1.png" alt="image"><br>  <i>Fig.</i>  <i>five</i> <br><br>  Auxiliary rays highlighted in orange.  The angle of deviation (between the orange and the black ray) is intentionally exaggerated here for clarity, but it should be much less than, say, half a degree. <br><br>  A simple optimization would be to determine whether both edges are visible, forming an angle, or one of them is hidden by the other.  If both are visible, then the auxiliary rays are not required, because the visibility cannot extend further.  In Fig.  4 the apex of the triangle is the visible angle, the auxiliary rays are not needed here, because the visibility cannot extend further.  Auxiliary rays are needed only when one of the two edges is hidden from the observer.  Both edges cannot be hidden, because we look at each corner of the polygon separately - at two edges and the point at which they join (see Fig. 6, black arrows and blue point).  Even if one of the edges is hidden, the emission of two auxiliary rays is redundant;  one can be avoided because only one can pass around the corner without difficulty.  In Fig.  5 the auxiliary beam created by rotating the primary clockwise is redundant. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c11/d17/b4b/c11d17b4b34131e62b0f233ffd419bfe.png" alt="image"><br>  <i>Fig.</i>  <i>6</i> <br><br>  To determine whether one of the edges blocks the other, one can use the split axis theorem.  Projecting the vectors of both edges on a vector perpendicular to the primary ray will produce results with different signs if one of the edges blocks the other.  Also, depending on the sign of the projection of the first edge, we can find out which of the two auxiliary rays is necessary.  In Fig.  6 above shows three possible situations, and below - the results of the projection.  The black dot indicates the position of the observer from which the primary beam is emitted (red).  Rib vector vectors (black) are projected onto the perpendicular primary vector (green).  If auxiliary rays are not required, both projections give negative values, because both edge vectors are in the negative half-space of the perpendicular.  In two other cases where auxiliary rays are needed (orange), the signs of the projections differ from the signs of the vectors;  if the sign is negative for a vector of a longer edge, then the auxiliary ray is sufficiently rotated clockwise, and if it is positive, then the ray rotated counterclockwise is sufficient. <br><br><h2>  3 Blocking edges and corner points </h2><br>  In the task we are considering, visibility is limited by angle and distance;  This leads us to interesting situations. <br><br><ul><li>  Corner points are not all the ends of the edges, but only in the area of ‚Äã‚Äãthe sector of visibility. <br><ul><li>  This at least halves the amount of rays emitted.  <strong>n</strong> now becomes even smaller. </li><li>  To take advantage of this, efforts should be made to separate the corner points from the edges of the ribs.  The technique used for this should be fast enough so that the separation itself does not take too long. </li></ul><br></li><li>  In addition, most edges will not potentially block;  for us, only those that are contained in the sector or cut off by them are important. <br><ul><li>  This reduces the number of required intersection checks.  The value of <strong>m</strong> should decrease. </li><li>  For this purpose, we should also come up with a fast algorithm for cutting off unnecessary edges. </li></ul></li></ul><br>  The main difference or deviation from the basic algorithm, explained in Section 2, is that there may be corner points that are not included in the set of edges of the edges.  It may be necessary to determine more angular points.  See configurations in Fig.  7 and 8. The edges of the edges are outside the sector of visibility, therefore they are useless as corner points.  All corner points necessary for the correct definition of the scope (marked with black, blue and red) do not coincide with the edges of the edges.  Each of them is necessary, the impossibility of emitting a beam into any of them will lead to an incorrect definition of the scope.  How do they differ and how to define them? <br><br>  Since vision is limited to the angle of sight, two corner points are necessary and must be unconditionally accepted regardless of the presence of an edge.  They are extreme points on the edges of the sector.  They emit rays and define the points of impact.  In Fig.  7, black shows one of these implied corner points: a corner point arising from a point on the right edge of a sector.  The beam emitted into it is blocked by an edge, which led to the appearance of a blue dot.  Another beam emitted at the corner point of the left edge passes unobstructed.  Therefore, the point of impact becomes the corner point itself, highlighted in blue.  So, blue dots are easy to determine, they do not require checks.  Their position is constant and depends on the position and direction of the sector of visibility. <br><br>  Consider a red corner point (turned into a hitting point, because the beam is not blocked by anything) at the intersection of the arc and edge of the sector.  It requires another check of the intersection: checking the intersection of the arc and the line segment.  These corner points are necessary when the edge intersects the sector arc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74f/bd9/5bd/74fbd95bd13c21f058946a43064ea9ea.png" alt="image"><br>  <i>Fig.</i>  <i>7</i> <br><br>  The beam is shown with the point of the arrow, and the edge has end points. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/aa9/059/bd0aa9059382bc2437f94a9b066407fb.png" alt="image"><br>  <i>Fig.</i>  <i>eight</i> <br><br>  Taking this into account, we will list the occurrence of corner points: <br><br><ul><li>  Any end point of the edge that is in the sector of visibility </li><li>  Any point of the arc sector in which it intersects the edge </li></ul><br>  In addition, potentially blocking ribs are ribs that are fully or partially located in the sector. <br><br>  Now the problem becomes the task of obtaining a set of corner points (searching for new ones and discarding unnecessary end points) and the set of potentially blocking edges (cutting off non-blocking edges).  This task must be performed quickly, discarding the wrong elements as early as possible so as not to burden the processing cycles with results that will be discarded later.  The goal is to reduce the values ‚Äã‚Äãof <strong>n</strong> (the number of emitted rays = the number of corner points) and <strong>m</strong> (the number of segments to check for intersection with the beam = the number of potentially blocking edges), providing a fast algorithm for determining FoV. <br><br><h4>  3.1 Clipping </h4><br>  In [3], it is assumed that the ideal cut-off algorithm (in reality, it will be resource-intensive and complicated by the problems of floating-point accuracy) leaves only a lot of visible points, and a fairly good algorithm discards most of the invisible ones, leaving exactly visible and potentially visible.  It will be conservative when dropping potentially visible points.  In other words, if he cannot be perfectly sure that the edge <em>does not</em> interfere with visibility, he will <em>not</em> discard it. <br><br><h5>  3.1.1 Stage early trivial drop </h5><br>  The simplest idea for discarding unsuitable endpoints and edges is to check only the endpoints of the edges that are inside the sector.  This is suitable for corner points, but not enough for blocking edges, because it does not work in configurations where the end points of the edges are not in the sector, but the edge blocks visibility (see Fig. 7 and 8).  Before proceeding to a more detailed analysis, the endpoint check can be completely skipped if we can drop the edge. <br><br><h5>  3.1.1.1 Intersection of a rib with a bounding circle </h5><br>  If the segment point closest to the center of the circle is inside the circle, then it either lies in it or intersects it.  This approach is described in detail in [4].  With the help of the edge and the bounding circle of the sector, we can discard all edges that are not included in the bounding circle.  After this stage, all edges that are not in a circle are not considered.  Since this is not a check for searching for intersection points, but simply cutting off extra edges, the result is represented in Boolean form and is obtained rather quickly.  To implement this test, we need only a couple of vector subtraction operations (giving a vector) and scalar products: one to find the nearest point (by projection), and another to calculate the square of the distance from it to the center of the circle. <br><br>  The results of this check are shown in Fig.  9. The bounding circle of the visibility sector is marked by a dotted line.  The blue dot on each edge indicates the point closest to the center of the circle.  Green edges are saved for further calculations.  Lilac also persist, but are false positive.  Red discarded.  The edge on the bounding circle is also dropped, because it does not interfere with visibility. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/07e/639/b3c07e639832b6d1ee35948597e034d0.png" alt="image"><br>  <i>Fig.</i>  <i>9</i> <br><br>  For aggressive rejection of false-positive results, the idea of ‚Äã‚Äãchecking the nearest point in the sector, and not in a circle, looks attractive.  However, such a test is incorrect, because it will discard positive results.  In Fig.  9, together with the purple dots, the green edge will also be dropped, the nearest point of which is outside the sector. <br><br><h5>  3.1.1.2 Point relative to the sector </h5><br>  Having a point and a sector, you can quickly determine <br><br><ol><li>  is the point behind the observer </li><li>  in front of the observer and <br><ol><li>  out of sight </li><li>  within sight distance and <br><ol><li>  inside the sector </li><li>  outside the sector but inside the limiting semicircle </li></ol></li></ol></li></ol><br>  using scalar and vector products only.  Since the vector product is not defined in 2D, we transfer the vectors to 3D, taking z = 0. The results of the vector product are vector, but since z = 0, the elements related to x and y will be equal to 0, and only the value z will be nonzero ( if the vectors are non-parallel).  Thus, we obtain a scalar result from this vector product.  See the various definitions of a vector product in 2D in [5]. <br><br>  Let the vector from the center of the circle to the point be (U), and the vectors of the sector edges be E1, E2.  We already have the direction of view V. <br><br><ol><li>  If U ‚ãÖ V &lt;0, then the point is behind the observer. </li><li>  otherwise, if U ‚ãÖ U = ‚ÄñU‚Äñ <sup>2</sup> &gt; r <sup>2</sup> , then the point is out of sight. </li><li>  otherwise, if sign (E1 √ó U) = sign (U √ó E2), then the point is in the sector. </li><li>  otherwise it is in the surrounding semicircle, but outside the sector. </li></ol><br>  We used two optimizations that required explanations.  We compare the length squares (2) instead of the length comparison, because finding the length means using <code>sqrt ( )</code> .  We avoid this and apply the optimization that is familiar to work with computer graphics ([7]).  To check whether a point is inside a sector (3), we can find the angle opposite the first edge of the sector and check whether it is inside the allowable angle of visibility (2Œ∏).  However, for this you need to use the <code>acos ()</code> trigonometric function, which may be more expensive than calculating a pair of vector products that uses only arithmetic operations. <br><br>  If the edge ‚Äúsurvived‚Äù the previous check, we check its endpoints to determine where they are located.  In Fig.  10 shows the current situation: gray points behind the observer (1), red - outside the sector (2), green endpoints - inside the sector (3), and lilac - inside the bounding semicircle, but outside the sector (4). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebb/a6d/0e7/ebba6d0e7dc72c11bb4d6add29bf0e3e.png" alt="image"><br>  <i>Fig.</i>  <i>ten</i> <br><br>  Corner points and blocking edges can be determined from the results: <br><br><ol><li>  If both ends of the observer (1), they do not interfere with visibility;  discard them and no longer handle. </li><li>  If both ends are inside a sector (3), mark both as corner points, and the edge as blocking.  We stop further processing. </li><li>  If one of them is inside a sector (3), and the other is not - (1), (2), (4) - we mark one inside as a corner point, and an edge - as a blocking one.  This edge can intersect the sector arc and create a new corner point. </li><li>  If both are outside the sector - (2), (4) - the end points are not angular, but the edge can intersect the sector arc, creating new corner points.  An edge can be blocking if it intersects an arc or sector edges. </li></ol><br>  In cases 3 and 4, we need additional checks to find corner points that are not end points contained inside the edges and block visibility by the edges.  This leads us to the stage of narrowing the cut. <br><br><h4>  3.2 Contraction Stage </h4><br>  At this stage, we get rid of other false-positive results with more costly checks to improve the performance of the emission of rays.  We can conduct checks on the intersection of the edge and arc of an arch and / or edge and edge. <br><br>  However, before performing a little costly verification of the intersection of a segment and an arc (it uses a square root and more than three branch operations), we can use the results of the previous verification to make sure that verification is necessary.  The check is needed only when the edge has the ability to cross the arc.  If both endpoints are inside a bounding circle, the edge will not be able to cross the circle.  An edge can cross an arc of a sector only if one of its end points is in front of the observer, and the other is outside the bounding circle (case 2.1 in section 3.1.1.2). <br><br><table><caption>  <strong>Table 1.</strong> <em>Possible positions and states of the end points of the edges</em> </caption><thead><tr><th>  No </th><th>  End A </th><th>  End B </th><th>  condition </th></tr></thead><tbody><tr><td>  one </td><td>  Inside </td><td>  Inside (2.2.1) </td><td>  Corner points: A, B ‚Ä¢ Blocks </td></tr><tr><td>  2 </td><td>  Inside </td><td>  Rear (1) </td><td>  Corner Point: A ‚Ä¢ Blocks </td></tr><tr><td>  3 </td><td>  Inside </td><td>  In the semicircle (2.2.2) </td><td>  Corner Point: A ‚Ä¢ Blocks </td></tr><tr><td>  four </td><td>  Inside </td><td>  Outside (2.1) </td><td>  Corner point: A ‚Ä¢ Blocks ‚Ä¢ may cross the arc </td></tr><tr><td>  five </td><td>  Behind </td><td>  Behind </td><td>  Discarded </td></tr><tr><td>  6 </td><td>  Behind </td><td>  Outside </td><td>  Can cross an arc ‚Ä¢ can block </td></tr><tr><td>  7 </td><td>  Behind </td><td>  In the semicircle </td><td>  Can block </td></tr><tr><td>  eight </td><td>  In the semicircle </td><td>  In the semicircle </td><td>  Can block </td></tr><tr><td>  9 </td><td>  In the semicircle </td><td>  Outside </td><td>  Can cross an arc ‚Ä¢ can block </td></tr><tr><td>  ten </td><td>  Outside </td><td>  Outside </td><td>  Can cross an arc ‚Ä¢ can block </td></tr></tbody></table><br>  We have already dealt with points 1, 2, 3 and 5 at the stage of early discarding and there is nothing to do with them.  Point 4 requires checking the intersection of the edge with the arc to make sure that no additional corner point is needed.  At an early stage, we have already marked one of its end points as a corner point, and an edge as a blocking point.  Points 6-10 are the most interesting at the stage of narrowing.  For points 6, 9 and 10, it is necessary to check the intersection of the edge with the arc in order to know whether corner points appear at the intersection.  If so, the edge should be marked as blocking.  If these points do not pass the test, they join points 7 and 8. They cannot have corner points, but they still have to go through the edge and edge intersection check in order to know if they are blocking visibility. <br><br><h5>  3.2.1 Intersection of the edge and arc sector </h5><br>  For points 4, 6, 9 and 10 of Table 1, by checking the intersection of the segment and the arc, we check whether the edge intersects the sector arc [6].  If so, then we mark the intersection points as corner points, and the edge as blocking.  Further processing is not required.  If this is not the case, the edge cannot have corner points, but the edge must pass the following visibility blocking test. <br><br>  In essence, this is a check of the intersection of a line and a circle, the result of which are two points.  Points lying on the segment and on the arc are considered the points of intersection.  Here you can make a small optimization: if both intersection points are behind the observer, then the segment cannot block the visibility and have corner points, so the edge can be dropped without further processing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ba/0ef/326/3ba0ef326c41148a23bcb814657a5bbc.png" alt="image"><br>  <i>Fig.</i>  <i>eleven</i> <br><br>  In Fig.  11, a gray edge is checked with one end point out of sight, and the other end point is checked behind the observer, but both intersection points behind the observer (purple) and, therefore, are discarded.  A green edge with both points in a semicircle is never checked.  The red edge with one end point out of sight is checked, but the only intersection point found (blue) is not on the arc.  This edge cannot have corner points, but is sent to the next stage (checking the intersection of the edge and edge) to check for a blockage.  All other edges (black) with one or both end points outside the bounding circle, having suitable (red) intersection points are marked as blocking, and intersection points as corner points. Each such edge corresponds to one of points 4, 6, 9 or 10 in Table 1. <br><br><h5>  3.2.2 Intersection of the edge and sector edge </h5><br>  For points 7 and 8, which have never passed the previous check, and for points (6, 9 and 10) that passed the check, which did not find any intersection points, there can be no corner points on the edge.  Both of its end points are not inside the sector, and no new corner points lie on the arc.  However, such edges cannot be rejected, because they can still block (see Fig. 8) or not block (see Fig. 10; an edge with a purple end point).  We have two options: make sure and mark them as blockers or, for confidence, check them for intersection with sector edges.  Having chosen the first option, for each false positive intersection with the sector of visibility, we pay checks by the intersection of the segment and segment <strong>n</strong> at the stage of emission of rays, because each beam is checked for intersection with each potentially blocking edge.  Instead of paying <strong>n</strong> times for false positive results, the best option would be to spend <strong>n + 2</strong> (in the worst case).  Therefore, we check the edge for intersection with both edges of the sector.  If an edge intersects at least one of them, we mark it as blocking. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6d/34f/a41/b6d34fa41973fa256050f6032d9f3928.png" alt="image"><br>  <i>Fig.</i>  <i>12</i> <br><br>  For items 6-10 in Fig.  12 there are two corresponding edges: one positive (green), the other negative (red).  From the figure it is obvious that this check has a greater probability of dropping edges that do not match the visibility. <br><br><h2>  4 Beam emission </h2><br>  We have all the corner points and blocking edges.  Before performing ray tracking, it is necessary to sort the corner points by angle so that the final shape of the scope is correct when connecting the points of hitting with edges and arcs.  In addition, if two or more corner points and the observer position are collinear, then several rays will be emitted in one direction.  It is necessary to discard the duplicate corner points in order to avoid extra rays. <br><br>  For sorting technique can be used.  described in section 3.1.1.2: using the vector product to determine whether a point is inside the sector of visibility.  Duplicate corner points can be easily processed again using a vector product.  Before the emission of a beam for each corner point, it multiplies vectorially with the previous one, and if the result is zero, then the vectors are linearly dependent (parallel), which means they can be ignored. <br><br>  Primary rays are emitted at sorted corner points.  If we know that the point is the end point of the edge, and not the intersection point, then it is also necessary to emit auxiliary rays (for more details, see Section 2.2).  Auxiliary rays are emitted only at the corner points, which are the end points of the edges, and are not emitted at the intersection points, because they cannot be the corners of the polygons, i.e.  visibility cannot spread beyond them. <br><br>  For each emitted beam, we find the point of intersection of the beam and the nearest edge to it.  It becomes the point of impact of the beam.  If this point is outside the visibility distance <strong>r</strong> , then we take the hit point as a point along the beam, which is at a distance <strong>r</strong> from the observer.  Those.  we drag the hitting point backward until the distance from it to the observer becomes equal to <strong>r</strong> .  We check whether each hit point is at the edge of the arc.  If this and the previous point is on the border of the arc, then we connect them with an arc, and otherwise - with a segment.  However, when performing this task "blindly" there is a small problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce8/3ed/868/ce83ed868ceb3e4fc9f5f6d02e0a8352.png" alt="image"><br>  <i>Fig.</i>  <i>13</i> <br><br>  In Fig.  13 points of impact (numbered from right to left) 1 and 2 are on the arc, and must be connected by an arc.  The same is the case with hit points 3 and 4. However, hit points 2 and 3 must be connected by a segment, because there is an edge intersecting an arc.  If a hit point 3 is detected and it is confirmed that it and the previous hit point are on an arc, before connecting them with an arc, check whether the connecting line is parallel to the nearest edge on which the hit point lies 3. Connect them with a segment if they are parallel. <br><br><h2>  5 Line of sight </h2><br><p>  A line of sight request is needed to answer the question of whether a certain point in the world <strong>X is</strong> visible to an observer with given observer parameters (see Section 1).  After finding the blocking edges and corner points, this is easy to do.  First, we classify <strong>X</strong> according to section 3.1.1.2.  If the point is not inside the sector, we return <code>false</code> .  If it is inside, we check whether any of the blocking edges intersects the segment formed by connecting X with the observer.  If it does not cross, we return <code>true</code> , because the line of sight or the beam from the observer to the object does not interfere.  Accordingly, the object is visible. <br><br></p><h2>  6 References </h2><br><ol><li>  <a href="http://www.redblobgames.com/articles/visibility">2D Visibility</a> , Amit Patel </li><li>  <a href="http://ncase.me/sight-and-light">Sight &amp; Light</a> , Nicky Case </li><li>  ¬ß14.2 Culling Techniques, <em>Real-Time Rendering</em> , Third Editio, Thomas Akenine-M√∂ller, Eric Haines and Naty Hoffman </li><li>  David Stygstra </li><li>  ¬ßA.2.1, <em>3-D Computer Graphics</em> , Samuel R. Buss </li><li>  <a href="http://www.geometrictools.com/Documentation/IntersectionLine2Circle2.pdf">Intersection of Linear and Circular Components in 2D</a> , David Eberly </li><li>  ¬ß2.2.5, <em>Essential Mathematics</em> , Second Edition, James Vanth and M. Bishop </li><li>  Fletcher Dunn and Ian Parberry <em>3D Math Primer for Graphics and Game Development</em> , Second Edition </li><li>  <em>Mathematics for 3D Game Programming</em> , Third Edition, Eric Lengyel </li></ol><p></p></div><p>Source: <a href="https://habr.com/ru/post/319040/">https://habr.com/ru/post/319040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319030/index.html">Segmentation as it is. Part 2</a></li>
<li><a href="../319032/index.html">Difficulties in modeling operations in standard ways. Modeling 4-objects, problem statement</a></li>
<li><a href="../319034/index.html">Infrastructure simple electronic signature. Part 2: Target System Modeling</a></li>
<li><a href="../319036/index.html">Comparison of lock-free algorithms - CAS and FAA on the example of JDK 7 and 8</a></li>
<li><a href="../319038/index.html">Isomorphic React Applications: Performance and Scaling</a></li>
<li><a href="../319042/index.html">Recognize checks in Google Docs using the ABBYY OCR SDK</a></li>
<li><a href="../319048/index.html">Hadoop From Scratch</a></li>
<li><a href="../319050/index.html">Galois field on Scala</a></li>
<li><a href="../319052/index.html">NoSQL - briefly about the main thing</a></li>
<li><a href="../319054/index.html">How to start using SSD hardware encryption using the example of Samsung EVO 850 and sedutil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>