<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hacker Battles: Parsing PHDays CTF and CTF Quals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Positive Hack Days CTF is an international competition for the protection of information, which is held according to the gaming principle of Capture t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hacker Battles: Parsing PHDays CTF and CTF Quals</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://www.phdays.ru/ctf/">Positive Hack Days CTF</a> is an international competition for the protection of information, which is held according to the gaming principle of Capture the Flag.  Several teams for a predetermined time to protect their networks and attack others.  The main task of the participants is to identify vulnerabilities in the systems of opponents and gain access to secret information (flags), while detecting and eliminating similar vulnerabilities in their system. <br><br>  In today's topic, we will present an analysis of some interesting tasks faced by participants in past competitions. <br><br><h4>  History and geography </h4><br>  This year PHDays CTF will be held for the fourth time.  For the first time, the competitions were held during the Positive Hack Days forum in 2011, then the participants of the American PPP team became winners, the next year the Russian team Leet More won, and Eindbazen from Holland became the PHDays III champions.  Every year teams from around the world take part in PHDays CTF - from the USA to Japan. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      More than 600 teams registered to participate in the qualifying competitions this year. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/20e/ce8/4f4/20ece84f4292c0f0c03db36f06c5bf14.png" alt="image"><br><br><h4>  Tasks and Atmosphere </h4><br>  Traditionally, game tasks and infrastructure are prepared in accordance with the legend of the competition - a special storyline that turns a simple set of PHDays CTF tasks into an exciting competition that has a goal.  For example, last year, participants saved the fictional world D'Errorim from death.  Upcoming competitions will continue <a href="http://www.phdays.ru/ctf/index.php%3Fid%3D2">this story</a> . <a name="habracut"></a><br><br>  Competition tasks, as a rule, are based on real prototypes: vulnerabilities inherent in CTF tasks and services can be found in various systems in real life.  PHDays CTF competitions are also interesting for original game mechanics, which make it possible to implement different and different strategies for playing a game (for more information, see <a href="http://www.phdays.ru/upload/ctf/ARTICLE_CTF_DEV_v2.pdf">PHDays website</a> ). <br><br>  Usually, the organizers are preparing for the team unusual tasks not directly related to burglary.  For example, during PHDays 2012 additional points could be earned by finding bonus flags in a special container with rubbish, and during PHDays III, the teams had to overcome the ‚Äú <a href="http://2013.phdays.ru/program/contests/index.php%3Fid%3D2">hacker maze</a> ‚Äù - the obstacle course with a laser field, tracking sensors, secret doors, a room with bugs and other interesting tests. <br><br>  But the main points, of course, are earned exclusively in the course of solving various problems of information security.  Let's take a look at some of them. <br><br><h4>  Parsing </h4><br>  The qualifying stage of the competition (PHDays CTF Quals) refers to the type of task-based CTF, that is, teams must solve tasks and get points for them.  Assignments may fall into one of the following categories: <br><br><ul><li>  Forensic - computer forensics, </li><li>  Reverse (reverse engineering) - binary code analysis, </li><li>  Pwn - exploitation of vulnerabilities, </li><li>  Admin - administration skills, </li><li>  Network - knowledge of network infrastructure and protocols </li><li>  Crypto - cryptography, </li><li>  Stegano - steganography, </li><li>  PPC (professional programming and coding) - Olympiad programming, </li><li>  Web - search and exploit web vulnerabilities, </li><li>  Misc - different. </li></ul><br>  Let's start with the last category. <br><br><h4>  Non-obvious tasks </h4><br>  PHDays IV CTF Quals participants in one of the tasks needed to decrypt the message hidden in the <a href="http://ctfarchive.phdays.com/phd4quals/mp3%2520me%2520(1400)/123.mp3.c3eb41b97e2b2d152c24392f17066208">mp3-file</a> . <br><br>  As a rule, if the problem statement mentions extracting a message hidden in some container, one of the ready-made solutions from the field of steganography is used.  At the same time, in order to find the answer, it is usually necessary to select a program for decryption and run it with the correct keys.  That is, the "key to success" in solving a specific task lies in finding a suitable option, previously written by the authors. <br><br>  In our case, everything is different.  If you open the proposed file in a text editor, it looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/c74/5c7/56d/c745c756d6f182ba0f15595dea9ca6d0.png" alt="image"><br>  At the beginning of the file are metadata in ID3 format.  First comes the TRCK (track number) tag, and then some pieces of text: <br><br>  <b>RGB7 5.183, NULL RGB6 0.42.159 RGB5 194.244.68 RGB4 47.77.6 RGB3 44.73.141 RGB2 140.207.72 RGB1 120,156,203</b> <br><br>  This information can be broken down into seven entries (from RGB7 to RGB1): <br><br>  <b>RGB7 5.183, NULL</b> <b><br></b>  <b>RGB6 0.42,159</b> <b><br></b>  <b>RGB5 194,244,68</b> <b><br></b>  <b>RGB4 47,77,6</b> <b><br></b>  <b>RGB3 44,73,141</b> <b><br></b>  <b>RGB2 140,207,72</b> <b><br></b>  <b>RGB1 120,156,203</b> <br><br>  After each of the RGB identifiers there are three values.  These are usually numbers, but in one case NULL.  It is easy to assume that this is an array of records, each of which contains up to three single-byte values.  You can sort, combine, turn decimal codes into symbols and display them in hexadecimal, for example, using the following program: <br><br> <code>&gt;&gt;&gt; a = [120,156,203, 140,207,72, 44,73,141, 47,77,6, 194,244,68, 0,42,159, 5,183]</code> <br> <code>&gt;&gt;&gt; print "".join(map(chr, a)).encode("hex")</code> <br> <br>  As a result, we get: <br><br> <code>789ccb8ccf482c498d2f4d06c2f444002a9f05b7</code> <br> <br>  The hexadecimal sequence starts with bytes with codes 0x78 0x9C, and this tells us that the zlib data compression algorithm is used.  If you use zlib in compression mode with default parameters, the output sequence will start from these bytes. <br><br>  With a single call to the zlib library's decompress function in Python, you can unpack a packed message: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> zlib &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> zlib.decompress(<span class="hljs-string"><span class="hljs-string">""</span></span>.join(map(chr, a)))</code> </pre><br>  And then the text will be displayed: <br><br>  <b>i_hate_ucucuga</b> <br><br>  It was this flag that had to be sent to the organizers of the competition. <br><br><h4>  Incorrect cryptography </h4><br>  This task belongs to the category of Crypto.  According to legend, the <a href="http://ctfarchive.phdays.com/phd4quals/mars%2520(2500)/mars.txt.9398d7aa954d2d38b4abb8ead791c93a">session</a> was intercepted, and the teams need to decrypt the transmitted messages. <br><img src="https://habrastorage.org/getpro/habr/post_images/701/bcb/22d/701bcb22de9afbf695d9a3abb0485d10.png" alt="image"><br>  First of all, the process of key exchange is clearly visible, and then the transfer of encrypted data.  It is necessary to understand on the basis of which cryptographic basis such communication can be built. <br><br>  The task is called mars, we can assume that this means Modified RSA. <br><br>  Each key consists of two parts, and the second part in both cases is 0x010001 == 65537 - the frequently used public exponent RSA (e).  This means that in a communication session, the public keys are first exchanged (n <sub>1</sub> / e <sub>1</sub> , n <sub>2</sub> / e <sub>2</sub> ), and then the messages encrypted on them (c1, c2) are exchanged. <br><br>  If it really is something like RSA, then ci = pow (m <sub>i</sub> , e <sub>i</sub> , n <sub>i</sub> ).  It is required to find m <sub>1</sub> and m <sub>2</sub> . <br>  pow is a function of modular exponentiation, pow (val, exp, modulus) == val <sup>exp</sup> % modulus. <br><br>  According to the RSA algorithm: <br><br><ul><li>  m <sub>i</sub> = pow (c <sub>i</sub> , d <sub>i</sub> , n <sub>i</sub> ), </li><li>  d <sub>i</sub> * e <sub>i</sub> ‚â° 1 mod œÜ (n <sub>i</sub> ), </li><li>  n <sub>i</sub> - the product of several prime numbers </li><li>  œÜ (n) is the Euler function, the number of positive integers with n and less than n. </li></ul><br>  In the task n <sub>1</sub> and n <sub>2</sub> have a length of 1535 bits, that is, they are not amenable to factorization (decomposition into simple factors). <br><br>  Let's use the implementation of the advanced Euclidean algorithm in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">egcd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Extended Greatest Common Divisor if a == 0: return (b, 0, 1) else: g, y, x = egcd (b % a, a) return (g, x - (b // a) * y, y)</span></span></code> </pre><br>  Find the GCD (the greatest common factor) of the numbers n <sub>1</sub> and n <sub>2</sub> : <br><br><pre> <code class="python hljs">gcd = egcd(n1,n2)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  GCD (n <sub>1</sub> , n <sub>2</sub> ) is 1024 bits long.  Find the other dividers of the numbers n <sub>1</sub> and n <sub>2</sub> : <br><br><pre> <code class="python hljs">p1 = n1 / gcd p2 = n2 / gcd</code> </pre><br>  p <sub>1</sub> and p <sub>2</sub> are prime numbers 512 bits long, gcd is a composite number 1024 bits long (most likely 512 * 512), and it is also too large to factor ... <br><br>  Consider the case when the desired messages m <sub>i</sub> can be represented by numbers not exceeding p <sub>i</sub> . <br><br>  Let n <sub>i</sub> = p <sub>i</sub> * q * r, then for 0 &lt;m <sub>i</sub> &lt;p <sub>i the</sub> following expression will be true: <br><br>  <b>pow (m <sub>i</sub> , e <sub>i</sub> , n <sub>i</sub> )% p <sub>i</sub> == pow (m <sub>i</sub> , e <sub>i</sub> , p <sub>i</sub> )</b> <br><br>  Then the exponent to decrypt d ' <sub>i</sub> must satisfy the following expression: <br><br>  e <sub>i</sub> * d ' <sub>i</sub> ‚â° 1 mod œÜ (p <sub>i</sub> ) <br><br>  The value of d ' <sub>i</sub> can be found by computing the algebraic complement: <br><br>  d ' <sub>i</sub> = invmod (e <sub>i</sub> , œÜ (p <sub>i</sub> )) <br><br>  For a simple p <sub>i</sub> true: <br><br>  œÜ (p <sub>i</sub> ) == p <sub>i-1</sub> , <br><br>  Consequently: <br><br>  d ' <sub>i</sub> = invmod (e <sub>i</sub> , p <sub>i-1</sub> ) <br><br>  The calculation of an algebraic complement is implemented by the following function in Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invmod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Modular inversion g, x, y = egcd (a, m) if g == 1: return x % m raise Exception("modular inverse does not exist")</span></span></code> </pre><br>  You also need a function that turns a number into a string and leaves only the text from the last '\ 0' character to the end of the line: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"%0256X"</span></span> % v).decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>).split(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>)[<span class="hljs-number"><span class="hljs-number">-1</span></span>]</code> </pre><br>  Calculate di, perform decryption: <br><br><pre> <code class="perl hljs">d1 = invmod(e, p1-<span class="hljs-number"><span class="hljs-number">1</span></span>) d2 = invmod(e, p2-<span class="hljs-number"><span class="hljs-number">1</span></span>) showX(pow(c1, d1, p1)) showX(pow(c2, d2, p2))</code> </pre><br>  And we get the result: <br><br>  <b>REQUEST: GET_FLAG (SIGNATURE: 5e2d5e0323591b1c).</b> <b><br></b>  <b>RESPONSE: its_n0t_ab0ut_p4dd1ng</b> <b><br></b> <br>  The flag is the string " <code>its_n0t_ab0ut_p4dd1ng</code> ". <br><br><h4>  Cryptographic task secc </h4><br>  It is given: the source.tar.gz archive containing the ecc.py and task.py files, which contain <a href="http://ctfarchive.phdays.com/phd4quals/secc%2520(3500)/source.tar.gz.d69d625930c28eab0ef53dfc5826ab8103269e59">the</a> key verification <a href="http://ctfarchive.phdays.com/phd4quals/secc%2520(3500)/source.tar.gz.d69d625930c28eab0ef53dfc5826ab8103269e59">scheme</a> implemented using elliptical cryptography.  It is known that by connecting to 1955.133.87.171 on port 5555, you can connect to some server: <br><br> <code>nc 195.133.87.171 5555</code> <br> <code>password: secch4l*</code> <br> <br>  Since the source code is given, it is worth starting with their analysis.  You can even run them. <br>  Since I did not have the libnum module, I had to write it myself.  It is sufficient to implement the previously mentioned modular inversion function and the Euclidean algorithm it uses: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">egcd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Extended Greatest Common Divisor if a == 0: return (b, 0, 1) else: g, y, x = egcd (b % a, a) return (g, x - (b // a) * y, y) def invmod(a, m): # Modular inversion g, x, y = egcd (a % m, m) if g != 1: raise Exception("modular inverse does not exist") else: return x % m</span></span></code> </pre><br>  So, the <code>main</code> function from <code>task.py</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Auth:‚Äú auth = raw_input() if hashlib.sha1(auth).hexdigest() != "</span></span><span class="hljs-number"><span class="hljs-number">375</span></span>d5c01ca1b8c3863024d10aac7713472eb5033<span class="hljs-string"><span class="hljs-string">": # secch4l* print "</span></span>nope‚Äú <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefix = os.urandom(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Proof of work, please‚Äú print "</span></span>Prefix <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> (hexed) <span class="hljs-string"><span class="hljs-string">", prefix.encode("</span></span>hex<span class="hljs-string"><span class="hljs-string">") test = raw_input().decode("</span></span>hex<span class="hljs-string"><span class="hljs-string">") if not test.startswith(prefix) or len(test) &gt; 16: print "</span></span>nope‚Äú <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h = hashlib.sha1(test).hexdigest() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> h.startswith(<span class="hljs-string"><span class="hljs-string">"000000"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"nope‚Äú return goflag()</span></span></code> </pre><br>  A string is read, SHA-1 from which must be equal to the specified value (‚Äúsecch4l *‚Äù). <br>  Then a random 8-byte prefix is ‚Äã‚Äãsent to the client.  Bytes are encoded as a hex string.  In response, the client must send a string no longer than 16 bytes, so that it begins with the specified prefix, and the first 3 bytes of the SHA-1 value from this string must be zero.  If all stages are completed successfully, the goflag () function is called. <br><br>  The following code fragment connects to the server, sends the password, receives the prefix, calculates and sends the response: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readLn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sock)</span></span></span><span class="hljs-function">:</span></span> a = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: c = sock.recv(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> == c: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join(a) a.append(c) HOST = <span class="hljs-string"><span class="hljs-string">"195.133.87.171"</span></span> PORT = <span class="hljs-number"><span class="hljs-number">5555</span></span> sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((HOST, PORT)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> readLn(sock) <span class="hljs-comment"><span class="hljs-comment"># Auth: sock.send("secch4l*\n") print readLn(sock) # Proof of work, please s = readLn(sock) print s # Prefix is (hexed) 0b3997e62b9ffbf4 prefix = s.split()[-1].decode("hex") for i in xrange(0x7FFFFFFF): s = "%s%X" % (prefix, i) if hashlib.sha1(s).digest()[:3] == '\0\0\0': break sock.send(s + '\n')</span></span></code> </pre><br>  After executing this code on the client side, the server performs the goflag () function, which displays something like the following: <br><br>  <b>EC PASSWORD CHECK</b> <b><br></b>  <b>R = 572115218124168948525078362547166172445820217705568707355669424304224832114</b> <b><br></b>  <b>SHARED SECRET = R ^ PASSWORD</b> <b><br></b>  <b>ENCRYPTED MESSAGE: 7a93846a011e0d0382e94f32d705239e6298169dcec20da5d6</b> <br><br>  What happens in the <code>goflag</code> function from <code>task.py</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goflag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"EC PASSWORD CHECK"</span></span> r = random.randint(<span class="hljs-number"><span class="hljs-number">31337</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">250</span></span>) R = p256.power(G, r) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"R ="</span></span>, R <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"SHARED SECRET = R ^ PASSWORD"</span></span> S = p256.power(R, PASSWORD) key = p256.derive(S) cipher = encrypt(FLAG, key) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"ENCRYPTED MESSAGE:"</span></span>, cipher.encode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>)</code> </pre><br>  Asymmetric cryptography on elliptic curves is used.  The P-256 curve recommended by NIST is selected.  The implementation of operations on the curve points does not contain obvious vulnerabilities. <br><br>  We know the value of R, but without knowing the value of PASSWORD (which is read by the server from the file password.txt) we cannot calculate S. Knowing S would allow us to easily calculate the key.  So can encryption be implemented with an error? <br><br>  The <code>encrypt</code> function from <code>task.py</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg, key)</span></span></span><span class="hljs-function">:</span></span> iv = os.urandom(<span class="hljs-number"><span class="hljs-number">8</span></span>) stream = hashlib.sha256(iv + key).digest() stream = hashlib.sha256(stream + iv + key).digest() cipher = iv + xor(msg, stream) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cipher</code> </pre><br>  The code shows that the encrypted message is preceded by a random 8-byte initialization vector iv, and encryption is performed as the XOR flag with a gamma generated as the output of two SHA-256 calculations.  Without knowing the value of key, getting a gamma is not possible.  But how does the key get in the program? <br><br>  Derive function from task.py: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">derive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashlib.sha256(str((p[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) / p[<span class="hljs-number"><span class="hljs-number">1</span></span>])).digest()</code> </pre><br>  It turns out that the value of the point S (consisting of two coordinates - x and y) is used as input SHA-256.  In fact, the value of str (int (x * 1024 / y)) is fed to the input of the hash.  Since x and y have similar values ‚Äã‚Äã(these are large integers), the result of arithmetic operations should be close to 1024 (although it may exceed it by several times). <br><br>  Thus, due to the implementation characteristics of the derive function, the key value can take on a very small number of states.  You can simply sort through them all, try to decipher the message on each key, and if it consists only of typed characters - we have achieved success. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib, ecc enc = <span class="hljs-string"><span class="hljs-string">"7a93846a011e0d0382e94f32d705239e6298169dcec20da5d6"</span></span>.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) iv = enc[:<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key)</span></span></span><span class="hljs-function">:</span></span> stream = hashlib.sha256(iv + key).digest() stream = hashlib.sha256(stream + iv + key).digest() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ecc.xor(enc[<span class="hljs-number"><span class="hljs-number">8</span></span>:], stream) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>): s = decrypt(hashlib.sha256(str(i)).digest()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bytearray(s): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c &lt; <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> c &gt;= <span class="hljs-number"><span class="hljs-number">128</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> s <span class="hljs-comment"><span class="hljs-comment"># ecc_is_too_s3cure break</span></span></code> </pre><br>  Thus, the flag is the line "ecc_is_too_s3cure". <br><br><h4>  Reverse engineering.  Shadelt900 </h4><br>  Reverse engineering is another popular job category.  In addition to CTF, there is a Best Reverser contest in the PHDays competition program. <br><br>  The task Shadelt900, as well as the previous three, was part of the PHDays IV CTF Quals program, which took place in January 2014.  Commands had to decrypt an image called 'derrorim_enc.bmp'.  The means used to encrypt it was known - it is called Shadelt9000.exe, but the decryptor could not be found.  Here is this image: <br><br><img src="http://i.imgur.com/y60HKL7.jpg" alt="image"><br><br>  A closer look at the Shadelt9000.exe file makes it clear that the application uses OpenGL.  Also there is a copyright inflate 1.2.8 Copyright 1995-2013 Mark Adler, indicating that the program uses the popular compression library zlib. <br><br>  If you can see in the disassembler where the calls to the zlib functions come from, you can quickly find such a piece of code: <br><br><img src="http://i.imgur.com/Qcxjksf.png" alt="image"><br><br>  At addresses 0x47F660 and 0x47F7B8 are located data arrays, packed zlib.  Unpack them: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> zlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decompress <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> unZ base = <span class="hljs-number"><span class="hljs-number">0x47C000</span></span> - <span class="hljs-number"><span class="hljs-number">0x7AE00</span></span> <span class="hljs-comment"><span class="hljs-comment"># data section base ab=open("ShadeIt9000.exe", "rb").read() open("1.txt", "w").write(unZ(ab[0x47F660-base:],-15)) open("2.txt", "w").write(unZ(ab[0x47F7B8-base:],-15))</span></span></code> </pre><br>  After unpacking, the 1.txt file contains a pixel shader: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#version 330 uniform sampler2D u_texture; uniform sampler2D u_gamma; varying vec4 texCoord0; varying vec3 v_param; uint func(vec3 co){ return uint(fract(sin(dot(co ,vec3(17.1684, 94.3498, 124.9547))) * 68431.4621) * 255.); } uvec3 rol(uvec3 value, int shift) { return (value &lt;&lt; shift) | (value &gt;&gt; (8 - shift)); } const uvec3 m = uvec3(0xff); void main() { uvec3 t = uvec3(texture2D(u_texture, vec2(texCoord0)).rgb * 0xff) &amp; m; uvec3 g = uvec3(texture2D(u_gamma, vec2(texCoord0)).rgb * 0xff) &amp; m; int s = int(mod(func(v_param), 8)); t = rol(t, s); vec3 c = vec3((t ^ g) &amp; m) / 0xff; gl_FragColor = vec4(c, 1.); }</span></span></code> </pre><br><br>  File 2.txt contains the vertex shader: <br><br><pre> <code class="python hljs">attribute vec3 a_param; varying vec4 texCoord0; varying vec3 v_param; void main(void) { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; texCoord0 = gl_MultiTexCoord0; v_param = a_param; }</code> </pre><br>  The main information about the pixel shader is highlighted in red: <br><br><img src="http://i.imgur.com/Synu9MG.png" alt="image"><br><br>  The variable t is the current element of the processed texture (input file), <br>  and in variable g, the current gamma element (generated in a pseudo-random fashion). <br>  In the variable s, we see some value used later for the cyclic shift s. <br>  The output value is actually calculated as <br><br> <code>(rol(t,s) ^ g)</code> <br> <br>  And if you run the program several times with the same input file, then for each element the value of g will change from launch to launch, and t and s will remain the same. <br><br>  Find how gamma is generated: <br><br><pre> <code class="python hljs">unsigned char *pbGamma = malloc(cbGamma); srand(time(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cbGamma; i++) { pbGamma[i] = rand(); }</code> </pre><br>  It can be seen that it depends on the current time. <br><br>  From the source archive you can find out that the file derrorim_enc.bmp was created on January 21, 2014 at 18:37:52. <br>  We get the value that the time () function would return at that moment: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> hex(int(time.mktime((<span class="hljs-number"><span class="hljs-number">2014</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>,<span class="hljs-number"><span class="hljs-number">37</span></span>,<span class="hljs-number"><span class="hljs-number">52</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))</code> </pre><br><br>  <b>0x52de8640</b> <br><br>  Now copy the file ShadeIt9000.exe to ShadeIt9000_f.exe and fix it. <br><br>  At offset 00015557 need bytes <br><br> <code>E8 A5 31 01 00</code> <br> <br>  replaced by <br><br> <code>B8 40 86 DE 52</code> <br> <br>  This is equivalent to replacing <br><br>  <code>call _time</code> on <code>mov eax,52de8640h</code> . <br><br>  Thus, we have received a version of ShadeIt9000_f, which will always encrypt with the same gamma that was at the time of encryption of the file of interest. <br>  Now you need to prepare values ‚Äã‚Äãthat will help decipher the image: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os bmp=open(<span class="hljs-string"><span class="hljs-string">"derrorim_enc.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>).read() hdr = bmp[:<span class="hljs-number"><span class="hljs-number">0x36</span></span>] abData = bytearray(bmp[<span class="hljs-number"><span class="hljs-number">0x36</span></span>:]) cbBody = len(bmp) - len(hdr) open(<span class="hljs-string"><span class="hljs-string">"00.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>).write(hdr + <span class="hljs-string"><span class="hljs-string">'\0'</span></span>*cbBody) open(<span class="hljs-string"><span class="hljs-string">"XX.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>).write(hdr + <span class="hljs-string"><span class="hljs-string">'\2'</span></span>*cbBody) os.system(<span class="hljs-string"><span class="hljs-string">"ShadeIt9000_f.exe 00.bmp"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"ShadeIt9000_f.exe XX.bmp"</span></span>)</code> </pre><br>  In the file 00_enc.bmp will be the result of encoding the image, consisting of zero bytes.  This will be the gamma in its purest form. <br><br>  The XX_enc.bmp file will contain the result of encoding the image, consisting of bytes with value 2. This will help us know how many bits each byte cyclically shifted. <br><br>  Finally, decoding Shadelt9000: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v,i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((v&lt;&lt;i) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) | ((v&gt;&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>-i)) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v,i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((v&gt;&gt;i) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) | ((v&lt;&lt;(<span class="hljs-number"><span class="hljs-number">8</span></span>-i)) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)) dRot = {rol(<span class="hljs-number"><span class="hljs-number">1</span></span>,i):i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">8</span></span>)} bmp=open(<span class="hljs-string"><span class="hljs-string">"derrorim_enc.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>).read() hdr = bmp[:<span class="hljs-number"><span class="hljs-number">0x36</span></span>] abData = bytearray(bmp[<span class="hljs-number"><span class="hljs-number">0x36</span></span>:]) abGamma = bytearray(open(<span class="hljs-string"><span class="hljs-string">"00_enc.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>).read()[<span class="hljs-number"><span class="hljs-number">0x36</span></span>:]) abRot = bytearray(open(<span class="hljs-string"><span class="hljs-string">"XX_enc.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>).read()[<span class="hljs-number"><span class="hljs-number">0x36</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(abGamma): abRot[i] = dRot[abRot[i] ^ b] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(abGamma): abData[i] = ror(abData[i] ^ b, abRot[i]) open(<span class="hljs-string"><span class="hljs-string">"derrorim.bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>).write(hdr + str(abData))</code> </pre><br>  we get: <br><br><img src="http://i.imgur.com/Yk7lNvC.png" alt="image"><br><br>  Above was described the correct, but not the most effective way to solve a task.  There is a shorter way. <br><br>  Immediately behind the vertex shader at addresses 0x47F848 and 0x47F9A0 lies the packed zlib code of the pixel and vertex shader to perform the inverse transform.  Perhaps he was accidentally forgotten by the developer of the task.  And maybe left intentionally. <br><br>  The vertex shader codes for encryption and decryption are identical, so there is no point in touching them.  And what happens if you replace the pixel shader? <br><br>  Copy ShadeIt9000_f.exe to ShadeIt9000_d.exe and fix it: <br><br> <code>00015775: 60 F6 ==&gt; 48 F8</code> <br> <br>  Then run ShadeIt9000_d.exe derrorim_enc.bmp.  And we get the decrypted file derrorim_enc_enc.bmp, which (with the exception of small artifacts) is the same as the one we decrypted with the Python script. <br><br>  That's all for today!  Thank you all for your attention, we will be happy to answer questions in the comments. <br><br>  We remind you that the PHDays IV CTF final will take place on May 21 and 22 during the Positive Hack Days forum.  It will be possible to follow the course of the competition not only directly on the court, but also with the help of mobile applications.  Follow the <a href="http://www.phdays.ru/ctf/">news</a> ! <br><br>  <b>See also:</b> <br><br><ul><li>  <a href="http://habrahabr.ru/company/pt/blog/186310/">PHDays III CTF: An Inside Look (Part 1)</a> </li><li>  <a href="http://habrahabr.ru/company/pt/blog/186800/">PHDays III CTF: An Inside Look (Part 2)</a> </li></ul><br>  We remind you that registration has already begun for participation in online contests <a href="http://hashrunner.phdays.com/">HashRunner</a> and ‚Äú <a href="http://www.phdays.ru/registration/">Competitive Intelligence</a> ‚Äù on PHDays IV! <br><br>  PS An archive of all PHDays CTF and CTF Quals assignments can be found <a href="http://ctfarchive.phdays.com/phd4quals/">on the PHDays website</a> .  So, if you want to test yourself - go ahead! <br><br>  PPS A detailed analysis of the tasks presented in the topic was held on a special webinar, which was moderated by Dmitry Sklyarov.  Record of the webinar is available at the link: <a href="http://my.webinar.ru/record/290241/">http://my.webinar.ru/record/290241/</a> . </div><p>Source: <a href="https://habr.com/ru/post/221991/">https://habr.com/ru/post/221991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221977/index.html">Robotic snake to help people</a></li>
<li><a href="../221979/index.html">Synchronize MySQL + Git structure</a></li>
<li><a href="../221983/index.html">US Robotics Pilot 5000 - the first successful PDA. Internals, modem, use with modern OS</a></li>
<li><a href="../221987/index.html">Universal powerful PC the size of a smartphone: Tango PC</a></li>
<li><a href="../221989/index.html">Targeting users: region, city, street</a></li>
<li><a href="../221997/index.html">Introduction to programming the DECT module SC14CVMDECT</a></li>
<li><a href="../221999/index.html">Conflicts when merging csproj files</a></li>
<li><a href="../222001/index.html">IconBIT Toucan Stick 4K Review: Top HDMI Stick on AllWinner A31</a></li>
<li><a href="../222005/index.html">Each environment has its own favicon</a></li>
<li><a href="../222007/index.html">Dependency Injection in C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>