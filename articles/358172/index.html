<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DC / AC inverter: principle of operation, circuitry, firmware</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pulse converters and power electronics in general have always remained something sacred for the majority of amateurs and professionals in the field of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DC / AC inverter: principle of operation, circuitry, firmware</h1><div class="post__text post__text-html js-mediator-article">  Pulse converters and power electronics in general have always remained something sacred for the majority of amateurs and professionals in the field of electronics development.  The article highlights perhaps the most interesting topic among DIY-makers and fans of alternative energy - the formation of a sinusoidal voltage / current from DC. <br><br>  I think many of you probably saw the advertisement, or read the article, where was the phrase "pure sine."  That's it about him and will be discussed, but not about the marketing component, but about only technical implementation.  I will try to explain as clearly as possible about the principles of operation, about standard (and not so) circuit solutions, and most importantly, we will write and analyze the software for the STM32 microcontroller, which will generate the necessary signals for us. <br><br>  Why STM32?  Yes, because now it is the most popular MK in the CIS: there is a lot of Russian-language information on them, there are a lot of examples, and most importantly, these MK and debugging tools are very cheap for them.  Frankly, in a commercial project, I would put only TMS320F28035 or a similar DSP from the Piccolo series from TI, but this is a completely different story. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One thing is important - STM32 allows you to stably control simple ‚Äúhousehold‚Äù power converters on which the <s>fate of the world</s> does not work any NPP or data center. <br><br><img src="https://habrastorage.org/webt/lv/df/cu/lvdfcunjwdp6xfp7zp1t_gbpuw8.png"><br><br>  This is the picture of control signals that must be obtained in order to convert a constant current into an alternating current.  And yes - here it is the sine!  Like in that movie: ‚ÄúSee the gopher?  - Not.  - And he is ... " <br><br>  It is interesting to know how the sine is formed?  I would like to know how the kilowatts of energy are still pumping <s>oil</s> ?  Then welcome under the cat! <br><a name="habracut"></a><br><h2>  1. Topology for the formation of a sinusoidal signal </h2><br>  If you ask the crowd of electronics engineers: ‚ÄúHow can a sine wave be formed?‚Äù, Then sentences with a dozen different methods will sprinkle, but which one do we need?  Let's push off from the original task - we need to turn, for example, 380V 10A into alternating voltage 230V.  In general, this is a ‚Äúclassic‚Äù case, we can see it in any good on-line UPS or inverter.  It turns out we need to convert the power to about 4 kW, and even with good efficiency, not weak, right?  I think a similar condition will reduce the number of options for "drawing" the sine.  So what remains for us? <br><br>  In power converters up to 6-10 kW, two main topologies are used: a full bridge and a ‚Äúhalf bridge‚Äù with a through neutral.  They look <u>like this</u> : <br><br>  1) Topology with pass-through neutral <br><br><img src="https://habrastorage.org/webt/tn/ly/ju/tnlyjuejfaeh5fbk8anz8eio4m8.png"><br><br>  This topology is very often found in budget UPSs with a sine output, although such authorities as APC and GE do not disdain to use it even at sufficiently large capacities.  What motivates them to this?  Let's look at the advantages and disadvantages of this topology. <br><br><h4>  Pros: </h4><br><ul><li>  The minimum possible number of power transistors, which means the loss is 2 times smaller and the cost of the device is also lower </li><li>  Pass-through zero.  This simplifies the certification process, especially CE and ATEX.  This is due to the fact that the through zero allows the input protection systems (for example, RCD) to operate as well when an accident occurs in the output circuits after the converter </li><li>  A simple topology that allows us to minimize the cost of the product at small <br>  and medium serial production </li></ul><br><h4>  Minuses: </h4><br><ul><li>  The need for a bipolar power source.  As you can see on the inverter circuit should be served ¬± 380V and zero more </li><li>  Doubled the number of high voltage capacitors.  High-voltage and high-voltage capacitors with small ESR at capacities from 3-4 kW start to be from 20 to 40% <br>  component cost </li><li>  The use of electrolytic capacitors in the "divider".  They dry, pick up capacitors with the same parameters is almost impossible, and if we consider that the parameters of electrolytes change during operation, it is also meaningless.  Replace with a film is possible, but expensive </li></ul><br>  The main advantages and disadvantages are determined, so when is this topology necessary?  My subjective opinion: at capacities up to 500-1000 W, when cost, not reliability, is a fundamental requirement.  An obvious representative of such consumer goods is the stabilizers from ‚ÄúA-electronics‚Äù: cheap, it works somehow and well.  For 60% of consumers in our country, this is sufficient and affordable.  Draw conclusions. <br><br>  2) Bridge topology <br><br><img src="https://habrastorage.org/webt/0f/yd/vl/0fydvlcitxtdtm7jsrsv1ugpq6i.png"><br><br>  Bridge topology ... probably the most understandable and most common topology in power converters, and most importantly accessible to developers, even with little experience.  After 10 kW you will not encounter anything other than a single or three phase bridge.  Why is he so loved? <br><br><h4>  Pros: </h4><br><ul><li>  Very high reliability.  It is mainly due to the quality of the power transistor control system and does not depend on the degradation of components </li><li>  Input capacity required at times, and even an order of magnitude less.  It is only necessary to provide the estimated value of the ESR.  This allows the use of film capacitors while maintaining cost.  Film capacitors - do not dry, lead better in harsh temperatures, the working life is much higher than that of electrolytes </li><li>  Minimal voltage ripple on transistors, which means that transistors can be applied for lower voltage </li><li>  The simplicity and clarity of the algorithms.  This leads to a significant reduction in time for product development, as well as for its commissioning. </li></ul><br><h4>  Minuses: </h4><br><ul><li>  The increased number of power transistors, and therefore more serious cooling is needed.  The increase in the price of transistors, but at the expense of a smaller number of capacitors, this is more likely even a plus </li><li>  Increased driver complexity, especially with requirements for galvanic isolation </li></ul><br>  As you can see from the real drawbacks of the bridge topology, there is only an increased requirement for the cooling of transistors.  Many will think: "Heat is allocated more - it means efficiency is lower!".  Not exactly ... Due to the reduced emissions of EMF and a more ‚Äúrigid‚Äù control system, the efficiency of the two topologies is approximately equal. <br><br>  In 70% of cases, I have to apply a bridge circuit not only in DC / AC inverters, but also in other converters.  This is due to the fact that I design mainly industrial solutions and more often for European customers, and there it has been decided to give a guarantee for 5-15 years for expensive industrial devices.  The classical requirement: ‚ÄúWe want a piece of iron so that we can give a guarantee of 10 years,‚Äù there is no need to choose.  Of course, when people want a device with a minimum price, then it is necessary to start from a specific task when choosing a topology. <br><br>  <u>Small result</u> : this article will provide software for the operation of a bridge converter (H-bridge or Full Bridge), but the principle of sine formation is the same for all topologies.  The code can also be adapted for the 1st topology, but this is yourself. <br><br><h2>  2. Formation of alternating current using a bridge converter </h2><br>  First, let's look at how a bridge converter works.  We look at the circuit and see the transistors VT1-VT4.  They allow us to apply this or that potential to our abstract load (resistor, for example).  If we open the transistors VT1 and VT4, we get the following: VT4 connects one end of the load to minus (GND), and transistor VT1 connects to + 380V, the potential difference ‚Äú380V - 0V‚Äù appears on the load, which is not zero, and therefore the load will begin to flow.  I think everyone remembers that scientists have agreed - the current flows ‚Äúfrom plus to minus.‚Äù  We get this picture: <br><br><img src="https://habrastorage.org/webt/rr/05/oz/rr05oztig6gvhehgpu87sj3dj6c.png"><br><br>  What did we get by opening VT1 and VT4?  We connected our load to the network!  If the resistor is replaced with a light bulb, then it would just catch fire.  And we did not just include the load, but determined the direction of the current flowing through it.  It is very important!  And what happened at that time with VT2 and VT3?  They were closed ... completely ... tightly ... What would happen if all the same VT2 or VT3 were also open?  We look: <br><br><img src="https://habrastorage.org/webt/8y/kx/ch/8ykxch3vlq0z7qrucs4jt4fo8eq.png"><br><br>  Suppose that transistors VT1, VT4 and VT2 are opened.  We recall Ohm's law, look at the channel resistance of high-voltage transistors, for example, IPP60R099P7XKSA1 and see 0.1 Ohm, we have 2 of them in series - it means the resistance of the circuit VT1 and VT2 is about 0.2 Ohm.  Now we calculate the current that goes through this circuit: 380V / 0.2 Ohm = 1900A.  I think everyone understands that this is a short circuit?  I also think everyone understands why VT2 and VT3 should be closed? <br><br>  This "phenomenon" is called - <b>through current</b> .  And it is with him that there is a big war in power electronics.  How to avoid it?  Create a control system whose algorithm will strictly forbid the simultaneous opening of an extra transistor. <br><br>  Why, then, need transistors VT2 and VT3?  Remember I wrote that the direction of the current is very important?  Let's remember what alternating current is.  Actually it is a current that has something variable, in this case the direction of the current.  We have a current flowing in the outlet, which changes its direction 100 times per second.  Let's now close VT1 and VT4, and then open the transistors VT2 and VT3 and get the following picture: <br><br><img src="https://habrastorage.org/webt/14/hp/wq/14hpwqm6ivawim-mxlqwudro014.png"><br><br>  As you can see the direction of the current (indicated by arrows) has changed to the opposite.  Using a bridge allowed us to change the direction of the current, what does that mean?  Yes, we got alternating current! <br><br>  Please note that the bridge has, as it were, 2 diagonals: the first diagonal is formed by VT1 + VT4, and the second diagonal is formed by using VT2 + VT3.  These diagonals work in turn, switching the current first in one direction and then in the other. <br><br>  So we got an alternating current, tell you, but not everything is so simple ... We have a standard - the mains voltage.  It is normalized by two main parameters: voltage and frequency.  Let's take a look at the frequency for now, because the voltage issue is simple and purely circuitry. <br><br>  And so the frequency ... that it is known about it - it is 50 Hz (sometimes 60 Hz in the States).  The signal period is 20 ms.  A sinusoid piece is symmetrical in this case, which means that our 2 half-waves (positive and negative) have the same duration, that is, 10 ms + 10 ms.  I hope everything is clear. <br><br>  What does this mean in the physical sense?  Yes, the fact that we need to change the direction of the current in the load every 10 ms.  We get that at first we have a 10 ms VT1 + VT4 diagonal open, and then it closes and the VT2 + VT3 diagonal opens for the next 10 ms. <br><br><div class="spoiler">  <b class="spoiler_title">What does it mean to open the transistor and what signal to apply to it</b> <div class="spoiler_text">  Let's digress a bit on the principle of transistor control.  I use Mosfet N-channel field-effect transistors. <br><br>  An ‚Äúopen transistor‚Äù is a transistor whose gate (G) has a positive potential (+ 10..18 V) relative to the source (S) and the transistor has changed the channel resistance (SD) from infinitely large (2-100 MŒ©) to small (usually 0.1 - 1 ohm).  That is, the transistor began to conduct current. <br><br>  The ‚Äúclosed transistor‚Äù is a transistor whose gate (G) is pulled to the source (S) and its resistance has changed from small to infinitely large.  That is, the transistor has ceased to conduct. <br><br>  For better acquaintance with the principle of operation of a field-effect transistor or IGBT - I advise you to read a couple of chapters in Semenov‚Äôs book Fundamentals of Power Electronics, or another source, you can also start Wikipedia. <br><br>  To control, we give a signal with Pulse Width Modulation or a more familiar abbreviation - PWM.  The peculiarity of this signal is that it has 2 states: the lower voltage (GND) and the upper voltage (VCC), that is, by supplying it to the gate of the transistor, we either open it or close it ‚Äî there is no other way.  I also advise you to read about PWM in addition, because I described <s>to</s> you superficially <s>for the lazy</s> . </div></div><br>  And so, in order for our bridge to change the direction of the current every 10 ms, we need to send a PWM signal to it, the period of which is 20 ms and the duty cycle 50%.  This means that in 20 ms the shoulder is half the time (10 ms) open and carries current, and the other half is closed.  We need to supply such a PWM to all keys, but with one condition - on the VT1 + VT4 diagonal we submit direct PWM, and on the VT2 + VT3 diagonal already inverse.  Speaking more intelligently, the signal supplied to the diagonal should have a 180 o shift.  I think at this moment your head is boiling in trying to understand the text, so we are looking at its visual presentation: <br><br><img src="https://habrastorage.org/webt/cn/0w/n9/cn0wn9iwb4nsfiec0tfmcpfc02c.png"><br><br>  Now everything is clear?  Not?  Then more ... As you can see, I specifically noted the moments of the opening and closing of the transistors: they open at the "plus" and close at the "minus".  Also, the signals are opposite, that is, inverse: when the blue signal is ‚Äúplus‚Äù, then the green signal is ‚Äúminus‚Äù.  We give a blue signal on one diagonal to one, and a green signal on another - as seen on the oscillogram, our diagonals never open at the same time.  AC is ready! <br><br>  Look at the period.  Specially showed the waveform from the controller outputs, so that my words were not an abstraction.  The signal period is 20 ms, one diagonal is open 10 ms and creates a positive half-wave, the other diagonal also opens for 10 ms and creates a negative half-wave already.  Now I hope everyone understands, and who still do not understand - write in the LAN, I will hold for you an individual lesson on your fingers.  In confirmation of my words, the oscillogram shows our cherished 50 Hz!  Just relax early ... <br><br>  We received an alternating current with a frequency of 50 Hz, but we have a sinusode in the socket, and here the meander is not the case.  Formally, you can apply the meander to the output and supply them with most of the loads, for example, to a pulsed power supply unit anyway: a sine or a meander.  That is, turning on laptops, telephones, televisions, telephones and other things is enough for you, but if you plug in an AC motor, everything will be very bad - it will start to warm up and its efficiency will be significantly less, and in the end it will most likely burn.  Do you think you don't have engines at home?  And the refrigerator compressor?  And a circular heating pump?  The latter generally burn as if made of wood.  The same situation with deep pumps for wells, and indeed a lot with what.  It turns out that a sinusoidal signal at the output of an inverter, stabilizer, or UPS is still important.  Well, you need to create it!  Now the brain explosion will start ... <br><br><h2>  3. The formation of a sinusoidal waveform using PWM </h2><br>  Frankly speaking, I do not know how to present this section in an accessible language.  Suddenly, whoever does not understand, I ask you either to google it additionally, or write in a comment or a LAN ‚Äî I will try to explain to you personally.  The eyes are afraid, and the hands are doing ... <br><br>  Let's see what a regular sine plot looks like: <br><br><img src="https://habrastorage.org/webt/x5/jl/h-/x5jlh-mkmnealtyciflxm5wpegu.jpeg"><br><br>  We see 2 axes: one axis with a period of pi, pi / 2 and further, the second with an amplitude of -1 to +1.  In our problem, the period is measured in seconds and is 20 ms or 10 ms for each half-wave.  Everything is simple and clear, but with amplitude more fun - just accept as an axiom that the amplitude is from 0 to 1000. This is the value of the duty cycle that the microcontroller sets, that is, 100 is 10%, 500 - 50%, 900 - 90 %  I think the logic is clear.  In the next chapter, you will understand why from 0 to 1000, but for now we will reorganize our graph to our values: <br><br><img src="https://habrastorage.org/webt/cj/m4/cd/cjm4cdxgxb1gresudvtgdjjqn5o.jpeg"><br><br>  This is how the <s>smoker‚Äôs</s> sinus graph looks like, which corresponds to our task.  As you can see, I did not identify negative half-time, because  here it is implemented not by using a sinusoidal signal, but by changing the direction of the current by switching the bridge diagonals. <br><br>  On the X axis, we have time, and on the Y axis, the duty cycle of our PWM signal.  We need to draw a sine using SHIM.  Remember the geometry at school, how did we build the graphics?  That's right, by the points!  And how many points?  Let's build a sine by several points O1 (0,0) + O2 (5,1000) + O3 (10,0) + O4 (15, -1000) + O5 (20, 0) and we get the following sine: <br><br><img src="https://habrastorage.org/webt/5d/wo/gn/5dwogn7oehjljaau4uh2qjtlv0w.png"><br><br>  We have built and see that, in principle, this signal is more like a sine than a normal meander, but it is still not a sine for now.  Let's increase the number of points.  This is by the way called ‚Äúsignal resolution‚Äù or, in this case, ‚ÄúPIM discretization‚Äù.  And how do you know the coordinates of these points?  With the extreme, it was just ... <br><br><h4>  Calculation of values ‚Äã‚Äãfor the formation of sine </h4><br>  As I said earlier, the sine is quite symmetrical.  If we build 1/4 of the period, that is, from 0 to 5 ms, then duplicating this piece further - we can build a sine for an infinitely long time.  And so the formula: <br><img src="https://habrastorage.org/webt/er/jm/n3/erjmn3wv1qkivp5kxg1w0twaixo.png"><br>  And so in order: <br><br><ul><li>  n - the value of the duty cycle at this discrete point </li><li>  A is the signal amplitude, that is, the maximum value of the duty ratio.  We have 1000 </li><li>  pi / 2 - 1/4 of the sine period falls into pi / 2, if we consider 1/2 of the period, then pi </li><li>  x - step number </li><li>  N - the number of points </li></ul><br>  Let‚Äôs make an example of conveniently the condition that we have 5 points.  It turns out we have 1 step = 1 ms, it will allow you to easily build a schedule.  The discretization step is considered simple: the period in which we plot the graph (5 ms) is divided by the number of points.  Let's bring the formula to the human mind: <br><br><img src="https://habrastorage.org/webt/tk/4g/cs/tk4gcse-rse5-tyaae6a0bewypw.png"><br>  We get a sampling step of 1 ms.  The formula for calculating the duty cycle will be, for example, in excel and we will get the following table: <br><br><img src="https://habrastorage.org/webt/dt/zy/tz/dtzytzlg1dd9e9kzwuelxbjhnuw.png"><br><br>  Now back to our sine plot and build it again, but for more points and see how it changes: <br><br><img src="https://habrastorage.org/webt/vo/um/l3/vouml3yuxohvo9tpblm9ig4_sgk.png"><br><br>  As you can see, the signal is much more like a sine, even taking into account my skill in drawing, and more precisely in the level of laziness)) I think the result does not require an explanation?  According to the results of construction, we derive an axiom: <br><blockquote><h4>  The more points, the higher the signal sampling, the more ideal the shape of the sinusoidal signal </h4></blockquote><br>  And so, how many points will we use ... It is clear that the more the better.  How to calculate: <br><br><ol><li>  I use for the article an old microcontroller STM32F100RBT6 (debugging STM32VL-Discovery), its frequency is 24 MHz. </li><li>  Consider how many cycles will last a period of 20 ms: 24,000,000 Hz / 50 Hz = 480,000 ticks </li><li>  This means half of the period lasts 240,000 ticks, which corresponds to a frequency of 24 kHz.  Want to increase the carrier frequency - take the stone faster.  24 kHz, our ears will still be heard, but for tests or a piece of iron, standing in the basement will go.  A little later, I plan to transfer to F103C8T6, and there already 72 MHz. </li><li>  240,000 ticks ... It is logical to ask 240 points for half the period.  The timer will update the duty ratio every 1000 ticks or every 41.6 Œºs </li></ol><br>  With discreteness of PWM decided, 240 points on the floor of the period with a margin is enough to get the waveform at least as good as the network.  Now consider the table, also in excel as the easiest option.  We get the following schedule: <br><br><img src="https://habrastorage.org/webt/vz/u0/qz/vzu0qzvv_s5nnk9rpk19bfpqelu.png"><br><br>  The source of the table and values ‚Äã‚Äãcan be taken by reference - <a href="https://drive.google.com/open%3Fid%3D1UHGcnm9O86g5xv_eIErNKxTtDlXVw8nr">here</a> . <br><br><h2>  4. Control the bridge transducer to form a sine </h2><br>  We got a sine table and what to do with it?  It is necessary to transfer these values ‚Äã‚Äãwith a certain discretization step, which is known to us.  It all starts with the fact that the timer was initialized - time 0, duty cycle zero.  Next, we count the sampling step of 41.66 Œºs and write the PWM value from table 13 (0.13%) to the timer, count another 41.66 Œºs and write 26 (0.26%) and so on all 240 values.  Why 240?  We have 120 steps for 1/4 period, and we need to draw 1/2 period.  The duty ratio is the same, only after they have reached 1000, we write it in the reverse sequence and we get a decrease in sine.  At the output, we will have the following waveform: <br><br><img src="https://habrastorage.org/webt/ev/ls/3n/evls3nttkufuiz55hxpo4nb7v7w.png"><br><br>  As you can see, we received a bunch of PWM values ‚Äã‚Äãin a clearly defined period and its duration is: 240 steps x 41.66 (!) Œús = 9998.4 Œºs = 9.9984 ms ~ 10 ms.  We got half the period for a 50Hz network frequency.  As you can see, there are two signals again and they are out of phase, just what is needed to control the diagonals of the bridge.  But excuse me, where is the sine you ask?  The moment of truth has come!  Let's now give the signal from the output of the microcontroller to the low-pass filter, I made a simple low-pass filter on the RC circuits with nominal values ‚Äã‚Äãof 1.5 kŒ© and 0.33 ŒºF (they were just at hand) and I got the following result: <br><br><img src="https://habrastorage.org/webt/s7/h9/ps/s7h9psfeeu2glggk0wy2j_nvxyy.png"><br><br>  Voila!  Here it is our long-awaited sinus!  The red beam of the oscilloscope is the signal before the low-pass filter, and the yellow beam is the signal after filtering.  LPF cut off all frequencies above 321 Hz.  We still have the main signal of 50 Hz, and of course its harmonics with a small amplitude.  If you want to clear the signal perfectly, then make a low-pass filter with a cut-off frequency of about 55-60 Hz, but for now it doesn‚Äôt matter, we just had to check whether we have a sinus or not.  By the way ... I have synchronization of the oscilloscope on the yellow beam (arrow on the right of the screen) and we see its frequency at the bottom of the screen - an ideal 50 Hz.  What more could you want?  Perhaps everything, it remains to decide what signal and where to submit.  Let's look at this picture: <br><br><img src="https://habrastorage.org/webt/d-/u9/af/d-u9afnw820ogdix_v8fpuefstw.png"><br><br>  If you draw on the first oscillogram in the article, you will see that the signal in yellow and blue better have the same phase, that is, they become positive at the same time and open the transistors.  These 2 signals open VT1 + VT4 diagonal.  Accordingly, 2 other signals also have the same phase and open another diagonal.  Now we do not just change the direction of the current, but also set the amplitude with the help of PWM so that it varies sinusoidally.  Now consider the same schema, but with currents: <br><br><img src="https://habrastorage.org/webt/di/sp/pw/disppwegsawq_jkn4nghglzk-e4.png"><br><br>  As you can see, the current through the load flows in the opposite direction, changing direction with a frequency of 50 Hz, and the modulated PWM applied to the transistors VT1 and VT2 allows you to draw a sinusoidal waveform on half-waves. <br><br>  Low-pass filter (low-pass filter) is made on inductance L1 and capacitor C2.  I advise you to consider the cutoff frequency for this filter to be less than 100 Hz, this will minimize the voltage ripple on the output. <br><br>  For dessert, I will show part of the scheme of a real device with a similar topology and filter, it is large, so we download the PDF <a href="https://drive.google.com/open%3Fid%3D15Z1f4nJWIszjpOfJq5Cy0yaBCHMGtCWM">here</a> . <br><br><h2>  5. Fight against through currents </h2><br>  I think it is no secret to anyone that there is nothing perfect?  The same with Mosfet-s, they have a number of drawbacks and we will consider one of them - a large gate capacity.  That is, in order for us to open the transistor, it is necessary not only to energize, but also to charge the capacitor with this very voltage, therefore the front and falloff of the signal is delayed.  This leads to the fact that at the signal boundary there can be a point in time when one transistor has not fully closed yet, and the other has already begun to open. <br><br>  I advise you to read more about this phenomenon, for example, in <a href="https://drive.google.com/open%3Fid%3D1MJE7AEr8NsVjp6V2aBEpU6XA8TF3WA5O">this article</a> .  I just tell you how to deal with it.  So that the transistors have time to close normally before the opening of the next arm between the control signals, they introduce dead-time or, more simply, a time delay.  We have such a delay will be introduced between the control signals on transistors VT3 and VT4, because  They provide switching half-waves.  On transistors with modulated PWM (VT1 and VT2) such delays already exist - the sine begins with a duty cycle of 0% and ends also at 0%.  This delay is 1 sampling long, that is, 41.6 Œºs. <br><br>  And so - it is necessary to realize the dead time between the blue and the green beam / signal.  On any controller, such a delay can be made programmatically, but this is not good - the program will hang or stay and your device <s>and apartment will be</s> already on fire.  Therefore, in power electronics it is worth using only hardware.  On all specialized motor controls, hardware deadtime is provided on all outputs of PWM and channels, but STM32 is still a general-purpose MK, so everything is simpler, but it will perform our function. <br><br>  We need a timer TIM1, only he knows how to insert a hardware delay between the signals, in the section on writing software, I will tell you how to do it, and now we are looking at the result and what should be in general: <br><br><img src="https://habrastorage.org/webt/2q/s1/o7/2qs1o7yvllytmxvus3x3zrezoxq.png"><br><br>  To see the delay, we ‚Äústretch‚Äù the signal on the oscilloscope, since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It has a short duration of about 300 ns. </font><font style="vertical-align: inherit;">The required time duration of deadtime must be calculated for each specific task in order to protect the transistors from through-currents. </font><font style="vertical-align: inherit;">The delay time is adjusted when the TIM1 timer is initialized (configured). </font><font style="vertical-align: inherit;">This delay is present at both the front and the low signal.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Writing firmware for the STM32 microcontroller </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we‚Äôve probably come to the most important and interesting part. We have disassembled the physics of the process, the principle of operation seems to be clear, the necessary minimum of protection is also defined - it remains only to implement all this in real hardware. To do this, I use the STM32VL-Discovery shawl, I got it by the way back in 2011, at a time when ST distributed debugs at their conferences and since then she lay packed - opened the packaging just a couple of months ago, like the shelf life has not passed))) My ‚Äústand‚Äù for writing the code looks like this:</font></font><br><br><img src="https://habrastorage.org/webt/yb/es/fr/ybesfrpaq3dhfrliz6z517bwy-8.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now go through the connection. </font><font style="vertical-align: inherit;">Since I need to form two signals with different frequencies, I had to use the PWM outputs on different timers. </font><font style="vertical-align: inherit;">TIM1 generates a signal that sets the main frequency of 50 Hz and supplies them to transistors VT3 and VT4. </font><font style="vertical-align: inherit;">The PIMA channel # 3 + its complementary output is used. </font><font style="vertical-align: inherit;">Yes, yes, in STM32, hardware deadtime can only be configured between normal and complementary single-channel output, which I didn‚Äôt like much. </font><font style="vertical-align: inherit;">The process of forming the sine itself is transmitted to the timer TIM2, there is no need for a delay here (previously wrote why), and it is quite suitable for generating a modulated signal on VT1 and VT2.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Used outputs: </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PA10 - normal PWM output, channel 3 of TIM1 timer, which generates 50 Hz per transistor VT3 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PB15 - complementary output of channel 3 of the timer TIM1, which is fed to the transistor VT4 </font></font></li><li> PA0 ‚Äî    ‚Ññ1  TIM2.     VT1 </li><li> PA1 ‚Äî    ‚Ññ2  TIM2.     VT2 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project is implemented in Keil 5, it will be attached to the archive at the end of the article. I don‚Äôt hope to tell how to create a project and similar obvious things, if such questions arise, I advise you to look at how to do it in Google or on youtube. All code is written in CMSIS (registers), because to use any additional levels of abstraction in the converter control system is simply a sin! In ST, these are SPL libraries and more current HALs. For interest I worked with those and with those, the conclusion is full of trash. HAL is so crazy in general, and for applications with hard real-time just doesn‚Äôt fit the word at all. In some critical moments, the registers were several times faster, by the way, I found more than one article on the Internet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some will surely ask: ‚ÄúWhy not use DMA?‚Äù This can and should be done, but this article is more of an introductory nature, and the MC itself doesn‚Äôt do anything complicated in terms of computation, so the core performance isn‚Äôt exactly up to you. </font><font style="vertical-align: inherit;">DMA is good, but you can do without DMA without any potential problems. </font><font style="vertical-align: inherit;">Let's clarify what we need to do in the program:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create an array with our 240 sine points </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adjust the clocking circuit at 24 MHz by selecting the source external quartz resonator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set the TIM1 timer to generate 50 Hz PWM with deadtime enabled </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adjust TIM2 to generate PWM with 24 kHz carrier frequency </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set the timer TIM6, which generates 24 kHz interrupts. </font><font style="vertical-align: inherit;">In it, we will send the next value of the duty cycle from the table to the timer TIM2, as well as alternate the generation of half-waves</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing complicated, right? </font><font style="vertical-align: inherit;">Then let's go ...</font></font><br><br><h4>  6.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create sine table </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is simple, just an array. </font><font style="vertical-align: inherit;">The only thing to remember is that we have 120 points from 0 to 1000. We need to add 120 more points to the table, but in reverse order:</font></font><br><br><pre><code class="cpp">uint16_t sin_data[240] = <font></font>
{13,26,39,52,65,78,91,104,117,130,143,156,169,182,195,207,220,233,246,258,<font></font>
271,284,296,309,321,333,346,358,370,382,394,406,418,430,442,453,465,477,488,500,<font></font>
511,522,533,544,555,566,577,587,598,608,619,629,639,649,659,669,678,688,697,707,<font></font>
716,725,734,743,751,760,768,777,785,793,801,809,816,824,831,838,845,852,859,866,<font></font>
872,878,884,891,896,902,908,913,918,923,928,933,938,942,946,951,955,958,962,965,<font></font>
969,972,975,978,980,983,985,987,989,991,993,994,995,996,997,998,999,999,999,1000,<font></font>
999,999,999,998,997,996,995,994,993,991,989,987,985,983,980,978,975,972,969,965,<font></font>
962,958,955,951,946,942,938,933,928,923,918,913,908,902,896,891,884,878,872,866,<font></font>
859,852,845,838,831,824,816,809,801,793,785,777,768,760,751,743,734,725,716,707,<font></font>
697,688,678,669,659,649,639,629,619,608,598,587,577,566,555,544,533,522,511,500,<font></font>
488,477,465,453,442,430,418,406,394,382,370,358,346,333,321,309,296,284,271,258,<font></font>
246,233,220,207,195,182,169,156,143,130,117,104,91,78,65,52,39,26,13};</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2. </font><font style="vertical-align: inherit;">Setting the clocking system</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setting clocking in the STM32 is very flexible and convenient, but there are several nuances. </font><font style="vertical-align: inherit;">The sequence itself looks like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Switch to clocking from the integrated RC-chain (HSI) to external quartz (HSE), then wait for the ready flag</font></font><br>
<br>
<pre><code class="cpp">RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); 	// Enable HSE<font></font>
while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));	// Ready start HSE </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) The controller's flash memory is slightly slower than the kernel. For this, we configure flash clocking. </font><font style="vertical-align: inherit;">If this is not done, the program will start, but will periodically fall: a pair of kW and unstable software are incompatible things.</font></font><br>
<br>
<pre><code class="cpp">FLASH-&gt;ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;  // Cloclk Flash memory</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) We set up dividers for the system bus clocking (AHB) and for the bus peripherals, of which there are already two pieces: APB1 and APB2. </font><font style="vertical-align: inherit;">We need the maximum frequency, so we do not divide anything and the division factors are made equal to 1.</font></font><br>
<br>
<pre><code class="cpp">RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1;	// AHB = SYSCLK/1<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV1;	// APB1 = HCLK/1<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV1;	// APB2 = HCLK/1</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4) Adjust the frequency multiplier (PLL) predivider, which stands in front of him and divides the frequency of quartz by 2. We get that 8 MHz divided by 2 and received 4 MHz. </font><font style="vertical-align: inherit;">Now we need to multiply them by 6, so that the output is 24 MHz. </font><font style="vertical-align: inherit;">Before writing registers, we first erase their contents just in case.</font></font><br>
<br>
<pre><code class="cpp">RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLMULL; // clear PLLMULL bits<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLSRC;	// clearn PLLSRC bits<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLXTPRE; // clearn PLLXTPRE bits<font></font>
<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLSRC_PREDIV1;  // source HSE<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLXTPRE_PREDIV1_Div2; // source HSE/2 = 4 MHz<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLMULL6; // PLL x6: clock = 4 MHz * 6 = 24 MHz</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5) Now you need to turn on the frequency multiplier (PLL) and wait for the readiness flag:</font></font><br>
<br>
<pre><code class="cpp">RCC-&gt;CR |= RCC_CR_PLLON; // enable PLL                      	<font></font>
while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0) {} // wait till PLL is ready </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6) Finally, we configure the clock source for the system bus (AHB) output of our frequency multiplier, which has the cherished 24 MHz. </font><font style="vertical-align: inherit;">Pre-register the contents of the clean, set the desired bit and wait for the ready flag:</font></font><br>
<br>
<pre><code class="cpp">RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; // clear SW bits<font></font>
RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // select source SYSCLK = PLL<font></font>
while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // wait till PLL is used </code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, we have this clocking setting function:</font></font><br>
 <br>
<pre><code class="cpp">void RCC_Init (void){<font></font>
<font></font>
RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); // Enable HSE<font></font>
while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY));   // Ready start HSE<font></font>
<font></font>
FLASH-&gt;ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY; // Cloclk Flash memory<font></font>
<font></font>
RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1; // AHB = SYSCLK/1<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV1; // APB1 = HCLK/1<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV1; // APB2 = HCLK/1<font></font>
<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLMULL; // clear PLLMULL bits<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLSRC; // clearn PLLSRC bits<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_PLLXTPRE; // clearn PLLXTPRE bits<font></font>
<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLSRC_PREDIV1; // source HSE<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLXTPRE_PREDIV1_Div2; // source HSE/2 = 4 MHz<font></font>
RCC-&gt;CFGR |= RCC_CFGR_PLLMULL6; // PLL x6: clock = 4 MHz * 6 = 24 MHz<font></font>
<font></font>
RCC-&gt;CR |= RCC_CR_PLLON; // enable PLL<font></font>
while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0) {} // wait till PLL is ready<font></font>
RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; // clear SW bits<font></font>
RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // select source SYSCLK = PLL<font></font>
while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // wait till PLL is used<font></font>
}</code></pre> <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Setting the timer TIM1 and "dead time"</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will give a general setting of the timer, it is described in detail in the reference manual - I advise you to read the purpose of each register. </font><font style="vertical-align: inherit;">And there are basic articles on working with PWM on the Internet. </font><font style="vertical-align: inherit;">I have very well commented on the code itself, so I‚Äôll quote immediately the code of the function for initializing the timer TIM1, and analyze the most interesting moments:</font></font><br>
<br>
<pre><code class="cpp">void PWM_50Hz_Init (void){<font></font>
<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN; // enable clock for TIM1<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; // enable clock for port A<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN; // enable clock for port B<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_AFIOEN; // enable clock for alternative gpio<font></font>
	<font></font>
/****************************** Setting PA10 **************************************/<font></font>
<font></font>
GPIOA-&gt;CRH 	&amp;= ~GPIO_CRH_CNF10; // setting out alternative push-pull for PWM<font></font>
GPIOA-&gt;CRH 	|= GPIO_CRH_CNF10_1;<font></font>
<font></font>
GPIOA-&gt;CRH	&amp;= ~GPIO_CRH_MODE10;<font></font>
GPIOA-&gt;CRH	|= GPIO_CRH_MODE10; // gpio speed 50 MHz<font></font>
		<font></font>
/***************************** Setting PB15 ***************************************/<font></font>
<font></font>
GPIOB-&gt;CRH 	&amp;= ~GPIO_CRH_CNF15; // setting complementary for CH3N<font></font>
GPIOB-&gt;CRH 	|= GPIO_CRH_CNF15_1;<font></font>
<font></font>
GPIOB-&gt;CRH	&amp;= ~GPIO_CRH_MODE15;<font></font>
GPIOB-&gt;CRH	|= GPIO_CRH_MODE15; // gpio speed 50 MHz<font></font>
<font></font>
/************************** Config PWM channel ************************************/<font></font>
<font></font>
TIM1-&gt;PSC = 480-1; // div for clock: F = SYSCLK / [PSC + 1]<font></font>
TIM1-&gt;ARR = 1000; // count to 1000<font></font>
TIM1-&gt;CR1 &amp;= ~TIM_CR1_CKD; // div for dead-time: Tdts = 1/Fosc = 41.6 ns<font></font>
TIM1-&gt;CCR3 = 500; // duty cycle 50%<font></font>
<font></font>
TIM1-&gt;CCER |= TIM_CCER_CC3E | TIM_CCER_CC3NE; // enable PWM complementary out<font></font>
TIM1-&gt;CCER &amp;= ~TIM_CCER_CC3NP; // active high level: 0 - high, 1 - low<font></font>
<font></font>
TIM1-&gt;CCMR2 &amp;= ~TIM_CCMR2_OC3M;<font></font>
TIM1-&gt;CCMR2 |= TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3M_1; // positiv PWM<font></font>
<font></font>
TIM1-&gt;BDTR &amp;= ~TIM_BDTR_DTG; // clear register<font></font>
TIM1-&gt;BDTR |= TIM_BDTR_DTG_2 | TIM_BDTR_DTG_1 | TIM_BDTR_DTG_0;	 // value dead-time<font></font>
TIM1-&gt;BDTR |= TIM_BDTR_MOE | TIM_BDTR_AOE; // enable generation output<font></font>
	<font></font>
/*******************************************************************************/<font></font>
<font></font>
TIM1-&gt;CR1 &amp;= ~TIM_CR1_DIR; // count up: 0 - up, 1 - down<font></font>
TIM1-&gt;CR1 &amp;= ~TIM_CR1_CMS; // aligned on the front signal	<font></font>
TIM1-&gt;CR1 |= TIM_CR1_CEN; // start count<font></font>
	<font></font>
}</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The duty cycle is fixed and never changes, as well as the frequency. </font><font style="vertical-align: inherit;">It is this timer that sets the time and sequence of the diagonals:</font></font><br>
<br>
<pre><code class="cpp">TIM1-&gt;CCR3 = 500; // duty cycle 50%</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The duration of the pause "dead time" depends strongly on the TDTS time parameter, which is configured here:</font></font><br>
<br>
<pre><code class="cpp">TIM1-&gt;CR1 &amp;= ~TIM_CR1_CKD; // div for dead-time: Tdts = 1/Fosc = 41.6 ns</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Its duration is 1 clock tick. </font><font style="vertical-align: inherit;">If you look in the reference manual, you can see that the CKD bits can, for example, make Tdts equal to 2, 8 ticks, and so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The very same pause time is set here:</font></font><br>
<br>
<pre><code class="cpp">TIM1-&gt;BDTR |= TIM_BDTR_DTG_2 | TIM_BDTR_DTG_1 | TIM_BDTR_DTG_0;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you open the reference manual RM0041, you will see formulas for calculating DT. </font><font style="vertical-align: inherit;">As you can see the Tdts parameter is fundamental there:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ht/7-/dy/ht7-dyrbbx2vtyjawhmdirpjpxi.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.4. </font><font style="vertical-align: inherit;">Setting the timer TIM2, forming a sine</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs still easier here, probably there‚Äôs no point in explaining something in the setup, for comments are already redundant. </font><font style="vertical-align: inherit;">If you have questions - wait for them in the comments.</font></font><br>
<br>
<pre><code class="cpp">void PWM_Sinus_Init (void){<font></font>
RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM2EN; // enable clock for TIM2<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN; // enable clock for port A<font></font>
RCC-&gt;APB2ENR |= RCC_APB2ENR_AFIOEN; // enable clock for alternative gpio<font></font>
<font></font>
/****************************** Setting PA0 ***************************************/<font></font>
<font></font>
GPIOA-&gt;CRL 	&amp;= ~GPIO_CRL_CNF0; // setting out alternative push-pull for PWM1_CH1<font></font>
GPIOA-&gt;CRL 	|= GPIO_CRL_CNF0_1;<font></font>
<font></font>
GPIOA-&gt;CRL	&amp;= ~GPIO_CRL_MODE0;<font></font>
GPIOA-&gt;CRL	|= GPIO_CRL_MODE0; // gpio speed 50 MHz<font></font>
/****************************** Setting PA1 ***************************************/<font></font>
<font></font>
GPIOA-&gt;CRL 	&amp;= ~GPIO_CRL_CNF1; // setting out alternative push-pull for PWM1_CH1<font></font>
GPIOA-&gt;CRL 	|= GPIO_CRL_CNF1_1;<font></font>
<font></font>
GPIOA-&gt;CRL	&amp;= ~GPIO_CRL_MODE1;<font></font>
GPIOA-&gt;CRL	|= GPIO_CRL_MODE1; // gpio speed 50 MHz<font></font>
<font></font>
/*************************** Config PWM channel ***********************************/<font></font>
<font></font>
TIM2-&gt;PSC = 0; // div for clock: F = SYSCLK / [PSC + 1]<font></font>
TIM2-&gt;ARR = 1000; // count to 1000<font></font>
TIM2-&gt;CCR1 = 0; // duty cycle 0%<font></font>
TIM2-&gt;CCR2 = 0; // duty cycle 0%<font></font>
<font></font>
TIM2-&gt;CCER |= TIM_CCER_CC1E; // enable PWM out to PA8<font></font>
TIM2-&gt;CCER &amp;= ~TIM_CCER_CC1P; // active high level: 0 - high, 1 - low<font></font>
<font></font>
TIM2-&gt;CCER |= TIM_CCER_CC2E; // enable PWM complementary out to PA9<font></font>
TIM2-&gt;CCER &amp;= ~TIM_CCER_CC1P; // active high level: 0 - high, 1 - low<font></font>
<font></font>
TIM2-&gt;CCMR1 &amp;= ~(TIM_CCMR1_OC1M | TIM_CCMR1_OC2M);<font></font>
TIM2-&gt;CCMR1 |= TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 |<font></font>
 TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1; // positiv PWM1_CH1 and PWM1_CH2  <font></font>
<font></font>
/*******************************************************************************/<font></font>
<font></font>
TIM2-&gt;CR1 &amp;= ~TIM_CR1_DIR; // count up: 0 - up, 1 - down<font></font>
TIM2-&gt;CR1 &amp;= ~TIM_CR1_CMS; // aligned on the front signal: 00 - front; 01, 10, 11 - center<font></font>
TIM2-&gt;CR1 |= TIM_CR1_CEN; // start count<font></font>
	<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.5. </font><font style="vertical-align: inherit;">Setting the TIM6 Timer Interrupt</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We configure the timer itself at a frequency of 24 kHz:</font></font><br>
<br>
<pre><code class="cpp">void TIM6_step_init (void){<font></font>
<font></font>
RCC-&gt;APB1ENR |= RCC_APB1ENR_TIM6EN; // enable clock for basic TIM6<font></font>
<font></font>
TIM6-&gt;PSC = 1-1; // div, frequency 24 kHz<font></font>
TIM6-&gt;ARR = 1000; // count to 1000<font></font>
TIM6-&gt;DIER |= TIM_DIER_UIE; // enable interrupt for timer<font></font>
TIM6-&gt;CR1 |= TIM_CR1_CEN; // start count<font></font>
<font></font>
NVIC_EnableIRQ(TIM6_DAC_IRQn); // enable interrupt TIM6_DAC_IRQn<font></font>
	<font></font>
}</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.6. </font><font style="vertical-align: inherit;">Implementation of the main control algorithm</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Major events occur in an interrupt generated by the TIM6 timer. </font><font style="vertical-align: inherit;">An interrupt is generated every 41.66 Œºs, if you remember this is our sample rate. </font><font style="vertical-align: inherit;">Accordingly, in the interrupt, the value of the duty ratio from the table to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CCRx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register is </font><b><font style="vertical-align: inherit;">written</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Also in this interrupt, it is determined which diagonal is currently drawn by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inverting the sin_status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">after each half period. </font><font style="vertical-align: inherit;">We draw 240 points, invert the flag, which causes the control to switch to another channel, when it has already drawn, the flag is inverted again and everything repeats. </font><font style="vertical-align: inherit;">Main algorithm code:</font></font><br>
<br>
<pre><code class="cpp">void TIM6_DAC_IRQHandler(void){<font></font>
<font></font>
TIM6-&gt;SR &amp;= ~TIM_SR_UIF; 	<font></font>
<font></font>
if(sin_status == 0){TIM2-&gt;CCR1 = sin_data[sin_step];}<font></font>
if(sin_status == 1){TIM2-&gt;CCR2 = sin_data[sin_step];}<font></font>
<font></font>
sin_step++;<font></font>
<font></font>
if(sin_step &gt;= 240){<font></font>
         sin_step=0;<font></font>
         sin_status = sin_status ? 0 : 1;<font></font>
         }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Results</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Download the project, compile and upload to your microcontroller and get a working inverter. All you have to do is make a bridge and give signals to it: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/eu/oe/xbeuoedsmgdvntnsequnhzr2kau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I‚Äôve put some of my bridge schemes in PDF earlier in the PDF, I hope it will help you in mastering power electronics.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also in the project, I pulled FreeRTOS. Of course, using RTOS means it is impossible to implement similar management tasks, since simple switching between tasks lasts from 4 to 18 microseconds, and that if the code is well written and nothing can hinder the work of the scheduler. This does not allow to get a control system operating in hard real-time. I set up FreeRTOS for another: communication interfaces (RS-485 Modbus RTU), adjustment of the output voltage amplitude, recalculation of the table, synchronization with the 230V network and so on. I will also try to implement all these buns on STM32, and maybe I'll write a continuation of the topic of the article, if interesting results are obtained and there is something to share.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope you liked the article. </font><font style="vertical-align: inherit;">If you have questions on the use of this code in real hardware, I will be glad to answer them. </font><font style="vertical-align: inherit;">Also, please do not take this code as something ready, this is the core of the converter that implements the main function. </font><font style="vertical-align: inherit;">All the "buns" and other redundancy you can add yourself. </font><font style="vertical-align: inherit;">The bare core of the project will allow you to understand how it works and not spend a lot of time disassembling code.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materials</font></font></b><div class="spoiler_text">1)   Keil 5  ‚Äî <a href="https://drive.google.com/open%3Fid%3D15h5nhCaskF2LYJ9_JVWoxQIrAhTBo-Vd"></a><br>
 : <br>
) start_init ‚Äî  ,  MCO  , GPIO   (/)<br>
) PWM ‚Äî  ,   ,        <br>
) main.c ‚Äî  <br>
<br>
2) Reference manual  STM32F10x ‚Äî <a href="https://drive.google.com/open%3Fid%3D1luJ8lI31ABWtdKHe358oA-RcnSZUcNC0"></a></div></div><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I would like to thank the </font></font><a href="https://habr.com/users/sleip/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sleip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user </font><font style="vertical-align: inherit;">for a number of errors found, mainly in the sine table - it has been changed. </font><font style="vertical-align: inherit;">Those who have used the code or the table itself, please copy it again, in the article already corrected version.</font></font></div><p>Source: <a href="https://habr.com/ru/post/358172/">https://habr.com/ru/post/358172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358162/index.html">They want to register in social networks using a passport, but children shouldn‚Äôt be allowed at all</a></li>
<li><a href="../358164/index.html">State Duma proposes to penalize those who refuse to decipher their traffic. Update: amendments accepted</a></li>
<li><a href="../358166/index.html">Decree "On the national goals and strategic objectives of the development of the Russian Federation for the period up to 2024"</a></li>
<li><a href="../358168/index.html">Programming for Palm in 2017</a></li>
<li><a href="../358170/index.html">How is AADHAAR - the largest biometric system in the world</a></li>
<li><a href="../358174/index.html">Planar transformer: technology, calculations, cost</a></li>
<li><a href="../358176/index.html">Basics of game code optimization</a></li>
<li><a href="../358178/index.html">Antipattern testing software</a></li>
<li><a href="../358180/index.html">Magnasanti - the largest and most terrible city of SimCity</a></li>
<li><a href="../358182/index.html">Use GPG to encrypt messages and files.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>