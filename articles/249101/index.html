<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.14 of 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the main course 


- Article 1: Bresenham algorithm 
- Article 2: rasterization of the triangle + clipping of the rear faces 
- Article 3: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.14 of 6</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content of the main course </h1><br><ul><li>  <a href="http://habrahabr.ru/post/248153/">Article 1: Bresenham algorithm</a> </li><li>  <a href="http://habrahabr.ru/post/248159/">Article 2: rasterization of the triangle + clipping of the rear faces</a> </li><li>  <a href="http://habrahabr.ru/post/248179/">Article 3: Removing invisible surfaces: z-buffer</a> </li><li>  Article 4: Required Geometry: Matrix Festival <br><ul><li>  <a href="http://habrahabr.ru/post/248611/">4a: Construction of perspective distortion</a> </li><li>  <a href="http://habrahabr.ru/post/248723/">4b: we move the camera and what follows from this</a> </li><li>  <a href="http://habrahabr.ru/post/249467/">4c: a new rasterizer and perspective distortion correction</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/248963/">Article 5: We write shaders for our library</a> </li><li>  <a href="http://habrahabr.ru/post/249139/">Article 6: A little more than just a shader: shadow rendering</a> </li></ul><br><ul><li>  <a href="http://habrahabr.ru/post/248909/">Article 3.1: It‚Äôs time to refactor</a> </li><li>  <b><a href="http://habrahabr.ru/post/249101/">Article 3.14: Beautiful Matrix Class</a></b> </li><li>  how does the new rasterizer work </li></ul><br><h3>  Communication outside Habr </h3>  If you have questions and do not want to ask them in the comments, or simply do not have the opportunity to write in the comments, join the jabber conference 3d@conference.sudouser.ru <br><br><h4>  4 Welcome and introduction </h4> <i>The numbering in the last article ended with 3, in this we will continue to number through.</i> <br>  <b>UPD: ATTENTION!</b>  <b>The section, starting with numbers 3.1, 3.14 and 3.141 and on, will be about the intricacies of the implementation of the basis of the basics of computer graphics - linear algebra and computational geometry.</b>  <b>About the principles of graphics writes <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> , but I will write about how it can be clearly programmed!</b> <br><br>  This article is a continuation of a series of articles on the practical implementation of elements of computational geometry, and, in particular, software renderers, using C ++ 98.  We <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> deliberately go to using the previous version of the standard and writing our own geometric library in order to, first, release the code of examples, which without special difficulties will be compiled by most of the available compilers, and second, that there is nothing in our code that is hidden in the bowels of the library.  The article outlines the implementation of a rectangular matrix pattern: <code>template&lt;size_t DimRows,size_t DimCols,typename number_t&gt; class mat;</code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  4.1 Acknowledgments </h5>  I express great appreciation to <a href="https://habrahabr.ru/users/haqreu/" class="user_link">haqreu</a> as the founder of this course.  Keep it up! <br>  I am very grateful to <a href="https://habrahabr.ru/users/lemelisk/" class="user_link">lemelisk</a> for the preliminary review and review of my sources.  Thank you for the fruitful discussions! <br>  I also have to thank <a href="https://habrahabr.ru/users/mingun/" class="user_link">Mingun</a> for the <a href="http://habrahabr.ru/post/249101/">valuable comment</a> on the design of the templates.  I hope they have become more readable. <br><a name="habracut"></a><br><h5>  <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2582%25D0%25B2%25D0%25B5%25D1%2582_%25D0%25BD%25D0%25B0_%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B2%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581_%25D0%25B6%25D0%25B8%25D0%25B7%25D0%25BD%25D0%25B8,_%25D0%25B2%25D1%2581%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25B8_%25D0%25B2%25D1%2581%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2582%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">4.2</a> A little philosophical remark about language, mathematics, C ++, and all such </h5>  In general, abstractions such as ‚Äúmatrix‚Äù and ‚Äúvector‚Äù and operations on them are necessary in order to simplify and formalize the language of presentation of geometry.  Without them, we would have to constantly say (and write in the program) something like: <br><br>  We speak: <blockquote>  To get the new coordinates of Point, which is moved in the direction of Direction, you need to add <br>  x point of point with x moving direction, <br>  Point Point with y Direction moving, <br>  z Point Point with z Direction Moving </blockquote>  We write: <br><pre> <code class="cpp hljs">Point.x=Point.x+Direction.x; Point.y=Point.y+Direction.y; Point.z=Point.x+Direction.z; <span class="hljs-comment"><span class="hljs-comment">//(, "  ")</span></span></code> </pre><br>  After the concept of "vector" entered our speech, we can already say: <br><blockquote>  To get the new radius vector of Point after moving in the direction of Direction, you need to add the Point and Direction vectors </blockquote><br>  And after including the vec template in our code, we can write: <br><pre> <code class="cpp hljs">Point=Point+Direction;</code> </pre>  Thus, we shorten what we have written, we insure against <a href="http://habrahabr.ru/company/pvs-studio/blog/224783/">mistakes when copying, pasting and editing,</a> and we get a way to reason with more succinct terms. <br><br>  Here is what Jeff Alger writes about this in the book ‚ÄúC ++ for Real programmers‚Äù, (by AP Professional, translation published by Peter, entitled ‚ÄúC ++: Programmer‚Äôs Library‚Äù) <br><br><blockquote>  C ++ is actually not so much a language as a tool for creating your own languages.  Its elegance lies not in simplicity (C ++ words and simplicity cut the ear with their apparent contradiction), but in its potential.  Behind every ugly problem hides some clever idiom, an elegant language trick, thanks to which the problem melts right in front of our eyes.  The problem is solved as elegantly as a real language like Smalltalk or Lisp would have done, but your processor is not smoked by voltage, and stocks of manufacturers of memory chips do not grow on Wall Street </blockquote><br>  This is exactly what we are going to do - we will build a geometric primitive control language using C ++, trying to do this as close as possible to the definitions from mathematics. <br><br><h4>  5 Template class for processing and storage of matrices </h4>  We store the matrix as an array of row vectors using the appropriate specialization of <a href="http://habrahabr.ru/post/248909/">the vec template.</a>  Our template is focused only on working with matrices of small dimension (maximum 10x10 elements. Although it will be terrible already).  But in computational geometry, as a rule, all work goes precisely with matrices no more than 4x4.  Large matrices, as a rule, are very sparse ‚Äî for them it is known in advance that they are almost completely filled with zeros, which makes it possible to optimize their processing and storage. <br><br><h5>  5.1 Index Operators </h5>  We defined the constant and non-constant variants of the index operator [] so that they return a reference to the corresponding vector row of the matrix: <br><div class="spoiler">  <b class="spoiler_title">their source code</b> <div class="spoiler_text"><table><tbody><tr><td>  Constant variant <br></td><td>  Non-constant option <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert(idx&lt;DimRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows[idx]; }</code> </pre></td><td><pre> <code class="cpp hljs">vec&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { assert(idx&lt;DimRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows[idx]; }</code> </pre></td></tr></tbody></table></div></div>  Two variants of operators are needed because we, wherever possible, use <code>const</code> .  If there were no constant variant of the index operator, the compiler would not allow us to compile code in which, for example, the operator is called by a constant reference to an instance of the matrix: <br><div class="spoiler">  <b class="spoiler_title">So GCC 4.9.2 swears when it does not find the constant variant of the operator []</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">geometry.h:<span class="hljs-number"><span class="hljs-number">182</span></span>: : <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'operator[]'</span></span> (operand <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> are <span class="hljs-string"><span class="hljs-string">'const mat&lt;2ul, 3ul, float&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'size_t {aka long unsigned int}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i=DimRows; i<span class="hljs-comment"><span class="hljs-comment">--; ret[i]=lhs[i]*rhs); ^</span></span></code> </pre></div></div>  In addition, we use the <code>assert()</code> macro here to catch attempts to refer to a nonexistent row of the matrix.  Read more about assert in <a href="http://habrahabr.ru/post/248909/">article 3.1.</a> <br><br><h5>  5.2 Calculation of the inverse matrix </h5>  We needed a subroutine to calculate the inverse matrix.  In particular, using the inverse matrix, one can ‚Äúbeautifully‚Äù find the barycentric coordinates (you can see in <a href="">my branch on the githabe</a> , the <code>filltria</code> function). <br>  The task of calculating the inverse matrix in the general case is quite time consuming and can be accompanied by the accumulation of significant errors in the calculations.  However, for such small matrices, these problems are not so significant (if you do not specifically build such an example).  We chose an algorithm using the allied matrix, because it seemed to us more transparent than <abbr title="Write the initial matrix on the left and the unit matrix on the right, then use the equivalent unit transformation on the left of the equivalent transformations of both matrices. Then the right will be back to the original">the Gauss-Jordan algorithm.</abbr>  The following fact is used: <br><ul><li>  if for a given matrix to make an ally matrix, </li><li>  and then transpose </li><li>  and divide it by the determinant of this, </li></ul>  we get the inverse of the matrix.  These are just three distinct steps. <br>  The union matrix is ‚Äã‚Äãcomposed of algebraic additions.  An algebraic addition is the determinant of the submatrix obtained from the principal by deleting the row and column containing the element for which we find this addition. <br><div class="spoiler">  <b class="spoiler_title">Explanatory picture from Wikipedia, author - Alexander Mekhonoshin</b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7c3/ade/8cf/7c3ade8cf0933a82c98026ea765434a0.png" alt="image"></a> <br></div></div><br>  Got the next question - how to find the determinant. <br>  We use the following property: <blockquote>  the determinant is equal to the product of the elements of the row or column of the matrix by their algebraic complements. </blockquote><br>  A recursion is obtained - the algebraic complement is also the determinant of the matrix, only the dimension is one less.  And the determinant of a matrix of dimension 1 is its only element.  Recursion is closed.  We will use the beautiful feature of C ++ templates ‚Äî we will deploy this recursion right at compile time. <br><br>  <b>Note:</b> Our matrix is ‚Äã‚Äãrectangular, and the determinant can be calculated only for a square matrix.  At the compilation stage, I would like to catch attempts to find the determinant of a non-square matrix.  There are two ways to do this: <br><ul><li>  inherit from mat the squareMat class in which to declare the determinant </li><li>  use the fact that the dimensions of the matrix are known to us at the compilation stage, so we can compare them and interrupt the compilation, if they do not match </li></ul><br>  In the first case, we get a separate type of matrices and a bunch of problems with matrix transformation back and forth, because we can form a square matrix within the mat type, but to calculate the determinant, we have to construct an instance of the squareMat type from it. <br>  Therefore, we will choose the second method - when expanding templates, detect a size mismatch and break the compilation.  In C ++ 11 there is a standard tool to do this - static_assert ().  In C ++ 98 there is no such means, so we will invent a surrogate: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_assertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_assertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span>};</code> </pre>  If you substitute true into this template, it simply forms an empty static_assertion {} structure.  But if you set it to false, an error is generated (an attempt to use an incomplete declaration of the static_assertion structure), which stops the compilation: <br><pre> <code class="bash hljs">geometry.h:125: : invalid use of incomplete <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'struct static_assertion&lt;false&gt;'</span></span> static_assertion&lt;DimCols&lt;=10&gt;(); ^</code> </pre>  The more errors shifted to the compilation stage, the better, because they simply do not allow bad code to work. <br>  Let's return to our recursion: <br><div class="spoiler">  <b class="spoiler_title">Sources for the recursion template</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/////////////////////////////////////////////    dt 1. template&lt;size_t Dim,typename number_t&gt; struct dt 2. { 3. static number_t det(const mat&lt;Dim,Dim,number_t&gt;&amp; src) 4. { 5. number_t ret=0; 6. for (size_t i=Dim; i--;) 7. { 8. ret += src[0][i] * src.cofactor(0,i); 9. } 10. return ret; 11. } 12. }; /////////////////////////////////////////////     ,    1. 13. template&lt;typename number_t&gt; struct dt&lt;1,number_t&gt; 14. { 15. static number_t det(const mat&lt;1,1,number_t&gt;&amp; src) 16. { 17. return src[0][0]; 18. } 19. };</span></span></code> </pre><br></div></div><br>  So, for all situations when the first parameter of the template is not equal to 1, the upper template (lines 1-11) will be used.  For the situation, the <i>first parameter is 1</i> , a special version of the template is defined (lines 12-18).  Pay attention to line 13: Addition <code>&lt;1,number_t&gt;</code> just also indicates that this announcement is a separate entity.  With a common version of the dt template, nothing binds it.  There is an error when confusing the behavior of partial specialization and inheritance, expecting that everything declared in the general version will be in partial.  This will not happen - the programmer is charged with recreating, in a partial specialization, all that he needs. <br><ul><li>  The wrapping into a separate structure is performed because the standard does not allow partial specialization for functions. </li><li>  We removed this function from mat because, having acted differently, we would be forced to add in mat &lt;1,1, number_t&gt; part of the methods from the general version, which would lead to some swelling of the code. </li></ul>  Partial specialization, exactly by definition of the 1x1 matrix determinant, gives us a single element (line 16). <br><br>  The common version of the template performs the <i>decomposition of the matrix on the zero line</i> - it takes an element with the index <code>0, i</code> from the first line, multiplies it by the algebraic complement - <code>cofactor(0,i)</code> and the result accumulates in the variable <code>ret</code> .  Everything is in complete agreement with the formula of this decomposition: <img src="http://www.loria.fr/~sokolovd/infographie/04-geometry/imgc/f01.svg" alt="image"><br><br><h5>  5.3 How recursion happens </h5>  <b>IMPORTANT: Strictly speaking, the template processing mechanism is the compiler's own business.</b>  <b>Below, I talk about how this <i>could happen</i> .</b>  <b>This is done only to illustrate how template declarations unfold recursively.</b> <br><br>  Imagine that we independently deploy templates.  Code written: <pre> <code class="cpp hljs">... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mat&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m; .... <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; m.det() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre>  We see in it a call to det () from the mat template, which means we should get the text of the det () function for the specific case of mat &lt;3.3, int&gt;. <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 3;  DimRows = 3;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> det() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { static_assertion&lt;DimCols==DimRows&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&lt;3,</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span></span>{ static_assertion&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>==<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td></tr></tbody></table>  Great, now we need from the template &lt;size_t Dim, typename number_t&gt; struct dt to get the specific text for the case dt &lt;3, int&gt;: <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution is Dim = 3;  number_t = int <br></td></tr><tr><td><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> number_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mat&lt;Dim,Dim,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">number_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--;) { ret += src[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] * src.cofactor(<span class="hljs-number"><span class="hljs-number">0</span></span>,i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } };</code> </pre></td><td><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class">&lt;3,int&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mat&lt;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">3</span></span>; i--;) { ret += src[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] * src.cofactor(<span class="hljs-number"><span class="hljs-number">0</span></span>,i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } };</code> </pre></td></tr></tbody></table>  We met the call to the operator [] and cofactor () from mat &lt;3.3, int&gt;.  The body [] is of no interest to us now, we are investigating with cofactor (): <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 3;  DimRows = 3;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> cofactor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_minor(row,col).det()*((row+col)%<span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cofactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> col)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_minor(row,col).det() *( (row + col) % <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre></td></tr></tbody></table>  Here, get_minor () is called.  Get the text for it: <table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 3;  DimRows = 3;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs">mat&lt;DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>,DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; get_minor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { mat&lt;DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>,DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>;j--;) { ret[i][j]=rows[ i&lt;row ? i : i+<span class="hljs-number"><span class="hljs-number">1</span></span> ] [ j &lt;col ? j : j+<span class="hljs-number"><span class="hljs-number">1</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">//  j &lt;col ? j : j+1      col // i&lt;row ? i : i+1 -      row } } return ret; }</span></span></code> </pre></td><td><pre> <code class="cpp hljs">mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_minor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { mat&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">2</span></span>; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=<span class="hljs-number"><span class="hljs-number">2</span></span>;j--;) { ret[i][j]=rows[ i&lt;row?i:i+<span class="hljs-number"><span class="hljs-number">1</span></span> ] [ j&lt;col?j:j+<span class="hljs-number"><span class="hljs-number">1</span></span> ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre></td></tr></tbody></table>  We got this get_minor () to return a 2x2 matrix already.  Now we, <i>for the 2x2 matrix,</i> will call mat &lt;2.2, int&gt; :: det ().  But we only have the body mat &lt;3.3, int&gt; :: det ().  Therefore, we dive into recursion by one step and build another set of methods: <br><div class="spoiler">  <b class="spoiler_title">Methods that appeared when expanding a 2x2 template</b> <div class="spoiler_text">  We need to get the text of the det () function for the specific case of mat &lt;2.2, int&gt;: <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution is Dim = 2;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> det() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { static_assertion&lt;DimCols==DimRows&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&lt;2,</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span></span>{ static_assertion&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>==<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td></tr></tbody></table>  Great, now we need from the template &lt;size_t Dim, typename number_t&gt; struct dt to get the specific text for the case dt &lt;2, int&gt;: <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution is Dim = 2;  number_t = int <br></td></tr><tr><td><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Dim,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> number_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mat&lt;Dim,Dim,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">number_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=Dim; i--;) { ret += src[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] * src.cofactor(<span class="hljs-number"><span class="hljs-number">0</span></span>,i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } };</code> </pre></td><td><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class">&lt;2,int&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mat&lt;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">2</span></span>; i--;) { ret += src[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] * src.cofactor(<span class="hljs-number"><span class="hljs-number">0</span></span>,i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } };</code> </pre></td></tr></tbody></table>  We met the call of the operator [] and cofactor () from mat &lt;2.2, int&gt;.  The body [] is of no interest to us now, we are investigating with cofactor (): <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 2;  DimRows = 2;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> cofactor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_minor(row,col).det()*((row+col)%<span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cofactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> row, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> col)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_minor(row,col).det() *( (row + col) % <span class="hljs-number"><span class="hljs-number">2</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre></td></tr></tbody></table>  Here, get_minor () is called.  Get the text for it: <table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 2;  DimRows = 2;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs">mat&lt;DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>,DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; get_minor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { mat&lt;DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>,DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows<span class="hljs-number"><span class="hljs-number">-1</span></span>; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=DimCols<span class="hljs-number"><span class="hljs-number">-1</span></span>;j--;) { ret[i][j]=rows[ i&lt;row?i:i+<span class="hljs-number"><span class="hljs-number">1</span></span> ] [ j&lt;col?j:j+<span class="hljs-number"><span class="hljs-number">1</span></span> ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre></td><td><pre> <code class="cpp hljs">mat&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get_minor(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> row, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { mat&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>;j--;) { ret[i][j]=rows[ i&lt;row?i:i+<span class="hljs-number"><span class="hljs-number">1</span></span> ] [ j&lt;col?j:j+<span class="hljs-number"><span class="hljs-number">1</span></span> ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> </td></tr></tbody></table><br></div></div><br>  Having expanded the pattern chain, we again encountered the call to get_minor () in the body of cofactor (), but for the case of DimCols = 2, DimRows = 2.  The resulting version of get_minor () returns a 1x1 matrix.  Further, for it in the body of cofactor () a determinant is requested.  Again we should get the text mat :: det (), but for the case DimCols = 1;  DimRows = 1. <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution DimCols = 1;  DimRows = 1;  number_t = int <br></td></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> det() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { static_assertion&lt;DimCols==DimRows&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&lt;1,</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span></span>{ static_assertion&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dt&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::det(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre></td></tr></tbody></table>  Great, now we need from the template &lt;size_t Dim, typename number_t&gt; struct dt to get the specific text for the case of dt &lt;1, int&gt;.  <b>STOP</b> , this also falls under the partial specialization of the template dt &lt;1, number_t&gt;!  It is necessary to process it, and not the general version of the template! <br><table><tbody><tr><td>  Template <br></td><td>  The result of the substitution is Dim = 1;  number_t = int <br></td></tr><tr><td><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dt</span></span></span><span class="hljs-class">&lt;1,number_t&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">det</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mat&lt;</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">number_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> src[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; } };</code> </pre></td><td><pre> <code class="hljs markdown">template<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">number_t</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> struct dt<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">1,int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> { static number_t det(const mat<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">1,1,int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>&amp; src) { return src[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">0</span></span>]; } };</code> </pre></td></tr></tbody></table><br>  We see that there is no longer access to cofactor ().  At this, the recursion promotion is over - we got the bodies of functions for calculating the determinant of 3x3, 2x2, 1x1 matrices. <br>  Important note: You may wish to write this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> det() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DimCols==<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; DimRows==<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rows[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span> ret=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimCols; i--;) { ret += src[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] * src.cofactor(<span class="hljs-number"><span class="hljs-number">0</span></span>,i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  The motivation is simple - it will be sort of like ordinary recursion, and partial specialization is not needed.  However, during the deployment of templates, the compiler will not do anything with the conditional operator, but will start building templates (3, 2, 1, 0, std :: numeric_limits &lt;size_t&gt; :: max, std :: numeric_limits &lt;size_t&gt; :: max- 1, ...) until it is stopped by the internal counter <code>-ftemplate-depth=</code> (by default, this depth is 900). <br>  The ability to use familiar flow control operators appears in C ++ 11 for functions declared with the <code>constexpr</code> .  They allow you to organize <i>another type of computation at compile time</i> , different from recursion on templates.  <i>And if I can not turn all of our render during compilation?</i> <br><br>  So, we have described in terms of C ++ the search for the determinant of a matrix, as well as the operations accompanying it - the construction of a minor matrix and an algebraic complement.  To find the inverse matrix, it remains only to construct an allied matrix: <br><div class="spoiler">  <b class="spoiler_title">The method that builds the ally matrix:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; adjugate() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows; i--;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=DimCols; j--;) { ret[i][j]=cofactor(i,j) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre></div></div>  acts exactly by definition - fills the matrix with algebraic complements of the corresponding elements. <br>  It remains to perform the main stage of construction - to find the inverse matrix (it will be obtained in transposed form): <br><pre> <code class="cpp hljs">mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; invert_transpose() { mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret = adjugate(); <span class="hljs-comment"><span class="hljs-comment">//   number_t det = ret[0]*rows[0]; //   ,   //  - //       return ret/det; //     , //      }</span></span></code> </pre><br><h5>  5.4 Matrix Multiplication </h5>  The operation of matrix multiplication is also quite time consuming and may be accompanied by an accumulation of error.  In cases of matrices of higher dimensionality (greater than 64x64), special algorithms, like <a href="http://www.algolib.narod.ru/Math/Matrix.html">the Strassen algorithm</a> , are usually used.  The asymptotic record holder, the Coppersmith-Winograd Algorithm (with Virginia Williams improvements), is not used now, because it starts to overtake the Strassen algorithm on matrices so huge that they are not yet encountered in modern computational practice.  We have small matrices, so for the multiplication we are simply satisfied with the definition of the matrix multiplication operation: <br><blockquote>  The product of matrices AB consists of all possible combinations of scalar products of the row vector of matrix A and the column vector of matrix B <br></blockquote><br><img src="https://upload.wikimedia.org/wikipedia/commons/e/eb/Matrix_multiplication_diagram_2.svg" alt="image"><br><div class="spoiler">  <b class="spoiler_title">Information about the author of the picture</b> <div class="spoiler_text">  <a href="">Matrix multiplication diagram 2 of</a> <a href="" title="File: Matrix multiplication diagram.svg">File: Matrix multiplication diagram.svg</a> : <a href="https://commons.wikimedia.org/wiki/User:Bilou" title="User: Bilou">User: Bilou</a> See Below - This file is derived from: <a href="" title="File: Matrix multiplication diagram.svg">Matrix multiplication diagram.svg</a> .  Under the license <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a> from <a href="https://commons.wikimedia.org/wiki/">Wikimedia Commons</a> . <br></div></div><br>  The definition in this form allows us to use the scalar multiplication operation from our vec template.  But for this we need a method that extracts its column from the matrix as a vector: <br><div class="spoiler">  <b class="spoiler_title">col () method text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">vec&lt;DimRows,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; col(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { assert(idx&lt;DimCols); vec&lt;DimRows,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows; i--;) { ret[i]=rows[i][idx]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre></div></div>  Yes, there seems to be too much copying (later we will see if the compiler can cope with throwing it out), but the main goal is to write such a short and capacious multiplication of matrices: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> R1,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> C1,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> C2,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; mat&lt;R1,C2,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mat&lt;R1,C1,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mat&lt;C1,C2,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; rhs ) { mat&lt;R1,C2,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=R1; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=C2; j--;) { result[i][j]=lhs[i]*rhs.col(j); <span class="hljs-comment"><span class="hljs-comment">//  i-    //  j-   } } return result; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to this text. Here, C ++ sets out the mathematical definition of the multiplication operation of rectangular matrices, and this is done very close to the text [‚Äúfilling the result matrix with all possible scalar products of the row vector of the left matrix and the right column vector‚Äù]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, the control of dimensions (the number of columns of the left should be equal to the number of rows of the right) is performed immediately at the compilation stage - an attempt to multiply matrices that are not suitable for the size does not even compile. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is very important, because the runtime error can be floating, elusive, and so on. And the compilation error gets out almost always. (It is necessary to take into account the madness of the IDE, which can part of the project to cache, part to forget to update, and so on. But there is a sure cure for this - Rebuild All).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.5 Single Matrix Generator </font></font></h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In his text: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; identity() { mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows; i--; ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=DimCols;j--;) { ret[i][j]=(i==j) ; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an interesting feature - writing the result of type bool into a variable of a priori unknown type number_t. Here a nightmare can happen to a person who would like to use our geometry in his project, and together with a self-made type for storing numbers (this may be a type that stores numbers with a fixed comma). He may not expect our methods to try to write bool values ‚Äã‚Äãto his type (operator == for size_t returns bool), and pile up his own constructor that accepts bool and does not convert this conversion as described in the standard ([¬ß4.7 / 4 ] requires that when casting bool to a numeric type, false becomes 0, true to 1). Since in this case, a hypothetical user deviates from the standard, we should not try to lay straw on it (we could do this:</font></font><code>ret[i][j]=static_cast&lt;number_t&gt;(static_cast&lt;int&gt;(i==j))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and to transfer at least int to it at the price of a succession of transformations - has violated the standard - it is my fault. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.6 Matrix multiplication by vector </font></font></h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To multiply the matrix (left) by the vector (right), we consider the vector as a matrix of one column. </font><font style="vertical-align: inherit;">Further, we can perform the matrix multiplication operation already known to us, which in the end will also give a matrix of one column ‚Äî this column vector will be the result of multiplication.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need the set_col () method to populate a matrix column from a vector:</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_col</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, vec&lt;DimRows,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">number_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; v)</span></span></span><span class="hljs-function"> </span></span>{ assert(idx&lt;DimCols); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows; i--;) { rows[i][idx]=v[i]; } }</code> </pre></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the matrix generator for a given column vector</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> mat&lt;DimRows,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; make_from_vec_col(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;DimRows,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; v) { static_assertion&lt;DimCols==<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(); mat&lt;DimRows,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; ret; ret.set_col(<span class="hljs-number"><span class="hljs-number">0</span></span>,v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we can write the matrix-vector multiplication operator: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimRows,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimCols,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; vec&lt;DimRows,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec&lt;DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; rhs ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (lhs * mat&lt;DimCols,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;::make_from_vec_col(rhs) ).col(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It was worked out exactly by definition - they obtained a matrix with one column from a vector, multiplied it, returned a column-result. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.7 Dividing the matrix by a scalar, output to ostream </font></font></h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performed using the fact that the matrix is ‚Äã‚Äãstored as an array of vector - rows, and for the vector similar operations have already been written: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaction Texts</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimRows,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimCols,<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; mat&lt;DimCols,DimRows,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>/( mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt; lhs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&amp; rhs ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=DimRows; i--; ) { lhs[i]=lhs[i]/rhs; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimRows,<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> DimCols,<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number_t</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:ostream&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream&amp; out, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mat&lt;DimRows,DimCols,<span class="hljs-keyword"><span class="hljs-keyword">number_t</span></span>&gt;&amp; m ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;DimRows; i++) { out &lt;&lt; m[i] &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out; }</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 Conclusion </font></font></h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I tried to describe as much as possible the construction of the mat class template. </font><font style="vertical-align: inherit;">In the next article I will discuss the issues of optimization and acceleration of this code on x86_64 and ARM architectures (using the example of STM32F3). </font><font style="vertical-align: inherit;">See you soon article!</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/249101/">https://habr.com/ru/post/249101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249091/index.html">An extension for the normal selection of text inside a link in browsers</a></li>
<li><a href="../249093/index.html">Open Data Day February 21 will be held around the world</a></li>
<li><a href="../249095/index.html">Data Center per billion or "Super Ring" for the "Wild West"</a></li>
<li><a href="../249097/index.html">New GHOST vulnerability threatens popular Linux distributions</a></li>
<li><a href="../249099/index.html">Warming data centers</a></li>
<li><a href="../249103/index.html">Curves Beziers de Castelgio. HTML5 Canvas</a></li>
<li><a href="../249105/index.html">How to get convenient access to XAML-resources from Code-Behind</a></li>
<li><a href="../249107/index.html">ReactJS for stupid people</a></li>
<li><a href="../249113/index.html">Categories</a></li>
<li><a href="../249115/index.html">How we made a mod under the Oculus Rift for World of Tanks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>