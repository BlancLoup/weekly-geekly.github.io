<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the analysis of the complexity of algorithms (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: this text is given with insignificant abbreviations due to places of excessive ‚Äúrazvezhnannosti‚Äù material. The author absolutely ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the analysis of the complexity of algorithms (part 1)</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: this text is given with insignificant abbreviations due to places of excessive ‚Äúrazvezhnannosti‚Äù material.</i>  <i>The author absolutely rightly warns that certain topics will seem too simple or well-known.</i>  <i>Nevertheless, personally this text helped me to streamline the existing knowledge on the analysis of the complexity of algorithms.</i>  <i>I hope that it will be useful to someone else.</i> <i><br></i>  <i>Due to the large volume of the original article, I broke it into pieces, which in total will be four.</i> <i><br></i>  <i>I (as always) would be extremely grateful for any comments in PM about improving the quality of the translation.</i> <br><br><h4>  Introduction </h4><br>  Many modern programmers who write cool and widespread programs have an extremely vague idea of ‚Äã‚Äãtheoretical computer science.  This does not prevent them from being excellent creative professionals, and we are grateful for what they create. <br><br>  However, knowledge of the theory also has its advantages and can be very useful.  In this article, intended for programmers who are good practitioners, but have a weak understanding of the theory, I will present one of the most pragmatic programmer tools: the notion ‚Äúbig O‚Äù and the analysis of the complexity of algorithms.  As a person who has worked both in the field of academic science and in creating commercial software, I find these tools really useful in practice.  I hope that after reading this article you can apply them to your own code to make it even better.  Also, this post will bring with it an understanding of such general terms used by computer science theorists as ‚Äúbig O‚Äù, ‚Äúasymptotic behavior‚Äù, ‚Äúanalysis of the most unfavorable case‚Äù, etc. <br><a name="habracut"></a><br>  This text is also aimed at secondary school students from Greece or any other country participating in the <a href="http://en.wikipedia.org/wiki/International_Olympiad_in_Informatics">International Olympiad in Informatics</a> , competitions in algorithms for students and the like.  As such, it does not require prior knowledge of any complex mathematical aspects and will simply give you a basis for further research of algorithms with a firm understanding of the theory behind them.  As one who has participated in various competitions at one time, I strongly recommend that you read and understand all the introductory material.  This knowledge will be essential when you continue to learn algorithms and various advanced technologies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I hope that this text will be useful for those practical programmers who do not have much experience in theoretical computer science (the fact that the most inspired software engineers never went to college is a long-time fact).  But since the article is intended for students too, at times it will sound like a textbook.  Moreover, some topics may seem too simple (for example, you might encounter them during your training).  So, if you feel that you understand them - just skip these moments.  Other sections go somewhat deeper and are more theoretical, because students participating in competitions should understand the theory of algorithms better than the average practitioner.  But to know these things is not less useful, but to follow the course of the narration is not so difficult, so they most likely deserve your attention.  The original text was sent to high school students, it does not require any special mathematical knowledge, so everyone who has programming experience (for example, who knows what recursion is) is able to understand it without any special problems. <br><br>  In this article you will find many interesting links to materials that go beyond our discussion.  If you are a working programmer, then it is quite possible that you are familiar with most of these concepts.  If you are just a novice student participating in competitions, clicking on these links will give you information about other areas of computer science and software development that you have not yet had time to learn.  View them to increase your own baggage of knowledge. <br><br>  The ‚Äúbig O‚Äù notation and analysis of the complexity of algorithms are those things that both practitioners and novice students often find difficult to understand, fear, or avoid at all, as useless.  But they are not so complicated and abstruse, as it may seem at first glance.  The complexity of the algorithm is just a way to formally measure how fast a program or algorithm works, which is a very pragmatic goal.  Let's start with a little motivation on this topic. <br><br><h4>  Motivation </h4><br>  We already know that there are tools that measure how fast the code works.  These are programs called <i>profilers</i> , which determine the execution time in milliseconds, helping us to identify bottlenecks and optimize them.  But, although it is a useful tool, it is not related to the complexity of the algorithms.  The complexity of the algorithm is that it is based on comparing the two algorithms at an ideal level, ignoring low-level details such as the implementation of a programming language, the hardware on which the program is running, or the instruction set in a given CPU.  We want to compare the algorithms in terms of what they actually are: ideas, how the calculation happens.  Counting the milliseconds will be of little help here.  It may well turn out that a bad algorithm written in a low-level language (for example, <a href="http://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25B0%25D1%2581%25D1%2581%25D0%25B5%25D0%25BC%25D0%25B1%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">assembly language</a> ) will be much faster than a good algorithm written in a high-level programming language (for example, <a href="http://www.python.org/">Python</a> or <a href="https://www.ruby-lang.org/en/">Ruby</a> ).  So it's time to decide what the ‚Äúbest algorithm‚Äù really is. <br><br>  An algorithm is a program that is exclusively a calculation, without other things that are often performed by a computer ‚Äî network tasks or user input / output.  Analysis of complexity allows us to find out how fast this program is when it performs calculations.  Examples of purely <i>computational</i> operations can be operations on <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D1%2581_%25D0%25BF%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25B0%25D1%258E%25D1%2589%25D0%25B5%25D0%25B9_%25D0%25B7%25D0%25B0%25D0%25BF%25D1%258F%25D1%2582%25D0%25BE%25D0%25B9">floating-point numbers</a> (addition and multiplication), searching for a given value from a database located in RAM, and determining by game artificial intelligence (AI) movement of your character so that it moves only a short distance inside the game. world, or launching a <a href="http://www.regular-expressions.info/">regular expression</a> pattern against a string.  Obviously, computing is found everywhere in computer programs. <br><br>  The complexity analysis also allows us to explain how the algorithm will behave as the input data stream increases.  If our algorithm runs for one second with 1000 entries, how does it behave, if we double this value?  Will it also work fast, one and a half times faster or four times slower?  In programming practice, such predictions are extremely important.  For example, if we created an algorithm for a web application that works with thousands of users, and measured its execution time, then using complexity analysis, we will get a very good idea of ‚Äã‚Äãwhat will happen when the number of users rises to two thousand.  For competitions on the construction of algorithms, the analysis of complexity will also give us an understanding of how long our code will run on the largest of the tests to verify its correctness.  So, if we define the general behavior of our program on a small amount of input data, we can get a good idea of ‚Äã‚Äãwhat will happen to it with large data streams.  Let's start with a simple example: finding the maximum element in an array. <br><br><h4>  Counting instructions </h4><br>  In this article, I will use various programming languages ‚Äã‚Äãto implement the examples.  Do not worry if you are not familiar with any of them - anyone who can program can read this code without any problems, because it is simple and I‚Äôm not going to use any exotic baubles of the implementation language.  If you are an academic student, then most likely write in <a href="http://www.cplusplus.com/doc/tutorial/">C ++</a> , so you should have no problems either.  In this case, I also recommend working out the exercises using C ++ for more practice. <br><br>  The maximum array element can be found using the simplest code snippet.  For example, such, written in <a href="http://www.quirksmode.org/js/intro.html">Javascript</a> .  Given an input array <code></code> size <code>n</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M = A[ <span class="hljs-number"><span class="hljs-number">0</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( A[ i ] &gt;= M ) { M = A[ i ]; } }</code> </pre><br>  First, let's calculate how many <i>fundamental instructions</i> are calculated here.  We will do it only once - as we go deeper into theory, such a need will disappear.  But for now, have patience for the time we spend on it.  In the process of analyzing this code, it makes sense to break it into simple instructions - tasks that can be performed by the processor immediately or close to it.  Suppose that our processor is able to perform the following operations as a single instruction: <br><ul><li>  Assign variable value </li><li>  Find the value of a specific element in the array </li><li>  Compare two values </li><li>  Increment value </li><li>  Basic arithmetic operations (for example, addition and multiplication) </li></ul><br>  We will assume that the branching (the choice between <code>if</code> and <code>else</code> parts of the code after calculating <code>if</code> -conditions) occurs instantly, and we will not take this instruction into account when calculating.  For the first line in the code above: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M = A[ <span class="hljs-number"><span class="hljs-number">0</span></span> ];</code> </pre><br>  Two instructions are required: to search for <code>A[0]</code> and to assign a value to <code>M</code> (we assume that <code>n</code> always at least 1).  These two instructions will be required by the algorithm, regardless of the value of <code>n</code> .  Initializing the <code>for</code> loop will also occur all the time, which gives us two more commands: assignment and comparison. <br><br><pre> <code class="javascript hljs">i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n;</code> </pre><br>  All this happens before the first run of <code>for</code> .  After each new iteration, we will have two more instructions: the increment <code>i</code> and the comparison to check if it is time for us to stop the cycle. <br><br><pre> <code class="javascript hljs">++i; i &lt; n;</code> </pre><br>  Thus, if we ignore the contents of the loop body, then the number of instructions in this algorithm is <code>4 + 2n</code> - four at the beginning of the <code>for</code> loop and two for each iteration, which we have <code>n</code> pieces.  Now we can define a mathematical function <code>f(n)</code> such that, knowing <code>n</code> , we will know the number of instructions required by the algorithm.  For a for loop with an empty body, <code>f( n ) = 4 + 2n</code> . <br><br><h4>  Analysis of the most unfavorable case </h4><br>  In the body of the loop, we have search operations in the array and comparisons that always occur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( A[ i ] &gt;= M ) { ...</code> </pre><br>  But the <code>if</code> body may or may not start, depending on the actual value from the array.  If it happens that <code>A[ i ] &gt;= M</code> , then we will run two additional commands: search in the array and assignment: <br><br><pre> <code class="javascript hljs">M = A[ i ]</code> </pre><br>  We can no longer determine <code>f(n)</code> so easily, because now the number of instructions depends not only on <code>n</code> , but also on specific input values.  For example, for <code>A = [ 1, 2, 3, 4 ]</code> program will require more commands than for A = [4, 3, 2, 1].  When we analyze algorithms, we most often consider the worst case scenario.  What will it be in our case?  When will the algorithm require the most instructions to complete?  Answer: when the array is ordered in ascending order, such as <code>A = [ 1, 2, 3, 4 ]</code> .  Then <code>M</code> will be reassigned each time, which will give the most commands.  Theorists have for this a bizarre name - <i>analysis of the most unfavorable case</i> , which is nothing more than a simple consideration of the most unfortunate option.  Thus, in the worst case, four instructions are run from our code in the loop body, and we have <code>f( n ) = 4 + 2n + 4n = 6n + 4</code> . <br><br><h4>  Asymptotic behavior </h4><br>  With the function obtained above, we have a very good idea of ‚Äã‚Äãhow fast our algorithm is.  However, as I promised, we do not need to constantly engage in such a tedious task, like counting commands in a program.  Moreover, the number of instructions for a particular processor required to implement each position of the programming language used depends on the compiler of this language and the set of commands available to the processor (AMD or Intel Pentium on a personal computer, MIPS on Playstation 2, etc.).  Earlier we said that we were going to ignore conditions of this kind.  Therefore, we will now skip our function <code>f</code> through a ‚Äúfilter‚Äù to clean it of minor details that theorists prefer to ignore. <br><br>  Our function <code>6n + 4</code> consists of two elements: <code>6n</code> and <code>4</code> .  When analyzing complexity, only what happens with the function of counting instructions with a significant increase in <code>n</code> important.  This coincides with the previous idea of ‚Äã‚Äãthe ‚Äúworst scenario‚Äù: we are interested in the behavior of an algorithm that is in ‚Äúbad conditions‚Äù when it is forced to perform something difficult.  Notice that this is really useful when comparing algorithms.  If one of them beats the other with a large input data stream, then it is likely that it will remain faster and on light, small streams.  That is why <b>we discard those elements of the function that increase as <code>n</code> grows slowly, and leave only those that grow strongly</b> .  Obviously, 4 will remain 4, regardless of the value of <code>n</code> , and <code>6n</code> contrary will grow.  Therefore, the first thing we will do is drop 4 and leave only <code>f( n ) = 6n</code> . <br><br>  It makes sense to think of 4 simply as an ‚Äúinitialization constant‚Äù.  Different programming languages ‚Äã‚Äãmay require different time settings.  For example, Java first needs to initialize its <a href="http://ru.wikipedia.org/wiki/Java_Virtual_Machine">virtual machine</a> .  And since we agreed to ignore the differences in programming languages, we simply discard this value. <br><br>  The second thing you can ignore is a factor in front of <code>n</code> .  So our function turns into <code>f( n ) = n</code> .  As you can see, this simplifies a lot.  Once again, it makes sense to discard the constant multiplier if we think about the differences in compile time for different programming languages ‚Äã‚Äã(PL).  ‚ÄúSearching in an array‚Äù for one PL can be compiled completely differently than for another.  For example, in C, performing <code>A[ i ]</code> does not include checking that <code>i</code> does not go beyond the declared size of the array, while for <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258C_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Pascal</a> it exists.  Thus, this Pascal code: <br><br><pre> <code class="delphi hljs">M := A[ i ]</code> </pre><br>  equivalent to the following in C: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; n ) { M = A[ i ]; }</code> </pre><br>  So it makes sense to expect that different programming languages ‚Äã‚Äãwill be influenced by various factors that will affect the counting of instructions.  In our example, where we use the ‚Äúdumb‚Äù Pascal compiler, ignoring optimization possibilities, we need three instructions in Pascal for each access to an array element instead of one in C.  Neglect of this factor goes in line with the neglect of the differences between specific programming languages ‚Äã‚Äãwith a focus on analyzing the very idea of ‚Äã‚Äãthe algorithm itself. <br><br>  The filters described above - ‚Äúdiscard all factors‚Äù and ‚Äúleave only the largest element‚Äù - together give what we call <i>asymptotic behavior</i> .  For <code>f( n ) = 2n + 8</code> it will be described by the function <code>f( n ) = n</code> .  Speaking in the language of mathematics, we are interested in the limit of the function <code>f</code> as <code>n</code> tends to infinity.  If you do not quite understand the meaning of this formal phrase, then do not worry - you already know everything you need.  (Aside: strictly speaking, in the mathematical formulation we could not reject constants in the limit, but for the purposes of theoretical informatics we act this way for the reasons described above).  Let's work on a couple of tasks in order to fully understand this concept. <br><img src="http://habrastorage.org/storage3/8e1/6b9/5ce/8e16b95ce9b5ce17d334e24ed0c65917.png" align="right"><br>  We find the asymptotics for the following examples, using the principles of discarding constant factors and leaving only the fastest growing element: <br><ol><li>  <code>f( n ) = 5n + 12</code> gives <code>f( n ) = n</code> . <br>  The bases are the same as those described above. </li><li>  <code>f( n ) = 109</code> will give <code>f( n ) = 1</code> . <br>  We drop the factor to <code>109 * 1</code> , but 1 is still needed to show that the function is non-zero. </li><li>  <code>f( n ) = n</code> <sup>2</sup> <code>+ 3n + 112</code> will give <code>f( n ) = n</code> <sup>2</sup> <br>  Here <code>n</code> <sup>2</sup> increases faster than <code>3n</code> , which, in turn, grows faster <code>112</code> </li><li>  <code>f( n ) = n</code> <sup>3</sup> <code>+ 1999n + 1337</code> will give <code>f( n ) = n</code> <sup>3</sup> <br>  Despite the large magnitude of the factor before <code>n</code> , we still believe that we can find an even larger <code>n</code> , therefore <code>f( n ) = n</code> <sup>3</sup> is still more than <code>1999n</code> (see the figure above) </li><li>  <code>f( n ) = n + sqrt( n )</code> will give <code>f( n ) = n</code> <br>  Because <code>n</code> increasing the argument grows faster than <code>sqrt( n )</code> </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Exercise 1</b> <div class="spoiler_text"><ol><li>  f (n) = n <sup>6</sup> + 3n </li><li>  f (n) = 2 <sup>n</sup> + 12 </li><li>  f (n) = 3 <sup>n</sup> + 2 <sup>n</sup> </li><li>  f (n) = n <sup>n</sup> + n </li></ol><br>  If you have problems with performing this task, then just substitute a large enough <code>n</code> into the expression and see which of its members has <b>the</b> most value.  It's very simple, isn't it? <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/196560/">https://habr.com/ru/post/196560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196544/index.html">Stored Functions on C in PostgreSQL</a></li>
<li><a href="../196546/index.html">We are preparing a web application for the zoo versions of Android</a></li>
<li><a href="../196548/index.html">Lock-free data structures. The basics: where did the memory barriers go from?</a></li>
<li><a href="../196550/index.html">Configuring Vim to work with Python code</a></li>
<li><a href="../196556/index.html">Test of the prototype of the iLook Media Center</a></li>
<li><a href="../196562/index.html">Wi-Fi Mesh networks for the smallest</a></li>
<li><a href="../196564/index.html">Task sync plugin for Redmine</a></li>
<li><a href="../196566/index.html">Saving clouds</a></li>
<li><a href="../196568/index.html">HeadHunter on Android: finally!</a></li>
<li><a href="../196570/index.html">Self-assembly structures from moving cubes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>