<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic software testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 For a long time, it was believed that dynamic program analysis is too heavy an approach to detecting software defects, and the results ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic software testing</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  For a long time, it was believed that dynamic program analysis is too heavy an approach to detecting software defects, and the results do not justify the effort and resources expended.  However, two important trends in the development of the modern software industry allow us to take a fresh look at this problem.  On the one hand, with a constant increase in the volume and complexity of the software, any automatic error detection and quality control tools can be useful and in demand.  On the other hand, the continuous increase in the productivity of modern computing systems makes it possible to effectively solve increasingly complex computational problems.  Recent research in the field of dynamic analysis, such as <a href="http://research.microsoft.com/en-us/um/people/pg/public_psfiles/ndss2008.pdf">SAGE</a> , <a href="http://llvm.org/pubs/2008-12-OSDI-KLEE.pdf">KLEE</a> and <a href="http://code.google.com/p/avalanche/">Avalanche</a> , demonstrate that despite the inherent complexity of this approach, its use is justified, at least for some class of programs. <br><br><a name="habracut"></a><br><h4>  Dynamic vs Static Analysis </h4><br>  Static analysis is often considered as a more effective alternative to dynamic analysis.  In the case of static analysis, the search for possible errors is carried out without launching the program under study, for example, from the source code of the application.  Usually, an abstract model of the program is built, which, in fact, is the object of analysis. <br>  The following characteristic features of static analysis should be emphasized: <br><ul><li>  Separate analysis of individual fragments of a program (usually individual functions or procedures) is possible, which provides a reasonably effective way of dealing with the non-linear increase in the complexity of analysis. </li><li>  False positives are possible, either due to the fact that some details are ignored in the construction of an abstract model, or because the analysis of the model is not exhaustive. </li><li>  When a defect is detected, firstly, the problem of checking the truth of the detected defect ( <a href="http://ru.wikipedia.org/wiki/False_positive">false positive</a> ) and, secondly, the problem of reproducing the found defect when the program is run on certain input data. </li></ul><br>  Unlike static analysis, dynamic analysis is performed while the program is running.  Wherein: <br><ul><li>  To run the program requires some input. </li><li>  Dynamic analysis detects defects only on the track defined by specific input data;  defects located in other parts of the program will not be detected. </li><li>  In most implementations, the occurrence of false positives is excluded, since error detection occurs at the moment of its occurrence in the program;  Thus, the detected error is not a prediction made on the basis of the analysis of the program model, but a statement of the fact of its occurrence. </li></ul><br><br><h3>  Application </h3><br>  Automated testing is primarily intended for programs for which performance and security with any input data are the most important priorities: web server, SSH client / server, sandboxing, network protocols. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Fuzz testing (fuzzing) </h3><br>  <b>Fuzzing</b> is a testing technique in which <b>non</b> - <b>valid</b> , unintended or random data is input to a program. <br><br>  The main idea of ‚Äã‚Äãthis approach is to randomly ‚Äúmutate‚Äù, i.e.  change the expected input data in arbitrary places.  All fuzzers work in approximately the same way, allowing you to set some constraints on the mutation of input data by certain bytes or a sequence of bytes.  As an example, we can mention: <a href="http://linux.die.net/man/1/zzuf">zzuf (linux)</a> , minifuzz (Windows), filefuzz (Windows).  Protocol phasers: <a href="https://www.ee.oulu.fi/research/ouspg/Protos">PROTOS (WAP, HTTP-reply, LDAP, SNMP, SIP) (Java)</a> , <a href="http://www.blackhat.com/presentations/bh-usa-02/bh-us-02-aitel-spike.ppt">SPIKE (linux)</a> .  Fuzzing frameworks: <a href="http://code.google.com/p/sulley/">Sulley (framework for creating complex data structures)</a> . <br>  <b>Fuzz testing</b> - the forerunner of automatic testing, the method of ‚Äúbrute force‚Äù.  Of the advantages of this approach, only its simplicity stands out.  The obvious disadvantage is that Fazzer knows nothing about the program‚Äôs internal structure and, ultimately, to completely cover the code, he has to sort through an <i>astronomical number of</i> options (as you might guess, a full search grows exponentially from the size of the input data O (c ^ n), c&gt; 1). <br><br><h3>  Phasers new generation (review) </h3><br>  The logical but not so simple continuation of the idea of ‚Äã‚Äãautomatic testing was the emergence of approaches and programs that allow to impose restrictions on mutable input data, taking into account the specifics of the program under study. <br><br><h5>  Tracking of tagged data in the program </h5><br>  The concept of symbolic or <i>tainted</i> data is introduced - data received by the program from an external source (standard input stream, files, environment variables, etc.).  A common solution to this problem is to intercept a set of system calls: open, close, read, write, lseek (Avalanche, KLEE). <br><br><h5>  Code Instrumentation </h5><br>  The code of the program under study is reduced to a form suitable for analysis.  For example, an internal hardware-independent representation of <a href="http://ru.wikipedia.org/wiki/Valgrind">valgrind</a> (Avalanche) is used, or the <a href="http://habrahabr.ru/blogs/programming/47878/">llvm bytecode of the</a> program (KLEE), convenient for parsing, is analyzed. <br><br>  The instrumented code makes it easy to find potentially dangerous instructions (for example, division by zero or dereferencing a null pointer) and their operands, as well as branch instructions that depend on the tagged data.  Analyzing the instructions, the tool creates logical conditions for the tagged data and transmits a request for satisfiability to the ‚Äúsolver‚Äù of Boolean formulas ( <b>SAT Solver</b> ). <br><br><h5>  Solving Boolean constraints </h5><br>  <b>SAT Solvers</b> - solve the problems of the feasibility of Boolean formulas.  They answer the question: is the given formula always fulfilled, and if not always, a set of values ‚Äã‚Äãis given, on which it is false.  The results of the work of such solvers are used by a wide range of analyzing programs, from <i>theorem provers</i> to genetic code analyzers in bioinformatics.  Such programs are interesting in their own right and require separate consideration.  Examples: <a href="https://sites.google.com/site/stpfastprover/">STP</a> , <a href="http://minisat.se/">MiniSAT</a> . <br><br><h5>  Simulation environment </h5><br>  In addition to intercepting system calls, analyzers need to formalize the task to automatically generate conditions for the ‚Äúsolver‚Äù of Boolean formulas.  The input file, the set of registers and the address space (memory) of the program are represented using arrays of the Boolean ‚Äúsolver‚Äù. <br><h5>  Brute force in the program </h5><br>  Having received the answer from the ‚Äúsolver‚Äù, the tool receives a condition on the input data for inverting the conditional transition under study or finds out that it is always true or false.  Each condition variant creates a new independent path in the program, and the program has to consider each path and the conditions for its execution independently, i.e.  the paths are <i>forged</i> on each branch instruction depending on the input data.  New input data can open previously unopened basic blocks of the program under study, and so on.  For exhaustive testing, a complete search of all possible paths in the program is necessary.  Since the growth rate of the number of paths has decreased significantly compared with the brute force method (~ O (2 ^ n), where n is the number of conditional transitions depending on the input data), but still remains significant.  Analyzers are forced to use different heuristics to prioritize the analysis of certain paths.  In particular, there is a distinction between the choice of the path covering the largest number of uncovered (new) basic blocks (Avalanche, KLEE) and the choice of a random path (KLEE). <br><br><h4>  Avalche </h4><br>  <b>Avalanche</b> is a software defect detection tool using dynamic analysis.  Avalanche uses the program‚Äôs dynamic instrumentation capabilities provided by Valgrind to collect and analyze the program execution path.  The result of this analysis is either a set of input data on which an error occurs in the program, or a set of new test data, which allows you to bypass the previously unfulfilled and, accordingly, not yet verified program fragments.  Thus, having a single set of test data, Avalanche implements an iterative dynamic analysis in which the program is repeatedly executed on various automatically generated test data, with each new launch increasing the coverage of the program code with such tests. <br><br><h5>  General scheme of work </h5><br>  The Avalanche tool consists of 4 main components: two Valgrind expansion modules (plug-ins) - <i>Tracegrind</i> and <i>Covgrind</i> , an STP constraint checking tool and a control module. <br><br>  Tracegrind dynamically monitors the flow of tagged data in the analyzed program and collects conditions for bypassing its uncompleted parts and for triggering dangerous operations.  These conditions are transmitted by the control module to the STP to investigate their feasibility.  If any of the conditions is feasible, then the STP determines those values ‚Äã‚Äãof all the variables involved in the conditions (including the byte values ‚Äã‚Äãof the input file) that turn the condition to true. <br><ul><li>  In the case of the fulfillment of the conditions for triggering dangerous operations, the program is started up by the control module again (this time without any instrumentation) with the corresponding input file to confirm the error found. </li><li>  The conditions for bypassing the non-completed parts of the program determine the set of possible input files for new program launches.  Thus, after each program launch, the STP tool automatically generates a number of input files for subsequent analysis runs. </li><li> Next comes the task of choosing from this set the most ‚Äúinteresting‚Äù input data, i.e.  first of all, the input data on which the error is most likely to occur is to be processed.  To solve this problem, the heuristic metric is used - the number of previously untapped base blocks in the program (the base block is understood here in the sense that it is defined by the Valgrind framework).  To measure the heuristic value, the Covgrind component is used, whose functions also include fixing possible execution errors.  Covgrind is a much more lightweight module than Tracegrind, so a relatively quick measurement of the heuristic value for all previously received input files and selection of the input file with its highest value is possible. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/aea/878/625/aea8786257251f5c0d74dc35edaba2f7.png" alt="image"><br><br><h5>  Restrictions </h5><ul><li>  single input file marked or socket </li><li>  error analysis is limited to dereferencing a null pointer and dividing by zero. </li></ul><br><h5>  results </h5><br>  The effectiveness of finding bugs with Avalanche has been investigated on a large number of open source projects. <br><ul><li>  <b>qtdump</b> (libquicktime-1.1.3).  Three defects are associated with the dereferencing of a null pointer, one - with the presence of an infinite loop, in another case there is a call to an incorrect address (segmentation error).  Part of the defects corrected by the developer. </li><li>  <b>flvdumper</b> (gnash-0.8.6).  The immediate occurrence of a defect is associated with the occurrence of an exceptional situation in the application library used by the application boost (one of the internal pointers of the boost library turns out to be zero).  Since the application itself does not catch the exception that has occurred, the program ends with a SIGABRT signal.  Defect is corrected by the developer. </li><li>  <b>cjpeg</b> (libjpeg7).  The application reads a zero value from the file and, without a corresponding check, uses it as a divisor, which causes a floating point exception and terminates the program with a SIGFPE signal.  Defect is corrected by the developer. </li><li>  <b>swfdump</b> (swftools-0.9.0).  The occurrence of both defects is associated with the dereferencing of the null pointer. </li></ul><br><br><h3>  <b><a href="http://klee.llvm.org/">KLEE</a></b> </h3><br>  KLEE is somewhat different from Avalanche in that it does not look for suspicious places, but tries to cover as much code as possible and conduct an exhaustive analysis of the paths in the program.  According to the general scheme, KLEE is similar to Avalanche, but uses other basic tools for solving the problem, which imposes its own limitations and advantages. <br><ul><li>  Instead of the valgrind instrumentation that Avalanche uses, KLEE analyzes programs in llvm-bytecode.  Accordingly, it allows analyzing the program in any programming language for which there is an llvm-backend. </li><li>  KLEE also uses STP to solve the boolean constraint problem. </li><li>  KLEE also intercepts about 50 system calls, allowing multiple virtual processes to run in parallel without interfering with each other. </li><li>  Optimization and caching of requests to STP. </li></ul><br>  KLEE is a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">symbolic</a> virtual machine, where symbolic processes run in parallel (within the terminology of KLEE: <i>states</i> ), where each process is one of the paths in the program under study.  Effective implementation of forks of such processes (not by the system means) at each branch in the program allows you to analyze a large number of paths simultaneously. <br>  For each unique traversed path, KLEE stores a set of input data required to traverse that path. <br>  The KLEE capabilities allow you to check the equivalence of any two functions ( <i>checking the identical functionality of a working prototype, refactoring</i> ) over the entire range of specified input data at low cost (an extensive API is provided). <br>  The following example illustrates this functionality: <br><blockquote>  <font color="#0000ff">unsigned</font> mod_opt <font color="#008000">(</font> <font color="#0000ff">unsigned</font> x, <font color="#0000ff">unsigned</font> y <font color="#008000">)</font> <font color="#008000">{</font> <br>  <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#008000">(</font> y <font color="#000040">&amp;</font> ‚àíy <font color="#008000">)</font> <font color="#000080">==</font> y <font color="#008000">)</font> <font color="#666666">// power of two?</font> <br>  <font color="#0000ff">return</font> x <font color="#000040">&amp;</font> <font color="#008000">(</font> y‚àí <font color="#0000dd">1</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">else</font> <br>  <font color="#0000ff">return</font> x <font color="#000040">%</font> y <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">unsigned</font> mod <font color="#008000">(</font> <font color="#0000ff">unsigned</font> x, <font color="#0000ff">unsigned</font> y <font color="#008000">)</font> <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> x <font color="#000040">%</font> y <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br>  <font color="#0000ff">unsigned</font> x, y <font color="#008080">;</font> <br>  make symbolic <font color="#008000">(</font> <font color="#000040">&amp;</font> x, <font color="#0000dd">sizeof</font> <font color="#008000">(</font> x <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  make symbolic <font color="#008000">(</font> <font color="#000040">&amp;</font> y, <font color="#0000dd">sizeof</font> <font color="#008000">(</font> y <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000dd">assert</font> <font color="#008000">(</font> mod <font color="#008000">(</font> x, y <font color="#008000">)</font> <font color="#000080">==</font> mod_opt <font color="#008000">(</font> x, y <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote><br>  By running KLEE in this example, you can verify the equivalence of two functions in the entire range of input values ‚Äã‚Äã(y! = 0).  Solving the problem of failure to fulfill the condition in assertion, KLEE, on the basis of enumeration of all possible paths, comes to the conclusion that the two functions are equivalent over the entire range of values. <br><br><h4>  results </h4><br>  To obtain real test results, the authors analyzed the entire coreutils 6.11 software suite.  The average code coverage percentage was 94%.  In total, the program generated 3321 sets of input data, allowing to cover the entire specified percentage of code.  It was also found 10 unique errors that were recognized by the developers of the package as real defects in the programs, which is a very good achievement, since this set of programs has been developed for over 20 years and most of the errors have been fixed. <br><br><h4>  Restrictions </h4><br><ul><li>  no support for multi-threaded applications, floating-point symbolic data (STP restriction), assembler inserts. </li><li>  The application under test must be assembled into llvm-byte code (as well as its libraries!). </li><li>  for effective analysis you need to edit the code. </li></ul><br><br><h3>  Preliminary findings </h3><br>  Of course, dynamic analysis will find its niche among the tools that help individual programmers and teams of programmers to solve the problem, because  is an effective way to find errors in programs, as well as proof of their absence!  In some cases, such tools are simply vital (Mission critical software: RTOS, production management systems, aviation software, and so on). <br><br><h3>  Conclusion </h3><br>  It is planned to continue the topic of the article (the results of some experience with avalanche and KLEE, as well as a comparison of KLEE and Avalanche, a review of S2E (https://s2e.epfl.ch) (Selection Symbolic Execution)) provided positive feedback from Habr readers. <br><br>  The article contains fragments of the following works: <a href="http://code.google.com/p/avalanche/">avalanche_article</a> , <a href="http://www.doc.ic.ac.uk/~cristic/papers/klee-osdi-08.pdf">KLEE</a> , <a href="http://www.slideshare.net/VLDCORP/fuzz">Application of fuzz testing</a> . </div><p>Source: <a href="https://habr.com/ru/post/128503/">https://habr.com/ru/post/128503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128494/index.html">Google acquired another patent package from IBM</a></li>
<li><a href="../128498/index.html">Start</a></li>
<li><a href="../128500/index.html">260 ideas for startups</a></li>
<li><a href="../128501/index.html">Installing Windows 8 Developer Preview for Lazy</a></li>
<li><a href="../128502/index.html">Introduction to the Joomla Framework - we write a simple Web application</a></li>
<li><a href="../128505/index.html">Ubuntu EducationPack 11.04 - education, science and programming</a></li>
<li><a href="../128509/index.html">Finch - a robot as a tutorial on programming</a></li>
<li><a href="../128511/index.html">Scala Application Development</a></li>
<li><a href="../128512/index.html">Ubiquiti UniFi in StandAlone mode (without external controller)</a></li>
<li><a href="../128515/index.html">We read habr on all width of the browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>