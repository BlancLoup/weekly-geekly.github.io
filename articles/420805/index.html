<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[Translation] When to use parallel streams</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A source 
 Authors: Doug Lea with Brian Goetz, Paul Sandoz, Aleksey Shipilev, Heinz Kabutz, Joe Bowbeer, ... 

 The java.util.streams framework contai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[Translation] When to use parallel streams</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">A source</a> <br>  Authors: Doug Lea with Brian Goetz, Paul Sandoz, Aleksey Shipilev, Heinz Kabutz, Joe Bowbeer, ... </blockquote><p> The <code>java.util.streams</code> framework contains data-driven operations on collections and other data sources.  Most stream methods perform the same operation on each of the elements.  Using the <code>parallelStream()</code> collection method, if there are several cores, <em>data-driven</em> can be turned into <em>data-parallel</em> .  But when is it worth doing? </p><a name="habracut"></a><br><p>  Consider using <code>S.parallelStream().operation(F)</code> instead of <code>S.stream().operation(F)</code> , provided that the operations are independent of each other, and either costly in terms of computation, or applied to a large number of elements effectively split. (splittable) data structures, or both.  More precisely: </p><br><ul><li>  <code>F</code> : the function for working with one element, usually lambda, is independent, i.e.  performing an operation on any of the elements does not depend on and does not affect operations on other elements (for recommendations on the use of independent (non-interfering) stateless functions, see the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">documentation on the <em>stream</em> package</a> ). </li><li>  <code>S</code> : The original collection is effectively split.  In addition to the collections, there are also other, suitable for parallelization, stream data sources, for example, <code>java.util.SplittableRandom</code> (for which parallelization you can use the <code>stream.parallel()</code> method).  But most of the sources with I / O at the core are designed mainly for sequential operation. </li><li>  The total time in the sequential mode exceeds the minimum allowable limit.  Today, for most platforms, the limit is roughly equal (within x10) to 100 microseconds.  Accurate measurements, in this case, are not required.  For practical purposes, it is sufficient to simply multiply <code>N</code> (the number of elements) by <code>Q</code> (the running time of one <code>F</code> ), and <code>Q</code> can be roughly estimated by the number of operations or the number of lines of code.  Then you need to check that <code>N * Q</code> is at least less than <code>10000</code> (if you are a coward, then add one or a couple of zeros).  So, if <code>F</code> is a small function like <code>x -&gt; x + 1</code> , then parallel execution will have meaning for <code>N &gt;= 10000</code> .  Conversely, if <code>F</code> is a weighty calculation, like finding the next best move in a game of chess, then the value of <code>Q</code> so great that <code>N</code> can be neglected, but as long as the collection is completely split. </li></ul><br><p>  The stream processing framework will not (and cannot) insist on any of the above.  If the calculations are dependent on each other, then their parallel execution does not make sense, or will be harmful at all and will lead to errors.  Other criteria derived from the above engineering constraints (issues) and tradeoffs (tradeoffs) criteria include: </p><br><ul><li>  <em>Start (Start-up)</em> <br>  The emergence of additional cores in processors, in most cases, was accompanied by the addition of a power management mechanism, which can be the cause of slower launch of cores, sometimes with additional overlays from the JVM, the operating system and the hypervisor.  In this case, the limit at which parallel mode makes sense roughly corresponds to the time required for a subtask to start processing a sufficient number of cores.  After that, parallel computing may be more energy efficient than sequential (depending on the details of the processors and systems. For an example, see the <a href="https://queue.acm.org/detail.cfm%3Fid%3D1658422">article</a> ). </li><li>  <em>Detailing (Granularity)</em> <br>  It rarely makes sense to split up and so small calculations.  The framework usually divides the task in such a way that the individual parts can work on all the available cores of the system.  If, after the start, there is practically no work for each core, then (usually sequential) efforts to organize parallel computing will be wasted.  Considering that in practice the number of nuclei ranges from 2 to 256 threshold, also prevents the undesirable effect of excessive division of the task. </li><li>  <em>Severability (Splittability)</em> <br>  The most efficiently split collections include <code>ArrayList</code> and <code>{Concurrent}HashMap</code> , as well as regular arrays ( <code>T[]</code> , which are divided into parts using static methods <code>java.util.Arrays</code> ).  The least efficiently splittable are <code>LinkedList</code> , <code>BlockingQueue</code> and most sources with I / O at the base.  The rest are somewhere in the middle (data structures that support random access and / or efficient search are usually effectively split).  If data fragmentation takes longer than processing, then efforts are vain.  If <code>Q</code> is large enough, then you can get a gain due to paralleling even for <code>LinkedList</code> , but this is quite a rare case.  In addition, some sources cannot be split into a single element, and thus there may be a limit on the degree of decomposition of the problem. </li></ul><br><p>  Obtaining the exact characteristics of these effects can be difficult (although, if you try, and doable using tools like <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> ).  But the cumulative effect is fairly easy to notice.  To experience it yourself - conduct an experiment.  For example, on a 32-core test machine, when small functions are started, like <code>max()</code> or <code>sum()</code> , the break-even point is approximately 10,000 over an <code>ArrayList</code> .  For more elements, acceleration is noted up to 20 times.  Working time for collections with less than 10,000 items is not much less than for 10,000, and therefore slower than sequential processing.  The worst result occurs with less than 100 elements - in this case, the involved threads stop doing nothing useful, because  calculations are completed before they start.  On the other hand, when operations on elements are time-consuming, in the case of using efficiently and fully split collections, such as <code>ArrayList</code> , the benefit is immediately visible. </p><br><p>  To paraphrase all of the above, the use of <code>parallel()</code> in the case of an unnecessarily small amount of computation can cost about <code>100</code> microseconds, and the use otherwise should save at least this time itself (or perhaps the clock for very large tasks).  The specific cost and benefits will vary over time and for different platforms, and, also, depending on the context.  For example, the launch of small computations in parallel within a sequential cycle enhances the effect of rises and falls (performance micro tests in which this manifests itself may not reflect the real situation). </p><br><h2 id="voprosy-i-otvety">  Questions and answers </h2><br><ul><li>  Why does the JVM itself not know when to perform operations in parallel mode? </li></ul><br><p>  She might try, but too often the decision would be wrong.  The search for fully automatic multi-core concurrency has not led to a universal solution over the past thirty years, and therefore, the framework uses a more robust approach, requiring the user to only choose between <em>yes or no</em> .  This choice is based on engineering problems that are constantly encountered in sequential programming, which are unlikely to completely disappear ever.  For example, you may encounter a 100-fold slowdown when searching for the maximum value in a collection containing a single element by comparison using this value directly (without a collection).  Sometimes the JVM can optimize such cases for you.  But this rarely happens in sequential cases, and never in the case of parallel mode.  On the other hand, it can be expected that, as it develops, the tools will help users make better decisions. </p><br><ul><li>  What if I don‚Äôt have enough knowledge about the parameters ( <code>F</code> , <code>N</code> , <code>Q</code> , <code>S</code> ) to make a good decision? </li></ul><br><p>  This, too, is similar to problems often encountered in sequential programming.  For example, the <code>S.contains(x)</code> method of the <code>Collection</code> class usually executes quickly if <code>S</code> is a <code>HashSet</code> , slowly if <code>LinkedList</code> , and moderately in other cases.  Usually, for the author of a component using a collection, the best way out of this situation is to encapsulate it and publish only a specific operation on it.  Then users will be isolated from the need to choose.  The same applies to parallel operations.  For example, a component with an internal <em>price</em> collection can define a method that checks its size to reach the limit, which will make sense until elementwise calculations become too expensive.  Example: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> priceStream().max(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priceStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (prices.size() &lt; MIN_PAR) ? prices.stream() : prices.parallelStream(); }</code> </pre> <br><p>  This idea can be extended to other considerations about when and how to use parallelism. </p><br><ul><li>  What if my function might do I / O or synchronized operations? </li></ul><br><p>  At one extreme are functions that do not meet the independence criteria, including successive I / O operations in nature, access to blocking synchronized resources, and cases where an error in one parallel subtask that performs I / O affects others.  Their parallelization does not make much sense.  On the other hand, there are calculations that occasionally perform I / O or rarely blocked synchronization (for example, most logging cases, and using such competitive collections as <code>ConcurrentHashMap</code> ).  They are harmless.  What lies between them requires more research.  If each subtask can block for a significant amount of time while waiting for I / O or access, CPU resources will be idle without being able to be used by the program or the JVM.  From such a bad all.  In these cases, parallel stream processing is not always the right choice.  But there are good alternatives - for example, asynchronous I / O and the <code>CompletableFuture</code> approach. </p><br><ul><li>  What if my source is based on I / O? </li></ul><br><p>  Currently, I / O using JDK <code>Stream</code> s generators (for example, <code>BufferedReader.lines()</code> ) are mainly adapted for use in sequential mode, processing elements one by one as they arrive.  Support for high-performance mass (bulk) processing of buffered I / O is possible, but, at the moment, this requires the development of special generators <code>Stream</code> s, <code>Spliterator</code> s and <code>Collector</code> .  Support for some common cases may be added in future JDK releases. </p><br><ul><li>  What if my program runs on a booted computer and all the cores are busy? </li></ul><br><p>  Machines usually have a fixed number of cores, and cannot magically create new ones when performing parallel operations.  However, as long as the criteria for choosing a parallel mode are clearly spoken <em>for</em> , there is nothing to doubt.  Your parallel tasks will compete for others with the CPU and you will notice less acceleration.  In most cases, it is still more effective than other alternatives.  The underlying mechanism is designed so that if there are no available cores, you will notice only a slight slowdown in comparison with the sequential option, unless the system is so overloaded that it spends all its time switching the context instead of doing some real work, or configured with the expectation that all processing is performed sequentially.  If you have such a system, then perhaps the administrator has already disabled the use of multi-threading / kernel in the JVM settings.  And if you are the system administrator yourself, then it makes sense to do it. </p><br><ul><li>  Do all operations parallelize when using parallel mode? </li></ul><br><p>  Yes.  At least to some extent.  But it is necessary to take into account that the stream-framework takes into account the limitations of sources and methods when choosing how to do it.  In general, the less constraints, the greater the potential for concurrency.  On the other hand, there are no guarantees that the framework will identify and apply all available opportunities for parallelism.  In some cases, if you have the time and expertise, your own solution can make better use of the possibilities of parallelism. </p><br><ul><li>  What acceleration do I get from concurrency? </li></ul><br><p>  If you follow these tips, it is usually enough to make sense.  Predictability is not the strength of modern hardware and systems, and therefore there is no universal answer.  The cache locality, GC characteristics, JIT compilation, memory access conflicts, data location, OS dispatch policies, and the presence of the hypervisor are some of the factors that have significant influence.  The performance of the sequential mode is also affected by them, which, when using parallelism, is often exacerbated: a problem causing a 10 percent difference in the case of sequential execution can lead to a 10-fold difference in parallel processing. </p><br><p>  Stream-framework includes some features that help increase the chances of acceleration.  For example, using specialization for primitives, such as <code>IntStream</code> , usually has a greater effect for parallel mode than for serial mode.  The reason is that in this case not only the consumption of resources (and memory) is reduced, but also the locality of the cache is improved.  Using <code>ConcurrentHashMap</code> instead of <code>HashMap</code> , in the case of the parallel operation of the <code>collect</code> operation, reduces internal costs.  New tips and recommendations will appear as you gain experience with the framework. </p><br><ul><li>  All this is too scary!  Can we just come up with rules for using JVM properties to turn off concurrency? </li></ul><br><p>  We don't want to tell you what to do.  The appearance for programmers of new ways to do something wrong may be scary.  Errors in code, architecture, and evaluations will of course occur.  Decades ago, some people predicted that having concurrency at the application level would lead to more trouble.  But it never came true. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/420805/">https://habr.com/ru/post/420805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420793/index.html">Debug as a process</a></li>
<li><a href="../420795/index.html">Analyst Misconceptions</a></li>
<li><a href="../420797/index.html">Learning can not be postponed or not only by machine learning is a person alive</a></li>
<li><a href="../420799/index.html">MPS 2018.2: Generator Tests, GitHub Plugin, VCS Aspect, Migration Notifications, and More</a></li>
<li><a href="../420803/index.html">3D printing lessons. Plastic savings when printing non-functional models from 3Dtool</a></li>
<li><a href="../420809/index.html">Security Week 31: Fifty shades of insecurity in Android</a></li>
<li><a href="../420811/index.html">Decentralized messenger and new generation telephone network</a></li>
<li><a href="../420813/index.html">Behind the scenes of the network in Kubernetes</a></li>
<li><a href="../420815/index.html">How ‚Äúdecoding of the digital world‚Äù exploded the hall: top 10 reports DotNext 2018 Piter</a></li>
<li><a href="../420819/index.html">Top 10 Python tools for machine learning and data-science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>