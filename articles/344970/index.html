<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ChatScript Intelligent Chatbots: Development Practice and JavaScript Integration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we are publishing the second part of the translation of material on the development of chat bots using ChatScript and JavaScript. Last time, we ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ChatScript Intelligent Chatbots: Development Practice and JavaScript Integration</h1><div class="post__text post__text-html js-mediator-article">  Today we are publishing the second part of the translation of material on the development of chat bots using ChatScript and JavaScript.  <a href="https://habrahabr.ru/company/ruvds/blog/344604/">Last time,</a> we were mainly engaged in theory.  Namely, they talked about chat bots usage scenarios and the internal structure of CS applications.  Today there will be more practice.  Namely, we will discuss the working environment of ChatScript, talk about the integration of CS and JS, and discuss approaches to solving problems characteristic of chat bots. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd0/fe5/e5b/bd0fe5e5b003676b542d6ae4d23a20ec.jpg" alt="image"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">ChatScript environment</font> </h2><br><h3>  <font color="#3AC1EF"> Command line interface</font> </h3><br>  ChatScript has a command line interface (CLI, Command Line Interface), which is used during development as an aid.  In particular, it is necessary to build chat bots. <br><br>  The basic command that will be needed during the course of work is, of course <code>:build</code> .  With its help, first of all, you need to collect the bot's zero level to use concepts that are predefined in the system (for example, <code>~yes</code> , <code>~timeinfo</code> , <code>~number</code> ).  Then they collect everything that relates to a specific bot, giving the same name in this command that was used for the file with the list of topics used in the script. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another useful command is <code>:reset</code> .  It returns the bot to its original state, and, in addition, clears all variables for long-term data storage (these values ‚Äã‚Äãare preserved even after assembly). <br><br>  The <code>:trace</code> command allows you to perform a full trace of the stack of rules and topics called during the analysis of the last portion of data received from the user. <br><br>  The <code>:why</code> command <code>:why</code> used to display the rules, the application of which affected the latest output generated by the bot.  To switch between users, use the command <code>:user</code> , which, as a parameter, takes the user name. <br><br>  The <code>:quit</code> command stops the chatScript process. <br><br>  In the process of adding new rules, it is useful to check whether they violate the work of previously created templates.  There is a very useful command for this <code>:verify</code> .  The developer, in order to use it, you need to add in front of each template a set of phrases to which it should correspond.  The syntax of these check phrases is: <br><br><pre> <code class="hljs sql"><span class="hljs-comment"><span class="hljs-comment">#! I want burger #! I will take salad #! I need icecream u: BURGER (I {will} [want need take] ~food_type)</span></span></code> </pre> <br>  When executing the command, a detailed report will be displayed on which phrases the system successfully passed the test, and on which phrases it did not: <br><br><pre> <code class="hljs dos">fastfood&gt; :<span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> fastfood VERIFYING ~fastfood ...... Pattern failed to match <span class="hljs-number"><span class="hljs-number">1</span></span> ~fastfood.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>:  I need icecream =&gt; u: FOOD ( ^want ( _~food_type ) )  Adjusted Input: I need ice_cream  Canonical Input: I need ice_cream <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> findings of <span class="hljs-number"><span class="hljs-number">3</span></span> trials.</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPerformance</font> </h3><br>  CS is a lightweight process, so it is quite possible to run several instances of it on one computer.  Moreover, operations such as pattern matching and concept searching are well optimized, they work very fast and support many connections.  In order to check whether CS is fast enough, we wrote our own small benchmark aimed at studying the performance of a chat bot under load.  Our wrapper class, written in JS, sends a set of 10,000 requests and measures the time it takes the engine to answer them.  Here are the results of these tests: <br><br><pre> <code class="hljs mel">Total messages count:  <span class="hljs-number"><span class="hljs-number">10000</span></span> Chunks count:  <span class="hljs-number"><span class="hljs-number">100</span></span> Chunks <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>:  <span class="hljs-number"><span class="hljs-number">100</span></span> Percentage of the requests served within a certain time (ms) <span class="hljs-number"><span class="hljs-number">10</span></span>%:  <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>%:  <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>%:  <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>%:  <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>%:  <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span>%:  <span class="hljs-number"><span class="hljs-number">21</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>%:  <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>%:  <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">90</span></span>%:  <span class="hljs-number"><span class="hljs-number">27</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>%:  <span class="hljs-number"><span class="hljs-number">29</span></span> Time taken <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tests:  <span class="hljs-number"><span class="hljs-number">19.972</span></span>  seconds. Requests per second:  <span class="hljs-number"><span class="hljs-number">500.70098137392347</span></span> [#/sec] Time per request:  <span class="hljs-number"><span class="hljs-number">1.9972</span></span> [ms]</code> </pre> <br>  The number of requests per second is less than one would expect, given the time taken to process one request. <br><br>  This happens because groups of messages are sent asynchronously, using promises.  Therefore, by multiplying the received number of requests per second by the total number of seconds that the test took, we get a number that is less than 10,000. <br><br><h3>  <font color="#3AC1EF">‚ñçContinuous integration in CS</font> </h3><br>  When you are working on a bot, expand its functionality, it is useful to periodically check whether, taking into account recent changes, what has been written before continues to work normally.  This, in fact, occurs quite often, especially if the templates you create are too general and may correspond to input data that you did not expect to match.  In order to cope with such problems, CS has a regression testing mechanism that can be used during the development process.  In order to prepare a data set for regression testing, you need to do the following: <br><br>  <b>1.</b> Create a fresh build with a stable chat bot version.  To do this, in CLI CS you need to run the following commands: <br><br><pre> <code class="hljs pgsql">./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>=":build 0" &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>=":build food" &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span></code> </pre> <br>  <b>2.</b> Create a list with all the phrases you want to test during the test.  You can put a file with it anywhere, but I prefer to store such files in the <code>REGRESS</code> directory of a CS project.  At the beginning of this file there should be a command to set up the user used for testing, and the <code>reset</code> command, which allows you to clear long-term data storage variables.  At the end of the file also need to insert a <code>reset</code> .  For our chat bot, the corresponding file might look like this: <br><br><pre> <code class="hljs pgsql">:<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> test :<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> I want burger I will take salad I need ice-cream :<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span></code> </pre> <br>  <b>3.</b> Now you need to organize the output of the output data that the bot generated based on the test list to the log.  The system will take input data, send it to the chat bot and receive answers from it.  The command must include the user name that is used to perform the regression test, and the path to save the output.  Again, you can use any path, but I advise you to store this output in the <code>RAWDATA_YOURBOT</code> directory.  For this purpose, you can create a separate folder, in our case the <code>RAWDATA_FOOD/TEST</code> folder was used.  You can generate the output using the following command: <br><br><pre> <code class="hljs pgsql">./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>=test_user source=REGRESS/food.txt &gt; /dev/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span></code> </pre> <br>  <b>4.</b> Initialize the file for the regression test (after completing this operation, enter: <code>quit</code> in the CS console): <br><br><pre> <code class="hljs pgsql">./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>=test_user <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>=":regress init test_user RAWDATA/FOOD/TEST/food.txt"</code> </pre> <br>  <b>5.</b> Perform a test and check whether the system has passed or not: <br><br><pre> <code class="hljs pgsql">./BINARIES/ChatScript <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>=test_user <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span>=":regress RAWDATA/TEST/food.txt"</code> </pre> <br><h2>  <font color="#3AC1EF">The practice of developing chat bots on CS</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Resolution of collisions in concepts</font> </h3><br>  Being engaged in the development of a bot, designed to work with input data related to a certain topic, you need to create your own concepts. <br><br>  It is useful to group only the words and phrases related by meaning.  It helps to reuse concepts in different templates and allows you to know in advance about the meanings of concepts in the concept.  Ideally, if all the words used are different, this mechanism works fine.  However, when working with large lists of terms, some words may appear in different concepts.  A completely normal approach is to not use these concepts in the same template.  However, I had to work with concepts that, when used together, had collisions in one of the types of phrases.  The main problem was that we, in fact, did not know anything about the order of the terms from the concept in the phrases.  That is why I had to use a construction of the form <code>&lt;&lt; ‚Ä¶ &gt;&gt;</code> in order for the system to match words located in any order: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">u:</span></span> ANY_ORDER_MATCH (I want &lt;&lt; {<span class="hljs-number"><span class="hljs-number">_</span></span>~concept_A} {<span class="hljs-number"><span class="hljs-number">_</span></span>~concept_B} <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>)</code> </pre> <br>  This is how this template works.  After the CS engine finds the first value in <code>~concept_A</code> , it no longer performs its search in <code>~concept_B</code> .  This gives us errors of the first type, or false-positive matches.  Since, due to collisions, one cannot lose the correct values, which coincide with the system, I found three ways to solve such problems. <br><br>  The first way is to exclude values ‚Äã‚Äãthat cause a collision between <code>~concept_A</code> and <code>~concept_B</code> .  However, such an approach would not be particularly useful if there is a need for accurate phrase recognition results, since a certain set of values ‚Äã‚Äãwill be lost. <br>  The second approach is to invite users to apply the parameters in the same order in which they appear in the template.  This solution can be used only if there is a clear protocol for communicating with the bot, and users know in advance when certain phrases are used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7d/c61/397/d7dc6139728e142c909a7dc0ffc9c3bb.jpg"><br>  <i><font color="#999999">Concept Collision</font></i> <br><br>  And finally, the third way to deal with collisions is to organize a set of terms where all collisions are moved to a separate concept, and then this concept is added to the template.  Then you can find out whether the data transmitted to the bot correspond to the concepts between the concepts or one of the concepts.  It looks like this: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">u:</span></span> ANY_ORDER_MATCH (I want &lt;&lt; {<span class="hljs-number"><span class="hljs-number">_</span></span>~concept_A} {<span class="hljs-number"><span class="hljs-number">_</span></span>~concept_B} {<span class="hljs-number"><span class="hljs-number">_</span></span>~concept_A_collision} <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">Several topics in one chat bot, or several topics in several bots?</font> </h3><br>  In our project, I was faced with the difficult task of implementing a chat bot for several different topics.  The same user phrases could be related to each of them, but these messages should have been processed differently depending on the topic being discussed with the bot.  I found two solutions to this problem. <br><br>  The first option relates to the message level.  You can specify an additional prefix that will apply to a specific topic and add it to each message that needs to be processed in the context of a specific topic.  For example, we have vegetarian and regular restaurants.  In this case, the question ‚Äúwhat salads do you have?‚Äù (‚ÄúWhich salads do you have?‚Äù) Should be given different answers.  The rules with this approach will look something like this: <br><br><pre> <code class="hljs perl">u: (&lt; vegetarian fastfood what salads)  We have $list_of_vegeterain_salads u: (&lt; common fastfood what salads)  We have $list_of_salads_with_meat</code> </pre> <br>  It can be seen that the phrases ‚Äúvegetarian fastfood‚Äù and ‚Äúcommon fastfood‚Äù, indicating, respectively, vegetarian and ordinary cuisine, will be added to the message before sending it to ChatScript.  The main advantage of this approach is that there is only one instance of the chat bot that will handle phrases from all possible topics.  But at the same time, it complicates the development process, as the size of the script increases, it turns out to be more difficult to expand and maintain.  In addition, this, at some stage of the work, may lead to additional conflicts between different topics. <br><br>  The second solution to the problem of processing the same statements on different topics is to transfer similar topics into different chat bots.  With this approach, before launching bots on the server, each of them must have its own folders for storing CS assemblies and user data.  Each bot will work independently, on its own port.  Before launching each instance, you must specify the location of the folders with the assembly, user data and the port number in the form of additional parameters (for example, - <code>./BINARIES/ChatScript topic=./TOPIC_VEGETARIAN users=./USERS_VEGETARIAN port=1045)</code> . <br><br>  A similar approach, when several bot instances are used, simplifies the expansion of each of them.  The minus is the additional load on the server. <br><br>  The creator of ChatScript declares that, in fact, there is no need to place different bots on different ports, and I believe that he is right.  Bots can exist together, in one assembly.  In the application I was working on, an approach using different ports was used to separate the bot instances and, if necessary, simplify disabling part of the logic implemented in the system (for example, if some clients do not need the support of all the implemented themes for which created the bots).  As a result, the use of different ports for different bots is an optional technique, however, in my case, it was he who was used, and in similar cases it can also be used. <br><br><h3>  <font color="#3AC1EF">‚ñçTonlet Handling</font> </h3><br>  The CS engine has a built-in mechanism for handling words entered with errors.  Usually long words can be recognized even if they contain typos.  However, it may happen that a common error in a certain engine word is not recognized.  There are several ways to deal with this problem. <br><br>  The first approach is to describe a word inside a pattern using a wildcard in the part of the word where a typo may appear: <br><br><pre> <code class="hljs sql">u: TYPO_PATTERN (I [want need will] <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">first</span></span> app*ach)</code> </pre> <br>  This pattern, namely, its ‚Äúapp * ach‚Äù part, will correspond to words beginning with ‚Äúapp‚Äù and ending in ‚Äúach‚Äù, and it does not matter how many characters there are between them, and what symbols they are.  As a result, both the correct and incorrect, in terms of the correctness of the spelling of the word, options will correspond to this rule. <br><br>  The second approach is to create a concept for a word with frequently encountered typos and include all variants of such typos in this concept.  Then this concept can be used in templates instead of the word: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">concept</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">frequency</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IGNORESPELLING</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[frequency ferquency freuqency]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">topic</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">topic_with_typos</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">keep</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">repeat</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">u</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TYPO_CONCEPT</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">I</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">know</span></span> ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">frequency</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">of</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">typo</span></span>)</code> </pre> <br>  Please note that I used the <code>IGNORESPELLING</code> flag <code>IGNORESPELLING</code> .  This allows you to avoid warnings about errors in the concept during the assembly of the bot. <br><br>  The third option suits me best.  It lies in the fact that you can expand the existing database of engine fixes.  In order to do this, you need to add to the file <code>ChatScript_LIVEDATA_ENGLISH_SUBSTITUTES_spellfix.txt</code> lines containing the word and spelling variants of this misspelled word: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">misspell</span></span> mispell</code> </pre> <br>  After that, just restart the engine. <br><br><h3>  <font color="#3AC1EF">Chat ChatScript interaction with JavaScript</font> </h3><br>  Using ChatScript, it is easy to implement the logic of processing phrases and studying user information, but in any case, if CS capabilities are needed in some web project, you need to establish communication with the server on which the bot is running.  Unfortunately, CS does not allow to organize data exchange via HTTP.  However, for these purposes you can use TCP sockets. <br><br>  When using the Node.js server, in order to establish a connection with the bot, you need to connect the <code>net</code> package and, before sending the message line to the bot, in a special way to prepare it.  First of all, you need to add a prefix and postfix to the message being sent.  The prefix consists of the username and the name of the <code>outputmacro</code> macro used in the control script.  Between this information, you must use special delimiter characters.  In our example, <code>simplecontrol.top</code> used from the Harry chat bot, the macro is called <code>harry</code> .  In order for a bot to establish a connection, it must be started without the <code>local</code> parameter (by default it is on port 1024, but this can be changed using the key of the form <code>port=PORT_NUMBER</code> , for example - <code>./BINARIES/ChatScript port=1055</code> ) . <br><br>  As a rule, all connections to chat bots from JS look like this: <br><br><pre> <code class="hljs coffeescript">const net    = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'net'</span></span>); const prefix = <span class="hljs-string"><span class="hljs-string">'username\x00harry\x00'</span></span>; const post   = <span class="hljs-string"><span class="hljs-string">'\x00'</span></span> const client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> net.Socket(); client.connect(<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {  client.write(prefix + <span class="hljs-string"><span class="hljs-string">'some message'</span></span> + post); }); client.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.toString());</code> </pre> <br>  You can simplify the connection by adding an additional level of abstraction, using the methods of the <code>Socket</code> object, writing a wrapper class in JS to organize interaction with CS.  In this class, it is enough to have an asynchronous method of sending data and a constructor to set the host name of the server and the port before interacting with the CS engine.  As an additional parameter, the user name can be passed to such a constructor.  CS is able to communicate with various users, as it saves the state and stores all the data that he learned about the user in long-term memory. <br><br><h3>  <font color="#3AC1EF">CS CS and JS integration architecture</font> </h3><br>  In order to clearly understand how CS integrates with JS, and learn about the architecture of a JavaScript web application that will use ChatScript as an engine for recognizing user messages, take a look at the following figure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11a/556/9cf/11a5569cf6d6387a0c14f0fa408ed09e.png"><br>  <i><font color="#999999">Application architecture using chat bot on CS</font></i> <br><br>  As you can see, the process starts in the user interface.  This part of the system depends on exactly what technologies are used to implement the chat interface that provides user interaction with the bot.  Then comes the REST API layer (in our case, this is the server on Node.js).  The REST API server uses the CS wrapper class written in JS, described above.  It is this part of the system that sends the user's message to the chat bot using TCP sockets and processes the answers of the bot, which either recognized the message or not.  The next component is the implementation of chat bots on CS, which performs message recognition.  There could be, for example, one huge topic containing all the rules, or logic implemented in the form of several entities.  We have already talked about this, once again I note that the internal structure of the bot depends on the needs of a particular project.  For the recognition of user phrases and issuing answers, the chat bot uses the CS engine, where it compares with patterns, searches in the knowledge base and in dictionaries.  In addition, here you can add an additional feature: your own concept with terms related to the application domain.  This may be necessary in order for a chat bot to define terms and answer frequently asked questions. <br><br><h3>  <font color="#3AC1EF">‚ñç Debugging</font> </h3><br>  Once a set of rules has been created in a script, it may be difficult to find out exactly what rule was called to process a certain phrase, in a situation where the two patterns overlap.  In this case, the CS creator <a href="">advises the</a> use of the construction <code>:verify blocking</code> , which allows you to get information about intersecting topics.  There is another convenient approach.  It was he who approached me.  I decided to create a variable that is intended to hold the name of the rule.  Then this variable simply joins everything that the bot produces.  As a result, you can immediately see which of the existing patterns causes a conflict when processing certain input data.  In code, it looks like this: <br><br><pre> <code class="hljs mel">u: BURGER (I {will} [want need take] _~burger)  $rule = BURGER  $order = _0  ^respond(~make_order) u: DRINKS (I {will} [want need take] _~drink_type)  $rule = DRINKS  $order = _0  ^respond(~make_order) topic: ~make_order keep repeat nostay [] u: ()  Okay, you can take your $order. (Catched <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule $rule)</code> </pre> <br><h3>  <font color="#3AC1EF">Project structure</font> </h3><br>  In our small example, all the code is placed in one file.  But when the size of such a file grows, it makes sense to divide the script into parts.  That is why I decided to create separate directories for concepts (the <code>CONCEPTS</code> directory), responses ( <code>RESPONDERS</code> ) and tests ( <code>TESTS</code> ): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">FOOD</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONCEPTS</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">RESPONDERS</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TESTS</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">food</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.top</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">simplecontroll</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.top</span></span></code> </pre> <br>  The main script, which contains rules related to one response category, can be replaced with an empty template and the <code>^respond</code> method to call topics from another file (the <code>nostay</code> flag should be used in this topic, because after processing the response, we need to return in the main topic).  Here is the file <code>food.top</code> , which contains the main topic: <br><br><pre> <code class="hljs delphi"># main topic <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> RAWDATA/FOOD/food.top topic: ~food keep <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> [] u: DRINKS ()  ^respond(~drinks) u: MEALS ()  ^respond(~meals)</code> </pre> <br>  Here is an example of a file with an auxiliary topic: <br><br><pre> <code class="hljs delphi"># topic <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> RAWDATA/FOOD/RESPONDERS/drinks.top topic: ~drinks keep <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> nostay [] u: DRINK (^want(_~drink_type))  Ok, take <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> drink your _0 .</code> </pre> <br>        ,       .      . <br><br><pre> <code class="hljs vhdl"># concepts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> RAWDATA/FOOD/CONCEPTS/food_concepts.top concept: ~food_type [burger potato salad ice-cream vegan_<span class="hljs-symbol"><span class="hljs-symbol">'s_burger</span></span>] concept: ~drink_type [~alcohol ~non_alcohol] concept: ~non_alcohol [cola juice milk water] concept: ~alcohol [rum gean wiskey vodka]</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>         ,      -  ChatScript     Node.js,        -   CS.  ,     CS,   <a href="https://github.com/bwilcox-1234/ChatScript"></a>   GitHub. <br><br>  <b>Dear readers!</b>           -,  ,     CS? </div><p>Source: <a href="https://habr.com/ru/post/344970/">https://habr.com/ru/post/344970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344960/index.html">Phone number without a passport</a></li>
<li><a href="../344962/index.html">Git bottom to top</a></li>
<li><a href="../344964/index.html">FAQ on integration with ESIA</a></li>
<li><a href="../344966/index.html">HyperRAM: Using a HyperBus Memory Interface Chip</a></li>
<li><a href="../344968/index.html">Translation - Maximum Usage APK Analyzer</a></li>
<li><a href="../344972/index.html">Found the largest database of stolen passwords: what you should know</a></li>
<li><a href="../344974/index.html">Solving the problem of class name CSS conflicts in a React application using a webpack loader</a></li>
<li><a href="../344980/index.html">Simplify user action log</a></li>
<li><a href="../344982/index.html">Lectures of the Technosphere. Neural networks in machine learning</a></li>
<li><a href="../344984/index.html">Automated correction of indentation in layout based on typographic styles and text metrics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>