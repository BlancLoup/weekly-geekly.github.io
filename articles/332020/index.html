<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript: Many Faces Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are developing JavaScript, no matter what platform you are talking about, this means that you are able to appreciate the value of functions. Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript: Many Faces Functions</h1><div class="post__text post__text-html js-mediator-article">  If you are developing JavaScript, no matter what platform you are talking about, this means that you are able to appreciate the value of functions.  The way they work, the possibilities that they give to the programmer, make them a truly universal and indispensable tool.  <a href="https://github.com/tc39/test262">Test262</a> developers, the official test suite that is designed to test JavaScript engines for compatibility with the EcmaScript standard, think so. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/332020/"><img src="https://habrastorage.org/web/4a5/110/a3c/4a5110a3c74e439594b911feade54549.jpg"></a> <br><br>  In this material they give an overview of the syntactic forms of the definition of functions.  In particular, it will focus on what exists in JS from the day it appeared, what emerged in it over the years of development, and what should be expected in the future. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Traditional approaches</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçFunction declaration and function expression</font> </h3><br>  The most famous and widely used methods for defining functions in JS, in addition, are the oldest.  This is a function declaration (Function Declaration) and a functional expression (Function Expression).  The first method was part of the original version of the language since 1995 and was reflected in the <a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25201st%2520edition,%2520June%25201997.pdf">first edition of the</a> specification, in 1997.  The second is presented in the <a href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25203rd%2520edition,%2520December%25201999.pdf">third edition</a> , in 1999. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you look at these ways of defining functions, you can see three options for using them: <br><br><pre><code class="hljs lua">//   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}</code> </pre> <br><pre> <code class="hljs lua">//    // (BindingIdentifier     ) (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs lua">//    (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br>  Here, however, it is worth considering that an anonymous functional expression may still have a ‚Äúname‚Äù.  <a href="https://bocoup.com/blog/whats-in-a-function-name">Here is</a> some good stuff about function names. <br><br><h3>  <font color="#3AC1EF">FunctionConstructor Function</font> </h3><br>  If we talk about the "API functions" in JavaScript, then this conversation should start with the <code>Function</code> constructor.  Taking into account the initial approach to the design of the language, by analogy with other constructions, the above function declaration can be interpreted as a ‚Äúliteral‚Äù to the API of the <code>Function</code> constructor. <br><br>  The <code>Function</code> constructor provides the means to define functions by specifying the parameters and the body of the function through string arguments.  The last of these arguments is the function body: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'return x ** y;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  It is important to note that when defining functions using constructors, we are forced to resort to dynamic code execution, which is fraught with security problems. <br>  In practice, the <code>Function</code> constructor is used very rarely, although it is present in the language from the first edition of EcmaScript.  In most cases, it has much more convenient alternatives. <br><br><h2>  <font color="#3AC1EF">New approaches</font> </h2><br>  The <a href="https://www.ecma-international.org/ecma-262/6.0/index.html">ES2015</a> standard introduced several new syntactic forms for defining functions.  They have a huge number of options. <br><br><h3>  <font color="#3AC1EF">‚ñçNot such an anonymous function declaration.</font> </h3><br>  If you have experience with ES modules, you should be familiar with the new form of anonymous function declaration.  Although it is very similar to an anonymous functional expression, such a function actually has an <a href="https://tc39.github.io/ecma262/">associated name</a> <code>"*default*"</code> .  As a result, the function is not so anonymous. <br><br><pre> <code class="hljs haskell">//        <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function() {}</code> </pre> <br>  By the way, such a ‚Äúname‚Äù is not a valid identifier and a binding is not created here. <br><br><h3>  <font color="#3AC1EF">‚ñç Methods for determining methods of objects</font> </h3><br>  In the properties of objects that represent functions, you can easily recognize functional expressions, named and anonymous.  Please note that these constructions are not some special syntactic forms for defining functions.  These are the functional expressions already discussed above that are used in object initializers.  These designs were introduced in ES3. <br><br><pre> <code class="hljs lua">let object = { propertyName: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}, }; let object = { // (BindingIdentifier     ) propertyName: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}, };</code> </pre> <br>  Here are the property accessor declarations introduced in ES5: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> = { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propertyName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propertyName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> {}, };</code> </pre> <br>  In ES2015, an abbreviated syntax has appeared for defining object methods, which can be used both in the format of a regular property name and with square brackets that enclose a string representation of the name.  The same applies to property accessors: <br><br><pre> <code class="hljs markdown">let object = { propertyName() {}, [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {}, get [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {}, set [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"><span class="hljs-link">value</span></span>) {}, };</code> </pre> <br>  A similar approach can be used to define prototype methods in class declarations (Class Declarations) and in class expressions (Class Expressions): <br><br><pre> <code class="hljs markdown">//   class C { methodName() {} [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} get [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} set [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"><span class="hljs-link">value</span></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//   let C = class { methodName() {} [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} get [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} set [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"><span class="hljs-link">value</span></span>) {} };</code> </pre> <br>  The same applies to static class methods: <br><br><pre> <code class="hljs markdown">//   class C { static methodName() {} static [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} static get [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} static set [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"><span class="hljs-link">value</span></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//   let C = class { static methodName() {} static [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} static get [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} static set [<span class="hljs-string"><span class="hljs-string">"computedAccessorName"</span></span>](<span class="hljs-link"><span class="hljs-link">value</span></span>) {} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFireout functions</font> </h3><br>  The arrow functions, which appeared in ES2015, made a lot of noise, however, as a result they gained wide popularity and popularity.  There are two forms of switch functions.  The first is the short form (Concise Body), which does not provide for the presence of curly brackets after the arrow, there is only an assignment expression (Assignment Expression).  The second is a block form.  Here, after the arrow, comes the function body in curly brackets, which can be empty, or contain a number of expressions. <br><br>  If the switch function has no arguments, or more than one, then what is in front of the arrow should be enclosed in parentheses.  If such a function has only one argument, the use of parentheses is optional. <br><br>  In practice, the above means the presence of a variety of options for determining the arrow functions: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//       (x =&gt; x ** 2);</span></span></code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//        (x =&gt; { return x ** 2; });</span></span></code> </pre> <br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> x ** y);</code> </pre> <br>  The last part of the example shows a set of parameters of the arrow function in brackets (covered parameters).  This approach allows you to work with a list of parameters, for example, allowing you to use restructuring patterns: <br><br><pre> <code class="hljs lisp">({ x }) =&gt; x</code> </pre> <br>  The parameter without brackets (uncovered parameter), as already mentioned, allows you to specify a switch function that has only one argument.  Before this single argument, you can use the keywords <code>await</code> or <code>yield ‚Äî</code> if the switch function is defined inside an asynchronous function or generator, but that‚Äôs where the possibilities of this syntax end. <br><br>  Arrow functions can be used in object initializers and when setting their properties.  Arrow Function Expression is used here: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x ** <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">propertyName</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x ** <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçGenerators</font> </h3><br>  Generators have a special syntax.  It consists in adding an asterisk to the definitions of functions, with the exception of the switch functions and the declarations of getters and setters.  The result is a declaration of functions and methods, functional expressions, and even constructors.  Take a look at all this in the following example: <br><br><pre> <code class="hljs lua">//   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}</code> </pre> <br><pre> <code class="hljs haskell">//        <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function *() {}</code> </pre> <br><pre> <code class="hljs lua">//   // (BindingIdentifier      ) (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs lua">//    (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs markdown">//   let object = { <span class="hljs-emphasis"><span class="hljs-emphasis">*methodName() {}, *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {}, };</code> </pre> <br><pre> <code class="hljs markdown">//      class C { <span class="hljs-emphasis"><span class="hljs-emphasis">*methodName() {} *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//       class C { static <span class="hljs-emphasis"><span class="hljs-emphasis">*methodName() {} static *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//      let C = class { <span class="hljs-emphasis"><span class="hljs-emphasis">*methodName() {} *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} };</code> </pre> <br><pre> <code class="hljs markdown">//       let C = class { static <span class="hljs-emphasis"><span class="hljs-emphasis">*methodName() {} static *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} };</code> </pre> <br><h2>  <font color="#3AC1EF">ES2017</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Asynchronous functions</font> </h3><br>  In June 2017, the ES2017 standard was published, in which, after several years of development, asynchronous functions (Async Functions) were presented.  Despite the fact that the standard literally just ‚Äúleft the typography‚Äù, many developers already use asynchronous functions thanks to <a href="https://babeljs.io/">Babel</a> . <br><br>  Asynchronous functions allow you to conveniently describe asynchronous operations.  Thanks to their use, the code is clean and uniform.  When an asynchronous function is called, a promise will be returned, which will be resolved after the asynchronous function returns the result of its work.  If an expression with the <code>await</code> keyword is encountered in an asynchronous function, it may pause, and wait for the expression to complete, for example, return its results. <br><br>  The syntax of asynchronous functions is not particularly different from what has already been considered.  Their main feature is the <code>async</code> prefix: <br><br><pre> <code class="hljs lua">//    async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { /**/ }</code> </pre> <br><pre> <code class="hljs haskell">//          <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> async function() { /**/ }</code> </pre> <br><pre> <code class="hljs lua">//     // (BindingIdentifier     ) (async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs lua">//     (async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs markdown">//   let object = { async methodName() {}, async [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {}, };</code> </pre> <br><pre> <code class="hljs markdown">//      class C { async methodName() {} async [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//       class C { static async methodName() {} static async [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//      let C = class { async methodName() {} async [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} };</code> </pre> <br><pre> <code class="hljs markdown">//       let C = class { static async methodName() {} static async [<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Asynchronous switch functions</font> </h3><br>  The keywords <code>async</code> and <code>await</code> can be used not only with traditional function declarations and functional expressions.  They are compatible with switch functions: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//       (async x =&gt; x ** 2);</span></span></code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    ,      (async x =&gt; { return x ** 2; });</span></span></code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//         (async (x, y) =&gt; x ** y);</span></span></code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//    ,      (async (x, y) =&gt; { return x ** y; });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Look into the future</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Asynchronous Generators</font> </h3><br>  In future versions of the JavaScript specification, the use of the <code>async</code> and <code>await</code> keywords will be extended to generators.  The progress of the implementation of this functionality can be seen <a href="https://github.com/tc39/proposal-async-iteration">here</a> .  As you probably guessed, we are talking about a combination of <code>async/await</code> keywords and existing forms for defining generators - through declarations and expressions. <br><br>  The asynchronous generator, when called, returns an iterator, whose method <code>next()</code> returns a promise that will be resolved by the object, which is what the iterator normally returns.  Under normal conditions, calling this method will directly return the result. <br><br>  Asynchronous generators can be found where there are already ordinary generator functions. <br><br><pre> <code class="hljs lua">//    async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { /**/ }</code> </pre> <br><pre> <code class="hljs haskell">//         <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> async function *() {}</code> </pre> <br><pre> <code class="hljs lua">//    // (BindingIdentifier      ) (async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindingIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs lua">//    (async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre> <br><pre> <code class="hljs markdown">//   let object = { async <span class="hljs-emphasis"><span class="hljs-emphasis">*propertyName() {}, async *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {}, };</code> </pre> <br><pre> <code class="hljs markdown">//       class C { async <span class="hljs-emphasis"><span class="hljs-emphasis">*propertyName() {} async *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//       let C = class { async <span class="hljs-emphasis"><span class="hljs-emphasis">*propertyName() {} async *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }; //       class C { static async <span class="hljs-emphasis"><span class="hljs-emphasis">*propertyName() {} static async *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} }</code> </pre> <br><pre> <code class="hljs markdown">//       let C = class { static async <span class="hljs-emphasis"><span class="hljs-emphasis">*propertyName() {} static async *</span></span>[<span class="hljs-string"><span class="hljs-string">"computedName"</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) {} };</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font>  <font color="#3AC1EF">About JavaScript engines, tests and functions</font> </h2><br>  Imagine the path of a new way of defining a function from idea to working code.  In simplified form, it looks like this.  First, the idea becomes a proposal to the standard, then it enters the standard, then its implementation in JS engines goes on, then - the study by programmers and practical application. <br><br>  The contribution of those who work on Test262 to this process is to, after sorting out the standards, prepare tests that test new language constructs taking into account the existing ones.  Such an approach means a tremendous job of creating tests that is not rational to impose on a person.  For example, checking the arguments by default should be carried out with all forms of functions, in such things it cannot be limited to, say, a simple form of a function declaration.  All this led to the development of tools for creating tests, which suggests that almost everything that can be tested is subjected to tests. <br><br>  Now the project contains a set of <a href="https://github.com/tc39/test262/tree/master/src">files with source code</a> , which consist of different test scripts and <a href="https://github.com/tc39/test262/tree/master/src/function-forms/default">templates</a> . <br><br>  For example, <a href="https://github.com/tc39/test262/tree/master/src/arguments">here</a> you can see how the property of the <code>arguments</code> function is checked; <a href="https://github.com/tc39/test262/tree/master/src/arguments">here</a> , tests of various forms of functions.  Of course, there are a lot more in Test262.  Say, <a href="https://github.com/tc39/test262/tree/master/src/dstr-binding">here</a> and <a href="https://github.com/tc39/test262/tree/master/src/dstr-assignment">here</a> - tests related to destructuring.  In the process of working on tests, rather big pull requests are obtained, <a href="https://github.com/tc39/test262/pull/651">errors are</a> detected and corrected.  All this leads to a constant increase in the quality of Test262, which means to improved checks of JS engines for compliance with the EcmaScript specification.  This has a direct impact on the JavaScript industry.  The more software constructs will be identified and covered with tests, the easier it will be for engine developers to implement new features, the more stable and more reliable, as a result, JavaScript programs will work. <br><br>  Dear readers!  What methods of defining functions in JavaScript do you use most often? </div><p>Source: <a href="https://habr.com/ru/post/332020/">https://habr.com/ru/post/332020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332006/index.html">"Factory Method" in the development for Android. The best way to handle pushes</a></li>
<li><a href="../332008/index.html">Retrospective. 10 years of Yota and 10 interesting facts about the company</a></li>
<li><a href="../332012/index.html">NetApp HCI is the new generation hyperconvergent system for working with data</a></li>
<li><a href="../332016/index.html">‚ÄúIt is important to prioritize‚Äù: about testing at Sberbank Technologies</a></li>
<li><a href="../332018/index.html">How we unify analytic work in CUSTIS</a></li>
<li><a href="../332022/index.html">Startup Day (June 2017)</a></li>
<li><a href="../332024/index.html">Improving data quality with Oracle Enterprise Data Quality</a></li>
<li><a href="../332026/index.html">Libdispatch. How to make the application responsive</a></li>
<li><a href="../332028/index.html">How to choose a language to learn in 2017</a></li>
<li><a href="../332030/index.html">It would not be happy, but sports programming helped</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>