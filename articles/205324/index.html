<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Snake on the PLC. Our answer to Siemens</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. 

 Recently, they sent me a link to an article where an example of the implementation of a simple and at the same time cult game "Snake" in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Snake on the PLC. Our answer to Siemens</h1><div class="post__text post__text-html js-mediator-article">  Hello. <br><br>  Recently, they sent me a link to <a href="http://habrahabr.ru/post/203964/">an article</a> where an example of the implementation of a simple and at the same time cult game "Snake" in the controller of the Siemens s7-300 family was shown.  And I thought: everyone knows about monsters like Siemens, ABB, etc.  But modern domestic developments remain in the shadows. <br><br>  In this article I will show how in half an hour to implement the algorithm of the game "Snake" on the Russian <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25A2%25D0%259A_%25D0%259A%25D0%25B2%25D0%25B8%25D0%25BD%25D1%2582">industrial</a> control system <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25A2%25D0%259A_%25D0%259A%25D0%25B2%25D0%25B8%25D0%25BD%25D1%2582">"KVINT 7"</a> , developed in <a href="http://www.niiteplopribor.ru/">NIITeplopribor</a> .  And for more interest, the game will be fully implemented in the language of technological programming <a href="http://ru.wikipedia.org/wiki/FBD">FBD</a> , which is paid unfairly little attention. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, let's begin: <br><a name="habracut"></a><br>  Our task is to write the game "Snake" in half an hour. <br>  To implement the ideas we need: <br><ul><li>  Computer with installed QUINT 7 software </li><li>  R-400 controller </li><li>  Patchkord for communication of the controller with the computer </li><li>  License for operational tools (for the game) and design tools (to write the game itself) KVINT 7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">A little explanation</b> <div class="spoiler_text">  Although KVINT 7 has a complete virtualization of the entire process control system, an arbitrarily complex project can be implemented on one computer, but we will do everything for an adult. </div></div><br><br>  The algorithm of the game itself can be divided into several large blocks: <br><ul><li>  Generator (for clock generation) </li><li>  Management (so that you can play) </li><li>  Snake head (the element that we will manage) </li><li>  Snake tail (without it, the game loses its meaning, because the goal of the game is to collect as long as possible the tail) </li><li>  Food (those cells that the snake will "eat" and increase the length of the tail) </li><li>  Additional checks (allow you to make the game more convenient and more logical) </li></ul><br><br><h5>  Generator </h5><br>  To begin with, let's create a snake base.  Since  a snake in our country continuously crawls across the field, then the basis of the entire program will be a generator that gives out pulses with a period corresponding to the speed of the snake.  Let for a start this speed will be equal to 1 cell per second.  This generator is very easy to organize.  It will only be necessary an algorithm of logical AND, a pulse counter, an algorithm of comparison, and an algorithm of choice.  Total for 1 minute doing the simplest generator. <br><img src="https://habrastorage.org/getpro/habr/post_images/cb2/c2d/8a1/cb2c2d8a16b4a67af75de60cbf8ac8a7.png"><br>  The principle of operation is as follows.  At the output of algoblock " <i>I1</i> ", each cycle changes the logical value 1 &lt;-&gt; 0. <br>  Next, on the slab ‚Äú <i>Sludge1</i> ‚Äù, the number of units is calculated, which is compared with the value specified by us (in this example, 50, since the cycle time is 10 ms, then in 1 second the counter counts 50 inclusions). <br>  In <i>case of</i> equal readings of the counter and our given value, we wind back the value (algorithm " <i>Vych1</i> " wound on the counter) and issue a clock pulse of 10 ms duration (1 controller cycle) from the output "=" of the " <i>Compar1</i> " algorithm.  The last selection algorithm serves to reset the counter by the reset signal. <br><div class="spoiler">  <b class="spoiler_title">For attentive readers</b> <div class="spoiler_text">  The attentive reader probably noticed that when first turned on, the counter counts 50 pulses not in 1 second, but in 980 ms.  because we are counting on the leading edge, and not on the back.  But at the same time it will issue all other clock pulses in exactly 1 second.  Of course, it is very easy to fix this situation, however, I intentionally left this version of the generator implementation for this particular issue. </div></div><br>  After the generator is made, we roll it up into a compact macro and leave it to wait in the wings. <br><img src="https://habrastorage.org/getpro/habr/post_images/ae6/92f/c81/ae692fc81675b6d467b410fa439cdcae.png"><br><br><h5>  Control </h5><br>  It's all very simple.  We already have a generator.  Snake continuously crawling across the field, changing only the direction of its movement.  The field itself is a two-dimensional array, each cell of which is defined by X and Y coordinates. When moving to the right, the X coordinate increases by one with each step, and the Y coordinate does not change.  When moving to the left, the X coordinate decreases with a constant Y coordinate. For moving up and down similarly, only the Y coordinate will change, and the X coordinate will be constant. <br>  Therefore, we put two reversible counters (one for each coordinate), which, depending on the command, simultaneously with the arrival of a new clock pulse, will either add or subtract a unit from the current coordinate of the snake head.  As a result, we obtain the following scheme. <br><img src="https://habrastorage.org/getpro/habr/post_images/5ae/d12/aaa/5aed12aaa2ef79b73011481ab332768b.png"><br><div class="spoiler">  <b class="spoiler_title">A little explanation about the redundancy scheme</b> <div class="spoiler_text">  Again, attentive readers may ask the question - why this scheme is not implemented in an optimal way, but using additional unnecessary algorithms.  Everything is very simple.  These, so far useless, algorithms are included in the scheme in advance and we will need it at the stage of ‚Äúcombing‚Äù the program.  In order not to return and correct the original construction once again, it is better to introduce them in advance.  What are they for I will tell in the spoiler below </div></div><br><div class="spoiler">  <b class="spoiler_title">Operating principle</b> <div class="spoiler_text">  Algorithm " <i>Ruchselektor1</i> " serves to enter snake commands.  It has 4 exits which correspond to four directions of movement (right-left-up-down).  Next is another selection algorithm " <i>Ruchselektor2</i> ".  Since  control commands can be received at any time, we use it to synchronize control commands with clock pulses.  those.  from the first selector we will transmit the value to the second only after the arrival of the clock pulse.  In fact, it is obvious that this algorithm is redundant, since  we synchronize with clock pulses directly on the counters (this can be seen from the diagram), but this algorithm was left by me in the program solely for debugging purposes.  Next, there are 4 algorithms " <i>And</i> " for synchronizing the counters with clock pulses, as I wrote above.  The corresponding signal from the algorithms " <i>And</i> " is selected to increase or decrease the coordinates we need by one.  Since  the selection algorithm works according to the scheme ‚Äú1 of n‚Äù, therefore at each moment of time the logical unit will be only on one of the outputs of the selector.  And this means that we can simply add up the increment of the corresponding coordinate and send the resulting value to the reversible counter of this coordinate, implemented as in the case of the generator on the summation algorithm with feedback. </div></div><br>  This completes the control scheme.  For now, let's not collapse it into a macro.  we will correct it a little more at the last stage. <br><br><h5>  Snake head and tail </h5><br>  As mentioned earlier, the snake head is an array cell with specific X and Y coordinates. But for now, we don‚Äôt have this array.  In addition, looking a little into the future (namely, the creation of the snake tail), it becomes clear that this cell of the array should be with memory.  The simplest logical element with memory is a trigger.  There are many varieties of them, each of which is used for its own purposes.  In this example, we give preference to the "RS-trigger".  To add beauty to the game (for example, to color the snake and food in different colors, highlight the snake's head, etc.) with a logical memory cell is not enough, because we will have to store at least 4 states in it no longer.  Those.  you will have to make a memory cell either from several triggers, or in another format ‚Äî for example, store an integer in the cell.  But it will somewhat complicate the program, and one of the goals of this whole action is to meet within half an hour. <br>  Let's make for our snake a 20 to 20 field.  we will need 400 triggers.  The problem is solved simply.  make one cell with one trigger and collapse it into a macro.  Make twenty cell macros and collapse them into a new, large macro.  We put twenty large macros and get 400 memory cells. <br>  The cell macro itself will have 5 inputs and 4 outputs. <br><img src="https://habrastorage.org/getpro/habr/post_images/7e5/dcb/c9a/7e5dcbc9ae63b29844906f1400f6fa2a.png"><br>  Inputs: <br><ol><li>  Input (a logical sign of whether the snake's ‚Äúhead‚Äù is in this memory cell) </li><li>  Tact (clock pulses to synchronize with the main generator) </li><li>  Length (length of snake tail) </li><li>  Reset (a logical sign of pressing the reset button to start a new game) </li><li>  Food (a logical indication if the ‚Äúfood‚Äù is for a snake in this cell) </li></ol><br><div class="spoiler">  <b class="spoiler_title">About food and snake head</b> <div class="spoiler_text">  "Food" for the snake must be separated from the "head" because  they are tested for hitting the head of a snake in a given cell in different ways.  Hitting a snake's head on a cage with ‚Äúfood‚Äù is good, while getting a snake on a cage with a snake's tail leads to a defeat and the end of the game. </div></div><br>  Outputs: <br><ol><li>  Output (a logical sign, paint this cell on the field or not) </li><li>  GameOver (a logical sign of the end of the game if the snake has stepped on its tail) </li><li>  Yum_nyam (a logical sign that a snake has stepped on a cell with food and you need to generate a new food for a snake) </li><li>  Another attempt (a logical sign that a randomly thrown cell with food got into the field, already occupied by a snake, and you need to regenerate the coordinates of a new random cell) </li></ol><br>  After the inputs and outputs of the cell are defined and in the brow it is clear that we want from it, we describe the logic of the cell operation. <br><img src="https://habrastorage.org/getpro/habr/post_images/9af/bc2/8ba/9afbc28ba6700ee9c338a930e0f5fe46.png"><br><div class="spoiler">  <b class="spoiler_title">The principle of the cell algorithm</b> <div class="spoiler_text">  A signal arrives at the input that a snake has stepped on this cell.  Their pulse is emitted with a length of 10 ms.  and the algorithm " <i>And</i> " is added to the clock pulse.  If both conditions are met, i.e.  in one cycle, a clock pulse came and a signal that a snake appeared in this cell, then the trigger " <i>RS1</i> " is cocked.  This is the main trigger of this memory cell.  In principle, to process a snake's head, it is enough to reset the trigger with the next clock signal.  All the rest is processing of the tail, and various situations. <br><br>  1. handling of the situation ‚Äúthe snake came on its tail‚Äù.  everything is simple with the exception of a small subtlety.  We add in both the input signal and the state of the trigger.  If both signals are equal to one, then the head came stepped on the cell occupied by the tail.  This is a violation of the rules and we issue a ‚ÄúGameOver‚Äù signal at which the game ends.  The subtlety lies in the fact that the signal from the trigger must be taken not in the current, but in the previous cycle.  For this purpose, feedback is used here (displayed as a dotted line). <br><br>  2. processing "food".  here, too, everything is simple.  We receive a signal that there must be food in this cell.  We add it on And with the main trigger.  If both signals are units, then the food cell fell on a field already occupied by a snake.  In this case, we give out the ‚ÄúMore_express‚Äù signal, which gives the command to generate new random coordinates. <br><br>  3. handling the situation of "the snake ate food."  If conditions 2 are not fulfilled, i.e.  the cell with the food hit the free field, then the " <i>RS2</i> " food trigger is cocked.  Then we just wait for the signal that the snake has stepped on this cell.  As soon as such a signal is received, we reset the food trigger (the food is eaten) and issue a ‚ÄúYum-yum‚Äù signal by which we increase the length of the snake by one and at the same time send the command to generate new coordinates for the food. <br><br>  4. "tail treatment".  The idea is to keep the state of the cell until the entire tail of the snake crawls away.  To do this, we put the counter (algorithm " <i>Slug1</i> ") and count how many clock pulses we had during the time the main trigger was cocked.  We compare this value with the length of the snake and as soon as they become equal - reset the trigger.  For simplicity and debugging, the counter value is not compared with the length.  And the difference between them is with zero.  One of the points worth paying attention to is that from after subtracting from the length of the meter readings we add one to the resulting difference.  This is done in order to compensate for the calculation of the first clock cycle, which occurs simultaneously with the snake hitting the cage. <br></div></div><br><br><h5>  "Food" </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/08a/770/7fe/08a7707fe8786fba454df717d7f52cb0.png"><br>  Here the biggest problem is getting a random number.  Since  we don‚Äôt have the ‚Äúrandom‚Äù command.  On the Internet there are a lot of ways to generate a pseudo-random number.  In this example, one of them is implemented.  Some big changing number is taken - controller's UpTime in seconds.  And is divided into a constantly changing divider (implemented on the integrator).  The remainder of the quotient is taken and it is considered that this is a random number.  In fact, of course, it is not random at all, and at first glance it can be noted that the probability of small numbers falling out is greater than large ones due to the divider‚Äôs ‚Äúwalking‚Äù in a certain area, but if we take not the whole of the remainder, but say hundredths or thousandths from the remainder.  Bring them to the range of 1-20, we get a number, the value of which will already be very similar to a random variable. <br><br><h5>  We connect all the parts and comb the program </h5><br>  So, all parts of the program are ready.  We connect them with each other connections.  In the first approximation, our game is already running.  There are final touches left. <br><br>  1. Check to go beyond the field. <br>  It all depends on the implementation of the game.  We recall that at the second ‚ÄúManagement‚Äù stage we had a counter in which the coordinates of the snake head were in X and Y. Just compare these coordinates with 0 and with 21 (since we have a field of 20 x 20 and coordinates 1 -20).  If any of the conditions is fulfilled, then set the ‚ÄúEnd of Game‚Äù sign (which should be added along OR with our ‚ÄúGameOver‚Äù sign).  You can do it like in the game <a href="http://ru.wikipedia.org/wiki/Pac-Man">‚ÄúPac-man‚Äù</a> so that when a snake crawls out of the field, it would appear on the other side.  To do this, simply reset the corresponding coordinate. <br><br>  2. Check for correct command. <br>  Our snake can not instantly turn 180 degrees.  Therefore, we will add a small check, which will not allow to give commands of the opposite direction one after another. <br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/d0e/969/bcfd0e969ac6184b5b19882e86c2280d.png"><br>  The principle of operation is as follows.  If a team comes, then we check if it is the opposite of the existing team.  If not, then write a new command in memory and feed it to the output.  If it is, then the write to memory does not pass and the old command remains at the output.  If you wish, you can take this sign to a separate output of the macro and form an audio signal using it. <br><br>  3. Commands "Start" and "Reset". <br>  Made for convenience.  The "Start" command cocks the trigger, which sends a signal to our generator.  The "Reset" command resets this trigger, stopping the generator.  At the same time reset resets all memory cells and data in all counters. <br><div class="spoiler">  <b class="spoiler_title">The final program.</b>  <b class="spoiler_title">drawing is very big</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/c4f/72f/c9c/c4f72fc9cc6a5a7a84150f4639a87b7b.png"></div></div><br><br><h5>  Making the interface and playing </h5><br>  From the time allotted to us for the game there are a couple of minutes, which are just enough to fasten the graphical interface to the game. <br>  Draw a field of 20x20 squares.  Each square corresponds to its own memory cell.  Set the properties so that when the value of the corresponding memory cell is 0, the square is gray, and when 1 it is green (or any colors you like). <br><img src="https://habrastorage.org/getpro/habr/post_images/69b/146/309/69b14630999fc6aedaca0d2f2513a17e.png"><br>  Searching for pictures on the Internet, we find a beautiful frame for the field and some kind of snake pattern that matches the meaning. <br>  Next to the field we place the control buttons and bind the mouse and keyboard controls with the WASD keys. <br>  Nearby place the buttons "Start" and "Reset".  And the big inscription "GameOver", which will appear when you lose. <br><br>  Compile and load the program into the controller.  We launch the operational control station and play. <br><div class="spoiler">  <b class="spoiler_title">This is the mnemonic scheme the operator will have</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/48c/892/775/48c892775ab48a5bea2cacb682b59fb3.png"></div></div><br><br><h5>  Summing up </h5><br>  In this article, we <b>briefly</b> reviewed the principles of programming in the FBD language for <b>PTC</b> controllers <b>KVINT 7</b> .  Without making much effort, we implemented the game "Snake".  Since  FBD language is mostly oriented to technologists, then anyone who is familiar with elementary logic (for example, the logic of the AND, OR, algorithms, and counter algorithms) can begin to understand the principles of operation and begin to write their programs.  You do not need to have extensive experience in programming or circuitry. <br><br>  This algorithm can be implemented on any system that supports the FBD programming language simply by replacing the algorithms presented in the figure with similar in functionality, since  The algorithms used here are basic and exist in all systems. <br><br>  When writing a program in FBD, it is important to follow the order of execution of the algorithms.  As I already wrote above, the given program is not optimal and is equipped with additional algorithms that are needed with only one purpose - to control the execution order and synchronization of all algorithms with a clock signal. <br><br>  Of course, by simple manipulations, you can improve the program, for example, by increasing the speed of the snake movement over time.  Or enter the parameter ‚Äúhunger‚Äù, according to which a snake that does not receive during a certain period of time does not receive a new food, is accelerated.  In addition, attentive readers could pay attention to the function of memorizing the length of a snake when moving it into a new cell (and here a small error was specially laid down to attract attention) and think that this is wrong.  usually the snake is lengthened from the head, not from the tail.  You can do anything.  This is just a matter of desire and time. <br><br>  Thanks to all who read to the end.  I hope it was interesting. </div><p>Source: <a href="https://habr.com/ru/post/205324/">https://habr.com/ru/post/205324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205314/index.html">How to make autoloading screenshots on FTP in OS X or history, about how we are not looking for easy ways</a></li>
<li><a href="../205316/index.html">Object pool and fast creation of heap objects</a></li>
<li><a href="../205318/index.html">Simplicity Algorithm for O (log N)</a></li>
<li><a href="../205320/index.html">Basics of I2P Network Client Development</a></li>
<li><a href="../205322/index.html">Price Calculator for Cloud Hosting Instances</a></li>
<li><a href="../205326/index.html">Antivirus scan access to Samba</a></li>
<li><a href="../205328/index.html">Tuning mooedit</a></li>
<li><a href="../205332/index.html">Dell VRTX - IT small business infrastructure in one box</a></li>
<li><a href="../205334/index.html">IBM PureData for Hadoop: how can this system help me?</a></li>
<li><a href="../205336/index.html">Dynamic access control: working with centralized rules and access policies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>