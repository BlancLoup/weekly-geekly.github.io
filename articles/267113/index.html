<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deepen in Scheme</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If the only tool you have is a hammer, then many different objects will seem like nails. 
 Mark Twain 


 Part 1 Introduction to Scheme 
 Part 2 Groov...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deepen in Scheme</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/076/2c9/bc4/0762c9bc4bd44488a65fd1a9e5fcc888.png"></div><br><blockquote>  If the only tool you have is a hammer, then many different objects will seem like nails. <br>  Mark Twain <br></blockquote><br><br>  <a href="http://habrahabr.ru/company/tcsbank/blog/267015/">Part 1 Introduction to Scheme</a> <br>  <a href="http://habrahabr.ru/company/tcsbank/blog/267113/">Part 2 Groove in the Scheme</a> <br>  <a href="http://habrahabr.ru/company/tcsbank/blog/267119/">Part 3 Practicing IronScheme</a> <br><br><h2>  Get acquainted closer </h2><br>  It is time to learn the basic constructs of the Scheme language.  The best way to learn how to use a new language is to start writing on it.  Let's start a gradual immersion with the analysis of the most basic elements of the language. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I propose to run the IronScheme interpreter in REPL mode and enter the commands below. <br><br>  A single line comment starts with a semicolon and is valid until the end of the line: <br><pre><code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;     </span></span></code> </pre> <br>  A Scheme program consists of lists enclosed in parentheses and separated by a space (s-expression).  The function call is written as (fxyz ...), where f is the name of the function, and x, y, z, ... are operands. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 4</span></span></code> </pre><br>  Here we have performed the operation of adding two numbers. <br><br>  Expressions can be nested: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 4</span></span></code> </pre><br>  Thus, expressions can consist of atoms or other expressions.  In the example above, the numbers ‚Äú1‚Äù and ‚Äú2‚Äù are atoms, and ‚Äú(+ 2 (+ 1 1))‚Äù and ‚Äú(+ 1 1)‚Äù expressions. <br><br><h2>  Primitives </h2><br>  Numbers: <br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">9999999999999999999999</span></span> <span class="hljs-comment"><span class="hljs-comment">; integers #b111 ; binary =&gt; 7 #o111 ; octal =&gt; 73 #x111 ; hexadecimal =&gt; 273 3.14 ; reals 6.02e+23 1/2 ; rationals 1+2i ; complex numbers</span></span></code> </pre><br>  To create a list of any values, for example, from the same primitives, use the list function, whose arguments will be put together in a list.  You can do it another way, to suppress the calculation.  Suppression is achieved by the quote function or its sugar equivalent by a single quote in front of the ‚Äú'‚Äù list.  It is important to remember that list does not suppress calculations. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">list</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; =&gt; (1 2 3 4 5 6) (quote (1 2 3 4 5 (+ 1 2 3))) ; =&gt; (1 2 3 4 5 (+ 1 2 3)) '(1 2 3 4 5 (+ 1 2 3)) ; =&gt; (1 2 3 4 5 (+ 1 2 3))</span></span></code> </pre><br><h2>  Some arithmetic operations </h2><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 2 (- 8 1) ; =&gt; 7 (* 10 2) ; =&gt; 20 (expt 2 3) ; =&gt; 8 (quotient 5 2) ; =&gt; 2 (remainder 5 2) ; =&gt; 1 (/ 35 5) ; =&gt; 7 (/ 1 3) ; =&gt; 1/3 (exact-&gt;inexact 1/3) ; =&gt; 0.3333333333333333 (+ 1+2i 2-3i) ; =&gt; 3-1i</span></span></code> </pre><br><br><h2>  Boolean algebra </h2><br>  To indicate the truth there is a primitive ‚Äú#t‚Äù, a lie is designated as ‚Äú#f‚Äù, besides all other values ‚Äã‚Äãother than ‚Äú#f‚Äù are interpreted as true: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">not</span></span> #t) <span class="hljs-comment"><span class="hljs-comment">; =&gt; #f (and 0 #f) ; =&gt; #f (or #f 0) ; =&gt; 0</span></span></code> </pre><br><br><h2>  Characters, lines </h2><br>  According to the RnRs standard, symbols can be represented in the code in two ways, by a symbol that designates itself or by a symbol code: <br><pre> <code class="lisp hljs">#\A <span class="hljs-comment"><span class="hljs-comment">; =&gt; #\A #\x03BB ; =&gt; #\Œª</span></span></code> </pre><br>  Strings are arrays of characters of fixed length and are enclosed in double quotes: <br><pre> <code class="lisp hljs"><span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span></code> </pre><br>  Quotes inside a string can be escaped with a backslash: <br><pre> <code class="lisp hljs"><span class="hljs-string"><span class="hljs-string">"Benjamin \"Bugsy\" Siegel"</span></span></code> </pre><br>  To print a string to standard output, you can use the display function that accepts a string as an argument: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">display</span></span> <span class="hljs-string"><span class="hljs-string">"Some string"</span></span>)</code> </pre><br>  Strings can be combined: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">string-append</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> <span class="hljs-string"><span class="hljs-string">"world!"</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; "Hello world!"</span></span></code> </pre><br>  You can access the character of a string by index as follows: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">string-ref</span></span> <span class="hljs-string"><span class="hljs-string">"Apple"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; #\A</span></span></code> </pre><br>  For formatting strings, it is convenient to use the formatting function: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-string"><span class="hljs-string">"~a can be ~a"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"formatted"</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; "strings can be formatted"</span></span></code> </pre><br>  To prevent the result of formatting from being lost, you can assign a string to a variable: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> str (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-string"><span class="hljs-string">"~a can be ~a"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"formatted"</span></span>))</code> </pre><br><br><h2>  Variables </h2><br>  You can declare variables using the define function, in which the first argument is the name of the function, the second is not a necessary argument, the value by which the variable will be initialized.  A variable name can contain any characters except: () [] {} ‚Äù, '`; # / \ <br>  For example: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> some-var <span class="hljs-number"><span class="hljs-number">5</span></span>) some-var <span class="hljs-comment"><span class="hljs-comment">; =&gt; 5</span></span></code> </pre><br>  Variables in Lisp without strong typing and can point to atoms or functions. <br>  The ‚Äúset!‚Äù Operation saves the value in a variable, in fact, is an analogue of the assignment operator ‚Äú=‚Äù from other languages.  Do not forget to first declare a variable operation ¬´define¬ª: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> my-name <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>) my-name <span class="hljs-comment"><span class="hljs-comment">; =&gt; "unknown" (set! my-name "NalaGinrut") my-name ; =&gt; " NalaGinrut "</span></span></code> </pre><br>  Attempting to access a previously undeclared variable will cause an exception. <br>  It is convenient to immediately declare a group of local variables using the construct (let ...). <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">let</span></span> ( (<span class="hljs-name"><span class="hljs-name">a</span></span> <span class="hljs-string"><span class="hljs-string">"My"</span></span>) (<span class="hljs-name"><span class="hljs-name">b</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span>) (<span class="hljs-name"><span class="hljs-name">c</span></span> <span class="hljs-string"><span class="hljs-string">"is"</span></span>) (<span class="hljs-name"><span class="hljs-name">d</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>) ) (<span class="hljs-name"><span class="hljs-name">set!</span></span> d <span class="hljs-string"><span class="hljs-string">"Sara"</span></span>) (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-string"><span class="hljs-string">"~a ~a ~a ~a"</span></span> abcd) ) <span class="hljs-comment"><span class="hljs-comment">; =&gt; My name is Sara</span></span></code> </pre><br><br><h2>  Functions </h2><br>  To create a function, a construction is used (lambda (abc) body), where a, b, c are arguments, body is a sequence of commands. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">lambda</span></span> () <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>) (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">+</span></span> xx))</code> </pre><br>  The function created above does not have a name, so it is not possible to access it.  To access the created function, you can assign it to a variable. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> hello-world (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>)) (<span class="hljs-name"><span class="hljs-name">hello-world</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; "Hello World"</span></span></code> </pre><br>  Or so: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> hello-world) (<span class="hljs-name"><span class="hljs-name">set!</span></span> Hello-world (<span class="hljs-name"><span class="hljs-name">lambda</span></span> () <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>)) (<span class="hljs-name"><span class="hljs-name">hello-world</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; "Hello World"</span></span></code> </pre><br>  A more convenient construction is usually used (define (function-name arg1 arg2) body) <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">mul</span></span> ab) (<span class="hljs-name"><span class="hljs-name">*</span></span> ab)) (<span class="hljs-name"><span class="hljs-name">mul</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)<span class="hljs-comment"><span class="hljs-comment">; =&gt; 6</span></span></code> </pre><br>  The function always returns the last value. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">last-string</span></span>) ‚Äúone‚Äù ‚Äútwo‚Äù ‚Äúthree‚Äù) (<span class="hljs-name"><span class="hljs-name">last-string</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; ‚Äúthree‚Äù</span></span></code> </pre><br><br><h2>  Flow control </h2><br>  For branching in Scheme, there are various constructions of the most familiar, but not always the most convenient, if-then-else type <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">if</span></span> #t <span class="hljs-comment"><span class="hljs-comment">;  "this is true" ;   "this is false") ;   ; =&gt; "this is true"</span></span></code> </pre><br>  If a branch needs to execute several commands in a row, then they should be enclosed in the ‚Äúbegin‚Äù block. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">begin</span></span> (<span class="hljs-name"><span class="hljs-name">display</span></span> ‚Äúone line‚Äù) (<span class="hljs-name"><span class="hljs-name">newline</span></span>) (<span class="hljs-name"><span class="hljs-name">display</span></span> ‚Äútwo line‚Äù) (<span class="hljs-name"><span class="hljs-name">-</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) ) )</code> </pre><br>  When you need to check several conditions, the cond design is convenient. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>) ((<span class="hljs-name"><span class="hljs-name">&lt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"wrong again!"</span></span>) ((<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"ok"</span></span>) (<span class="hljs-name"><span class="hljs-name">else</span></span> <span class="hljs-string"><span class="hljs-string">"wrong also"</span></span>) )</code> </pre><br>  If the code needs to be executed only in the case of truth, ‚Äúwhen‚Äù is perfect <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) ‚Äútrue‚Äù)</code> </pre><br>  There are two ways to organize a cycle: recursion <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">lp</span></span> i) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> i <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-name"><span class="hljs-name">display</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-string"><span class="hljs-string">"i=~a\n"</span></span> i)) (<span class="hljs-name"><span class="hljs-name">lp</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> i)) ) ) (<span class="hljs-name"><span class="hljs-name">lp</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">; =&gt; i=5, i=6, ...</span></span></code> </pre><br>  Or using a named "let" <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">let</span></span> loop ((<span class="hljs-name"><span class="hljs-name">i</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; definition (when (&lt; i 10) ; condition (display (format "i=~a\n" i)) ; body (loop (+ 1 i)) ; next iteration ) ) ; =&gt; i=0, i=1, ...</span></span></code> </pre><br><br><h2>  Macros </h2><br>  Scheme macros are quite a powerful tool that allows you to extend the syntax of the language by creating new constructs.  However, you should not get too carried away and apply macros only where it is really necessary.  Macro definition begins with the define-syntax command <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> macro (<span class="hljs-name"><span class="hljs-name">syntax-rules</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;keywords&gt;</span></span>) ((<span class="hljs-name"><span class="hljs-name">&lt;pattern&gt;</span></span>) &lt;template&gt;) ... ((<span class="hljs-name"><span class="hljs-name">&lt;pattern&gt;</span></span>) &lt;template&gt;) ) )</code> </pre><br>  &lt;keywords&gt; - Keywords that can be used in the template description.  For example, you can write a macro for the construct ‚Äú(forech (item in items) ...)‚Äù, in this case the key word is ‚Äúin‚Äù, which must be present. <br><br>  &lt;pattern&gt; - A template that describes what is entered at the macro. <br><br>  &lt;template&gt; - A template describing what should be transformed In the macro, the ellipsis "..." means that the body can contain one or more forms. <br><br>  Consider using macros to create while and for loops. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> while (<span class="hljs-name"><span class="hljs-name">syntax-rules</span></span> () ((<span class="hljs-name"><span class="hljs-name">while</span></span> condition body ...) (<span class="hljs-name"><span class="hljs-name">let</span></span> loop () (<span class="hljs-name"><span class="hljs-name">when</span></span> condition body ... (<span class="hljs-name"><span class="hljs-name">loop</span></span>) ) ) ) ) )</code> </pre><br>  check the created macro <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> iter <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> iter <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-name"><span class="hljs-name">set!</span></span> iter (<span class="hljs-name"><span class="hljs-name">+</span></span> iter <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">displayln</span></span> iter )) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 1 2 3 ‚Ä¶</span></span></code> </pre><br>  Define a macro for a for loop: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define-syntax</span></span> for (<span class="hljs-name"><span class="hljs-name">syntax-rules</span></span> () ((<span class="hljs-name"><span class="hljs-name">for</span></span> (<span class="hljs-name"><span class="hljs-name">iterator</span></span> from to) body ...) (<span class="hljs-name"><span class="hljs-name">let</span></span> loop((<span class="hljs-name"><span class="hljs-name">iterator</span></span> from)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> iterator to) body ... (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> iterator)) ) ) ) ) )</code> </pre><br>  Check: <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">for</span></span> (<span class="hljs-name"><span class="hljs-name">i</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>) (<span class="hljs-name"><span class="hljs-name">displayln</span></span> i)) <span class="hljs-comment"><span class="hljs-comment">; =&gt; 1 2 3 ...</span></span></code> </pre><br><br><h2>  Exceptions </h2><br>  In life, it is not very rare to have the need to use unstable code, which during execution can cause an exception.  In Lisp and Scheme in particular, there is an advanced exception handling system, below is a simple example of how you can handle exceptions without fear that the program will crash. <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">guard</span></span> (<span class="hljs-name"><span class="hljs-name">cond</span></span> <span class="hljs-comment"><span class="hljs-comment">;  c    (display (condition-message cond)) ;   ) (/ 1 0) ;    )</span></span></code> </pre><br>  We learned some of the fundamentals of the Scheme language described by the standard.  Of course, this article does not provide all the possibilities of the language, otherwise the article would have turned out to be too voluminous, in fact it would be a translation of the standard.  However, what we have learned is quite enough to develop practically useful applications on Scheme. </div><p>Source: <a href="https://habr.com/ru/post/267113/">https://habr.com/ru/post/267113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267103/index.html">Corporate VPN with ACCEL-PPP + IPsec and authorization with Freeradius via AD</a></li>
<li><a href="../267105/index.html">UrbanAirship - push without creating a server</a></li>
<li><a href="../267107/index.html">Log Analysis with Hadoop / Python</a></li>
<li><a href="../267109/index.html">In the Norwegian abandoned mine will build the largest data center in Europe</a></li>
<li><a href="../267111/index.html">BabylonJS. Lesson 2 - Basic Meshes</a></li>
<li><a href="../267115/index.html">Back to basics</a></li>
<li><a href="../267117/index.html">Security Week 38: Attack on Cisco routers, bug in AirDrop, arrest of cryptobarg</a></li>
<li><a href="../267119/index.html">Practice IronScheme</a></li>
<li><a href="../267121/index.html">Links search - getting data about Portmone and Fidobank clients</a></li>
<li><a href="../267123/index.html">Histogram and box with a mustache on the fingers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>