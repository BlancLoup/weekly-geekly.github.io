<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming language D - continued</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good all the time of day! 
 So, I decided to continue the story about the wonderful programming language D. 
 My last article was about multi-paradigm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming language D - continued</h1><div class="post__text post__text-html js-mediator-article"> Good all the time of day! <br>  So, I decided to continue the story about the wonderful programming language D. <br>  My <a href="http://habrahabr.ru/blogs/programming/135044/">last article</a> was about multi-paradigm language, that it naturally and harmoniously supports the majority of modern popular programming styles. <br>  This time I decided to highlight the other side of the language - less general and fundamental, but no less useful.  Namely, the possibilities of metaprogramming and compile-time computations. <br><a name="habracut"></a><br><br>  I begin, perhaps with all the usual things - generic programming (generics, templates).  That is, from familiar to all of us in C ++ templates. <br><br>  For a start, what it is at a simple level: generic programming (template functions and data types) is a way to provide the ability to reuse code.  When a programmer writes code for some generalized type, and then substitutes concrete. <br>  In language D, a heterogeneous approach is chosen.  This means that the templates in the depths of the language implementation are nothing more than type-safe macros, and each specific type substituted into the template simply generates a separate implementation.  Let's try to describe a simple, and, I admit, little meaningful template function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs cs"><code><span class="hljs-function"><span class="hljs-function">T[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapInc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] arr</span></span></span><span class="hljs-function">)</span></span> { auto res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[arr.length]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i, v; arr) res[i] = v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code></code> </pre> <br><br>  First of all, I note that the return result is also parameterized.  Very convenient property. <br>  Let's see how it works: <br><br><pre> <code class="hljs java"><code><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ auto ar = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]; auto ard = [<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(MapInc(ar) == [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>], <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(MapInc(ard) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>); }</code></code> </pre> <br><br>  All tests passed as expected!  Undoubtedly, success.  But wait ... let's try this code: <br><br><pre> <code class="hljs cpp"><code><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ar = [<span class="hljs-string"><span class="hljs-string">"1"</span></span>,<span class="hljs-string"><span class="hljs-string">"2"</span></span>,<span class="hljs-string"><span class="hljs-string">"3"</span></span>,<span class="hljs-string"><span class="hljs-string">"4"</span></span>]; MapInc(ar);</code></code> </pre> <br><br>  Not compiled?  Not surprising.  Compilation error on line <br><pre> <code class="hljs matlab"><code>res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = v + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code></code> </pre> <br>  and as a result, on the line <br><pre> <code class="hljs lisp"><code>MapInc(<span class="hljs-name"><span class="hljs-name">ar</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code></code> </pre> <br>  Now imagine that this function is not written by us, but buried deep in the library.  Joyless right <br>  However, D provides a very convenient way to resolve a misunderstanding.  Since one line of code replaces a thousand words, just take a look: <br><br><pre> <code class="hljs coffeescript"><code>T[] MapInc(T)(T[] arr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   . { auto res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[arr.length]; foreach(i, v; arr) res[i] = v + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code></code> </pre> <br><br>  Thus, we simply and elegantly indicated to the compiler, for which input data the function is intended, and if it finds the code that gave errors in two lines at once, and one more directly in the function, then it will check the condition and generate an error right on the spot.  And, most importantly, it's completely free! <br>  Of course, by free, I mean the fact that all such checks are carried out at the compilation stage, without taking away a single tact in runtime.  This, by the way, means that we can write only those checks that can be calculated at the compilation stage. <br>  Now back to the code: <br><pre> <code class="hljs lisp"><code>if(<span class="hljs-name"><span class="hljs-name">is</span></span>(<span class="hljs-name"><span class="hljs-name">typeof</span></span>(<span class="hljs-name"><span class="hljs-name">arr</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>) == typeof(<span class="hljs-name"><span class="hljs-name">arr</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>])))</code></code> </pre> <br>  To you, it probably seems like sheer shamanism.  How to calculate at the stage of compilation arr [0] and even + 1?  The correct answer - and no way.  The compiler does not calculate this value.  In this case, typeof does not evaluate its own argument, it simply displays the type of the value that is passed to it, as an argument. <br>  In this way <br><pre> <code class="hljs lisp"><code>typeof(<span class="hljs-name"><span class="hljs-name">arr</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>) == typeof(<span class="hljs-name"><span class="hljs-name">arr</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code></code> </pre> <br>  just means that: <br>  a) We can add typeof (1) type values ‚Äã‚Äãto typeof (arr [0]) type values ‚Äã‚Äãand <br>  b) After the addition, we again get the typeof type (arr [0]). <br>  Wow, isn't it? <br><br>  So, we have written a function that can add one to all values ‚Äã‚Äãof the array, while it accurately reports if it is impossible to add one in principle.  Seems not bad?  However, the next is better. <br>  To get to better, you have to sweat a little more and modify the example: <br><br><pre> <code class="hljs cs"><code><span class="hljs-function"><span class="hljs-function">T[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapInc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] arr, T b</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(arr[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] + b</span></span></span><span class="hljs-function">)</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) { auto res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[arr.length]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i, v; arr) res[i] = v + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code></code> </pre> <br><br>  Now we add not a unit, but an arbitrary number.  Check our function: <br><br><pre> <code class="hljs java"><code><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ auto ar = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(MapInc(ar,<span class="hljs-number"><span class="hljs-number">3</span></span>) == [<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>], <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>); }</code> <br></code> </pre> <code><code>void main() { auto ar = [1,2,3,4]; assert(MapInc(ar,3) == [4,5,6,7], "wrong!"); }</code> <br></code> <br>  Success!  But wait, we treated her too gently, let's try to somewhat complicate the task: <br><br><pre> <code class="hljs java"><code><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ auto ar = [<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(MapInc(ar,<span class="hljs-number"><span class="hljs-number">1</span></span>) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,  . }</span></span></code></code> </pre> <br><br>  Oops!  The compiler could not understand our delightful idea.  What is it: another grumpy strict type system wishes us evil?  But let's take a closer look: we are to blame!  The definition clearly states that the array and the number are of the same type.  Good.  Let us try to modify the example to accept values ‚Äã‚Äãof different types. <br><br><pre> <code class="hljs cs"><code><span class="hljs-function"><span class="hljs-function">T[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapInc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T,P</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] arr, P b</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">is</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(arr[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] + b</span></span></span><span class="hljs-function">)</span></span> == T)) { auto res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[arr.length]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i, v; arr) res[i] = v + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code></code> </pre> <br><br>  Now the final success: <br><br><pre> <code class="hljs java"><code><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ auto ar = [<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(MapInc(ar,<span class="hljs-number"><span class="hljs-number">1</span></span>) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], <span class="hljs-string"><span class="hljs-string">"wrong!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// , ! }</span></span></code></code> </pre> <br><br>  I also note that the condition in the header of the function did not have to change - we want exactly the same as in the previous version. <br><br>  Now it's time to clarify lovers of rigor.  This is the option to write the function call: <br><pre> <code class="hljs lisp"><code>MapInc(<span class="hljs-name"><span class="hljs-name">ar</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code></code> </pre> <br>  Just the result of automatic type inference.  But how are things really: <br><br>  In D, each function has two sets of arguments and is generally defined as <br><pre> <code class="hljs lisp"><code>T f(<span class="hljs-name"><span class="hljs-name">c1</span></span>,c2/*, others*/)(<span class="hljs-name"><span class="hljs-name">r1</span></span>,r2/*, others*/)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code></code> </pre> <br>  The first set is the set of compile-time arguments, the second is the runtime. <br>  The name speaks for itself: arguments from the first set are computed at compile time, while from the second set at run time.  And that is not always. <br>  Thus, all the arguments of the compilation time are again given to us ‚Äúfor free‚Äù, but again we cannot use the noncomputable values ‚Äã‚Äãhere during the compilation. <br><br>  For calling polymorphic functions, the syntax is: <br><pre> <code class="hljs lisp"><code>auto v = f!(<span class="hljs-name"><span class="hljs-name">c1</span></span>,c2/*, others*/)(<span class="hljs-name"><span class="hljs-name">r1</span></span>,r2/*, others*/)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code></code> </pre> <br>  In this case, if the compile time argument is only one, then you can omit the brackets: <br><pre> <code class="hljs lisp"><code>auto v = f!c1(<span class="hljs-name"><span class="hljs-name">r1</span></span>,r2/*, others*/)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code></code> </pre> <br><br>  Compile-time arguments can be not only types, but in general any expressions computable at the compilation stage.  For example, "42". <br>  But 42 will fit in the C ++ templates, right there everything is much more interesting: you can even use functions as such parameters!  Consider an example: <br><br><pre> <code class="hljs pgsql"><code>P[] Map(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> f,T,P)(T[] arr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(typeof(f(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>])) == P)) { auto res = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> P[arr.length]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(i, v; arr) res[i] = f(v); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-type"><span class="hljs-type">void</span></span> main() { auto ard = [<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>]; auto ar = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(Map!((<span class="hljs-type"><span class="hljs-type">double</span></span> x) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+<span class="hljs-number"><span class="hljs-number">1</span></span>;},<span class="hljs-type"><span class="hljs-type">double</span></span>,<span class="hljs-type"><span class="hljs-type">double</span></span>)(ard) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], "wrong!"); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(Map!((<span class="hljs-type"><span class="hljs-type">int</span></span> x) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+<span class="hljs-number"><span class="hljs-number">1.0</span></span>;},<span class="hljs-type"><span class="hljs-type">int</span></span>,<span class="hljs-type"><span class="hljs-type">double</span></span>)(ar) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], "wrong!"); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(Map!((<span class="hljs-type"><span class="hljs-type">int</span></span> x) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+<span class="hljs-number"><span class="hljs-number">1</span></span>;},<span class="hljs-type"><span class="hljs-type">int</span></span>,<span class="hljs-type"><span class="hljs-type">int</span></span>)(ar) == [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>], "wrong!"); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(Map!((<span class="hljs-type"><span class="hljs-type">double</span></span> x) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+<span class="hljs-number"><span class="hljs-number">1.0</span></span>;},<span class="hljs-type"><span class="hljs-type">int</span></span>,<span class="hljs-type"><span class="hljs-type">double</span></span>)(ar) == [<span class="hljs-number"><span class="hljs-number">2.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>,<span class="hljs-number"><span class="hljs-number">4.0</span></span>,<span class="hljs-number"><span class="hljs-number">5.0</span></span>], "wrong!"); }</code></code> </pre> <br><br>  In this case, I had to help the compiler and manually determine the types for the template parameters.  Not sure, but probably you can somehow define this function so that it is not needed. <br>  <i>I propose to arrange a contest for the most beautiful map implementation in the comments :)</i> <br>  But on the other hand - look how great it turned out! <br><br>  Let's compare this approach with the C ++ 11 STL approach using the example of the well-known sort algorithm. <br><br><pre> <code class="hljs markdown"><code>auto arr = {1,2,3,4}; sort(arr.begin(), arr.end(), [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">int a, int b</span></span>) {return a &gt; b &amp;&amp; a <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">42</span></span></span></span><span class="xml"><span class="hljs-tag">;});</span></span></span></span></code></code> </pre> <br><br>  What's going on here?  That's right, sorting the array, at the same time to determine if the elements need to be swapped, they need to be compared and our lambda function is called for this (thanks for at least now lambda, before you had to write a function).  Called every time.  And in this (and, probably, in many) case, the cost of calling a function is comparable to the time it takes to calculate the function itself, even if it does not exceed it.  Unforgivable waste of performance. <br>  At that time, as in D, we have seen that a function is a compile time argument, and, accordingly, it is calculated at compile time, and accordingly it is inline elementary.  So, we can say, in some ways, D even surpasses C ++ in efficiency, as they say, by design. <br><br>  The article has already been smashed, but I just started! <br><br>  So, let's continue with the calculations during the compilation process. <br><br>  We all remember, but unsharply and sin with expressions like <br><pre> <code class="hljs cpp"><code><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> P ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code></code> </pre> <br><br>  In D there is no preprocessor (someone will say: ‚Äúand thank God‚Äù, someone will frown, but we will not arrange holivar, but continue to read). <br>  However, there are constructions in the language that replace it.  For example, the above construction replaces the expression static if.  In general, we treated him very (believe me, well, sooo) unfairly: static if can be incomparably more. <br>  Here you need a lyrical digression.  D has the alias keyword.  It works a lot like, but now we need it as a typedef.  Here is an example: <br><pre> <code class="hljs cs"><code><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyOwnPersonalInt;</code></code> </pre> <br>  So, static if.  I will try to show in practice: <br><pre> <code class="hljs cs"><code><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Arch {x86, x64}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Arch arch = x86; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arch == x86</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">alias</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> integer</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> integer;</code></code> </pre> <br><br>  We have defined an integer type, the size of which depends on the architecture of the machine on which the code is compiled. <br>  Now we can use it like any other type: <br><pre> <code class="hljs pgsql"><code><span class="hljs-type"><span class="hljs-type">integer</span></span> Inc(<span class="hljs-type"><span class="hljs-type">integer</span></span> n) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n+<span class="hljs-number"><span class="hljs-number">2</span></span>;}</code></code> </pre> <br><br>  You can write static if literally anywhere: In global code, in functions, and even in class definitions! <br>  Here you need a small addition, the expression "static else" no!  Use the usual else, no collisions can occur, nesting is taken into account. <br><br>  And finally, another interesting and useful feature.  One of the principles of the ideology of a language is: to calculate everything that can be calculated at compile time. <br>  Consider this code: <br><br><pre> <code class="hljs objectivec"><code><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = f(); <span class="hljs-comment"><span class="hljs-comment">//   enum int b = f();</span></span></code></code> </pre> <br><br>  The language assumes that the compiler checks the ability to calculate f () at compile time using the interpreter, and if this is not possible, an error is generated, otherwise the value is simply substituted into the code.  For D, the common practice is to write functions that must be computed at compile time. <br>  Once again: unlike C / C ++, static variables are initialized not during the first call of the initialization code, but during the compilation of the program and, accordingly, must be initialized expressions computable during compilation. <br><br>  Well, that's probably for today and everything.  An attentive reader, of course, noted that I did not mention the generalized data ‚Äî classes, interfaces, and structures, but from the point of view of metaprogramming, the difference with generalized functions is small, so I leave it to self-study for those interested. <br><br>  I hope I did my job well and this article will be able to interest people in the programming language D. <br>  Those who could read this over - I hope you enjoyed it and thank you for your attention! <br><br>  PS <br>  In the comments to my previous article there was a lot of grumbling in the direction of D. And claims of the inefficiency of standard types, and complaints about the lack of tools, and even support for different architectures.  Please keep grumbling with you - for the time being.  I hope you will like the article and I will be able to continue to delight you with other articles about the D language and in due time I will definitely get to every problem that has been voiced, study them and present them to the public, and then I will be able to articulate competently about your doubts they are justified or not. <br><br></div><p>Source: <a href="https://habr.com/ru/post/135248/">https://habr.com/ru/post/135248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135241/index.html">Most downloaded apps for 2011</a></li>
<li><a href="../135242/index.html">Logging architecture</a></li>
<li><a href="../135243/index.html">‚ÄúArtificial Intelligence‚Äù by Google</a></li>
<li><a href="../135244/index.html">Viola Jones in own skin, part 1. Setting up the project under OpenCV</a></li>
<li><a href="../135246/index.html">Do I need a criminal liability. for developers whose fault someone suffered damage to health?</a></li>
<li><a href="../135249/index.html">Jack Goldman passed away - founder and director of Xerox PARC</a></li>
<li><a href="../135250/index.html">AppStore and iCloud traffic disclosure</a></li>
<li><a href="../135252/index.html">greetings from npm</a></li>
<li><a href="../135253/index.html">Configuring GNOME Shell</a></li>
<li><a href="../135255/index.html">Crackme Analysis # 1 by PE_Kill</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>