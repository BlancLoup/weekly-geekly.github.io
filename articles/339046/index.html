<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with resources, or how I pushed through @Cleanup</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a fictional story, and all coincidences are random. 

 Finally, the development team of Unknown Ltd. released release on time. Head of Develop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with resources, or how I pushed through @Cleanup</h1><div class="post__text post__text-html js-mediator-article">  This is a fictional story, and all coincidences are random. <br><br>  Finally, the development team of Unknown Ltd.  released release on time.  Head of Development Andrew, Systems Architect South and simple ordinary developer Bob got together for planning. <br><a name="habracut"></a><br>  In the upcoming quarter, they decided to take more tasks from those.  debt, as almost all of the previous one was devoted to fixing bugs and making urgent improvements for specific customers. <br><br>  Everyone sat back and began to discuss the upcoming plan.  Bob immediately drew attention to the task of processing the generation of documents.  The essence of the task was that the generated documents consist of the schema and settings of the generation and the document itself.  When saved to a database, the document is serialized to XML, converted into a stream of bytes and compressed, and then everything is standardly placed in a BLOB column.  When you need to display in the system or unload a document, then everything repeats with accuracy and vice versa, and voila, the documentary flaunts on the client's screen.  That's it, it's simple.  But as you know, the devil is in the details.  To regenerate a document, if you need to change the settings, you have to completely load the entire document from the database, although its contents are completely unnecessary.  Ay-i-yay.  We discussed the problem.  It was concluded that Bob will have to do the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  delete unnecessary entities, change existing ones, create new ones to share the schema with settings and the document data itself </li><li>  write a migration that will create a new table for storing the schema and data, in which there will be two columns, one CLOB type to store the XML schema, and another BLOB type to store the still compressed XML data </li></ul><br>  On that and decided.  We proceeded to discuss the remaining issues. <br><br>  An hour and a half passed. <br><br>  Bob returned from the planning enthusiastic, not having time to sit down at the workplace, he transferred the task to "In Work" and began execution.  About two days passed, and the first part was over.  Bob successfully commited the changes and sent them for review.  In order not to waste time in vain, he began to perform the second part - migration.  After some time, the following migrator code was born: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected public void migrate() throws Exception { PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data"); while (oldIdResult.next()) { long id = oldIdResult.getLong(1); selectOldContent.setLong(1, id); ResultSet oldContentResult = selectOldContent.executeQuery(); oldContentResult.next(); Blob oldContent = oldContentResult.getBlob(1); Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); XMLStreamWriter newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); XMLStreamWriter newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"); xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); String newScheme = newSchemeWriter.toString(); byte[] newData = newDataOutput.toByteArray(); StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } }</span></span></code> </pre> <br>  To use the migrator, the client code must create or in some way inject the migrator and call its migrate () method.  That's all. <br><br>  Something seems to be wrong, thought Bob.  Well, of course, he forgot to release resources.  Imagine that if a client has a production on the order of several hundred thousand documents, and we do not release resources.  Bob quickly fixed the problem: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV2</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected public void migrate() throws Exception { try ( PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data"); ){ while (oldIdResult.next()) { long id = oldIdResult.getLong(1); selectOldContent.setLong(1, id); try (ResultSet oldContentResult = selectOldContent.executeQuery()) { oldContentResult.next(); String newScheme; byte[] newData; Blob oldContent = null; try { oldContent = oldContentResult.getBlob(1); try ( Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); ){ XMLStreamWriter newSchemeXMLWriter = null; XMLStreamWriter newDataXMLWriter = null; try { newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter); newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"); xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); } finally { if (newSchemeXMLWriter != null) { try { newSchemeXMLWriter.close(); } catch (XMLStreamException e) {} } if (newDataXMLWriter != null) { try { newDataXMLWriter.close(); } catch (XMLStreamException e) {} } } newScheme = newSchemeWriter.toString(); newData = newDataOutput.toByteArray(); } } finally { if (oldContent != null) { try { oldContent.free(); } catch (SQLException e) {} } } try ( StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); ){ insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } } } } }</span></span></code> </pre><br>  Oh God!  I thought Bob.  How now in all this to understand?  This code is difficult to understand not only for another developer, but also for me, if I return to it, suppose in a month to correct or add something.  It is necessary to decompose, Bob thought, and split the independent parts of the code into methods: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV3</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected @RequiredArgsConstructor private static class NewData { final String scheme; final byte[] data; } private List&lt;Long&gt; loadIds() throws Exception { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); try (ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data")) { while (oldIdResult.next()) { ids.add(oldIdResult.getLong(1)); } } return ids; } private Blob loadOldContent(PreparedStatement selectOldContent, long id) throws Exception { selectOldContent.setLong(1, id); try (ResultSet oldContentResult = selectOldContent.executeQuery()) { oldContentResult.next(); return oldContentResult.getBlob(1); } } private void oldContentToNewData(Reader oldContentReader, StringWriter newSchemeWriter, GZIPOutputStream newZippedDataOutput) throws Exception { XMLStreamWriter newSchemeXMLWriter = null; XMLStreamWriter newDataXMLWriter = null; try { newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter); newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"); xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); } finally { if (newSchemeXMLWriter != null) { try { newSchemeXMLWriter.close(); } catch (XMLStreamException e) {} } if (newDataXMLWriter != null) { try { newDataXMLWriter.close(); } catch (XMLStreamException e) {} } } } private NewData generateNewDataFromOldContent(PreparedStatement selectOldContent, long id) throws Exception { Blob oldContent = null; try { oldContent = loadOldContent(selectOldContent, id); try ( Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); ){ oldContentToNewData(oldContentReader, newSchemeWriter, newZippedDataOutput); return new NewData(newSchemeWriter.toString(), newDataOutput.toByteArray()); } } finally { if (oldContent != null) { try { oldContent.free(); } catch (SQLException e) {} } } } private void storeNewData(PreparedStatement insertNewContent, long id, String newScheme, byte[] newData) throws Exception { try ( StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); ){ insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } public void migrate() throws Exception { List&lt;Long&gt; ids = loadIds(); try ( PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ){ for (Long id : ids) { NewData newData = generateNewDataFromOldContent(selectOldContent, id); storeNewData(insertNewContent, id, newData.scheme, newData.data); } } } }</span></span></code> </pre><br>  All, as before, the client code creates a migrator and calls migrate ().  Inside, all identifiers of current documents are loaded, and for each identifier, the contents of the documents are loaded, which with the help of the SAX parser is broken down into parts belonging to the schema and data, in order to save them into a new table, but separately in different columns. <br><br>  It seems to be a little better.  But Bob felt sad.  Why XMLStreamWriter and Blob do not implement Autoloseable, he thought, and started writing wrappers: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV4</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected @RequiredArgsConstructor private static class NewData { final String scheme; final byte[] data; } @RequiredArgsConstructor private static class SmartXMLStreamWriter implements AutoCloseable { final XMLStreamWriter writer; @Override public void close() throws Exception { writer.close(); } } @RequiredArgsConstructor private static class SmartBlob implements AutoCloseable { final Blob blob; @Override public void close() throws Exception { blob.free(); } } private List&lt;Long&gt; loadIds() throws Exception { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); try (ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data")) { while (oldIdResult.next()) { ids.add(oldIdResult.getLong(1)); } } return ids; } private Blob loadOldContent(PreparedStatement selectOldContent, long id) throws Exception { selectOldContent.setLong(1, id); try (ResultSet oldContentResult = selectOldContent.executeQuery()) { oldContentResult.next(); return oldContentResult.getBlob(1); } } private void oldContentToNewData(Reader oldContentReader, StringWriter newSchemeWriter, GZIPOutputStream newZippedDataOutput) throws Exception { try ( SmartXMLStreamWriter newSchemeXMLWriter = new SmartXMLStreamWriter(xmlFactory.createXMLStreamWriter(newSchemeWriter)); SmartXMLStreamWriter newDataXMLWriter = new SmartXMLStreamWriter(xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8")); ){ xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); } } private NewData generateNewDataFromOldContent(PreparedStatement selectOldContent, long id) throws Exception { try ( SmartBlob oldContent = new SmartBlob(loadOldContent(selectOldContent, id)); Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.blob.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); ){ oldContentToNewData(oldContentReader, newSchemeWriter, newZippedDataOutput); return new NewData(newSchemeWriter.toString(), newDataOutput.toByteArray()); } } private void storeNewData(PreparedStatement insertNewContent, long id, String newScheme, byte[] newData) throws Exception { try ( StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); ){ insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } public void migrate() throws Exception { List&lt;Long&gt; ids = loadIds(); try ( PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ){ for (Long id : ids) { NewData newData = generateNewDataFromOldContent(selectOldContent, id); storeNewData(insertNewContent, id, newData.scheme, newData.data); } } } }</span></span></code> </pre><br>  Two SmartXMLStreamWriter and SmartBlob wrappers were written, which automatically closed XMLStreamWriter and Blob into try-with-resources. <br><br>  And if I have more resources that do not implement AutoCloseable, will I have to write wrappers again?  Bob turned to the South for help.  South, a little bit, issued the original solution using the features of Java 8: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV5</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected @RequiredArgsConstructor private static class NewData { final String scheme; final byte[] data; } private List&lt;Long&gt; loadIds() throws Exception { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); try (ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data")) { while (oldIdResult.next()) { ids.add(oldIdResult.getLong(1)); } } return ids; } private Blob loadOldContent(PreparedStatement selectOldContent, long id) throws Exception { selectOldContent.setLong(1, id); try (ResultSet oldContentResult = selectOldContent.executeQuery()) { oldContentResult.next(); return oldContentResult.getBlob(1); } } private void oldContentToNewData(Reader oldContentReader, StringWriter newSchemeWriter, GZIPOutputStream newZippedDataOutput) throws Exception { XMLStreamWriter newSchemeXMLWriter; XMLStreamWriter newDataXMLWriter; try ( AutoCloseable fake1 = (newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter))::close; AutoCloseable fake2 = (newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"))::close; ){ xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); } } private NewData generateNewDataFromOldContent(PreparedStatement selectOldContent, long id) throws Exception { Blob oldContent; try ( AutoCloseable fake = (oldContent = loadOldContent(selectOldContent, id))::free; Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); ){ oldContentToNewData(oldContentReader, newSchemeWriter, newZippedDataOutput); return new NewData(newSchemeWriter.toString(), newDataOutput.toByteArray()); } } private void storeNewData(PreparedStatement insertNewContent, long id, String newScheme, byte[] newData) throws Exception { try ( StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); ){ insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } public void migrate() throws Exception { List&lt;Long&gt; ids = loadIds(); try ( PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ){ for (Long id : ids) { NewData newData = generateNewDataFromOldContent(selectOldContent, id); storeNewData(insertNewContent, id, newData.scheme, newData.data); } } } }</span></span></code> </pre><br>  Yes, yes, yes, exactly what you thought: he took the opportunity to transfer the method.  The code turned out just awful.  But you don‚Äôt have to write wrappers, Bob thought and wept. <br><br>  And then he drew attention to the annotation that he had already actively used: @RequiredArgsConstructor.  Eureka!  The Lombok library has the @Cleanup annotation, which is born to console the Java programmer who has lost all hope.  At the compilation stage, it adds try-finally to the bytecode and automatically adds the code to securely close the resources.  Moreover, she knows how to work with any method of freeing resources, be it close (), free () or any other, the main thing for her to tell about it (although she herself is clever and curses, if she did not find a suitable method). <br><br>  And Bob rewrote problem areas using @Cleanup: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV6</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected @RequiredArgsConstructor private static class NewData { final String scheme; final byte[] data; } private List&lt;Long&gt; loadIds() throws Exception { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); try (ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data")) { while (oldIdResult.next()) { ids.add(oldIdResult.getLong(1)); } } return ids; } private Blob loadOldContent(PreparedStatement selectOldContent, long id) throws Exception { selectOldContent.setLong(1, id); try (ResultSet oldContentResult = selectOldContent.executeQuery()) { oldContentResult.next(); return oldContentResult.getBlob(1); } } private void oldContentToNewData(Reader oldContentReader, StringWriter newSchemeWriter, GZIPOutputStream newZippedDataOutput) throws Exception { @Cleanup XMLStreamWriter newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter); @Cleanup XMLStreamWriter newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"); xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); } private NewData generateNewDataFromOldContent(PreparedStatement selectOldContent, long id) throws Exception { @Cleanup("free") Blob oldContent = loadOldContent(selectOldContent, id); try ( Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); StringWriter newSchemeWriter = new StringWriter(); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); ){ oldContentToNewData(oldContentReader, newSchemeWriter, newZippedDataOutput); return new NewData(newSchemeWriter.toString(), newDataOutput.toByteArray()); } } private void storeNewData(PreparedStatement insertNewContent, long id, String newScheme, byte[] newData) throws Exception { try ( StringReader newSchemeReader = new StringReader(newScheme); ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); ){ insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } public void migrate() throws Exception { List&lt;Long&gt; ids = loadIds(); try ( PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); ){ for (Long id : ids) { NewData newData = generateNewDataFromOldContent(selectOldContent, id); storeNewData(insertNewContent, id, newData.scheme, newData.data); } } } }</span></span></code> </pre><br>  Satisfied with the found elegant, and most importantly, out of the box, Bob made a long-awaited commit by decision and gave the code for the review. <br><br>  Nothing foreshadowed trouble.  But trouble always lurks around the corner.  The commit did not pass the review, South and Andrew did not endorse @Cleanup.  Only two places where non-AutoCloseable resources are used, they said.  What profit will it give us?  We do not like this abstract!  How will we debug the code in case of what?  And stuff like that.  Bob ruthlessly fought back, but all attempts were in vain.  And then he made another attempt to prove the convenience and rolled out the following code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigratorV7</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connection conn; <span class="hljs-comment"><span class="hljs-comment">// Injected private SAXParser xmlParser; // Injected private XMLOutputFactory xmlFactory; // Injected public void migrate() throws Exception { @Cleanup PreparedStatement selectOldContent = conn.prepareStatement("select content from old_data where id = ?"); @Cleanup PreparedStatement insertNewContent = conn.prepareStatement("insert into new_data (id, scheme, data) values (?, ?, ?)"); @Cleanup ResultSet oldIdResult = conn.createStatement().executeQuery("select id from old_data"); while (oldIdResult.next()) { long id = oldIdResult.getLong(1); selectOldContent.setLong(1, id); @Cleanup ResultSet oldContentResult = selectOldContent.executeQuery(); oldContentResult.next(); @Cleanup("free") Blob oldContent = oldContentResult.getBlob(1); @Cleanup Reader oldContentReader = new InputStreamReader(new GZIPInputStream(oldContent.getBinaryStream())); @Cleanup StringWriter newSchemeWriter = new StringWriter(); @Cleanup XMLStreamWriter newSchemeXMLWriter = xmlFactory.createXMLStreamWriter(newSchemeWriter); ByteArrayOutputStream newDataOutput = new ByteArrayOutputStream(); @Cleanup GZIPOutputStream newZippedDataOutput = new GZIPOutputStream(newDataOutput); @Cleanup XMLStreamWriter newDataXMLWriter = xmlFactory.createXMLStreamWriter(newZippedDataOutput, "utf-8"); xmlParser.parse(new InputSource(oldContentReader), new DefaultHandler() { // Usage of schemeXMLWriter and dataXMLWriter to write XML into String and byte[] }); String newScheme = newSchemeWriter.toString(); byte[] newData = newDataOutput.toByteArray(); @Cleanup StringReader newSchemeReader = new StringReader(newScheme); @Cleanup ByteArrayInputStream newDataInput = new ByteArrayInputStream(newData); insertNewContent.setLong(1, id); insertNewContent.setCharacterStream(2, newSchemeReader, newScheme.length()); insertNewContent.setBlob(3, newDataInput, newData.length); insertNewContent.executeUpdate(); } } }</span></span></code> </pre><br>  Yes Yes.  He removed all the additional methods and returned the sequential procedural code again.  He did not have time to check his working capacity, of course, because he wanted so much to show simplicity.  In this code, probably, not only he himself will understand in a month, but any other who will have to read it. <br><br>  But again he did not find support.  No matter how he fought against the wall - the wall was stronger.  And he gave up.  In production, the MigratorV5 code was eventually rolled out - the one where Java 8 features are used so clumsily. <br><br>  Epilogue. <br><br>  Of course, the code that was provided is far from ideal, and it can still be combed, some things can be rewritten in a completely different way, for example, using the template code.  The latter option is generally the embodiment of a procedural programming style, which is not very good (but it is understandable when reading from top to bottom).  But that's not the point.  @Cleanup is a cool annotation that helps precisely in such moments when we cannot use try-with-resources, it saves us from unnecessary nesting of blocks of code from one to another, if we do not divide operations into methods.  She does not need to get involved, but if necessary, why not? </div><p>Source: <a href="https://habr.com/ru/post/339046/">https://habr.com/ru/post/339046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339030/index.html">Continued fasting from schoolchildren. How could Habrahabr change our destiny?</a></li>
<li><a href="../339034/index.html">DevOps coming to our home? Home Minecraft server in Azure using modern DevOps practices</a></li>
<li><a href="../339036/index.html">[CppCon 2017] Bjorn Stroustrup: Learning and teaching modern C ++</a></li>
<li><a href="../339038/index.html">How to debug small programs</a></li>
<li><a href="../339044/index.html">How to bring the first project to the end. Part 2. Myths, mistakes and failures</a></li>
<li><a href="../339048/index.html">Swift Generics: Styles for UIView and more. # 2</a></li>
<li><a href="../339050/index.html">Habr advise: how to win the NTI olympiad for schoolchildren in the Big Data profile</a></li>
<li><a href="../339052/index.html">The history of the clock synchronizer DCF77</a></li>
<li><a href="../339054/index.html">How the MobX library helps to manage the state of web applications. Lecture in Yandex</a></li>
<li><a href="../339060/index.html">About interval indices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>