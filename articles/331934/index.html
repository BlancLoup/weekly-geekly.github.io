<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn all programming languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I was still a freshman, I met another student who claimed that he could write code in any programming language that I could call. I was somewhat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn all programming languages</h1><div class="post__text post__text-html js-mediator-article">  When I was still a freshman, I met another student who claimed that he could write code in any programming language that I could call.  I was somewhat shocked and replied with a podnachka: <br><br>  - What, even in that unreadable esoteric language, where there are only a couple of teams that barely pretend to be a Turing machine? <br>  - Yes, this language is called brainfuck.  I know brainfuck. <br><br>  And it was not a trick - we checked.  I called a programming language known to me, he spent a couple of minutes on the Internet to refresh his knowledge of it - and was able to write working algorithms in this language.  I could not understand it.  He, like me, was then about 18 years old - how could he know all these languages ‚Äã‚Äãat that age? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/22b/b9f/4cd/22bb9f4cdcfc84455cc23feff60c2368.png" alt="image"><br>  <i>Brainfuck interpreter written in brainfuck</i> <br><br>  Today, I still respect that demonstration of the skills of my classmate, but I am no longer shocked by it.  After I learned more than one programming language, it became clear to me that they differ significantly from each other than would be expected.  At some stage of training, I already paid attention not so much to the syntax of a programming language, but rather to the ideas underlying it, the memory model, the principles for executing instructions.  All this can be called the theory of programming languages, from the point of view of which different languages ‚Äã‚Äãsimply implement several different versions of the same basic ideas. <br><br>  Today, I advise my students to "try to learn all programming languages."  Think for yourself - because this idea is better than all of these ‚ÄúThis year I will learn Go!  Oh, no, now they say that in the fashion of Rust - I will learn better Rust!  Or Swift ... ".  Just learn everything - you can't go wrong.  And this article may help you in this a little. <br><a name="habracut"></a><br><h2>  And immediately - a disclaimer :) </h2><br><ul><li>  I never say that you need to really learn 500+ (or how many actual ones are there now?) Of programming languages.  I'm talking about the need to understand the basic paradigms and implementation of patterns, which will give you the opportunity to understand almost any constructs in almost any language.  A forgotten keyword or function from the standard library can always be found in the documentation. </li><li>  This is not a five minute deal.  Perhaps you will go far on this path in some year.  But, you know, a <a href="http://norvig.com/21-days.html">decade</a> may well go </li><li>  We'll have to explore some of the already outdated or not yet fashionable concepts. </li><li>  Depending on your main job (or life goals), all this may never be useful to you. </li></ul><br><h2>  Then why do this? </h2><br>  If you see some significant part of your career related to writing software, then you should be familiar with programming languages: <br><br><ul><li>  Even without choosing any specific programming languages ‚Äã‚Äã(or choosing just one) after a couple of years of work as a programmer, you will find that you have already written (or read) code in several languages.  So for some reason it always happens </li><li>  You will find that having knowledge of several programming languages, you will want every time to be able to choose one of them to solve various problems. </li><li>  Programming languages ‚Äã‚Äãare flourishing and becoming obsolete.  Knowledge of several of them gives you the opportunity to stay on the cutting edge of progress, have access to more interesting projects or good companies. </li><li>  Many important projects require a fundamental understanding of the work of compilers and knowledge of several programming languages.  These are implementations of development tools, standard libraries, domain-specific languages, IDE, browsers, databases, static analysis tools, etc. </li></ul><br>  Personally, the last item seems to me very important.  Ras Bodik well <a href="https://youtu.be/MjR7tQTIWbc%3Ft%3D13m17s">emphasized</a> this point in his lecture to Berkeley students when he explained the importance of studying the compiler development course: <br><br><blockquote>  Do not be the developers of template consumer software.  Instead, try developing new tools for users and other programmers.  If you draw a historical analogy, who would you rather be like: an employee at a loom who performs daily operations or develops new models of such machines? </blockquote><br><h2>  Step number 0: stop calling yourself a ‚ÄúRails programmer (substitute your language / platform)‚Äù </h2><br>  This is a simple but important step.  Yes, you probably already have some kind of specialization and you may be proud of it and continue to improve it - this is good.  But at the same time, such self-identification creates a mental barrier in your head.  Each new technology, each new language is perceived with a hint of skepticism or criticism, and possibly neglect - and this is already bad.  Start calling yourself simply ‚Äúsoftware engineer‚Äù or ‚Äúprogrammer‚Äù. <br><br>  An example would be Alex Gaynor - a great Python specialist, one of the Core Developers of such things as Django and PyPy, a member of the board of directors of the Python Software Foundation.  But once he was asked for help by <a href="https://en.wikipedia.org/wiki/United_States_Digital_Service">United States Digital Service</a> - and Alex <a href="https://alexgaynor.net/2016/dec/23/looking-for-work/">spent several years in projects on an ASP</a> (not even on ASP.NET, but on that old ASP).  Do you know why?  Because he is a software engineer, not a Python developer. <br><br><h2>  Step number 1: go to the meta level </h2><br>  There is such an old anecdote about how an applied physicist accidentally came to a conference of theoretical physicists.  He turned to one of the speakers and asked how he even managed to think about all these things, occurring in 11 dimensions?  The theoretical physicist replied, ‚ÄúOh, this is simple.  Just imagine N measurements, and then fix N equal to 11 ". <br><br>  A good programmer can use the same trick.  You can listen to all these stories of marketers that ‚ÄúGo is a new and ambitious programming language‚Äù, or you can simply define it for yourself as a compiled statically typed language with garbage collection and CSP competitiveness style.  Swift can be a ‚Äúnew and carefully designed‚Äù well or simply compiled general-purpose multi-paradigm language implemented on the basis of LLVM. <br><br>  For those who have never had the opportunity to study compilers, I can advise a few excellent books and online materials.  Firstly, this is a course from Alex Aiken, which was once available on the Coursera, and now on Stanford‚Äôs own platform ( <a href="https://lagunita.stanford.edu/courses">Lagunita</a> ).  Not bad and the course from Berkeley - CS164.  True, they stopped publishing its updates in open access, but 2012 materials seem to be still available. <br><br>  The canonical handbook about compilers: <a href="https://smile.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">‚ÄúCompilers: Principles, Techniques &amp; Tools‚Äù</a> .  She is the Book of the Dragon.  Like all books of this level, it has both fierce fans and irreconcilable critics.  Personally, I consider it an excellent material, but be prepared for the fact that some of its parts will have to be re-read more than once before full understanding.  There is a more simple and practical book aimed at <a href="https://smile.amazon.com/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/">Language Implementation Patterns</a> .  If your interest is limited to a specific practical task of a small scale (like writing a domain-specific language), then this book will work better than the classic Book of the Dragon. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e9/5b5/8b4/3e95b58b4c9dedb58133a535e362c793.jpg" alt="image"><br>  <i>Dragon book</i> <br><br><h2>  Step number 2: start with primary sources </h2><br>  With a good theoretical basis, it will be easier to learn new languages, but it‚Äôs still not so easy to take and learn all the 500+ more or less relevant programming languages ‚Äã‚Äãtoday.  Therefore, one can begin with the definition of languages ‚Äã‚Äãin which some fundamentally new ideas were first investigated and implemented.  On their basis, the study of similar tools in newer languages ‚Äã‚Äãwill be a trivial task. <br><br>  Peter Norvig gives some <a href="http://norvig.com/21-days.html">tips</a> on which paradigms are really important, and also in which languages ‚Äã‚Äãthey were first implemented: <br><br><blockquote>  Learn at least 5 programming languages.  Your knowledge should include at least one language with the classic abstraction of ‚Äúclasses‚Äù (it can be Java or C ++), one functional language (like Lisp, ML or Haskell), one language with support for syntactic abstraction (like Lisp), one declarative language (Prolog or C ++ templates), one language with advanced parallelism support (Clojure or Go). </blockquote> <br>  I think this advice is an excellent base, but you can go this way further.  First, I advise you to learn language C as early as possible.  It is so omnipresent and important that it simply cannot be ignored.  In addition, the study of C makes it much easier to study other languages, since well, very many of them took some ideas or parts of the syntax from C. <br><br>  I also recommend learning any assembler.  This can be MIPS (if you want to spend less time on training) or x86 (if you want to have practical use).  This will give you more knowledge about computer architecture and processor device than about programming languages, but if in the future you want to write a compiler, then this knowledge is what you need.  Perhaps someday, instead of an assembler, it will be possible to recommend studying the format of the intermediate code LLVM. <br><br>  Peter Norvig recommends learning declarative languages, but I would be more specific here and would advise you to learn a logic programming language.  It can be either a classic Prolog or <a href="https://en.wikipedia.org/wiki/MiniKanren">miniKanren</a> . <br><br>  In the section "languages ‚Äã‚Äãwith concurrency support" to the options mentioned, I would add CUDA.  This is a qualitatively different scale of parallelism, because hundreds of GPU cores can not be compared with some 4 cores of conventional processors.  You will not only understand the GPU device better, but also lay a good foundation for yourself to further explore machine learning (there, parallelism and computing on the GPU will be very useful).  But it is important to understand that you need both CUDA knowledge and one of the mentioned languages ‚Äã‚Äãwith parallelism for the CPU (like Go, Clojure or Erlang). <br><br>  Vector programming is another powerful paradigm.  Norvig in vain missed languages ‚Äã‚Äãwith his support, because they have quite specific application in use.  Classic examples can be APL / J / K / Q, as well as Matlab. <br><br>  There is also such a thing as highly specialized languages.  Sometimes creating your own highly specialized language for specific tasks can be the right decision.  But in order to decide on this, it is necessary to study specific examples of when this approach was successful.  I advise for this to look at things like Frink. <br><br>  Perhaps I have already suffered a little, but it is so difficult to stop when there is so much all that is delicious!  Someone will say that you should not miss learning Forth in order to understand stack languages ‚Äã‚Äã(although it seems to me that the work of stacks can be understood in other languages).  Someone will say that I have missed a very important language X or a whole category of languages ‚Äã‚ÄãY - and this will be true, because there are a <a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type">lot of</a> them. <br><br><h2>  Step number 3: practice </h2><br>  Simply make a list of languages ‚Äã‚Äãthat you plan to learn.  But to really take and study - it will take some time.  If you are lucky, you can apply some of them in your main job.  But even if this does not happen, you should try to find a way to learn a new language not only from a theoretical but also from a practical point of view.  Without theory, progress will be slow, but without practice you will be stuck. <br><br>  A good way to start learning a new language is to read a short squeeze on <a href="http://hyperpolyglot.org/">Hyperpolyglot</a> or <a href="https://learnxinyminutes.com/">Learn X in Y Minutes</a> .  This will give an approximate understanding of the key ideas of the language and remove the fear of unfamiliar syntax.  If you are already familiar with some similar language, then Hyperpolyglot has a very convenient language comparison function - this can surprisingly quickly move you into learning a new language. <br><br>  Another useful exercise would be to study not even the syntax of the language, but the document, which describes the motivation of its creators.  This will give you an understanding of why people in general spent their time and energy on creating this thing, what their motivation was and whether it can now or in the future coincide with yours.  For example, if you are afraid to study C ++ deeply or are skeptical about some of Stroustrup solutions, you should definitely read <a href="https://smile.amazon.com/Design-Evolution-C-Bjarne-Stroustrup/dp/0201543303/">The Design and Evolution of C ++</a> .  Most other programming languages ‚Äã‚Äãalso have somewhat similar publications. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/136/f44/ee6/136f44ee6f070f9bbfa278c01db0de3d.jpg" alt="image"><br><br>  After that, you can already read a book on the language or go straight to trying to write something not very difficult on it.  As for books, it is difficult to give some general recommendations, but I would still advise you to choose the most well-established, proven over the years things written for experienced programmers who are learning a new language.  Such books are often written by the authors of the language themselves and emphasize their main ideas, while more modern publications are aimed more at the practical application of languages ‚Äã‚Äãin various spheres. <br><br>  The fastest way to join a new language, in my opinion, is to find a set of small tasks and gradually solve them.  <a href="http://exercism.io/">Exercism.io</a> can be a good source.  In addition to the tasks there are even tests that make it possible to quickly assess the quality of your implementation.  The solution of small problems is in good agreement with the study of the theory and with the main work on other projects. <br><br>  Once you are comfortable with the syntax and small tasks will no longer cause you problems, I advise you to find a big project in this language.  And it should be a project in the area for which this language was created.  For example, if you are learning C or Go, write a command line utility with a large number of system calls.  If you are learning Python or Ruby - try to write something algorithmic and not very demanding on performance (AI for tic zeros :)) well, etc. <br><br><h2>  Keep digging </h2><br>  Given the number of programming languages ‚Äã‚Äãin the world and the fact that we really use even very old languages ‚Äã‚Äãlike C, it is easy to conclude that humanity has already invented all the programming languages ‚Äã‚Äãit needs.  But this is a very controversial assumption.  There is a very significant gap between what is considered possible to be programmed and what we have learned to program today.  And the problem is not in computing resources - with all the existing hardware platforms and clouds today we have where to drive the code.  The problem is in our ways of communicating with the computer, so that we can not always comfortably express what we want to get at the output of the program and how this should be calculated. <br><br>  Gerald Jay Sussman drew attention to this in his amazing report, <a href="https://www.infoq.com/presentations/We-Really-Dont-Know-How-To-Compute">We Really Don't Know How To Compute</a> .  It uses a somewhat outdated toolkit, but the tools that exist today do not give us any qualitatively different approaches to solving the problems highlighted by it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cd/a30/1d7/4cda301d7c7c1817f2b66d2705d6277b.png" alt="image"><br>  <i>Triangle of illusions.</i>  <i>A person immediately sees in this figure a triangle, but you need to spend considerable effort to teach a computer program to do it.</i> <br><br>  One of the people working at the forefront of science in the direction of developing programming languages ‚Äã‚Äãis Chris Granger, working on <a href="http://www.chris-granger.com/2016/07/21/two-years-of-eve/">Eve</a> .  He wants to develop not only the language, but also all related tools.  The language will be just one of the important components of a common platform.  I don‚Äôt know if Eve will become a new generation of mainstream platforms, but I believe that this approach, extending and complementing the language with supporting tools, can become part of the future.  At least, this will give the opportunity to better explain to the computer what we want from it.  As Ras Bodik mentioned above (and I repeated), I would like you to be a part of this progress.  Learn all programming languages, not just one language.  Understanding the basics and principles allows you to see further and be ready for the emergence of a new one. </div><p>Source: <a href="https://habr.com/ru/post/331934/">https://habr.com/ru/post/331934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331908/index.html">JaCarta Authentication Server and JaCarta WebPass for OTP Authentication in Linux SSH</a></li>
<li><a href="../331910/index.html">Super Metroid Invisible Hand</a></li>
<li><a href="../331912/index.html">How to create an alternative to Google Drive and Dropbox in 3700 hours</a></li>
<li><a href="../331916/index.html">N ways to use Ahrefs when conducting a search audit</a></li>
<li><a href="../331930/index.html">Transition to binary</a></li>
<li><a href="../331938/index.html">Configuring Dockerfile to create and run a Docker container with your Go program</a></li>
<li><a href="../331940/index.html">Guide: how to use Python for algorithmic trading on the exchange. Part 2</a></li>
<li><a href="../331944/index.html">Algorithm for finding the best route in linux</a></li>
<li><a href="../331946/index.html">Using GAP analysis to identify and coordinate project tasks</a></li>
<li><a href="../331948/index.html">Multicore DSP TMS320C6678. Core memory organization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>