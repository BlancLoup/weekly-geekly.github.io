<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ten years of Erlang programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I joined the Erlang community about 10 years ago, in the middle of the first phase of the HYIP. We were told that Erlang is the future of competitiven...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ten years of Erlang programming</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/c35/07e/d08c3507ef04c305f0934e703b35bf53.png"></div><br>  I joined the Erlang community about 10 years ago, in the middle of the first phase of the HYIP.  We were told that Erlang is the future of competitiveness and concurrency.  Implementing them in this language is the easiest and fastest, and you still get free distribution.  At that time, the future seemed incredible.  The virtual machine recently received <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">SMP</a> support, but in order to actually use all the processors, you had to run multiple virtual machines on one computer. <br><br>  I want to reflect on the past decade.  In this article I will talk about the HYIP phases in relation to Erlang, about the <i>ladder of ideas</i> in the language and its possible influence on the distribution of the language, about the changes I have gone through in these 10 years.  And in conclusion, I will share my thoughts on the fact that Erlang has yet to be brought into the community of programmers as a whole. <br><a name="habracut"></a><br><h3>  HYIP Phase </h3><br>  <a href="https://ru.wikipedia.org/wiki/Gartner">The HYIP cycle</a> consists of phases in the life cycle of a product or technology.  This is a marketing concept, not a scientific one, but it often helps in describing the essence of what is happening.  Most of all I am interested in <i>the HYIP phase</i> , a kind of gold rush covering the communities of programmers.  Perhaps you have come across this more than once, and all these phases are connected with some killer app that everyone rushes to use. <br><br>  From the examples, it immediately comes to mind Ruby on Rails, <a href="https://www.youtube.com/embed/Gzj723LkRJY">How to Build a Blog Engine in 15 minutes</a> (the phrase <i>‚ÄúLook at everything that I don‚Äôt do!‚Äù Is</i> still funny) or Go with Kubernetes (they worked together before, but then there was a direct surge).  This also includes Elixir from Phoenix. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      During the HYIP phase, there is an incredible influx of newbies who want to see what all the fuss is about.  Someone remains, most go.  You can stay for months or years, in rare cases you find a home for decades.  However, the overwhelming majority are a constant stream of serial people who jump from technology to technology, looking for opportunities to gain benefits by the fact that they are the first to use a framework, a language or a set of tools. <br><br>  So most often you need to make one real ‚Äúkiller app‚Äù, and people will reach into your ecosystem.  Killer app boosts the hype.  If you write it, they will come to you.  And if you can keep a small share of them and keep them active, then you will have a living community for the foreseeable future.  This, to some extent, resembles the idea of <a href="https://en.wikipedia.org/wiki/Rain_follows_the_plow"><i>rain following the plow</i></a> : <br><br>  <i>The Lord is driving the plow. ... Following this miraculous adaptation, which is man‚Äôs sole dominion over nature, clouds shed abundant rains ... [the plow] is a tool separating civilization from barbarism, it turns the desert into farms and gardens.</i>  <i>... In short, the rain follows the plow.</i> <br><br>  The essence of the theory was that human habitation and agriculture have an irreversible effect on the climate of arid and semi-arid areas, making these regions more humid.  This theory was widely adopted in the 1870s as an excuse for settling the Great Plains - a region formerly known as the ‚ÄúGreat American Desert‚Äù.  In the same years, this theory was used to justify the expansion of wheat sowing on marginal lands in South Australia. <br><br>  If we can run a large project, then developers will appear, and it will become self-sufficient.  I think this idea is clearly erroneous, mainly because during the largest phase of the HYIP, Erlang had dozens of killer applications, but the community is still small.  Here are examples of these applications: <br><br><ul><li>  <a href="https://www.ejabberd.im/">ejabberd</a> (2002, first stable release in 2005): it was one of the most, if not the most scalable chat server.  Ejabberd has achieved great success, and to some extent it is still relevant.  Today on StackOverflow there are still questions about the modules for this server.  Around 2011, it was forked into <a href="https://mongooseim.readthedocs.io/en/latest/History/">MongooseIM</a> , and both solutions are still supported. <br></li><li>  <a href="http://couchdb.apache.org/">CouchDB</a> (2005): one of the most popular databases written in Erlang, based on <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">the CAP theorem</a> .  Refers to the time of the appearance of multi-master storage.  Although MongoDB occupied the main market share, CouchDB has spiritual heirs among the storage engines, like <a href="https://barrel-db.org/">BarrelDB</a> , which is also still supported. <br></li><li>  <a href="https://www.rabbitmq.com/">RabbitMQ</a> (2007): Message Queuing Server, bending over most of the AMQP market.  It develops and often competes with <a href="https://kafka.apache.org/">Kafka</a> when it comes to streaming loads, although these products have different capabilities and applications. <br></li><li>  <a href="https://www.facebook.com/notes/facebook-engineering/chat-stability-and-scalability/51412338919/">Facebook chat</a> (2008): The initial version of Facebook Chat was written in Erlang.  For a number of internal reasons (stability, a large number of C ++ programmers, and a number of well-established solutions) were later rewritten to C ++. <br></li><li>  <a href="https://www.whatsapp.com/">WhatsApp</a> (2009, purchased in 2014): when Facebook got rid of the Erlang chat system, they bought WhatsApp, which <a href="https://www.wired.com/2015/09/whatsapp-serves-900-million-users-50-engineers/">required only 50 engineers for 900 million users</a> to support.  He lives to this day, and what's more, the WhatsApp team has further strengthened its ties with the Erlang and Elixir communities. <br></li><li>  <a href="https://riak.com/">Riak</a> (2009): one of the best examples of demonstrating power in the world of distributed systems.  Riak was a reliable distributed key-value repository.  This is Basho's product, which still works in health systems and other critical parts of the infrastructure.  Later, Basho went bankrupt (in no small measure due to <a href="https://www.klgatesdelawaredocket.com/2018/09/controller-breaches-fiduciary-duties-by-coercing-onerous-financing-terms/">violations of fiduciary duties</a> , which <a href="https://www.theregister.co.uk/2018/07/09/basho_damages_20m_misinformation_threats/">‚Äúled the company to full collapse‚Äù</a> ).  Then <a href="https://www.bet365.com/">Bet365</a> bought all their IP, generously opened them, and since then the database has been living in the open source world, although today it is going through hard times. <br></li></ul><br>  Many of these products came out during the first run of the book by Joe Armstrong <a href="https://www.goodreads.com/book/show/808814.Programming_Erlang">Programming Erlang</a> .  As a result, there was an explosion in the popularity of the language, and Erlang gained many admirers.  Even the fact that <a href="https://news.ycombinator.com/item%3Fid%3D12502531">Hacker News forced all the discussions on the Innards of Erlang</a> had a significant impact.  However, few people remained faithful to this language. <br><br>  Now I believe that killer applications are created by people who form the initial phase of the HYIP, and not vice versa.  There is always a small part of people who, before others, seek out interesting technologies, decide whether they like them, then create something, and if a killer app turns out, then it stimulates the development of an even more powerful phase of HYIP.  People will be engaged in the cult of cargo, and successful projects will produce imitators.  Also, the standard situation is the ‚Äúwheel inventions‚Äù phase, when everyone spends his time re-inventing already existing things, and a wave of messages about ‚Äúimplementing <i>X,</i> but in Y‚Äù appears. <br><br>  However, it is not enough just to create a killer app.  It is curious that all these products, like RabbitMQ and Ejabberd, despite their popularity, have a much larger user community than the developer community.  Thousands and thousands of corporations using these products do not necessarily make a significant contribution to the Erlang community. <br><br>  This is partly due to the fact that most Erlang killer applications are used in specialized infrastructures.  You have created a highly reliable component in the form of a black box that everyone uses, and if it works well, then no one will look inside.  Several dozen developers have provided the basis for thousands of other products and services.  A specialized infrastructure, by definition, does not need a large number of people to ensure its widespread impact.  It always has few developers and a small community compared to technologies that are closer to the final product, for example, web frameworks, or even more generalized infrastructures that are used in small projects for deployment, suitable for any company. <br><br>  But even despite all this, it is obvious that Erlang missed many people who went through it during the HYIP phase. <br><br><h3>  Ideas ladder </h3><br>  I will not <a href="https://plato.stanford.edu/entries/counterfactuals/">rant</a> about what could or should have been done.  Instead, I want to talk about popular learning patterns that I have met in the Erlang community over the years I have been teaching this language and programming on it.  I observe the same patterns today in the Elixir community, and this may indicate a similar future for him. <br><br>  I have a theory that such a technical topic as a programming language (and its ecosystem) has several levels of complexity, on which different concepts are located.  I used this theory in the project <i>Learn You Some Erlang</i> .  She is represented in the diagram, which I called the <a href="https://learnyousomeerlang.com/relups">Nine Circles of Earl</a> . <br><br>  Of course, this is an ironic idea, I do not think that the study of any technology is endless suffering (at least it should not be so).  I just liked the pun.  Simply put, there is always some kind of ‚Äúmain‚Äù path or sequence of topics that you learn when studying technology - this is the ‚Äúladder of ideas‚Äù, and the higher the concept on this ladder is, the more valuable it is and the harder it is to achieve, the fewer people learn it. <br><br>  What a ladder of ideas in Erlang might look like: <br><br><ol><li>  Functional programming. <br></li><li>  Isolated processes and competitiveness. <br></li><li>  Reliable competitiveness (links, monitors, timeouts). <br></li><li>  Principles of OTP and other system abstractions. <br></li><li>  How to structure the system according to the principles of OTP. <br></li><li>  How to collect releases and work with them (deploy). <br></li><li>  How to prevent the system from falling and working with it. <br></li></ol><br>  If you only get acquainted with Erlang and bought a book for beginners, then you probably spend the first days on the first rung of the ladder: acquaintance with functional programming, immutability (immobility), recursion and other similar concepts.  Sooner or later you will get to the competition and parallelism, processes and messaging.  Immediately after them, you will begin to explore links and monitors, handling failures and what makes Erlang what it is.  During the big phase of the HYIP, the second and third steps contained opportunities that for most observers looked just unbelievable.  If you needed to learn something that you would use in all future projects, then you could choose one of these Erlang features. <br><br>  It was possible to climb to other steps later, but only if you stick to the step training program.  In particular, OTP (fourth stage) can be described as ‚Äúwhat it is all about.‚Äù  Competitiveness and functional programming are good, but the common framework introduced using OTP was truly unique and needed to be used.  Over time, many will work with him, find that they can create cool abstractions, but they will not like the approach to structuring. <br><br>  In fact, to create applications like Ejabberd it was enough to overcome the fourth step.  At that time, the ecosystem was reminiscent of the Wild West, and the knowledge of OTP was owned by experts working at Ericsson, as well as the most motivated self-taught people.  Most never reached the fifth step, unless they sent something to production and did not encounter problems after that, or if they were not looking for a better solution.  The achievement of the sixth stage was rare until 2015-2016, and then <a href="https://github.com/erlware/relx">Relx emerged</a> , simplifying the assembly of releases and their mastering.  Almost no one got to the seventh stage, and a lot of people think that they should not perform a hot update of the Erlang node, and, ideally, they will never need to use SSH to debug production. <br><br>  In practice, not everyone goes up the ladder of ideas in the same order, its steps in some books are interchanged (for example, in <a href="https://www.manning.com/books/erlang-and-otp-in-action">Erlang and OTP in Action</a> ).  There is nothing wrong with that, the ladder is invented only as an illustration. <br><br>  The size of communities changes in waves.  During the phases of the HYIP, the size for some time may increase by tens or hundreds of times, and all these people are curious and go.  Most participants sit on the first rung of the stairs and rarely leave it behind.  Some climb to the second step, even less - to the third, and so on, until you get to a narrow circle of experts at the very top step. <br><br>  I think it was easy to climb the first three steps of Erlang.  To climb to the fourth one had to be engaged in development for several years, and indeed to feel the need for further study.  The fifth step is already very difficult.  The Erlang toolkit and ecosystem were poor.  Community members tolerated this barren environment, and were indifferent to the plight of newcomers.  To make the article shorter (well, long, but not absurdly long), see my presentation on the language ecosystem at the Erlang User Conference: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Z28SDd9bXcE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  If you write on Elixir, then you probably see at what level of this fictional staircase you are standing, and you can already imagine how much the community is distributed over it.  Many of the participants are fluent in Phoenix alone, but rarely rise above the fourth step, and many get stuck in the third and below.  And often this is enough.  I do not blame, but only share the observation.  Like anyone who has climbed many steps (and probably there are a few more steps in front of me, like a virtual machine patch or something else), I see that these people don't know much.  But honestly, all this information may be useless to them.  And this is good. <br><br>  What I want to say: I believe that we, as a community, are probably nagging under the bough, making the ladder of ideas very difficult to master above the basic level.  Some topics need to be studied slowly, and in some topics the blind lead the blind, because Erlang is so small that we simply have too few people who can share all the necessary experiences.  Today it‚Äôs easier, and if you don‚Äôt come to Erlang during the HYIP phase, you‚Äôll probably get help, because far fewer people ask for it at the same time. <br><br>  I would like to think, if tomorrow the second phase of the HYIP begins in the world of Erlang, then we will be able to accept newcomers better than during the times of the big wave, when I came too.  And I hope this experience, coupled with the closer cooperation of the Erlang and Elixir communities, will double our chances of successfully expanding the use of these languages. <br><br><h3>  What changed </h3><br>  Erlang does not float alcoholized in a flask, waiting to be pulled out into the light.  He is constantly evolving.  This is partly due to the competition and wishes from the Elixir community, which, fortunately, expects much more from their tools than what Erlang users are used to.  And partly the development is due to the actual needs of the industry and the wishes of the academic community. <br><br>  I think someone will be happy with these changes, which have occurred since 2009 or even earlier: <br><br><ul><li>  Multi-core support now works well.  Previously, if there were more than 2-4 cores, the system rested on all sorts of bottlenecks that were not subject to the application developer.  Then it became possible to use 12-16 cores.  Today I do not even know what the upper limit is, but I wrote and managed the stacks that worked on more than 32 cores without any problems. <br></li><li>  The stack traces now have line numbers.  It is almost unthinkable to return to the past, before the appearance of numbers.  In those years, ‚Äúwriting short, self-documented functions‚Äù was not a matter of architecture, but of survival.  Now you can debug programs on Erlang without supernatural debugging skills, although they never hurt. <br></li><li>  Currently, the quality of Unicode support is acceptable.  The strings module contains the most important algorithms, and the unicode module does an excellent job with most types of transformations and normalizations.  There are typical approaches for working with code points, UTF-8, UTF-16, and UTF-32.  Support for locales still leaves much to be desired, but everything else is in working condition.  Modules such as re (module for working with regular expressions) and all high-level functions for working with files also have no problems when working with unicode. <br></li><li>  Map maps (implemented as <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">HAMT</a> ) with explicit pattern matching syntax are <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">supported</a> .  With the help of Dialyzer, type analysis is applied to them, which allows them to be used in cases in which the use of records used to require great effort. <br></li><li>  Virtual machines now have excellent mechanisms for <a href="https://learnyousomeerlang.com/time">working with time</a> , they cope with changing time scales, different types of clocks and other things.  However, working with time zones and formatting time is better with the help of libraries developed by the community. <br></li><li>  Added high-performance tools such as <a href="http://erlang.org/doc/man/atomics.html">atomics</a> , <a href="http://erlang.org/doc/man/counters.html">counters</a> and <a href="http://erlang.org/doc/man/persistent_term.html">persistent terms</a> , they help to improve the various mechanisms underlying the monitoring tools and low-level base libraries. <br></li><li>  All <a href="https://www.youtube.com/watch%3Fv%3DU-JIzj07uQA">signal processing became asynchronous</a> , including work with <a href="">ports</a> , which saved us from many bottlenecks. <br></li><li>  The compiler has been rewritten and is still being rewritten to improve high-level analysis and performance with <a href="http://blog.erlang.org/ssa-history/">SSA.</a> <br></li><li>  There was a special type of scheduler for use in NIF - dirty schedulers, which further simplified integration with code written on with or even rust, with support for both CPU and I / O-intensive processes.  So, although the language itself did not become so much faster (although there is progress), it became much easier to connect high-performance libraries without unduly affecting the stability of the virtual machine. <br></li><li>  Various improvements have been made <a href="https://github.com/erlang/otp/tree/master/erts/emulator/internal_doc">in the mechanism for allocating and managing memory.</a> <br></li><li>  Analysis of the program has become more accurate and faster due to faster and more flexible traceability and <a href="http://erlang.org/doc/man/msacc.html">microstates accounting</a> . <br></li><li>  The more flexible OTP behavior of gen_statem made it possible to implement state machines capable of processing input data selectively. <br></li><li>  New improved <a href="https://ferd.ca/erlang-otp-21-s-new-logger.html">logging framework</a> with built-in support for structured logs. <br></li><li>  The crypto module is rewritten and uses NIF instead of more complex (and often slower update) drivers. <br></li><li>  The file driver was completely rewritten using NIF, which <a href="http://blog.erlang.org/My-OTP-21-Highlights/">greatly improved performance.</a> <br></li><li>  To achieve the same performance continue to rewrite network drivers using NIF. <br></li><li>  The use of SSL to handle TLS has been completely redone.  When I worked at Heroku, we tried to make the product comparable to C ++ solutions in terms of latency (maybe 5 percent worse) and greatly overtaken by predictability (10-30 times less than 99 percentiles). <br></li><li>  Significantly improved ETS performance. <br></li><li>  I wrote a <a href="https://erlang-in-anger.com/">guide to managing and debugging production systems</a> on Erlang virtual machines. <br></li><li>  A brand new build tool ( <a href="https://www.rebar3.org/">rebar3</a> ) integrated with a unified <a href="https://hex.pm/">package manager for the Erlang ecosystem.</a> <br></li><li>  Now a number of other languages ‚Äã‚Äãare available in the virtual machine, with cross-use of libraries.  Supported languages ‚Äã‚Äãinclude Elixir, Efene, LFE, Luerl, Clojerl and at least two languages ‚Äã‚Äãwith type derivation with Gleam and Alpaca. <br></li><li>  And many other changes inside and outside the main distribution of Erlang. <br></li></ul><br>  If you want to know more, read the <a href="https://www.erlang.org/news/tag/release">full list of changes in releases</a> .  In short, I can say that if the OTP team at Ericsson worked on 13-16 releases a little less intensively (and now version 22!), Then their efforts to use Erlang in the main product would be obvious.  However, everything changes outside of Ericsson.  The Erlang and Elixir communities, as well as Erlang VM development participants from other languages, have joined together to create the <a href="http://erlef.org/">Erlang Ecosystem Foundation</a> , with working groups that now help coordinate and solve the problems of assembly and packaging tools, improve observability ( security, etc. <br><br>  If you, like me, were part of a big initial HYIP phase, but, unlike me, you didn‚Äôt linger on this language, because a lot of things looked unusable or confusing, then you might want to give Erlang a second chance.  The convenience and language ecosystem has improved dramatically. <br><br><h3>  Where does Erlang go? </h3><br>  Perhaps, large killer applications no longer appeared, as it was in 2007-2009, but this does not mean that there are no promising projects.  Erlang is still deeply integrated into the infrastructure of many corporations, and most of its original killer applications are still in use.  In addition, we have many interesting new players, as each BEAM Conf conference shows.  I myself am very passionate about concepts like property-based testing (Property-Based Testing), and for Erlang and Elixir some of the best frameworks in the world have been created.  And despite all this, we are <i>not</i> in the HYIP phase.  At least now. <br><br>  Will there be another such phase?  Maybe yes, maybe not.  You can say that the next phase of HYIP was Elixir.  Ecosystems have much in common, so that the lessons learned in one of them are applied in the other.  Both ecosystems have more similarities than differences.  Perhaps we are waiting for some Renaissance.  Personally, I do not care anymore.  I like small communities, I feel comfortable in them.  To love Erlang, I do not need the geometric growth of followers, let their number simply be stable. <br><br>  In addition, the size of the community has never prevented the spread of Erlang around the world.  As far as I know him, the language has always been in such a position that there are not enough tasks for all Erlang programmers, and not enough programmers for all Erlang tasks: there are many of those and others, but geographically they do not always coincide.  The best are corporations and workers who enter remote labor markets. <br><br>  And if before Erlang could not easily penetrate the web application market, now with minimal modifications the entire Elixir market is open to it. <br><br>  It is probably not very important for the overall picture of the world whether you use a language like Erlang or not.  Although it seems to me that it is undervalued and could be applied more widely.  The main advantage of Erlang is not to use it.  The main advantage in learning the basics of designing reliable systems, as well as in the practical application of the knowledge gained. <br><br>  Over the years constantly heard issues related to the study.  How to learn to design protocols?  What advise to read about the creation of distributed systems?  How to work, but to do something very reliable and fault-tolerant?  How to understand that my architecture is modular and my abstractions do not flow?  What is good error handling?  How to know that optimization is premature?  What does ‚Äúmake something declarative‚Äù mean? <br><br>  We love short and digestible solutions, like recipe books and best practices, but the real answers are a variation of "I have learned in recent years."  Honestly, in my career, nothing compares to being in the Erlang community and absorbing the experience of its veterans.  The community is small but rich in all other criteria.  For several years, I moved from junior to senior roles, performed around the world, looking for ways to transfer my experience, and for the most part, it's all thanks to the community. <br><br>  Perhaps, I still can‚Äôt write a blog engine for 15 minutes (to tell the truth, I‚Äôm generally slowly developing), but I very quickly became much stronger as a developer and system architect.  Again, I was not always attracted by the <i>use of</i> systems, but by their creation and bringing to working condition.  Everyone has their own motivation. <br><br>  I can not imagine that I would have received as much in another community.  These 10 years have been awesome.  It is curious that the Erlang community is still small and its potential has not been revealed.  This means that there are many opportunities to participate in everything, to communicate one on one with people who are full of wisdom and want to share it, and find their place. <br><br>  <i>Ps.</i>  <i>Thanks for the translation mail ru group;</i>  <i>Erlang community in Telegram (Evgeny M., Sergey Ivanov, Vladimir Sekisov, Greg)</i> </div><p>Source: <a href="https://habr.com/ru/post/460115/">https://habr.com/ru/post/460115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460101/index.html">Operation cookie-based XSS | $ 2300 Bug Bounty story</a></li>
<li><a href="../460107/index.html">ISPsystem, forgive and forgive! Why and how we wrote our server control panel</a></li>
<li><a href="../460109/index.html">Angular: when you need to cut the application, and the backend is not yet ready</a></li>
<li><a href="../460111/index.html">Upgraded version of SAP Business One 9.3: what has changed</a></li>
<li><a href="../460113/index.html">A few stories from the life of the JSOC CERT, or nonbanal forsenika</a></li>
<li><a href="../460117/index.html">The largest customers in Russia - a big score or a headache? AGIMA Experience</a></li>
<li><a href="../460119/index.html">Errors that static code analysis does not find, because it is not used</a></li>
<li><a href="../460125/index.html">Node.js or Java: performance, resources, flow control, popularity, and personal experience</a></li>
<li><a href="../460129/index.html">Robots and strawberries: how AI increases field yields</a></li>
<li><a href="../46013/index.html">Y! LIVE, Pownce ... Who's next?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>