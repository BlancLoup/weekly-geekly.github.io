<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Git internals: data storage and merge</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of transition from SVN to Git, we were faced with the need to rewrite our internal tools related to the deployment of code, which focus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Git internals: data storage and merge</h1><div class="post__text post__text-html js-mediator-article">  In the process of transition from SVN to Git, we were faced with the need to rewrite our internal tools related to the deployment of code, which focused on the existence of a linear history of edits (and development on the trunk).  On Habr√© already published possible solutions to this problem through Git-SVN, but we went the other way.  We need support for Git features such as <i>branching</i> and <i>merge</i> , so we decided to understand the basics of how Git works and how it should be integrated with it. <br><a name="habracut"></a><br><h4>  About the article </h4><br>  The material is primarily aimed at readers who know how to work with Git at the level of a regular user and who know the basic concepts of working with him.  Perhaps the article will not contain anything new for developers of version control systems that support the easy creation of branches and their reliable merging.  All information is taken from open sources, including Git sources (2d242fb3fc19fc9ba046accdd9210be8b9913f64). <br><br><h4>  Data Storage: Objects </h4><br>  The information is based on the <a href="http://git-scm.com/book/en/Git-Internals">latest chapter of Pro Git</a> . <br><br>  In Git, the data storage unit is an object (English object), which is uniquely determined by the 40-character sha1 hash.  Git stores almost everything in objects: commits, the contents of files, their hierarchy.  At first, objects are regular files in the .git / objects folder, and after git gc they are packaged into .pack-files, which will be described below.  To save disk space, the contents of all objects are additionally compressed using zlib. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can find out the type of object by typing <pre> <code class="hljs ruby"><code>git cat-file -t .   : <br> <br> BLOB ( ). <br>    BLOB       .  :   ,     . <br> <br>  ,   BLOB    ,   ,   . ,        <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>       ,       : <br> <br> $ git init Initialized empty Git repository <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test/.git/ $ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>((i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">100000</span></span>;i++)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo $i; done &gt;test.txt $ ls -lh <span class="hljs-number"><span class="hljs-number">575</span></span>K test.txt $ git add test.txt $ git commit -m <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> [master (root-commit) b3061d2] First commit <span class="hljs-number"><span class="hljs-number">1</span></span> file changed, <span class="hljs-number"><span class="hljs-number">100001</span></span> insertions(+) create mode <span class="hljs-number"><span class="hljs-number">100644</span></span> test.txt $ find .git/objects -type f <span class="hljs-params"><span class="hljs-params">| xargs ls -lh 204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #   ... $ echo 10001 &gt;&gt; test.txt $ git commit -m "Added another line" test.txt [master 0361e3c] Added another line 1 file changed, 1 insertion(+) # Git ,   1  $ find .git/objects -type f |</span></span> xargs ls -lh <span class="hljs-number"><span class="hljs-number">204</span></span>K .git/objects/<span class="hljs-number"><span class="hljs-number">59</span></span>/e434385635dccf949e66353f7a74a077357438 <span class="hljs-comment"><span class="hljs-comment">#   204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #    ...</span></span></code></code> <h5> <code class="hljs ruby"><code>git cat-file -t .   : <br> <br></code> BLOB ( ). <br>    BLOB       .  :   ,     . <br> <br>  ,   BLOB    ,   ,   . ,        <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>       ,       : <br> <br> $ git init Initialized empty Git repository <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test/.git/ $ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>((i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">100000</span></span>;i++)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo $i; done &gt;test.txt $ ls -lh <span class="hljs-number"><span class="hljs-number">575</span></span>K test.txt $ git add test.txt $ git commit -m <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> [master (root-commit) b3061d2] First commit <span class="hljs-number"><span class="hljs-number">1</span></span> file changed, <span class="hljs-number"><span class="hljs-number">100001</span></span> insertions(+) create mode <span class="hljs-number"><span class="hljs-number">100644</span></span> test.txt $ find .git/objects -type f <span class="hljs-params"><span class="hljs-params">| xargs ls -lh 204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #   ... $ echo 10001 &gt;&gt; test.txt $ git commit -m "Added another line" test.txt [master 0361e3c] Added another line 1 file changed, 1 insertion(+) # Git ,   1  $ find .git/objects -type f |</span></span> xargs ls -lh <span class="hljs-number"><span class="hljs-number">204</span></span>K .git/objects/<span class="hljs-number"><span class="hljs-number">59</span></span>/e434385635dccf949e66353f7a74a077357438 <span class="hljs-comment"><span class="hljs-comment">#   204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #    ...</span></span></code> </h5> <code class="hljs ruby"><code>git cat-file -t .   : <br> <br></code> BLOB ( ). <br>    BLOB       .  :   ,     . <br> <br>  ,   BLOB    ,   ,   . ,        <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>       ,       : <br> <br> $ git init Initialized empty Git repository <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test/.git/ $ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>((i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">100000</span></span>;i++)); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo $i; done &gt;test.txt $ ls -lh <span class="hljs-number"><span class="hljs-number">575</span></span>K test.txt $ git add test.txt $ git commit -m <span class="hljs-string"><span class="hljs-string">"First commit"</span></span> [master (root-commit) b3061d2] First commit <span class="hljs-number"><span class="hljs-number">1</span></span> file changed, <span class="hljs-number"><span class="hljs-number">100001</span></span> insertions(+) create mode <span class="hljs-number"><span class="hljs-number">100644</span></span> test.txt $ find .git/objects -type f <span class="hljs-params"><span class="hljs-params">| xargs ls -lh 204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #   ... $ echo 10001 &gt;&gt; test.txt $ git commit -m "Added another line" test.txt [master 0361e3c] Added another line 1 file changed, 1 insertion(+) # Git ,   1  $ find .git/objects -type f |</span></span> xargs ls -lh <span class="hljs-number"><span class="hljs-number">204</span></span>K .git/objects/<span class="hljs-number"><span class="hljs-number">59</span></span>/e434385635dccf949e66353f7a74a077357438 <span class="hljs-comment"><span class="hljs-comment">#   204K .git/objects/97/578648a76227f183339438512ad99a383b48cc #    ...</span></span></code> </pre><br><br>  Also, storing objects entirely allows you to reliably merge branches with conflict resolution.  But more on that later. <br><br><h5>  Tree (FS hierarchy) </h5><br>  a tree object ( <i>tree</i> ) is stored a list of records that corresponds to the hierarchy of the file system.  One entry is the following: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sha1</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag"> &gt;</span></span></code> </pre><br>  File permissions in Git can have only a very limited set of values: <br><br>  040000 - directory; <br>  100644 - a regular file; <br>  100755 - file with the rights of execution; <br>  120000 - symbolic link. <br><br>  The object type is a BLOB or tree, for a file and a directory, respectively.  That is, the object of the tree type for the root directory stores the entire hierarchy of the file system, since within one tree there may be references to other trees. <br><br><h5>  Commit </h5><br>  In Git, one <i>commit</i> (eng. <i>Share</i> ) is a link to the tree object corresponding to the root directory, and a link to the parent commit (except for the very first commit in the repository).  Also in the commit there is information about the author and UNIX timestamp from the time of creation. <br><br>  If a commit is a simple merge ( <code>git merge &lt; &gt;</code> ), then it will have 2 parents: the current HEAD and the commit that <code>&lt; &gt;</code> points to.  Git also supports the octopus merge strategy ( <i>octopus</i> ), in which it can merge more than two branches.  For such commits, the number of parents will be more than two. <br><br><pre> <code class="hljs xml">$ git cat-file -p 0361e3c6d16fb3bbbcac8faa4e673667ea6fe20b tree ce9f2ced0ebb4346676879c7b12b92628378477f parent b3061d23da6f1a62dbc8f97b2a06e10e1aee2afa author Yuriy Nasretdinov <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span> 1354450065 +0400 committer Yuriy Nasretdinov <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span> 1354450065 +0400 Added another line</code> </pre><br><br><h5>  Pack files </h5><br>  If Git really kept all the objects entirely (albeit compressed), the <i>.git</i> folder would be a huge set of files, and they would be much larger than in the working copy.  However, this does not happen, but mysterious <i>pack-files</i> appear in which the objects are packed.  Oddly enough, there is little information on the Internet about how Git stores data in these files, so here‚Äôs an excerpt from a Linus Torvalds email that gives some explanation about these mysterious files (source: <a href="http://gcc.gnu.org/ml/gcc/2007-12/msg00165.html">gcc.gnu.org/ml/gcc / 2007-12/msg00165.html</a> ): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  "... It's worth explaining (you are not aware of it, but <br>  let me go through the basics anyway) how git delta-chains work <br>  they are so different from most other systems. <br><br>  In other SCM's, a delta-chain is generally fixed.  It might be "forwards" <br>  or "backwards", and it might be a bit like you work with the repository, <br>  but some <br>  kind of single scm entity.  In CVS, it's obviously the *, v file, and a lot <br>  systems do rather similar things. <br><br>  Git also has a lot more "loosely".  There <br>  is no fixed entity.  Delta's are generated against any random other version <br>  that git deems to be a good candidate <br>  successful heursitics), and there are absolutely no hard grouping rules. <br><br>  This is generally a very good thing.  It's good for various conceptual <br>  reasons (ie git internally never <br>  revision chain at it) <br>  delta rules means <br>  that git doesn't <br>  for example - there simply are no arbitrary *, v "revision files" that have <br>  some hidden meaning. <br><br>  It is a little more open-ended <br>  question.  You really <br>  There is a lot of choices, but in git, it really <br>  can be a totally different issue. <br></div></div><br><br>  In short, in the pack-files, objects are grouped by similarity (for example, type and size), after which they are stored in the form of "chains".  The first element of the chain is the newest version of the object, and the next one is diff to the previous one.  The most recent versions of the object are considered the most requested, so they are stored higher in the chain. <br><br>  Thus, Git still keeps diffs, but only at the level of direct data storage.  From the point of view of any API at a higher level, Git handles objects entirely, which allows you to implement various merge strategies and easily resolve conflicts. <br><br><h5>  History storage </h5><br>  Git does not have a separate history repository.  The whole story can be expanded, but only by following the links to the parent from the commit you need.  If you only need to look at the history by one file (or by subdirectory), Git still needs to do the same, but it will return the filtered results.  It is worth keeping this in mind when you are integrating with Git, and not forcing Git to do a full history view for each file. <br><br>  In addition, as you may have noticed, Git does not store information about renaming files.  If you need to understand whether the file has been renamed or not, Git analyzes the contents of the objects it has and with some (adjustable) tolerance, considers that the file has been renamed. <br><br><h5>  <i>Merge</i> : three way merge ( <i>resolve</i> strategy) </h5><br>  If you need to merge two branches, then git defaults to the <i>recursive</i> strategy, but more on that later.  Before this strategy appeared, the resolve strategy was used, which is a <a href="http://en.wikipedia.org/wiki/Merge_(revision_control)">trilateral merger</a> .  In order to perform such a merge, you need to have 3 versions: a common parent, a version from one branch and a version from another branch.  If you are merging files, such a three-way merger can be done using the <i>diff3</i> utility, which is included in the standard <a href="http://en.wikipedia.org/wiki/Diff3">diffutils</a> package.  This modest and rarely mentioned utility, in one way or another, does all the dirty work of merging in most existing version control systems, including RCS, CVS, SVN and, of course, Git. <br><br>  In addition to using the <i>diff3</i> analog (the specific implementation used in Git is LibXDiff), Git also calculates file renames on the fly and uses this information to merge tree objects.  Merging directory hierarchies does not represent anything fundamentally difficult compared to merging files, but generates a lot of different types of conflicts. <br><br>  A small illustration of how Git performs a three-way merge in a simple case (taken from <i>man git-merge</i> ): <br><br><blockquote>  Suppose we have such a story and the current branch is master: <br><br><pre> <code class="hljs pgsql"> A<span class="hljs-comment"><span class="hljs-comment">---B---C topic / D---E---F---G master</span></span></code> </pre> <br><br>  Then the <i>git merge topic</i> will repeat the changes made in the topic starting with the commit, when the story split (commit E), and create a new commit H, which will have two parents, and a commit message that the user will provide. <br><pre> <code class="hljs pgsql"> A<span class="hljs-comment"><span class="hljs-comment">---B---C topic / \ D---E---F---G---H master</span></span></code> </pre> <br></blockquote><br>  Nevertheless, the development in the branches of the <i>topic</i> and <i>master</i> can be continued, and then the merger will no longer look so simple: we can have more than one commit that fits the definition of a ‚Äúcommon ancestor‚Äù: <br><pre> <code class="hljs pgsql"> A<span class="hljs-comment"><span class="hljs-comment">---B---C---K---L---M topic / \ D---E---F---G---H---N---O---P master</span></span></code> </pre><br><br>  If we use the <i>resolve</i> strategy, the oldest common ancestor (commit E) will be selected.  If, as a result of merge, there were conflicts resolved in commit H, we would still need to resolve them again. <br><br>  To perform a merge using the <i>resolve</i> strategy, Git will take commit E as a common ancestor and commit M and P as two new versions.  If there was a conflict in commit C, then the conflicting changes can be rolled back using <i>git revert</i> (for example, this is done in commit K), then the final state M will no longer contain a conflict, and there will also be no conflicts when merging conflicts. <br><br><h4>  Merge made by the 'recursive' strategy </h4><br>  Imagine this story: <br><pre> <code class="hljs pgsql"> A<span class="hljs-comment"><span class="hljs-comment">---B---C---K---L---M topic / \ / D---E---F---G---H---N---O---P master</span></span></code> </pre><br><br>  Now we need to run the <i>git merge topic</i> while in the <i>master</i> branch.  We could choose to commit E as a common ancestor, but Git with the <i>recursive</i> strategy does otherwise.  On the Internet, you can find one good article that describes this strategy in some detail: <a href="http://codicesoftware.blogspot.com/2011/09/merge-recursive-strategy.html">codicesoftware.blogspot.com/2011/09/merge-recursive-strategy.html</a> .  The article describes an algorithm that boils down to the following: <br><ul><li>  compile a list of all common ancestors, starting with the most recent; </li><li>  we take the very first ancestor for the current commit; </li><li>  we merge the current commit with the next ancestor and get a <i><b>virtual commit</b></i> that we take as the current <i><b>commit</b></i> ; </li><li>  perform the previous operation until the list of common ancestors ends. </li></ul><br><br>  The result of this operation will be a virtual commit, which is the "cursed" state of all common ancestors in the correct order - conflict resolution will also fall into this commit, and more recent commits will have priority.  When we have a common ancestor, the three-way merger described above is performed. <br><br>  Excerpt from <i>merge-recursive.c</i> : <br><pre> <code class="hljs php">int merge_recursive(...) { &lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ca) { ca = get_merge_bases(h1, h2, <span class="hljs-number"><span class="hljs-number">1</span></span>); ca = reverse_commit_list(ca); } &lt;...&gt; merged_common_ancestors = pop_commit(&amp;ca); &lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iter = ca; iter; iter = iter-&gt;next) { &lt;...&gt; merge_recursive(o, merged_common_ancestors, iter-&gt;item, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;merged_common_ancestors); &lt;‚Ä¶&gt; } &lt;...&gt; clean = merge_trees(o, h1-&gt;tree, h2-&gt;tree, merged_common_ancestors-&gt;tree, &amp;mrtree); &lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clean; }</code> </pre><br><br><h4>  Low Level Git Commands </h4><br>  If you've worked for a while with Git, then you probably know about the checkout, branch, pull, push, rebase, commit, and some other commands.  But initially Git was created not as a full-fledged version control system, but as a framework for its creation.  Therefore, Git has a very rich set of built-in commands that work at a low level.  Here are some of them, very useful, in our opinion: <br><br><h5>  git rev-parse &lt;revision&gt; </h5><br>  This command is very simple: it returns the commit hash for the specified revision.  For example, git rev-parse HEAD will return the hash of the commit pointed to by HEAD. <br><br><h5>  git rev-list &lt;commit&gt; ... </h5><br>  The command displays a list of commit hashes for the specified request and can be used as a faster alternative to <code>git log</code> .  For example, <code>git rev-list branch ^origin/branch ^origin/master</code> will output all the commits from the branch that have not yet been started (provided that origin / branch and origin / master are fresh, for example, before this was done <code>git fetch</code> ) . <br><br>  <i>Pitfalls:</i> With regard to requests of the type <i>branch ^ other_branch</i> , Git may incorrectly output results if commits have the wrong time.  For example, the output may be missing commits that ‚Äúoccurred in the future‚Äù compared to merge branches. <br><br><h5>  git diff-index </h5><br>  Shows the difference between a working copy and an <i>index</i> (.git / index).  In the index, Git stores the <i>lstat ()</i> cache from all files it knows about. <br><br>  <i>Pitfalls:</i> if you transfer files from one server to another (or make a copy of a folder), then git diff-index will show many changes, although they are not there.  This is due to the fact that almost all <i>lstat</i> fields are stored in <i>.git / index</i> , including the <i>inode</i> , and the contents of <i>diff-index</i> files are not parsed.  Therefore, you need to do additional <i>git update-index</i> , or use the usual <i>git diff</i> , which does this automatically.  Read more about .git / index: <a href="http://www.kernel.org/pub/software/scm/git/docs/v1.6.5/technical/racy-git.txt">www.kernel.org/pub/software/scm/git/docs/v1.6.5/technical/racy-git.txt</a> <br><br><h5>  git cat-file &lt;object&gt; </h5><br>  This team has already met in the article, but it is still worth mentioning again.  It allows you to get the contents of a commit and any other Git object. <br><br><h5>  git ls-tree &lt;object&gt; </h5><br>  Prints the contents of the tree object in a reasonable form. <br><br><h5>  git ls-remote &lt;repository&gt; </h5><br>  Displays information about branches and tags (along with commit hashes) from the specified remote repository. <br><br><h5>  GIT_SSH </h5><br>  If you wrote scripts that make <i>git pull</i> , then most likely you‚Äôve come across SSH asking for confirmation of the ‚Äúauthenticity‚Äù of the remote repository, and it does it interactively.  The solution to this problem is not so elegant, because GIT_SSH should be the path to the executable file (rather than the SSH option): <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'#!/bin/sh exec ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \"\$@\"'</span></span> &gt;/tmp/gitssh; chmod +x /tmp/gitssh; <span class="hljs-comment"><span class="hljs-comment">#  git pull: GIT_SSH=/tmp/gitssh git pull ‚Ä¶</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  As you can see, Git allows you to work really well and reliably with branches, including correctly handling situations where two branches have more than one common ancestor.  Unless your goal is to write your version control system, we would recommend using the results of Git, rather than trying to reproduce its merge algorithm. <br><br>  Hopefully this material was interesting for you and let you understand why Git works this way and not otherwise.  We believe that the article will also be useful for developers of various interfaces to Git, leading to a deeper understanding of what is happening "under the hood." <br><br>  <i>Yuri Nasretdinov, Badoo developer</i> </div><p>Source: <a href="https://habr.com/ru/post/163853/">https://habr.com/ru/post/163853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163839/index.html">Product Lifecycle Management. Popularly about the processes of life cycle management of telecommunications services</a></li>
<li><a href="../163841/index.html">Display generated on the fly html pages without saving to the clipboard or file system</a></li>
<li><a href="../163845/index.html">When is MIN (DATE)! = MIN (DATE)?</a></li>
<li><a href="../163847/index.html">Controlled caching of pages in nginx</a></li>
<li><a href="../163849/index.html">What is wrong with the work on the result</a></li>
<li><a href="../163855/index.html">Creating a Django web application in Visual Studio 2012 and publishing it to the Windows Azure cloud</a></li>
<li><a href="../163857/index.html">EBS RAID for faster performance and cost effectiveness</a></li>
<li><a href="../163859/index.html">Multithreaded web server for 1C: Enterprise using .Net Framework</a></li>
<li><a href="../163861/index.html">Minicomputer from router with OpenWRT: write USB class-driver under Linux</a></li>
<li><a href="../163865/index.html">Started collecting pre-orders for virt2real (Virtuirlka)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>