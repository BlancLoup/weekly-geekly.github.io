<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of program execution time in C ++ (remove conditional transitions)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By optimizing the execution time of the algorithm using the LDPC decoder, the profiler resulted in a function that calculates the following value: 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of program execution time in C ++ (remove conditional transitions)</h1><div class="post__text post__text-html js-mediator-article">  By optimizing the execution time of the algorithm using the <a href="http://ru.wikipedia.org/wiki/LDPC">LDPC</a> decoder, the profiler resulted in a function that calculates the following value: <br><img src="https://habrastorage.org/getpro/habr/post_images/724/c58/fa2/724c58fa2d83f712369ef9aacc7b5cc4.png" alt="image"><br>  where <i>a</i> and <i>b</i> are integers.  The number of calls went to millions, and its implementation was enough <a name="habracut"></a>  simple and unsophisticated: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (b&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) ? __min(a,b) : -__min(a,-b); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (b&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) ? -__min(-a,b) : __min(-a,-b); }</code> </pre> <br><br>  The function consists essentially of three consecutive comparison operations.  This gives (taking into account the optimization of the compiler) two (if the numbers of different signs) or three (if one) conditional transition to get the result.  Recalling the <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B2%25D0%25B5%25D0%25B9%25D0%25B5%25D1%2580">potential problems of the</a> <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B2%25D0%25B5%25D0%25B9%25D0%25B5%25D1%2580">conveyor</a> with a large number of conditional transitions, it was decided to reduce their number or even get rid of them.  To evaluate the performance was written a small <div class="spoiler">  <b class="spoiler_title">test project</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Windows.h&gt; static inline int LLR(int a, int b) { if (a&gt;0) return (b&gt;0) ? __min(a,b) : -__min(a,-b); else return (b&gt;0) ? -__min(-a,b) : __min(-a,-b); } int _tmain(int argc, _TCHAR* argv[]) { SetPriorityClass(GetCurrentProcess(),REALTIME_PRIORITY_CLASS); SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL); srand(0); int x(0); __int64 t1,t2; QueryPerformanceCounter((LARGE_INTEGER*)&amp;t1); for (size_t i=0;i&lt;MAXUINT&gt;&gt;4;i++) { int a = rand() - RAND_MAX / 2; int b = rand() - RAND_MAX / 2; /* x += LLR(a,b);*/ } QueryPerformanceCounter((LARGE_INTEGER*)&amp;t2); t2 -= t1; QueryPerformanceFrequency((LARGE_INTEGER*)&amp;t1); _tprintf_s(_T("%f"),t2/(t1*1.)); return 0; }</span></span></span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The build was done in MSVS 2008 in the Release configuration (default settings) for the x86 platform. <br></div></div><br>  To begin, comment out the call to the computational function to estimate the cycle time with random number generation (unfortunately, the call to <i>QueryPerformanceCounter ()</i> itself is rather slow and leads to a significant distortion of the result if it is done inside the cycle).  Run the project several times to make sure that the result is repeatable.  On a machine with an Intel Core i7-3770 processor with a frequency of 3.4 GHz, the execution time is on average 9.2 seconds.  If you uncomment the call to the calculated function, rebuild the project and repeat the experiment, we get about 11.5 seconds.  The increase in the execution time is obvious, and we will fight with it. <br><br>  Let's try to get rid of conditional statements.  First, find out the sign of the product <i>a</i> and <i>b</i> .  It is incorrect to calculate it in the forehead due to possible overflow.  Since only the sign is important for us (that is, the bit value of the sign bit of an integer), it is appropriate to use the <b><i>xor</i></b> operation to determine the sign of the product <i>a</i> and <i>b</i> .  Next, we shift the result of <i>a <b>xor</b> b</i> to the right by 31 bits (leaving only the sign bit) and get 0 in the case of a non-negative number and 1 in the case of a negative one.  Multiply this value by two, subtract from unity and get -1 for a negative number and 1 for a non-negative one: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a^b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>);</code> </pre>  Now we calculate the modules <i>a</i> and <i>b</i> .  Using a similar method, we determine the signed coefficients <i>a</i> and <i>b</i> and multiply by them: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; c = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>); a *= c; c = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>); b *= c;</code> </pre>  Let's turn to the calculation of the minimum.  Since <i>a</i> and <i>b</i> already have non-negative values, it is possible to calculate the minimum based on the sign of their difference: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numbers[<span class="hljs-number"><span class="hljs-number">2</span></span>], min; numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = b; numbers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = a; a -= b; c = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>(a))&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; min = numbers[c];</code> </pre>  Let's put it all together and get <div class="spoiler">  <b class="spoiler_title">next function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLR_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign, numbers[<span class="hljs-number"><span class="hljs-number">2</span></span>]; sign = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a^b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>); a *= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>); b *= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>); numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = b; numbers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = a; a -= b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sign*numbers[((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>]; }</code> </pre><br></div></div><br>  Replace the <i>LLR ()</i> call with <i>LLR_2 ()</i> and see what happens.  In the assembler code, now there is not a single conditional transition, but there appeared three instructions for integer multiplication <i>imul</i> (multiplication by 2 the compiler replaces itself with a shift).  Having banished the test program, we get the following result - the runtime is 9.4 seconds!  So, comparing the net times (2.1 and 0.2 seconds, respectively) for the two options for calculating the desired value, we get a tenfold <a href="https://habr.com/ru/post/180085/"><sup>*</sup></a> increase in the speed of the required operation. <br><br>  Let's try to go a little further.  Integer multiplication is needed only to change the sign of a number that can be performed <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_%2528%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0%2529">directly</a> .  In particular, the calculation of the modulus of <i>a</i> can be implemented as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> constant[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = ((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; a = a^mask[c]+constant[c];</code> </pre>  Finally, replace the right 31 bits with a single left circular shift using the <i>_rotl ()</i> function.  Looking ahead, the compiler converts its call directly into a <i>rol</i> instruction without using <i>call</i> .  Putting it all together again and get <div class="spoiler">  <b class="spoiler_title">third option</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> constant[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LLR_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign,c, numbers[<span class="hljs-number"><span class="hljs-number">2</span></span>]; sign = (_rotl(a^b,<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>); c = ((_rotl(a,<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)); a = (a^mask[c])+constant[c]; c = ((_rotl(b,<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)); b = (b^mask[c])+constant[c]; numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = b; numbers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = a; c = ((_rotl(ab,<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (numbers[c]^mask[sign])+constant[sign]; }</code> </pre><br></div></div><br>  Replace the <i>LLR () _ 2</i> <i>call</i> with <i>LLR_3 ()</i> and see that this does not give a significant increase (the execution time is approximately the same 9.4 seconds with a small difference in the third digit in a smaller direction).  It turns out that <i>imul</i> on modern processors runs pretty fast! <br><br>  Let's return to the algorithm that started it all.  The described optimization of only one function managed to reduce the processing time of a single data block from 160 to 140 seconds (when executed on i7), which is more than 10% and is a very good result.  Next up are some more similar features ... <br><br>  And finally, I propose an embodiment of the function of determining the maximum of two whole 32-decimal numbers.  It was already written out of academic curiosity.  Those interested can not hurry to look under the spoiler and try to implement this themselves.  The variant without conditional jumps works about three times faster than the standard <i>__max ()</i> macro (when executed on i7).  Good luck in optimizing your programs! <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numbers[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = b; numbers[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = a; numbers[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = a; numbers[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign_a = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)a&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign_b = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)b&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign_ab = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)(a^b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> abs_a = (<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*sign_a)*a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> abs_b = (<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*sign_b)*b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sign_a_b = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)(abs_a-abs_b)&gt;&gt;<span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = sign_ab; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = ((<span class="hljs-number"><span class="hljs-number">1</span></span>^(sign_a_b)^(sign_a | sign_b)) &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>^c0)) | (sign_ab &amp; sign_a); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = numbers[c0][c1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><br> <i><a name="upd"></a></i>  <i>* UPD.</i>  <i>In the <a href="http://habrahabr.ru/post/180085/">comments,</a> user <a href="http://habrahabr.ru/users/shodan/" class="user_link">shodan</a> gave an example in which rand () is removed from the counting time, and data is read from a pre-formed array.</i>  <i>In this case, the performance gain is approximately threefold.</i>  <i>Apparently, this is due to the more efficient operation of the conveyor when reading data from an array.</i> </div><p>Source: <a href="https://habr.com/ru/post/180085/">https://habr.com/ru/post/180085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../180067/index.html">ImageControl with ProgressRing display for Win 8 / RT</a></li>
<li><a href="../180071/index.html">rake setup: Environment configuration for running a project on Ruby on Rails</a></li>
<li><a href="../180073/index.html">Video clip for David Bowie's song, shot onboard the ISS, became a Youtube hit</a></li>
<li><a href="../180077/index.html">Real Estate Search Engine Interface</a></li>
<li><a href="../180083/index.html">Search on Drupal 7 using Apache Solr Part 4 - faceted filters</a></li>
<li><a href="../180087/index.html">Echoes of the past - getting data from framework database 3</a></li>
<li><a href="../180097/index.html">Wasted Dreams - the story of a forgotten game (pilot article from the series "The History of the Game Industry")</a></li>
<li><a href="../180099/index.html">Corporation good in shock</a></li>
<li><a href="../180107/index.html">Humble Bundle can now pay Bitcoin</a></li>
<li><a href="../180111/index.html">Six weeks before Google Reader closes - we save everything we can</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>