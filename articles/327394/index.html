<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Where did unreliable tests go to Google</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If the tests fail on the previously tested code, then this is a clear sign that some new error has appeared in the code. Previously, the tests were su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Where did unreliable tests go to Google</h1><div class="post__text post__text-html js-mediator-article">  If the tests fail on the previously tested code, then this is a clear sign that some new error has appeared in the code.  Previously, the tests were successful and the code was correct, now the tests fail and the code does not work correctly.  The goal of a good test suite is to make this signal as clear and clearly addressed as possible. <br><br>  Unreliable (flaky), that is, non-deterministic tests behave differently.  They can show both positive and negative results on the same code.  In other words, a test failure may or may not mean the appearance of a new problem.  And an attempt to reproduce the error by restarting the test on the same version of the code may or may not lead to a successful pass of the test.  We regard such tests as unreliable, and in the end they lose their value.  If the initial problem is non-determinism in the working code, then ignoring the test means ignoring the bug in production. <br><br><h3>  Unreliable tests in Google </h3><br>  In the continuous integration of Google runs about 4.2 million tests.  Of these, about 63 thousand show an unpredictable result during the week.  Although they represent less than 2% of all tests, they still bear a serious burden on our engineers. <br><a name="habracut"></a><br>  If we want to fix unreliable tests (and avoid writing new ones), then first of all we need to understand them.  We at Google collect a lot of data for our tests: runtime, test types, execution flags, and consumed resources.  I studied how some of these data correlate with the reliability of the tests.  I think this study can help us improve and make more stable testing methods.  In the overwhelming majority of cases, the larger the test (in terms of the size of the binaries, the use of RAM, or the number of libraries), the less reliable it is.  The rest of the article will discuss some of the patterns found. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a previous discussion of unreliable tests, see John Mikko's <a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html">article</a> from May 2016. <br><br><h3>  Test size - big tests are less reliable. </h3><br>  We divided the tests into three groups by size: small, medium and large.  Each test has a size, but the choice of label is subjective.  The engineer determines the size when he initially writes the test, and the size is not always updated when the test changes.  For some tests, this label no longer corresponds to reality.  However, she has some predictive value.  During the week, 0.5% of our small tests showed a non-deterministic property, 1.6% of average tests and 14% of large tests <sup>[1]</sup> .  There is a clear decrease in reliability from small to medium tests and from medium to large tests.  But it still leaves many questions open.  Little can be understood, given only the size. <br><br><h3>  The more test, the less reliability </h3><br>  We collect some objective assessments: the binary size of the test and the amount of RAM used during the test <sup>[2]</sup> .  For these two metrics, I grouped tests into two groups of equal size <sup>[3]</sup> and calculated the percentage of unreliable tests in each group.  The numbers below are the r2 values ‚Äã‚Äãfor the best linear objective prediction <sup>[4]</sup> . <br><br><table cellpadding="3" width="500"><tbody><tr><td colspan="2" width="500">  Correlation between metric and test unreliability prediction </td></tr><tr><td>  Metrics </td><td width="300">  r2 </td></tr><tr><td>  Binary size </td><td>  0.82 </td></tr><tr><td>  Used RAM </td><td>  0.76 </td></tr></tbody></table><br>  The tests considered here are mostly leak-proof tests that give a success / failure signal.  Binary size and RAM usage correlated well across the entire sample of tests, and there is not much difference between them.  So it's not just that big tests are more likely to be unreliable, but about a gradual decrease in reliability with an increase in the test. <br><br>  Below, I compiled graphs with these two metrics for the entire test suite.  Unreliability increases with increasing binary size <sup>[5]</sup> , but we also observe an increase in the difference <sup>[6]</sup> in the linear objective prediction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/7d9/576/7947d9576af57ac204ab484a077d65b5.png"><br><br>  The graph of the use of RAM below is moving more clearly and begins to show large differences only between the first and second vertical lines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/002/d6c/3be/002d6c3be07f1d7eca8c618d4b51c91a.png"><br><br>  Although the sizes of the groups are constant, the number of tests in each of them is different.  The points on the right of the graph with large differences correspond to groups that contain much fewer tests than the groups on the left.  If you take less than 96% of the tests (which end right behind the first vertical bar) and then reduce the size of the groups, you get a much stronger correlation (r2 equals 0.94).  This probably means that RAM and binary size have much more predictive power than shown in the general graphs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/781/aee/8d8/781aee8d8022863955f926e6108cfdd4.png"><br><br><h3>  Certain tools correlate with the frequency of unreliable tests. </h3><br>  Some tools blame the fact that they are the cause of unreliable tests.  For example, <a href="http://www.seleniumhq.org/projects/webdriver/">WebDriver</a> tests (whether written in Java, Python, or JavaScript) have the reputation of being unreliable <sup>[7]</sup> .  For some of our usual test tools, I calculated the proportion of unreliable tests written with this tool.  It should be noted that all of these tools are more often used to create larger tests.  This is not an exhaustive list of testing tools, and it covers about a third of all tests.  In the remaining tests, less known tools are used or the tool cannot be defined there. <br><br><table><tbody><tr><td colspan="3">  Unreliability of tests when using some of our usual test tools </td></tr><tr><td width="300">  Category </td><td width="150">  Share of unreliable </td><td width="150">  Share all unreliable tests </td></tr><tr><td>  All tests </td><td>  1.65% </td><td>  100% </td></tr><tr><td>  Java webdriver </td><td>  10.45% </td><td>  20.3% </td></tr><tr><td>  Python WebDriver </td><td>  18.72% </td><td>  4.0% </td></tr><tr><td>  Internal integration tool </td><td>  14.94% </td><td>  10.6% </td></tr><tr><td>  Android emulator </td><td>  25.46% </td><td>  11.9% </td></tr></tbody></table><br>  All these tools show a percentage of unreliability above average.  And given that every fifth unreliable test is written in Java WebDriver, it becomes clear why people complain about it.  But correlation does not mean causality.  Knowing the results from the previous section, we can assume that some other factor reduces the reliability of tests, and not just a tool. <br><br><h3>  Size gives a better forecast than tools. </h3><br>  You can combine the choice of tool and the size of the test - and see what is more important.  For each tool I mentioned, I isolated the tests that use this tool and divided them into groups according to memory usage (RAM) and binary size, according to the same principle as before.  Then he calculated the line of the best objective forecast and how it correlates with the data (r2).  Then I calculated the prediction of the probability that the test would be unreliable in the smallest group <sup>[8]</sup> (which already covers 48% of our tests), as well as the 90th and 95th percentile of RAM usage. <br><br><table><tbody><tr><td colspan="5">  Predicted probability of unreliability by <b>RAM</b> and <b>tool</b> </td></tr><tr><td>  Category </td><td width="40">  r2 </td><td width="127">  Smallest group (48th percentile) </td><td width="127">  90th percentile </td><td width="130">  95th percentile </td></tr><tr><td>  All tests </td><td>  0.76 </td><td>  1.5% </td><td>  5.3% </td><td>  9.2% </td></tr><tr><td>  Java webdriver </td><td>  0.70 </td><td>  2.6% </td><td>  6.8% </td><td>  eleven% </td></tr><tr><td>  Python WebDriver </td><td>  0.65 </td><td>  ‚àí2.0% </td><td>  2.4% </td><td>  6.8% </td></tr><tr><td>  Internal integration tool </td><td>  0.80 </td><td>  ‚àí1.9% </td><td>  3.1% </td><td>  8.1% </td></tr><tr><td>  Android emulator </td><td>  0.45 </td><td>  7.1% </td><td>  12% </td><td>  17% </td></tr></tbody></table><br>  This table shows the results of calculations for RAM.  Correlation is stronger for all tools except the Android emulator.  If you ignore the emulator, the difference in the correlation between the tools with similar use of RAM will be around 4-5%.  The difference between the smallest test and the 95th percentile is 8-10%.  This is one of the most useful conclusions of our research: the tools have some effect, but the use of RAM gives much greater deviations in reliability. <br><br><table><tbody><tr><td colspan="5">  Predicted probability of unreliability by <b>binary size</b> and <b>tool</b> </td></tr><tr><td>  Category </td><td width="40">  r2 </td><td width="170">  Smallest group (33rd percentile) </td><td width="127">  90th percentile </td><td width="127">  95th percentile </td></tr><tr><td>  All tests </td><td>  0.82 </td><td>  ‚àí4.4% </td><td>  4.5% </td><td>  9.0% </td></tr><tr><td>  Java webdriver </td><td>  0.81 </td><td>  ‚àí0.7% </td><td>  14% </td><td>  21% </td></tr><tr><td>  Python WebDriver </td><td>  0.61 </td><td>  ‚àí0.9% </td><td>  eleven% </td><td>  17% </td></tr><tr><td>  Internal integration tool </td><td>  0.80 </td><td>  ‚àí1.8% </td><td>  ten% </td><td>  17% </td></tr><tr><td>  Android emulator </td><td>  0.05 </td><td>  18% </td><td>  23% </td><td>  25% </td></tr></tbody></table><br>  For tests in the Android emulator, there is practically no correlation between the binary size and unreliability.  For other tools, you can see a large difference in prediction of unreliability between small and large tests for RAM consumption;  up to 12 percentage points.  But at the same time, when comparing tests on a binary size, the difference in the prediction of unreliability is even greater: up to 22 percentage points.  This is similar to what we saw when analyzing the use of RAM, and this is another important conclusion of our study: the binary size is more important for deviations in the prediction of unreliability than the tool used. <br><br><h3>  findings </h3><br>  The size of the test chosen by the developer correlates with unreliability, but Google doesn‚Äôt have enough size options for this parameter to be really useful for forecasting. <br><br>  Objectively measured indicators of binary size and RAM usage correlate strongly with the reliability of the test.  This is a continuous, not step function.  The latter would show unexpected jumps and would mean that at these points we move from one type of test to another (for example, from unit tests to system tests or from system tests to integration tests). <br><br>  Tests written with the help of certain tools often give unpredictable results.  But this can mainly be explained by the larger size of these tests.  The tools themselves make a small contribution to this difference in reliability. <br><br>  Care should be taken when writing a large test.  Think about what code you are testing and what the minimum test for this will look like.  And you need to be very careful writing big tests.  Without additional protective measures, there is a high probability that you will make a test with a non-deterministic result, and such a test will have to be corrected. <br><br><h3>  Notes </h3><br><ol>
<li>  The test was considered unreliable if it showed at least one unreliable result during the week. </li><li>  I also took into account the number of libraries created for the test.  In the 1% sample rate, the binary size (0.39%) and the use of RAM (0.34%) show stronger correlations than the number of libraries (0.27).  Further I investigated only the binary size and use of RAM. </li><li>  Approximately 100 groups for each metric. </li><li>  r2 measures how closely the best prediction line matches the data.  The value 1 means that the line completely coincides with the data. </li><li>  There are two interesting areas on the graphs, where the points in reality show a reverse trend towards a general upward trend.  One begins about halfway to the first vertical line and continues for two data points, and the second begins right before the first vertical line, and ends immediately after it.  Here, the sample size is large enough, so it is unlikely to be just random noise.  Around these points are bunches of tests that are more or less unreliable than can be expected based on only the binary size.  This is a prospect for future research. </li><li>  The distance between the observed point and the objective forecast line. </li><li>  Other web-testing tools are also blamed, but we most often use WebDriver. </li><li>  Some of the predicted percentages of unreliability for the smallest groups were negative.  Although in reality there can be no negative part of the tests, but this is a possible result when using this type of prediction. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/327394/">https://habr.com/ru/post/327394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327380/index.html">Why Apache Ignite is a good microservice platform</a></li>
<li><a href="../327384/index.html">Second webinar on SAP Cloud Platform: a detailed overview of services</a></li>
<li><a href="../327386/index.html">New Intel NUC 7th Generation - Review, Comparison, Testing</a></li>
<li><a href="../327388/index.html">Video about static code analysis</a></li>
<li><a href="../327390/index.html">Video of the reports of the conference AI & BigDataLab over the past three years</a></li>
<li><a href="../327396/index.html">Nvidia has published a report on the development and optimization of current GPUs and compared them with Google‚Äôs TPU</a></li>
<li><a href="../327398/index.html">New in 3CX V15.5: G.711 fax reception and updated Chrome 3CX Click-to-call extension</a></li>
<li><a href="../327400/index.html">C ++ Russia 2017 videos are available online.</a></li>
<li><a href="../327402/index.html">Do advertising on the Internet - quickly or correctly?</a></li>
<li><a href="../327404/index.html">Sending service messages to whatsapp via yowsup2 using http-get method, including Bacula backup server reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>