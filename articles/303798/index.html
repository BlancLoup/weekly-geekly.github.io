<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Core Data + Swift for the smallest: minimum necessary (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of the Core Data trilogy, the first is available here: Core Data + Swift for the smallest: the minimum necessary (part 1) . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Core Data + Swift for the smallest: minimum necessary (part 2)</h1><div class="post__text post__text-html js-mediator-article">  This is the second part of the Core Data trilogy, the first is available here: <a href="https://habrahabr.ru/post/303512/">Core Data + Swift for the smallest: the minimum necessary (part 1)</a> . <br><br>  In the first part, we introduced general information about Core Data, the main components (NSManagedObjectModel, NSPersistentStoreCoordinator, NSManagedObjectContext), the Data Model Editor, and created our data model. <br><br>  In this part we will work with objects, get acquainted with NSEntityDescription and NSManagedObject, autogeneration of classes, and also write an auxiliary class that significantly improves the usability of working with Core Data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  NSEntityDescription and NSManagedObject </h4><br>  Let's start with <b>NSEntityDescription</b> - as the name suggests, this is an object that contains a description of our entity.  Everything that we have imagined with an entity in the Data Model Editor (attributes, relationships, deletion rules, etc.) is contained in this object.  The only thing we will do with it is to receive it and pass it somewhere as a parameter, nothing else. <br><br>  <b>NSManagedObject</b> is the managed object itself, an entity instance.  Continuing the analogy with the DBMS (started in the last article), we can say that NSManagedObject is a record (row) in a database table. <br><br>  To understand how to work with this, let's create a new customer.  Since we do not yet have a ready-made interface part (we will deal with this in the next article), then let's program a little directly in the application delegate module ( <code><b>AppDelegate.swift</b></code> ).  Do not worry, this is only a demonstration that is important for understanding, a little later we will move everything from here to another place.  I will use to demonstrate the following function: <br><br><pre> <code class="objectivec hljs">func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//      // ‚Ä¶ return true }</span></span></code> </pre><br>  Creating a managed object (in this case, the Customer) is as follows: <br><br><pre> <code class="objectivec hljs">func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//   let entityDescription = NSEntityDescription.entityForName("Customer", inManagedObjectContext: self.managedObjectContext) //    let managedObject = NSManagedObject(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext) return true }</span></span></code> </pre><br>  First we get a description of the entity ( <b>entityDescription</b> ) by passing to the appropriate constructor a string with the name of the entity we need and a link to the context.  How it works: the managed object context, as we remember from the first part, is associated with the coordinator of the persistent storage, and the coordinator, in turn, is associated with the object data model, where the entity will be searched by the specified name.  Note that this function returns an optional value. <br><br>  Then, based on the obtained description of the entity, we create the managed object itself ( <b>managedObject</b> ).  The second parameter is the context in which this object should be created (in general, as you remember, there can be several contexts). <br><br>  Well, we created an object, how do we set its attribute values ‚Äã‚Äãnow?  For this, the <b>Key-Value</b> coding is used, the essence of which is that there are two universal methods, one that sets the specified value by the specified name, and the second retrieves the value by the specified name.  It sounds much harder than it looks. <br><br><pre> <code class="objectivec hljs"> func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//   let entityDescription = NSEntityDescription.entityForName("Customer", inManagedObjectContext: self.managedObjectContext) //    let managedObject = NSManagedObject(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext) //    managedObject.setValue(" ¬´¬ª", forKey: "name") //    let name = managedObject.valueForKey("name") print("name = \(name)") return true }</span></span></code> </pre><br>  Console output: <br><pre> <code class="bash hljs"> name = Optional( ¬´¬ª)</code> </pre><br>  As you can see, everything is quite simple.  Go ahead.  Now we need to save this object in our database.  Is the fact that we created an object is not enough?  No, any <u>object ‚Äúlives‚Äù in a particular specific context and only there</u> .  You can create, modify and even delete it there, but this will all happen within a specific context.  Unless you <b>explicitly</b> save all changes to the context, you will not change the real data.  You can draw an analogy with the file on the disk that you open for editing - until you clicked the "Save" button, no changes are recorded.  In fact, it is very convenient and great optimizes the whole process of working with data. <br><br>  Saving context changes is done elementarily: <br><pre> <code class="objectivec hljs"> managedObjectContext.save()</code> </pre><br>  We even have a ready-made function in the delegate module for more "smart" saving (we talked about it in passing in the last article), the recording occurs only if the data is really changed: <br><br><pre> <code class="objectivec hljs"> func saveContext () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> managedObjectContext.hasChanges { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try managedObjectContext.save() } catch { let nserror = error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(nserror), \(nserror.userInfo)"</span></span>) abort() } } }</code> </pre><br>  Thus, all the code for creating and writing an object will look like this: <br><br><pre> <code class="objectivec hljs"> func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//   let entityDescription = NSEntityDescription.entityForName("Customer", inManagedObjectContext: self.managedObjectContext) //    let managedObject = NSManagedObject(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext) //    managedObject.setValue(" ¬´¬ª", forKey: "name") //    let name = managedObject.valueForKey("name") print("name = \(name)") //   self.saveContext() return true }</span></span></code> </pre><br>  We created an object and wrote it into our database.  How do we get it back now?  It is not much more complicated.  Let's take a look at the code. <br><pre> <code class="objectivec hljs"> let fetchRequest = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>(entityName: <span class="hljs-string"><span class="hljs-string">"Customer"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { let results = try <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.managedObjectContext.executeFetchRequest(fetchRequest) } catch { print(error) }</code> </pre><br>  Here we create an object request <b>NSFetchRequest</b> , passing in the constructor as a parameter the name of the entity the data of which we want to receive.  Then we call the context method, passing this request as a parameter.  This is the easiest way to retrieve records; in general, NSFetchRequest is very flexible and provides ample opportunities to extract data under certain conditions.  We will consider an example of filtering and sorting data with its help in the next part of the article. <br><br>  Important note: the <b>managedObjectContext.executeFetchRequest</b> function always returns an <b>array of</b> objects, even if there is only one object ‚Äî an array will be returned, if there are no objects at all, an empty array. <br><br>  In view of the above, we will have the following function text: <br><pre> <code class="objectivec hljs"> func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//   let entityDescription = NSEntityDescription.entityForName("Customer", inManagedObjectContext: self.managedObjectContext) //    let managedObject = NSManagedObject(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext) //    managedObject.setValue(" ¬´¬ª", forKey: "name") //    let name = managedObject.valueForKey("name") print("name = \(name)") //   self.saveContext() //   let fetchRequest = NSFetchRequest(entityName: "Customer") do { let results = try self.managedObjectContext.executeFetchRequest(fetchRequest) for result in results as! [NSManagedObject] { print("name - \(result.valueForKey("name")!)") } } catch { print(error) } return true }</span></span></code> </pre><br>  Console output: <br><pre> <code class="bash hljs">name = Optional( ¬´¬ª) name -  ¬´¬ª name -  ¬´¬ª</code> </pre><br>  As soon as you receive an object, in the listing above, it is the <b>result</b> variable inside the loop, then you can edit it arbitrarily (there are no differences from setting attributes for a new object), or delete it.  Deletion is performed by calling the corresponding method of the context variable, to which the deleted object is passed as a parameter <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.managedObjectContext.deleteObject(result)</code> </pre><br>  After deletion, it is also necessary to force the saving of the context, do not forget about it. <br><br><div class="spoiler">  <b class="spoiler_title">Small optional supplement</b> <div class="spoiler_text">  If you want to ‚Äútouch‚Äù Core Data closer, at the table level, then this is easier than it might seem.  If you are using Simulator, then the database file is somewhere here: <br><pre> <code class="bash hljs">/Users/&lt;USER&gt;/Library/Developer/CoreSimulator/Devices/&lt;DEVICE_ID&gt;/data/Containers/Data/Application/&lt;APPLICATION_ID&gt;/Documents/&lt;FileName&gt;.sqlite</code> </pre><br>  Do not rush to look for this file manually, wondering what is the ID of your application.  There is a wonderful utility that does it all for you - <a href="https://github.com/dsmelov/simsim"><b>SimSim</b></a> (I take this opportunity to thank the authors). <br><br>  After launch, it hangs in the menu bar and looks like this (bat icon): <br><img src="https://habrastorage.org/files/627/93b/92f/62793b92f2414e0a916ed2e3f5dd17bd.png"><br><br>  Actually, the purpose is obvious: the utility shows a list of the repositories installed on the simulator of applications and allows you to go directly to them: <br><img src="https://habrastorage.org/files/ba0/7c3/d3f/ba07c3d3f05741c5853a31b14bc39352.png"><br><br>  To view the SQLite file itself, you can use any free browser, for example, <a href="https://itunes.apple.com/ru/app/datum-free/id901631046%3Fmt%3D12">Datum Free</a> <br><img src="https://habrastorage.org/files/e22/20f/32c/e2220f32c0e04f9383d385cca40a9a96.png"><br></div></div><br><h4>  Auto Generation Core Data Classes </h4><br>  The Key-Value method is good because it is simple, versatile and works out of the box.  But there are two points that spoil the impression: first, the code is more than we would like, and secondly, passing the name of the props each time as a string, it is easy to make a mistake (there is no auto-completion).  And how can we be if we want a bit more functionality from managed objects, for example, calculated fields or our own constructors?  Core Data has a solution!  We can easily create our own class (even more - Core Data will do it for us), inheriting it from <b>NSManagedObject</b> and adding everything we need.  As a result, we will be able to work with managed objects as with an ordinary OOP object, creating it by calling its constructor and accessing its fields ‚Äúthrough the point‚Äù using auto-completion (that is, all the power of the OOP is in your hands). <br><br>  Open the Data Model Editor and select any entity.  Select in the menu (it is context-sensitive, so you need to select an entity) <b>Editor \ Create NSManagedObject Subclass ...</b> <br><br><img src="https://habrastorage.org/files/24f/aae/6e0/24faae6e0a1d44d2bd3b742559b03e37.png"><br><br>  The data model selection window will open;  Yes, in general, there may be several independent data models, but we have one, so the choice is obvious. <br><img src="https://habrastorage.org/files/328/e82/bd1/328e82bd1f59465f8a7dd6bdecb30e47.png"><br><br>  In the next window, we are offered to choose entities for which we need to generate classes, let's select everything at once. <br><img src="https://habrastorage.org/files/ca4/52b/a3a/ca452ba3a9504302b5ef168a2f85f39a.png"><br><br>  The following standard window should be familiar to you, the only thing that can be alerted here is the option <b>"Use scalar properties for primitive data types"</b> .  What is the meaning of this option: if this option is not selected, then instead of primitive data types (Float, Double, Int, etc.) a kind of ‚Äúwrapper‚Äù will be used, containing the value inside it.  This is more relevant for <b>Objective-C</b> , since there is no such thing as <b>Optional</b> .  But we use <b>Swift</b> , so I see no reason not to choose this option (perhaps more experienced colleagues in the comments will correct me). <br><br><img src="https://habrastorage.org/files/87a/9ad/e70/87a9ade7040d424a878ddfaa3389a2f9.png"><br><br>  As a result, Core Data will create several files for us, let's see what these files are. <br><img src="https://habrastorage.org/files/e74/4fa/b23/e744fab23d634ab49223645c8c6d4322.png"><br><br>  Each entity is represented by a pair of files, for example: <br><ul><li>  <code><b>Customer.swift</b></code> - this file is for you, you can add any functionality you need there, which we will now do. </li><li>  <code><b>Customer+CoreDataProperties.swift</b></code> is a Core Data file, it‚Äôs better not to touch it and here‚Äôs why: this file contains a description of the attributes and relationships of your entity, that is, if you make changes to this part, then you have the entity and its representing class not will be agreed. </li></ul><br>  Also, if for some reason you decide to change the data model, then you can re-create these generated classes.  In this case, the first file ( <code><b>Customer.swift</b></code> ) will remain untouched, and the second ( <code><b>Customer+CoreDataProperties.swift</b></code> ) will be completely replaced by a new one. <br><br>  Well, we have created classes for our entities, now we can access the ‚Äúthrough point‚Äù class fields, let's give our example a more familiar look. <br><pre> <code class="objectivec hljs"> func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//   let entityDescription = NSEntityDescription.entityForName("Customer", inManagedObjectContext: self.managedObjectContext) //    let managedObject = Customer(entity: entityDescription!, insertIntoManagedObjectContext: self.managedObjectContext) //    managedObject.name = " ¬´¬ª" //    let name = managedObject.name print("name = \(name)") //   self.saveContext() //   let fetchRequest = NSFetchRequest(entityName: "Customer") do { let results = try self.managedObjectContext.executeFetchRequest(fetchRequest) for result in results as! [Customer] { print("name - \(result.name!)") } } catch { print(error) } return true }</span></span></code> </pre><br>  So much better.  But the creation of the object looks a bit heavy.  It would be possible to hide all this in the constructor, but for this we need a reference to the managed context in which the object should be created.  By the way, we are still writing code in the delegate module, since this is where we define the Core Data Stack.  Maybe you can think of something better? <br><br><h4>  Core data manager </h4><br>  The most common practice when working with Core Data is to use the <b>Singleton</b> pattern based on the Core Data Stack.  Let me remind you if someone does not know or has forgotten that Singleton guarantees the presence of only one instance of a class with a global access point.  That is, a class always has one and only one object, regardless of who, when and where it is accessed.  We will now implement this approach; we will have a Singleton for global access and management of the Core Data Stack. <br><br>  Create a new empty file named <b>CoreDataManager.swift</b> <br><br><img src="https://habrastorage.org/files/415/46f/7dd/41546f7ddd9245e2981dd5e913a32d61.png"><br><br><img src="https://habrastorage.org/files/87c/c06/260/87cc0626097441d2b19a21a29c685173.png"><br><br><img src="https://habrastorage.org/files/4d8/2d9/22d/4d82d922de4d4fbca12b8d7a26e7d791.png"><br><br>  First, let's add the Core Data import directive and create Singleton itself. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CoreData <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreDataManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Singleton static let instance = CoreDataManager() private init() {} }</span></span></code> </pre><br>  Now, let's move all the functions and definitions associated with Core Data from the application delegate module. <br><pre> <code class="objectivec hljs">import CoreData import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CoreDataManager { <span class="hljs-comment"><span class="hljs-comment">// Singleton static let instance = CoreDataManager() private init() {} // MARK: - Core Data stack lazy var applicationDocumentsDirectory: NSURL = { let urls = NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask) return urls[urls.count-1] }() lazy var managedObjectModel: NSManagedObjectModel = { let modelURL = NSBundle.mainBundle().URLForResource("core_data_habrahabr_swift", withExtension: "momd")! return NSManagedObjectModel(contentsOfURL: modelURL)! }() lazy var persistentStoreCoordinator: NSPersistentStoreCoordinator = { let coordinator = NSPersistentStoreCoordinator(managedObjectModel: self.managedObjectModel) let url = self.applicationDocumentsDirectory.URLByAppendingPathComponent("SingleViewCoreData.sqlite") var failureReason = "There was an error creating or loading the application's saved data." do { try coordinator.addPersistentStoreWithType(NSSQLiteStoreType, configuration: nil, URL: url, options: nil) } catch { var dict = [String: AnyObject]() dict[NSLocalizedDescriptionKey] = "Failed to initialize the application's saved data" dict[NSLocalizedFailureReasonErrorKey] = failureReason dict[NSUnderlyingErrorKey] = error as NSError let wrappedError = NSError(domain: "YOUR_ERROR_DOMAIN", code: 9999, userInfo: dict) NSLog("Unresolved error \(wrappedError), \(wrappedError.userInfo)") abort() } return coordinator }() lazy var managedObjectContext: NSManagedObjectContext = { let coordinator = self.persistentStoreCoordinator var managedObjectContext = NSManagedObjectContext(concurrencyType: .MainQueueConcurrencyType) managedObjectContext.persistentStoreCoordinator = coordinator return managedObjectContext }() // MARK: - Core Data Saving support func saveContext () { if managedObjectContext.hasChanges { do { try managedObjectContext.save() } catch { let nserror = error as NSError NSLog("Unresolved error \(nserror), \(nserror.userInfo)") abort() } } } }</span></span></code> </pre><br><br>  Now we have a Singleton and we can access the Core Data Stack from anywhere in our application.  For example, accessing a managed context would look like this: <br><pre> <code class="objectivec hljs">CoreDataManager.instance.managedObjectContext</code> </pre><br>  Let's now transfer everything needed to create a managed object into its constructor. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Customer.swift // core-data-habrahabr-swift import Foundation import CoreData class Customer: NSManagedObject { convenience init() { //   let entity = NSEntityDescription.entityForName("Customer", inManagedObjectContext: CoreDataManager.instance.managedObjectContext) //    self.init(entity: entity!, insertIntoManagedObjectContext: CoreDataManager.instance.managedObjectContext) } }</span></span></code> </pre><br>  Let's go back to the application delegate module and make a few changes.  Firstly, the creation of a managed object is simplified here to one line (calling a new constructor of our class), and secondly, such a link to the managed context <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.managedObjectContext</code> </pre><br>  need to replace the next <br><br><pre> <code class="objectivec hljs">CoreDataManager.instance.managedObjectContext</code> </pre><br><br>  Now the code will look quite familiar, and work with managed objects will differ little from ordinary OOP objects. <br><pre> <code class="objectivec hljs">func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: [<span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>: AnyObject]?) -&gt; Bool { <span class="hljs-comment"><span class="hljs-comment">//    let managedObject = Customer() //    managedObject.name = " ¬´¬ª" //    let name = managedObject.name print("name = \(name)") //   CoreDataManager.instance.saveContext() //   let fetchRequest = NSFetchRequest(entityName: "Customer") do { let results = try CoreDataManager.instance.managedObjectContext.executeFetchRequest(fetchRequest) for result in results as! [Customer] { print("name - \(result.name!)") } } catch { print(error) } return true }</span></span></code> </pre><br>  Not bad, is it?  All we have to do is create similar constructors for the rest of our entities.  But first, let's make another improvement in order to reduce the amount of code - we move the function that returns the entity description to <b><code>CoreDataManager</code></b> . <br><br>  Let's go back to the <b><code>CoreDataManager.swift</code></b> module and add the <b><code>entityForName</code></b> function. <br><pre> <code class="objectivec hljs">import CoreData import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CoreDataManager { <span class="hljs-comment"><span class="hljs-comment">// Singleton static let instance = CoreDataManager() private init() {} // Entity for Name func entityForName(entityName: String) -&gt; NSEntityDescription { return NSEntityDescription.entityForName(entityName, inManagedObjectContext: self.managedObjectContext)! }</span></span></code> </pre><br>  Now let's go back to the <b><code>Customer.swift</code></b> module and change the code in the following way. <br><pre> <code class="objectivec hljs">import Foundation import CoreData <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Customer: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> { convenience init() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init(entity: CoreDataManager.instance.entityForName(<span class="hljs-string"><span class="hljs-string">"Customer"</span></span>), insertIntoManagedObjectContext: CoreDataManager.instance.managedObjectContext) } }</code> </pre><br>  Now everything is exactly, duplication of the code is minimized.  Let's create similar constructors for other entities.  I will give only one for an example, it is simple and should not cause any difficulties (absolutely everything is the same, except for the name of the entity). <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Order.swift // core-data-habrahabr-swift import Foundation import CoreData class Order: NSManagedObject { convenience init() { self.init(entity: CoreDataManager.instance.entityForName("Order"), insertIntoManagedObjectContext: CoreDataManager.instance.managedObjectContext) } }</span></span></code> </pre><br><br><h4>  Instead of conclusion </h4><br>  Note that the <b>CoreDataManager</b> that we created is fairly versatile, in the sense that it can be used in any application based on Core Data.  The only thing that connects it with our project is the name of the data model file.  Nothing else.  That is, having written this module once, you can use it constantly in different projects. <br><br>  In the <a href="https://habrahabr.ru/post/304586/">next, final part</a> , we will work a lot with the <b><code>Storyboard</code></b> and the <b><code>UITableViewController</code></b> , become familiar with <b><code>NSFetchedResultsController</code></b> and once again recall <b><code>NSFetchRequest</code></b> . <br><br>  <a href="">This project is on github</a> </div><p>Source: <a href="https://habr.com/ru/post/303798/">https://habr.com/ru/post/303798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303786/index.html">Coding standards and other IT practices</a></li>
<li><a href="../303788/index.html">Hardcore startups. Part 1: How to make your dream come true</a></li>
<li><a href="../303790/index.html">IoT: from smart bulbs to advanced production technologies</a></li>
<li><a href="../303794/index.html">The implementation of interactive diagrams using OOP on the example of the prototype editor of UML diagrams. Part 1</a></li>
<li><a href="../303796/index.html">Dell Storage SC9000: Intelligent Storage for Efficient Data Center</a></li>
<li><a href="../303800/index.html">The implementation of interactive diagrams using OOP on the example of the prototype editor of UML diagrams. Part 2</a></li>
<li><a href="../303802/index.html">Big Data Brain</a></li>
<li><a href="../303804/index.html">The ‚ÄúMake with Ada‚Äù competition for developers of embedded systems has begun.</a></li>
<li><a href="../303806/index.html">Harvard CS50 Programming Course Now in Russian</a></li>
<li><a href="../303814/index.html">Launch Xamarin.Forms on Windows 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>