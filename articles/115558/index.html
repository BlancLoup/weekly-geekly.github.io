<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Redirection of functions in Mach-O libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a previous article , the call pickup method for shared ELF libraries was described. And now we will look at how to do the same with the Mach-O libr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Redirection of functions in Mach-O libraries</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage/e05efef3/d9c24989/b691c991/a08b7a4d.png">  In a <a href="http://habrahabr.ru/blogs/development/106107/">previous article</a> , the call pickup method for shared <a href="http://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> libraries was described.  And now we will look at how to do the same with the <a href="http://en.wikipedia.org/wiki/Mach-O">Mach-O</a> libraries. <br><br>  Briefly recall the situation.  We have a program for Mac OS X, which uses many third-party dynamically-composable libraries, which, in turn, also use each other's functions. <br><br>  The task is as follows: intercept the call of a function from one library to another, and in the handler call the original. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As usual, the impatient can all <a href="">download</a> and try right now. <br><a name="habracut"></a><br>  For clarity, an imaginary example: we have a program called ‚Äútest‚Äù in the C language (file test.c) and a shared library (file libtest.c), with constant content, compiled in advance.  This library provides one function: libtest ().  In their implementation, each of them uses the puts () function from the standard C language library (supplied with Mac OS, contained in libSystem.B.dylib).  Let's look at a schematic representation of the described situation: <br><img src="https://habrastorage.org/storage/3de56165/bb038d82/f90a7552/2e63b600.jpg"><br>  The task is as follows: <br><ol><li>  It is necessary to replace the call of the puts () function for libtest.dylib with the call of the hooked_puts () function implemented in the main program (file test.c), which, in turn, can use the original has (); <br><img src="https://habrastorage.org/storage/0945ab20/bdafd936/1d201753/9c0982bf.jpg"></li><li>  Cancel the changes made, that is, make the repeated call to libtest () result in a call to the original puts (). <br><img src="https://habrastorage.org/storage/743c0a52/101bd7e5/1f7bfeca/3af0895f.jpg"></li></ol>  In this case, changing the code or recompiling the libraries themselves is not allowed, only the main program.  Call forwarding itself should be carried out only for a specific library and on the fly, without restarting the program. <br><br><h3>  <b>Mach-O in brief</b> </h3><br>  The best way to understand Mach-O is to look at the image below. <br><img src="https://habrastorage.org/storage/b63fe092/9b97adbf/9586465e/4edb3195.jpg"><br>  It seems that humanity has not yet managed to portray its structure more clearly.  In the first approximation, it looks like this: <br><ol><li>  Title - information about the target architecture and various options for further interpretation of the file contents are stored here. </li><li>  Load commands - tell you how and where to load Mach-O parts: segments (see below), symbol tables, and also - which libraries this file depends on in order to load them first </li><li>  Segments - describe the regions of memory where to load sections with code or data. </li></ol><h5>  Parser Utilities </h5><br>  For the second approximation you'll have to get acquainted with some utilities: <br><ul><li>  <a href="http://developer.apple.com/library/mac/">otool</a> - is a console program that comes with the system.  It is capable of displaying the contents of various parts of a file: headers, load commands, segments, sections, and so on.  It is especially useful to add the -v (verbose) switch when calling. </li><li>  <a href="http://sourceforge.net/projects/machoview/">MachOView</a> - distributed under the GPL, has a GUI, works only on Mac OS 10.6 and higher.  Allows you to view the full content of Mach-O, complements the information on some sections, based on data from other parts, which is very convenient. </li></ul> <a href=""><img src="https://habrastorage.org/storage/44fe040d/4d88535f/b5a7285e/e9dd7dae.png"></a> <br><br>  By and large, in order for an ordinary user to deal with Mach-O, it‚Äôs enough to play with MachOView on various examples.  But this is not enough for Mach-O programming, since the exact structures of the headers, load commands, segments, sections, symbol tables and the exact description of their fields are unknown.  But, it is not a big problem, if there is a specification.  And it is always <a href="http://developer.apple.com/library/mac/">available</a> on the official Apple website.  And if you have installed development tools, you can look at the header files from / usr / include / mach-o (especially loader.h). <br><br>  In addition, it is worth remembering that, although the contents of the file are located in memory in exactly the same order as it is on the disk, but at boot time the linker can delete some parts of the symbol table, the entire table of rows and put down the values ‚Äã‚Äãof real memory offsets where necessary, while in the file, these values ‚Äã‚Äãcan generally be set to zero or correspond to the offset on the disk. <br><br>  The header structure is simple (for a 32-bit architecture, the 64-bit architecture is not much different): <br><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mach_header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> magic; <span class="hljs-keyword"><span class="hljs-keyword">cpu_type_t</span></span> cputype; <span class="hljs-keyword"><span class="hljs-keyword">cpu_subtype_t</span></span> cpusubtype; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> filetype; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ncmds; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sizeofcmds; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> flags; };</code> </pre> <br>  Everything starts with a magical value (0xFEEDFACE or vice versa, depending on the agreement regarding the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">order of bytes</a> in machine words).  It then indicates the type of processor architecture, the number and size of boot commands, and flags describing other features. <br><br>  For example: <br><img src="https://habrastorage.org/storage/ece5d559/2bf7c983/908fd4b8/84aa62a7.png"><br><br>  The essential download commands are listed below: <br><ul><li>  LC_SEGMENT - contains various information about a certain segment: size, number of sections, offset in the file and, after loading, in memory </li><li>  LC_SYMTAB - loads character table and strings </li><li>  LC_DYSYMTAB - creates an import table, character data is taken from the symbol table </li><li>  LC_LOAD_DYLIB - indicates dependency on some third-party library. </li></ul>  For example (32-bit and 64-bit versions, respectively): <br><table><tbody><tr><td><img src="https://habrastorage.org/storage/a16f7b60/df32c156/d09207a4/66a974d1.png"></td><td><img src="https://habrastorage.org/storage/80ec4cd3/3e63bcc8/e68f2488/d53b1390.png"></td></tr></tbody></table><br>  The most important segments are as follows: <br><ul><li>  __TEXT - executable code and other read-only data </li><li>  __DATA - data available for writing;  including import tables that tend to be changed by the dynamic loader during late binding </li><li>  __OBJC - various information of the standard runtime Objective-C language library </li><li>  __IMPORT - import table exclusively for 32-bit architecture (I only generated on Mac OS 10.5) </li><li>  __LINKEDIT - here the dynamic loader places its data for already loaded modules: character tables, strings, etc. </li></ul>  Any download command starts with the following fields: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">load_command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cmd; <span class="hljs-comment"><span class="hljs-comment">//   uint32_t cmdsize; //     };</span></span></code> </pre><br>  After which there may be many more different fields, depending on the type of team. <br><br>  For example: <br><img src="https://habrastorage.org/storage/8a32634c/643f470a/a800c878/3792a031.png"><br><br>  The most interesting sections in these segments are: <br><ul><li>  __TEXT, __ text - the actual code </li><li>  __TEXT, __ cstring - constant strings (in double quotes) </li><li>  __TEXT, __ const - various constants </li><li>  __DATA, __ data - initialized variables (strings and arrays) </li><li>  __DATA, __ la_symbol_ptr - a table of pointers to imported functions </li><li>  __DATA, __ bss - uninitialized static variables </li><li>  __IMPORT, __ jump_table - stubs for calls to imported functions </li></ul>  Looking ahead, I‚Äôll note that in a single Mach-O, the import table can be either __IMPORT, __ jump_table (32 bits, Mac OS 10.5), or __DATA, __ la_symbol_ptr (64 bits, or Mac OS 10.6 and later). <br><br>  Sections in the segments have the following structure: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> sectname[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> segname[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> align; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> reloff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nreloc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> flags; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> reserved1; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> reserved2; };</code> </pre><br>  We have the name of the segment and the section itself, the size, the offset in the file and the address in memory for which the dynamic loader has placed it.  In addition, there is another, section-specific information. <br><br>  For example: <br><img src="https://habrastorage.org/storage/aced305d/8ee6c518/7181f4db/c3c30f37.png"><br><br><h3>  <b>Fat binary</b> </h3><br>  Of course, it is worth mentioning that, as a result of Apple's repeated smooth change of its target architectures (Motorola -&gt; IBM -&gt; Intel), executable files and libraries ‚Äúlearned‚Äù to store several versions of executable code at once.  In general, such files are called <a href="http://en.wikipedia.org/wiki/Fat_binary">fat binary</a> .  In fact, these are several Mach-O, collected in one file, but its title is special.  It contains information on the number and type of supported architectures and the offset to each of them.  At this offset are the usual Mach-O with the structure described above. <br><br>  Here‚Äôs what it looks like in C: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fat_header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> magic; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nfat_arch; };</code> </pre><br>  Where under magic lies 0xCAFEBABE (or vice versa - we remember about the different order of bytes in machine words on different processors).  And after, immediately follows exactly nfat_arch type structures: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fat_arch</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cpu_type_t</span></span> cputype; <span class="hljs-keyword"><span class="hljs-keyword">cpu_subtype_t</span></span> cpusubtype; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> align; };</code> </pre><br>  Actually, the field names speak for themselves: the type of processor, the offset in the file of a particular Mach-O, the size and alignment. <br><br><h3>  <b>Experimental program</b> </h3><br>  To study the work of a call to an imported function, we take the following files in C: <br><br><h6>  File test.c </h6><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> libtest(); //<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libtest.dylib <span class="hljs-type"><span class="hljs-type">int</span></span> main() { libtest(); //calls puts() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> libSystem.B.dylib <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br><h6>  File libtest.c </h6><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta">#include &lt;stdio.h&gt; void libtest() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//just a simple library function { puts("libtest: calls the original puts()"); }</span></span></span></span></code> </pre><br><h3>  <b>Explore dynamic layout</b> </h3><br>  We confine ourselves to Intel processors.  Let us have Mac OS 10.5.  Add these files to the new Xcode project, compile it (32-bit version) and launch it in debug mode, stopping at the line where the function lib (() libtest.dylib function calls the puts () function.  Here is the assembler listing for libtest (): <br><br> <a href=""><img src="https://habrastorage.org/storage/7dd4d641/3655ddd1/677b7691/edf63e1b.png"></a> <br><br>  Perform another instruction: <br><br> <a href=""><img src="https://habrastorage.org/storage/9f89d435/857571b3/57b0ab34/130def0b.png"></a> <br><br>  And look at her in memory: <br><br><img src="https://habrastorage.org/storage/cc471e9d/b8ea1df0/dd0fa4ac/29a6f9f3.png"><br><br>  This is the cell of the import table (in this case, the __IMPORT cell, __jump_table), which serves as a springboard for calling the dynamic loader (__dyld_stub_binding_helper_interface function) if late binding (lazy binding) is used, or jumps directly to the objective function.  This is confirmed by a subsequent call to puts (): <br><br> <a href=""><img src="https://habrastorage.org/storage/9f89d435/857571b3/57b0ab34/130def0b.png"></a> <br><br>  And in memory: <br><br><img src="https://habrastorage.org/storage/8c38df38/b31f274f/be7e6834/5335b7bd.png"><br><br>  So, we see that the dynamic loader has replaced the indirect call instruction CALL (0xE8) with the indirect jump instruction JMP (0xE9).  Therefore, to redirect the __jump_table elements, it will be enough for us to write instead of their initial content an instruction for indirectly switching to the beginning of the substitution function. <br><br>  Another interesting point.  Why is JMP not used to go to the dynamic bootloader (also known as linker)?  Because CALL, which stores the return address on the stack, will help the linker to determine which element of the import table has caused it.  And, therefore, calculate what it was for the symbol and resolve it by changing the CALL to itself for an indirect JMP for the required function. <br><br>  Now let's move the project to Mac OS 10.6 and compile the fat binary for 32-bit and 64-bit architectures.  Just in case, in Xcode you can do it like this: <br><br><img src="https://habrastorage.org/storage/871e546e/ffc6db7d/ee00df31/f52f01c7.png"><br><br>  We compile, run the 64-bit version (just for example; the import table on Snow Leopard will be the same for 32-bit) and stops again at the call to ((): <br><br> <a href=""><img src="https://habrastorage.org/storage/013565ef/346424ce/e6770080/f22611b2.png"></a> <br><br>  And again simple CALL.  Look further: <br><br> <a href=""><img src="https://habrastorage.org/storage/ca3cc5f7/50d59a50/42aff21e/b8c69bbd.png"></a> <br><br>  Here there is already a noticeable difference with the usual __IMPORT, __jump_table. <br><br>  Welcome to __TEXT, __symbol_stub1.  This table is a set of JMP instructions for each function being imported.  In our case, there is only one such instruction presented above.  Each such instruction jumps to the address specified in the corresponding cell of the __DATA table, __la_symbol_ptr.  The latter is the import table for this Mach-O. <br><br>  But let's continue the research.  If you look at the address to which the transition is going to occur: <br><br><img src="https://habrastorage.org/storage/1d07c7f3/d9c06e1d/6e15e485/94b62afb.png"><br><br>  Then we will see the following: <br><br> <a href=""><img src="https://habrastorage.org/storage/c52c90b0/62758452/fb2b3cd4/90a23908.png"></a> <br><br>  We fall into the section __TEXT, __stub_helper.  In essence, this is a PLT (Procedure Linkage Table) for Mach-O.  The first instruction (in this case, this is the LEA in conjunction with R11, and there could be a simple PUSH) dynamic linker remembers what character needs to be relocated, the second instruction always leads to the same address ‚Äî the beginning of the function __dyld_stub_binding_helper, which will bind : <br><br> <a href=""><img src="https://habrastorage.org/storage/9e83e224/44687069/37248899/06f7e13e.png"></a> <br><br>  After the dynamic linker performs the relocation for puts (), the corresponding cell in __DATA, __la_symbol_ptr will look like this: <br><br><img src="https://habrastorage.org/storage/0cedad0c/46e70cbc/d651f089/ee3fa95b.png"><br><br>  And this is already the address of the puts () function from the libSystem.B.dylib module.  That is, replacing it with some address, we get the desired effect of call forwarding. <br><br>  So.  At this stage, we used a concrete example to find out how dynamic linking takes place, what import tables there are in Mach-O and what elements they consist of.  Now we proceed to the analysis of Mach-O! <br><br><h3>  <b>Search item in import table</b> </h3><br>  It is necessary to find the corresponding cell in the import table by the symbol name.  The algorithm of this action is somewhat non-trivial. <br><br>  First, you need to find the character itself in the symbol table.  The latter is an array of the following structures: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nlist</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> n_strx; } n_un; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> n_type; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> n_sect; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> n_desc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> n_value; };</code> </pre><br>  Where n_un.n_strx is the offset in bytes from the beginning of the string table of the name of this character.  The rest concerns the type of character, the section in which it is located, and so on.  In short, here are some of its last elements for our experimental library libtest.dylib (32-bit version): <br><br><img src="https://habrastorage.org/storage/f8e91123/35172c81/9805062e/f1627078.png"><br><br>  The string table is a chain of names, each of which is terminated by zero.  However, it is worth noting that for each name the compiler adds an underscore "_" to the beginning, so for example the name "puts" will appear in the string table as "_puts". <br><br>  Here is an example: <br><img src="https://habrastorage.org/storage/d8280db3/170f6042/e4722788/6c302248.png"><br><br>  You can find the location of the symbol and string table from the corresponding load command (LC_SYMTAB): <br><br><img src="https://habrastorage.org/storage/44d6b0ab/0f6bf88a/c2319630/a2bec1dd.png"><br><br>  However, the symbol table is not uniform.  There are several sections in it.  One of them is especially interesting to us - these are undefined symbols, that is, those that are dynamically linked.  By the way, MachOView highlights any bluish background.  In order to determine which part of the symbol table reflects a subset of undefined symbols, you need to look into the dynamic character loading command (LC_DYSYMTAB): <br><br><img src="https://habrastorage.org/storage/4fe3cf6a/3299d2bc/72180cb7/6b15a7f0.png"><br><br>  Here is its presentation in C: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dysymtab_command</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cmd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cmdsize; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ilocalsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nlocalsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> iextdefsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nextdefsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> iundefsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nundefsym; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tocoff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ntoc; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> modtaboff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nmodtab; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> extrefsymoff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nextrefsyms; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> indirectsymoff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nindirectsyms; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> extreloff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nextrel; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> locreloff; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nlocrel; };</code> </pre>  Here dysymtab_command.iundefsym is the index in the symbol table, from which the subset of undefined symbols begins.  dysymtab_command.nundefsym - the number of undefined characters.  Since what we are looking for is a deliberately undefined symbol, then you only need to search for it in the symbol table in this subset. <br><br>  And now, a very important point: having found a symbol by its name, the most important thing for us is to remember its index in the symbol table from its beginning.  Because of the numerical values ‚Äã‚Äãof these indices is another important table - a table of indirect (indirect) characters.  You can find it by dysymtab_command.indirectsymoff, and the number of indices is determined by dysymtab_command.nindirectsyms. <br><br>  In our trivial case, this table consists of only one element (in real life there are much more): <br><br><img src="https://habrastorage.org/storage/68bd08f9/fd904e0a/ca8be2fb/7a9d25c5.png"><br><br>  And finally, let's look at the __IMPORT section, __jump_table, some element of which we need to find in the end.  She looks like this: <br><br><img src="https://habrastorage.org/storage/3ed79eb5/0d491193/8a788def/98a3a8ff.png"><br><br>  The section.reserved1 field for this section is very important (MachOView called it Indirect Sym Index).  It means the index in the table of indirect symbols, from which one-to-one correspondence begins with the __jump_table elements.  And we remember that the elements in the table of indirect symbols are indices in the symbol table.  Catch what I'm getting at? <br><br>  But, before finally gathering all the pieces of knowledge together, for completeness, we‚Äôll have a quick look at the situation in Snow Leopard, where __DATA, __la_symbol_ptr plays the role of the import table.  In fact, the differences are not very noticeable. <br><br>  Here is the character load command: <br><br><img src="https://habrastorage.org/storage/8a32634c/643f470a/a800c878/3792a031.png"><br><br>  And here are its last elements: <br><br><img src="https://habrastorage.org/storage/81f0be97/1274a167/ff519fa4/62221c49.png"><br><br>  Two undefined symbols are visible on the bluish background, which corresponds to the data from the dynamic symbol loading command (LC_DYSYMTAB): <br><br><img src="https://habrastorage.org/storage/30eca70c/48a61b64/8a86b1ab/fffdc423.png"><br><br>  Yes, and in the table of indirect symbols, there is no longer one element, but four: <br><br><img src="https://habrastorage.org/storage/d237e31b/0f8f45bc/98506254/87a90fd1.png"><br><br>  However, if you look at the reserved1 field of the cherished section __la_symbol_ptr, you can find that the one-to-one reflection of its elements on the table of indirect symbols starts not from the beginning of the last, but from the fourth element (the index is 3): <br><br><img src="https://habrastorage.org/storage/bde99cea/d347ce76/6fd22578/f0e2b644.png"><br><br>  The very contents of the import table, which the __la_symbol_ptr section describes, will be: <br><br><img src="https://habrastorage.org/storage/2b6284d4/57aee842/49c54518/d38c88d8.png"><br><br>  Having learned about all these intricacies of Mach-O, we can formulate an algorithm for finding the desired item in the import table. <br><br><h3>  <b>Redirection algorithm</b> </h3><br>  We describe all actions in words, since the code, despite the abundance of comments, may not be so clear: <ol><li>  We look for a table of characters and strings from the data from the LC_SYMTAB download command. </li><li>  We learn from the download command LC_DYSYMTAB with which element of the symbol table the subset of undefined symbols begins (iundefsym field). </li><li>  We are looking for a target symbol by name among a subset of undefined symbols in the symbol table. </li><li>  Remember the index of the target character from the beginning of the symbol table. </li><li>  We look for a table of indirect characters from the data from the LC_DYSYMTAB download command (field indirectsymoff). </li><li>  We recognize the index from which the mapping of the import table begins (the contents of the __DATA section, __la_symbol_ptr (or __IMPORT, __jump_table - there will be one thing)) on the indirect symbol table (reserved1 field). </li><li>  Starting from this index, we look through the table of indirect symbols and look for the value corresponding to the index of the target symbol in the symbol table. </li><li>  We remember how the target character got into the account from the beginning of the mapping of the import table to the table of indirect symbols.  The stored value is the index of the desired item in the import table. </li><li>  According to the data from the __la_symbol_ptr section (or __jump_table) we find the import table (field offset). </li><li>  Having the index of the target element in it, we rewrite the address (for __la_symbol_ptr) to the value we need (or change the CALL / JMP instruction to JMP with the operand ‚Äî the address of the function we need (for __jump_table)). </li></ol>  I note that working with tables of characters, strings and indirect characters is only necessary by loading them from a file.  And to read the contents of the sections describing import tables, and, of course, to make the redirect itself, already in memory.  This is due to the fact that the tables of characters and strings may be missing or do not display the actual state of affairs in the target Mach-O.  After all, a dynamic loader worked there before us and safely saved all the necessary data about the characters, without placing the tables themselves. <br><br><h3>  <b>Redirect implementation</b> </h3><br>  It is time to turn the thoughts into code.  To optimize the search for the necessary Mach-O elements at each redirection, we divide the whole operation into three steps: <br><ol><li><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mach_hook_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library_filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *library_address)</span></span></span></span>;</code> </pre>  Based on the Mach-O file itself and its memory mapping, this function returns an opaque descriptor, which hides offsets to the import table, a table of characters, strings, and the display of indirect (indirect) characters from the table of dynamic symbols, as well as a number of useful indices for this module.  Here is this descriptor: <br><pre> <code class="hljs pgsql">struct mach_hook_handle { <span class="hljs-type"><span class="hljs-type">void</span></span> const *library_address; //base address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a library <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory <span class="hljs-type"><span class="hljs-type">char</span></span> const *string_table; //buffer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> string_table <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> file struct nlist const *symbol_table; //buffer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> file uint32_t const *indirect_table; //buffer <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> the indirect symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dynamic symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> file uint32_t undefined_symbols_count; //number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> undefined symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> uint32_t undefined_symbols_index; //position <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> undefined symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> uint32_t indirect_symbols_count; //number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> indirect symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the indirect symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DYSYMTAB uint32_t indirect_symbols_index; //<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the first imported symbol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the indirect symbol <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DYSYMTAB uint32_t import_table_offset; //the <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> (__DATA, __la_symbol_ptr) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (__IMPORT, __jump_table) uint32_t jump_table_present; //special flag <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (__IMPORT, __jump_table) };</code> </pre></li><li><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">mach_substitution </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mach_hook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *handle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *function_name, mach_substitution substitution</span></span></span><span class="hljs-function">)</span></span>;</code> </pre>  This function, according to the library descriptor, the name of the target character and the interceptor address performs the redirection itself according to the algorithm described above. <br></li><li><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mach_hook_free</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *handle</span></span></span><span class="hljs-function">)</span></span>;</code> </pre>  This is the way to clear any handle that returned mach_hook_init (). </li></ol><br>  Given these prototypes, the test program will have to be rewritten: <br><pre> <code class="hljs lua">#include &lt;stdio.h&gt; #include &lt;dlfcn.h&gt; #include <span class="hljs-string"><span class="hljs-string">"mach_hook.h"</span></span> #define LIBTEST_PATH <span class="hljs-string"><span class="hljs-string">"libtest.dylib"</span></span> void libtest(); //from libtest.dylib int hooked_puts(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> const *s) { puts(s); //calls the original puts() from libSystem.B.dylib, because our main executable module called <span class="hljs-string"><span class="hljs-string">"test"</span></span> remains intact <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> puts(<span class="hljs-string"><span class="hljs-string">"HOOKED!"</span></span>); } int main() { void *handle = <span class="hljs-number"><span class="hljs-number">0</span></span>; //handle to store hook-related info mach_substitution original; //original data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> restoration Dl_info info; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dladdr((void const *)libtest, &amp;info)) //gets an address of a library which contains libtest() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fprintf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stderr, "Failed to get the base address of a library!\n", LIBTEST_PATH)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } handle = mach_hook_init(LIBTEST_PATH, info.dli_fbase); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!handle) { fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Redirection init failed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } libtest(); //calls puts() from libSystem.B.dylib puts(<span class="hljs-string"><span class="hljs-string">"-----------------------------"</span></span>); original = mach_hook(handle, <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, (mach_substitution)hooked_puts); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!original) { fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Redirection failed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } libtest(); //calls hooked_puts() puts(<span class="hljs-string"><span class="hljs-string">"-----------------------------"</span></span>); original = mach_hook(handle, <span class="hljs-string"><span class="hljs-string">"puts"</span></span>, original); //restores the original relocation <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!original) { fprintf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Restoration failed!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; } libtest(); //again calls puts() from libSystem.B.dylib <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>: mach_hook_free(handle); handle = <span class="hljs-number"><span class="hljs-number">0</span></span>; //no effect here, but just a good advice to prevent double freeing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The full implementation of the test case along with the redirection algorithm and the project file is available for <b><a href="">download</a></b> . <br><br><h3>  <b>Test run</b> </h3><br>  and try something like this: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>@mac$ arch -i386 ./test libtest: calls the original puts() <span class="hljs-comment"><span class="hljs-comment">----------------------------- libtest: calls the original puts() HOOKED! ----------------------------- libtest: calls the original puts()</span></span></code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>@mac$ arch -x86_64 ./test libtest: calls the original puts() <span class="hljs-comment"><span class="hljs-comment">----------------------------- libtest: calls the original puts() HOOKED! ----------------------------- libtest: calls the original puts()</span></span></code> </pre><br>  The output of the program indicates the complete implementation of the task set at the very beginning. <br><br><h3>  <b>useful links</b> </h3><ul><li>  <a href="http://developer.apple.com/library/mac/">Mac OS X ABI Mach-O File Format Reference</a> </li><li>  <a href="http://developer.apple.com/library/mac/">Mach-O Programming Topics</a> </li><li>  <a href="http://timetobleed.com/dynamic-linking-elf-vs-mach-o/">Dynamic Linking: ELF vs.</a>  <a href="http://timetobleed.com/dynamic-linking-elf-vs-mach-o/">Mach-o</a> </li><li>  <a href="http://timetobleed.com/dynamic-symbol-table-duel-elf-vs-mach-o-round-2/">Dynamic symbol table duel: ELF vs Mach-O, round 2</a> </li><li>  <a href="http://subreption.com/blog/runtime-binary-loading-via-the-dynamic-loader-on-apple-mac-os-x/">Runtime binary loading via Apple Mac OS X</a> </li><li>  <a href="http://www.blackhat.com/presentations/bh-dc-09/Iozzo/BlackHat-DC-09-Iozzo-Macho-on-the-fly.pdf">Let your Mach-O fly - Black Hat</a> </li><li>  <a href="http://www.blackhat.com/presentations/bh-dc-10/Suiche_Matthieu/Blackhat-DC-2010-Advanced-Mac-OS-X-Physical-Memory-Analysis-wp.pdf">Advanced Mac OS X Physical Memory Analysis - Black Hat</a> </li><li>  <a href="http://www.orkspace.net/secdocs/Unix/Misc/Breaking%2520Mac%2520OS%2520X.ppt">Breaking Mac OS X</a> </li></ul>  <b>Good luck!</b> </div><p>Source: <a href="https://habr.com/ru/post/115558/">https://habr.com/ru/post/115558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115553/index.html">New logo in Google Chrome Dev channel update</a></li>
<li><a href="../115554/index.html">Gears will no longer be in Chrome</a></li>
<li><a href="../115555/index.html">March application number for UserAndLINUX magazine is available - ‚ÄúMore than USER‚Äù</a></li>
<li><a href="../115556/index.html">Live (again) without boring things.</a></li>
<li><a href="../115557/index.html">Unity3d Tank Tutorial: Undercarriage (Lesson 1. Basics of vehicle mechanics)</a></li>
<li><a href="../115559/index.html">Down Silicon Valley Monopoly: Ukrainian ImPAD vs. iPad</a></li>
<li><a href="../115560/index.html">Scalaxi Updates: Windows Cloning and IP Addresses</a></li>
<li><a href="../115562/index.html">Citrix XenClient by the system administrator</a></li>
<li><a href="../115563/index.html">New Ebay tariffs, and also goodbye Buy it Now, hello Add to cart</a></li>
<li><a href="../115566/index.html">DWA-525 AP or budget WIFI access point</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>