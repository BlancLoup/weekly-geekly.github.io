<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When ID is not ID or Mongolian vowel separator attacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's notes  In the translation, I allowed myself to use some anglicisms, such as ‚Äúvalid‚Äù, ‚Äúnative‚Äù and ‚Äúbinary‚Äù. I hope there will be no quest...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When ID is not ID or Mongolian vowel separator attacks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/885/3b8/439/8853b8439abd4a9fb1bf2257b76dd4c1.jpg"><br><div class="spoiler">  <b class="spoiler_title">Translator's notes</b> <div class="spoiler_text">  In the translation, I allowed myself to use some anglicisms, such as ‚Äúvalid‚Äù, ‚Äúnative‚Äù and ‚Äúbinary‚Äù.  I hope there will be no questions with them. <br><br>  Identifiers is a special term for the C # specification that identifies everything to which you can refer to by name, such as the name of a class, the name of a variable, etc. <br><br>  Roslyn is a C # code compiler written in C #.  Was created to replace the existing csc.exe.  I usually omit the word compiler in this text. <br></div></div><br>  First, a few things you might not have heard about: <br><ul><li>  Identifiers in C # may include Unicode character escape sequences (such as \ u1234). </li><li>  Identifiers in C # may include Unicode characters of the category Cf (other, format), but when comparing identifiers for identity, these characters are ignored. </li><li>  The character "Mongolian vowel separator" (U + 180E), depending on the Unicode version, belongs to either the category Cf (other, format) or the category Zs (separator, space). </li><li>  .NET stores its own list of Unicode categories, independent of these in Win32. </li><li>  Roslyn is a .NET application and therefore uses the Unicode categories that are written in .NET files.  The native compiler (csc.exe) uses either system (Win32) categories or stores a copy of Unicode tables. </li><li>  None of the Unicode character tables (neither .NET nor Win32) exactly follow any version of the Unicode standard. </li><li>  Compilers may have bugs. </li></ul><br>  All of this leads to some problems ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Vladimir is to blame </h1><br>  It all started with a discussion at the ECMA technical group meeting last week.  We looked at ‚Äúnormative references,‚Äù and in particular, which version of the Unicode standard we will use.  At that time, ECMA-335 (4th Edition) uses Unicode 4.0, and Microsoft‚Äôs C # 5 specification uses Unicode 3.0.  I don‚Äôt know for sure if compiler developers take into account such features.  In my opinion, it would be better if ECMA and Microsoft did not indicate a specific version of Unicode in their specifications.  Let compiler developers use the latest version of Unicode currently available.  However, then the compilers will have to be supplied with their personal copy of the Unicode table, which is a bit strange, in my opinion. <br><a name="habracut"></a><br>  During our discussion, <a href="https://twitter.com/vreshetnikov">Vladimir Reshetnikov</a> casually mentioned the ‚Äú <a href="http://www.fileformat.info/info/unicode/char/180e/index.htm">Mongolian vowel separator</a> ‚Äù (U + 180E), which was tormented by a fair amount of life.  This character was added in Unicode 3.0.0 to the Cf category (other, format).  Then, in Unicode 4.0.0 it was moved to the Zs category (separator, space), and in Unicode 6.3.0 it was returned to the Cf category again. <br><br>  Of course, I tried to condemn such actions.  My initial goal was to show you a code that would behave differently, depending on the version of the Unicode table that the compiler uses.  However, it turned out that in fact everything is a little more complicated.  But for starters, we assume that we are using a ‚Äúhypothetical compiler‚Äù that does not contain bugs, and uses any version of Unicode that we want (which is a bug according to the requirements of the current C # specification, but we will leave aside this subtlety). <br><br><h1>  Hypothetical example 1: correct or incorrect </h1><br>  For simplicity, let's forget about UTFs for a while, and use the usual ASCII: <br><br><blockquote>  <font color="blue">class</font> <font color="#2b91af">MvsTest</font> <br>  { <br>  <font color="blue">static</font> <font color="blue">void</font> Main () <br>  { <br>  <font color="blue">string</font> stringx = <font color="#a31515">"a"</font> ; <br>  string \ u180ex = <font color="#a31515">"b"</font> ; <br>  <font color="#2b91af">Console</font> .WriteLine (stringx); <br>  } <br>  } </blockquote><br><br>  If the compiler uses Unicode version 6.3 or higher (or a version lower than 4.0), then U + 180E will be considered a character from the Cf category, and therefore allowed for use in the identifier.  If the symbol is allowed to be used in the identifier, then instead of this symbol we can use the escape sequence, and the compiler will gladly process it correctly.  The identifier in the second line of this method is considered to be ‚Äúidentical‚Äù to stringx, so that ‚Äúb‚Äù will be displayed. <br><br>  So what about a compiler that uses Unicode version 4.0 - 6.2 inclusive?  In this case, U + 180E will be considered a character from the category Zs, which makes it a whitespace character.  Whitespace characters are allowed inside C # code, but not in the identifiers themselves.  And since this symbol is not a permitted identifier and is not inside a character \ string literal, from the compiler‚Äôs point of view, using the escape sequence in this segment is incorrect, and therefore this section of the code simply does not compile. <br><br><h1>  Hypothetical example 2: correct, in two different ways </h1><br>  However, we can write the same code without using an escape sequence.  To do this, create a regular ASCII file: <br><br><blockquote>  <font color="blue">class</font> <font color="#2b91af">MvsTest</font> <br>  { <br>  <font color="blue">static</font> <font color="blue">void</font> Main () <br>  { <br>  <font color="blue">string</font> stringx = <font color="#a31515">"a"</font> ; <br>  stringAAAx = <font color="#a31515">"b"</font> ; <br>  <font color="#2b91af">Console</font> .WriteLine (stringx); <br>  } <br>  } </blockquote><br><br>  Then open it in a hex editor and replace AAA characters with E1 A0 8E bytes.  Thus, we obtained a file containing the UTF-8 representation of the U + 180E symbol in the same place in which it was displayed using the escape sequence in the first example. <br><br>  The compiler, which successfully adopted the first example, will also compile this option (assuming that you were able to tell the compiler that the file is encoded in UTF-8), and the result will be exactly the same ‚Äî the ‚Äúb‚Äù will be displayed on the screen, as the second the construction in the method is a simple assignment to an existing variable. <br><br>  However, even if the compiler perceives U + 180E as a whitespace character (that is, refuses to compile the program from Example 1), problems with this variant will not arise anyway, the compiler will accept the second expression in the method as declaring a new local variable x and assigning it some initial value.  You may receive a compiler warning about declaring an unused local variable, but the code will be successfully compiled and ‚Äúa‚Äù will be displayed. <br><br><h1>  Reality: Microsoft Compilers </h1><br>  When we talk about the Microsoft C # compiler, we need to distinguish between the native compiler (csc.exe) and Roslyn (rcsc, although I usually call it simply Roslyn). <br><br>  Since csc.exe is written in native code, it uses either Unicode tools built into Windows or simply stores a table of Unicode characters in its executable file.  (I scoured the entire MSDN in search of a native Win32 function to determine if a character belonged to a certain Unicode category, but I didn‚Äôt find anything. And pity, such a function would be very useful ...) <br><br>  At this time, Roslyn, which is written in C #, uses the <a href="http://msdn.microsoft.com/en-us/library/system.char.getunicodecategory">char.GetUnicodeCategory () function</a> , which relies on the tables built into mscorlib.dll, to define the Unicode categories (as far as I know). <br><br>  My experiments suggest that, regardless of what the native compiler uses to determine the category, U + 180E is always taken for the symbol Cf category.  At least I tried to find old machines (including VM images) on which no updates were installed since September 2013 (this was the time when the Unicode 6.3 standard was published) and they all compiled the program from the first example without either mistakes.  I begin to suspect that csc.exe probably has a copy of Unicode 3.0 table built into the binary.  He definitely perceives U + 180E as a formatting character, but ‚Äúdislikes‚Äù the characters U + 0600 and U + 00AD in identifiers (U + 0600 was not introduced before Unicode 4.0, but it was always a formatting character; U + 00AD in Unicode 3.0 was a punctuation character (dash), but since Unicode 4.0 it is a formatting character) <br><br>  However, the table embedded in mscorlib.dll definitely changed with the advent of new versions of the .NET Framework.  If you run this program: <br><br><blockquote>  <font color="blue">using</font> System; <br><br>  <font color="blue">class</font> <font color="#2b91af">Test</font> <br>  { <br>  <font color="blue">static</font> <font color="blue">void</font> Main () <br>  { <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="#2b91af">Environment</font> .Version); <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="blue">char</font> .GetUnicodeCategory ( <font color="#a31515">'\ u180e'</font> )); <br>  } <br>  } </blockquote><br><br>  Then under the CLRv2, ‚ÄúSpaceSeparator‚Äù will be displayed, while under CLRv4 (at least on the recently updated system) ‚ÄúFormat‚Äù will be displayed. <br><br>  Of course, Roslyn will not work on older versions of the CLR.  However, we still have hope in the face of <a href="http://csharppad.com/">csharppad.com</a> , which launches Roslyn in some kind of environment (of unknown origin, maybe Mono? Not sure), and, as a result, the ‚ÄúSpaceSeparator‚Äù is displayed.  I am sure that the program from the first example will not be compiled.  However, with the second example, everything is more complicated - csharppad.com does not allow downloading the source file, and copy / paste gives a strange result. <br><br><h1>  Reality: mcs (Mono C # compiler) </h1><br>  The Mono compiler also uses the GetUnicodeCategory () method, which makes our experiments much easier, but unfortunately, the Mono parser has at least 2 bugs: <br><ul><li>  It allows you to use any escape sequence as an identifier, regardless of whether this escape sequence is a valid identifier or not.  For example, from the point of view of the Mono compiler, the construction of string \ u0020x = ‚Äú‚Äù is valid.  Marked as <a href="https://bugzilla.xamarin.com/show_bug.cgi%3Fid%3D24968">bug 24968</a> .  <a href="">Source of</a> </li><li>  It does not allow the use of formatting symbols within identifiers, including symbols from the category Mn, Mc, Nd and Pc, but not Cf.  Marked as <a href="https://bugzilla.xamarin.com/show_bug.cgi%3Fid%3D24969">bug 24969</a> .  <a href="">Source of</a> </li></ul><br>  For this reason, the program from the first example is always compiled, and displays ‚Äúb‚Äù.  However, the program from the second example will produce a compilation error, regardless of which of the categories (Zs or Cf), according to the compiler, the U + 180E symbol belongs to. <br><br><h1>  So what version is it? </h1><br>  Next, let's reflect on the Unicode table itself in .NET, since it is not entirely clear which version of Unicode different BCL implementations use.  Run this program: <br><br><blockquote>  <font color="blue">using</font> System; <br><br>  <font color="blue">class</font> <font color="#2b91af">Test</font> <br>  { <br>  <font color="blue">static</font> <font color="blue">void</font> Main () <br>  { <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="blue">char</font> .GetUnicodeCategory ( <font color="#a31515">'\ u00ad'</font> )); <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="blue">char</font> .GetUnicodeCategory ( <font color="#a31515">'\ u0600'</font> )); <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="blue">char</font> .GetUnicodeCategory ( <font color="#a31515">'\ u180e'</font> )); <br>  } <br>  } </blockquote><br><br>  On my computer, this program running under CLRv4 issues ‚ÄúDashPunctuation, Format, Format‚Äù, and under Mono (3.3.0) and CLRv2 issues ‚ÄúDashPunctuation, Format, SpaceSeparator‚Äù. <br><br>  This is at least strange.  This behavior does not correspond to any of the versions of the standard Unicode, as far as I can say. <br><ul><li>  U + 00AD was a Po (other, punctuation) symbol in Unicode 1.x, then Pd (dash, punctuation) in 2.x and 3.x, and starting from 4.0 it is a Cf symbol. </li><li>  U + 0600 was first introduced in Unicode 4.0 and has always been a Cf symbol. </li><li>  U + 180E was introduced as a Cf character in Unicode 3.0, then became a Zs character in Unicode 4.0, and finally returned to the Cf category in Unicode 6.3. </li></ul><br>  Thus, none of the Unicode versions of the standard matches the first or third line of output.  Now I'm really confused ... <br><br><h1>  What about nameof and CallerMemberName? </h1><br>  Identifiers are not only used for comparison, they are available as strings (C # strings) without any use of Reflection.  Starting in C # 5, the CallerMemberName attribute is available to us, allowing us to do such things: <br><br><blockquote>  <font color="blue">public</font> <font color="blue">static</font> <font color="blue">void</font> X \ u0600y () <br>  { <br>  ShowCaller (); <br>  } <br><br>  <font color="blue">public</font> <font color="blue">static</font> <font color="blue">void</font> ShowCaller ([ <font color="#2b91af">CallerMemberName</font> ] <font color="blue">string</font> caller = <font color="blue">null</font> ) <br>  { <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="#a31515">"Called by</font> <font color="mediumseagreen">{0}</font> <font color="#a31515">"</font> , caller); <br>  } </blockquote><br><br>  And in C # 6 we can write this: <br><br><blockquote>  <font color="blue">string</font> x \ u0600y = <font color="#a31515">""</font> ; <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="#a31515">"nameof =</font> <font color="mediumseagreen">{0}</font> <font color="#a31515">"</font> , <font color="blue">nameof</font> (x \ u0600y)); </blockquote><br><br>  What will these two programs display?  They simply print ‚ÄúXy‚Äù and ‚Äúxy‚Äù as names, as if the compiler simply threw out all the formatting characters.  But what should they bring out?  It is necessary to take into account that in the second case we could just write nameof (xy) and such a string would still remain equal to the string of the declared identifier. <br><br>  We cannot even say: ‚ÄúWhat is the name of the declared member?‚Äù, Because you can overload it with an ‚Äúother, but equal to it‚Äù identifier: <br><br><blockquote>  <font color="blue">public</font> <font color="blue">static</font> <font color="blue">void</font> Xy () {} <br>  <font color="blue">public</font> <font color="blue">static</font> <font color="blue">void</font> X \ u0600y () {} <br>  <font color="blue">public</font> <font color="blue">static</font> <font color="blue">void</font> X \ u070fy () {} <br>  ... <br>  <font color="#2b91af">Console</font> .WriteLine ( <font color="blue">nameof</font> (X \ u200by)); </blockquote><br><br>  What should be displayed on the screen?  I‚Äôm sure you‚Äôll feel relieved to know that the creators of C # have a plan for this, but this is really one of those scenarios for which ‚Äúthere is no obvious right answer.‚Äù  Things get even stranger when the CLI specification comes into play.  Section I.8.5.1 of the 6th edition of ECMA-335 standard says: <br><blockquote>  Assemblies should be guided by Appendix 7 of Technical Report 15 of the Unicode Standard 3.0 defining a set of characters allowed for use in identifiers, which is available at <a href="http://www.unicode.org/unicode/reports/tr15/tr15-18.html">www.unicode.org/unicode/reports/tr15/tr15-18.html</a> .  Identifiers must be in the canonical format defined in "Unicode Normalization Form C".  To meet the CLS specification, two identifiers must be the same, only if their lowercase representations (Unicode-specific locale-independent mapping of one-to-one lowercase) are the same.  For this reason, in order for two identifiers to be treated as different, according to the CLS, they must differ more than just in the case of characters.  However, in order to override the inherited definition, the CLI requires the exact encoding used to encode the original definition. </blockquote><br>  I would like to study the effect of this document by adding a Cf symbol in IL, but unfortunately, I still haven‚Äôt been able to figure out how to affect the encoding used by ilasm in order to convince him that my ‚Äúcorrected‚Äù IL is what I want him to be. <br><br><h1>  Conclusion </h1><br>  As mentioned earlier, the <a href="http://habrahabr.ru/post/243523/">text is complex</a> . <br><br>  It turned out that even by limiting oneself only with identifiers, the ‚Äútext is complex‚Äù.  Who would have thought? <br><br>  From the translator: I thank user <a href="https://habrahabr.ru/users/impwx/" class="user_link">impwx</a> for translating the previous publication of John Skit </div><p>Source: <a href="https://habr.com/ru/post/248797/">https://habr.com/ru/post/248797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248783/index.html">HTML5 canvas karaoke</a></li>
<li><a href="../248785/index.html">Fundamentals of graphics programming on Apple Metal: Getting started</a></li>
<li><a href="../248787/index.html">WRL and BindableAttribute</a></li>
<li><a href="../248789/index.html">Developer Stories: Microblink PhotoMath</a></li>
<li><a href="../248793/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ32 (January 19 - 25, 2015)</a></li>
<li><a href="../248799/index.html">React JS Quick Start Guide</a></li>
<li><a href="../248801/index.html">How open data is arranged in Russia</a></li>
<li><a href="../248803/index.html">Do you still have SSL3 enabled? Check server and browser for POODLE vulnerability</a></li>
<li><a href="../248807/index.html">We deliver voice to the mobile network: step 1 - how the voice turns into an electrical signal</a></li>
<li><a href="../248809/index.html">Age rating of Windows Store games in plain language</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>