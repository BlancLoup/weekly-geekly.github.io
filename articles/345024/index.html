<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to read a large file using PHP (without crashing a server)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Christopher Pitt . 


 PHP developers do not often have to monitor the memory consumption in their applications. The PHP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to read a large file using PHP (without crashing a server)</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of the <a href="https://www.sitepoint.com/performant-reading-big-files-php/">article by</a> <a href="https://twitter.com/assertchris">Christopher Pitt</a> .</em> </p><br><p>  PHP developers do not often have to monitor the memory consumption in their applications.  The PHP engine itself does a good job of cleaning up the garbage behind us, and the web server model with the execution context ‚Äúdying‚Äù after the execution of each request allows even the worst code to not create big long problems. </p><br><p>  However, in some situations, we may encounter problems of lack of RAM - for example, trying to run a composer on a small VPS, or when opening a large file on a server that is not rich in resources. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e5d/8de/d81/e5d8ded81c6b152ac53fd5fcb5d187f9.jpg" alt="Fragmented terrain"></p><br><p>  The last problem will be considered in this lesson. </p><a name="habracut"></a><br><p>  <em>All code is available at <a href="https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php">https://github.com/sitepoint-editors/sitepoint-performant-reading-of-big-files-in-php</a></em> </p><br><h2 id="merila-uspeha">  Meryl of Success </h2><br><p>  When conducting any optimizations of the code, we must always measure the results of its execution before and after, in order to evaluate the effectiveness (or destructiveness) of our optimizations. </p><br><p>  Usually measure the CPU load and memory usage.  It often happens that saving one leads to increased costs of the other and vice versa. </p><br><p>  In the asynchronous model of the application (multiprocessor and multithreaded) it is always very important to monitor both the processor and the memory.  In classic applications, resource control becomes a problem only when approaching server limits. </p><br><p>  <em>Measuring CPU usage inside PHP is a bad idea.</em>  <em>It is better to use any utility like <strong>top</strong> from Ubuntu or macOS.</em>  <em>If you have Windows, you can use Linux Subsystem to access <strong>top</strong> .</em> </p><br><p>  In this tutorial, we will measure memory usage.  We will look at how memory is spent in traditional scripts, and then apply a couple of chips for optimization and compare the results.  I hope, by the end of the article, the reader will get a basic understanding of the basic principles of optimizing memory consumption when reading large amounts of data. </p><br><p>  We will measure the memory like this: </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// formatBytes is taken from the php.net documentation memory_get_peak_usage(); function formatBytes($bytes, $precision = 2) { $units = array("b", "kb", "mb", "gb", "tb"); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 &lt;&lt; (10 * $pow)); return round($bytes, $precision) . " " . $units[$pow]; }</span></span></code> </pre> <br><p>  We will use this function at the end of each script, and compare the values ‚Äã‚Äãobtained. </p><br><h2 id="kakie-est-varianty">  What are the options? </h2><br><p>  There are many different approaches for efficiently reading data, but all of them can be divided into two groups: we either read and <em>process the read <strong>portion of the</strong> data immediately</em> (without first loading all the data into memory), or <em>convert the data into a stream</em> without bothering it content. </p><br><p>  Let's imagine that for the first option we want to read the file and process it every 10,000 lines separately.  You will need to keep at least 10,000 lines in memory and transfer them to the queue (in whatever form it is implemented). </p><br><p>  For the second scenario, suppose we want to compress the contents of a very large API response.  It does not matter to us what data is contained there, it is important to return them in a compressed form. </p><br><p>  In both cases, you need to consider large amounts of information.  In the first, we know the data format, in the second, the format does not matter.  Consider both options. </p><br><h2 id="chtenie-fayla-stroka-za-strokoy">  Reading File Line by Line </h2><br><p>  There are many functions for working with files.  Let's write with their help your reader: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from memory.php function formatBytes($bytes, $precision = 2) { $units = array("b", "kb", "mb", "gb", "tb"); $bytes = max($bytes, 0); $pow = floor(($bytes ? log($bytes) : 0) / log(1024)); $pow = min($pow, count($units) - 1); $bytes /= (1 &lt;&lt; (10 * $pow)); return round($bytes, $precision) . " " . $units[$pow]; } print formatBytes(memory_get_peak_usage());</span></span></code> </pre> <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from reading-files-line-by-line-1.php function readTheFile($path) { $lines = []; $handle = fopen($path, "r"); while(!feof($handle)) { $lines[] = trim(fgets($handle)); } fclose($handle); return $lines; } readTheFile("shakespeare.txt"); require "memory.php";</span></span></code> </pre> <br><p>  Here we read the file with the works of Shakespeare.  The file size is about <strong>5.5MB</strong> and peak memory usage is <strong>12.8MB</strong> . </p><br><p>  And now let's use the <strong>generator</strong> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from reading-files-line-by-line-2.php function readTheFile($path) { $handle = fopen($path, "r"); while(!feof($handle)) { yield trim(fgets($handle)); } fclose($handle); } readTheFile("shakespeare.txt"); require "memory.php";</span></span></code> </pre> <br><p>  The file is the same, and peak memory usage has dropped to <strong>393KB</strong> !  But as long as we do not perform any operations with the read data, this has no practical use.  For example, we can break a document into parts if we meet two empty lines: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from reading-files-line-by-line-3.php $iterator = readTheFile("shakespeare.txt"); $buffer = ""; foreach ($iterator as $iteration) { preg_match("/\n{3}/", $buffer, $matches); if (count($matches)) { print "."; $buffer = ""; } else { $buffer .= $iteration . PHP_EOL; } } require "memory.php";</span></span></code> </pre> <br><p>  Although we broke the document into <strong>1,216</strong> pieces, we used only <strong>459KB of</strong> memory.  All this, thanks to the peculiarities of the generators - the amount of memory for their work is equal to the size of the largest iterated part.  In this case, the largest part consists of <strong>101,985</strong> characters. </p><br><p>  Generators can be used in other situations, but this example demonstrates well the performance of reading large files.  Generators may be one of the best options for data processing. </p><br><h2 id="payping-mezhdu-faylami">  Piping between files </h2><br><p>  In situations where data processing is not required, we can forward data from one file to another.  This is called pipeping (pipe), <em>perhaps because we do not see what is happening inside the pipe, but we see what comes in and out of it</em> ).  This can be done using streaming methods.  But first, let's write a classic script that stupidly transfers data from one file to another: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from piping-files-1.php file_put_contents( "piping-files-1.txt", file_get_contents("shakespeare.txt") ); require "memory.php";</span></span></code> </pre><br><p>  It is not surprising that this script uses much more memory than the file being copied.  This is due to the fact that it must read and store the contents of the file in memory until the file is copied completely.  For small files there is nothing terrible, but not for big ones ... </p><br><p>  Let's try to stream (or pipe) files, one to another: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from piping-files-2.php $handle1 = fopen("shakespeare.txt", "r"); $handle2 = fopen("piping-files-2.txt", "w"); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require "memory.php";</span></span></code> </pre><br><p>  The code is rather strange.  We open both files, the first for reading, the second for writing.  Then we copy the first to the second, and then close both files.  It may be a surprise, but we spent only <strong>393KB</strong> . </p><br><p>  Something familiar.  Doesn't this look like a generator reading every line?  This is because the second <code>fgets</code> argument determines how many bytes of each line need to be read (by default, -1, that is, to the end of the line).  Optional, the third stream_copy_to_stream does the same thing.  <code>stream_copy_to_stream</code> reads the first stream on one line and writes to the second. </p><br><p>  Piping this text is not very useful for us.  Let's come up with a real example.  Suppose we want to get a picture from our CDN and transfer it to a file or to <code>stdout</code> .  We could do it like this: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from piping-files-3.php file_put_contents( "piping-files-3.jpeg", file_get_contents( "https://github.com/assertchris/uploads/raw/master/rick.jpg" ) ); // ...or write this straight to stdout, if we don't need the memory info require "memory.php";</span></span></code> </pre><br><p>  In order to implement our plans this way it took <strong>581KB</strong> .  Now let's try to do the same with threads. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from piping-files-4.php $handle1 = fopen( "https://github.com/assertchris/uploads/raw/master/rick.jpg", "r" ); $handle2 = fopen( "piping-files-4.jpeg", "w" ); // ...or write this straight to stdout, if we don't need the memory info stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require "memory.php";</span></span></code> </pre><br><p>  Spent a little less memory ( <strong>400KB</strong> ) with the same result.  And if we did not need to save the image in memory, we could immediately zastrizit it in <code>stdout</code> : </p><br><pre> <code class="php hljs">$handle1 = fopen( <span class="hljs-string"><span class="hljs-string">"https://github.com/assertchris/uploads/raw/master/rick.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span> ); $handle2 = fopen( <span class="hljs-string"><span class="hljs-string">"php://stdout"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span> ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); <span class="hljs-comment"><span class="hljs-comment">// require "memory.php";</span></span></code> </pre><br><h3 id="drugie-potoki">  Other streams </h3><br><p>  There are other streams to / from which you can stream: </p><br><ul><li>  <code>php://stdin</code> - read only </li><li>  <code>php://stderr</code> - write only </li><li>  <code>php://input</code> - read only (gives access to the naked body of the request) </li><li>  <code>php://output</code> - write only (allows writing to output buffer) </li><li>  <code>php://memory</code> and <code>php://temp</code> - read and write.  Here you can store temporary data, the difference is that <code>php://temp</code> will store data in the file system as it grows, and <code>php://memory</code> will write everything into RAM to the last. </li></ul><br><h2 id="filtry">  Filters </h2><br><p>  There is one more feature that we can use - these are <strong>filters</strong> .  An intermediate option that gives us a little control over the flow, without the need to dive into its contents in detail.  Suppose we want to compress a file.  You can apply zip extension: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from filters-1.php $zip = new ZipArchive(); $filename = "filters-1.zip"; $zip-&gt;open($filename, ZipArchive::CREATE); $zip-&gt;addFromString("shakespeare.txt", file_get_contents("shakespeare.txt")); $zip-&gt;close(); require "memory.php";</span></span></code> </pre><br><p>  Good code, but it consumes almost <strong>11MB</strong> .  With filters, get better: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from filters-2.php $handle1 = fopen( "php://filter/zlib.deflate/resource=shakespeare.txt", "r" ); $handle2 = fopen( "filters-2.deflated", "w" ); stream_copy_to_stream($handle1, $handle2); fclose($handle1); fclose($handle2); require "memory.php";</span></span></code> </pre><br><p>  Here we use <code>php://filter/zlib.deflate</code> which reads and compresses incoming data.  We can pipe compressed data to a file, or somewhere else.  This code used only <strong>896KB</strong> . </p><br><p>  <em>I know that this is not exactly the same format as the zip archive.</em>  <em>But think about it, if we have the opportunity to choose a different compression format, spending 12 times less memory, is it worth it?</em> </p><br><p>  To unpack the data, apply another zip filter. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from filters-2.php file_get_contents( "php://filter/zlib.inflate/resource=filters-2.deflated" );</span></span></code> </pre><br><p>  Here are a couple of articles for those who would like to dive deeper into the topic of threads: ‚Äú <a href="https://www.sitepoint.com/%25EF%25BB%25BFunderstanding-streams-in-php/">Understanding Streams in PHP</a> ‚Äù and ‚Äú <a href="https://www.sitepoint.com/using-php-streams-effectively/">Using PHP Streams Effectively</a> ‚Äù. </p><br><h2 id="kastomizaciya-potokov">  Stream customization </h2><br><p>  <code>fopen</code> and <code>file_get_contents</code> have a number of preset options, but we can change them as you please.  To do this, you need to create a new thread context: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// from creating-contexts-1.php $data = join("&amp;", [ "twitter=assertchris", ]); $headers = join("\r\n", [ "Content-type: application/x-www-form-urlencoded", "Content-length: " . strlen($data), ]); $options = [ "http" =&gt; [ "method" =&gt; "POST", "header"=&gt; $headers, "content" =&gt; $data, ], ]; $context = stream_content_create($options); $handle = fopen("http://example.com/register", "r", false, $context); $response = stream_get_contents($handle); fclose($handle);</span></span></code> </pre><br><p>  In this example we are trying to make a <code>POST</code> request to the API.  We register several headers, and access the API by file descriptor.  There are many other options for customization, so it will not be superfluous to get acquainted with the documentation on this issue. </p><br><h2 id="sozdanie-svoih-protokolov-i-filtrov">  Creating your own protocols and filters </h2><br><p>  Before you finish, let's talk about creating custom protocols.  If you look in the <a href="https://php.net/manual/en/class.streamwrapper.php">documentation</a> , you can see an example: </p><br><pre> <code class="php hljs">Protocol { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> resource $context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> __construct ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> __destruct ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool dir_closedir ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool dir_opendir ( string $path , int $options ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string dir_readdir ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool dir_rewinddir ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool mkdir ( string $path , int $mode , int $options ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rename ( string $path_from , string $path_to ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rmdir ( string $path , int $options ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> resource stream_cast ( int $cast_as ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void stream_close ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_eof ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_flush ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_lock ( int $operation ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_metadata ( string $path , int $option , mixed $value ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_open ( string $path , string $mode , int $options , string &amp;$opened_path ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> string stream_read ( int $count ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_seek ( int $offset , int $whence = SEEK_SET ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_set_option ( int $option , int $arg1 , int $arg2 ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> stream_stat ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int stream_tell ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool stream_truncate ( int $new_size ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int stream_write ( string $data ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool unlink ( string $path ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> url_stat ( string $path , int $flags ) }</code> </pre><br><p>  Writing your own implementation of this pulls into a separate article.  But if you still get confused and do it, then you can easily register your wrapper for streams: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (in_array(<span class="hljs-string"><span class="hljs-string">"highlight-names"</span></span>, stream_get_wrappers())) { stream_wrapper_unregister(<span class="hljs-string"><span class="hljs-string">"highlight-names"</span></span>); } stream_wrapper_register(<span class="hljs-string"><span class="hljs-string">"highlight-names"</span></span>, <span class="hljs-string"><span class="hljs-string">"HighlightNamesProtocol"</span></span>); $highlighted = file_get_contents(<span class="hljs-string"><span class="hljs-string">"highlight-names://story.txt"</span></span>);</code> </pre><br><p>  Similarly, you can create custom stream filters.  An example of a dock filter class: </p><br><pre> <code class="php hljs">Filter { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $filtername; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $params <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int filter ( resource $in , resource $out , int &amp;$consumed , bool $closing ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void onClose ( void ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool onCreate ( void ) }</code> </pre><br><p>  And it‚Äôs also easy to register: </p><br><pre> <code class="php hljs">$handle = fopen(<span class="hljs-string"><span class="hljs-string">"story.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w+"</span></span>); stream_filter_append($handle, <span class="hljs-string"><span class="hljs-string">"highlight-names"</span></span>, STREAM_FILTER_READ);</code> </pre><br><p>  The <code>filtername</code> property in the new filter class must be equal to <code>highlight-names</code> .  You can also use the inline filter <code>php://filter/highligh-names/resource=story.txt</code> .  Creating filters is much easier than protocols.  But the protocols have more flexible features and functionality.  For example, one of the reasons for which filters are not suitable, but protocols are required - these are operations with directories where a filter will be needed to process each piece of data. </p><br><p>  I strongly recommend experimenting with creating your own protocols and filters.  If you manage to apply a filter to the <code>stream_copy_to_stream</code> function, you will get tremendous memory savings when working with large amounts of data.  Imagine that you will have a filter for resizing images or a filter for encryption, and maybe even more awesome. </p><br><h2 id="itog">  Total </h2><br><p>  Although this is not the most common problem with which we are suffering, it is very easy to mess with large files.  In asynchronous applications, it‚Äôs generally very easy to put an entire server if you don‚Äôt control memory usage in your scripts </p><br><p>  I hope that this lesson gave you a few new ideas (or refreshed them in memory) and now you can work with large files much more efficiently.  Acquainted with generators and threads (and no longer using functions like <code>file_get_contents</code> ), our applications can be spared a whole class of errors.  What seems like a good thing to aim for! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/345024/">https://habr.com/ru/post/345024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345014/index.html">How to manage sections in Oracle DB and not go crazy</a></li>
<li><a href="../345016/index.html">Polymer, fight for performance</a></li>
<li><a href="../345018/index.html">Tutorial on the Unreal Engine. Part 7: Sound</a></li>
<li><a href="../345020/index.html">How I hacked 40 sites in 7 minutes (transfer)</a></li>
<li><a href="../345022/index.html">Collect and Filter Logon Events with Log Parser</a></li>
<li><a href="../345026/index.html">How we created an online service for learning English: from startup to flourish</a></li>
<li><a href="../345028/index.html">Magically vanishing JS framework</a></li>
<li><a href="../345030/index.html">Building maintenance: what will happen if you go wisely once</a></li>
<li><a href="../345032/index.html">Modeling enterprise assets using projection modeling</a></li>
<li><a href="../345034/index.html">How to speed up the selection process</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>