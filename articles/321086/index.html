<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Physics of trains in Assassin's Creed Syndicate</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about our own simulator, created to simulate the physics of trains in Assassin's Creed Syndicate. The game takes place ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Physics of trains in Assassin's Creed Syndicate</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://www.youtube.com/embed/faXgqr1xRp8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In this article I want to talk about our own simulator, created to simulate the physics of trains in Assassin's Creed Syndicate.  The game takes place in London in 1868, during the industrial revolution, when the development of society depended on steam and steel.  It was a great pleasure for me to work on a unique opportunity to realize the world of London in the Victorian era.  Attention to historical and real details led us to create this physical simulation. <br><br><h2>  Introduction </h2><br>  Today, writing your own physics engines is not very popular.  However, there are situations in which creating your own physical simulator from scratch is extremely useful.  Such situations may arise when there is a special need for a new gameplay function or part of a simulated game world.  This is exactly the problem that arose in the development of railways and train management systems in London of the 19th century. <br><br>  The standard system for connecting European trains is shown in Fig.  1 left.  The same system was used in 19th century trains in London [1].  When we started working on trains, we quickly realized that interesting interactions and dependencies could be created, simulating a coupler physically.  Therefore, instead of a rigid fastening of the cars, we connected them with a movable coupling device controlling the movement of all the cars of the train. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/9db/205/a20/9db205a20098ee341d884330acc6b189.png" alt="image"><br>  <i><b>Fig.</b></i>  <i><b>1.</b> On the left - details of the screw tie (source: Wikipedia [1]).</i>  <i>On the right is the connective system in Assassin's Creed Syndicate.</i> <br><a name="habracut"></a><br>  In this case, our physical simulation gives a couple of advantages: <br><br><ul><li>  Winding railway tracks are easier to control using a 1D simulator.  Forcing 3D physics to use motion control limiters in a one-dimensional space is a rather risky decision.  She can be very sensitive to the emerging instability, due to which the cars will take off into the air.  However, we still needed to recognize the collisions of the cars in full 3D space. </li><li>  The moving connection provides more freedom in gameplay design.  Compared to the real world, we need a much greater distance between the cars.  This is required in order to have more space to perform different actions of the player and the camera (for example, to climb onto the roof of the car).  In addition, our coupler is connected much less rigidly than in the real world to provide freer relative motion between the cars.  This makes it easier for us to cope with sharp turns of railway tracks, and the recognition of collisions between cars protects against interpenetration. </li><li>  Thanks to our system, we can perform the uncoupling of cars (taking into account friction forces) and the calculation of collisions between uncoupled cars and the rest of the train (for example, when the train stops abruptly, when the uncoupled cars continue to move and as a result hit the train). </li></ul><br>  Here is a video with an example of the work of our physics: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w8hhUeNxo-w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  We begin with a section in which we explain how trains are controlled. <br><br>  <u>Note: in</u> order to simplify the explanation, we will designate the term ‚Äútractor‚Äù as a carriage closer to the locomotive, and the term ‚Äútrailer‚Äù carriage that is located closer to the tail of the train. <br><br><h2>  Locomotive control </h2><br>  To control the locomotive, we have created a very simple interface consisting only of requests for the required speed: <br><br><pre><code class="cpp hljs">Locomotive::SetDesiredSpeed(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DesiredSpeed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TimeToReachDesiredSpeed)</code> </pre> <br>  The rail system manager sends such requests for each train moving in the game.  To fulfill the query, we calculate the force needed to create the required acceleration.  We use the following formula (Newton's second law): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/497/1d4/fde/4971d4fdef21baa0782e30df0a8d16f6.gif" alt="image"><br><br>  where <i>F</i> is the calculated force, <i>m</i> is the mass of the locomotive, <img src="https://habrastorage.org/getpro/habr/post_images/6b3/d52/8eb/6b3d528eba9a72815d7a2937f548d2ef.gif" alt="image">  (the required speed is the current speed), and <i>t = TimeToReachDesiredSpeed ‚Äã‚Äã(time to reach the required speed)</i> . <br><br>  After calculating the force, we transfer it to <i>WagonPhysicsState</i> as the ‚Äúengine power‚Äù to drive the locomotive (more on this in the next section). <br><br>  Since the physical behavior of a train may depend, for example, on the number of cars (cars colliding with each other create a chain reaction and push the train forward), we need a way to ensure that the request sent to the desired speed is completely fulfilled.  To achieve this, we re-compute the speed required to achieve the required speed every 2 seconds.  Thus, we guarantee that the sent request will be executed as a result.  But because of this, we cannot exactly match the value of <i>TimeToReachDesiredSpeed</i> .  However, small time variations in the game are acceptable. <br><br>  In addition, in order to maintain the locomotive speed specified by the <i>SetDesiredSpeed</i> request, we do not allow the coupling tie limiter to change the locomotive speed.  To compensate for the absence of such impulses from limiters, we created a special method for simulating traction force (for more details, see the ‚ÄúStarting the train‚Äù section).  And finally, we do not allow the reaction to collisions to change the speed of the locomotive, except for the case when the train brakes to zero speed. <br><br>  The following section describes the basic level of physical simulation. <br><br><h2>  Basic simulation step </h2><br>  Here is the structure used to store physical information about each car (and locomotive): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WagonPhysicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,   : //     . RailwayTrack m_Track; float m_LinearMomentum; // ,   . float m_LinearSpeed; //   . float m_EngineForce; float m_FrictionForce; //     ,    . Vector m_WorldPosition; Quaternion m_WorldRotation; //   : float m_Mass; }</span></span></code> </pre> <br>  As you can see, the angular velocity is missing.  Even if we check collisions between cars using 3D colliders (and the turn always corresponds to the direction of the tracks), trains move in a one-dimensional world along railway tracks.  Therefore, for physics it is not necessary to store information about the angular motion.  In addition, due to the one-dimensional simulation, for storing physical quantities (forces, impulses, and velocity), variables of type float are sufficient. <br><br>  For each car, we use the Euler method [2] as the step of the basic simulation ( <i>dt</i> is the time of one simulation step): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WagonPhysicsState::BasicSimulationStep(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt) { <span class="hljs-comment"><span class="hljs-comment">//  . float dPosition = m_LinearSpeed; float dLinearMomentum = m_EngineForce + m_FrictionForce; //  . m_LinearMomentum += dLinearMomentum*dt; m_LinearSpeed = m_LinearMomentum / m_Mass; //  . float DistanceToTravelDuringThisStep = dPosition*dt; m_Track.MoveAlongSpline( DistanceToTravelDuringThisStep ); //       . m_WorldPosition = m_Track.GetCurrentWorldPosition(); m_WorldRotation = m_Track.AlignToSpline(); }</span></span></code> </pre> <br>  To implement <i>BasicSimulationStep,</i> we use three basic equations.  These equations show that speed is a derivative of a position, and force is a derivative of a pulse (the point above the symbol denotes the derivative with respect to time) [2-4]: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03b/7af/b3c/03b7afb3c3cecbed625bae349e7fb69d.gif" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9b/98e/708/b9b98e70868604d36fd143b6309e1bac.gif" alt="image"><br><br>  In the third equation, the momentum <i>P</i> is determined, which is the product of mass and velocity: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e4/dfa/a9a/5e4dfaa9ab988d21581b88a41ecdcf14.gif" alt="image"><br><br>  In our implementation, applying a pulse to a car is simply a summation operation with the current pulse: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WagonPhysicsState::ApplyImpulse(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> AmountOfImpulse) { m_LinearMomentum += AmountOfImpulse; m_LinearSpeed = m_LinearMomentum / m_Mass; }</code> </pre> <br>  As you can see, immediately after the change in momentum, we recalculate the speed for more convenient access to this value.  This is done in the same way as in [2]. <br><br>  Now, having a basic method of calculating changes over time, we can move on to other parts of the algorithm. <br><br><h2>  High-level simulation steps for one train </h2><br>  Here is the pseudo-code of the full simulation step for a single train: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       //       ApplyDeferredImpulses (  ) //       UpdateCouplingChainConstraint (   ) //       UpdateEngineAndFrictionForces (    ) SimulationStepWithFindCollision (    ) CollisionResponse (  )</span></span></code> </pre> <br>  It is important to mention that, as written in pseudocode, each part is performed sequentially for all the cars of one train.  Part A implements a special behavior associated with the launch of the train.  Part B applies pulses from collisions.  Part B is a solution for an interconnect coupler, ensuring that we do not exceed the maximum distance for the interlock.  Part G is responsible for engine power and friction, the basic simulation step (integration) and collision handling. <br><br>  The simulation algorithm always preserves the same order of updates for train cars.  We start with the locomotive and consistently go through all the cars of the train, from first to last.  Since we can use this property in the simulator, it simplifies the formulation of calculations.  We use this feature only for contact collisions, for sequential simulation of the movement of each car and checking the collision with only one neighboring car. <br><br>  Each part of this high-level simulation cycle is discussed in detail in the following sections.  Because of the special importance of part G, we will start with it and with <i>SimulationStepWithFindCollision</i> . <br><br><h2>  Collision simulation </h2><br>  Here is the code for the <i>SimulationStepWithFindCollision</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WagonPhysicsState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimulationStepWithFindCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WagonPhysicsState InitialState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ WagonPhysicsState NewState = InitialState; NewState.BasicSimulationStep( dt ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCollision = IsCollisionWithWagonAheadOrBehind( NewState ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsCollision) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewState; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FindCollision(InitialState, dt); }</code> </pre> <br>  First, we perform a trial simulation step with a complete time change, causing <br><br><pre> <code class="cpp hljs">NewState.BasicSimulationStep( dt );</code> </pre> <br>  and checking whether any collisions are detected in the new state: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCollision = IsCollisionWithWagonAheadOrBehind( NewState );</code> </pre> <br>  If this method returns <i>false</i> , then the new computed state can be used directly.  But if a collision is detected, we perform <i>FindCollision</i> to find a more accurate time and state of physics just before the collision event.  To perform this task, we use a binary search similar to that used in [2]. <br><br>  Here is a cycle for finding a more accurate collision time and state of physics: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WagonPhysicsState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WagonPhysicsState CurrentPhysicsState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TimeToSimulate)</span></span></span><span class="hljs-function"> </span></span>{ WagonPhysicsState Result = CurrentPhysicsState; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MinTime = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MaxTime = TimeToSimulate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">0</span></span> ; step&lt;MAX_STEPS ; ++step) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TestedTime = (MinTime + MaxTime) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; WagonPhysicsState TestedPhysicsState = CurrentPhysicsState; TestedPhysicsState.BasicSimulationStep(TestedTime); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCollisionWithWagonAheadOrBehind(TestedPhysicsState)) { MaxTime = TestedTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MinTime = TestedTime; Result = TestedPhysicsState; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result; }</code> </pre> <br>  Each iteration brings us closer to the exact time of the collision.  We also know that it is necessary to check collisions with only one car, which is directly in front of the current car (or behind it, in case of reversal).  To calculate the result, the <i>IsCollisionWithWagonAheadOrBehind</i> method uses collision checking between two oriented colliders (OBB).  We check collisions in full 3D space using <i>m_WorldPosition</i> and <i>m_WorldRotation</i> from <i>WagonPhysicsState</i> . <br><br><h2>  Collision response </h2><br>  Having obtained the state of physics right before the collision event, we have to calculate the corresponding jet impulse <i>j</i> , in order to attach it to both the tractor and the trailer.  We will start by calculating for the current relative speed between cars before a collision: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image016.gif" alt="image"><br><br>  Similar relative speed <img src="http://www.gamasutra.com/db_area/images/blog/290322/image018.gif" alt="image">  after the collision event: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image020.gif" alt="image"><br><br>  Where <img src="http://www.gamasutra.com/db_area/images/blog/290322/image022.gif" alt="image">  and <img src="http://www.gamasutra.com/db_area/images/blog/290322/image024.gif" alt="image">  - velocities after application of the impulse of reaction to collision <i>j</i>  These velocities can be calculated using the pre-collision velocities and the momentum <i>j</i> as follows ( <img src="http://www.gamasutra.com/db_area/images/blog/290322/image026.gif" alt="image">  and <img src="http://www.gamasutra.com/db_area/images/blog/290322/image028.gif" alt="image">  - these are carriages masses): <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image030.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image032.gif" alt="image"><br><br>  Now we are ready to determine the coefficient of elastic recovery <i>r</i> : <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image034.gif" alt="image"><br><br>  The coefficient of elastic recovery determines how "elastic" the reaction to the collision.  The value <i>r = 0</i> means the total energy loss, the value <i>r = 1</i> - the absence of energy loss (absolute elasticity).  Substituting this equation into the previous formulas, we get <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image036.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image038.gif" alt="image"><br><br>  Order this equation to get momentum <i>j</i> : <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image040.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image042.gif" alt="image"><br><br>  Finally, we can calculate the momentum <i>j</i> : <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image044.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image046.gif" alt="image"><br><br>  In the game we use the coefficient of elastic recovery <i>r = 0.35</i> . <br><br>  We apply the impulse <i>+ j</i> to the tractor and the impulse <i>-j</i> to the trailer.  However, for the tractor we use ‚Äúpending‚Äù impulses.  Since we have already performed the integration for the tractor and do not want to change its current speed, we postpone the pulse to the next simulation frame.  Visually, this is not very noticeable, because the difference in one frame is hardly visible.  Such a ‚Äúdelayed‚Äù impulse is saved for the car and is used in part B of the next frame of the simulation. <br><br>  Video with an example of a train stop: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UmBurfAYOws" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Coupling tie </h2><br>  It is possible to perceive a connecting coupler as a limiter of the distance between the cars.  To meet the requirement of this distance limiter, we calculate and apply the appropriate impulses to change speeds. <br><br>  We start the calculation with the distance equation for the next simulation step.  For every two cars connected by a coupler, we calculate the distances they will cover during the next simulation step.  We can very easily calculate this distance using the current speed (and exploring integral equations): <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image050.gif" alt="image"><br><br>  where <i>x</i> is the distance, <i>V</i> is the current speed, and <i>t</i> is the time step of the simulation. <br><br>  Then we calculate the formula: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image052.gif" alt="image"><br><br>  Where: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image054.gif" alt="image">  - the distance that the tractor will travel at the next simulation step. <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image056.gif" alt="image">  - the distance that the trailer will cover at the next simulation step. <br><br>  If the <i>FutureChainLength is</i> greater than the maximum length of the connecting tie, then the distance limiter will be broken in the next simulation step.  Accept that <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image058.gif" alt="image"><br><br>  If the distance limiter is broken, the value of <i>d</i> will be positive.  In this case, in order to satisfy the condition of a distance limiter, we need to apply such impulses so that <i>d = 0</i> .  To establish the scale of the required impulses, use the weight of the car.  It is necessary that the lighter car moves more, and the heavier one moves less.  Assign the following factors <img src="http://www.gamasutra.com/db_area/images/blog/290322/image060.gif" alt="image">  and <img src="http://www.gamasutra.com/db_area/images/blog/290322/image062.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image064.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image066.gif" alt="image"><br><br>  Notice that <img src="http://www.gamasutra.com/db_area/images/blog/290322/image068.gif" alt="image">  .  We need the trailer to go the extra distance in the next simulation step. <img src="http://www.gamasutra.com/db_area/images/blog/290322/image070.gif" alt="image">  , and the tractor - with a distance <img src="http://www.gamasutra.com/db_area/images/blog/290322/image072.gif" alt="image">  .  To do this by applying a pulse, we need to multiply this distance by the mass divided by the time of the simulation step: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image074.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image076.gif" alt="image"><br><br>  If you use the following additional coefficient <i>C</i> <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image078.gif" alt="image"><br><br>  then you can simplify impulse formulas to <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image080.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image082.gif" alt="image"><br><br>  You can see that they have the same size, but different signs. <br><br>  After the application of both pulses, cars connected by such a coupling tie will not break the distance stop in the next simulation step.  These pulses change speeds in such a way that as a result, in the integration formulas, positions are obtained that satisfy the condition of maximum distance for the tie. <br><br>  However, even after calculating these pulses for one coupling tie, there is a possibility of breaking the maximum tie distance for other cars in the train.  We will need to perform this method several times to reduce the final result.  However, in practice it turned out that only one cycle is enough.  It is enough to obtain satisfactory overall results. <br><br>  We perform these calculations sequentially for each connecting tie in the train, starting with the locomotive.  We always apply impulses to both cars connected by a coupler.  But there is one exception to this rule: we never apply momentum to the locomotive.  We need the locomotive to maintain its speed, so the impulse is applied only to the first carriage after the locomotive.  This impulse is applied only to the trailer, which needs compensation for the entire required distance <i>d</i> (in this case we have <img src="http://www.gamasutra.com/db_area/images/blog/290322/image084.gif" alt="image">  , <img src="http://www.gamasutra.com/db_area/images/blog/290322/image086.gif" alt="image">  and <img src="http://www.gamasutra.com/db_area/images/blog/290322/image088.gif" alt="image">  ). <br><br><h2>  Correction during sharp turns </h2><br>  Since the simulation is carried out along a one-dimensional line, we have problems with perfect fit for the connecting tie on the hook when the cars move on sharp turns.  In this situation, the 1D world intersects with the 3D world of the game.  The connecting strap is located in the 3D world, but the impulses (compensating for satisfying the condition of the distance stop) are applied only in the simplified 1D world.  To correct the determination of the final position of the tie on the hook, we slightly change the <i>MaximumLengthOfCouplingChain</i> depending on the relative angle between the directions of the tractor and the tie.  The larger the angle, the shorter the maximum possible tie length.  First, we compute the scalar product of two normalized vectors: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image090.gif" alt="image"><br><br>  Where <img src="http://www.gamasutra.com/db_area/images/blog/290322/image092.gif" alt="image">  - the normalized direction of the connecting tie, and <img src="http://www.gamasutra.com/db_area/images/blog/290322/image094.gif" alt="image">  - vector of the forward direction of the tractor.  Then we use the following formula to finally calculate the distance to be subtracted from the physical length of the connecting tie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DistanceConvertedFromCosAngle = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>*clamp( (<span class="hljs-number"><span class="hljs-number">1.0f</span></span>s)<span class="hljs-number"><span class="hljs-number">-0.001f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DistanceSubtract = clamp( DistanceConvertedFromCosAngle, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span> );</code> </pre> <br>  As you can see, we do not calculate the exact value of the angle, but directly use the cosine.  This saves us some computational time and this is enough for our needs.  You can also use additional numbers based on empirical tests to limit the values ‚Äã‚Äãwithin acceptable limits.  And finally, we use the <i>DistanceSubtract</i> value to satisfy the length limiter condition for the joint tie: <br><br><pre> <code class="cpp hljs">MaximumLengthOfCouplingChain = ChainPhysicalLength - DistanceSubtract;</code> </pre> <br>  It turned out that in practice these formulas work very well.  They provide the correct hanging of the connecting tie on the hook, even on sharp turns in the route of the track. <br><br>  Now we consider a special case - the start of the train. <br><br><h2>  Train start </h2><br>  As I mentioned earlier, we do not allow the impulses of the connecting tie to change the speed of the locomotive.  However, we still need a way to simulate the effects of traction, especially when starting the train.  When the locomotive starts, it starts to pull other cars, but the locomotive itself must also slow down according to the mass of the cars.  To achieve this, we change speeds when the train accelerates from zero speed.  We start with calculations based on the law of momentum balancing.  This law states that ‚Äúthe impulse of the system is constant if external forces do not act on the system‚Äù [3].  This means that in our case the impulse <img src="http://www.gamasutra.com/db_area/images/blog/290322/image096.gif" alt="image">  before towing another car should be equal to the impulse <img src="http://www.gamasutra.com/db_area/images/blog/290322/image098.gif" alt="image">  Immediately after the tie strap pulls another car: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image100.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image102.gif" alt="image"><br><br>  In our case, we can expand this to the following formula: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image104.gif" alt="image"><br><br>  Where <img src="http://www.gamasutra.com/db_area/images/blog/290322/image106.gif" alt="image">  - weight of the <i>i-</i> th car ( <img src="http://www.gamasutra.com/db_area/images/blog/290322/image108.gif" alt="image">  - the mass of the locomotive), <img src="http://www.gamasutra.com/db_area/images/blog/290322/image110.gif" alt="image">  - the current speed of the locomotive (we assume that all already moving cars have the same speed as the locomotive), <img src="http://www.gamasutra.com/db_area/images/blog/290322/image112.gif" alt="image">  - system speed after towing (we assume that all towed cars have the same speed).  If to use the additional designation <img src="http://www.gamasutra.com/db_area/images/blog/290322/image114.gif" alt="image">  defined as <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image116.gif" alt="image"><br><br>  then you can simplify the formula as follows <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image118.gif" alt="image"><br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image112.gif" alt="image">  - this is the value we are looking for: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image120.gif" alt="image"><br><br>  With this formula, you can simply set a new speed. <img src="http://www.gamasutra.com/db_area/images/blog/290322/image112.gif" alt="image">  for the locomotive and all cars (from 2 to n), which are currently pulled by a coupling coupler. <br>  In Fig.  2 shows a schematic description of the pulse when the locomotive <img src="http://www.gamasutra.com/db_area/images/blog/290322/image108.gif" alt="image">  and two cars start to pull the third car <img src="http://www.gamasutra.com/db_area/images/blog/290322/image124.gif" alt="image">  : <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/Figure2_TheStartupOfTheTrain.png" alt="image"><br>  <i><b>Fig.</b></i>  <i><b>2.</b> Start the train.</i> <br><br>  Here's a video of the train start: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/faXgqr1xRp8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Friction </h2><br>  To calculate the friction force (the <i>m_FrictionForce</i> variable in <i>WagonPhysicsState</i> ), the formulas and values ‚Äã‚Äãchosen after a series of experiments and most relevant to the gameplay are used.  The value of the friction force is constant, but we additionally scale it according to the current speed (when the speed is below 4).  Here is a graph of the standard friction force for wagons in the game: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/Figure3_TheStandardFrictionForWagons.png" alt="image"><br>  <i><b>Fig.</b></i>  <i><b>3.</b> Standard friction force for wagons.</i> <br><br>  For disconnected cars other values ‚Äã‚Äãare used: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/Figure4_TheFrictionForDetachedWagons.png" alt="image"><br>  <i><b>Fig.</b></i>  <i><b>4.</b> Friction force for uncoupled wagons.</i> <br><br>  In addition, we wanted to give the player the ability to conveniently jump from car to car for a short period of time after disconnecting.  Therefore, we used a lower friction value and scaled it relative to the time elapsed after the car was disconnected.  The final friction value for uncoupled cars is set as follows: <br><br><img src="http://www.gamasutra.com/db_area/images/blog/290322/image132.gif" alt="image"><br><br>  where <i>t</i> is the time elapsed after the disconnect event (in seconds). <br><br>  As you can see, we do not use friction for the first three seconds, and then gradually increase it. <br><br><h2>  Last notes </h2><br>  In game trains, we added moving bumpers in front and rear of the cars.  These bumpers do not create any physical strength.  We implemented their behavior as an additional visual element.  They move according to the detected displacement of the adjacent bumper of another car. <br><br>  In addition, as you can see, we do not check collisions between different trains in the simulator.  The rail system manager is responsible for adjusting train speeds to avoid collisions.  In our simulation, collisions are checked only between cars of the same train. <br><br>  It is important to add that game sounds and special effects play a very important role in train perception.  We compute various values ‚Äã‚Äãderived from physical behavior for controlling sounds and special effects (for example, the sounds of tightening a connecting tie, bumper bumps, braking, etc.). <br><br><h2>  Total </h2><br>  We talked about our physical train simulator, created for Assassin's Creed Syndicate.  Working on this part of the game was a great pleasure and was very difficult.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the gameplay of the open world, there are many gameplay possibilities and various interactions. </font><font style="vertical-align: inherit;">The open world creates even more difficulties in providing stable and sustainable systems. </font><font style="vertical-align: inherit;">But after all the work done, it is very joyful to watch the trains moving in the game and contributing to the quality of the game process.</font></font><br><br><h2>  Thanks </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I want to thank James Carnahan of Ubisoft Quebec City and Nobuyuki Miura of Ubisoft Singapore for editing this article and useful tips. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also want to thank my colleagues from the Ubisoft Quebec City studio: Pierre Fortin, who helped me get started with train physics and inspired me to develop; Dave Tremblay for technical support; James Carnahan for all our talk of physics; Mathieu Pierrot (Matthieu Pierrot) for the inspiring approach; Maxim Begin, who was always ready to talk to me about programming; Vincent Martineau for his help. In addition, I am grateful to Martin Bedard (Marc Parenteau), Jonathan Gendron, Jonathan Gendron, Carl Dumont, Patrick Charland, Patrick Charland, Emil Uddestrand, J√©f√©lard (Patrick Charland), Emil Uddestrand, Em J√ºrden Dumont, Patrick Charland Damien Bastian), Eric Martel (Eric Martel), Steve Blezy (Steve Blezy), Patrick Legare (Patrick Legare),Guilherme Lupien, Eric Girard and everyone else who worked on Assassin's Creed Syndicate and created such an amazing game!</font></font><br><br><h2>  Reference materials </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] ‚ÄúBuffers and chain coupler‚Äù, </font></font><a href="https://en.wikipedia.org/wiki/Buffers_and_chain_coupler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://en.wikipedia.org/wiki/Buffers_and_chain_coupler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [Approx. </font><font style="vertical-align: inherit;">Per.: The Russian-language </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2581%25D1%2586%25D0%25B5%25D0%25BF%25D0%25BA%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on Wikipedia is rather superficial. </font><font style="vertical-align: inherit;">Read more about the compounds used in the formulations </font></font><a href="http://www.pomogala.ru/wiki/szepka/szepnye_ustroystva.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Andrew Witkin, David Baraff and Michael Kass, ‚ÄúAn Introduction to Physical Based Modeling‚Äù, </font></font><a href="http://www.cs.cmu.edu/~baraff/pbm/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.cs.cmu.edu/~baraff/pbm /</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] Fletcher Dunn, Ian Parberry, ‚Äú3D Math Primer for Graphics and Game Development, Second Edition‚Äù, CRC Press, Taylor &amp; Francis Group, 2011. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] David H. Eberly, ‚ÄúGame Physics. </font><font style="vertical-align: inherit;">Second Edition ‚Äù, Morgan Kaufmann, Elsevier, 2010.</font></font></div><p>Source: <a href="https://habr.com/ru/post/321086/">https://habr.com/ru/post/321086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321072/index.html">85% of employees scores on project management systems. How do we do our</a></li>
<li><a href="../321074/index.html">sudo rm -rf, or Chronicle of the incident with the database GitLab.com from 2017/01/31</a></li>
<li><a href="../321076/index.html">Powershell and Cyrillic in console applications (updated)</a></li>
<li><a href="../321078/index.html">Friday JS: How to be inspired by Smalltalk and go to hell</a></li>
<li><a href="../321082/index.html">Friday format: Is there life after the meeting?</a></li>
<li><a href="../321088/index.html">Network Controller: software-defined networks in Windows Server 2016. Part 1: features and services</a></li>
<li><a href="../321092/index.html">What Xamarin developers should know at the beginning of 2017</a></li>
<li><a href="../321094/index.html">Price Games: Strategies and Psychology of the Buyer</a></li>
<li><a href="../321096/index.html">Standard exchange of 1C-Bitrix for BASH: incremental upload of XML files from the import and offers directory</a></li>
<li><a href="../321098/index.html">Agile in small teams - how beautiful it is to break your neck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>