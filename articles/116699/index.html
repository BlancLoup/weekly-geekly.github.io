<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Streams or events</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are two ways to handle parallel requests to the server. Streaming (threaded, synchronous) servers use a multitude of simultaneously running thre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Streams or events</h1><div class="post__text post__text-html js-mediator-article">  There are two ways to handle parallel requests to the server.  Streaming (threaded, synchronous) servers use a multitude of simultaneously running threads, each of which processes a single request.  At this time event (evented, asynchronous) servers perform a single event loop that processes all requests. <br><br>  To select one of the two approaches, you need to determine the server load profile. <br><a name="habracut"></a><br>  Suppose each request requires <i>c</i> milliseconds of CPU and <i>w</i> milliseconds of real time for processing.  CPU time is spent on active computations, and real time includes all requests to external resources.  For example, a request requires 5 ms of time <i>c</i> from the CPU and 95 ms to wait for a response from the database.  The result is 100ms.  Let's also assume that the streaming server version can support up to <i>t</i> streams before scheduling and context switching problems begin. <br><br>  If each request only requires CPU time to process, the server is able to respond to at most 1000 / <i>c</i> requests per second.  For example, if each request takes 2 milliseconds of CPU time, then it will be 1000/2 = 500 requests per second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, a multi-threaded server is able to handle <i>t</i> * 1000 / <i>w</i> requests per second. <br><br>  The throughput of the streaming server is the minimum of these expressions (1000 / <i>c</i> and <i>t</i> * 1000 / <i>w</i> ).  The event server is limited only by the CPU performance (1000 / <i>c</i> ), since it uses only one thread.  Everything described above can be expressed as follows: <br><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_request_rate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, c, w)</span></span></span><span class="hljs-function">:</span></span> cpu_bound = <span class="hljs-number"><span class="hljs-number">1000.</span></span> / c thread_bound = t * <span class="hljs-number"><span class="hljs-number">1000.</span></span> / w <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'threaded: %d\nevented: %d'</span></span> % (min(cpu_bound, thread_bound), cpu_bound)</code> </pre> <br><br>  Now consider the different types of servers and see how they show themselves in a different implementation. <br><br>  For examples, I will use <i>t</i> = 100. <br><br>  Let's start with a classic example: HTTP proxy server.  This type of server requires almost no CPU time, so suppose that <i>c</i> = 0.1 ms.  Suppose that the following servers receive a delay, say <i>w</i> = 50 ms.  Then we get: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; max_request_rate(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">threaded:</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">evented:</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  Our calculations show that the streaming server will be able to process 2,000 requests per second, and event-driven 10,000. The high performance of the event server tells us that the number of streams has become a bottleneck for the streaming server. <br><br>  Another example is a web application server.  First, consider the case of an application that does not require any external resources, but makes certain calculations.  The processing time will be, say, 5 ms.  Because  no blocking calls are made, the time <i>w</i> will also be 5 ms.  Then: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; max_request_rate(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">threaded:</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-symbol"><span class="hljs-symbol">evented:</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre><br>  In this case, CPU performance was a bottleneck. <br><br>  Now imagine that the application needs to request data from an external resource and the CPU time is 0.5 ms, and the total time <i>w</i> = 100 ms. <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; max_request_rate(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">threaded:</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-symbol"><span class="hljs-symbol">evented:</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span></code> </pre><br><br>  As can be seen from simple calculations, and indeed from mathematics, a synchronous streaming implementation will not have greater performance than an asynchronous event. <br><br>  However, it should be borne in mind that the end user is primarily interested in real time, which he spends waiting for a response.  Problems begin when an application has to do something long.  For example, to make a large and complex request to the database, to carry out complex calculations, process graphics, make a request to someone else's server.  There are many examples. <br><br>  As soon as a single-threaded program serving ten thousand clients in a cycle, has to linger for the sake of one of them, for example, for a second, everyone else is waiting for this second.  If there are many such requests, no client will receive a response earlier than the total request processing time.  Cooperative multitasking in action.  In the case of streaming solutions, there is preemptive multitasking.  The system will not allow "heavy" request to spend the time of all. <br><br>  On the one hand, we have production asynchronous solutions whose bottleneck is the complexity of writing programs, since most of the existing libraries are written in blocking style.  The programmer takes responsibility for the fact that an error in one request does not affect the others. <br><br>  On the other hand, we have blocking solutions for which we are used to writing programs.  The problem of the number of supported threads can be solved with the help of specialized tools, for example, greenlet or Erlang processes.  If streaming servers reach a bar at which the number of threads will no longer be the bottleneck, they will look more attractive due to response time and reliability. </div><p>Source: <a href="https://habr.com/ru/post/116699/">https://habr.com/ru/post/116699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116691/index.html">Jokes about what Vovochka are looking for the most? April Fools' rating jokes</a></li>
<li><a href="../116694/index.html">Speech Tips</a></li>
<li><a href="../116695/index.html">MTS 945 Glonass Now Available</a></li>
<li><a href="../116697/index.html">Image Compression Algorithms</a></li>
<li><a href="../116698/index.html">"Megabit bezlimitka" for 0 rubles per month</a></li>
<li><a href="../116700/index.html">Emacs Video Course Preview</a></li>
<li><a href="../116701/index.html">April 1st on the Internet</a></li>
<li><a href="../116702/index.html">Popular: Site RSS + Facebook Statistics</a></li>
<li><a href="../116703/index.html">Statistics of musical preferences of Habr's readers</a></li>
<li><a href="../116705/index.html">Thoughts on free accounting software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>