<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Translation SDL Game Framework Series. Part 4 - SDL Tutorial: Tic Tac Toe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous lessons, we laid the groundwork for developing the game. We created a basic framework with a set of common procedures, a class for handlin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Translation SDL Game Framework Series. Part 4 - SDL Tutorial: Tic Tac Toe</h1><div class="post__text post__text-html js-mediator-article">  In previous lessons, we laid the groundwork for developing the game.  We created a basic framework with a set of common procedures, a class for handling events, and a class for working with surfaces.  In this lesson we will use our work and create the first game - Tic-tac-toe (Tic Tac Toe).  Don't worry, everything will be pretty simple.  We take the code written in the previous lessons as a basis. <br><a name="habracut"></a><br>  First of all (are we going to become serious game developers?), We need to make a small statement of work and determine the components of future tic-tac-toe.  As we know, in the tic-tac-toe there is a field of 3x3 cells in which two players alternately put <i>X</i> or <i>O.</i>  So, we need to prepare 3 images, one for the field, and one for <i>X</i> and <i>O.</i>  Note that we do not need to create 9 pictures for <i>X</i> and <i>O</i> , but only one at a time (after all, we can use them as many times as we like).  Yes, in essence, you can create only 1 image for <i>X</i> and <i>O</i> (remember about <i>SDL_Rect</i> from the second lesson? Translated, I‚Äôll stick to the original code, but if you're interested, then see my implementation under <i>linux</i> ).  We are ready to take the first step.  Let's create our field with the size of 300x300 pixels, respectively, the <i>X</i> and <i>O</i> images will be 100x100 pixels in size, i.e.  1/9 of the field.  I chose these sizes by chance.  As you probably already noticed, my screenshots are not highlighted in high resolution, but because I‚Äôm writing from a netbook =).  You can use any other sizes (and create Tic Tac Toe HD). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03d/f6b/a0d/03df6ba0d99cab65c5180c9be07e74f0.png"><br>  Field image <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cb/748/e39/4cb748e3993ac14bb20a45cbe2321fe6.png"><br>  Image with <i>X</i> and <i>O</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, there are pictures, it remains to program their download.  Open <i>CApp.h</i> and make the following changes - remove the test surface and declare 3 new ones: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL.h&gt; #include "CEvent.h" #include "CSurface.h" class CApp : public CEvent { private: bool Running; SDL_Surface* Surf_Display; private: SDL_Surface* Surf_Grid; SDL_Surface* Surf_X; SDL_Surface* Surf_O; public: CApp(); int OnExecute(); public: bool OnInit(); void OnEvent(SDL_Event* Event); void OnExit(); void OnLoop(); void OnRender(); void OnCleanup(); }; #endif</span></span></span></span></code> </pre> <br></div></div><br>  Almost similar manipulations need to be done in <i>CApp.cpp</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> CApp::CApp() { Surf_Grid = NULL; Surf_X = NULL; Surf_O = NULL; Surf_Display = NULL; Running = true; } int CApp::OnExecute() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(OnInit() == false) { return -1; } SDL_Event Event; while(Running) { while(SDL_PollEvent(&amp;Event)) { OnEvent(&amp;Event); } OnLoop(); OnRender(); } OnCleanup(); return 0; } int main(int argc, char* argv[]) { CApp theApp; return theApp.OnExecute(); }</span></span></code> </pre><br></div></div><br>  You've probably already guessed that we, too, will clean all the resulting surfaces, so open <i>CApp_OnCleanup.cpp</i> and write: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnCleanup.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> void CApp::OnCleanup() { SDL_FreeSurface(Surf_Grid); SDL_FreeSurface(Surf_X); SDL_FreeSurface(Surf_O); SDL_FreeSurface(Surf_Display); SDL_Quit(); }</span></span></code> </pre><br></div></div><br>  So, the surfaces are set, now is the time to start loading them into memory.  Open <i>CApp_OnInit.cpp</i> and make edits there - remove the test surface, add new ones, and also resize the window to 300x300 so that we do not have any empty places in the window.  And make sure that the paths to the image files are spelled correctly! <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnInit.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> bool CApp::OnInit() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Display = SDL_SetVideoMode(300, 300, 32, SDL_HWSURFACE | SDL_DOUBLEBUF)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Grid = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/grid.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_X = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/x.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_O = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/o.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } return true; }</span></span></code> </pre><br></div></div><br>  Have you noticed that I added <i>./gfx/</i> in front of the file names?  I argue: during the development of honest and large games, the number of source code files and all kinds of resource files is growing steadily, so it is most convenient to place them in different folders.  I think you agree with me =).  Now let's display our field on the screen!  Open <i>CApp_OnRender.cpp</i> and replace the display of the test surface with the field surface: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnRender.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> void CApp::OnRender() { CSurface::OnDraw(Surf_Display, Surf_Grid, 0, 0); SDL_Flip(Surf_Display); }</span></span></code> </pre><br></div></div><br>  Now you can compile the game and enjoy "the most beautiful playing field on the planet!"  Now it is important to remember 5 simple steps when working with surfaces: declare, reset, load, draw, release (memorize this mantra, because in your further development this will help avoid many mistakes, memory leaks, brakes and malfunctions of your game). <br>  Most likely you also noticed that the pictures of crosses and zeros on a pink background and thought - "And what is the author, emo?".  I hasten to convince you!  It does not matter what color we denote the background (just in this particular example, the contrast allows us to accurately determine the line between the image and the background), because later we will ‚Äúlower‚Äù the background and make it transparent using the simple and clear <i>SDL_SetColorKey</i> function.  So let's apply it!  To do this in the <i>CSurface.h</i> file write: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL.h&gt; class CSurface { public: CSurface(); public: static SDL_Surface* OnLoad(char* File); static bool OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y); static bool OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y, int X2, int Y2, int W, int H); static bool Transparent(SDL_Surface* Surf_Dest, int R, int G, int B); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  And in <i>CSurface.cpp</i> add a function: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CSurface::Transparent(SDL_Surface* Surf_Dest, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> G, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Surf_Dest == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } SDL_SetColorKey(Surf_Dest, SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGB(Surf_Dest-&gt;format, R, G, B)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br>  Consider the function in more detail.  In addition to the pointer to the original surface, three more variables are transferred to it, each of which is responsible for designating the color component from the <i>RGB</i> format (if someone is not yet up to date: R - red, G - green, B - blue; red, green and blue).  Those.  if we passed <b>255, 0, 0</b> to the function <b>,</b> then the red color would ‚Äúturn off‚Äù from the surface and become transparent. <br>  First, our function checks for the existence of the surface and, if successful, sets the color corresponding to the transferred values ‚Äã‚Äã(for example, <b>255, 0, 0</b> ) in the <i>Surf_Dest</i> surface to <i>be</i> transparent (‚Äúturns it off‚Äù).  The turn has come to understand the signature of the <i><a href="http://www.libsdl.org/docs/html/sdlsetcolorkey.html">SDL_SetColorKey</a></i> itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDL_SetColorKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SDL_Surface *surface, Uint32 flag, Uint32 key)</span></span></span></span>;</code> </pre><br><ul><li>  The first parameter defines the surface to which the function is applied; </li><li>  The second parameter sends flags meaning: <i>SDL_SRCCOLORKEY</i> - indicates that the surface needs to turn off the color transmitted by the third parameter ( <i>Uint32 key</i> ), <i>SDL_RLEACCEL</i> allows the use of <i><a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B4%25D0%25BB%25D0%25B8%25D0%25BD_%25D1%2581%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B9">RLE</a></i> image compression technology to accelerate the display of the surface.  If we pass instead of the flags "0", then in this way we can clear the value of the "switch off" color, previously set in this surface; </li><li>  The third parameter sets the value of the ‚Äúswitched off‚Äù color, calculated using <i><a href="http://www.libsdl.org/docs/html/sdlmaprgb.html">SDL_MapRGB</a></i> , which searches for the most suitable color in the format of the transmitted surface (you know that the color formats are different from each other, and this function greatly helps us to ‚Äúfriends‚Äù with them). </li></ul><br>  Well, that's all ready, it remains to apply the function to our surfaces.  Open <i>CApp_OnInit.cpp</i> and write: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnInit.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> bool CApp::OnInit() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Display = SDL_SetVideoMode(300, 300, 32, SDL_HWSURFACE | SDL_DOUBLEBUF)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Grid = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/grid.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_X = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/x.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_O = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"./gfx/o.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } CSurface::Transparent(Surf_X, 255, 0, 255); CSurface::Transparent(Surf_O, 255, 0, 255); return true; }</span></span></code> </pre><br></div></div><br>  So all the surfaces are set up, things are easy to draw.  First of all, we need an array of nine components that will store the type of the area to display a cross or zero.  The zero element will store the type for the upper left quadrant, the first for the upper middle, the second for the right upper, etc.  to the bottom right.  You need to register this array in <i>CApp.h</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL.h&gt; #include "CEvent.h" #include "CSurface.h" class CApp : public CEvent { private: bool Running; SDL_Surface* Surf_Display; private: SDL_Surface* Surf_Grid; SDL_Surface* Surf_X; SDL_Surface* Surf_O; private: int Grid[9]; public: CApp(); int OnExecute(); public: bool OnInit(); void OnEvent(SDL_Event* Event); void OnExit(); void OnLoop(); void OnRender(); void OnCleanup(); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  We know that each cell of our grid can be either empty or contain a cross or a toe.  In order not to use all sorts of " <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">magic numbers</a> ", we are wise to use the so-called  enumeration (enum), more about which you can read <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D1%258F%25D0%25B5%25D0%25BC%25D1%258B%25D0%25B9_%25D1%2582%25D0%25B8%25D0%25BF">here</a> .  Thus, we will assign meaningful names to our cell states and will always know that <i>GRID_TYPE_NONE</i> = 0, <i>GRID_TYPE_X</i> = 1, and <i>GRID_TYPE_O</i> = 2. Go back to <i>CApp.h</i> and add the enumeration below the declaration of the cell coordinate array: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { GRID_TYPE_NONE = <span class="hljs-number"><span class="hljs-number">0</span></span>, GRID_TYPE_X, GRID_TYPE_O };</code> </pre><br></div></div><br>  I hope you are well versed in the code of our framework and know exactly where the file to write the code I proposed.  Just sometimes I quote the code completely, but I can just say where to place a piece of code, and then I hope for your competence.  We have almost everything ready, it remains to provide a function for cleaning our playing field.  Let's declare the <i>reset</i> function in <i>CApp.h</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br></div></div><br>  In <i>CApp.cpp</i> list: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CApp::Reset() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>;i++) { Grid[i] = GRID_TYPE_NONE; } }</code> </pre><br></div></div><br>  This cycle runs through the grid cells and clears them by setting the value of <i>GRID_TYPE_NONE</i> .  It‚Äôs best for us to call this cleanup at the very start of the game, so, open <i>CApp_OnInit.cpp</i> and make the following changes: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnInit.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//... ... CSurface::Transparent(Surf_X, 255, 0, 255); CSurface::Transparent(Surf_O, 255, 0, 255); Reset();</span></span></code> </pre><br></div></div><br>  Now add the ability to draw crosses and zeros.  Define another function in <i>CApp.h</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type)</span></span></span></span>;</code> </pre><br></div></div><br>  Well and, respectively, in <i>CApp.cpp</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CApp::SetCell(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ID, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ID &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || ID &gt;= <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Type &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || Type &gt; GRID_TYPE_O) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; Grid[ID] = Type; }</code> </pre><br></div></div><br>  This function, as we see, takes 2 arguments - the ID of the cell being changed and the type to which its value should be changed.  Also implemented a primitive check for the correctness of the passed parameters in order to avoid crashes of the game due to the output of the array.  Go directly to the drawing: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnRender.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X = (i % <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y = (i / <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Grid[i] == GRID_TYPE_X) { CSurface::OnDraw(Surf_Display, Surf_X, X, Y); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Grid[i] == GRID_TYPE_O) { CSurface::OnDraw(Surf_Display, Surf_O, X, Y); } }</code> </pre><br></div></div><br>  It's a little more complicated here.  First, we start a cycle in which we run through all the cells in the grid of the playing field, and then, depending on the type of ID, we display a cross or a zero.  And we find the coordinates to display the cross and zero as follows: for the X-coordinate, divide the iterator by 3 with the remainder and multiply by 200 (the size of one displayed cell), eventually getting 0 for i = 0, 1 for 1, 2 for 2, 0 for 3, etc .;  for the Y-coordinate, divide the iterator by 3 without remainder and multiply again by 200, getting 0 for 0, 1 and 2, etc.  After checking the type of cell being drawn, we display it.  Now we just have to override the event handling function and add the variable responsible for the player.  Open <i>CApp.h</i> and add the <i>OnLButtonDown</i> function just below the <i>OnEvent</i> function: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLButtonDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mY)</span></span></span></span>;</code> </pre><br></div></div><br>  Now change the <i>CApp_OnEvent</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnEvent.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CApp::OnLButtonDown(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mX, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mY) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ID = mX / <span class="hljs-number"><span class="hljs-number">100</span></span>; ID = ID + ((mY / <span class="hljs-number"><span class="hljs-number">100</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Grid[ID] != GRID_TYPE_NONE) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurrentPlayer == <span class="hljs-number"><span class="hljs-number">0</span></span>) { SetCell(ID, GRID_TYPE_X); CurrentPlayer = <span class="hljs-number"><span class="hljs-number">1</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ SetCell(ID, GRID_TYPE_O); CurrentPlayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br></div></div><br>  With this code, we check to see if the player‚Äôs cell has already been filled in, and if not, fill it with a cross or zero (depending on the player), and then switch players (i.e. if the player ID is CurrentPlayer = 1 the next button click will be interpreted as a player click with ID 0).  Open <i>CApp.h</i> and add a variable responsible for the player: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentPlayer;</code> </pre><br></div></div><br>  And do not forget to reset it in <i>CApp.cpp</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">CApp::CApp() { CurrentPlayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; Surf_Grid = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Surf_X = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Surf_O = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Surf_Display = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br>  Well that's all!  The game is finally ready, so let's play!  Compile and enjoy!  Congratulations!  You have come a long way and deserved rest. <br>  In the future, you can experiment and add inscriptions at the end of the game ‚ÄúX Won‚Äù, ‚ÄúO won‚Äù, implement the game modes for man VS man, man VS computer, etc.  Dare, because you already have the basis for the game! <br><br>  But the video of working tic-tac-toe <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/c4i_Dh7ZsOY%3Ffeature%3Doembed&amp;xid=17259,15700002,15700021,15700186,15700190,15700253,15700259&amp;usg=ALkJrhggC4J2aSQ69aNf829J6-6opOppUA" frameborder="0" allowfullscreen=""></iframe><br><br>  My version <a href="https://github.com/m0sk1t/TicTacToe">on GitHub'e</a> . <br><br>  Links to source code: <br><ul><li>  <a href="">Win32</a> </li><li>  <a href="">* nix</a> </li></ul><br><br>  Links to all lessons: <br><ul><li>  <a href="http://habrahabr.ru/post/166875/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/166875/">Part 1 - The Basics of SDL</a> </li><li>  <a href="http://habrahabr.ru/post/167035/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/167035/">Part 2 - Coordinates and Mapping</a> </li><li>  <a href="http://habrahabr.ru/post/167245/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/167245/">Part 3 - Events</a> </li><li>  Developing a game framework.  Part 4 - Tic-Tac-Toe </li><li>  <a href="http://habrahabr.ru/post/169197/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/169197/">Part 5 - Animation</a> </li><li>  <a href="http://habrahabr.ru/post/169295/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/169295/">Part 6 - Entities</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/167443/">https://habr.com/ru/post/167443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167423/index.html">DeltaMaker - another 3D printer</a></li>
<li><a href="../167427/index.html">300 screens, one admin - how Digital Signage works</a></li>
<li><a href="../167431/index.html">New PHP extension allows you to add arbitrary methods to scalars</a></li>
<li><a href="../167437/index.html">Creating a sprite engine</a></li>
<li><a href="../167441/index.html">Arduino: Robo-arm on two servos</a></li>
<li><a href="../167445/index.html">Saturday morning reluctant to sleep</a></li>
<li><a href="../167449/index.html">Say a good word about high salary</a></li>
<li><a href="../167451/index.html">Top 5 annoying moments in the work of the programmer</a></li>
<li><a href="../167453/index.html">Google allocates millions of dollars to new Chrome hacking contest</a></li>
<li><a href="../167455/index.html">Unbound Jailbreak for iOS 6.1 coming out on Sunday</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>