<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of using WxPython to create a node interface. Part 2: Handling Mouse Events</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a small series of articles will be described the use of WxPython to solve a very specific task of developing a user interface, and even how to make...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An example of using WxPython to create a node interface. Part 2: Handling Mouse Events</h1><div class="post__text post__text-html js-mediator-article">  In a small series of articles will be described the use of WxPython to solve a very specific task of developing a user interface, and even how to make this solution universal.  This tutorial is designed for those who have already begun to study this library and want to see something more complex and holistic than the simplest examples (although everything will start from relatively simple things). <br><br>  In the last part, I talked about the task and began to describe the process of implementation, or rather the rendering of objects.  Now it's time to implement user interaction. <br><br>  <a href="http://habrahabr.ru/post/201336/">Part 1: Learning to draw</a> <br>  <a href="http://habrahabr.ru/post/201538/">Part 2: Handling Mouse Events</a> <br>  <a href="http://habrahabr.ru/post/201608/">Part 3: We continue to add features + keyboard handling</a> <br>  <a href="http://habrahabr.ru/post/201784/">Part 4: Implementing Drag &amp; Drop</a> <br>  <a href="http://habrahabr.ru/post/201930/">Part 5: We connect nodes</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Who cares, welcome under the cat‚Ä¶ <br><a name="habracut"></a><br><br>  Let me remind you that the last time we got a simple program that draws simple notes on the canvas (for now, rectangles with text).  It's time to make the nodes moveable. <br><br><h4>  4. Highlighting objects when you hover over them </h4><br>  But before realizing the movement of the nodes, we will make one useful feature: highlighting the object when the cursor is moved over it.  Parts of this feature will later come in handy when implementing the rest of the functionality.  To implement, we need to perform 3 steps: <br>  1) Track cursor movement <br>  2) Find and save the topmost object under the cursor <br>  3) Render the selection of this object <br><br>  To track the cursor movement, we need to add a handler for the corresponding event to the canvas class: <br><pre><code class="python hljs">self.Bind(wx.EVT_MOTION, self.OnMouseMotion)</code> </pre> <br>  Now when you move the cursor, the method will be called: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMotion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, evt)</span></span></span><span class="hljs-function">:</span></span> pos = self.CalcUnscrolledPosition(evt.GetPosition()).Get() self._objectUnderCursor = self.FindObjectUnderPoint(pos) self.Render()</code> </pre><br>  Three actions take place here: since the cursor coordinates are relative to the window, we first need to translate them into the coordinates of the canvas (since we have scrolled), then we need to find the corresponding object and update the image so that the object lights up on which the user has moved the cursor .  Objects under the cursor are searched by the method: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindObjectUnderPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#Check all objects on a canvas. Some objects may have multiple components and connections. for obj in reversed(self._canvasObjects): objUnderCursor = obj.ReturnObjectUnderCursor(pos) if objUnderCursor: return objUnderCursor return None</span></span></code> </pre><br>  Everything is trivial and not very.  On the one hand, we simply go through all the objects and look for the one that is under the cursor.  And we do this in reverse order, because we want to get the top one, i.e.  last added object.  On the other hand, we use the ‚ÄúReturnObjectUnderCursor‚Äù method, which returns an object to us, although we seem to know which object we are checking.  This is done with a margin for the future, so that you can make nodes that contain other objects in themselves (for example: connections with other nodes or angles to change the size of the node).  So far this method at our node just checks if the cursor is in a rectangle: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnObjectUnderCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; self.position[<span class="hljs-number"><span class="hljs-number">0</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; self.position[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; self.position[<span class="hljs-number"><span class="hljs-number">0</span></span>]+self.boundingBoxDimensions[<span class="hljs-number"><span class="hljs-number">0</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; self.position[<span class="hljs-number"><span class="hljs-number">1</span></span>]+self.boundingBoxDimensions[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self</code> </pre><br>  So, we always know what object is under the cursor, it remains to somehow select it when rendering, which will be done by this code during rendering: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._objectUnderCursor: gc.PushState() self._objectUnderCursor.RenderHighlighting(gc) gc.PopState()</code> </pre><br>  It remains to add the code for rendering the backlight to the node: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderHighlighting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gc)</span></span></span><span class="hljs-function">:</span></span> gc.SetBrush(wx.Brush(<span class="hljs-string"><span class="hljs-string">'#888888'</span></span>, wx.TRANSPARENT)) gc.SetPen(wx.Pen(<span class="hljs-string"><span class="hljs-string">'#888888'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, wx.DOT)) gc.DrawRectangle(self.position[<span class="hljs-number"><span class="hljs-number">0</span></span>]<span class="hljs-number"><span class="hljs-number">-3</span></span>, self.position[<span class="hljs-number"><span class="hljs-number">1</span></span>]<span class="hljs-number"><span class="hljs-number">-3</span></span>, self.boundingBoxDimensions[<span class="hljs-number"><span class="hljs-number">0</span></span>]+<span class="hljs-number"><span class="hljs-number">6</span></span>, self.boundingBoxDimensions[<span class="hljs-number"><span class="hljs-number">1</span></span>]+<span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Here we use a transparent brush, so that when rendering, do not overwrite what was previously rendered (i.e., the node itself). <br>  The result is this picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/3bb/70b/0b33bb70b3cff7d845c27172c2553982.png"><br>  Cursor had to finish after the fact, so it‚Äôs not traditional :) <br>  I will not give here all the code, who cares, this one here <a href="https://github.com/Akson/MoveMe/tree/a15502a448a958969da13a62bf4cb3f47271da06">on GitHub</a> contains it. <br><br><h4>  5. A little refactoring and adding interfaces </h4><br>  And again, we will not postpone for a long time the implementation of the movement of our objects, this time for a small refactoring.  If this framework has to be universal, it means that the nodes here can be all sorts of different, including unmovable ones (for example, connections between objects that are defined by the objects themselves or some kind of node components, and even if it doesn‚Äôt matter what people will think of).  So we need some kind of universal way of describing what can and cannot be done with nodes.  And in general, I would like to introduce some kind of universal interface for nodes.  But now we will not use abc, zope.interface or something like that, but just make the base class for the objects on the canvas: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanvasObject</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#Supported operations self.clonable = False self.movable = False self.connectable = False self.deletable = False self.selectable = False def Render(self, gc): """ Rendering method should draw an object. gc: GraphicsContext object that should be used for drawing. """ raise NotImplementedError() def RenderHighlighting(self, gc): """ RenderHighlighting method should draw an object with a highlighting border around it. gc: GraphicsContext object that should be used for drawing. """ raise NotImplementedError() def ReturnObjectUnderCursor(self, pos): """ ReturnObjectUnderCursor method returns a top component of this object at a given position or None if position is outside of all objects. pos: tested position as a list of x, y coordinates such as [100, 200] """ raise NotImplementedError()</span></span></code> </pre><br>  As you can see, we have a number of standard actions that are not supported by default.  But there are 3 methods that should be in any object on the canvas.  What is logical, why do we need such objects on the canvas that we cannot see (Render), and how we will see, so poke them with the cursor (ReturnObjectUnderCursor, RenderHighlighting).  And here we remember that we want to move our nodes, i.e.  they must be relocatable, and for this there is a special class: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MoveMe.Canvas.Objects.Base.CanvasObject <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CanvasObject <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MovableObject</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CanvasObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> super(MovableObject, self).__init__() self.position = position self.movable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br>  Everything is simple, this class allows movement and also adds such a useful property as a position, so moving something from one position to another without having this position itself is difficult.  Now the definition of our node has become a bit more complicated, since it has become the heir of our new classes, although, in general, it‚Äôs still the same good old node: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MoveMe.Canvas.Objects.Base.CanvasObject <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CanvasObject <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MoveMe.Canvas.Objects.Base.MovableObject <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MovableObject <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleBoxNode</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MovableObject, CanvasObject)</span></span></span><span class="hljs-class">:</span></span> ...........</code> </pre><br><h4>  6. Move Nodes </h4><br>  Here we come to the long-awaited implementation of moving nodes.  To do this, we need to do 2 basic steps: remember which object the user started dragging (i.e. what object was under the cursor at the moment of pressing the left mouse button) and update the position of the object when moving the cursor until the user releases the mouse button. <br>  The first action is performed in: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseLeftDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, evt)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._objectUnderCursor: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._objectUnderCursor.movable: self._lastDraggingPosition = self.CalcUnscrolledPosition(evt.GetPosition()).Get() self._draggingObject = self._objectUnderCursor self.Render()</code> </pre><br>  We simply remember the position of the cursor and the current object under the cursor as moved, if it supports the movement.  Unless there is still a check for the presence of an object under the cursor, since there is no point in moving the void.  The second part is a bit more interesting. <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMotion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, evt)</span></span></span><span class="hljs-function">:</span></span> pos = self.CalcUnscrolledPosition(evt.GetPosition()).Get() self._objectUnderCursor = self.FindObjectUnderPoint(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> evt.LeftIsDown(): self._draggingObject = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> evt.LeftIsDown() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> evt.Dragging() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self._draggingObject: dx = pos[<span class="hljs-number"><span class="hljs-number">0</span></span>]-self._lastDraggingPosition[<span class="hljs-number"><span class="hljs-number">0</span></span>] dy = pos[<span class="hljs-number"><span class="hljs-number">1</span></span>]-self._lastDraggingPosition[<span class="hljs-number"><span class="hljs-number">1</span></span>] newX = self._draggingObject.position[<span class="hljs-number"><span class="hljs-number">0</span></span>]+dx newY = self._draggingObject.position[<span class="hljs-number"><span class="hljs-number">1</span></span>]+dy <span class="hljs-comment"><span class="hljs-comment">#Check canvas boundaries newX = min(newX, self.canvasDimensions[0]-self._draggingObject.boundingBoxDimensions[0]) newY = min(newY, self.canvasDimensions[1]-self._draggingObject.boundingBoxDimensions[1]) newX = max(newX, 0) newY = max(newY, 0) self._draggingObject.position = [newX, newY] #Cursor will be at a border of a node if it goes out of canvas self._lastDraggingPosition = [min(pos[0], self.canvasDimensions[0]), min(pos[1], self.canvasDimensions[1])] self.Render()</span></span></code> </pre><br>  The first check ensures that if the user at some point drives the mouse with the left button released, it means that he is already moving nothing.  This is better than stopping the movement on a button release event, since the cursor may be outside the window and then we will not receive this event.  Then we check that we are really carrying something and begin to consider the relative movement of our object.  At the moment we do not think about what is happening with the keyboard (whether Ctrl is pressed or something else, it will be later).  There is still a check for going beyond the limits of canvas.  With this test, everything is not entirely simple and clear.  On the one hand, if the size of the canvas is fixed, then everything should be so, but on the other hand, it would be nice to stretch the canvass along the way (although this is not the ideal solution).  In general, at the moment, the size of the canvas will be fixed and the nodes will rest against the borders of the canvas. <br>  That's all, now we can move objects along the canvas.  The code lives in <a href="https://github.com/Akson/MoveMe/tree/28f6713f0f0d445e1ffb529ef509b3c7a06ee088">this commit on GitHub</a> .  And it looks like this: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/kTmYpz-goHQ%3Ffeature%3Doembed&amp;xid=17259,15700002,15700023,15700186,15700190,15700253&amp;usg=ALkJrhhxYT4fg2kvoNINGBbbp6Fa0ZuvJA" frameborder="0" allowfullscreen=""></iframe><br><br>  PS: Write about typos in PM. </div><p>Source: <a href="https://habr.com/ru/post/201538/">https://habr.com/ru/post/201538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201524/index.html">Release of Tizen platform version 2.2.1</a></li>
<li><a href="../201526/index.html">Secure mail and messages for yourself and others</a></li>
<li><a href="../201528/index.html">How to understand the assembler for AVR</a></li>
<li><a href="../201532/index.html">Another way to optimize the Youtube interface</a></li>
<li><a href="../201534/index.html">ABC sorting</a></li>
<li><a href="../201544/index.html">What styles of code design does the Gietgab audience prefer?</a></li>
<li><a href="../201546/index.html">How to understand the assembler. Part 2. Microcontroller</a></li>
<li><a href="../201548/index.html">Programming language surveys (+ update)</a></li>
<li><a href="../201550/index.html">Impressions of using RavenDB</a></li>
<li><a href="../201552/index.html">The digest of news from the world of mobile development in the last week ‚Ññ31 (November 4‚Äî10, 2013)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>