<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Is it possible to steal money from mobile banking? Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the topic of mobile banking security, which we started in the first part . Probably many have already guessed, this article will focus on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Is it possible to steal money from mobile banking? Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/027/45d/dc602745dc25bbfde7f8d9d404aca8e4.jpg" alt="image"><br>  We continue the topic of mobile banking security, which we started in the <a href="http://habrahabr.ru/company/dsec/blog/229373/">first part</a> .  Probably many have already guessed, this article will focus on the man-in-the-middle attack, MitM.  This attack was not chosen by chance.  If the data channel between the mobile banking application and the server is controlled by an attacker, the latter can steal money from the client‚Äôs account, that is, cause direct financial damage.  But first things first. <br><br><a name="habracut"></a><br>  In general, to conduct this study we were prompted by two reasons.  First, from project to project, we see a recurring sad picture of vulnerabilities.  According to the results of the audit, it turns out another short film with MB hacking for the customer.  Secondly, two very interesting publications were published: <a href="http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf">‚ÄúThe Most Dangerous Code in the World: Validating SSL Certi Ô¨Å cates in Non-Browser Software‚Äù</a> and <a href="http://android-ssl.org/files/p49.pdf">‚ÄúRethinking SSL Development in An App ed Ed World‚Äù</a> - we advise you to read them.  But first things first. <br><br><h4>  Man-in-the-middle </h4><br>  The main scenarios for the implementation of the attack <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BA_%25D0%25BF%25D0%25BE%25D1%2581%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B5">"MitM"</a> : <br>  - Connecting a user to a fake Wi-Fi access point.  This is the most common and real scenario MitM-attacks.  It can be easily reproduced in a cafe, shopping or business center.  Software to conduct this attack is easy to find in the public domain. <br>  - Connection to a fake base station operator.  This scheme is becoming more accessible to the masses due to the rich choice of hardware and software and its low cost.  The situation must be taken under control as quickly as possible. <br>  - Using infected network equipment.  The infection of network equipment means not only the execution of malicious code on it, but also its targeted malicious reconfiguration, for example, through a vulnerability.  We already know many examples of the implementation of such attacks. <br>  It is worth saying that these are just a few of the many possible scenarios.  The main thing that is necessary for an attacker is to ensure that the network traffic from the victim to the server goes through the host under his control. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Malicious SOHO routers <br><br>  A cool find and <a href="http://www.team-cymru.com/ReadingRoom/Whitepapers/SOHOPharming.html">study</a> from the guys from Team Cymru - they found malware that, when getting into the internal network, changed the DNS settings to their own.  What does it mean?  Now that the sites controlled by the attacker were redirected not only to the internal machines, but also to all the mobile devices that cling to these routers via WiFi!  And here we have such an intricate MiTM. </blockquote><br>  The specifics of mobile devices with Wi-Fi-networks: <br>  - Automatic connection to known Wi-Fi networks (based on PNL, Preferred Network List) <br>  o Not everywhere can be disabled or configured in any simple way. <br>  - Network identification is based on SSID (network name) and security settings <br>  - If there are several known networks, each OS has a different connection choice. <br><br>  The attacker can deploy its own Wi-Fi network, completely identical to the known network for a mobile device.  As a result, the device will automatically connect to such an access point and will work through it.  For example, using the <a href="http://www.theta44.org/karma/">KARMA</a> program.  This scheme and the lack of simple management of trusted networks simplifies the implementation of ‚ÄúMitM‚Äù for an attacker. <br><br><h4>  Channel protection </h4><br>  Before breaking, let's examine what can prevent us from doing this. <br>  A secure channel is a channel in which encryption and integrity monitoring is used to ensure data transfer.  But you should not forget that not all cryptographic algorithms remain stable and the use of cryptography does not always occur correctly. <br><br>  Channels can be divided into 3 main groups: <br>  - Open <br>  Being in the same network with the victim, the attacker sees all the client-server interaction in the clear. <br>  - Protected by non-standard methods <br>  As our practice shows, this is not the best solution: it leads to a number of errors that lead to the compromise of the transmitted data. <br>  - Protected by standard methods <br>  The most common option is SSL / TLS <br><img src="https://habrastorage.org/getpro/habr/post_images/fd7/2f2/6db/fd72f26db1d95248507cbc3176bd2b9f.jpg" alt="image"><br>  Certificate Verification Process <br><br>  To ensure the efficiency of this scheme, there are many root certificates (CA) on the device, which are stored in a special store of trusted root certificates, and everything that they have signed is trusted for the device. <br><br>  Certificates are divided into: <br>  ‚Ä¢ system - pre-installed in the system <br>  ‚Ä¢ custom - set by user <br>  Verification of certificates goes on a chain: from sent to the device to the root (CA), which the device trusts.  Next come the hostname, revocation, and so on.  Further checks may vary (this, by the way, can also be played when attacking a particular application) depending on the implementation of the library, OS, etc. <br><br><h4>  SSL and Android </h4><br>  In Android OS up to version 4.0, all certificates were stored in a single file - Bouncy Castle Keystore File. <br><br>  File: /system/etc/security/cacerts.bks <br><br>  It was impossible to change it without root privileges, and the OS did not provide any ways to modify it.  Any certificate change (addition, revocation) required an OS update. <br>  Starting with the version of Android 4.0, the approach to working with certificates has changed.  Now all certificates are stored in separate files, and if necessary, you can remove them from trusted ones. <br><br>  System files are stored in: / system / etc / security / cacerts <br>  Custom stored in: / data / misc / keychain / cacerts-added <br><br>  To view certificates in Android OS, go to Settings -&gt; Security -&gt; Trusted certificates (Settings -&gt; Security -&gt; Trusted credentials). <br>  The number of system certificates in different versions of Android: <br>  - Android 4.0.3: 134 <br>  - Android 4.2.2: 140 <br>  - Android 4.4.2: 150 <br>  The number of certificates may also vary from manufacturer to manufacturer and for each device model. <br>  To install a user certificate in Android OS, you need to upload the root certificate to the SD card and go to Settings -&gt; Security -&gt; Install from a memory card or via MDM (DevicePolicyManager) in Android, starting with version 4.4.  Making a user install a certificate using social engineering is possible, but not very easy. <br><br><h4>  SSL and iOS </h4><br>  On iOS, you cannot view embedded certificates, and you can only get information about them from <a href="http://support.apple.com/kb/HT5012%3Fviewlocale%3Den_US">the</a> Apple <a href="http://support.apple.com/kb/HT5012%3Fviewlocale%3Den_US">website</a> .  To view user certificates, go to Settings -&gt; General -&gt; Profile (s). <br><br>  System stored in: /System/Library/Frameworks/Security.framework/certsTable.data <br>  Custom stored at: /private/var/Keychains/TrustStore.sqlite3 <br>  The number of system certificates in different versions of iOS (The number of certificates can be updated): <br>  - iOS 5: 183 <br>  - iOS 6: 183 <br>  - iOS 7: 211 <br><br>  On iOS, there are several ways to install user certificates: <br>  - Via Safari browser - you need to follow the link on which the certificate with the .pem extension or the configuration profile with the .profile extension rests <br>  - By attaching the certificate to the E-mail <br>  - Through MDM API <br><br>  It can be seen that installing a user certificate through social engineering on iOS is much easier than on Android. <br><br>  Possible vectors for installing certificates through social engineering: <br>  1) The user does everything himself because of ignorance.  For example, promises free access to the Internet at a particular access point after installing a specific certificate;) <br>  2) Acquired second hand phone with embedded malicious certificate <br>  3) The certificate is installed on an iOS phone in a few seconds if it happens to be in the hands of an attacker (for example, he asked to call) <br>  4) Network equipment with a ‚Äúgood‚Äù certificate - here the NSA and everything.  In the process of viewing the system certificates were seen certificates from Japan and America.  That is, they can conduct MiTM, re-signing their own certificate, and the device does not even ‚Äúprick‚Äù about the attack (and the backdoor is not needed in the crypt).  Ours are not there = ( <br><br><h4>  Vulns, bugs, errors, ... </h4> <br>  In this section, we will look at what problems exist in the interaction between the client application (in our case, the mobile banking application) and the server. <br>  All the examples cited here are real, we received this information in the process of auditing the security of mobile banking applications. <br><br>  - No HTTPS (SSL) <br>  No matter how surprisingly it sounded, a year ago we met mobile banking applications in which all communication, including financial transactions, was carried out using the HTTP protocol: authentication, transfer data ‚Äî everything was open.  This means that the attacker, in order to obtain financial gain, needed to simply be with the victim on the same network and have the minimum qualifications.  Then, for a successful attack, it was enough to correct the numbers of the target accounts and, if desired, the amount. <br>  As for the interaction of the application with third-party services, compared to last year, the situation has become a little better, but still most of them go for additional information for their operation through an open channel, which can be easily affected by an attacker.  This information is usually associated with: <br>  ‚Ä¢ bank news <br>  ‚Ä¢ ATM location <br>  ‚Ä¢ currency exchange rate <br>  ‚Ä¢ social networks; <br>  ‚Ä¢ program statistics for developers; <br>  ‚Ä¢ advertising <br><br>  At best, the attacker can simply misinform the victim, and at worst, they can inject their own code that runs on the victim's device, which will later help steal authentication data or money.  The reason is that <a href="http://habrahabr.ru/company/dsec/blog/217715/">the Android OS allows you to</a> load code from the Internet and then execute it.  Such a code, the attacker may, under certain circumstances, to introduce into the public channel.  Or another situation where the developer transmits the crash dump program through the open channel, and there you can find the username and password from MB and other interesting information. <br><br>  - Own encryption <br>  This option we also met both in practice and in the research process.  Its use is incomprehensible to us, but, according to our assumptions, it may be associated with well-established internal processes of the bank.  At the same time, SSL traffic is not additionally wrapped by the developer. <br>  As our practice shows, the use of our own encryption does not lead to good.  Sometimes it is not even encryption, but simply its own binary protocol, which, at first glance, seems incomprehensible, encrypted.  So after a little manual analysis, MiTM is also possible. <br><br>  - Incorrect use of SSL <br>  The most common class of errors is the incorrect use of SSL.  Most often it is associated with the following reasons: <br>  ‚Ä¢ Lack of customer test infrastructure <br>  Sometimes a customer cannot, for one reason or another, provide a good test infrastructure.  And this leads to the fact that developers have to go to a number of tweaks to verify the correctness of the application. <br>  ‚Ä¢ developer negligence <br>  This item is partially related to the previous one, and leads to the fact that the development process uses a different debugging code to speed up the testing process.  And before the release of the program about this code is forgotten. <br>  ‚Ä¢ Use of vulnerable frameworks <br>  Often, developers use various frameworks to simplify.  In other words, they use someone else's code, the low-level part of which is often hidden and inaccessible.  This code also contains vulnerabilities, which developers often do not even guess.  This is especially true in light of the active cross-platform development for mobile devices.  Example, vulnerability in <a href="http://www.securify.nl/advisory/SFY20140301/nss_2014_affected_by_remote_code_execution___insecure_certificate_validation.html">Appcelerator Titanium</a> or Heartbleed (CVE-2014-0160) in OpenSSL (you can also attack the client - <a href="https://github.com/Lekensteyn/pacemaker">exploit</a> ). <br>  ‚Ä¢ Developer errors <br>  The developer can use different libraries for working with SSL, each has its own specifics, and it should be taken into account.  So, with the transition from the library to the library, the developer can incorrectly use a constant during initialization or override a function with his own. <br><br>  The main errors when working with SSL: <br>  - Disabling checks (debug API) <br>  - Incorrect redefinition of standard handlers to your own <br>  - Incorrect configuration of API calls <br>  - Weak encryption options <br>  - Using the vulnerable version of the library <br>  - Incorrect handling of call results <br>  - Lack of verification for the host name or the use of incorrect regular expressions for verification <br><br>  Unconditional classic - disable certificate validation! <br><img src="https://habrastorage.org/getpro/habr/post_images/306/1de/4eb/3061de4ebe59581a6e7f062651e409cd.png" alt="image"><br><br>  Unconditional classic - disable the verification of the host name in the certificate! <br><img src="https://habrastorage.org/getpro/habr/post_images/766/9e6/932/7669e6932562e39ab8281f9d92c23904.png" alt="image"><br><br><h4>  Compromise of the root certificate </h4><br>  When using SSL, there is a dependency on root certificates.  We can not exclude the possibility of their compromise - remember, for example, the latest incidents with Bit9, DigiNator and Comodo.  Do not forget about the certificates of other countries, companies for which traffic can be said to be open. <br>  As already shown, devices have a large number of CA certificates, and if any of them are compromised, almost all SSL traffic for the device is compromised. <br><br>  If the CA certificate is compromised: <br>  1) User can delete certificate from trusted <br>  a.  In the Android OS, the user can do this with both embedded certificates and user certificates. <br>  b.  In iOS, a user can only delete user certificates. <br>  2) The OS developer may release an update. <br>  3) The certificate issuer may revoke its certificate.  The certificate verification mechanism can dynamically verify this. <br>  a.  Android does not support either CRL or OCSP <br>  b.  iOS uses OCSP <br><br>  It is difficult to hope that the user will manage root certificates himself.  So the only way is to wait for the OS update.  OCSP is not implemented everywhere.  The user is vulnerable during the time between compromise and system update. <br>  CA certificates are of different types - more precisely, they can be used for different purposes (mail encryption, code signing, etc.), but they are usually stored in the same secure storage and can be used to verify trust in an HTTPS connection.  Unfortunately, the correct verification of the purpose of the certificate is not implemented everywhere.  Thus, an attacker can obtain a legitimate certificate from the issuing center for the same purpose, and use a MitM attack to establish an HTTPS connection during the process. <br>  In addition, when the user is working in the browser, he may notice actions with a suspicious certificate on the red padlock icon in the address bar.  In the same situation, when working through the application, the user will not be informed in any way, unless the developer has foreseen this in advance, which makes the attack hidden. <br><br><h4>  SSL pinning </h4><br>  SSL Pinning approach can be used to protect against compromise of root system certificates and specially embedded user certificates. <br>  Pinning is the process of associating a host with its expected X509 certificate or public key.  The approach is to embed a certificate or public key, which we trust when interacting with the server, directly into the application and refusing to use the built-in certificate store.  As a result, when working with our server, the application will check the validity of the certificate only on the basis of the cryptographic primitive stitched in it. <br>  Applications for MB are great for using SSL Pinning, as developers know exactly which servers will connect to the application, and the list of such servers is small. <br><br>  SSL Pinning comes in two basic types: <br>  - Certificate Pinning: <br>  o Ease of implementation <br>  o Low approach flexibility <br>  - Public Key Pinning: <br>  o Implementation issues on some platforms <br>  o Good flexibility of approach <br><br>  Each approach has its <a href="http://h30499.www3.hp.com/t5/Fortify-Application-Security/Certificate-Pinning-for-Mobile-Applications/ba-p/6223897">pros and cons</a> . <br>  The advantage is also the ability to use: <br>  1) Self-Signed Certificates <br>  2) Private CA-Issued Certificates <br><br>  To implement SSL Pinning, you must override some standard functions and write your own handlers.  It should be noted that SSL Pinning cannot be implemented if you use WebView in Android and UIWebView in iOS due to their specificity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7dd/383/02f/7dd38302f49aa9b20e7a3be2fefc94cd.jpg" alt="image"><br>  SSL Pinning Mechanism <br>  App1 to check the validity of the certificate will use only the embedded certificate or public key. <br>  App2 to check the validity of the certificate will go to the system certificate store, where it will sequentially pass through all the certificates. <br><br><blockquote>  Using SSL Pinning these days <br><br>  For the first time, technology has spread widely in Chrome 13 for Google services.  Next were Twitter, Cards.io, etc. <br>  Now all mobile app stores (Google Play, App Store, Windows Phone Market) use this approach to work with their devices. <br></blockquote><br>  The code for SSL Pinning can now be found on the <a href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning">OWASP</a> website for Android, iOS and .NET.  Starting with Android 4.2, SSL Pinning is <a href="http://nelenkov.blogspot.ru/2012/12/certificate-pinning-in-android-42.html">supported</a> at the system level. <br><br><blockquote>  SSL Pinning Bypass <br><br>  SSL Pinning can be bypassed / disabled if jailbreak or root access is present on the mobile device.  As a rule, only <a href="https://media.blackhat.com/bh-us-12/Turbo/Diquet/BH_US_12_Diqut_Osborne_Mobile_Certificate_Pinning_Slides.pdf">researchers</a> need this to analyze network traffic.  To turn off on Android, there is the Android SSL Bypass program, for iOS, the iOS SSL Kill Switch and TrustMe programs. <br>  In theory, malware can use these same approaches. </blockquote><br>  Like any code, SSL Pinning checks may not be implemented correctly, and you should pay attention to this. <br><br><h4>  Analysis </h4><br>  Enough theory, let's move on to practice and results! <br>  For this study, we used 2 devices: iPhone with iOS 7 and Android with 4.0.3 <br>  Of the tools used: Burp, sslsplit, iptables and openssl.  Here is a simple set.  As you can guess, dynamic analysis was used - just an attempt was made to authenticate with the bank through the application.  It's funny that all applications are available for free in stores (Google Play and the App Store), and we do not need registered accounts in all (there are several exceptions) banks!  So this experiment can be carried out by anyone with a certain level of knowledge and ‚Äústraight‚Äù hands. <br><br>  We tested two aspects: <br>  1) How valid is the SSL certificate validation on the client: <br>  - Used self-signed certificate <br>  - Used a certificate issued by a trusted CA to another host name <br>  2) Is SSL Pinning enabled: <br>  - Used CA certificate for this host; <br><br>  We carried out an active attack "MitM".  To do this, we forced the victim to access the Internet through our controlled gateway, which was used to manipulate certificates. <br>  To test the work with self-signed certificates, we generated our own. <br>  To verify the presence of SSL Pinning and the correctness of checking the host name, we generated our own root certificate and installed it on a mobile device. <br><br>  So, the results: <br>  IOS has 6% of applications, and Android has 11% of applications had their own protocol, and the security of this interaction requires deep manual analysis.  From the visual analysis of the traffic, it can be said that it contains both clear, readable data and compressed / encrypted data.  Our practice and international experience suggest that, most likely, these applications are vulnerable to the MitM attack. <br>  14% of iOS applications and 15% of Android applications are vulnerable to self-signed certificates.  Stealing funds for these applications is only a matter of time. <br>  14% of iOS apps and 23% of Android apps are vulnerable to CA-signed cert hostname.  It can also be noted that when checking host names, there may be many verification errors.  Due to the fact that this test was performed with only one name, these results can only be considered as the lower limit of the number of vulnerable applications. <br>  It should be said that only one bank has simultaneously a vulnerable application for iOS and Android. <br>  SSL pinning is very rare: in 1% of applications for iOS and in 8% of applications for Android.  It is worth noting that, perhaps, this check did not pass for any other reasons not related to SSL pinning, and the percentage of applications using this mechanism is even smaller.  We also did not try to circumvent this defense mechanism, did not analyze the correctness of its implementation. <br><br><blockquote>  As shown by our experience in analyzing the security of mobile applications, almost always there is code that is responsible for disabling certificate validation.  Functions are usually named after Fake *, NonValidating *, TrustAll *, etc.  This code is used by developers for test purposes.  In this regard, due to the negligence of the developer, the code can get into the final release of the program.  Thus, the certificate validity vulnerability can appear in one version and disappear into another, which makes this vulnerability ‚Äúfloating‚Äù from version to version.  As a result, the security of this code depends on the correctness of the processes organized by the developer. </blockquote><br><br><h4>  CONCLUSION </h4><br>  Incorrect work with SSL is just one of the vulnerabilities that leads to the theft of money from the accounts of bank customers.  Using other vulnerabilities (sometimes less critical) and their chains, can also lead to financial losses.  At the same time, on the server side, too, sometimes all is not well ( <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B7%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B0%25D0%25BD%25D0%25BA%25D0%25BE%25D0%25B2%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">ABS</a> sometimes beckons to itself), but this is another story. <br><br>  PS It should be noted that similar vulnerabilities were found by the author in the process of participating in <a href="http://habrahabr.ru/company/mailru/blog/223775/">various</a> BugBounty programs;) <br>  PSS Thanks to Egor Karbutov, Ivan Chalykin, Nikita Kelesis for help in analyzing such a huge number of programs! </div><p>Source: <a href="https://habr.com/ru/post/229849/">https://habr.com/ru/post/229849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229839/index.html">The history of the failure of the online store</a></li>
<li><a href="../229841/index.html">SpaceX put 6 satellites into orbit</a></li>
<li><a href="../229843/index.html">Intercom multi-key and everything about the imitation of "tablets"</a></li>
<li><a href="../229845/index.html">Postgraduate Studies in Holland: What (teaching and working process)</a></li>
<li><a href="../229847/index.html">FedEx: Part 1. Excursion to the FedEx World Package Sorting Center</a></li>
<li><a href="../229851/index.html">What we should build a network</a></li>
<li><a href="../229853/index.html">Building Reliable Web Applications with React: Part 2, Optimization with Browserify</a></li>
<li><a href="../229857/index.html">Android Wear: What went wrong?</a></li>
<li><a href="../229859/index.html">Report from Dribbble Meetup 2014 in Moscow</a></li>
<li><a href="../229861/index.html">"Test Zone" Beeline: go to the tight lock, dress warmer at the gym and turn off the phones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>