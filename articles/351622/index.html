<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quantum computing and Q # language for beginners</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You may have learned about the release of the Quantum Development Kit, a package of quantum tools, and thought it sounded really awesome ... and then ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quantum computing and Q # language for beginners</h1><div class="post__text post__text-html js-mediator-article">  You may have learned about the release of the <a href="http://www.microsoft.com/quantum">Quantum Development Kit, a</a> package of quantum tools, and thought it sounded really awesome ... and then you remembered that you almost knew nothing about quantum mechanics.  But that's okay.  In 30 minutes you will know enough about qubbles, superposition and quantum entanglement to write your first program and, more importantly, to understand well what it does. <br><br><img src="https://habrastorage.org/webt/wf/h9/mo/wfh9mon9rbeyej65r0x4yxnudqi.jpeg"><a name="habracut"></a><br><br><blockquote><h2>  Articles from the cycle: </h2><br><ol><li>  <a href="https://habrahabr.ru/company/microsoft/blog/351622/">Quantum computing and Q # language for beginners</a> </li><li>  <a href="https://habrahabr.ru/company/microsoft/blog/351624/">Introduction to quantum computing</a> </li><li>  <a href="https://habrahabr.ru/company/microsoft/blog/351628/">Quantum circuits and valves - introductory course</a> </li><li>  <a href="https://habrahabr.ru/company/microsoft/blog/351630/">Fundamentals of quantum computing: pure and mixed states</a> </li><li>  <a href="https://habrahabr.ru/company/microsoft/blog/351632/">Quantum teleportation in Q #</a> </li><li>  <a href="https://habr.com/company/microsoft/blog/351634/">Quantum Computing: Reference Materials</a> </li></ol></blockquote><br>  Frances is a graduate of Imperial College London with a degree in computational technology.  She wrote her graduation project, working in the Microsoft Research division.  Frances currently works at Microsoft as a software engineer.  Its main areas of activity are machine learning, big data and quantum computing. <br><blockquote><h2>  The content of the article </h2><br><ul><li>  Repeat the basics </li><li>  Measure qubit </li><li>  Quantum gates </li><li>  Important valves </li><li>  Several qubits </li><li>  Another important valve </li><li>  Bella's condition </li><li>  Writing a quantum program </li><li>  What's next? </li><li>  application </li><li>  Additional materials </li></ul></blockquote><br><h2>  Repeat the basics </h2><br>  If you do not program at the lowest level, then you can completely forget that any programs, in fact, only manipulate the zeros and units that are stored in our "classic" computers.  Discrete binary states of physical systems correspond to these zeros and ones.  Quantum computers operate with continuous state ranges.  In part, their capabilities are due precisely to this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The classic bit can take only one of two states - ‚Äúon‚Äù or ‚Äúoff‚Äù, like a normal incandescent lamp.  Qubits, the basis of quantum computers, are more like a lamp with adjustable brightness. <br><br><img src="https://habrastorage.org/webt/sz/cz/yg/szczygqiocot4okbomvedkcvulu.png"><br><br>  To record two states of qubits, you can use sconces and ket symbols (Dirac symbols) that correspond to the following vectors: <br><br><img src="https://habrastorage.org/webt/5a/jp/8j/5ajp8j-eakjlyvhaqapctkxzak8.png"><br><br>  Using a linear combination of these two states, any possible combination of vectors | 0 and | 1 can be expressed.  In quantum mechanics, this combination is called a superposition.  The corresponding entry in the Dirac notation will look like this: <br><br>  | œà‚ü© = Œ± | 0„Äâ + Œ≤ | 1 <br><br>  The values ‚Äã‚Äãof Œ± and Œ≤ are related to probabilities (with one small difference ‚Äî these coefficients can be expressed by complex numbers).  You can think of them as real numbers, but in this case, remember that they can take negative values.  However, the sum of their squares is always 1. <br><br><h2>  Measure qubit </h2><br>  Quantum states are a weird thing.  As a result of the measurement (or, as they say, ‚Äúin the presence of an observer‚Äù), the qubit collapses immediately.  What does it mean?  Suppose a qubit is in a superposition state.  If you measure it, it will take one specific value - | 0„Äâ or | 1 (both measurements cannot show both results at once!).  After measuring the qubit, the coefficients Œ± and Œ≤, which characterized its previous state, will, in fact, be lost. <br><br>  Therefore, the apparatus of the theory of probability is used to describe the measurements of qubits.  In the general case, the probability that a qubit state measurement will show the result | 0„Äâ is equal to <img src="https://habrastorage.org/webt/nr/se/w1/nrsew1hjzsjldzseho-vp9wtr-y.png">  and the probability to get the state | 1„Äâ is <img src="https://habrastorage.org/webt/ba/1j/fk/ba1jfkbbgrh2k3ddgwd0jdaezbq.png">  .  Consider an example.  Suppose we have the following qubit: <br><br><img src="https://habrastorage.org/webt/fi/_q/pa/fi_qpa7w0c6ld0lrjhszws-8w20.png"><br><br>  If we measure its state, then in 50% of cases we will get a value of 0, because: <br><br><img src="https://habrastorage.org/webt/qw/u8/_8/qwu8_8vx3frfajf4ock5zbgbbla.png"><br><br>  That is, after the measurement, it will be in the state | 0„Äâ (that is, Œ± = 1, Œ≤ = 0).  For the same reason, the probability of getting state 1 is 50%.  In this case, after the measurement, the qubit will move to the state | 1 (that is, Œ± = 0, Œ≤ = 1). <br><br><img src="https://habrastorage.org/webt/fx/hy/sp/fxhyspvcy7p4ubtcadfxbrrdr4i.png"><br><br>  For the first time, all this is very confusing (nothing will change for the second, third and fourth time).  The basic idea here is that probabilistic quantum states can be used for calculations, and in some cases this quantum ‚Äústrangeness‚Äù allows us to obtain systems with efficiency higher than the classical ones.  Now let's see how these qubits can be used for computations, like the classic bits. <br><br><h2>  Quantum gates </h2><br>  Let's go back to the more familiar things.  In the classical theory of computation, logic gates are used to perform operations on bits.  Qubit manipulations use similar constructions - quantum gates.  For example, the NOT gate performs transformations 0 ‚Üí 1 and 1 ‚Üí 0. The quantum gate NOT is similar to its classical ancestor: it performs transformations | 0„Äâ ‚Üí | 1„Äâ and | 1 ‚Üí | 0.  This means that after passing such a valve, the qubit from the state Œ± | 0„Äâ + Œ≤ | 1„Äâ changes to the state Œ± | 1„Äâ + Œ≤ | 0.  The gate NOT can be written in the form of a matrix (X), which swaps 0 and 1 in the state matrix: <br><br><img src="https://habrastorage.org/webt/ny/yo/e9/nyyoe9a62ignxeyyzparxkiz2-g.png"><br><br>  As you can see, X | 0„Äâ = | 1, and X | 1 = | 0: <br><br><img src="https://habrastorage.org/webt/h9/p_/_n/h9p__neklrpw8gjlfzow2_enoii.png"><br><br>  Since | 0„Äâ and | 1„Äâ in vector form are written as <img src="https://habrastorage.org/webt/_0/bi/dg/_0bidgkc7hjqascr6c3z55on_rq.png">  and <img src="https://habrastorage.org/webt/7f/d1/fi/7fd1fiuctlyagh1uier0ics0hwk.png">  , the first column of the matrix X can be considered as a transformation of the vector | 0, and the second - as a transformation of the vector | 1. <br><br>  It would seem that the difference from the classical case is not so great.  But do not forget what we said in the previous section: measuring the state of a qubit is probabilistic in nature.  As is known from elementary probability theory, the sum of the probabilities of the complete group of incompatible events is equal to one.  therefore <img src="https://habrastorage.org/webt/lz/d8/9e/lzd89emyp4vsnndbrppozxtyamc.png">  for the quantum state, Œ± | 0„Äâ + Œ≤ | 1„Äâ. <br><br>  It follows that not all imaginable gates can exist in the quantum world.  Here is one of the limitations: the condition for the normalization of the quantum state of a qubit, <img src="https://habrastorage.org/webt/h7/bu/ax/h7buaxgylolmh398nsb8ckdkb3s.png">  , must be observed both before the passage of the valve and after it.  In terms of matrix algebra, this condition will be satisfied if the matrix is ‚Äã‚Äãunitary. <br><br>  I will try to explain what the mathematical concept of unitarity means.  If you read it quickly enough, you just find yourself on the next sentence.  A valve is called unitary if <img src="https://habrastorage.org/webt/be/ti/zq/betizqpvn09omqlq-eb6p5zvltg.png">  obtained by transposition and complex conjugation <img src="https://habrastorage.org/webt/sl/e1/mk/sle1mkcimwjfgzudk4x_v7nwldq.png">  and is the unit matrix of rank 2. If we speak in human language, this means that the transformation does not change the length of the vector.  If the vector length does not change with time, then the sum of all probabilities is invariably equal to one, or 100% (as it should be).  The calculations, as a result of which the sum of all probabilities turns out to be equal to 200% or 25%, would be meaningless.  Unitary matrices protect at least from such insanity (although it remains abundant in the quantum world). <br><br>  Good news: this restriction is the only one.  Due to this condition, some classical gates do not have a quantum analogue, however, some quantum gates do not have a classical prototype.  Next we analyze the most important of the quantum gates. <br><br><h2>  Important valves: valve Z and Hadamard valve </h2><br>  The valves described below will be used in our first quantum program, so try to memorize them.  The Z valve works very simply: it saves the component | 0 and changes the sign of the component | 1.  It can be written as a matrix <br><br><img src="https://habrastorage.org/webt/cl/fm/_2/clfm_2y1pwi95wbejdyvlsb718i.png"><br><br>  which transforms the states of qubits as follows: | 0„Äâ ‚Üí | 0„Äâ, | 1„Äâ ‚Üí - | 1„Äâ (remember that the first column of the matrix describes the transformation of the vector | 0, the second - the transformation of the vector | 1). <br><br>  The Hadamard gate creates a superposition of states | 0„Äâ and | 1, similar to those discussed above.  Its matrix notation looks like this: <br><br><img src="https://habrastorage.org/webt/dc/pa/5o/dcpa5oexns6ilgsp846byp_8ly0.png"><br><br>  which corresponds to the following state transformations of qubits: <img src="https://habrastorage.org/webt/sg/e7/an/sge7an_5krknxwanvqatl1vimlm.png">  , <img src="https://habrastorage.org/webt/ov/6_/mv/ov6_mv1koi-k72kpdl7ikvqpjr4.png"><br><br>  More detailed information on unitary matrices and on how to visualize valves is provided in the resources referenced in the "Additional materials" section. <br><br><h2>  Several qubits </h2><br>  Consider something more familiar.  Classical bits exist not only singly, but also in the form of combinations: for example, 00, 01, 10 and 11. In quantum computing, similar combinations are used: | 00„Äâ, | 01„Äâ, | 10 and | 11„Äâ.  The state of two qubits can be described using the following vector: <br><br><img src="https://habrastorage.org/webt/oo/1e/ka/oo1ekahlpm8s6-68kbniews3nre.png"><br><br>  As before, the probability to receive as a result of measurement the value 00 is equal <img src="https://habrastorage.org/webt/gm/r8/nl/gmr8nlegi50t3kjogqno8czphja.png">  , <br>  for 01, the probability is <img src="https://habrastorage.org/webt/vu/ej/ai/vuejai_snlunyo2ue_bemuvebzi.png">  etc. <br><br>  Suppose now that we want to measure the state of not both qubits, but only the first one.  The probability of getting 0 is equal to <img src="https://habrastorage.org/webt/pn/dc/xp/pndcxpshi07qrugyfiuuq8t5kpg.png">  .  As we remember, measurement changes state, therefore after it the vector will matter <br><br><img src="https://habrastorage.org/webt/i1/ir/c3/i1irc3azowlaa0foqbcoaxpaux4.png"><br><br>  Pay attention to the numerator: we removed all the terms for which the first bit is 1 (since, by hypothesis, the measurement result is 0).  In order for a vector to describe an admissible quantum state, it is necessary that the square of the sum of amplitudes be equal to one (both before and after the transformation).  In order for this condition to be satisfied, we add the normalization factor ‚Äî the reciprocal of the square root of the determinant. <br><br><h2>  Another important valve </h2><br>  We have already disassembled the operation of the NOT gate.  Next in line is the CNOT (controlled-NOT, ‚ÄúNOT controlled‚Äù) gate.  At its entrance serves two qubits.  The first is called the manager, the second - managed.  If the controlling qubit is | 0, then the state of the controlled qubit does not change.  If the controlling qubit is | 1, then the operation NOT is applied to the managed qubit. <br><br>  The CNOT operation can be interpreted in several ways.  Like the valves X, Z and H, it can be written in matrix form, which is denoted by the letter U. <br><br><img src="https://habrastorage.org/webt/i9/4d/rv/i94drv217se8cv8f_gugirmhm4q.png"><br><br>  You can see that the columns of the matrix correspond to the following transformations: | 00„Äâ ‚Üí | 00„Äâ, | 01„Äâ ‚Üí | 01, | 10 ‚Üí | 11, | 11„Äâ ‚Üí | 10.  Like the matrices that we sorted out <img src="https://habrastorage.org/webt/9g/zf/zq/9gzfzqdlzlmtgj98nydp1xjdxvg.png">  , it is unitary, which means <img src="https://habrastorage.org/webt/fz/hm/pe/fzhmpetga3sdoezf6nxmvuqtdrw.png">  . <br><br>  Also for this valve the following designation is used (the upper part corresponds to the control qubit, the lower part - to the controlled one): <br><br><img src="https://habrastorage.org/webt/bi/1o/rg/bi1orgu48paouh-nvdp6xmakpns.png"><br><br>  Looks like an exhibit of the exhibition of contemporary art. <br><br><h2>  Bella States </h2><br>  This important topic is worth devoting a whole section.  In total there are four states of Bell.  One of them (| œï +‚ü©) will be used in the quantum program below.  Let's consider it. <br><br><img src="https://habrastorage.org/webt/ul/gv/qd/ulgvqd4ju-gz_gujmjwm-9md1u4.png"><br><br>  Suppose we measure the state of the first qubit.  Result | 0„Äâ we get with probability <img src="https://habrastorage.org/webt/b_/if/le/b_ifleo2fe5zcrjtv8egv4jkjtm.png">  .  This means that the state after the measurement | œà '‚ü© = | 00„Äâ, or | 1 with the same probability (0.5), and the state after the measurement | œà' = | 11.  For the curious we cite the complete set of Bell states (they represent the simplest cases of quantum entanglement): <br><br><img src="https://habrastorage.org/webt/nr/hd/iz/nrhdizj_ss0rswawafqzduqdnge.png"><br><br>  Now suppose that we measured the state of the second qubit.  According to the same reasoning, after measuring the steam will be in the state | 00„Äâ or | 11.  If after this we decide to measure the state of the first qubit, the probabilities will no longer be equal to 0.5.  We will get | 0„Äâ with a probability of 1 or 0, depending on what the measurement result was.  Here it is important to understand that these results are related.  The first to notice this were Albert Einstein, Boris Podolsky and Nathan Rosen (therefore, these states are sometimes called ‚ÄúEPR pairs‚Äù).  Subsequently, their theory was developed by John Bell. <br><br>  One final observation: Bell states can be generated using the Hadamard valve and the CNOT valve.  In my opinion, it is admirable.  Hadamard's gate puts the first qubit into a superposition state.  Then this qubit is fed to the control input of the CNOT valve.  Here is how this process can be represented using a circuit diagram: <br><br><img src="https://habrastorage.org/webt/lg/qo/jv/lgqojv0jmc5g1a348rctwxlkxlg.png"><br><br>  To learn more about how each of these transformations works, refer to the additional materials (the list is given below).  We already know about qubit states, quantum gates and Bell states enough to write our first program using qubits. <br><br><h2>  Writing a quantum program </h2><br>  We will follow the instructions from the <a href="https://docs.microsoft.com/en-us/quantum/quantum-writeaquantumprogram%3Fview%3Dqsharp-preview">documentation</a> . <br><br>  This tutorial will help you do the following: install a quantum software development package (steps 1‚Äì2), select a qubit and perform a number of simple manipulations on it ‚Äî for example, set it to a certain state and measure it (steps 3‚Äì5), then translate the qubit is in the superposition state (step 6), and after that the two qubits are transformed into an entangled state - the Bell state, or the EPR pair (step 7). <br><br>  It is recommended that you follow the instructions in the manual referenced above and return to this material if you need tips or additional explanations. <br><br><h2>  Stage 1. Creating a project and solution </h2><br>  Q # is at the bottom of this list. <br><br><img src="https://habrastorage.org/webt/95/dg/ic/95dgic3_rn8wi5ol0f2vbk0lj-g.png"><br><br><h2>  Stage 2 (optional).  Upgrading NuGet Packages </h2><br>  We followed this advice, but this is not necessary, especially if you like to take risks. <br><br><h2>  Stage 3. Entering the Q # code </h2><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Quantum.Bell</span></span> { open Microsoft.Quantum.Primitive; open Microsoft.Quantum.Canon; <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">desired: Result, q1: Qubit</span></span></span><span class="hljs-function">) : (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { body { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = M(q1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (desired != current) { X(q1); } } } }</code> </pre> <br>  This operation converts our qubit to the selected (by us) state - 0 or 1. First, we measure the qubit (this operation is denoted by the letter M), and it collapses into the state 0 or 1. If the measured state does not match the desired state, we change it with the help of the valve NOT, X. Otherwise, nothing needs to be done. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BellTest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count : Int, initial: Result</span></span></span><span class="hljs-function">) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Int,Int</span></span></span><span class="hljs-function">)</span></span> { body { mutable numOnes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (qubits = Qubit[<span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>.count) { Set (initial, qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = M (qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Count the number of ones we saw: if (res == One) { set numOnes = numOnes + 1; } } Set(Zero, qubits[0]); } // Return number of times we saw a |0&gt; and number of times we saw a |1&gt; return (count-numOnes, numOnes); } }</span></span></code> </pre><br>  This small piece of code is intended to test the operation we just wrote.  This is a very simple program: it checks that the qubit has been transferred to the state we need. <br><br>  To do this, it takes a measurement in a cycle and counts the number of results 1 using the variable numOnes. <br><br>  The entry ‚ÄúQubit [1]‚Äù means ‚Äúcreate an array of qubits from one element‚Äù.  The array elements are indexed from scratch.  To select two qubits (later we need to do this), we need to write ‚ÄúQubit [2]‚Äù.  Cubits in such an array correspond to numbers 0 and 1. <br><br>  In the for loop, we set the qubit allocated for a certain initial state ‚Äî One or Zero (in the <b>Driver.cs</b> file, to which we will soon move on, this is done explicitly).  We measure this state, and if it is One, we increase the value of the counter by one.  The function then returns the number of observed states One and Zero.  At the end, the qubit is placed in the Zero state (just to leave it in some known state). <br><br><h2>  Step 4. Enter the C # driver code </h2><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-comment"><span class="hljs-comment">// Try initial values Result[] initials = new Result[] { Result.Zero, Result.One }; foreach (Result initial in initials) { var res = BellTest.Run(sim, 1000, initial).Result; var (numZeros, numOnes) = res; System.Console.WriteLine( $"Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4}"); } } System.Console.WriteLine("Press any key to continue..."); System.Console.ReadKey();</span></span></code> </pre><br>  This driver creates a quantum simulator and an array of initial values ‚Äã‚Äãthat need to be checked (Zero and One).  Then the simulation is repeated 1000 times, and the result for debugging is displayed on the screen using the System.Console.WriteLine function. <br><br><h2>  Stage 5. Assembly and execution </h2><br> <code>Init:Zero 0s=1000 1s=0 <br> Init:One 0s=0 1s=1000 <br> Press any key to continue... <br></code> <br>  If everything is in order, the display should look like the one shown above.  This result means that if we transfer the initial qubit to the Zero state and perform a thousand repetitions, then the number of states | 0„Äâ according to the observation results will be 1000. The same should be done for the One state. <br><br><h2>  Stage 6. Creating a superposition </h2><br>  Let's try something more interesting.  Here we change the state of the qubit using the NOT gate. <br><pre> <code class="cs hljs"> X(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = M (qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br>  Then we run the program again and see that the results are reversed. <br> <code>Init:Zero 0s=0 1s=1000 <br> Init:One 0s=1000 1s=0 <br></code> <br><br>  Then the NOT valve is replaced with the Hadamard valve (H).  As a result, as we know, the qubit will go over to the superposition of states, and the result of its measurement can be equal to both | 0„Äâ and | 1, with some probability. <br><pre> <code class="cs hljs"> H(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = M (qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br>  If you run the program again, we get a rather interesting result. <br> <code>Init:Zero 0s=484 1s=516 <br> Init:One 0s=522 1s=478 <br></code> <br>  The number of measurement results | 0„Äâ and | 1„Äâ will be approximately equal. <br><br><h2>  Step 7. Preparing entangled state </h2><br>  We will now create the state of Bella.  Examine the code below.  First, we create an array of two qubits (Qubit [2]).  The first qubit (in the previous circuit diagram, it was denoted by the symbol x) we transfer to some initial state, and the second one (y in the diagram) is set to the Zero state.  This is about the same as entering | 00„Äâ or | 10„Äâ depending on X: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BellTest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count : Int, initial: Result</span></span></span><span class="hljs-function">) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Int,Int</span></span></span><span class="hljs-function">)</span></span> { body { mutable numOnes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (qubits = Qubit[<span class="hljs-number"><span class="hljs-number">2</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>.count) { Set (initial, qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Set (Zero, qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); H(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); CNOT(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>],qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = M (qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Count the number of ones we saw: if (res == One) { set numOnes = numOnes + 1; } } Set(Zero, qubits[0]); Set(Zero, qubits[1]); } // Return number of times we saw a |0&gt; and number of times we saw a |1&gt; return (count-numOnes, numOnes); } }</span></span></code> </pre><br>  According to the diagram, the first qubit, qubits [0], needs to be passed through the Hadamard gate.  As a result, he will be in superposition.  Then we pass the qubits through the CNOT gate (qubits [0] - the controlling qubit, qubits [1] - controlled) and measure the result. <br><br>  To understand what result to expect, we repeat once again how our state of Bell works.  If we measure the first qubit, we get the value | 0„Äâ with probability <img src="https://habrastorage.org/webt/ak/47/kp/ak47kpbq_ljodtkxincuyzi61z0.png">  .  This means that the state after the measurement | œà '‚ü© = | 00„Äâ or | 1 with the same probabilities (0.5), and the state after the measurement | œà' = | 11.  Thus, the result of measuring the state of the second qubit will be | 0„Äâ if the first qubit was in the state | 0, and | 1„Äâ if the first qubit was in the state | 1.  If the states of two qubits were successfully entangled, then our results should show that the first and second qubits are in the same states. <br><br>  In our code, we check if the measurement result of qubits [1] is equal to the measurement result of qubits [0], using the if operator. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BellTest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count : Int, initial: Result</span></span></span><span class="hljs-function">) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Int,Int,Int</span></span></span><span class="hljs-function">)</span></span> { body { mutable numOnes = <span class="hljs-number"><span class="hljs-number">0</span></span>; mutable agree = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (qubits = Qubit[<span class="hljs-number"><span class="hljs-number">2</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span>.count) { Set (initial, qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Set (Zero, qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); H(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); CNOT(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>],qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = M (qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M (qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]) == res) { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> agree = agree + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Count the number of ones we saw: if (res == One) { set numOnes = numOnes + 1; } } Set(Zero, qubits[0]); Set(Zero, qubits[1]); } // Return number of times we saw a |0&gt; and number of times we saw a |1&gt; return (count-numOnes, numOnes, agree); } }</span></span></code> </pre><br><br>  Before checking the results, you need to make another change to the Driver.cs file: add the variable agree. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-comment"><span class="hljs-comment">// Try initial values Result[] initials = new Result[] { Result.Zero, Result.One }; foreach (Result initial in initials) { var res = BellTest.Run(sim, 1000, initial).Result; var (numZeros, numOnes, agree) = res; System.Console.WriteLine( $"Init:{initial,-4} 0s={numZeros,-4} 1s={numOnes,-4} agree={agree,-4}"); } } System.Console.WriteLine("Press any key to continue..."); System.Console.ReadKey();</span></span></code> </pre><br>  Now the program can be run.  What do these results mean?  If the first qubit was initially placed in the Zero state (that is, we input the value | 00), then the Hadamard valve puts the qubits in the superposition state, and the measurement result is | 0 in 50% of cases and | 1 in 50% of cases .  The fulfillment of this condition can be estimated by the number of zeros and ones.  If the measurement of the state of the first bit did not affect the state of the second, it would remain equal to | 0, and consistency would be achieved only in 499 cases. <br><br>  But, as we can see, the states of the first and second qubit are completely consistent: the number of results | 0„Äâ and | 1 (approximately) coincide.  Thus, the results are consistent in each of the 1000 cases.  This is how Bell states should work. <br> <code>Init:Zero 0s=499 1s=501 agree=1000 <br> Init:One 0s=490 1s=510 agree=1000 <br></code> <br>  On it we will finish.  You wrote your first quantum program and (since you got to the end), you probably understood what it was doing.  It is worth noting a good cup of tea. <br><br><img src="https://habrastorage.org/webt/lh/hx/zj/lhhxzjsm5k-2i05fk3ktjm6gr4q.png"><br><br><h2>  What's next? </h2><br>  There are many examples available in the <a href="https://github.com/Microsoft/Quantum/tree/master/Samples">GitHub</a> repository. <br><br>  In the next article we will talk about the theory of quantum teleportation and study sample code. <br><br>  Quantum vents are discussed in more detail in <a href="https://blogs.msdn.microsoft.com/uk_faculty_connection/2018/02/06/introduction-to-quantum-computing/">Anita‚Äôs blog</a> (note: Anita is simply amazing). <br><br><h2>  Additional materials </h2><br>  If you want to delve into the topics covered, below is a list of resources that were very helpful to us.  The first of them is the book ‚ÄúQuantum Computations and Quantum Information‚Äù (M. Nielsen, I. Chang).  The second is the Microsoft SDK <a href="https://docs.microsoft.com/en-us/quantum/quantum-concepts-1-intro%3Fview%3Dqsharp-preview">documentation</a> . <br><br>  If it will be interesting to readers (leave a comment!), We can make a separate publication about other resources. <br><br><h2>  Application.  Bella States </h2><br><img src="https://habrastorage.org/webt/xq/ge/ro/xqgerowyzbethukbw-9i4mja-ik.png"><br><br>  Bell states can be generated using the Hadamard valve and the CNOT valve.  Hadamard's gate puts the first qubit into a superposition state.  Then this qubit is fed to the control input of the CNOT valve.  On the circuit diagram, it looks like this: <br>  Let us begin with the first case when a pair of qubits in the state | 00  is input.  The first qubit, | 0„Äâ, passes through the Hadamard valve and turns into <img src="https://habrastorage.org/webt/pc/fb/44/pcfb44wn1ai5aitywry6r0jelzs.png">  .  The second qubit does not change.  Result: <br><br><img src="https://habrastorage.org/webt/2k/vb/la/2kvblars1ymofuylwx0mslzdz3k.png"><br><br>  Then the qubits pass through the CNOT gate (which performs the | 00„Äâ ‚Üí | 00„Äâ and | 10„Äâ ‚Üí | 11„Äâ) transformations.  Now their state will be described by the formula <br><br><img src="https://habrastorage.org/webt/sx/ss/-g/sxss-gtne4fjxjryy31kbjbjybe.png"><br><br>  Second case: Qbits | 01„Äâ are input.  Hadamard's gate puts the first qubit | 0 into the state <img src="https://habrastorage.org/webt/a8/zr/q-/a8zrq-akgf1oz1jsr51w8vje5wc.png">  .  The second qubit does not change.  Result: <br><br><img src="https://habrastorage.org/webt/xh/qw/gz/xhqwgzv5ef9ouea9q0gspnltjy0.png"><br><br>  Now we will pass the qubits through the CNOT gate, which performs the transformations | 01„Äâ ‚Üí | 01 and | 11 ‚Üí | 10.  The final state of a pair of qubits will look like this: <br><br><img src="https://habrastorage.org/webt/gn/tf/vn/gntfvnkl1kumke9la6kumckeuz4.png"><br><br>  The third case: Qbits | 10  are input.  Hadamard's gate puts the first qubit | 1‚ü© into the state <img src="https://habrastorage.org/webt/az/qd/ei/azqdeinkk299wfjwt4lslrmhurs.png">  .  The second qubit does not change.  Result: <br><br><img src="https://habrastorage.org/webt/dv/d1/cw/dvd1cwyp0zcttemiv3modqwtdxe.png"><br><br>  Then the qubits pass through the CNOT gate (which performs the | 00„Äâ ‚Üí | 00„Äâ and | 10„Äâ ‚Üí | 11„Äâ) transformations.  Now their state will be described by the formula <br><br><img src="https://habrastorage.org/webt/e8/fr/z9/e8frz9p8rsortktuptoif4lutdw.png"><br><br>  The fourth case: Qbits | 11  are fed to the input.  Hadamard's gate puts the first qubit | 1‚ü© into the state <img src="https://habrastorage.org/webt/mp/ap/ey/mpapey6loioja30jl_0m0obj-5k.png">  .  The second qubit does not change.  Result: <br><br><img src="https://habrastorage.org/webt/zr/vz/pg/zrvzpgo1vrrk6idyqcgolr30llg.png"><br><br>  Now we will pass the qubits through the CNOT gate, which performs the transformations | 01„Äâ ‚Üí | 01 and | 11 ‚Üí | 10.  The final state of a pair of qubits will look like this: <br><br><img src="https://habrastorage.org/webt/vi/o7/e2/vio7e2oqtgbrfdwlmnvsmynjd80.png"><br><br>  Done, we dismantled all cases. </div><p>Source: <a href="https://habr.com/ru/post/351622/">https://habr.com/ru/post/351622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351610/index.html">We are looking for patterns on the stock exchange</a></li>
<li><a href="../351614/index.html">TP-Link T2600G-28MPS: work with PoE, LLDP and Voice VLAN</a></li>
<li><a href="../351616/index.html">Overview of the first day of Data Science Weekend 2018. Machine learning practice, a new approach to competition and much more</a></li>
<li><a href="../351618/index.html">Mosdroid # 6 - Report</a></li>
<li><a href="../351620/index.html">JS ‚Üî DOM tracing, or back and forth</a></li>
<li><a href="../351624/index.html">Introduction to quantum computing</a></li>
<li><a href="../351626/index.html">PVS-Studio - additional insurance for medical software</a></li>
<li><a href="../351628/index.html">Quantum circuits and valves - introductory course</a></li>
<li><a href="../351630/index.html">Fundamentals of quantum computing: pure and mixed states</a></li>
<li><a href="../351632/index.html">Quantum teleportation in Q #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>