<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Authorization in ASP.NET Core MVC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Logo designed by Pablo Iglesias . 


 The article describes the patterns and methods of authorization in ASP.NET Core MVC. I emphasize that only autho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Authorization in ASP.NET Core MVC</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/eaa/02a/8b4/eaa02a8b4f014c1fa5d816b7c4251e54.png"><br><p>  <em>Logo designed by <a href="https://github.com/campusMVP/dotnetCoreLogoPack">Pablo Iglesias</a> .</em> </p><br><p>  The article describes the patterns and methods of <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">authorization</a> in ASP.NET Core MVC.  I emphasize that only authorization is considered (verification of user rights) and not authentication, so the article will not use ASP.NET Identity, authentication protocols, etc.  There will be many examples of server-side code, a brief digression into the depth of the Core MVC source, and a test project (link at the end of the article).  I invite those interested in cat. </p><br><p>  Content: </p><br><ul><li>  <a href="https://habr.com/ru/post/322566/">Claims</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Preparatory work</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Authorize attribute and access policies</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Access Policy Settings</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Resource-based authorization</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Authorization in the Razor Markup</a> </li><li>  <a href="https://habr.com/ru/post/322566/">Permission-based authorization.</a>  <a href="https://habr.com/ru/post/322566/">Own authorization filter</a> </li></ul><br><a name="habracut"></a><br><h3 id="claims">  Claims </h3><br><p>  The principles of authorization and authentication in ASP.NET Core MVC have not changed compared with the previous version of the framework, differing only in details.  One of the relatively new concepts is claim-based authorization, with which we will begin our journey.  What is a claim?  This is a pair of key-value lines, the key can be "FirstName", "EmailAddress", etc.  Thus, a claim can be treated as a property of the user, as a string with data, or even as some kind of statement ‚Äú <em>the user has something</em> .‚Äù  The one-dimensional role-based model familiar to many developers is organically contained in a multidimensional claim-based model: the role (the statement ‚Äúyou <em>have the role X</em> ‚Äù) is one of the claim and is contained in the list of predefined <a href="https://referencesource.microsoft.com/">System.Security.Claims.ClaimTypes</a> .  It is not forbidden to create your own claims. </p><br><p>  The next important concept is identity.  This is a single statement containing a claim.  So, identity can be interpreted as a solid document (passport, driver's license, etc.), in this case, the claim is a string in the passport (date of birth, last name ...).  Core MVC uses the <a href="https://referencesource.microsoft.com/">System.Security.Claims.ClaimsIdentity</a> class. </p><br><p>  Another level up is the concept of principal, denoting the user himself.  As in real life, a person may have several documents on hand at the same time, and in Core MVC, a principal may contain several identities associated with a user.  The well-known <a href="">HttpContext.User</a> property in Core MVC is of type <a href="https://referencesource.microsoft.com/">System.Security.Claims.ClaimsPrincipal</a> .  Naturally, through the principal you can get all the claims of each identity.  A set of more than one identity can be used to restrict access to different sections of the site / service. </p><br><img src="https://habrastorage.org/files/d33/c5d/252/d33c5d2523b444ffb0045db8550c1ac4"><br><p>  <em>The diagram shows only some of the properties and methods of classes from the System.Security.Claims namespace.</em> </p><br><p>  Why is all this necessary?  When claim-based authorization, we explicitly indicate that the user needs to have the necessary claim (user property) to access the resource.  In the simplest case, the fact of the presence of a specific claim is verified, although much more complex combinations are possible (set with the help of policy, requirements, permissions - we will look at these concepts in more detail below).  A real-life example: to control a passenger car, a person must have a driver's license (identity) with an open category B (claim). </p><br><h3 id="podgotovitelnye-raboty">  Preparatory work </h3><br><p>  Here and further throughout the article, we will configure access for different pages of the website.  To run the presented code, it is enough to create in Visual Studio 2015 a new application such as "ASP.NET Core Web Application", set the Web Application pattern and the authentication type "No Authentication". </p><br><p>  When using "Individual User Accounts" authentication, a code would be generated to store and load users into the database using ASP.NET Identity, EF Core and localdb.  What is completely redundant in this article, even though <a href="https://www.scottbrady91.com/Entity-Framework/Entity-Framework-Core-In-Memory-Testing">there is a</a> lightweight <a href="https://stormpath.com/blog/tutorial-entity-framework-core-in-memory-database-asp-net-core">EntityFrameworkCore.InMemory</a> testing solution.  Moreover, we basically do not need an ASP.NET Identity <em>authentication</em> library.  Obtaining a principal for authorization can be self-emulated in-memory, and the principal can be serialized into a cookie using standard Core MVC tools.  This is all that is needed for our testing. </p><br><div class="spoiler">  <b class="spoiler_title">If you want to use ASP.NET Identity with in-memory user repository</b> <div class="spoiler_text"><p>  To emulate a user repository, just open Startup.cs and register stub services in the built-in DI container: </p><br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Identity services.AddIdentity&lt;IdentityUser, IdentityRole&gt;(); //  services.AddTransient&lt;IUserStore&lt;IdentityUser&gt;, FakeUserStore&gt;(); services.AddTransient&lt;IRoleStore&lt;IdentityRole&gt;, FakeRoleStore&gt;(); }</span></span></code> </pre> <br><p>  By the way, we just did the same work that the <a href="">AddEntityFrameworkStores &lt;TContext&gt;</a> call <a href="">would do</a> : </p><br><pre> <code class="hljs xml">services.AddIdentity<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IdentityUser,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">IdentityRole</span></span></span><span class="hljs-tag">&gt;</span></span>() .AddEntityFrameworkStores<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IdentityDbContext</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> </div></div><br><p>  Let's start with the authorization of the user on the site: on <code>GET /Home/Login</code> we will draw a stub form, add a button to send an empty form to the server.  On <code>POST /Home/Login</code> we will manually create a principal, identity and claim (in a real application, this data would be obtained from the database).  The <code>HttpContext.Authentication.SignInAsync</code> call serializes the principal and <code>HttpContext.Authentication.SignInAsync</code> it into an encrypted cookie, which in turn will be attached to the response of the web server and saved on the client side: </p><br><div class="spoiler">  <b class="spoiler_title">Creating a principal stub when a user logs on to the site</b> <div class="spoiler_text"><pre> <code class="hljs coffeescript">[HttpGet] [AllowAnonymous] public IActionResult Login(string returnUrl = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ViewData[<span class="hljs-string"><span class="hljs-string">"ReturnUrl"</span></span>] = returnUrl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } [HttpPost] [AllowAnonymous] [ValidateAntiForgeryToken] public async Task&lt;IActionResult&gt; Login(LoginViewModel vm, string returnUrl = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>TODO:  ,    ,  ..  .. var claims = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Claim&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Claim(ClaimTypes.Name, <span class="hljs-string"><span class="hljs-string">"Fake User"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Claim(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-string"><span class="hljs-string">"25"</span></span>, ClaimValueTypes.Integer) }; var identity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClaimsIdentity(<span class="hljs-string"><span class="hljs-string">"MyCookieMiddlewareInstance"</span></span>); identity.AddClaims(claims); var principal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClaimsPrincipal(identity); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HttpContext.Authentication.SignInAsync(<span class="hljs-string"><span class="hljs-string">"MyCookieMiddlewareInstance"</span></span>, principal, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationProperties { ExpiresUtc = DateTime.UtcNow.AddMinutes(<span class="hljs-number"><span class="hljs-number">20</span></span>) }); _logger.LogInformation(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"User logged in."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RedirectToLocal(returnUrl); }</code> </pre> </div></div><br><p>  Enable cookie authentication in the Startup.Configure (app) method: </p><br><pre> <code class="hljs cs">app.UseCookieAuthentication(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CookieAuthenticationOptions() { AuthenticationScheme = <span class="hljs-string"><span class="hljs-string">"MyCookieMiddlewareInstance"</span></span>, CookieName = <span class="hljs-string"><span class="hljs-string">"MyCookieMiddlewareInstance"</span></span>, LoginPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathString(<span class="hljs-string"><span class="hljs-string">"/Home/Login/"</span></span>), AccessDeniedPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathString(<span class="hljs-string"><span class="hljs-string">"/Home/AccessDenied/"</span></span>), AutomaticAuthenticate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, AutomaticChallenge = <span class="hljs-literal"><span class="hljs-literal">true</span></span> });</code> </pre> <br><p>  This code with minor modifications will be the basis for all subsequent examples. </p><br><h3 id="atribut-authorize-i-politiki-dostupa">  Authorize attribute and access policies </h3><br><p>  The <code>[Authorize]</code> attribute has not gone anywhere from MVC.  As before, when controller / action is marked with this attribute, only an authorized user will get access to it inside.  Things become more interesting if you additionally specify the name of the policy (policy) - some requirements to claim the user: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Authorize(Policy = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"age-policy"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">About</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); }</code> </pre> <br><p>  Policies are created in the <code>Startup.ConfigureServices</code> method already known to us: </p><br><pre> <code class="hljs pgsql">services.AddAuthorization(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.AddPolicy("age-policy", x =&gt; { x.RequireClaim("age"); }); });</code> </pre> <br><p>  This policy establishes that only an authorized user with the claim "age" can access the About page, and the value of the claim is not taken into account.  In the next section, we will move on to examples more complicated (finally!), And now we will understand how this works inside? </p><br><p>  <code>[Authorize]</code> - a marker attribute that does not contain logic in itself.  It is needed only in order to specify MVC, to which the controller / action <a href="">AuthorizeFilter</a> should be connected - one of Core MVC‚Äôs built-in filters.  <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">The concept of filters</a> is the same as in previous versions of the framework: filters are executed sequentially and allow you to execute code before and after accessing the controller / action.  An important difference from middleware: filters have access to the MVC-specific context (and, of course, they are executed after all middleware).  However, the line between filter and middleware is very vague, since it is possible <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">to integrate the</a> middleware call <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">into the filter chain</a> using the [MiddlewareFilter] attribute. </p><br><p>  Let's return to authorization and AuthorizeFilter.  The most interesting thing happens in his <a href="">OnAuthorizationAsync</a> method: </p><br><ol><li>  From the list of policies, the required one is selected based on the value specified in the [Authorize] attribute (or <a href="">AuthorizationPolicy</a> is taken - the default policy containing only one requirement with a talking name - <a href="">DenyAnonymousAuthorizationRequirement</a> . </li><li>  It checks whether the set of user identities and claims (for example, those obtained earlier from the request cookies) meets the policy requirements. </li></ol><br><p>  I hope the links to the source code gave you an idea of ‚Äã‚Äãthe internal design of filters in Core MVC. </p><br><h3 id="nastroyki-politik-dostupa">  Access Policy Settings </h3><br><p>  Creating access policies through the fluent interface discussed above does not provide the flexibility that is required in real applications.  Of course, you can explicitly specify the allowed values ‚Äã‚Äãof claim through a call to <code>RequireClaim("x", params values)</code> , you can combine through logical AND several conditions by calling <code>RequireClaim("x").RequireClaim("y")</code> .  Finally, it is possible to hang different policies on the controller and action, which, however, will lead to the same combination of conditions through logical I. Obviously, a more flexible mechanism for creating policies is needed, and we have it: requirements and handlers. </p><br><pre> <code class="hljs pgsql">services.AddAuthorization(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>.AddPolicy("age-policy", <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">policy</span></span>.Requirements.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AgeRequirement(<span class="hljs-number"><span class="hljs-number">42</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> FooRequirement())); });</code> </pre> <br><p>  Requirement is no more than a DTO for passing parameters to the appropriate handler, which in turn has access to HttpContext.User and is free to impose any checks on the principal and the identity / claim contained in it.  Moreover, the handler can receive external dependencies through the DI container built into Core MVC: </p><br><div class="spoiler">  <b class="spoiler_title">Example requirement and handler</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MinAgeRequirement : IAuthorizationRequirement { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MinAgeRequirement(<span class="hljs-type"><span class="hljs-type">int</span></span> age) { Age = age; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Age { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; private <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MinAgeHandler : AuthorizationHandler&lt;MinAgeRequirement&gt; { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MinAgeHandler(IFooService fooService) { // fooService    DI } protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, MinAgeRequirement requirement) { <span class="hljs-type"><span class="hljs-type">bool</span></span> hasClaim = context.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.HasClaim(c =&gt; c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == "age"); <span class="hljs-type"><span class="hljs-type">bool</span></span> hasIdentity = context.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.Identities.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>(i =&gt; i.AuthenticationType == "MultiPass"); string claimValue = context.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.FindFirst(c =&gt; c.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == "age").<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span>.Parse(claimValue) &gt;= requirement.Age) { context.Succeed(requirement); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { context.Fail(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; } }</code> </pre> </div></div><br><p>  We register the handler itself in Startup.ConfigureServices (), and it is ready for use: </p><br><pre> <code class="hljs xml">services.AddSingleton<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IAuthorizationHandler,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">MinAgeHandler</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br><p>  Handlers can be combined using both AND and OR.  So, when registering several heirs of <code>AuthorizationHandler&lt;FooRequirement&gt;</code> , all of them will be called.  In this case, a call to <code>context.Succeed()</code> not mandatory, and a call to <code>context.Fail()</code> results in a general denial of authorization, regardless of the result of other handlers.  In total, we can combine the access mechanisms as follows: </p><br><ul><li>  Policy: AND </li><li>  Requirement: AND </li><li>  Handler: AND / OR. </li></ul><br><h3 id="resource-based-avtorizaciya">  Resource-based authorization </h3><br><p>  As mentioned earlier, the policy-based authorization is performed by the Core MVC in the filter pipeline, i.e.  BEFORE calling the protected action.  The success of authorization depends only on the user - either he has the necessary claim or not.  But what if it is also necessary to take into account the protected resource and its properties, to get some data from external sources?  Example from the life: we protect the action of the type <code>GET /Orders/{id}</code> , which reads the id string with the order from the database.  Let we can determine if the user has rights to a specific order only after receiving this order from the database.  This automatically renders the previously uncovered aspect-oriented scenarios based on MVC filters, which are executed before the user code gets control, unsuitable.  Fortunately, Core MVC has ways to authorize it manually. </p><br><p>  For this, in the controller we will need an <a href="">implementation of the</a> <code>IAuthorizationService</code> .  We get it, as usual, through dependency injection into the constructor: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResourceController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { IAuthorizationService _authorizationService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResourceController</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAuthorizationService authorizationService</span></span></span><span class="hljs-function">)</span></span> { _authorizationService = authorizationService; } }</code> </pre> <br><p>  Then create a new policy and handler: </p><br><pre> <code class="hljs actionscript">options.AddPolicy(<span class="hljs-string"><span class="hljs-string">"resource-allow-policy"</span></span>, x =&gt; { x.AddRequirements(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ResourceBasedRequirement()); }); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceHandler</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthorizationHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceBasedRequirement</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> Task HandleRequirementAsync( AuthorizationHandlerContext context, ResourceBasedRequirement requirement, Order order) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> ,         if (true) context.Succeed(requirement); return Task.CompletedTask; } }</span></span></code> </pre> <br><p>  Finally, we check the user + resource for compliance with the desired policy inside the action (note that the <code>[Authorize]</code> attribute is no longer needed): </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> async Task&lt;IActionResult&gt; Allow(<span class="hljs-type"><span class="hljs-type">int</span></span> id) { <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>(); //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (await _authorizationService.AuthorizeAsync(<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>, "my-resource-policy")) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">401</span></span>  <span class="hljs-number"><span class="hljs-number">403</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ChallengeResult(); } }</code> </pre> <br><p>  The <code>IAuthorizationService.AuthorizeAsync</code> method has an overload that takes a list from a requirement instead of a policy name: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AuthorizeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> ClaimsPrincipal user, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resource, IEnumerable&lt;IAuthorizationRequirement&gt; requirements</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  That allows even more flexibility to configure access rights.  For the demonstration, use the predefined <code>OperationAuthorizationRequirement</code> (yes, this example migrated to the article directly from <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased">docs.microsoft.com</a> ): </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Operations { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static OperationAuthorizationRequirement <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> OperationAuthorizationRequirement { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "Create" }; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static OperationAuthorizationRequirement <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> OperationAuthorizationRequirement { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "Read" }; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static OperationAuthorizationRequirement <span class="hljs-keyword"><span class="hljs-keyword">Update</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> OperationAuthorizationRequirement { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "Update" }; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static OperationAuthorizationRequirement <span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> OperationAuthorizationRequirement { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "Delete" }; }</code> </pre> <br><p>  which will allow you to do the following things: </p><br><pre> <code class="hljs pgsql">_authorizationService.AuthorizeAsync( <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, resource, Operations.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>, Operations.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>, Operations.<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>);</code> </pre> <br><p>  In the <code>HandleRequirementAsync(context, requirement, resource)</code> method <code>HandleRequirementAsync(context, requirement, resource)</code> corresponding handler - you only need to check the rights of the operation, respectively, specified in <code>requirement.Name</code> and do not forget to call <code>context.Fail()</code> if the user failed authorization: </p><br><pre> <code class="hljs pgsql">protected override Task HandleRequirementAsync( AuthorizationHandlerContext context, OperationAuthorizationRequirement requirement, <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>) { string operationName = requirement.Name; // ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) context.Succeed(requirement); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; }</code> </pre> <br><p>  The handler will be called as many times as the requirement you submitted to <code>AuthorizeAsync</code> and will check each requirement separately.  For a one-time check of all rights to operations in one call to the handler, pass the list of operations inside the requirement, for example: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> OperationListRequirement(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>[] { Ops.<span class="hljs-keyword"><span class="hljs-keyword">Read</span></span>, Ops.<span class="hljs-keyword"><span class="hljs-keyword">Update</span></span> })</code> </pre> <br><p>  This is where the overview of resource-based authorization is complete, and it's time to cover our handlers with tests: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MinAgeHandler_WhenCalledWithValidUser_Succeed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requirement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MinAgeRequirement(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClaimsPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClaimsIdentity(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Claim&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Claim(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-string"><span class="hljs-string">"25"</span></span>) })); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthorizationHandlerContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { requirement }, user, resource: <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MinAgeHandler(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> handler.HandleAsync(context); Assert.True(context.HasSucceeded); }</code> </pre> <br><h3 id="avtorizaciya-v-razor-razmetke">  Authorization in the Razor Markup </h3><br><p>  User rights verification performed directly in the markup can be useful to hide UI elements to which the user should not have access.  Of course, in the view, you can pass all the necessary flags through the ViewModel (other things being equal, I am for this option), or you can directly contact the principal via HttpContext.User: </p><br><pre> <code class="hljs css">&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">h4</span></span>&gt;: @<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">GetClaimValue</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">age</span></span>")&lt;/<span class="hljs-keyword"><span class="hljs-keyword">h4</span></span>&gt;</code> </pre> <br><p>  If you're interested, the view is inherited from the <a href="">RazorPage</a> class, and direct access to the HttpContext from the markup is possible through the property <code>@Context</code> . </p><br><p>  On the other hand, we can use the approach from the previous section: get the <code>IAuthorizationService</code> implementation through DI (yes, right in the view) and check the user for compliance with the requirements of the desired policy: </p><br><pre> <code class="hljs coffeescript">@inject IAuthorizationService AuthorizationService @if (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AuthorizationService.AuthorizeAsync(User, <span class="hljs-string"><span class="hljs-string">"my-policy"</span></span>))</code> </pre> <br><p>  Do not try to use the <code>SignInManager.IsSignedIn(User)</code> call in our test project (used in the web application template with the Individual User Accounts authentication type).  First of all, because we do not use the <code>Microsoft.AspNetCore.Identity</code> authentication library to which this class belongs.  The method itself doesn‚Äôt do anything inside, apart from checking that the user has an identity with a name in the library‚Äôs code. </p><br><h3 id="permission-based-avtorizaciya-svoy-filtr-avtorizacii">  Permission-based authorization.  Own authorization filter </h3><br><p>  Declarative listing of all requested operations (first of all from CRUD) when authorizing a user, such as: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requirement = OperationListRequirement(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { Ops.FooAction, Ops.BarAction }); _authorizationService.AuthorizeAsync(User, resource, requirement);</code> </pre> <br><p>  ... it makes sense if your project has a system of personal permissions (permissions): there is a certain set of a large number of high-level business logic operations, there are users (or groups of users) who were manually granted rights to specific operations with a specific resource.  For example, Vasya has the right to "scrub the deck", "sleep in the cabin", and Petya can "turn the steering wheel."  Good or bad, such a pattern is a topic for a separate article (I personally am not happy with it).  The obvious problem of this approach: the list of operations easily grows to several hundred, even not in the largest system. </p><br><p>  The situation is simplified if for authorization there is no need to take into account a specific instance of the protected resource, and our system has sufficient granularity to simply attach an attribute with a list of checked operations to the entire method, instead of hundreds of <code>AuthorizeAsync</code> calls in the protected code.  However, the use of authorization based on policies <code>[Authorize(Policy = "foo-policy")]</code> will lead to a combinatorial explosion of the number of policies in the application.  Why not use the good old role-based authorization?  In the example code below, the user needs to be a member of all the specified roles to access the FooController: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Authorize(Roles = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PowerUser"</span></span></span><span class="hljs-meta">)</span></span>] [Authorize(Roles = <span class="hljs-string"><span class="hljs-string">"ControlPanelUser"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FooController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { }</code> </pre> <br><p>  Such a solution may also not provide sufficient detail and flexibility for a system with a large number of permissions and their possible combinations.  Additional problems start when both role-based and permission-based authorization is needed.  Yes, and semantically, roles and operations are different things, I would like to process their authorization separately.  Resolved: write your version of the attribute <code>[Authorize]</code> !  I will demonstrate the final result: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">AuthorizePermission(Permission.Foo, Permission.Bar)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Edit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); }</code> </pre> <br><p>  Start by creating an enum for operations, a requirement, and a handler for user verification: </p><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Permission</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Foo</span></span>, <span class="hljs-type"><span class="hljs-type">Bar</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PermissionRequirement</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAuthorizationRequirement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Permission</span></span>[] <span class="hljs-type"><span class="hljs-type">Permissions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">PermissionRequirement</span></span>(<span class="hljs-type"><span class="hljs-type">Permission</span></span>[] permissions) { <span class="hljs-type"><span class="hljs-type">Permissions</span></span> = permissions; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PermissionHandler</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthorizationHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PermissionRequirement</span></span></span><span class="hljs-class">&gt; </span></span>{ protected <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Task</span></span> <span class="hljs-type"><span class="hljs-type">HandleRequirementAsync</span></span>( <span class="hljs-type"><span class="hljs-type">AuthorizationHandlerContext</span></span> context, <span class="hljs-type"><span class="hljs-type">PermissionRequirement</span></span> requirement) { <span class="hljs-comment"><span class="hljs-comment">//</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   ,         if (requirement.Permissions.Any()) { context.Succeed(requirement); } return Task.CompletedTask; } }</span></span></code> </pre> </div></div><br><p>  Earlier, I told you that the <code>[Authorize]</code> attribute is purely marker and is needed for using <code>AuthorizeFilter</code> .  We will not fight with the existing architecture, so we will write by analogy our own authorization filter.  Since the permissions list for each action is different, then: </p><br><ol><li>  You must create an instance of the filter for each call; </li><li>  It is not possible to directly create an instance through the embedded DI container. </li></ol><br><p>  Fortunately, in Core MVC, these problems are easily solved with the <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">[TypeFilter]</a> attribute: </p><br><pre> <code class="hljs pgsql">[TypeFilter(typeof(PermissionFilterV1), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>[] { Permission.Foo, Permission.Bar } })] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IActionResult <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">PermissionFilterV1</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PermissionFilterV1</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span>, <span class="hljs-title"><span class="hljs-title">IAsyncAuthorizationFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IAuthorizationService _authService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Permission[] _permissions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PermissionFilterV1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAuthorizationService authService, Permission[] permissions</span></span></span><span class="hljs-function">)</span></span> { _authService = authService; _permissions = permissions; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAuthorizationAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AuthorizationFilterContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ok = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _authService.AuthorizeAsync( context.HttpContext.User, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PermissionRequirement(_permissions)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) context.Result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChallengeResult(); } }</code> </pre> </div></div><br><p>  We got a fully working, but ugly looking solution.  In order to hide the implementation details of our filter from the calling code, the <code>[AuthorizePermission]</code> attribute is useful to us: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AuthorizePermissionAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">TypeFilterAttribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AuthorizePermissionAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Permission[] permissions</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(PermissionFilterV2</span></span></span><span class="hljs-function">))</span></span> { Arguments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PermissionRequirement(permissions) }; Order = Int32.MaxValue; } }</code> </pre> <br><p>  Result: </p><br><pre> <code class="hljs pgsql">[AuthorizePermission(Permission.Foo, Permission.Bar)] [Authorize(<span class="hljs-keyword"><span class="hljs-keyword">Policy</span></span> = "foo-policy")] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IActionResult <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>(); }</code> </pre> <br><p>  Please note: authorization filters work independently, which allows you to combine them with each other.             <code>AuthorizePermissionAttribute.Order</code> . </p><br><p>       (       ): </p><br><ul><li>    <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/introduction">docs.microsoft.com</a> . </li><li>     ASP.NET Core   <a href="https://andrewlock.net/">Andrew Lock | .NET Escapades</a> .    . </li></ul><br><p>      ASP.NET Core MVC .       WebAPI.         <a href="https://github.com/ilya-chumakov/PaperSource.AspNetCoreAuthorization"> </a> .    ( )   -   API     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322566/">https://habr.com/ru/post/322566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322554/index.html">JPEG technology: decision space analysis</a></li>
<li><a href="../322558/index.html">Making a living by creating games</a></li>
<li><a href="../322560/index.html">Bridge-domains and virtual-switch in JunOS</a></li>
<li><a href="../322562/index.html">Architecture of the growing project on the example of VKontakte</a></li>
<li><a href="../322564/index.html">Prospects for the development of public data</a></li>
<li><a href="../322570/index.html">Technical support 3CX responds: sound files are not played and iOS client does not ‚Äúwake up‚Äù</a></li>
<li><a href="../322572/index.html">"Moisten" objects using Cuckoo</a></li>
<li><a href="../322574/index.html">Watching user</a></li>
<li><a href="../322580/index.html">Wayland to replace the X Window System</a></li>
<li><a href="../322584/index.html">JQuery Masonry - dynamic layout, typeset without ‚Äúholes‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>