<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Publish to Azure Blob Storage with Shared Access Signature</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. This article will be very similar to the previous one . Here I will also tell you how to use Windows Azure Mobile Services to publish high-volume...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Publish to Azure Blob Storage with Shared Access Signature</h1><div class="post__text post__text-html js-mediator-article">  Hey.  This article will be very similar to the <a title="Mobile services, blobs and Windows 8. Store data in Windows Azure" href="http://habrahabr.ru/post/157641/">previous one</a> .  Here I will also tell you how to use Windows Azure Mobile Services to publish high-volume data to Blob Storage.  However, this time we will get rid of the WCF service and at the same time add an additional layer of protection against unauthorized access using <strong>Shared Access Signature</strong> .  The purpose of this article is to show the additional features of Windows Azure for working with data, as well as the ability to quickly create a Mobile Services backend. <br><br>  Before proceeding to further reading, I advise you to read the previous article, because there some points are disclosed in more detail than here. <br><a name="habracut"></a><br><h2>  Shared Access Signature </h2><br>  For a start it is worth telling, and what is this very Shared Access Signature, or simply SAS.  Behind these three letters lies nothing more than a simple URL that allows you to differentiate the right of access to a Windows Azure Blob resource, Table or Queue.  If you recall the previous article and how data was exchanged between the Windows 8 application and the WCF service, you can immediately understand that this solution clearly suffered from the lack of any protection.  First, the data channel was opened (HTTP), which allowed a potential attacker to intercept user information.  Secondly, even if the channel is encrypted (HTTPS), we did not have any verification of the authenticity of the request.  I want to say that if we had several users in the system, then there was no way to determine whether a particular user has write permissions to the repository, and in general - whether the application sent a request or is it just a hacker trying to send its malicious data.  Well, I don‚Äôt even consider the option of storing data for connecting to Blob Storage directly in a Windows 8 application - it‚Äôs not too security. <br><br>  Using Shared Access Signature in conjunction with Mobile Services will allow us to avoid such problems.  The fact is that SAS will be formed on the server side, directly in Mobile Services, where we are protected from prying eyes, and we also have all the necessary information about the user and can restrict access to anonymous people.  The very same signature will be issued for a very limited period of time, about 5 minutes, which will also minimize the possibility of its embezzlement and mercenary use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perhaps the words are quite difficult to explain, so I propose to move on to practice.  For this, I will take the idea from the previous post and a slightly modified application code. <br><h2>  Training </h2><br>  So, first we need to create the necessary services in Windows Azure.  Go to the new <a title="Windows Azure Management Portal" href="https://manage.windowsazure.com/">management portal</a> and create Blob-storage.  Through the standard menu of adding a service, select the item Data Services -&gt; Storage -&gt; Quick Create, where we need to specify the name of the future service, the region of the subscription, within which it should work: <br><br><img alt="Creating Windows Azure Blob Storage" src="https://habrastorage.org/storage2/ed2/9d6/130/ed29d61305c94b82c04178092697a979.png" width="800" height="355"><br><br>  We also need a mobile service, which can be created in the same portal menu in the Compute section -&gt; Mobile Service: <br><br><img alt="Creating a Windows Azure Mobile Service" src="https://habrastorage.org/storage2/4b5/5f0/49a/4b55f049ad4e8e7d9823550065cee79b.png" width="679" height="450"><br><br>  Both of these steps you can not do if you already have a blob-storage or mobile service created. <br><br><h2>  Create Shared Access Signature </h2><br>  Unlike what we started last time, now our first place to write code will be Windows Azure Mobile Services.  Yes, I have not described myself anywhere here - we will write code directly in the cloud service.  This is possible thanks to the built-in functions of scripts that can be executed when performing one of the CRUD operations on the table. <br><br>  This time we will save photos with a brief description in our application.  To begin with, we will create a new table in Mobile Services, in which the records will be located.  Let's call it Picture: <br><br><img alt="Creating Data Table" src="https://habrastorage.org/storage2/edb/652/4d2/edb6524d2ea2d31df96de274595661d9.png" width="644" height="553"><br><br>  When creating a table, in the fields with the name Permission specify ‚ÄúAnybody with the application key‚Äù.  This means that any user (even anonymous) who has access keys to the Mobile Service can perform this operation.  If you select the value ‚ÄúOnly authenticated users‚Äù, then the user will be checked before accessing the operation, and if it is not specified, the operation will be prohibited from being executed.  In this article I will not consider authentication using Mobile Services, so we will leave the default values ‚Äã‚Äãin these fields. <br><br>  Now that the table has been created, you can open the scripts.  To do this, go to the Data section in the control panel of your mobile service, select the table you just created.  At the top, she will have access to the Script section, which we need: <br><br><img alt="Script Data Table" src="https://habrastorage.org/storage2/38c/381/6da/38c3816da8ef2b77bc1b3568ccd96584.png" width="459" height="256"><br><br>  If you expand the Operation menu, it will have four options: Insert, Update, Delete and Read.  Each of these options corresponds to a separate script that is executed at the time of the occurrence of an event.  If we draw an analogy, then these scripts can be compared with database triggers.  In this case, the main body of the ‚Äútrigger‚Äù itself is the function of the same name, but you can write additional functions below.  The language of these scripts is JavaScript, with all the ensuing positive consequences, in the form of asynchrony, closures, etc. <br><br>  So, when it became a little clearer with the principle of the scripts, it‚Äôs time to write a little server code that will create Shared Access Signature for us.  For this we need a script for the insert event - Insert.  Scripts in Mobile Services allow you to use some APIs to work with other Windows Azure services.  Such APIs are connected as external library classes and are used in the code easily and simply.  Let's look at this with an example (I apologize for inserting the code as a picture, but more clearly): <br><br><img alt="Shared Access Signature 1 Script" src="https://habrastorage.org/storage2/ff3/b19/900/ff3b19900812657caa6d46fd86652968.png" width="902" height="784"><br><br>  Lines 1 and 2 just declare the plug-ins and give them names.  The azure module is responsible for working with Windows Azure services, and the querystring module is responsible for generating a URL with parameters (see below).  However, before we proceed to the consideration of the code (which, by the way, should be quite understandable), I want to draw your attention to how convenient the built-in editor is.  Firstly, there is syntax highlighting and automatic alignment, which, however, will surprise no one.  Secondly, it has built-in automatic code validation.  The <em>createAccessPolicy</em> and <em>createResourceURLWithSAS</em> <em>functions</em> are not yet declared in the code, and the editor highlights them with an underline and a red bar in the margins.  Well and in addition, thirdly, IntelliSense is built in the editor.  He, of course, not as cool as in Visual Studio, but also slightly simplifies life. <br><br>  Now look at the code itself.  As I said, there is nothing complicated and incomprehensible.  If in a nutshell, we, along with the recording of information about the new image, also need to record the URL, with which we can perform operations with BLOB storage (this URL contains SAS).  First you need to access the repository using its name and key (line 14), which can be obtained in the Windows Azure management portal in the storage management section.  Then we create a container (line 15), if it is not already there, and set access rights: allow reading to everyone.  Then, using an anonymous function and closures, we determine the code that will be executed after the container is created.  So we achieve asynchronous operation of the application, which is better for server performance.  Using the createAccessPolicy function (line 20), which is not yet described (line 20), we create an access policy (what we can and when) and create a URL using <em>createResourceURLWithSAS</em> (line 23). <br><br>  Let's look at the rest of the code: <br><br><img alt="Shared Access Signature 2 Creation Script" src="https://habrastorage.org/storage2/ba8/8a6/ca2/ba88a6ca2ca25cab4a5def484250e66a.png" width="888" height="516"><br><br>  This code snippet contains the remaining functions that were missing in the previous block.  The most interesting are <em>createAccessPolicy</em> and <em>getSAS</em> .  The first simply returns a special object that describes the access policy.  We create it with write-only rights, and also specify the expiration time of the rights - 5 minutes from the moment of creation.  Explicitly setting the SAS lifetime is a fairly correct approach.  If suddenly the attacker somehow gets a link from SAS, which has the Expiry option set, then he simply cannot do anything with it, since access will be closed after the expiration date and that SAS becomes useless. <br><br>  The <em>getSAS</em> function contains a fairly simple logic of creating a SAS object directly and forming part of the URL string with parameters.  All this is done using the Windows Azure API, which is connected to the current script at the very beginning. <br><br>  After finishing editing the script, do not forget to click on the Save button at the bottom of the page, otherwise all the work on the smarka. <br><br><h2>  Customer </h2><br>  So, we figured out the server logic and realized that there is nothing particularly difficult about it.  We now have a certain URL in which Shared Access Signature is registered, and now let's see what to do with it.  In the previous article, the Windows 8 application was only responsible for communicating with Windows Azure Mobile Services and WCF services, shifting the responsibility for saving binary data from blobs to other subsystems.  At the same time, the application will independently save all information to the Windows Azure services. <br><br>  To begin, let's create an empty application for Windows 8. I did not choose anything as a template, stopping at the Blank App.  Since now the article is not about how to write applications, the interface and functionality of the program will be at the minimum sufficient level.  In other words - no frills, but it works. <br><br>  From the elements of the interface on the main page of the application, I propose to place two buttons, a text field and a container for images, where we will place the images received from the camera.  I have it all look something like this: <br><br><img alt="Program Interface for Windows 8" src="https://habrastorage.org/storage2/7b8/277/c09/7b8277c090ba66ef9f2ad4c9e11a9190.png" width="1024" height="575"><br><br>  It is necessary to repent and apologize a bit to all designers and people with a good sense of taste - the application was made not for use, but for demonstration.  Accordingly, the code will also be without any frills - neither MVVM, nor other cool stuff.  Three methods, but everything is clear. <br><br>  Let's start with the fact that we define a class that will correspond to the Picture table in Mobile Services: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Picture</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [DataMember(Name = <span class="hljs-string"><span class="hljs-string">"description"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Description { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [DataMember(Name = <span class="hljs-string"><span class="hljs-string">"fileName"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FileName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [DataMember(Name = <span class="hljs-string"><span class="hljs-string">"imageurl"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ImageUrl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  This is a simple class in which Id must be a field / property.  The remaining properties are converted to similar fields in the table.  The DataMember attribute helps to explicitly indicate the name of the table field into which a particular class property should turn. <br><br>  Next, the method is responsible for obtaining images from the camera and display it on the screen: <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ButtonPhotoClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     CameraCaptureUI cameraCapture = new CameraCaptureUI(); _file = await cameraCapture.CaptureFileAsync(CameraCaptureUIMode.PhotoOrVideo); BitmapImage bitmapImage = new BitmapImage(); //    ,     FileRandomAccessStream stream = (FileRandomAccessStream)await _file.OpenAsync(FileAccessMode.Read); bitmapImage.SetSource(stream); Photo.Source = bitmapImage; }</span></span></code> </pre> <br><br>  Here, too, everything is simple.  Whoever is familiar with the development for Windows 8 (WinRT), he will immediately understand what is happening here.  And who does not know - he will guess.  First, we ask the camera for a photo or video (by the way, the video can also be transferred to the BLOB storage without any problems), and then we receive the stream from the received file, write it in a bitmap and output it to the application form.  Yes, and do not forget that to work with the camera in Windows 8, it is necessary, firstly, to register in the application manifest, that we are generally going to do this in principle, and secondly, to get permission from the user to access the device.  If any of these conditions is not met, the code above will fail with an error, because nothing is written in _file. <br><br>  Well, the only thing left for the snack is to write the received data to the Mobile Service table, get Shared Access Control from it and write the file to the cloud storage.  It sounds difficult, but in fact - a few lines of code: <br><pre> <code class="hljs pgsql"> private async <span class="hljs-type"><span class="hljs-type">void</span></span> ButtonSaveClick(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, RoutedEventArgs e) { var picture = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Picture(); picture.Description = Description.Text; picture.FileName = _file.Name; //     Mobile Service var table = App.MobileService.GetTable&lt;Picture&gt;(); await <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>.InsertAsync(picture); var containerName = "mypictures"; //     <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var fileStream = await _file.OpenStreamForReadAsync()) { await UploadBlob(fileStream, picture.FileName, picture.ImageUrl, containerName); } //  SAS  URL  picture.ImageUrl = picture.ImageUrl.Substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, picture.ImageUrl.IndexOf(<span class="hljs-string"><span class="hljs-string">'?'</span></span>)); await <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>.UpdateAsync(picture); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static async Task UploadBlob(Stream fileStream, string fileName, string blobUrl, string containerName) { fileStream.Position = <span class="hljs-number"><span class="hljs-number">0</span></span>; var sasUri = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uri(blobUrl); //  SAS  URL  StorageCredentials cred = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> StorageCredentials(sasUri.Query.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)); //   CloudBlobContainer container = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> CloudBlobContainer(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uri(string.Format("https://{0}/{1}", sasUri.Host, containerName)), cred); //   BLOB CloudBlockBlob blobFromSASCredential = container.GetBlockBlobReference(fileName); //   await blobFromSASCredential.UploadFromStreamAsync(fileStream.AsInputStream()); }</code> </pre> <br>  Let's go in order.  The ButtonSaveClick method is called when the Save button is clicked.  In it, we first form a Picture object, filling it with a value from the description field and the name of the image file.  Then begins work with Windows Azure.  We need to get the Picture table from Mobile Services and insert a new entry into it.  As you can see, this is done in two lines.  Then work with the BLOB repository.  Immediately after the new entry was inserted into the table, the Image object's ImageUrl property changed to the picture object, to which the URL of the future blob was entered, with the Shared Access Signature added to it.  With this URL, we can now access Blob Storage without knowing its name and Primary Key. <br><br>  Working with the storage is moved to a separate, but also a small method UploadBlob.  All the necessary actions fit into four simple steps.  First we get the Shared Access Signature from the URL of the image, which is passed as a query parameter.  Then, using this SAS, we get a container with which to work.  Then, in the same way, we get a blob by its name, and finally, we load the binary image data from the stream straight into Azure Blob Storage. <br><br>  Yes, I forgot to mention that in order to work with Blob Storage in Windows 8, a library is needed, which can be found <a href="">here</a> .  In NuGet, I did not find this, so you need to connect manually.  But I think that soon it will change. <br><br><h2>  Conclusion </h2><br>  In this article, I tried to visually show how you can work with data in Windows Azure from Windows 8 mobile applications more easily, reliably and without additional infrastructure layers using Windows Azure Mobile Services and Shared Access Signature.  By and large, all the logic for writing / extracting data from a table or blob storage fits into a couple of code strings, which greatly simplifies life when you need to get the result of your work as quickly as possible.  For independent developers and startups, this feature will greatly help in a successful start and will save you from the extra headache. <br><br>  PS This article was partially based on official source code examples for working with Mobile Services and Shared Access Signature.  You can familiarize yourself with this example here: <a href="http://code.msdn.microsoft.com/windowsapps/Upload-File-to-Windows-c9169190">http://code.msdn.microsoft.com/windowsapps/Upload-File-to-Windows-c9169190</a> </div><p>Source: <a href="https://habr.com/ru/post/167065/">https://habr.com/ru/post/167065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167055/index.html">Antigua and Barbuda: a country that does not pay license fees in the US</a></li>
<li><a href="../167057/index.html">WindowsAndroid allows you to run Android 4.0 ICS as a Windows application</a></li>
<li><a href="../167059/index.html">Scrum - real experience in methodology</a></li>
<li><a href="../167061/index.html">Remember the real world</a></li>
<li><a href="../167063/index.html">Selectel Cloud - About Super Habraeffect, Small Optimization, and Costs for 2 Years</a></li>
<li><a href="../167067/index.html">Database Connection Dialog</a></li>
<li><a href="../167071/index.html">Headphones Monster DNA: a comparative review on the background of Beats Solo HD</a></li>
<li><a href="../167073/index.html">THL A1 - budget smartphone with IPS screen</a></li>
<li><a href="../167075/index.html">The use of procedural generators in creating content for real-time 3D applications: Part 1. Oil Rush</a></li>
<li><a href="../167083/index.html">Winter Rating</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>