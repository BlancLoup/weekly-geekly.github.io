<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitcoin in a nutshell - Cryptography</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the reasons why Bitcoin continues to attract so much attention is its exceptional ‚Äúmathematics‚Äù. Satoshi Nakamoto managed to create a system th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitcoin in a nutshell - Cryptography</h1><div class="post__text post__text-html js-mediator-article">  One of the reasons why Bitcoin continues to attract so much attention is its exceptional ‚Äúmathematics‚Äù.  Satoshi Nakamoto managed to create a system that is able to function in the complete absence of trust between its members.  All interactions are based on rigorous mathematics, no human factor - this was what the idea was revolutionary in, and not in the peer-to-peer network, as many think.  Therefore, I decided to devote the first chapter to Bitcoin‚Äôs mathematical foundations. <br><br>  Below I will try to explain to you the most basic things - elliptic curves, ECC, private / public keys, and so on.  If possible, I will illustrate my words with code examples, mostly in Python 2.7, if something is not clear, ask in the comments. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26c/0e3/b87/26c0e3b873ba64ade7512aea9d9a7a6b.jpg" alt="intro"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Book </h3><br><ul><li>  Bitcoin in a nutshell - Cryptography </li><li>  <a href="https://habrahabr.ru/post/319860/">Bitcoin in a nutshell - Transaction</a> </li><li>  <a href="https://habrahabr.ru/post/319862/">Bitcoin in a nutshell - Protocol</a> </li><li>  <a href="https://habrahabr.ru/post/320176/">Bitcoin in a nutshell - Blockchain</a> </li><li>  <a href="https://habrahabr.ru/post/320178/">Bitcoin in a nutshell - Mining</a> </li></ul><br><br><h3>  Table of content </h3><br><ol><li>  Introduction </li><li>  Elliptic curve </li><li>  Digital signature </li><li>  Private key </li><li>  Public key </li><li>  Formats &amp; address </li><li>  Sign </li><li>  Verify </li><li>  Formats </li><li>  Links </li></ol><br><h3>  Introduction </h3><br>  As I said above, cryptography is a fundamental part of Bitcoin.  Without it, nothing would have worked, so you need to start from here. <br><br>  Bitcoin uses the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25BF%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F">elliptic</a> <em>curve cryptography (ECC</em> ).  It is based on some special function - an elliptic curve (not to be confused with an ellipse).  What is this function and why is it so remarkable, I will tell you further. <br><br><h3>  Elliptic curve </h3><br><blockquote>  Elliptical curve over field <img src="https://tex.s2cms.ru/svg/K" alt="K">  - non-singular cubic curve on the projective plane above <img src="https://tex.s2cms.ru/svg/%20%7B%5Chat%20%7BK%7D%7D%20" alt="{\ hat {K}}">  (algebraic closure of the field <img src="https://tex.s2cms.ru/svg/%20K%20" alt="K">  ), given by a 3rd degree equation with coefficients from the field <img src="https://tex.s2cms.ru/svg/%20K%20" alt="K">  and "point at infinity" - <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25BB%25D0%25B8%25D0%25BF%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F">Wikipedia</a> <br></blockquote><br>  If on the fingers, then the elliptic curve is an outwardly rather simple function, usually written in the form of the so-called Weierstrass form: <img src="https://tex.s2cms.ru/svg/%20y%5E%7B2%7D%3Dx%5E%7B3%7D%2Bax%2Bb%20" alt="y ^ {2} = x ^ {3} + ax + b"><br><br>  Depending on the values ‚Äã‚Äãof the parameters <img src="https://tex.s2cms.ru/svg/a" alt="a">  and <img src="https://tex.s2cms.ru/svg/b" alt="b">  The graph of this function may look different: <br><br><img src="https://habrastorage.org/files/ee8/746/c92/ee8746c9232b4033afd629279d5a3a8b.png" alt="elliptic curves"><br><br>  Script for drawing graphics in Python: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> a = <span class="hljs-number"><span class="hljs-number">-1</span></span> b = <span class="hljs-number"><span class="hljs-number">1</span></span> y, x = np.ogrid[<span class="hljs-number"><span class="hljs-number">-5</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">100j</span></span>, <span class="hljs-number"><span class="hljs-number">-5</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">100j</span></span>] plt.contour(x.ravel(), y.ravel(), pow(y, <span class="hljs-number"><span class="hljs-number">2</span></span>) - pow(x, <span class="hljs-number"><span class="hljs-number">3</span></span>) - x * a - b, [<span class="hljs-number"><span class="hljs-number">0</span></span>]) plt.grid() plt.show() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre> <br>  If you believe the wiki, then for the first time this feature appeared in the writings of Diophantus, and later, in the 17th century, Newton himself became interested in it.  His research led in many respects to the formulas for adding points on an elliptic curve, which we will now become acquainted with.  Here and in the following we will consider some elliptic curve. <img src="https://tex.s2cms.ru/svg/%5Calpha" alt="\ alpha">  . <br><br>  Let there be two points <img src="https://tex.s2cms.ru/svg/P%2C%20Q%20%5Cin%20%5Calpha" alt="P, Q \ in \ alpha">  .  Their sum is called point <img src="https://tex.s2cms.ru/svg/R%20%5Cin%20%5Calpha" alt="R \ in \ alpha">  which in the simplest case is defined as follows: let's draw a straight line through <img src="https://tex.s2cms.ru/svg/P" alt="P">  and <img src="https://tex.s2cms.ru/svg/Q" alt="Q">  - she will cross the curve <img src="https://tex.s2cms.ru/svg/%5Calpha" alt="\ alpha">  at a single point let's call it <img src="https://tex.s2cms.ru/svg/-R" alt="-R">  .  Exchanging <img src="https://tex.s2cms.ru/svg/y" alt="y">  point coordinate <img src="https://tex.s2cms.ru/svg/-R" alt="-R">  on the opposite sign, we get a point <img src="https://tex.s2cms.ru/svg/R" alt="R">  which we will call the sum <img src="https://tex.s2cms.ru/svg/P" alt="P">  and <img src="https://tex.s2cms.ru/svg/Q" alt="Q">  , i.e <img src="https://tex.s2cms.ru/svg/P%20%2B%20Q%20%3D%20R" alt="P + Q = R">  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bb/383/fb3/0bb383fb37b1164c914bceb4305362ec.jpg" alt="ellitic_curve_addiction"><br><br>  I consider it necessary to note that we are <strong>introducing</strong> such an operation of addition - if you add points in the usual sense, that is, by adding the corresponding coordinates, you will get a completely different point <img src="https://tex.s2cms.ru/svg/R'%20(x_1%20%2B%20x_2%2C%20y_1%20%2B%20y_2)" alt="R '(x_1 + x_2, y_1 + y_2)">  which most likely has nothing to do with <img src="https://tex.s2cms.ru/svg/R" alt="R">  or <img src="https://tex.s2cms.ru/svg/-R" alt="-R">  and generally does not lie on the curve <img src="https://tex.s2cms.ru/svg/%5Calpha" alt="\ alpha">  . <br><br>  The most savvy have already wondered - what will happen if, for example, we draw a line through two points that have coordinates of the form? <img src="https://tex.s2cms.ru/svg/P%20(a%2C%20b)" alt="P (a, b)">  and <img src="https://tex.s2cms.ru/svg/Q%20(a%2C%20-b)" alt="Q (a, -b)">  , that is, the straight line passing through them will be parallel to the axis of ordinates (the third frame in the picture below). <br><br><img src="https://habrastorage.org/files/688/4f9/518/6884f95189be44acae28a94d578c4191.png" alt="elliptic_curve_parallel"><br><br>  It is easy to see that in this case there is no third intersection with the curve. <img src="https://tex.s2cms.ru/svg/%5Calpha" alt="\ alpha">  which we called <img src="https://tex.s2cms.ru/svg/-R" alt="-R">  .  In order to avoid this incident, we introduce the so-called <strong>point in infinity</strong> (point of infinity), usually denoted <img src="https://tex.s2cms.ru/svg/O" alt="O">  or simply <img src="https://tex.s2cms.ru/svg/0">  , like on a picture.  And we will say that in the absence of intersection <img src="https://tex.s2cms.ru/svg/P%20%2B%20Q%20%3D%20O" alt="P + Q = O">  . <br><br>  Of particular interest to us is the case when we want to add a point to itself (2 frame, point <img src="https://tex.s2cms.ru/svg/Q" alt="Q">  ).  In this case, simply draw a tangent to the point. <img src="https://tex.s2cms.ru/svg/Q" alt="Q">  and reflect the resulting intersection point with respect to <img src="https://tex.s2cms.ru/svg/y" alt="y">  . <br><br>  Now, with a flick of the wrist, you can enter the operation of multiplying a point by some <img src="https://tex.s2cms.ru/svg/%5Cmathbb%7BN%7D" alt="\ mathbb {N}">  number.  As a result, we get a new point. <img src="https://tex.s2cms.ru/svg/K%20%3D%20G*k" alt="K = G * k">  , i.e <img src="https://tex.s2cms.ru/svg/K%20%3D%20G%20%2B%20G%20%2B%20...%20%2B%20G%2C%20%5C%20k" alt="K = G + G + ... + G, \ k">  time.  With the picture, everything should become generally clear: <br><br><img src="https://habrastorage.org/files/35f/451/fd9/35f451fd97464f7ca56471e285f82def.png" alt="Elliptic curve multiplication"><br><br><h4>  Elliptic curve over a finite field </h4><br>  The <em>ECC</em> uses exactly the same curve, only viewed over some finite field. <img src="https://tex.s2cms.ru/svg/%7BF%7D%20_%7Bp%7D%3D%5Cmathbb%7BZ%7D%20%2F%20%5Cmathbb%7BZ%7D_p%20%3D%20%5C%7B0%2C%201%2C%20...%2C%20p%20-%201%5C%7D%2C%20%D0%B3%D0%B4%D0%B5%20" alt="{F} _ {p} = \ mathbb {Z} / \ mathbb {Z} _p = \ {0, 1, ..., p - 1 \}, where"><img src="https://tex.s2cms.ru/svg/p" alt="p">  - Prime number.  I.e <br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0Ay%5E2%5C%20mod%5C%20p%20%3D%20x%5E3%20%2B%20ax%20%2B%20b%20%5C%20(mod%5C%20p)%0A" alt="y ^ 2 \ mod \ p = x ^ 3 + ax + b \ (mod \ p)"></div><p></p><br>  All the named properties (addition, multiplication, point in infinity) for such a function remain in force, although if you try to draw this function, then it will resemble the usual elliptic curve only remotely (at best).  And the concept of ‚Äútangent to a function at a point‚Äù generally loses all meaning, but that‚Äôs okay.  Here is an example function <img src="https://tex.s2cms.ru/svg/y%5E2%20%3D%20x%5E3%20%2B%207" alt="y ^ 2 = x ^ 3 + 7">  for <img src="https://tex.s2cms.ru/svg/p%3D17" alt="p = 17">  : <br><br><img src="https://habrastorage.org/files/b88/d43/1ec/b88d431ec74b422c995fe7a95fe4f4d0.png" alt="elliptic_curve_over_17"><br><br>  But for <img src="https://tex.s2cms.ru/svg/p%3D59" alt="p = 59">  , there is generally an almost chaotic set of points.  The only thing that still reminds of the origin of this graph is symmetry about the axis <img src="https://tex.s2cms.ru/svg/X" alt="X">  . <br><br><img src="https://habrastorage.org/files/48a/74b/f17/48a74bf177fc4bb0bfa86678bccf6125.png" alt="elliptic_curve_59"><br><br>  <strong>PS</strong> If you are interested, as in the case of a curve over a finite field, calculate the coordinates of a point <img src="https://tex.s2cms.ru/svg/R%20(x_3%2C%20y_3)" alt="R (x_3, y_3)">  knowing the coordinates <img src="https://tex.s2cms.ru/svg/P(x_1%2C%20y_1)" alt="P (x_1, y_1)">  and <img src="https://tex.s2cms.ru/svg/Q(x_2%2C%20y_2)" alt="Q (x_2, y_2)">  - you can look through <a href="http://www.slideshare.net/NikeshMistry1/introduction-to-bitcoin-and-ecdsa">‚ÄúAn introduction to Bitcoin, Elliptic Curves and the Mathematics of ECDSA‚Äù by N. Mistry</a> , everything is detailed there, it is enough to know mathematics at the grade 8 level. <br><br>  <strong>PPS</strong> In case my examples did not satisfy your inquiring mind, here is a <a href="https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-add.html">website</a> for drawing curves of all sorts, experiment. <br><br><h4>  SECP256k1 </h4><br>  Returning to Bitcoin, it uses the <a href="https://en.bitcoin.it/wiki/Secp256k1">SECP256k1</a> curve.  She has a look <img src="https://tex.s2cms.ru/svg/y%5E2%20%3D%20x%5E3%20%2B%207" alt="y ^ 2 = x ^ 3 + 7">  and viewed over the field <img src="https://tex.s2cms.ru/svg/F_p" alt="F_p">  where <img src="https://tex.s2cms.ru/svg/p" alt="p">  - a very large prime number, namely <img src="https://tex.s2cms.ru/svg/2%5E%7B256%7D%20-%202%5E%7B32%7D%20-%202%5E%7B9%7D%20-%202%5E%7B8%7D%20-%202%5E%7B7%7D%20-%202%5E%7B6%7D%20-%202%5E%7B4%7D%20-%201" alt="2 ^ {256} - 2 ^ {32} - 2 ^ {9} - 2 ^ {8} - 2 ^ {7} - 2 ^ {6} - 2 ^ {4} - 1">  . <br><br>  Also for SECP256k1 the so-called <em>base point is</em> defined, it‚Äôs also a <em>generator point</em> - this is just a point, as a rule, denoted <img src="https://tex.s2cms.ru/svg/G" alt="G">  lying on a given curve.  It is needed to create a public key, which will be described below. <br><br>  A simple example: using Python, check if a dot belongs <img src="https://tex.s2cms.ru/svg/G%20(x%2C%20y)" alt="G (x, y)">  curve <em>SECP256k1</em> <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>p = <span class="hljs-number"><span class="hljs-number">115792089237316195423570985008687907853269984665640564039457584007908834671663</span></span> &gt;&gt;&gt; x = <span class="hljs-number"><span class="hljs-number">55066263022277343669578718895168534326250603453777594175500187360389116729240</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">32670510020758816978083085130507043184471273380659243275938904335757337482424</span></span> &gt;&gt;&gt; (x ** <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">7</span></span>) % p == y**<span class="hljs-number"><span class="hljs-number">2</span></span> % p <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br><h3>  Digital signature </h3><br><blockquote>  Electronic signature (EDS), Electronic digital signature (EDS) - the attribute of an electronic document obtained as a result of cryptographic transformation of information using the private key of the signature and allowing to verify the absence of distortion of information in the electronic document from the moment of signature formation (integrity) signatures (authorship), and in case of successful verification, confirm the fact of signing an electronic document (non-repudiation) - <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">Wikipedia</a> <br></blockquote><br>  The general idea is this: Alice wants to translate 1 BTC to Bob.  To do this, it creates a message like: <br><br><pre> <code class="hljs pgsql">{ "from" : <span class="hljs-number"><span class="hljs-number">1</span></span>FXySbm7jpJfHEJRjSNPPUqnpRTcSuS8aN, // Alic<span class="hljs-string"><span class="hljs-string">e's address "to" : 1Eqm3z1yu6D4Y1c1LXKqReqo1gvZNrmfvN, // Bob'</span></span>s address "amount" : <span class="hljs-number"><span class="hljs-number">1</span></span> // Send <span class="hljs-number"><span class="hljs-number">1</span></span> BTC }</code> </pre><br><br>  Then Alice takes her private key (for now, you can assume that this is a number known only to Alice), a hash of the message, and a function like <img src="https://tex.s2cms.ru/svg/sign%5C_text(private%5C_key%2C%20text)" alt="sign \ _text (private \ _key, text)">  .  At the output, she receives the <em>signature of</em> her message - in the case of ECDSA it will be a pair of integers, for other algorithms the signature may look different.  After that, it sends to all members of the network the original message, signature and its public key. <br><br>  As a result, each Vasya, if he wishes, will be able to take this trinity, a function of the form <img src="https://tex.s2cms.ru/svg/validate%5C_signature(public%5C_key%2C%20signature%2C%20text)" alt="validate \ _signature (public \ _key, signature, text)">  and check whether the owner of the private key really signed this message or not.  And if everyone inside the network knows that <img src="https://tex.s2cms.ru/svg/public%5C_key" alt="public \ _key">  belongs to Alice, it can be understood, she sent the money or someone tries to do it on her behalf. <br><br><img src="https://habrastorage.org/files/b23/856/57d/b2385657dd3545998a0b0bc4af4a0fd5.png" alt="digital_signature_scheme"><br><br>  Moreover, suppose there is a person standing between Alice and the rest of the network.  Let him intercept Alice's message and change something in him, literally 1 bit out of a billion.  But even in this case, the verification of the signature on the validity <img src="https://tex.s2cms.ru/svg/validate%5C_signature(public%5C_key%2C%20signature%2C%20text')" alt="validate \ _signature (public \ _key, signature, text ')">  will show that the message has been changed. <br><br>  This is a very important feature for Bitcoin, because the network is <em>distributed</em> .  We cannot know in advance who our transaction will go to with the requirement to transfer 1000 BTC.  But he will not be able to change it (for example, specify his address as a recipient), because the transaction is signed with your private key, and the rest of the network will immediately realize that there is something wrong. <br><br>  <strong>Ahtung</strong>  In fact, the process is quite different from the above.  Here I just showed on my fingers what a digital signature is and why it is needed.  The real algorithm is described in the chapter <a href="https://habrahabr.ru/post/319860/">‚ÄúBitcoin in a nutshell - Transactions‚Äù</a> . <br><br><h3>  Private key </h3><br>  <em>A private key</em> is a fairly generic term, and different types of private keys can be used in various electronic signature algorithms. <br><br>  As you may have noticed, Bitcoin uses the ECDSA algorithm ‚Äî in this case, the private key is some natural 256 bit number, that is, the most common integer from <img src="https://tex.s2cms.ru/svg/1" alt="one">  before <img src="https://tex.s2cms.ru/svg/2%5E%7B256%7D" alt="2 ^ {256}">  .  Technically, even the number <em>123456</em> will be the correct private key, but very soon you will find out that your coins "belong" to you exactly until the attacker has your private key, and values ‚Äã‚Äãlike <em>123456 are</em> very easy to get through. <br><br>  It is important to note that, to date, it is impossible to sort through all the keys because <img src="https://tex.s2cms.ru/svg/2%5E%7B256%7D" alt="2 ^ {256}">  - this is a fantastically large number. <br><br>  We will try to present it: according to <a href="http://www.quickanddirtytips.com/education/math/how-many-grains-of-sand-are-on-earth%25E2%2580%2599s-beaches">this article</a> , a little less on the whole Earth <img src="https://tex.s2cms.ru/svg/10%5E%7B22%7D" alt="10 ^ {22}">  sand grains.  We take advantage of the fact that <img src="https://tex.s2cms.ru/svg/2%5E%7B10%7D%5Capprox10%5E%7B3%7D" alt="2 ^ {10} \ approx10 ^ {3}">  , i.e <img src="https://tex.s2cms.ru/svg/10%5E%7B22%7D%5Capprox2%5E%7B80%7D" alt="10 ^ {22} \ approx2 ^ {80}">  sand grains.  And all the addresses we have <img src="https://tex.s2cms.ru/svg/2%5E%7B256%7D" alt="2 ^ {256}">  , about <img src="https://tex.s2cms.ru/svg/%7B2%5E%7B80%7D%7D%5E3" alt="{2 ^ {80}} ^ 3">  . <br><br>  So, we can take all the sand on Earth, turn every grain of sand into a new Earth, in the resulting heap of planets every grain of sand on each planet will be turned into a new Earth again, and the total number of grains of sand will still be orders of magnitude less than the number of possible private keys. <br><br>  For the same reason, most Bitcoin clients simply take 256 random bits when creating a private key - the probability of a collision is extremely small. <br><br><h4>  Python </h4><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random &gt;&gt;&gt; private_key = <span class="hljs-string"><span class="hljs-string">''</span></span>.join([<span class="hljs-string"><span class="hljs-string">'%x'</span></span> % random.randrange(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>)]) &gt;&gt;&gt; private_key <span class="hljs-string"><span class="hljs-string">'9ceb87fc34ec40408fd8ab3fa81a93f7b4ebd40bba7811ebef7cbc80252a9815'</span></span> &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># or &gt;&gt;&gt; import os &gt;&gt;&gt; private_key = os.urandom(32).encode('hex') &gt;&gt;&gt; private_key '0a56184c7a383d8bcce0c78e6e7a4b4b161b2f80a126caa48bde823a4625521f'</span></span></code> </pre><br><h4>  Python, <a href="https://github.com/warner/python-ecdsa">ECDSA</a> </h4><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> binascii &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ecdsa <span class="hljs-comment"><span class="hljs-comment"># sudo pip install ecdsa &gt;&gt;&gt; private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1) &gt;&gt;&gt; binascii.hexlify(private_key.to_string()).decode('ascii').upper() u'CE47C04A097522D33B4B003B25DD7E8D7945EA52FA8931FD9AA55B315A39DC62'</span></span></code> </pre><br><h4>  Bitcoin-cli </h4><br><br><pre> <code class="hljs ruby">$ bitcoin-cli getnewaddress <span class="hljs-number"><span class="hljs-number">14</span></span>RVpC4su4PzSafjCKVWP2YBHv3f6zNf6U $ bitcoin-cli dumpprivkey <span class="hljs-number"><span class="hljs-number">14</span></span>RVpC4su4PzSafjCKVWP2YBHv3f6zNf6U L3SPdkFWMnFyDGyV3vkCjroGi4zfD59Wsc5CHdB1LirjN6s2vii9</code> </pre><br><h3>  Public key </h3><br>  Let be <img src="https://tex.s2cms.ru/svg/k" alt="k">  - our private key, <img src="https://tex.s2cms.ru/svg/G" alt="G">  - base point, then the public key <img src="https://tex.s2cms.ru/svg/K%3DG*k" alt="K = G * k">  .  That is, in fact, the <em>public key</em> is a certain point lying on the SECP256k1 curve. <br><br>  Two important nuances.  First, it is easy to see that the operation of obtaining a public key is uniquely defined, that is, a single private key always corresponds to a specific private key.  Secondly, the inverse operation is computationally difficult and, in the general case, obtaining a private key from the public one can only be done through the first search. <br><br>  Below you will find out that the exact same connection exists between the public key and the address, only there it is all about the irreversibility of hash functions. <br><br><img src="https://habrastorage.org/files/3ff/4e5/f93/3ff4e5f939a847b2aa40bfe4701f4bd9.png" alt="keys_to_address"><br><br><h4>  Python, ECDSA </h4><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> binascii &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ecdsa &gt;&gt;&gt; private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1) &gt;&gt;&gt; public_key = private_key.get_verifying_key() &gt;&gt;&gt; binascii.hexlify(public_key.to_string()).decode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>).upper() <span class="hljs-string"><span class="hljs-string">u'D5C08F1BFC9C26A5D18FE9254E7923DEBBD34AFB92AC23ABFC6388D2659446C1F04CCDEBB677EAABFED9294663EE79D71B57CA6A6B76BC47E6F8670FE759D746'</span></span></code> </pre><br><h4>  C ++, <a href="https://github.com/libbitcoin/libbitcoin">libbitcoin</a> </h4><br><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;bitcoin/bitcoin.hpp&gt; <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;iostream&gt; int main() { // <span class="hljs-type"><span class="hljs-type">Private</span></span> key bc::ec_secret secret = bc::decode_hash( <span class="hljs-comment"><span class="hljs-comment">"038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776"</span></span>); // <span class="hljs-type"><span class="hljs-type">Get</span></span> public key bc::ec_point public_key = bc::secret_to_public_key(secret); std::cout &lt;&lt; <span class="hljs-comment"><span class="hljs-comment">"Public key: "</span></span> &lt;&lt; bc::encode_hex(public_key) &lt;&lt; std::endl; }</code> </pre><br>  To compile and run use (pre-install libbitcoin): <br><br><pre> <code class="bash hljs">$ g++ -o public_key &lt;filename&gt; $$(pkg-config --cflags --libs libbitcoin) $ ./public_key Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa</code> </pre><br>  You can see that the public key formats in the first and second examples are different (at least in length), which I will discuss in more detail below. <br><br><h3>  Formats &amp; address </h3><br><h4>  Base58Check encoding </h4><br>  We will meet this encoding all the time throughout the book, so it‚Äôs worth understanding how it works and why it is needed at all. <br><br>  Its essence is to maximally jot down a sequence of bytes in a readable format and, at the same time, make the probability of possible typos even less.  I think you understand that in the case of Bitcoin, security is not superfluous.  One wrong character and money will go to the address, the keys to which most likely no one will ever find.  Here is a comment on this encoding from in <a href="">base58.h</a> : <br><blockquote><pre> <code class="hljs pgsql">// Why base<span class="hljs-number"><span class="hljs-number">-58</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instead</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> standard base<span class="hljs-number"><span class="hljs-number">-64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">encoding</span></span>? // - Don<span class="hljs-string"><span class="hljs-string">'t want 0OIl characters that look the same in some fonts and // could be used to create visually identical looking account numbers. // - A string with non-alphanumeric characters is not as easily accepted as an account number. // - E-mail usually won'</span></span>t <span class="hljs-type"><span class="hljs-type">line</span></span>-break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ther<span class="hljs-string"><span class="hljs-string">e's no punctuation to break at. // - Doubleclicking selects the whole number as one word if it'</span></span>s <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> alphanumeric.</code> </pre><br></blockquote><br>  The brevity of the record is easiest to implement using the fairly common <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> encoding, that is, using the base number system 64, where the digits are <code>0,1,...,9</code> , the letters <code>az</code> and <code>AZ</code> - this gives 62 characters, the remaining two can be anything, depending on the implementation. <br><br>  The first difference of <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58Check</a> is that the characters <code>0,O,l,I</code> removed in case someone decides to confuse them.  It turns out 58 characters, you can check <br><br><pre> <code class="python hljs">b58 = <span class="hljs-string"><span class="hljs-string">'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base58encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: result = b58[n%<span class="hljs-number"><span class="hljs-number">58</span></span>] + result n /= <span class="hljs-number"><span class="hljs-number">58</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-comment"><span class="hljs-comment"># print "Base58 encode for '123123':", base58encode(123123) # # Base58 encode for '123123': dbp</span></span></code> </pre><br>  The second difference is the same <em>check</em> .  <em>Checksum</em> is added to the end of the line - the first 4 bytes of <code>SHA256(SHA256(str))</code> .  Well, you still need to add as many units to the beginning as there were leading zeros before encoding in base58, this is already a matter of technique. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base58encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> b58 = <span class="hljs-string"><span class="hljs-string">'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'</span></span> result = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: result = b58[n % <span class="hljs-number"><span class="hljs-number">58</span></span>] + result n /= <span class="hljs-number"><span class="hljs-number">58</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result <span class="hljs-comment"><span class="hljs-comment"># Will be used to decode raw bytes and then encode them to the base58 def base256decode(s): result = 0 for c in s: result = result * 256 + ord(c) return result def countLeadingZeroes(s): count = 0 for c in s: if c == '\0': count += 1 else: break return count def base58CheckEncode(prefix, payload): s = chr(prefix) + payload checksum = hashlib.sha256(hashlib.sha256(s).digest()).digest()[0:4] result = s + checksum return '1' * countLeadingZeroes(result) + base58encode(base256decode(result))</span></span></code> </pre><br><img src="https://habrastorage.org/files/8dc/200/25b/8dc20025b1bd4a8d99720a344219d267.png"><br><br><h4>  Private key formats </h4><br>  The most obvious way to store a private key is to write 256 bits in a heap of zeros and ones.  But, probably, any technically literate person understands that it will be much easier to represent the same sequence in the form of 32 bytes, where each byte corresponds to two characters in hexadecimal.  Let me remind you that in this case the numbers <code>0,1,...,9</code> and the letters <code>A,B,C,D,E,F</code> .  I used this format in the examples above, for beauty it is sometimes separated by spaces. <br><br><pre> <code class="markdown hljs">E9 87 3D 79 C6 D8 7D C0 FB 6A 57 78 63 33 89 F4 45 32 13 30 3D A6 1F 20 BD 67 FC 23 3A A3 32 62</code> </pre><br>  Another more progressive format is <a href="https://en.bitcoin.it/wiki/Wallet_import_format">WIF</a> ( <em>Wallet Import Format</em> ).  It is built quite simply: <br><ol><li>  We take a private key, for example <code>0C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D</code> </li><li>  We write it in Base58Check with the prefix <code>0x80</code> .  Everything. </li></ol><br><br><pre> <code class="python hljs">private_key = <span class="hljs-string"><span class="hljs-string">'0a56184c7a383d8bcce0c78e6e7a4b4b161b2f80a126caa48bde823a4625521f'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateKeyToWif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key_hex)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base58CheckEncode(<span class="hljs-number"><span class="hljs-number">0x80</span></span>, key_hex.decode(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># print "Private key in WIF format:", privateKeyToWif(private_key) # # Private key in WIF format: 5HtqcFguVHA22E3bcjJR2p4HHMEGnEXxVL5hnxmPQvRedSQSuT4</span></span></code> </pre><br><h4>  Public key formats </h4><br>  Just in case, I remind you that the public key is just a point on the line SECP256k1.  The first and most common variant of his record is <em>uncompressed</em> format, 32 bytes <em>each</em> for X and Y coordinates.  To avoid confusion, use the prefix <code>0x04</code> and that 65 bytes. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ecdsa private_key = <span class="hljs-string"><span class="hljs-string">'0a56184c7a383d8bcce0c78e6e7a4b4b161b2f80a126caa48bde823a4625521f'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateKeyToPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> sk = ecdsa.SigningKey.from_string(s.decode(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>), curve=ecdsa.SECP256k1) vk = sk.verifying_key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-string"><span class="hljs-string">'\04'</span></span> + sk.verifying_key.to_string()).encode(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) uncompressed_public_key = privateKeyToPublicKey(private_key) <span class="hljs-comment"><span class="hljs-comment"># print "Uncompressed public key: {}, size: {}".format(uncompressed_public_key, len(uncompressed_public_key) / 2) # # Uncompressed public key: 045fbbe96332b2fc2bcc1b6a267678785401ee3b75674e061ca3616bbb66777b4f946bdd2a6a8ce419eacc5d05718bd718dc8d90c497cee74f5994681af0a1f842, size: 65</span></span></code> </pre><br>  However, as the name suggests, this is not the best way to store a public key. <br><br>  You'd be surprised, but the second format is called <em>compressed</em> .  Its essence is as follows: the public key is a point on the curve, that is, a pair of numbers satisfying the equation <img src="https://tex.s2cms.ru/svg/y%5E2%5C%20mod%5C%20p%20%3D%20x%5E2%20%2B%20ax%20%2B%20b%20%5C%20(mod%5C%20p)" alt="y ^ 2 \ mod \ p = x ^ 2 + ax + b \ (mod \ p)">  .  So it is possible to write down only the X coordinate, and if we need the Y coordinate, we just solve the equation.  Thus, we reduce the size of the public key by almost 50%! <br><br>  The only caveat is that if a point lies on a curve, then for its X coordinate there are obviously two solutions to such an equation (look at the graphs above if in doubt).  Usually we would simply keep the sign for the Y coordinate, but when it comes to the function over a finite field, then we need to use the following property: <strong>if for the X coordinate there are solutions to the equation, then one of the points will have an even Y coordinate, and the second will be odd</strong> (again you can see for yourself). <br><br>  In the first case, the prefix <code>0x02</code> , in the second - <code>0x03</code> .  Here is an illustration of the process: <br><br><img src="https://habrastorage.org/files/793/2f2/f69/7932f2f69859427db1e43da99384dba0.png" alt="Compressed public key"><br><br><h4>  Address </h4><br>  As already mentioned, the address is obtained from the public key unambiguously.  Moreover, it is impossible to perform the inverse operation, since the cryptographically <a href="https://en.wikipedia.org/wiki/RIPEMD">secure</a> hash functions, <a href="https://en.wikipedia.org/wiki/RIPEMD">RIPEMD160</a> and <a href="https://en.wikipedia.org/wiki/SHA-2">SHA256, are used</a> .  Here is the algorithm for transferring the public key to the address: <br><ol><li>  Take a private key, for example <code>45b0c38fa54766354cf3409d38b873255dfa9ed3407a542ba48eb9cab9dfca67</code> </li><li>  We obtain from it the public key in <em>uncompressed</em> format, in this case <code>04162ebcd38c90b56fbdb4b0390695afb471c944a6003cb334bbf030a89c42b584f089012beb4842483692bdff9fcab8676fed42c47bffb081001209079bbcb8db</code> . </li><li>  We consider <code>RIPEMD160(SHA256(public_key))</code> , it turns out <code>5879DB1D96FC29B2A6BDC593E67EDD2C5876F64C</code> </li><li>  We translate the result into <em>Base58Check</em> with the prefix <code>0x00</code> - <code>17JdJpDyu3tB5GD3jwZP784W5KbRdfb84X</code> .  This is the address. </li></ol><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pubKeyToAddr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> ripemd160 = hashlib.new(<span class="hljs-string"><span class="hljs-string">'ripemd160'</span></span>) ripemd160.update(hashlib.sha256(s.decode(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>)).digest()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base58CheckEncode(<span class="hljs-number"><span class="hljs-number">0</span></span>, ripemd160.digest()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyToAddr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pubKeyToAddr(privateKeyToPublicKey(s)) <span class="hljs-comment"><span class="hljs-comment"># print keyToAddr("45b0c38fa54766354cf3409d38b873255dfa9ed3407a542ba48eb9cab9dfca67") # # '17JdJpDyu3tB5GD3jwZP784W5KbRdfb84X'</span></span></code> </pre><br><h3>  Sign &amp; verify </h3><br>  I don‚Äôt think you need to know the technical details of exactly how <em>ECDSA</em> signs and verifies messages, anyway you will use ready-made libraries everywhere.  The main thing is that you have a general understanding of why this is needed, but if you are still interested in it - look through the <a href="http://royalforkblog.github.io/2014/09/04/ecc/">Layman's Guide to Elliptic Curve Digital Signatures</a> , there is a beautiful visualization of the whole process below, you can try it yourself. <br><br>  I have it all, the next chapter: <a href="https://habrahabr.ru/post/319860/">Bitcoin in a nutshell - Transaction</a> . <br><br><h3>  Links </h3><br><ul><li>  <a href="http://www.slideshare.net/NikeshMistry1/introduction-to-bitcoin-and-ecdsa">"An Introduction to Bitcoin, Elliptic Curves and the Mathematics of ECDSA" by N. Mistry</a> </li><li>  <a href="http://www.nicolascourtois.com/bitcoin/thesis_Di_Wang.pdf">"Secure Implementation of ECDSA Signatures in Bitcoin" by Di Wang</a> </li><li>  <a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a> </li><li>  <a href="https://habrahabr.ru/post/188958/">Elliptical cryptography: theory</a> </li><li>  <a href="https://davanum.wordpress.com/2014/03/17/generating-a-bitcoin-private-key-and-address/">Generating A Bitcoin Private Key And Address</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/319868/">https://habr.com/ru/post/319868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319858/index.html">dock: a simple library of unit testing C ++ code</a></li>
<li><a href="../319860/index.html">Bitcoin in a nutshell - Transaction</a></li>
<li><a href="../319862/index.html">Bitcoin in a nutshell - Protocol</a></li>
<li><a href="../319864/index.html">One of the easiest ways to improve your programming skills is to read someone else's code.</a></li>
<li><a href="../319866/index.html">Interesting in March: DevOpsDays in Moscow</a></li>
<li><a href="../319872/index.html">Bored Powershell</a></li>
<li><a href="../319876/index.html">Python: collections, part 3/4: combining collections, adding and removing items</a></li>
<li><a href="../319878/index.html">Four options for strategic planning of IT infrastructure</a></li>
<li><a href="../319880/index.html">Generating dummy data with Mimesis: Part II</a></li>
<li><a href="../319884/index.html">Optimization of the portal design team using Sketch and the cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>