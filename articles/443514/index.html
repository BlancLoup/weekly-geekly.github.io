<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our network layer on Swift: a protocol-oriented approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now almost 100% of applications use networking, so the question of organizing and using the network layer arises before everyone. There are two main a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our network layer on Swift: a protocol-oriented approach</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/gg/rb/pk/ggrbpkas55pf0eigg33hin46i0g.png"><br><br>  Now almost 100% of applications use networking, so the question of organizing and using the network layer arises before everyone.  There are two main approaches to solving this problem, it is either the use of third-party libraries, or your own implementation of the network layer.  In this article, we will look at the second option, and we will try to implement the network layer using all the latest features of the language, using protocols and enumerations.  This will save the project from unnecessary dependencies in the form of additional libraries.  Those who have ever seen Moya will immediately recognize many similar details in implementation and use, the way it is, only this time we will do everything with our own hands, without touching Moya and Alamofire. <br><a name="habracut"></a><br><br>  In this guide, we will look at how to implement the network layer on pure Swift, without using any third-party libraries.  After you get acquainted with this article, your code will be 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  protocol-oriented </li><li>  easy to use </li><li>  easy to use </li><li>  type safe </li><li>  endpoints will use enumerations </li></ul><br><br>  Below is an example of how the use of our network layer will look like after its implementation: <br><br><img src="https://habrastorage.org/webt/zg/f5/jy/zgf5jybl_jika5ljlt-h3pcdg1e.png"><br><br>  By writing just <i><b>router.request (.</b></i> And using the full power of the enumerations, we will see all the variations of possible queries and their parameters. <br><br>  <b>First, a little about the project structure</b> <br><br>  Whenever you create something new, and in order to be able to understand everything easily in the future, it is very important to organize and structure everything correctly.  I adhere to the belief that a properly organized folder structure is an important detail when building an application architecture.  In order for everything to be correctly arranged in folders, let's create them in advance.  This is how the general folder structure in the project will look like: <br><br><img src="https://habrastorage.org/webt/vw/fz/y0/vwfzy0nlpqmg6mccy85s2q6iqrg.png"><br><br>  <b>EndPointType Protocol</b> <br><br>  First of all, we need to define our <i><b>EndPointType</b></i> protocol.  This protocol will contain all the necessary information for configuring the request.  What is a request (endpoint)?  In essence, this is a URLRequest with all related components, such as headers, request parameters, request body.  The <i><b>EndPointType</b></i> protocol is the most important part of our network layer implementation.  Let's create a file and name it <i><b>EndPointType</b></i> .  Put this file in the Service folder (not in the EndPoint folder, why - it will be clear a little later) <br><br><img src="https://habrastorage.org/webt/-9/j0/ul/-9j0ulvgk-w_hftxxyqwolmbujy.png"><br><br>  <b>HTTP Protocols</b> <br><br>  Our <i><b>EndPointType</b></i> contains several protocols that we need to create a request.  Let's see what these protocols are. <br><br>  <b>HTTPMethod</b> <br><br>  Create a file, name it <i><b>HTTPMethod</b></i> and place it in the Service folder.  This enumeration will be used to set the HTTP method of our request. <br><br><img src="https://habrastorage.org/webt/j2/3x/nr/j23xnrcovqknw9dzxhf-xva898q.png"><br><br>  <b>HTTPTask</b> <br>  Create a file, name it <i><b>HTTPTask</b></i> and place it in the Service folder.  HTTPTask is responsible for configuring the parameters of a particular request.  You can add as many different query options to it as you need, but I, in turn, am going to make regular queries, queries with parameters, queries with parameters and headers, so I will only make these three types of queries. <br><br><img src="https://habrastorage.org/webt/v5/4m/j6/v54mj6yxsvdwuiossyq3em2biia.png"><br><br>  In the next section, we will discuss <i><b>Parameters</b></i> and how we will work with them. <br><br>  <b>Httpheaders</b> <br><br>  <i><b>HTTPHeaders</b></i> is just a typealias for a dictionary.  You can create it at the top of your <i><b>HTTPTask</b></i> file. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">HTTPHeaders</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><br>  <b>Parameters &amp; Encoding</b> <br><br>  Create a file, name it <i><b>ParameterEncoding</b></i> and place it in the Encoding folder.  Create typealias for <i><b>Parameters</b></i> , this will again be a regular dictionary.  We do this to make the code look clearer and readable. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Parameters</span></span> = [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">Any</span></span>]</code> </pre> <br><br>  Next, we define the <i><b>ParameterEncoder</b></i> protocol with a single encode function.  The encode method has two parameters: <i><b>inout URLRequest</b></i> and <i><b>Parameters</b></i> .  <b>INOUT</b> is a keyword in Swift that defines a function parameter as a link.  Typically, parameters are passed to the function as values.  When you write <i><b>inout</b></i> before a function parameter in a call, you define this parameter as a reference type.  To learn more about inout arguments, you can follow this link.  If in brief, <i><b>inout</b></i> allows you to change the value of the variable itself, which was passed to the function, and not just to get its value in the parameter and work with it inside the function.  <i><b>ParameterEncoder</b></i> protocol will be implemented in <i><b>JSONParameterEncoder</b></i> and in <i><b>URLPameterEncoder</b></i> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(urlRequest: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">inout</span></span></span></span><span class="hljs-function"><span class="hljs-params"> URLRequest, with parameters: Parameters)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><br>  <i><b>ParameterEncoder</b></i> contains a single function whose task is to encode parameters.  This method can produce an error that needs to be processed, so we use throw. <br><br>  It may also be useful to produce not standard errors, but customized ones.  It's always pretty hard to decipher what Xcode gives you.  When you have all the errors customized and described, you always know exactly what happened.  To do this, let's define an enumeration that inherits from <i><b>Error</b></i> . <br><br><img src="https://habrastorage.org/webt/tl/bj/dd/tlbjddm7l48ho1alexej8rrj15q.png"><br><br>  Create a file, name it <i><b>URLParameterEncoder</b></i> and place it in the <i><b>Encoding</b></i> folder. <br><br><img src="https://habrastorage.org/webt/s-/eh/tg/s-ehtgdznm1pcdjyrhn3r4fibjs.png"><br><br>  This code takes a list of parameters, converts and formats them for use as URL parameters.  As you know, some characters are not allowed in the URL.  Parameters are also separated by the "&amp;" symbol, therefore we must take care of this.  We also need to set the default value for headers if they are not set in the request. <br><br>  This is the part of the code you intend to cover with unit tests  Building a URL request is key, otherwise we can provoke many unnecessary errors.  If you use an open API, you obviously do not want to use all possible requests for failed tests.  If you have a desire to learn more about Unit tests, you can start with this article. <br><br>  <b>JSONParameterEncoder</b> <br><br>  Create a file, name it <i><b>JSONParameterEncoder</b></i> and place it in the Encoding folder. <br><br><img src="https://habrastorage.org/webt/qf/nc/gp/qfncgpv0juhwx6xnvn4llxqv0eu.png"><br><br>  Everything is the same as in the case of <i><b>URLParameter</b></i> , here we simply convert the parameters for JSON and again add the parameters defining the ‚Äúapplication / json‚Äù encoding into a header. <br><br>  <b>Networkrouter</b> <br><br>  Create a file, name it <i><b>NetworkRouter</b></i> and place it in the Service folder.  We start by defining a typealias for closure. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">NetworkRouterCompletion</span></span> = (<span class="hljs-number"><span class="hljs-number">_</span></span> data: <span class="hljs-type"><span class="hljs-type">Data?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> response: <span class="hljs-type"><span class="hljs-type">URLResponse?</span></span>,<span class="hljs-number"><span class="hljs-number">_</span></span> error: <span class="hljs-type"><span class="hljs-type">Error?</span></span>)-&gt;()</code> </pre><br><br>  Next, we define the <i><b>NetworkRouter</b></i> protocol. <br><br><img src="https://habrastorage.org/webt/uf/zd/s0/ufzds0f3ci0fvx9mr0hingvxjtc.png"><br><br>  <i><b>NetworkRouter</b></i> has <i><b>EndPoint</b></i> , which it uses for requests, and as soon as the request is completed, the result of this request is passed to the <i><b>NetworkRouterCompletion</b></i> closure.  The protocol also has a <i><b>cancel</b></i> function that can be used to interrupt lengthy load and unload requests.  We also used the <i><b>associatedtype</b></i> here because we want our <i><b>Router to</b></i> support any type of <i><b>EndPointType</b></i> .  Without the associatedtype, the router would have to have some specific type implementing <i><b>EndPointType</b></i> .  If you want to learn more about the associatedtype, you can read <a href="https://www.natashatherobot.com/swift-what-are-protocols-with-associated-types/">this article</a> . <br><br>  <b>Router</b> <br><br>  Create a file, name it <i><b>Router</b></i> and place it in the Service folder.  We declare a private variable of type <i><b>URLSessionTask</b></i> .  All the work will be on it.  We make it private, because we don‚Äôt want someone from outside to change it. <br><br><img src="https://habrastorage.org/webt/gb/wk/cx/gbwkcxouam1y86i-sruvzyhub_c.png"><br><br>  <b>Request</b> <br><br>  Here we create <i><b>URLSession</b></i> using <i><b>URLSession.shared</b></i> , this is the easiest way to create.  But remember that this method is not the only one.  You can also use more complex <i><b>URLSession</b></i> configurations that can change its behavior.  More on this in <a href="https://www.raywenderlich.com/567-urlsession-tutorial-getting-started">this article</a> . <br><br>  The request is created by calling the <i>buildRequest</i> function <i>.</i> The function call is wrapped in do-try-catch, because the encoding functions inside <i>buildRequest</i> can throw exceptions.  In completion, the <i>response</i> , <i>data,</i> and <i>error</i> are transmitted. <br><br><img src="https://habrastorage.org/webt/oi/3c/jl/oi3cjllxhvs7n_m39kmy9r7q29k.png"><br><br>  <b>Build request</b> <br><br>  We create our request using the <i>buildRequest</i> function.  This function is responsible for all the vital work in our network layer.  Essentially, converts <i><b>EndPointType</b></i> to <i><b>URLRequest</b></i> .  And as soon as <i><b>EndPoint is</b></i> turned into a request, we can pass it to the <i><b>session</b></i> .  There is a lot going on here, so let's break it down by methods.  First we analyze the <i>buildRequest</i> method: <br><br>  1. We initialize the <i><b>URLRequest</b></i> request variable.  We set our base URL in it and add to it the path of a specific request to be used. <br><br>  2. Assign the <i>request.httpMethod</i> http method from our <i><b>EndPoint</b></i> . <br><br>  3. Create a do-try-catch block, because our encoders may generate an error.  By creating one big do-try-catch block, we eliminate the need to create a separate block for each try. <br><br>  4. In the switch, check <i><b>route.task</b></i> . <br><br>  5. Depending on the type of task, call the appropriate encoder. <br><br><img src="https://habrastorage.org/webt/pt/ij/58/ptij58jibcjvvawtyb44axo5mq4.png"><br><br>  <b>Configure Parameters</b> <br><br>  Create a <i><b>configureParameters</b></i> function in the Router. <br><br><img src="https://habrastorage.org/webt/fb/gf/fy/fbgffycewgssxqrnxglvsvftl0w.png"><br><br>  This function is responsible for converting our request parameters.  Since our API assumes the use of <i><b>bodyParameters</b></i> in the form of JSON and <i><b>URLParameters</b></i> converted to a URL format, we simply pass the corresponding parameters to the appropriate conversion functions that we described at the beginning of the article.  If you are using an API that includes various types of encoding, then in this case I would recommend complementing <i><b>HTTPTask with</b></i> an additional listing with the encoding type.  This listing should contain all possible types of encodings.  After that, add another argument to the configureParameters with this enumeration.  Depending on its value, switch with the help of switch and produce the necessary encoding. <br><br>  <b>Add Additional Headers</b> <br><br>  Create the <i>addAdditionalHeaders</i> function in the Router. <br><br><img src="https://habrastorage.org/webt/ow/07/8a/ow078aeoow6qlavpxiobwl6nbh0.png"><br><br>  Just add all the necessary headers to the request. <br><br>  <b>Cancel</b> <br><br>  The <i>cancel</i> function will look pretty simple: <br><br><img src="https://habrastorage.org/webt/v4/3t/mm/v43tmm1dlso_cwstw6sy444vyu4.png"><br><br>  <b>Usage example</b> <br><br>  Now let's try to use our network layer with a real example.  We connect to <a href="https://developers.themoviedb.org/3/getting-started/introduction">TheMovieDB</a> to get data for our application. <br><br>  <b>MovieEndPoint</b> <br><br>  Create a <i><b>MovieEndPoint</b></i> file and place it in the EndPoint folder.  MovieEndPoint is the same as <br>  and TargetType in Moya.  Here we implement our own EndPointType instead.  An article describing how to use Moya with a similar example can be found at <a href="https://medium.com/flawless-app-stories/getting-started-with-moya-f559c406e990">this link</a> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation enum NetworkEnvironment { case qa case production case staging } public enum MovieApi { case recommended(id:Int) case popular(page:Int) case newMovies(page:Int) case video(id:Int) } extension MovieApi: EndPointType { var environmentBaseURL : String { switch NetworkManager.environment { case .production: return "https:<span class="hljs-comment"><span class="hljs-comment">//api.themoviedb.org/3/movie/" case .qa: return "https://qa.themoviedb.org/3/movie/" case .staging: return "https://staging.themoviedb.org/3/movie/" } } var baseURL: URL { guard let url = URL(string: environmentBaseURL) else { fatalError("baseURL could not be configured.")} return url } var path: String { switch self { case .recommended(let id): return "\(id)/recommendations" case .popular: return "popular" case .newMovies: return "now_playing" case .video(let id): return "\(id)/videos" } } var httpMethod: HTTPMethod { return .get } var task: HTTPTask { switch self { case .newMovies(let page): return .requestParameters(bodyParameters: nil, urlParameters: ["page":page, "api_key":NetworkManager.MovieAPIKey]) default: return .request } } var headers: HTTPHeaders? { return nil } }</span></span></code> </pre><br><br>  <b>MovieModel</b> <br><br>  To parse the <i><b>MovieModel</b></i> data <i><b>model</b></i> and JSON into the model, the Decodable protocol is used.  Place this file in the <i><b>Model</b></i> folder. <br><br>  <i>Note</i> : for a more detailed acquaintance with the Codable, Decodable and Encodable protocols, you can read <a href="https://habr.com/ru/post/414221/">my other article</a> , which describes in detail all the features of working with them. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation struct MovieApiResponse { let page: Int let numberOfResults: Int let numberOfPages: Int let movies: [Movie] } extension MovieApiResponse: Decodable { private enum MovieApiResponseCodingKeys: String, CodingKey { case page case numberOfResults = "total_results" case numberOfPages = "total_pages" case movies = "results" } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: MovieApiResponseCodingKeys.self) page = try container.decode(Int.self, forKey: .page) numberOfResults = try container.decode(Int.self, forKey: .numberOfResults) numberOfPages = try container.decode(Int.self, forKey: .numberOfPages) movies = try container.decode([Movie].self, forKey: .movies) } } struct Movie { let id: Int let posterPath: String let backdrop: String let title: String let releaseDate: String let rating: Double let overview: String } extension Movie: Decodable { enum MovieCodingKeys: String, CodingKey { case id case posterPath = "poster_path" case backdrop = "backdrop_path" case title case releaseDate = "release_date" case rating = "vote_average" case overview } init(from decoder: Decoder) throws { let movieContainer = try decoder.container(keyedBy: MovieCodingKeys.self) id = try movieContainer.decode(Int.self, forKey: .id) posterPath = try movieContainer.decode(String.self, forKey: .posterPath) backdrop = try movieContainer.decode(String.self, forKey: .backdrop) title = try movieContainer.decode(String.self, forKey: .title) releaseDate = try movieContainer.decode(String.self, forKey: .releaseDate) rating = try movieContainer.decode(Double.self, forKey: .rating) overview = try movieContainer.decode(String.self, forKey: .overview) } }</code> </pre><br><br>  <b>Networkmanager</b> <br><br>  Create a <i><b>NetworkManager</b></i> file in the Manager folder.  Currently NetworkManager contains only two static properties: an API key and an enumeration describing the type of server to connect to.  <i><b>NetworkManager</b></i> also contains a <i><b>Router</b></i> , which is of type <i><b>MovieApi</b></i> . <br><br><img src="https://habrastorage.org/webt/yj/it/-b/yjit-b1afnahwsvjkkjnaezgpdu.png"><br><br>  <b>Network response</b> <br><br>  Create a <i><b>NetworkResponse</b></i> enumeration in NetworkManager. <br><br><img src="https://habrastorage.org/webt/vv/fv/7s/vvfv7sl-q-dmnz289jdcntmhs0k.png"><br><br>  We use this enumeration when processing responses to requests and we will display a corresponding message. <br><br>  <b>Result</b> <br><br>  Create a <i><b>Result</b></i> enumeration in NetworkManager. <br><br><img src="https://habrastorage.org/webt/en/oj/ad/enojad3e4jxk2jgkntgblqftivu.png"><br><br>  We use <i><b>Result</b></i> to determine if the request was successful, or not.  If not, we will return an error message with the cause. <br><br>  <b>Processing responses to the request</b> <br><br>  Create the <i><b>handleNetworkResponse</b></i> function.  This function takes one argument, such as <i><b>HTTPResponse,</b></i> and returns Result. <br><br><img src="https://habrastorage.org/webt/wt/uv/5f/wtuv5f7cptiudu69o8mn16psbsy.png"><br><br>  In this function, depending on the statusCode received from HTTPResponse, we return an error message, or a sign of a successful request.  Typically, a code in the range of 200..299 means success. <br><br>  <b>Making a network request</b> <br><br>  So, we did everything to start using our network layer, let's try to make a request. <br><br>  We will request a list of new films.  Create a function and name it <i><b>getNewMovies</b></i> . <br><br><img src="https://habrastorage.org/webt/ei/yn/fn/eiynfnoketqomcziq5nzv6ulaao.png"><br><br>  Let's take everything in steps: <br><br>  1. We define the <i><b>getNewMovies</b></i> method with two arguments: the pagination page number and the completion handler, which returns an optional array of <i><b>Movie</b></i> models, or an optional error. <br><br>  2. Call the <i><b>Router</b></i> .  Pass the page number and process the <i>completion</i> in the closure. <br><br>  3. <i><b>URLSession</b></i> returns an error if there is no network or it was not possible to make a request for any reason.  Please note that this is not an API error, such errors occur on the client and usually occur due to the poor quality of the Internet connection. <br><br>  4. We need to bring our <i><b>response</b></i> to an <i><b>HTTPURLResponse</b></i> , because we need to access the <i>statusCode</i> property. <br><br>  5. Declare <i><b>result</b></i> and initialize it using the <i><b>handleNetworkResponse</b></i> method <br><br>  6. <i><b>Success</b></i> means that the request was successful and we received the expected response.  Then we check to see if the data came with the response, and if not, then just end the method with return. <br><br>  7. If the answer comes with data, then it is necessary to parse the obtained data into the model.  After that we transfer the received array of models to completion. <br><br>  8. In case of an error, just pass the error to <i>completion</i> . <br><br>  Everything, this is how our own network layer works on pure Swift, without using any dependencies in the form of third-party platforms and libraries.  In order to make a test api-request to get a list of movies, create a MainViewController with the <i><b>NetworkManager</b></i> property and call the <i><b>getNewMovies</b></i> method through it. <br><br><pre> <code class="swift hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(networkManager: <span class="hljs-type"><span class="hljs-type">NetworkManager</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkManager = networkManager } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() view.backgroundColor = .green networkManager.getNewMovies(page: <span class="hljs-number"><span class="hljs-number">1</span></span>) { movies, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> movies = movies { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(movies) } } } }</code> </pre> <br><br>  <b>Small bonus</b> <br><br>  Did you have a situation in Xcode when you did not understand what kind of placeholder is being used in a particular place?  For example, take a look at the code that we have just written for <i><b>Router</b></i> . <br><br><img src="https://habrastorage.org/webt/sd/cb/ga/sdcbgacxit9y-j4zk8w32slxqm8.png"><br><br>  We ourselves have defined <i><b>NetworkRouterCompletion</b></i> , but even in this case it is easy to forget what type it is and how to use it.  But our favorite Xcode has taken care of everything, and it is enough just to make a doubleclick on the placeholder and Xcode will substitute the desired type. <br><br><img src="https://habrastorage.org/webt/la/wo/oj/lawoojq5qsvsdzzvfzarqc-wnsk.png"><br><br>  <b>Conclusion</b> <br><br>  Now we have an implementation of a protocol-oriented network layer, which is very easy to use and which can always be customized to fit your needs.  We understood its functionality and how all mechanisms work. <br><br>  Source code can be found in <a href="https://github.com/Mackis/NetworkLayer">this repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/443514/">https://habr.com/ru/post/443514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443502/index.html">Why exactly 4 years ago NASA shot Atlas V rocket at the night sky of Cape Canaveral?</a></li>
<li><a href="../443504/index.html">The World Wide Web has turned thirty years old - what will happen to it next?</a></li>
<li><a href="../443506/index.html">Simple parser for youtube in google tables</a></li>
<li><a href="../443510/index.html">Laptop Compaq Armada 7700 - as the development of the line Compaq LTE</a></li>
<li><a href="../443512/index.html">Hakaton on data analysis in Nizhny Novgorod</a></li>
<li><a href="../443516/index.html">Hacker Geohot decided to free up people from an AI simulation</a></li>
<li><a href="../443518/index.html">RBKmoney Payments under the hood - microservices, protocols and platform configuration</a></li>
<li><a href="../443520/index.html">Choosing a car for an IT person, or tips for teapots from a teapot</a></li>
<li><a href="../443522/index.html">Hosting: options, comparisons, user statistics</a></li>
<li><a href="../443524/index.html">Flash animation in Unity3D do it yourself. Part One, Lyrical</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>