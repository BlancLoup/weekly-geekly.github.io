<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automated Smart Contract Audit Guide. Part 3: Mythril</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warning 


 This article is not an autoanalyzer performance rating. I apply them to my own contracts, intentionally synthesizing errors, and study the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automated Smart Contract Audit Guide. Part 3: Mythril</h1><div class="post__text post__text-html js-mediator-article"><h2 id="warning">  <strong>Warning</strong> </h2><br><p>  This article is not an autoanalyzer performance rating.  I apply them to my own contracts, intentionally synthesizing errors, and study the reactions.  Such a study can not be the basis for determining the "better-worse", for this it makes sense to conduct a blind study on a large sample of contracts, which, given the capricious nature of this kind of software, is extremely difficult to conduct.  It is quite possible that a small mistake in the contract can turn off a large piece of analyzer logic, and the simplest heuristic feature can add a huge amount of points to the analyzer by finding a widespread bug that competitors simply did not have time to add.  Errors in the preparation and compilation of contracts may also play a role.  All the software in question is quite young, and is constantly being developed, so do not take critical comments as irreparable problems. </p><br><p>  The purpose of the article is to give the reader an understanding of how code analysis methods work in different analyzers and the ability to use them correctly, and not ‚Äúmake a choice‚Äù.  A sensible choice is to use several tools at once, with an emphasis on the most suitable for the contract being analyzed. </p><a name="habracut"></a><br><h2 id="nastroyka-i-podgotovka-k-zapusku">  <strong>Setup and preparation for launch</strong> </h2><br><p>  Mythril uses several types of analysis, here are a couple of good articles about him: <a href="https://arxiv.org/pdf/1902.03868.pdf">the main one</a> , <a href="https://hackernoon.com/introducing-mythril-a-framework-for-bug-hunting-on-the-ethereum-blockchain-9dc5588f82f6">this one</a> or <a href="https://hackernoon.com/practical-smart-contract-security-analysis-and-exploitation-part-1-6c2f2320b0c">this one</a> .  Before continuing, it makes sense to read them. </p><br><p>  To begin with, let's build our own Docker image of Mythril (who knows if we want to change it?): </p><br><pre><code class="plaintext hljs">git clone https://github.com/ConsenSys/mythril-classic.git cd mythril-classic docker build -t myth .</code> </pre> <br><p>  Now we will try to run it on our <code>contracts/flattened.sol</code> (I use the same contract that was discussed in the <a href="https://habr.com/ru/post/438336/">introduction</a> ), in which there are two main contracts, <code>Ownable</code> from Zeppelin and our <code>Booking</code> .  We still have a problem with the version of the compiler, I fixed it in the same way as in the previous article, adding in the Dockerfile the lines that will replace the version of the compiler: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.20 /usr/bin/solc /usr/bin</code> </pre> <br><p>  After rebuilding the image, you can try to run the contract analysis.  Immediately let's use the <code>-v4</code> and <code>--verbose-report</code> flags to see all the warnings.  Go: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ -v4 \ --verbose-report \ -x contracts/flattened.sol</code> </pre> <br><p>  Here we work with a flattened contract without dependencies.  To analyze the separate <code>Booking.sol</code> contract and so that Mythril can catch all the dependencies, you can use something like this: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp \ -w /tmp myth:latest \ --solc-args="--allow-paths /tmp/node_modules/zeppelin-solidity/ zeppelin-solidity=/tmp/node_modules/zeppelin-solidity" \ -v4 \ --verbose-report \ -x contracts/Booking.sol</code> </pre> <br><p>  I prefer to work with the flattened version, since  we will modify a lot in the code.  But Mythril also has an extremely convenient <code>--truffle</code> mode, which simply <code>--truffle</code> everything that <code>truffle</code> , testing the entire project for vulnerabilities.  Also an important feature is the ability to specify the name of the contract to be analyzed through the colon, otherwise Mythril will analyze all the contracts that have been encountered.  We believe that <code>Ownable</code> from OpenZeppelin is a secure contract, and we are only going to analyze <code>Booking</code> , so the final line to launch is: </p><br><pre> <code class="plaintext hljs">docker run -v $(pwd):/tmp -w /tmp myth:latest -x contracts/flattened.sol:Booking -v4 --verbose-report</code> </pre> <br><h2 id="zapusk-i-deploy-kontrakta">  <strong>Launch and contract contract</strong> </h2><br><p>  Start the analyzer with the above line, look at the output, and get, among other things, the following line: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout) The analysis was completed successfully. No issues were detected.</code> </pre> <br><p>  It turns out that our contract was not created and "locked" in the emulator.  That is why I recommend using the <code>-v4</code> flag for all types of analysis to see all messages and not to miss any important ones.  Let's figure out what's wrong.  The solution to this practical problem is quite important for understanding how to properly use Mythril. </p><br><p>  So, read about Mythril: <code>It uses concolic analysis, taint analysis and control flow checking to detect a variety of security vulnerabilities</code> .  If you are not very familiar with these terms, I recommend the wiki about concolic testing <a href="https://en.wikipedia.org/wiki/Concolic_testing">here</a> , but <a href="http://web.cs.iastate.edu/~weile/cs513x/2018spring/taintanalysis.pdf">a</a> good presentation about taint checking for x86.  In short: Mythril emulates the execution of a contract, fixes the branches along which execution can go and tries to reach the ‚Äúbroken‚Äù state of the contract, sorting through various combinations of parameters and trying to get around all possible paths.  Here is an approximate scheme of actions from the article above: </p><br><pre> <code class="plaintext hljs">1.      .   symbolic-,        . 2.      ,     ,   trace .    ,      ,    . 3.     . 4.       trace-. 5.  symbolic execution   trace,   symbolic ,    ,     ,     . 6.     ,          .    , . 7.   :   ,   ,   input-,     ,      .   input-   ,   .6    . 8.   .4</code> </pre> <br><p>  If to simplify greatly, then Mythril, having met a branch in the code, can understand at what sets of variables one can get into one and another branch.  In each branch, Mythril knows if it leads to <code>assert</code> , <code>transfer</code> , <code>selfdestruct</code> and other security-relevant opcodes.  Therefore, Mythril analyzes which parameter sets and transactions can result in a security violation.  And the way that Mythril cuts off branches that never get control and analyzes the control flow is its main feature.  For more information about the guts Mythril and walking on the branches are written <a href="https://github.com/b-mueller/smashing-smart-contracts/blob/master/smashing-smart-contracts-1of1.pdf">here</a> . </p><br><p>  Due to the determinism of the execution of smart contracts, the same sequence of instructions always leads strictly to one set of changes in the state, regardless of platform, architecture and environment.  Also, functions in smart contracts are rather short, and resources are extremely limited, so analyzers such as Mythril, combining symbolic and native execution, for smart contracts can work extremely efficiently. </p><br><p>  In the process of work, Mythril operates with the concept of "state" - this is the contract code, its environment, a pointer to the current command, the storage contract and the stack status.  Here is the documentation: </p><br><pre> <code class="plaintext hljs">The machine state Œº is defined as the tuple (g, pc, m, i, s) which are the gas available, the program counter pc ‚àà P256, the memory contents, the active number of words in memory (counting continuously from position 0), and the stack contents. The memory contents Œºm are a series of zeroes of size 256.</code> </pre> <br><p>  The transition graph between states is the main object of study.  In case of successful launch of the analysis, information about this column is displayed in the analysis log.  Also, Mythril can build this graph in a readable form using the <code>--graph</code> option. </p><br><p>  Now, more or less understanding what Mythril will do, we will continue to understand why the contract is not being analyzed and where did <code>[WARNING]: No contract was created during the execution of contract creation</code> come from <code>[WARNING]: No contract was created during the execution of contract creation</code> .  For a start, I twisted the <code>--create-timeout</code> and - <code>--max-depth</code> parameter (as recommended) and, without getting a result, I thought the designer was to blame - something in it does not work.  Here is his code: </p><br><pre> <code class="plaintext hljs">function Booking( string _description, string _fileUrl, bytes32 _fileHash, uint256 _price, uint256 _cancellationFee, uint256 _rentDateStart, uint256 _rentDateEnd, uint256 _noCancelPeriod, uint256 _acceptObjectPeriod ) public payable { require(_price &gt; 0); require(_price &gt; _cancellationFee); require(_rentDateStart &gt; getCurrentTime()); require(_rentDateEnd &gt; _rentDateStart); require(_rentDateStart+_acceptObjectPeriod &lt; _rentDateEnd); require(_rentDateStart &gt; _noCancelPeriod); m_description = _description; m_fileUrl = _fileUrl; m_fileHash = _fileHash; m_price = _price; m_cancellationFee = _cancellationFee; m_rentDateStart = _rentDateStart; m_rentDateEnd = _rentDateEnd; m_noCancelPeriod = _noCancelPeriod; m_acceptObjectPeriod = _acceptObjectPeriod; }</code> </pre> <br><p>  Recall the algorithm of action Mythril.  To start trace, you need to call the contract constructor, because all subsequent execution will depend on the parameters with which the constructor was called.  For example, if you call a constructor with <code>_price == 0</code> , the constructor <code>require(_price &gt; 0)</code> exception for <code>require(_price &gt; 0)</code> .  Even if Mythril enumerates the set of <code>_price</code> values, the constructor will still break if, for example, <code>_price &lt;= _cancellationFee</code> .  In this contract, with a dozen parameters associated with strict restrictions, and Mythril, of course, cannot guess the valid combinations of parameters.  He tries to go to the next branch of execution, going through the parameters of the constructor, but he has practically no chance to guess - there are too many combinations of parameters.  Therefore, the calculation of the contract does not work out - all the ways run into some kind of <code>require(...)</code> , and we get the above problem. </p><br><p>  Now we have two ways: the first is to disable all <code>require</code> in the constructor by commenting them out.  Then Mythril will be able to call the designer with any set of parameters and everything will work.  But this means that by examining a contract with such parameters, Mythril will find errors that are possible with incorrect values ‚Äã‚Äãpassed to the constructor.  Simply put, if Mythril finds a bug that arises, if the contract creator specifies <code>_cancellationFee</code> a billion times more than the rent price of <code>_mprice</code> , then there is no sense in such a bug - such a contract will never be secured, and resources for finding errors will be spent.  We mean that the contract is still secure with more or less holistic parameters, so for further analysis it makes sense to specify more realistic designer parameters so that Mythril does not look for errors that never occur if the contract is properly secured. </p><br><p>  I spent many hours trying to understand exactly where the site was breaking, turning on and off various parts of the constructor.  In addition to my troubles, the constructor uses <code>getCurrentTime()</code> , which returns the current time, and it is unclear how this call handles Mythril.  I will not describe these adventures here, because  most likely, with regular use, these details will become known to the auditor.  Therefore, I chose the second way: limit the input data, and simply removed all parameters from the constructor, even <code>getCurrentTime()</code> , simply loading the necessary parameters directly in the constructor (ideally, you should get these parameters from the customer): </p><br><pre> <code class="plaintext hljs"> function Booking( ) public payable { m_description = "My very long booking text about hotel and beautiful sea view!"; m_fileUrl = "https://ether-airbnb.bam/some-url/"; m_fileHash = 0x1628f3170cc16d40aad2e8fa1ab084f542fcb12e75ce1add62891dd75ba1ffd7; m_price = 1000000000000000000; // 1 ETH m_cancellationFee = 100000000000000000; // 0.1 ETH m_rentDateStart = 1550664800 + 3600 * 24; // current time + 1 day m_rentDateEnd = 1550664800 + 3600 * 24 * 4; // current time + 4 days m_acceptObjectPeriod = 3600 * 8; // 8 hours m_noCancelPeriod = 3600 * 24; // 1 day require(m_price &gt; 0); require(m_price &gt; m_cancellationFee); require(m_rentDateStart &gt; 1550664800); require(m_rentDateEnd &gt; m_rentDateStart); require((m_rentDateStart + m_acceptObjectPeriod) &lt; m_rentDateEnd); require(m_rentDateStart &gt; m_noCancelPeriod); }</code> </pre> <br><p>  Plus, in order for everything to start, you must also set the <code>max-depth</code> parameter.  It worked for me with this constructor with <code>--max-depth=34</code> on the AWS instance t2.medium.  At the same time, on my laptop, which is more powerful, everything runs without any <code>max-depth</code> .  Judging by the use of this <a href="https://github.com/ConsenSys/mythril-classic/blob/5e0bcd3f9fd98241475c6abaa1d4c2c0115954fa/mythril/laser/ethereum/strategy/__init__.py">parameter</a> , it is necessary to build branches for analysis, and its default value is infinity ( <a href="https://github.com/ConsenSys/mythril-classic/blob/3093ed54b4f7c98187449adc3075b1f08bb723f0/mythril/laser/ethereum/svm.py">code</a> ).  So twist-and-turn this parameter, but make sure that the contract you need is analyzed.  You can understand this by the message type: </p><br><pre> <code class="plaintext hljs">mythril.laser.ethereum.svm [INFO]: 248 nodes, 247 edges, 2510 total states mythril.laser.ethereum.svm [INFO]: Achieved 59.86% coverage for code: .............</code> </pre> <br><p>  The first line describes the graph that will be analyzed, read the other lines for yourself.  To analyze the various branches that can be executed, serious computational resources are required, therefore, when analyzing large contracts, you will have to wait even on a fast computer. </p><br><h2 id="poisk-oshibok">  <strong>Search for errors</strong> </h2><br><p>  Now we will look for errors and add our own.  Mythril is looking for branches that are sending ether, selfdestruct, assert, and other actions that are important from a security point of view.  If somewhere in the contract code there is one of the above instructions, Mythril studies the ways in which you can come to this branch and, moreover, output a sequence of transactions leading to this branch! </p><br><p>  First, let's see what Mythril issued for the long-suffering <code>Booking</code> contract.  First warning: </p><br><pre> <code class="plaintext hljs">==== Dependence on predictable environment variable ==== SWC ID: 116 Severity: Low Contract: Booking Function name: fallback PC address: 566 Estimated Gas Usage: 17908 - 61696 Sending of Ether depends on a predictable variable. The contract sends Ether depending on the values of the following variables: - block.timestamp Note that the values of variables like coinbase, gaslimit, block number and timestamp are predictable and/or can be manipulated by a malicious miner. Don't use them for random number generation or to make critical decisions. -------------------- In file: contracts/flattened.sol:142 msg.sender.transfer(msg.value-m_price)</code> </pre> <br><p>  and it arises because of </p><br><pre> <code class="plaintext hljs">require(m_rentDateStart &gt; getCurrentTime());</code> </pre> <br><p>  in the fallback function. </p><br><p>  Please note that Mythril realized that <code>getCurrentTime()</code> hiding in <code>getCurrentTime()</code> .  Despite the fact that, according to the meaning of the contract, this is not a mistake, the fact that Mythril connects the <code>block.timestamp</code> with the broadcast output - this is excellent!  In this case, the programmer must understand that the decision is made based on the value that the miner can control.  And, if in the future in this place of the contract an auction or another bargain for the service occurs, you need to consider the possibility of front-running attacks. </p><br><p>  See if Mythril sees a dependency on the <code>block.timestamp</code> if we hide the variable in a nested call, like this: </p><br><pre> <code class="plaintext hljs">function getCurrentTime() public view returns (uint256) { - return now; + return getCurrentTimeInner(); } + function getCurrentTimeInner() internal returns (uint256) { + return now; + }</code> </pre> <br><p>  And yes!  Mythril continues to see the connection between the block.timestamp and the transfer of the ether, this is extremely important for the auditor.  The relationship between the variable controlled by the attacker and the decision-making after several changes to the contract state can be very masked by logic, and Mythril allows you to track it.  Although you shouldn‚Äôt rely on all possible connections between all possible variables to be <code>getCurrentTime()</code> for you: if you continue to scoff at the <code>getCurrentTime()</code> function and make a triple depth of nesting, the warning will disappear.  Each function call for Mythril requires the creation of new branches of state, so analyzing very deep levels of nesting will require huge resources. </p><br><p>  Of course, there is a rather serious possibility that I simply use the analysis parameters incorrectly or the cutoff occurs somewhere in the depths of the analyzer.  As I said, the product is in active development, I see commits with <code>max-depth</code> right at the moment of writing this article, so do not take the current problems seriously, we have already found enough evidence that Mythril can very effectively look for implicit connections between variables. </p><br><p>  First, we add to the contract a function that broadcasts to anyone, but only after the client has sent the broadcast to the contract.  We allowed anyone to pick up 1/5 of the air, but only when the contract is in the <code>State.PAID</code> state (i.e., only after the client has paid for the number on the air).  Here is the function: </p><br><pre> <code class="plaintext hljs">function collectTaxes() external onlyState(State.PAID) { msg.sender.transfer(address(this).balance / 5); }</code> </pre> <br><p>  Mythril found a problem: </p><br><pre> <code class="plaintext hljs">==== Unprotected Ether Withdrawal ==== SWC ID: 105 Severity: High Contract: Booking Function name: collectTaxes() PC address: 2492 Estimated Gas Usage: 2135 - 2746 Anyone can withdraw ETH from the contract account. Arbitrary senders other than the contract creator can withdraw ETH from the contract account without previously having sent a equivalent amount of ETH to it. This is likely to be a vulnerability. -------------------- In file: contracts/flattened.sol:149 msg.sender.transfer(address(this).balance / 5) -------------------- -------------------- Transaction Sequence: { "2": { "calldata": "0x", "call_value": "0xde0b6b3a7640000", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" }, "3": { "calldata": "0x01b613a5", "call_value": "0x0", "caller": "0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef" } }</code> </pre> <br><p>  Great, i.e.  Mythril even brought out two transactions, which lead to the fact that you can take air from the contract.  And now we change the <code>State.PAID</code> requirement to <code>State.RENT</code> , like this: </p><br><pre> <code class="plaintext hljs">- function collectTaxes() external onlyState(State.PAID){ + function collectTaxes() external onlyState(State.RENT) {</code> </pre> <br><p>  Now <code>collectTaxes()</code> can be called only when the contract is in the <code>State.RENT</code> state, and at that moment there is nothing on the balance sheet, since  The contract has already sent the entire ether to the owner.  And the important thing here is that Mythril this time <strong>does NOT</strong> display the error <code>==== Unprotected Ether Withdrawal ====</code> Withal = <code>==== Unprotected Ether Withdrawal ====</code> !  Under the condition of <code>onlyState(State.RENT)</code> , the analyzer did not get to the branch of the code that sends the air from the contract with a non-zero balance.  Mythril went through different options of parameters, but you can get to <code>State.RENT</code> only by sending the entire broadcast to the lessor.  Therefore, to reach this branch of the code, having a non-zero balance, is impossible, and Mythril does not properly disturb the auditor! </p><br><p>  Similarly, Mythril will find <code>selfdestruct</code> and <code>assert</code> , showing the auditor what actions could lead to the destruction of a contract or a breakdown in an important function.  I will not give these examples, just try to make a function similar to the one above, only causing <code>selfdestruct</code> , and twist its logic. </p><br><p>  Also, do not forget that one of the parts of Mythril is the symbolic execution, and this approach, by itself, without emulating the execution, can define many vulnerabilities.  For example, it is possible to consider the ‚ÄúInteger overflow‚Äù vulnerability any use of ‚Äú+‚Äù, ‚Äú-‚Äù and other arithmetic operators, if one of the operands is somehow controlled by the attacker.  But I repeat once again, the most powerful feature of Mythril is the connection of symbolic and native execution and the determination of the values ‚Äã‚Äãof parameters leading to the branching of logic. </p><br><h2 id="zaklyuchenie">  <strong>Conclusion</strong> </h2><br><p>  Of course, to show the full range of potential problems that Mythril is capable of detecting will require not one, but several articles.  On top of that, he can do it all in a real blockchain, find the necessary contracts and vulnerabilities by signature, build beautiful call graphs, format reports.  Also, Mythril allows you to write your own test scripts, providing the python-based interface to the contract and allowing you to test individual functions with an arbitrary degree of flexibility, fix the parameter values, or even implement your own strategy for working with disassembled code. </p><br><p>  Mythril is still quite young software, this is not IDA Pro, and documentation, except for a few articles, is extremely small.  The value of many parameters can only be read in the Mythril code, starting with <a href="https://github.com/ConsenSys/mythril-classic/blob/develop/mythril/interfaces/cli.py">cli.py.</a>  I hope that a full and deep description of the work of each parameter will appear in the documentation. </p><br><p>  In addition, when the contract is more or less large, the output of the heap of errors takes up a lot of space, but I would like to be able to receive and compressed information about the error found, because  when working with Mythril, it is imperative to look at the analysis path, see which contracts were tested as far as possible and be able to forcibly disable specific errors that the auditor regards as false-positive. </p><br><p>  But in general, Mythril is an excellent and extremely powerful tool for analyzing smart contracts and at the moment should be in the arsenal of any auditor.  It allows at least to pay attention to the critical parts of the code and detect hidden connections between variables. </p><br><p>  In summary, the recommendations for using Mythril are: </p><br><ol><li>  Minimize the initial conditions of the contract under investigation.  If, when analyzing, Mythril spends a lot of resources on branches that will never be put into practice, he will lose the ability to find really important bugs, so you should always try to narrow down the scope of potential branches. </li><li>  Pay <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> whether the analysis of the contract has been launched, do not miss messages like <code>mythril.laser.ethereum.svm [WARNING]: No contract was created during the execution of contract creation Increase the resources for creation execution (--max-depth or --create-timeout)</code> , otherwise you may mistakenly think that there are no bugs. </li><li>  You can arbitrarily disable branches in the contract code, giving Mythril less variability in the choice of branches and saving resources.  Try to do without <code>max-depth</code> restrictions so as not to chop off the analysis, but be careful not to disguise the error. </li><li>  Be attentive to every warning, even light notes are sometimes worth it to at least add a comment to the contract code, making it easier for other developers. </li></ol><br><p>  In the next article we will deal with the Manticore analyzer, but the whole table of contents of articles that are ready or planned for writing: </p><br><p>  Part 1. <a href="https://habr.com/ru/post/438336/">Introduction.</a>  <a href="https://habr.com/ru/post/438336/">Compilation, flattening, Solidity versions</a> <br>  Part 2. <a href="https://habr.com/ru/post/438338/">Slither</a> <br>  3. Mythril ( ) <br>  4. Manticore (  ) <br>  5. Echidna (  ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/442114/">https://habr.com/ru/post/442114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442102/index.html">On the issue of batteries</a></li>
<li><a href="../442104/index.html">Kibana User Guide. Visualization. Part 5</a></li>
<li><a href="../442108/index.html">Guide for developers to create AI applications</a></li>
<li><a href="../442110/index.html">Vim antipatterns</a></li>
<li><a href="../442112/index.html">New programming languages ‚Äã‚Äãquietly kill our connection to reality</a></li>
<li><a href="../442116/index.html">Increase performance in React feature components with React.memo ()</a></li>
<li><a href="../442118/index.html">Coinhive mining pool stops working</a></li>
<li><a href="../442120/index.html">Training TensorFlow models with Azure Machine Learning Service</a></li>
<li><a href="../442122/index.html">Simple Muscovite Levelord: an interview with the creator of Duke Nukem</a></li>
<li><a href="../442124/index.html">Facebook will give users the opportunity to clean their history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>