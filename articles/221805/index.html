<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast web application - network trepanation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Psychology is an interesting and sometimes useful science. Numerous studies show that the delay in displaying a web page for more than 300 ms causes t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast web application - network trepanation</h1><div class="post__text post__text-html js-mediator-article">  Psychology is an interesting and sometimes useful science.  Numerous <a href="http://chimera.labs.oreilly.com/books/1230000000545/ch01.html">studies</a> show that the delay in displaying a web page for more than 300 ms causes the user to distract from the web resource and think: ‚Äúwhat the hell is this?‚Äù.  Therefore, ACCELERATING a web project to psychologically imperceptible values ‚Äã‚Äãcan JUST hold users longer.  And that is why the business is ready to spend money on speed: $ 80M - to reduce lateny by only <a href="http://chimera.labs.oreilly.com/books/1230000000545/ch01.html">1 ms</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a4/201/ace/1a4201ace3b7719f5ee25f97cfe24fb4.jpg"><br><br>  However, in order to speed up a modern web project, you will have to start korushki and thoroughly delve into this topic - therefore, a basic knowledge of network protocols is welcome.  Knowing the principles, you can effortlessly speed up your web system by hundreds of milliseconds in just a few approaches.  Well, ready to save hundreds of millions?  Pour coffee. <br><a name="habracut"></a><br><h4>  Aftertaste </h4><br>  This is a very hot topic - how to satisfy the site user - and usabilityists will most likely make me drink a Molotov cocktail, have a snack with a grenade without checks and have time to shout out before the explosion: ‚ÄúI carry heresy‚Äù.  Therefore, I want to go on the other side.  It is widely known that the delay in displaying a page is more than 0.3 seconds - it makes the user notice this and ... wake up from the process of communication with the site.  And the delay in the display is more than a second - to think about the topic: ‚Äúwhat am I doing here at all?  What are they torturing me for and forcing me to wait? ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, we will give the yuzabelists their ‚Äúusability‚Äù, while we ourselves will tackle a practical task - how not to disturb the ‚Äúdream‚Äù of the client and facilitate his work with the site as long as possible, without distractions to the ‚Äúbrake‚Äù. <br><br><h4>  Who is responsible for speed </h4><br>  Well, of course you are.  Otherwise, you would hardly have started reading the post.  If it is serious, then there is a problem - for the issue of speed is divided into 2 weakly connected both technologically and socially parts: the frontend and the backend.  And they often forget about the third key component - the network. <br><br><h4>  Just html </h4><br>  To begin with, we recall that the <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%2581%25D0%25B5%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D1%2583%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0">first sites</a> in the early nineties were ... a set of static pages.  And HTML was simple, clear and concise: first text, then text and resources.  Bacchanalia began with the dynamic generation of web pages and the proliferation of java, perl and at the present time - this is already a galaxy of technologies, including php. <br>  In order to reduce the impact of this race on the viability of the network, HTTP / 1.0 is taken in after 1996, and HTTP / 1.1 in 1999 after 3 years. Finally, they finally agreed that you don‚Äôt need to drive TCP handshakes from ~ 2/3 light speeds ( fiber) there-vessels for each request, establishing a new connection, and it is more correct to open a TCP connection once and work through it. <br><br><h4>  Backend </h4><br><h5>  application </h5><br>  Here, little has changed in the last 40 years.  Well, maybe a ‚Äúparody‚Äù on the relational theory was added under the name <a href="http://ru.wikipedia.org/wiki/NoSQL">NoSQL</a> - which gives both advantages and disadvantages.  Although, as practice shows, there seems to be <a href="http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html">more</a> business benefit from it (but also sleepless nights searching for the answer to the question: "who deprived the integrity data and under what pretext" - rather became more). <br><ol><li>  Application and / or web server (php, java, perl, python, ruby, etc.) - accepts client request </li><li>  The application accesses the database and receives data. </li><li>  The application generates html </li><li>  Application and / or web server - sends data to the client </li></ol><br>  Everything is clear in terms of speed: <br><ul><li>  optimal application code, no loops for seconds </li><li>  optimal data in the database, indexing, denormalization </li><li>  database caching </li></ul><br><br>  We will no longer talk about overclocking the ‚Äúapplication‚Äù - many books and articles have been written about it and everything is rather linear and simple. <br>  The main thing is that the application is transparent and you can measure the speed of the request through various components of the application.  If it is not - then you can not read, it will not help. <br>  How to achieve this?  Paths are known: <br><ul><li>  Standard query logging (nginx, apache, php-fpm) </li><li>  Logging slow database queries (option in mysql) </li><li>  Tools fixing bottlenecks when passing a query.  For php, this is xhprof, pinba. </li><li>  Built-in tools within the web application, for example, a separate <a href="http://www.1c-bitrix.ru/products/cms/features/perfmon.php">trace module</a> . </li></ul><br>  If you have a lot of logs and you get confused in them - aggregate the data, see percentiles and distribution.  Simple and straightforward.  Found a request for more than 0.3 seconds - start debriefing and so on until the bitter end. <br><br><h5>  Web server </h5><br>  Moving out.  Web server.  Here, too, little has changed much, but it can only be a crutches - through the installation of a reverse proxy web server in front of the web server (fascgi server).  Yes, it certainly helps: <br><ol><li>  to keep significantly more open client connections (due to? .. yes, another caching proxy architecture - for nginx this is the use of <a href="http://linux.die.net/man/2/select">multiplexing</a> sockets with a small number of processes and low memory for one connection) </li><li>  more efficiently allocate static resources directly from disk without filtering through application code </li></ol><br>  But the question remains - why didn‚Äôt immediately begin to do <a href="http://www.apache.org/">apache</a> ‚Äúcorrectly‚Äù and sometimes you have to install web servers with a train. <br><br><h6>  Permanent connections </h6><br>  Establishing a TCP connection takes 1 RTT.  Print the chart and hang it in front of you.  The key to understanding the appearance of brakes is here. <br><img src="https://habrastorage.org/getpro/habr/post_images/68a/a96/246/68aa962468e3205a68da9165eaa35230.png"><br>  This value correlates fairly closely with the location of your user relative to the web server (yes, there is the speed of light, there is the speed of light propagation in the material, there is routing) and it can take (especially considering the last mile provider) - tens and hundreds of milliseconds, which of course is a lot .  And the trouble is, if this connection is established for each request, which was distributed in HTTP / 1.0. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/d7c/826/906d7c826496fc14e893578873abe169.gif"><br><br>  For this, by and large, HTTP 1.1 was started and <a href="http://en.wikipedia.org/wiki/HTTP_2.0">HTTP 2.0</a> (in the person of <a href="http://ru.wikipedia.org/wiki/SPDY">spdy</a> ) is being developed in this direction.  IETF with Google is currently trying to do everything to squeeze the most out of the current network architecture - without breaking it.  And this can be done ... well, yes, as efficiently as possible using TCP connections, using their bandwidth as closely as possible through <a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">multiplexing</a> , recovery from packet loss, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca8/351/940/ca8351940ddd16748842b10e39df8fc3.png"><br><br>  Therefore, be sure to check the use of persistent connections on the web servers and in the application. <br><br><h6>  Tls </h6><br>  Without <a href="http://ru.wikipedia.org/wiki/TLS">TLS</a> , which originally originated in the depths of Netscape Communications as SSL, there is nowhere in the modern world.  And although, they say, the <a href="http://ru.wikipedia.org/wiki/Heartbleed">Last</a> ‚Äúhole‚Äù in this protocol made many people turn gray much earlier than the term - there is practically no alternative. <br>  But for some reason, not everyone remembers that TLS worsens the ‚Äúaftertaste‚Äù - adding 1-2 RTTs in addition to 1 RTT connection via TCP.  In nginx, in general, the default TLS session cache is <a href="http_ssl_module.html">off</a> - which adds an extra RTT. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d63/b53/22c/d63b5322cbd008879fb2b790c8dbd664.png"><br><br>  Therefore, make sure that the TLS sessions are cached on a mandatory basis - and so we will save another 1 RTT (and one RTT still remains, unfortunately, as a security fee). <br><br>  About the backend, probably all.  It will be more difficult, but more interesting. <br><br><h4>  Network.  Network distance and bandwidth </h4><br>  You can often hear - we have 50 Mbit / s, 100 Mbit / s, 4G will give even more ... But you can rarely see the understanding that bandwidth is not particularly important for a typical web application (unless you download files) - more important is lantency, t. to.  many small requests are made for different connections and the TCP window just does not have time to swing. <br>  And of course, the farther the client is from the web server, the longer.  But it happens that it is impossible otherwise or difficult.  That is why they came up with: <br><ol><li>  <a href="http://ru.wikipedia.org/wiki/Content_Delivery_Network">CDN</a> </li><li>  Dynamic proxying (CDN-vice versa).  When in the region put for example nginx, opening constant connections to the web server and terminating ssl.  It is clear why?  That is - the establishment of connections from the client to the web proxy is accelerated many times (handshakes begin to fly), and then a heated TCP connection is used. </li></ol><br>  What else can you do ... <a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/">increase</a> TCP's initial congestion window - yes, it often helps, because  A webpage is given in one set of packages without confirmation.  Try it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/017/d92/a3d/017d92a3dc39dcd49207c6fef3979b07.png"><br><br>  Turn on the browser debugger, look at the loading time of the web page and think about latency and how to reduce it. <br><br><h5>  Bandwidth </h5><br>  Remember that the TCP connection window must be accelerated first.  If the web page loads less than a second - the window may not have time to increase.  The average network bandwidth in the world is slightly higher than 3 Mbps.  Conclusion - transfer through one established connection as much as possible, "warming up" it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f39/614/a26/f39614a2693ae94f306e4819c0c30516.png"><br><br>  Here, of course, multiplexing of HTTP resources within a single TCP connection can help: the transfer of several resources alternately in both the request and the response.  And even this technique was included in the standard, but they were under-written and, as a result, it did not take <a href="https://tools.ietf.org/html/rfc2616">off</a> (it was removed in the chrome not so long ago).  Therefore, you can still try spdy, wait for HTTP 2.0, or use pipelining - but not from the browser, but from the application directly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad4/a89/36b/ad4a8936b641c510049aa94300bb9591.png"><br><br><h5>  Domain sharding </h5><br>  But what about the very popular domain sharding technique - when the browser / application overcomes the limit of&gt; = 6 connections per domain, opening more&gt;&gt; = 6 or more connections to fictitious domains: img1.mysite.ru, img2.mysite.ru ...?  It's fun, because  from the point of view of HTTP / 1.1, this will most likely speed you up, but from the point of view of HTTP / 2.0 it is an anti-pattern, since  Multiplexing HTTP traffic over a TCP connection can provide better bandwidth. <br>  So for now - shardim domains and waiting for HTTP / 2.0 to not do this anymore.  And of course - it is better to measure specifically for your web application and make an informed choice. <br><br><h4>  Frontend </h4><br>  About known things like rendering speed of a web page and the size of images and JavaScript, the order of loading resources, etc.  - writing is not interesting.  Subject beaten and killed.  If brief and inaccurate - cache the resources on the side of the web browser, but ... with your head.  Caching 10MB js-file and parsing it inside the browser on each web page - we understand where it will lead.  We turn on the browser debugger, pour coffee and by the end of the day - there are trends.  Throw a plan and implement.  Simple and transparent. <br>  Much sharper pitfalls can be hidden behind the fairly new and rapidly developing network capabilities of a web browser.  Let's talk about them: <br><ol><li>  <a href="http://www.w3.org/TR/XMLHttpRequest/">XMLHttpRequest</a> </li><li>  Long polling </li><li>  <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a> </li><li>  <a href="http://www.w3.org/TR/websockets/">Web sockets</a> </li></ol><br><br><h5>  Browser - as an operating system </h5><br>  Initially, the browser was perceived as a client application for displaying HTML markup.  But every year it was transformed into a control center of a galaxy of technologies - as a result, the HTTP server and the web application behind it are now perceived only as an auxiliary component inside the browser.  An interesting technological shift in emphasis. <br>  Moreover, with the advent of <a href="http://www.w3.org/TR/webrtc/">WebRTC, a</a> television studio built into the browser, and browser networking tools with the outside world, the issue of performance has smoothly shifted from the server infrastructure to the browser.  If this internal kitchen at the client will slow down - no one will remember the php on the web server or join the database. <br><br>  Let's disassemble this opaque monolith for parts. <br><br><h5>  XMLHttpRequest </h5><br>  This is the well-known AJAX - the browser's ability to access external resources via HTTP.  With the advent of <a href="http://www.w3.org/TR/cors/">CORS</a> - the perfect "chaos" began.  Now, to determine the cause of braking, you need to climb all the resources and watch logs everywhere. <br>  Seriously, the technology undoubtedly exploded the capabilities of the browser, turning it into a powerful platform for dynamic information rendering.  It makes no sense to write about it, the topic is known to many.  However, I will describe the limitations: <br><ol><li>  again, the lack of multiplexing of several ‚Äúchannels‚Äù makes it inefficient and not fully utilize the bandwidth of a TCP connection </li><li>  There is no adequate support for streaming (opened the connection and hang, wait), i.e.  it remains to pull the server and watch what he replied </li></ol><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eac/d35/8a9/eacd358a9a363b4fb323138d3b50af76.png"><br><br>  Nevertheless, the technology is very popular and it is easy to make it transparent in terms of monitoring speed. <br><br><h5>  Long polling </h5><br>  How to make a web chat?  Yes, you need to somehow transfer from the server to the browser information about the changes.  Directly via HTTP - can not, can not.  Only: request and reply.  It‚Äôs people who decided: make a request and wait for an answer, second, 30 seconds, a minute.  If something has come, give back and break the connection. <br><img src="https://habrastorage.org/getpro/habr/post_images/2c1/343/1e8/2c13431e85d74c6680466f8dda0f57e8.jpg"><br>  Yes, a lot of antipatterns, crutches - but the technology is very widespread and always works.  But, since  You are responsible for the speed - know, the load on the servers with this approach is very high, and can be compared with the load from the main attendance of the web project.  And if updates from the server to browsers are often distributed, then it can exceed the main load by several times! <br>  What to do? <br><br><h5>  Server-Sent Events </h5><br>  This opens a TCP connection to the web server, does not close, and the server writes different info to UTF-8 to it.  True binary data cannot be transmitted optimally without Base64 (+ 33% increase in size), but as a control channel in one direction is an excellent solution.  True in IE - not supported (see the paragraph above, which works everywhere). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d62/9a9/2c6/d629a92c6c96509921f354f8c99afb72.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/71f/c29/684/71fc29684f37d677bb51d21c6f81829d.png"><br><br>  The advantages of technology are that it: <br><ol><li>  very simple </li><li>  no need to reopen the connection to the server after receiving the message </li></ol><br><br><h5>  Web sockets </h5><br>  For the system administrator, this is not even a beast, but rather a night <a href="http://ru.deadspace.wikia.com/wiki/%25D0%259D%25D0%25B5%25D0%25BA%25D1%2580%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2580%25D1%2584_%25D1%258E%25D0%25BD%25D0%25B8%25D1%2582%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3">necromorph</a> .  In a ‚Äúsmart‚Äù way through HTTP 1.1 Upgrade, the browser changes the ‚Äútype‚Äù of the HTTP connection and it remains open. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b0/a95/565/2b0a95565abe36fc5958d6e13c288e8f.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/b70/f62/a94/b70f62a94dc5f8d044da48d237a15759.png"><br><br>  Then on the connection in the BOTH (!) Side, you can begin to transfer data, decorated in messages (frames).  Messages are not only with information, but also checklists, incl.  such as "PING", "PONG".  The first impression was that they invented the bicycle again, again TCP based on TCP. <br>  From the point of view of the developer, of course this is convenient; a duplex channel appears between the browser and the web application on the server.  You want streaming, you want messages.  But: <br><ol><li>  html caching is not supported, since  working through binary framing protocol </li><li>  compression is not supported, you need to implement it yourself </li><li>  Eerie glitches and delays when working without TLS - due to outdated proxy servers </li><li>  no multiplexing, as a result of which each bandwidth of each connection is used inefficiently </li><li>  On the server, there are many hanging and doing something "nasty with the database" direct TCP-connections from browsers </li></ol><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/3ad/7b8/c883ad7b86526365fed1b1a1e318b4f1.png"><br><br>  How to track Web Sockets performance?  Very good question left especially for a snack.  On the client side, the WireShark packet sniffer, on the server side and with TLS enabled, we solve the problem by patching the modules for nginx, but apparently there is a simpler solution. <br><br>  The main thing is to understand how Web Sockets are built from the inside, and you already know this and control over speed will be provided. <br>  So what is better: XMLHttpRequest, Long Polling, Server-Sent Events or Web Sockets?  Success - in a competent combination of these technologies.  For example, you can manage an application through WebSockets, and load resources using in-built caching via AJAX. <br><br><h4>  What now? </h4><br>  Learn to measure and respond to set points overshoot.  Process web application logs, deal with slow queries in them.  The speed on the client side was also possible to measure thanks to the <a href="http://www.w3.org/TR/navigation-timing-2/">Navigation timing API</a> - we collect performance data in browsers, send them using JavaScript to the cloud, aggregate to pinba and react to deviations.  Very useful API, use necessarily. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4d/e01/a99/f4de01a99db103b2e5d6dfa107e26c84.png"><br><br>  As a result, you will find yourself surrounded by a monitoring system like <a href="http://www.nagios.org/">nagios</a> , with a dozen or so automatic tests, which show that your web system‚Äôs speed is fine.  And in the case of triggers - the team is going and a decision is made.  Cases can be, for example, such: <br><ul><li>  Slow database query.  Solution - query optimization, denormalization in case of emergency. </li><li>  Slow processing of the application code.  Solution - algorithm optimization, caching. </li><li>  Slow transfer of the page body over the network.  Solution (in order of increasing cost) - increase the tcp initial cwnd, set the dynamic proxy next to the client, transfer servers closer </li><li>  Slow return of static resources to customers.  The solution is CDN. </li><li>  Blocking pending connection to servers in the browser.  The solution is domain sharding. </li><li>  Long Polling creates a load on servers that are greater than customer hits.  Solution - Server-Sent Events, Web Sockets. </li><li>  Brake, unstable work Web Sockets.  The solution is TLS for them (wss). </li></ul><br>  etc. <br><br><h4>  Results </h4><br>  We walked through the main components of a modern web application.  They learned about HTTP 2.0 trends, control points, which are important to understand and learn to measure in order to ensure the speed of a web application's response, if possible, below 0.3 sec.  They looked into the essence of the modern network technologies used in browsers, outlined their strengths and bottlenecks. <br><br>  Understand that to understand the network, its speed, latency and bandwidth - it is important.  And that bandwidth is not always important. <br><br>  It became clear that now it‚Äôs not enough to ‚Äúprotune‚Äù a web server and database.  You need to understand the bunch of network technologies used by the browser, know them from the inside and measure them effectively. Therefore, the TCP traffic sniffer should now become your right hand, and monitoring key performance indicators in server logs with your left foot. <br><br>  You can try to solve the problem of processing the client's request for "0.3 sec" in different ways.  The main thing is to determine the metrics, automatically collect them and act if they are exceeded - get to the root in each case.  In our <a href="http://www.1c-bitrix.ru/products/cms/new/">product,</a> we solved the problem of ensuring the lowest possible latency due to an integrated caching technology that combines static and dynamic site technologies. <br><br>  In conclusion, we invite you to visit our technology conference, which <a href="http://www.failoverconf.ru/conf2014/">will be held</a> soon, on May 23.  Good luck and success in the difficult task of ensuring the performance of web projects! </div><p>Source: <a href="https://habr.com/ru/post/221805/">https://habr.com/ru/post/221805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221795/index.html">Zabbix + Communigate Pro: we monitor the message queue on the selected domains and hosts</a></li>
<li><a href="../221797/index.html">How we didn't earn a million on an iPhone app.</a></li>
<li><a href="../221799/index.html">Colocation, normal and not very</a></li>
<li><a href="../221801/index.html">Linus Torvalds received the IEEE Computer Pioneer award</a></li>
<li><a href="../221803/index.html">VPS Optimization Checklist for PHP / Mysql / Nginx</a></li>
<li><a href="../221807/index.html">Benchmark 14 sorting algorithms on arrays with different dimensions and content</a></li>
<li><a href="../221809/index.html">Space free launch</a></li>
<li><a href="../221811/index.html">The story of parsing one aspx site</a></li>
<li><a href="../221813/index.html">Comparison of biological sequences</a></li>
<li><a href="../221815/index.html">We create a website using Laravel and Recurly. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>