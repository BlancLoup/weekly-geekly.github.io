<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ARMs for the smallest: layout-2, interrupts and hello world!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I found the opportunity to "finish off" the cycle with another article, where I will summarize a little. In fact, it‚Äôs only now that we‚Äôve gotten to t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ARMs for the smallest: layout-2, interrupts and hello world!</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/2cb/611/497/2cb61149753e25fb8ffd5a46da9e7713.jpg"><br><br>  I found the opportunity to "finish off" the cycle with another article, where I will summarize a little.  In fact, it‚Äôs only now that we‚Äôve gotten to the point where we usually start programming: <br><ul><li>  consider the ‚Äúcomplex‚Äù GNU ld build script; </li><li>  learn to use interrupts; </li><li>  finally get to hello world! </li></ul><br><br>  Previous articles of the cycle: <br><ul><li>  <a href="http://habrahabr.ru/post/189484/">ARMs for the smallest</a> </li><li>  <a href="http://habrahabr.ru/post/190032/">ARMs for the little ones: what time is it?</a> </li><li>  <a href="http://habrahabr.ru/post/191058/">ARMs for the smallest: subtleties of compilation and linker</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Code examples from the article: <a href="https://github.com/farcaller/arm-demos">https://github.com/farcaller/arm-demos</a> <br><br><a name="habracut"></a><br><br>  Last time, we figured out which sections we could encounter in the linked application and what their typical contents were.  In particular, we dealt with <code>.data</code> and <code>.bss</code> .  Remember that <code>.data</code> stores global (static) variables with the value specified during compilation.  This section must be copied from flash memory to operational.  Global variables with zero value are stored in <code>.bss</code> , it must be zeroed out. <br><br>  In typical conditions, the procedures from <code>crt0.a</code> (Wikipedia suggests that this name means C RunTime 0, where 0 means the very beginning of the application‚Äôs life).  Today we will write an analogue crt0 for our toy platforms. <br><br>  <i>Disclaimer.</i>  <i>In GNU ld, many of the same things can be done in different ways, using syntax variations and layout flags.</i>  <i>All of the methods described below are a figment of my imagination, written under the influence of LPCXpresso layout scripts.</i>  <i>If you know a more effective method of solving any of the described situation, write to me!</i> <br><br><h4>  Initialization of data in memory </h4><br>  See the file <code>04-helloworld/platform/protoboard/layout.ld</code> .  In general, there are no significant changes relative to the previous version: several constants, a description of the memory section.  Let's take a look at the <code>.data</code> section for an example: <br><pre> <code class="hljs haskell">.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class">(4) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_data</span></span></span><span class="hljs-class"> = .; *(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SORT_BY_ALIGNMENT</span></span></span><span class="hljs-class">(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">*)) . = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN(4)</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_edata</span></span></span><span class="hljs-class"> = .; } &gt; ram </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AT</span></span></span><span class="hljs-class">&gt;rom = 0xff</span></span></code> </pre><br><br>  A <code>.data</code> section is written to the output file with alignment of 4 bytes (i.e., if the cursor points to 0x00000101 before this section, then <code>.data</code> will start from 0x00000104).  The section is in RAM ( <code>&gt; ram</code> ), but is loaded from flash memory ( <code>AT&gt;rom</code> ). <br><br>  The construction <code>=0xff</code> sets the fill pattern.  If unaddressed bytes are formed in the output section, their value will be set to the value of the filler byte.  0xff is selected for the reason that the erased flash memory is all units, i.e., the 0xff record (as opposed to 0x00, for example) is an empty operation. <br><br>  Further, the current cursor position is stored in <code>_data</code> .  Since the section is in RAM, <code>_data</code> will indicate its very beginning, in this case: 0x10000000. <br><br>  Alternately, all source sections with names beginning with <code>.data</code> from all input files are copied to the section, while sorting them by size.  Sorting plays a very important role, consider it on an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> static_int = <span class="hljs-number"><span class="hljs-number">0xab</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> static_int2 = <span class="hljs-number"><span class="hljs-number">0xab</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> static_int3 = <span class="hljs-number"><span class="hljs-number">0xab</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> static_int4 = <span class="hljs-number"><span class="hljs-number">0xab</span></span>;</code> </pre><br><br>  Four variables for the <code>.data</code> section are defined here.  What gets into the final file? <br><pre> <code class="hljs haskell">.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> 0x0000000010000000 0xc load address 0x00000000000007b0 0x0000000010000000 _data = . *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">*) .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int2 0x0000000010000000 0x1 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000000 static_int2 *fill* 0x0000000010000001 0x3 ff .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int3 0x0000000010000004 0x4 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000004 static_int3 .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int4 0x0000000010000008 0x1 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000008 static_int4 *fill* 0x0000000010000009 0x1 ff .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int 0x000000001000000a 0x2 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x000000001000000a static_int 0x000000001000000c . = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class"> (0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x4</span></span></span><span class="hljs-class">) 0x000000001000000c _edata = .</span></span></code> </pre><br>  Note the <code>*fill*</code> bytes that align the variables along the word boundary.  Due to an unsuccessful order, we lost 4 bytes just like that.  Repeat the operation, this time using SORT_BY_ALIGNMENT: <br><pre> <code class="hljs haskell">.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> 0x0000000010000000 0x8 load address 0x00000000000007b0 0x0000000010000000 _data = . *(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SORT</span></span></span><span class="hljs-class">(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">*)) .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int3 0x0000000010000000 0x4 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000000 static_int3 .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int 0x0000000010000004 0x2 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000004 static_int .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int2 0x0000000010000006 0x1 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000006 static_int2 .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.static_int4 0x0000000010000007 0x1 build/d0f0154f60ed1a9c2083183e7c731846451d2bdb_helloworld.o 0x0000000010000007 static_int4 0x0000000010000008 . = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class"> (0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x4</span></span></span><span class="hljs-class">) 0x0000000010000008 _edata = .</span></span></code> </pre><br>  Variables are neatly sorted, and we saved a bunch (33%) of memory! <br><br>  Let us return to the cursor, which now points immediately to the end of all <code>.data</code> .  Construction  <code>. = ALIGN(4)</code> aligns the cursor (if there is not enough data in the input sections for full alignment) along the word boundary.  The final value is recorded in <code>_edata</code> . <br><br>  In addition to the addresses in memory, we need to know where the section is in flash memory. For this, the symbol is declared at the beginning of the script: <code>_data_load = LOADADDR(.data)</code> .  <b>LOADADDR</b> is a function that returns the section load address.  In addition to it there are some more interesting functions: <b>ADDR</b> returns the ‚Äúvirtual‚Äù address, <b>SIZEOF</b> - section size in bytes. <br><br>  Take a look at the initialization code of the <code>.data</code> section, <code>04-hello-world/platform/common/platform.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *load_addr = &amp;_data_load; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *mem_addr = &amp;_data; mem_addr &lt; &amp;_edata;) { *mem_addr++ = *load_addr++; }</code> </pre><br>  In the loop, we copy the values ‚Äã‚Äãfrom <code>load_addr</code> to <code>mem_addr</code> . <br><br>  Typically, this initialization is carried out as early as possible, if possible, as one of the very first tasks.  There is a very reasonable explanation for this: prior to initialization, access to global variables from C will return garbage.  In our case, the initialization is carried out after calling <code>platform_init</code> , since this function does not depend on the data in <code>.data</code> / <code>.bss</code> , and its execution will allow you to execute the subsequent code faster, which ultimately will give a performance boost.  The downside was the emergence of a separate <code>platform_init_post</code> , where the global variable is initialized by the system bus frequency value. <br><br>  The last section - <code>/DISCARD/</code> - is special, it's a kind of / dev / null linker.  All incoming sections will simply be thrown away (as you remember, if a section is not explicitly indicated, it will be automatically added to the appropriate memory area).  This section is described more for clarity, as the input sections in the case of ARMv6-M0 are guaranteed to be empty. <br><br><h4>  About different interruptions </h4><br>  Pay your attention to the slightly modified first section <code>.text</code> , where two new ones fall: <code>.isr_vector</code> and <code>.isr_vector_nvic</code> .  Both are wrapped in a <b>KEEP</b> instruction, which prevents the linker from ‚Äúoptimizing‚Äù them as superfluous.  <code>.isr_vector</code> contains a common interrupt table for the Cortex-M, which can be <code>platform/common/isr.c</code> in the file <code>platform/common/isr.c</code> : <br><br><pre> <code class="cpp hljs">__attribute__ ((weak)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_nmi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; __attribute__ ((weak)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_hardfault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; __attribute__ ((weak)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_svcall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; __attribute__ ((weak)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_pendsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; __attribute__ ((weak)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_systick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; __attribute__ ((section(<span class="hljs-string"><span class="hljs-string">".isr_vector"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isr_vector_table[])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = { &amp;_stack_base, main, <span class="hljs-comment"><span class="hljs-comment">// Reset isr_nmi, // NMI isr_hardfault, // Hard Fault 0, // CM3 Memory Management Fault 0, // CM3 Bus Fault 0, // CM3 Usage Fault &amp;_boot_checksum, // NXP Checksum code 0, // Reserved 0, // Reserved 0, // Reserved isr_svcall, // SVCall 0, // Reserved for debug 0, // Reserved isr_pendsv, // PendSV isr_systick, // SysTick };</span></span></code> </pre><br><br>  As you can see, we moved away from declaring a table in an assembly file and describe it in C terminology. Independent interrupt handlers were also introduced (instead of one common <code>hang</code> ).  All of these default handlers perform an infinite loop (although I shoved the debug LED a couple of times in <code>isr_hardfault</code> I wrote examples for the article), but since they are declared with the <code>weak</code> attribute, they can be redefined in any other file.  For example, <code>timer.c</code> has its own implementation of <code>isr_systick</code> , which will fall into the final image. <br><br>  The continuation of the table is made in a similar structure <code>isr_vector_table_nvic</code> , since it already depends on the specific processor, but the essence remains the same. <br><br><h4>  And about interruptions </h4><br>  Let's say a little more about interrupts.  The general essence of interrupts is a call to the handler as a reaction to any external events (relative to the code that is executed at the time of the event).  A nice feature of Cortex-M: the processor will pack / unpack register values ‚Äã‚Äãitself, so that interrupts can be written as normal functions in C. Moreover, the nesting of interrupts will also be worked out automatically. <br><br>  NVIC - nested vector interrupt controller processes interrupts from peripherals behind the ARM core.  It allows you to set different priorities for different interrupts, disable them centrally or generate an interrupt programmatically. <br><br>  Let's look at a new systick-based timer implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> systick_10ms_ticks = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform_delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tenms = msec / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> dest_time = systick_10ms_ticks + tenms; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(systick_10ms_ticks &lt; dest_time) { __WFI(); } } <span class="hljs-comment"><span class="hljs-comment">// override isr_systick from isr.c void isr_systick(void) { ++systick_10ms_ticks; }</span></span></code> </pre><br>  The standby cycle puts the processor in the interrupt standby mode (sleep mode) until the system counter exceeds the required value.  At the same time, every 10 ms, SysTick overflows and generates an interrupt, by which the <code>isr_systick</code> increments the counter by 1. Note that <code>systick_10ms_ticks</code> declared as <b>volatile</b> , this makes the compiler realize that the value of this variable can (and will) change outside the current context, and it should be re-read each time from RAM (where the interrupt handler will change it). <br><br><h4>  libgcc </h4><br>  In this code, we first use the division operation.  It would seem that there is a difficult, but in Cortex-M0 there is no hardware instruction for the division :-).  The compiler is aware of this, and instead of a division instruction, it inserts a call to the function <code>__aeabi_uidiv</code> , which divides numbers programmatically.  This function (and several similar ones) are implemented in the compiler support library: libgcc.a.  Unfortunately, our linker knows nothing about it, and we stumble upon an unpleasant error: <br><pre> <code class="hljs vhdl">build/<span class="hljs-number"><span class="hljs-number">5</span></span>a3e7023bbfde5552a4ea7cc57c4520e0e458a53_timer.o: <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> `platform_delay': timer.c:(.<span class="hljs-literal"><span class="hljs-literal">text</span></span>.platform_delay+<span class="hljs-number"><span class="hljs-number">0</span></span>x4): undefined reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> `__aeabi_uidiv'</code> </pre><br>  The correct solution is to replace the linker call directly with the gcc call, which will already figure out where to link.  True, gcc can be a little overdoing, so we tell it via <code>-nostartfiles</code> that we have our own initialization code, and through <code>-ffreestanding</code> , that our application is independent and does not depend on any OS. <br><br><h4>  Finally, hello habr! </h4><br>  This version is somewhat significant, as it has a UART driver, which means that we will see the real operation of our code not only by the flashing LED.  But first, the driver: <br> <code>platform/protoboard/uart.c</code> <br> <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> platform_clock; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">platform_uart_setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> baud_rate)</span></span></span><span class="hljs-function"> </span></span>{ NVIC_DisableIRQ(UART_IRQn);</code> </pre>  First of all, we turn off the interrupt on NVIC in case it was turned on. <br><pre> <code class="cpp hljs"> LPC_SYSCON-&gt;SYSAHBCLKCTRL |= (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>); LPC_IOCON-&gt;PIO1_6 &amp;= ~<span class="hljs-number"><span class="hljs-number">0x07</span></span>; LPC_IOCON-&gt;PIO1_6 |= <span class="hljs-number"><span class="hljs-number">0x01</span></span>; LPC_IOCON-&gt;PIO1_7 &amp;= ~<span class="hljs-number"><span class="hljs-number">0x07</span></span>; LPC_IOCON-&gt;PIO1_7 |= <span class="hljs-number"><span class="hljs-number">0x01</span></span>;</code> </pre>  Next, we will turn on the microcontroller unit, which is responsible for pin setting, and configure them in TXD / RXD UART mode.  This code spilled a lot of my blood when I tried to understand why the UART after a reboot does not work.  Be careful, sometimes the obvious things are turned off by default! <br><pre> <code class="cpp hljs"> LPC_SYSCON-&gt;SYSAHBCLKCTRL |= (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">12</span></span>); LPC_SYSCON-&gt;UARTCLKDIV = <span class="hljs-number"><span class="hljs-number">0x1</span></span>;</code> </pre>  Now you can turn on the UART itself, and at the same time set the input frequency divider. <br><pre> <code class="cpp hljs"> LPC_UART-&gt;LCR = <span class="hljs-number"><span class="hljs-number">0x83</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Fdiv = platform_clock <span class="hljs-comment"><span class="hljs-comment">//   / LPC_SYSCON-&gt;SYSAHBCLKDIV //      / LPC_SYSCON-&gt;UARTCLKDIV //    UART / 16 //   16,   / baud_rate; // , ,   LPC_UART-&gt;DLM = Fdiv / 256; LPC_UART-&gt;DLL = Fdiv % 256; LPC_UART-&gt;FDR = 0x00 | (1 &lt;&lt; 4) | 0; LPC_UART-&gt;LCR = 0x03;</span></span></code> </pre>  In addition to the classic 8N1 mode, we open access to the output dividers, which set the bitrate.  Calculate dividers and write them into registers.  For the curious, the formula is in section 13.5.15 of the manual.  In addition, it describes an additional divider for even more accurate bodrate.  In my tests, the 9580 worked quite well :-) <br><pre> <code class="cpp hljs"> LPC_UART-&gt;FCR = <span class="hljs-number"><span class="hljs-number">0x07</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> unused = LPC_UART-&gt;LSR; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(( LPC_UART-&gt;LSR &amp; (<span class="hljs-number"><span class="hljs-number">0x20</span></span>|<span class="hljs-number"><span class="hljs-number">0x40</span></span>)) != (<span class="hljs-number"><span class="hljs-number">0x20</span></span>|<span class="hljs-number"><span class="hljs-number">0x40</span></span>) ) ; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( LPC_UART-&gt;LSR &amp; <span class="hljs-number"><span class="hljs-number">0x01</span></span> ) { unused = LPC_UART-&gt;RBR; }</code> </pre>  We turn on the FIFO, reset it, make sure that there are no strange data in the registers. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// NVIC_EnableIRQ(UART_IRQn); // LPC_UART-&gt;IER = 0b101;</span></span></code> </pre>  Enable interrupts to receive (in fact, no).  There is no interrupt handler in the example, so there is no need for an interrupt. <br><br>  For LPC1768, the code is very similar, so I will not analyze it.  I note only that there all the peripherals are included at boot time, which simplifies the situation. <br><br>  An important point: mbed has three UARTs brought outside, and several pin options for each.  Since USB communication would take significantly more code, you will have to hook the FTDI-cord on the UART, in the example - these are the P13 / P14 pins. <br><br><h4>  Summing up </h4><br>  We have dealt with the linker, we have a ready core on which to expand the base and write drivers.  Or even take CMSIS and the demo from the manufacturer (just read the code, the examples in LPCXpresso have typos of different degrees of sadness). <br><br>  I have enough ideas for further articles, but there was not enough time, too many interesting things are not yet programmed!  I will try, nevertheless, to return to the ‚Äúmicrocosm‚Äù of embeddings after the ‚Äúmacroworld‚Äù of office days. <br><br>  PS As always, thank you very much <a href="https://habrahabr.ru/users/pfactum/" class="user_link">pfactum</a> for reading the text. <br><br><h6> <a rel="license" href=""><img alt="Creative Commons License" src="http://habr.habrastorage.org/post_images/a58/dd6/778/a58dd6778494eefb36a9b5ccee5d6187.png"></a>  This work is available under <a rel="license" href="">the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported license</a> .  The program text of the examples is available under <a rel="license" href="http://unlicense.org/">the Unlicense license</a> (unless otherwise indicated in the headers of the files).  This work is written solely for educational purposes and is in no way affiliated with the current or previous employers of the author. </h6></div><p>Source: <a href="https://habr.com/ru/post/194816/">https://habr.com/ru/post/194816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../194806/index.html">SmartProgress 2.0. We have turned goal achievement into an exciting activity.</a></li>
<li><a href="../194808/index.html">Incredible new polymer that heals itself with 97% efficiency.</a></li>
<li><a href="../194810/index.html">Broadcast launch RAD Studio XE5</a></li>
<li><a href="../194812/index.html">We organize Asterisk IP telephony in the office without learning Linux</a></li>
<li><a href="../194814/index.html">How do the stars count? Using InterSystems Cach√© eXtreme at Gaia</a></li>
<li><a href="../194818/index.html">InterSystems Cach√© and NoSQL Technology</a></li>
<li><a href="../194822/index.html">Copyright: you have to take the initiative</a></li>
<li><a href="../194830/index.html">It seems that the next Android will also be "flat"</a></li>
<li><a href="../194832/index.html">ILC: why do scientists need the second Big Collider?</a></li>
<li><a href="../194834/index.html">Recipe schemes for pizzeria cuisine. Fast food plus design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>