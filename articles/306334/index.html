<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elixir: Getting Started with Plug</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the world of Elixir , Plug is a specification that allows different frameworks to communicate with different web servers running in Erlang VM . 
 I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elixir: Getting Started with Plug</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f63/9be/3ec/f639be3ec4e44c548031fa7aa0fe26f4.jpg" align="left"><br><p> In the world of <code>Elixir</code> , <a href="https://github.com/elixir-lang/plug"><code><u>Plug</u></code></a> is a specification that allows different frameworks to communicate with different web servers running in <code>Erlang VM</code> . <br>  If you are familiar with <code>Ruby</code> , you can draw an analogy with <code>Rack</code> : <code>Plug</code> tries to solve the same problems, but in a different way.  Understanding the basics of <code>Plug</code> will help you better understand both <code>Phoenix</code> and other web frameworks created in the <code>Elixir</code> language. </p><br><p><br clear="left"></p><a name="habracut"></a><br><h3 id="rol-plug">  <em>Plug</em> role </h3><br><p>  You can think of <code>Plug</code> as a piece of code that takes a data structure, performs some transformations with it, and returns the same data structure, but already partially modified.  The data structure that the <code>Plug</code> works with is usually called a <em>connection</em> .  This structure stores everything you need to know about the request ( <em>lane</em> : and the answer, too). </p><br><p>  Since any <code>Plug</code> accepts and returns a <code></code> , it is possible to build a chain of several such objects that will sequentially handle the same <code></code> .  This composition is called <code>Plug pipeline</code> </p><br><p>  The data structure itself, representing the <code></code> is a regular <code>Elixir</code> structure called <code>%Plug.Conn{}</code> (documentation on it can be found <a href="http://hexdocs.pm/plug/Plug.Conn.html">here</a> ). </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f7/c18/7e1/3f7c187e1c1041a4b31c533851836fce.png"></div><br><h3 id="dva-razlichnyh-tipa-plug">  Two different types of <em>plug</em> </h3><br><p>  There are two different types of <code>Plug</code> : <code>Plug</code> function and <code>Plug</code> module. </p><br><p>  <strong><code>Plug</code> function</strong> is any function that accepts a <code></code> as an argument (this is the same <code>%Plug.Conn{}</code> ), and a set of options, and returns the <code></code> . </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_plug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conn, opts)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> conn <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  <strong><code>Plug</code> module</strong> is in turn any module that has the following interface: <code>init/1</code> and <code>call/2</code> , implemented as follows: </p><br><pre> <code class="hljs sql">module MyPlug <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> init(opts) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> opts <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, opts) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Of interest is the fact that the <code>init/1</code> function is called at compile time, and the <code>call/2</code> function is <code>call/2</code> while the program is running. </p><br><h3 id="prostoy-primer">  Simple example </h3><br><p>  Let's move from theory to practice and create a simple application that uses <code>Plug</code> to process an <code>http</code> request. </p><br><p>  First, create a new project using <code>mix</code> : </p><br><pre> <code class="bash hljs">$ mix new learning_plug $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> learning_plug</code> </pre> <br><p>  Edit the <code>mix.exs</code> file, adding <code>Plug</code> and <code>Cowboy</code> as dependencies (this is a web server): </p><br><pre> <code class="hljs pgsql"># ./mix.exs defp deps <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [{:plug, "~&gt; 1.0"}, {:cowboy, "~&gt; 1.0"}] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We will tighten dependencies: </p><br><pre> <code class="bash hljs">$ mix deps.get</code> </pre> <br><p>  and we are ready to start work! </p><br><p>  Our first <code>Plug</code> will simply return <em>"Hello, World!"</em>  : </p><br><pre> <code class="ruby hljs">defmodule LearningPlug <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># The Plug.Conn module gives us the main functions # we will use to work with our connection, which is # a %Plug.Conn{} struct, also defined in this module. import Plug.Conn def init(opts) do # Here we just add a new entry in the opts map, that we can use # in the call/2 function Map.put(opts, :my_option, "Hello") end def call(conn, opts) do # And we send a response back, with a status code and a body send_resp(conn, 200, "#{opts[:my_option]}, World!") end end</span></span></code> </pre> <br><p>  To use this module, run <code>iex</code> with the project environment: </p><br><pre> <code class="bash hljs">$ iex -S mix</code> </pre> <br><p>  and execute the following commands: </p><br><pre> <code class="bash hljs">iex(1)&gt; Plug.Adapters.Cowboy.http(LearningPlug, %{}) {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.150.0&gt;}</span></span></code> </pre> <br><p>  We use <code>Cowboy</code> as a web server, telling it to use our Plug.  The second argument of the <code>http/2</code> function (in this case, an empty <code>Map</code> <code>%{}</code> ) is the same set of options that will be passed as an argument to the <code>init/1</code> function in our <code>Plug</code> . <br>  The web server was supposed to start on port 4000, so if you open <code>http://localhost:4000</code> in a browser, you will see <em>"Hello, World!"</em>  .  Very simple! </p><br><p>  Let's try to make our <code>Plug</code> little smarter.  Let him analyze the URL to which we make a request to the server, and if for example we are trying to access <code>http://localhost:4000/Name</code> we should see <em>‚ÄúHello, Name‚Äù</em> . </p><br><p>  Since the <code></code> is figuratively <em>everything</em> you need to know about the request, it also stores its URL.  We can simply match the pattern of this URL to create the response we want.  Let's slightly alter the <code>call/2</code> function as follows: </p><br><pre> <code class="hljs sql">def <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(%Plug.Conn{request_path: <span class="hljs-string"><span class="hljs-string">"/"</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>} = <span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, opts) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> send_resp(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, #{name}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here it is, the power of functional programming!  We only match the information we need (name), and then use it to generate a response. </p><br><h3 id="pipeline-i-kak-eto-rabotaet">  <em>Pipeline</em> and how it works </h3><br><p>  <code>Plug</code> in itself is of no particular interest.  The beauty of this architecture is revealed when trying to compose multiple <code>Plug</code> modules together.  Each of them does its little part of the work, and passes the <code></code> on. </p><br><p>  <code>Phoenix</code> framework uses the <code>pipeline</code> everywhere, and does it very cleverly.  By default, to process a regular browser request, the <code>pipeline</code> looks like this: </p><br><pre> <code class="hljs ruby">pipeline <span class="hljs-symbol"><span class="hljs-symbol">:browser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> plug <span class="hljs-symbol"><span class="hljs-symbol">:accepts</span></span>, [<span class="hljs-string"><span class="hljs-string">"html"</span></span>] plug <span class="hljs-symbol"><span class="hljs-symbol">:fetch_session</span></span> plug <span class="hljs-symbol"><span class="hljs-symbol">:fetch_flash</span></span> plug <span class="hljs-symbol"><span class="hljs-symbol">:protect_from_forgery</span></span> plug <span class="hljs-symbol"><span class="hljs-symbol">:put_secure_browser_headers</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  If, for example, we need to process a request to the <strong>API</strong> , we do not need most of these functions.  Then the <code>pipeline</code> greatly simplified: </p><br><pre> <code class="hljs ruby">pipeline <span class="hljs-symbol"><span class="hljs-symbol">:api</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> plug <span class="hljs-symbol"><span class="hljs-symbol">:accepts</span></span>, [<span class="hljs-string"><span class="hljs-string">"json"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Of course, the <code>pipeline</code> macro from the previous example is built into <code>Phoenix</code> .  However, the <code>Plug</code> itself provides the ability to build such a <code>pipeline</code> : <code>Plug.Builder</code> . </p><br><p>  Here is an example of his work: </p><br><pre> <code class="ruby hljs">defmodule MyPipeline <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># We use Plug.Builder to have access to the plug/2 macro. # This macro can receive a function or a module plug and an # optional parameter that will be passed unchanged to the # given plug. use Plug.Builder plug Plug.Logger plug :extract_name plug :greet, %{my_option: "Hello"} def extract_name(%Plug.Conn{request_path: "/" &lt;&gt; name} = conn, opts) do assign(conn, :name, name) end def greet(conn, opts) do conn |&gt; send_resp(200, "#{opts[:my_option]}, #{conn.assigns.name}") end end</span></span></code> </pre> <br><p>  Here we made the composition of three <code>Plug</code> - <code>Plug.Logger</code> , <code>extract_name</code> and <code>greet</code> modules. <br>  <code>extract_name</code> uses <code>assign/3</code> to put a value with a specific key into the <code></code> .  <code>assign/3</code> returns a modified copy of the <code></code> , which is then processed by <code>greet_plug</code> , which reads the value backwards, to then generate the response we need. </p><br><p>  <code>Plug.Logger</code> comes with a <code>Plug</code> and, you guessed it, used to log <code>http</code> requests.  Directly out of the box is available a certain set of "batteries", the list can be found <a href="https://github.com/elixir-lang/plug">here.</a> </p><br><p>  Using such a <code>pipeline</code> is as easy as <code>Plug</code> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Plug</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Adapters</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Cowboy</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.http</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyPipeline</span></span>, %{})</code> </pre> <br><p>  It should be remembered that the modules are used in the same sequence in which they are defined in the <code>pipeline</code> </p><br><p>  Another feature: those compositions created with <code>Plug.Builder</code> also implement the <code>Plug</code> interface.  Therefore, for example, you can make a composition of the <code>pipeline</code> and <code>Plug</code> , and continue indefinitely! </p><br><h3 id="podytozhim">  Summarize </h3><br><p>  The basic idea is that both the request and the response are presented in one <code>%Plug.Conn{}</code> common structure, and this structure is passed "along the chain" from function to function, partially changing at each step ( <em>trans</em> : figuratively changing - data is immuniable, therefore, a modified copy of the structure is transmitted further, until a response is received that will be sent back.  <code>Plug</code> is a specification that defines how it should work and creates abstractions so that different frameworks can communicate with different web servers as long as they fulfill this specification. </p><br><p>  The "batteries" for the <code>Plug</code> include various modules that facilitate many different common tasks: the creation of a <code>pipeline</code> , simple routing, cookies, headers, and so on. </p><br><p>  And in the end I would like to note that the basis of the <code>Plug</code> is the very idea of ‚Äã‚Äãfunctional programming - the transfer of data along a chain of functions that transform this data until the desired result is obtained.  Just in this case, the data is an <code>http</code> request. </p><br><p>  <i>Update: in fact, this is a translation, for some reason it was created as a publication.</i>  <i>Correct, apologize.</i>  <i>Additionally - minor spelling corrections.</i> <i><br></i> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306334/">https://habr.com/ru/post/306334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306322/index.html">10 techniques used by manipulators (and how to deal with them)</a></li>
<li><a href="../306324/index.html">Implementation of the Bailey ‚Äî Borwein ‚Äî Plaff algorithm on Golang</a></li>
<li><a href="../306326/index.html">Help Desk and Service Desk - when is Excel and CRM insufficient? Really important functions of accounting systems</a></li>
<li><a href="../306328/index.html">10 errors leading to software overgraining</a></li>
<li><a href="../306332/index.html">Solve RAII problems with std :: thread: cancellation_token as an alternative to pthread_cancel and boost :: thread :: interrupt</a></li>
<li><a href="../306336/index.html">Skills and requirements for information security professionals</a></li>
<li><a href="../306338/index.html">Stripe: your dream service to automate money transfers</a></li>
<li><a href="../306340/index.html">Summer update on Habr√©: ‚ÄúAdministration‚Äù, voice weight and much more</a></li>
<li><a href="../306342/index.html">Prospects for the commercial use of IPv6 in Russia (year 2016)</a></li>
<li><a href="../306344/index.html">11 design projects that "blew up" the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>