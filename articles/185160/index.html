<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building scalable applications in TypeScript. Part 2 - Events or why you should reinvent your own bike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, I talked about asynchronous loading of modules using Require.js and standard TypeScript language tools. Inadvertentl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building scalable applications in TypeScript. Part 2 - Events or why you should reinvent your own bike</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/184942/">first part of the article,</a> I talked about asynchronous loading of modules using Require.js and standard TypeScript language tools.  Inadvertently, I preoccupied the topic of organizing work with abstract events, which I was very quickly reminded of in the comments.  In particular, the question was asked, why invent your own bike, if Backbone.Events, proven and well-working and other analogues, have existed for a long time? <br><br>  If you are interested in the answer to this question, an alternative implementation on TypeScript and is not afraid of reading the code, then I ask under the cat. <a name="habracut"></a><br><br>  Everything is simple - all existing Javascript frameworks today absolutely do not support one of the main advantages of TypeScript - static typing and its consequence - type control at the compilation stage.  JS frameworks have no reason to blame for this.  There is simply no means in the language for this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, this is not the only problem.  What's worse, JS uses impurities very often, in particular, the whole Backbone is built on them.  No, there is nothing wrong with them in themselves.  This is a completely natural and viable practice in the context of pure prototype dynamic JS and small projects.  In the case of TS, it leads to a number of unpleasant consequences, especially when trying to create an application of at least some serious size: <br><br><ol><li>  The analogue of impurities in classical OOP is multiple inheritance.  I would not want to enter the "holy war", but in my opinion, multiple inheritance is always bad.  Especially in the conditions of dynamic typing, without the ability to control the behavior of objects at least through an explicit or implicit implementation of interfaces a la C #.  Naturally in JS you can not even dream about it, so debugging, support and refactoring of such a code is a complete nightmare. </li><li>  Apart from high matters, TS simply does not support this at the language level.  Bekbonovsky extend is a complete analogue of inheritance in TS and it works fine for Model and View, but is absolutely not suitable for events.  No, we can of course inherit all classes in the application from Backbone.Event or its analogue depending on the framework and achieve the result, but this does not solve the 3rd problem: </li><li>  The events of Backbone or any other JS framework are not typed.  Goodbye static analysis and all the benefits of TS. </li></ol><br><br><h5>  What are such events and what is needed from them? </h5><br><br>  If you do not go into the wilds, then the event is a signal received by the application from the outside or generated internally, upon receipt of which the application can or may not do anything.  Personally, I don‚Äôt know what else can be said about events, if I get up at 2 am, send a flashlight to my face and start interrogating) <br><br>  But everything changes if some context appears.  In our case, the context is JavaScript, which, without any add-ons in the form of TS, is already a 100% OOP language.  In particular, all entities in JS are objects.  DOMEvent objects created by the browser are also objects.  That is, if we continue the analogy, then any event is an object. <br><br>  Suppose that in the case of Backbone, an event is also an object.  The question is - what?  In fact, we have a collection of callbacks that are called according to some rules.  The collection is universal.  She is able to take any function.  Ie, again I will stop at this, we do not have typification. <br><br>  But wait.  What is our goal?  Get static code analysis.  Hence, the event must be an object and have type - class.  This is the first requirement that is necessary to achieve a result.  Events must be described by classes so that they can be typed. <br><br>  This implies the second requirement - events must be processed and work in the same type, i.e.  inherit from base class.  If events are inherited, then even without delving into the jungle of SOLID, etc., it is clear that to inherit from them is a completely bad idea. <br><br>  The third requirement is the minimum required functionality.  You can subscribe to an event, unsubscribe from it, as well as call it.  Everything else is not critical.  Naturally, an event can have one or several handlers. <br><br>  The fourth consideration is that we are talking about events in the context of asynchronous loading of modules that are strongly typed, which is controlled at the compilation stage.  Those.  We have a late binding and strong typing situation, i.e.  subscribers always know which event they are subscribing to, and dependency management is not their problem. <br><br>  Fifth, I want events to be part of any object, regardless of the inheritance hierarchy. <br><br>  Gathering thoughts in a bunch and turning on KMFDM, I proceed to the solution of self-created problems. <br><br>  Sources, still on Codeplex: <a href="https://tsasyncmodulesexampleapp.codeplex.com/">https://tsasyncmodulesexampleapp.codeplex.com</a> <br><br><h5>  First thoughts </h5><br><br>  And so, any object, event is a class, etc.  This means 2 things: first, we have a base Event class: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Add(callback: any): void { /*    */ } Remove(callback: any): void { /*    */ } Trigger(): void { /*    */ } }</span></span></code> </pre> <br><br>  Secondly, we‚Äôll use it like this, carefully sneaking around looking at C # and inspired by its example: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;reference path="Events.ts" /&gt; import Events = require('Framework/Events'); export class MessagesRepo { public MessagesLoaded: Events.Event = new Events.Event(); } class SomeEventSubscriber { // .    private MessagesRepo = new MessagesRepo(); public Foo() { this.MessagesRepo.MessagesLoaded.Add(function () { alert('MessagesLoaded'); }); } }</span></span></code> </pre><br><br>  Those.  an event is just a public member of a class.  No more and no less.  What it gives us: <br><br><ul><li>  Events are known at compile time. </li><li>  Events can be announced in any class. </li><li>  We have the minimum necessary functionality, it is concentrated in one place and easily modified. </li><li>  All events are realized by one class or its successors, i.e.  we can easily change the logic of their work, for example, by creating a descendant of SecureEvent, inherited from the Event, performing a callback only under certain conditions. </li><li>  There is no typical hemorrhoids of JS frameworks with a context that now strictly depends on instances of objects, typos in the names of events, etc. </li></ul><br><br>  What we still do not have: <br><br>  1. Strong typing <br>  2. Due to the lack of context, it is impossible to unsubscribe from a callback event specified by an anonymous function, i.e.  any callback we have to save somewhere, which is inconvenient. <br>  3. Non-typed event parameters <br><br><h5>  Strong typing </h5><br><br>  We will deal with the first problem.  We use the innovation TypeScript 0.9 - generics: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Add(callback: Callback): void { /*    */ } Remove(callback: Callback): void { /*    */ } Trigger(): void { /*    */ } }</span></span></code> </pre><br><br>  And look at the application: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;reference path="Events.ts" /&gt; import Events = require('Framework/Events'); export class MessagesRepo { public MessagesLoaded: Events.Event&lt;{ (messages: string[]): void }&gt; = new Events.Event&lt;{ (messages: string[]): void }&gt;(); } class SomeEventSubscriber { // .    private MessagesRepo = new MessagesRepo(); public Foo() { this.MessagesRepo.MessagesLoaded.Add(function (messages: string[]) { alert('MessagesLoaded'); }); } }</span></span></code> </pre><br><br>  With this, the following code: <br><br><pre> <code class="javascript hljs">public Foo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MessagesRepo.MessagesLoaded.Add(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message: string</span></span></span><span class="hljs-function">) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'MessagesLoaded'</span></span>); }); }</code> </pre><br><br>  Will give an error: <br><br> <code>Supplied parameters do not match any signature of call target: <br> Call signatures of types '(message: string) =&gt; void' and '(messages: string[]) =&gt; void' are incompatible: <br> Type 'String' is missing property 'join' from type 'string[]'</code> <br> <br>  A callback with no parameters (well, we don‚Äôt need them), compiles calmly: <br><br><pre> <code class="javascript hljs">public Foo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MessagesRepo.MessagesLoaded.Add(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'MessagesLoaded'</span></span>); }); }</code> </pre><br><br>  The design of <code>Callback extends Function</code> necessary for correct compilation, since  TS should know that <code>Callback</code> can be called. <br><br><h5>  Anonymous callbacks and return subscription states <br></h5><br>  As I wrote above, with this implementation, we cannot unsubscribe anonymous callbacks, which leads to an absolutely unusual for laconic JS with its anonymous verbosity functions and declaring unnecessary variables.  For example: <br><br><pre> <code class="javascript hljs">private FooMessagesLoadedCallback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'MessagesLoaded'</span></span>); } public Foo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MessagesRepo.MessagesLoaded.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FooMessagesLoadedCallback); }</code> </pre><br><br>  In my opinion, this is a complete enterprise of the brain and the killing of all the functional features of JS / TS. <br><br>  Nevertheless, it is impossible to do without unsubscribing from events in any more or less complex application, since  without this, it is impossible to correctly destroy complex objects and control the behavior of objects participating in interaction through events.  For example, we have a certain base class of the FormBase form, from which all forms in our application are inherited.  Suppose that he has some method Destroy, which clears all unnecessary resources, unbinds events, etc.  Descendant classes override it if necessary.  If all functions are stored in variables, then there is no problem to transfer them to the event, and the event through the equality of types has no problem to determine the callback and remove it from the collection.  This scenario is not possible using anonymous functions. <br><br>  I propose to solve the second problem in the following way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class">&gt; </span></span>{ public Add(callback: Callback): ITypedSubscription&lt;Callback, Event&lt;Callback&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res: ITypedSubscription&lt;Callback, Event&lt;Callback&gt;&gt; = { <span class="hljs-attr"><span class="hljs-attr">Callback</span></span>: callback, <span class="hljs-attr"><span class="hljs-attr">Event</span></span>: that, <span class="hljs-attr"><span class="hljs-attr">Unsubscribe</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.Remove(callback); } } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } public Remove(callback: Callback): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> } public Trigger(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> } } <span class="hljs-comment"><span class="hljs-comment">/**     .  .     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface ISubscription { <span class="hljs-attr"><span class="hljs-attr">Unsubscribe</span></span>: { (): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }; } <span class="hljs-comment"><span class="hljs-comment">/**  .      callback */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface ITypedSubscription&lt;Callback, Event&gt; extends ISubscription { <span class="hljs-attr"><span class="hljs-attr">Callback</span></span>: Callback; Event: Event; }</code> </pre><br><br>  Ie, we simply return in the Add method a reference to the event, callback and wrapper for the Remove method.  After that, it remains to implement an elementary "finalizer" with the subscriber: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** ,    IntelliSense ;) */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeEventSubscriber</span></span></span><span class="hljs-class"> </span></span>{ private MessagesRepo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessagesRepo(); <span class="hljs-comment"><span class="hljs-comment">/**        */</span></span> private Subscriptions: Events.ISubscription[] = []; public Foo() { <span class="hljs-comment"><span class="hljs-comment">//      this.Subscriptions.push(this.MessagesRepo.MessagesLoaded.Add(function () { alert('MessagesLoaded'); })); //   this.Subscriptions.push(this.MessagesRepo.ErrorHappened.Add(function (error: any) { alert(error); })); } /**             */ public Destroy() { for (var i = 0; i &lt; this.Subscriptions.length; i++) { this.Subscriptions[i].Unsubscribe(); } this.Subscriptions = []; } }</span></span></code> </pre><br><br><h5>  Typing of event parameters </h5><br><br>  Everything is very simple.  Again we use generalizations: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Options</span></span></span><span class="hljs-class">&gt; </span></span>{ public Add(callback: Callback): ITypedSubscription&lt;Callback, Event&lt;Callback, Options&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> that = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res: ITypedSubscription&lt;Callback, Event&lt;Callback, Options&gt;&gt; = { <span class="hljs-attr"><span class="hljs-attr">Callback</span></span>: callback, <span class="hljs-attr"><span class="hljs-attr">Event</span></span>: that, <span class="hljs-attr"><span class="hljs-attr">Unsubscribe</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ that.Remove(callback); } } <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } public Remove(callback: Callback): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> } public Trigger(options: Options): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> } }</code> </pre><br><br>  The class publisher will now look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface ErrorHappenedOptions { <span class="hljs-attr"><span class="hljs-attr">Error</span></span>: any; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessagesRepo</span></span></span><span class="hljs-class"> </span></span>{ public MessagesLoaded: Events.Event&lt; { (messages: string[]): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } <span class="hljs-comment"><span class="hljs-comment">//Callback , string[]&gt; //Options = new Events.Event&lt;{ (messages: string[]): void }, string[]&gt;(); public ErrorHappened: Events.Event&lt; { (error: ErrorHappenedOptions): void }, //Callback ErrorHappenedOptions&gt; //Options = new Events.Event&lt;{ (error: ErrorHappenedOptions): void }, ErrorHappenedOptions&gt;(); }</span></span></code> </pre><br><br>  And the event call is: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subscriber: Messages.SomeEventSubscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Messages.SomeEventSubscriber(); subscriber.MessagesRepo.MessagesLoaded.Trigger([<span class="hljs-string"><span class="hljs-string">'Test message 1'</span></span>]); subscriber.MessagesRepo.ErrorHappened.Trigger({ <span class="hljs-attr"><span class="hljs-attr">Error</span></span>: <span class="hljs-string"><span class="hljs-string">'Test error 1'</span></span> });</code> </pre><br><br>  At this my Wishlist for events end.  For the complete source codes and the current example, I ask for <a href="https://tsasyncmodulesexampleapp.codeplex.com/">Codeplex</a> . <br><br>  Thank you all for the positive assessment of the first part. <br><br>  Depending on the interest in the article and the subject of comments I will choose the theme of the third part.  For now, I plan to write my view on widgets / forms, their loading and centralized ‚Äúmemory management‚Äù in the application. <br><br>  Work on the bugs according to the comments: <br>  Part 2.5: <a href="http://habrahabr.ru/post/185290/">Building Scalable Applications on TypeScript - Part 2.5.</a>  <a href="http://habrahabr.ru/post/185290/">Bug fixes and delegates</a> </div><p>Source: <a href="https://habr.com/ru/post/185160/">https://habr.com/ru/post/185160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185144/index.html">Ability to see abstractions</a></li>
<li><a href="../185148/index.html">Changed the time for taking Microsoft exams</a></li>
<li><a href="../185150/index.html">Simple-Science - Simple Experiments (Digest # 24)</a></li>
<li><a href="../185152/index.html">Simple NAS-based Web Server</a></li>
<li><a href="../185154/index.html">Real time music generation</a></li>
<li><a href="../185162/index.html">Try Windows Server 2012 R2, SQL Server 2014 and Visual Studio 2013 without installation!</a></li>
<li><a href="../185164/index.html">Backward compatibility for losers</a></li>
<li><a href="../185172/index.html">Windows on RAM disk</a></li>
<li><a href="../185176/index.html">The life of a homemade arcade machine</a></li>
<li><a href="../185178/index.html">Linux 3.10 kernel out</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>