<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis and visualization of real tabular data in R</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The material will be useful to those who master the R language as a tool for analyzing tabular data and want to see a cross-cutting example of the imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis and visualization of real tabular data in R</h1><div class="post__text post__text-html js-mediator-article">  The material will be useful to those who master the R language as a tool for analyzing tabular data and want to see a cross-cutting example of the implementation of the main processing steps. <br>  Below is a demonstration of loading data from csv files, parsing text strings with data cleansing elements, aggregating data by analytic measurements, and plotting diagrams. <br>  The example actively uses the functionality of the data.table, reshape2, stringdist, and ggplot2 packages. <br><br>  Information on the issued permits for carrying out passenger and baggage passenger taxi services in Moscow was taken as ‚Äúreal data‚Äù.  The data is provided for general use by the Department of Transport and the development of road and transport infrastructure of the city of Moscow.  Page data set <a href="http://data.mos.ru/datasets/655">data.mos.ru/datasets/655</a> <br>  The source data has the following format: <br><pre><code class="markdown hljs">ROWNUM;VEHICLE<span class="hljs-emphasis"><span class="hljs-emphasis">_NUM;FULL_</span></span>NAME;BLANK<span class="hljs-emphasis"><span class="hljs-emphasis">_NUM;VEHICLE_</span></span>BRAND_MODEL;INN;OGRN 1;"248197";" ¬´-¬ª";"017263";"FORD FOCUS";"7734653292";"1117746207578" 2;"249197";" ¬´-¬ª";"017264";"FORD FOCUS";"7734653292";"1117746207578" 3;"245197";" ¬´-¬ª";"017265";"FORD FOCUS";"7734653292";"1117746207578" <span class="hljs-code"><span class="hljs-code">```</span></span></code> </pre> <br><h5>  1. Download primary data </h5>  Data can be downloaded directly from the site.  In the boot process, we immediately rename the columns conveniently. <br><pre> <code class="python hljs">url &lt;- <span class="hljs-string"><span class="hljs-string">"http://data.mos.ru/datasets/download/655"</span></span> colnames = c(<span class="hljs-string"><span class="hljs-string">"RowNumber"</span></span>, <span class="hljs-string"><span class="hljs-string">"RegPlate"</span></span>, <span class="hljs-string"><span class="hljs-string">"LegalName"</span></span>, <span class="hljs-string"><span class="hljs-string">"DocNum"</span></span>, <span class="hljs-string"><span class="hljs-string">"Car"</span></span>, <span class="hljs-string"><span class="hljs-string">"INN"</span></span>, <span class="hljs-string"><span class="hljs-string">"OGRN"</span></span>, <span class="hljs-string"><span class="hljs-string">"Void"</span></span>) rawdata &lt;- read.table(url, header = TRUE, sep = <span class="hljs-string"><span class="hljs-string">";"</span></span>, colClasses = c(<span class="hljs-string"><span class="hljs-string">"numeric"</span></span>, rep(<span class="hljs-string"><span class="hljs-string">"character"</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), NA), col.names = colnames, strip.white = TRUE, blank.lines.skip = TRUE, stringsAsFactors = FALSE, encoding = <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>)</code> </pre>  Now you can begin to analyze and visualize ... <br><a name="habracut"></a><br><h5>  2. Data Conversion </h5>  Suppose that it is necessary to analyze the distribution of the number of cars registered as taxis, depending on the organizational form of the licensee and the make of the car.  The relevant data is not highlighted separately, but all the necessary information is contained in the fields FULL_NAME (renamed LegalName) and VEHICLE_BRAND_MODEL (Car). <br>  In the process of converting the original data is necessary <br><ul><li>  from the LegalName field to separate the organizational and legal form into a separate OrgType field; </li><li>  from the Car field, select the car brand in a separate CarBrand field; </li><li>  discard unused fields. </li></ul>  For simplicity, we assume that the first words of the LegalName and Car fields are, respectively, the organizational and legal form and the make of the car (below it will be clear what to do with the exceptions).  Unnecessary fields will be discarded automatically during the process of converting data.frame to data.table with explicit indication of the list of portable fields. <br><pre> <code class="python hljs">ptn &lt;- <span class="hljs-string"><span class="hljs-string">"^(.+?) (.+)$"</span></span> <span class="hljs-comment"><span class="hljs-comment"># regexp pattern to match first word dt &lt;- data.table(rawdata)[, list(RegPlate, LegalName, Car, OGRN, OrgType = gsub(ptn, "\\1" , toupper( LegalName )), CarBrand = gsub(ptn, "\\1", toupper( Car ))) ] rm(rawdata) # Clear some memory</span></span></code> </pre><br><h5>  3. First results </h5>  Check what organizational forms were selected from the data. <br><pre> <code class="python hljs">sort( table(dt$OrgType) )</code> </pre> <pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">##      ## 1 392 649 17118 17680</span></span></code> </pre>  The data is formed quite correctly: individual entrepreneurs are leading in terms of the number of licenses obtained (reducing the tax burden?), There are limited liability companies, open and closed joint-stock companies, and even one non-commercial partnership. <br>  In order to determine how many independent <i>licensees</i> (and not cars) have received a license, depending on the legal form, it is necessary to sum over the field that uniquely characterizes the legal entity (OGRN). <br><pre> <code class="python hljs">dt[, list( N = length( unique(OGRN) ) ), by = OrgType][order(N, decreasing = TRUE)]</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## OrgType N ## 1:  12352 ## 2:  563 ## 3:  14 ## 4:  6 ## 5:  1</span></span></code> </pre><br><h4>  Data cleansing </h4>  What brands of cars are used as a taxi in Moscow? <br>  There are quite a few car brands represented in the data set: 115, but are they really all unique?  For example, we deduce all marks starting with the letter ‚ÄúM‚Äù. <br><pre> <code class="python hljs">sort( unique( dt[grep(<span class="hljs-string"><span class="hljs-string">"^M.*"</span></span>, CarBrand), CarBrand]))</code> </pre> <pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## [1] "M214" "MASERATI" "MAZDA" ## [4] "MAZDA-" "MERCEDES" "MERCEDES-BENZ" ## [7] "MERCEDES-BENZ-" "MERCEDES-BENZ-S500" "MERCEDES-BENZC" ## [10] "MERCEDES-BENZE200K" "MERCEDES-BENZE220CDI" "MERCEDES-BNZ" ## [13] "MERCERDES-BENZ" "MERCRDES" "MERCRDES-BENZ" ## [16] "MERSEDES-" "MERSEDES-BENZ" "METROCAB" ## [19] "MG" "MINI" "MITSUBISHI"</span></span></code> </pre>  Unfortunately, a large number of brands of cars is largely due to errors in the data.  For example, the same brand - MERCEDES-BENZ - is found under different names.  Before analyzing the data must be cleared. <br>  The program basis for clearing textual information is the search function ‚Äúdistance between lines‚Äù.  For each pair of rows, they compute a metric characterizing the complexity of converting one string to another using letter operations.  The more similar the lines, the less operations are required.  Ideally, identical lines should have a distance equal to zero, and the most dissimilar ones should be one.  This is exactly how the Jaro-Winkler algorithm of the stringdist function of the same package works. <br>  Let's compare several lines, only we will count not distance, but similarity, 1-stringdist. <br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> - stringdist( c(<span class="hljs-string"><span class="hljs-string">"MERCEDES"</span></span>,<span class="hljs-string"><span class="hljs-string">"MERSEDES"</span></span>,<span class="hljs-string"><span class="hljs-string">"MAZDA"</span></span>,<span class="hljs-string"><span class="hljs-string">"RENAULT"</span></span>,<span class="hljs-string"><span class="hljs-string">"SAAB"</span></span>), <span class="hljs-string"><span class="hljs-string">"MERCEDES"</span></span>, method = <span class="hljs-string"><span class="hljs-string">"jw"</span></span>, p = <span class="hljs-number"><span class="hljs-number">0.1</span></span>)</code> </pre> <pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## [1] 1.0000 0.9417 0.5950 0.3452 0.0000</span></span></code> </pre>  At first glance, the task of data cleaning is solved simply: for each record, it suffices to choose the most similar value from the directory.  Unfortunately, this approach does not always work.  First, the directory may not be (as in the current case).  Secondly, some situations require manual data correction, even with an accurate reference guide.  For example, from the point of view of the method, three marks are equally suitable as an alternative to the incorrect value of ‚ÄúBAZ‚Äù: <br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> - stringdist(<span class="hljs-string"><span class="hljs-string">"BAZ"</span></span>, c(<span class="hljs-string"><span class="hljs-string">"VAZ"</span></span>, <span class="hljs-string"><span class="hljs-string">"UAZ"</span></span>, <span class="hljs-string"><span class="hljs-string">"ZAZ"</span></span>), method = <span class="hljs-string"><span class="hljs-string">"jw"</span></span>, p = <span class="hljs-number"><span class="hljs-number">0.1</span></span>)</code> </pre> <pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## [1] 0.7778 0.7778 0.7778</span></span></code> </pre>  Below, a semi-automatic correction method is used, which makes it possible to significantly ease the work of a data cleansing specialist by programmatically generating options for corrections with which the analyst can either agree or manually correct. <br>  It is assumed that in a large amount of data with a small number of errors, frequently occurring values ‚Äã‚Äãare correct, and rarely occurring errors.  Frequency values ‚Äã‚Äãare used as a weighting factor, proportionally increasing the proximity metric of rows.  So that frequently encountered brands of cars do not go ahead at the expense of quantity, and not similarity, only metrics of values ‚Äã‚Äãwith a degree of similarity above the threshold value <code>t</code> (about choosing <code>t</code> later) are taken into account.  For each possible value of the make of machine, a recommended reference value is thus determined from the same data set.  The ‚Äúbrand - proposed fix‚Äù pairs are displayed in a csv file.  After analysis and corrections, the corrected csv file is loaded and serves as a dictionary. <br>  We start by constructing a function that returns the best match on an existing dataset. <br><pre> <code class="python hljs">bestmatch.gen &lt;- function(wc, t = <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-comment"><span class="hljs-comment"># wc = counts of all base text words # t = threshold: only the words with similarity above threshold count bestmatch &lt;- function(a){ sim &lt;- 1 - stringdist( toupper(a), toupper( names(wc) ) , method = "jw", p = 0.1 ) # Compute weights and implicitly cut off everything below threshold weights &lt;- sim * wc * (sim &gt; t) # Return the one with maximum combined weight names( sort(weights, decr = TRUE)[1] ) } bestmatch }</span></span></code> </pre>  The threshold value <code>t</code> chosen empirically.  Here is an example of the function for the threshold parameter t = 0.7. <br><pre> <code class="python hljs"> bm07 &lt;- bestmatch.gen( table( dt$CarBrand), t = <span class="hljs-number"><span class="hljs-number">0.7</span></span> ) s &lt;- c(<span class="hljs-string"><span class="hljs-string">"FORD"</span></span>,<span class="hljs-string"><span class="hljs-string">"RENO"</span></span>,<span class="hljs-string"><span class="hljs-string">"MERS"</span></span>,<span class="hljs-string"><span class="hljs-string">"PEGO"</span></span>) sapply(s, bm07)</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## FORD RENO MERS PEGO ## "FORD" "RENAULT" "MERCEDES-BENZ" "PEUGEOT"</span></span></code> </pre>  At first glance, everything worked wonderfully.  However, rejoice too early.  Brand names with similar names that are well represented in the data set can ‚Äúpull over‚Äù other correct names. <br><pre> <code class="python hljs">s &lt;- c(<span class="hljs-string"><span class="hljs-string">"HONDA"</span></span>, <span class="hljs-string"><span class="hljs-string">"CHRYSLER"</span></span>, <span class="hljs-string"><span class="hljs-string">"VOLVO"</span></span>) sapply(s, bm07)</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## HONDA CHRYSLER VOLVO ## "HYUNDAI" "CHEVROLET" "VOLKSWAGEN"</span></span></code> </pre>  Let's try to increase the threshold value t. <br><pre> <code class="python hljs">bm09 &lt;- bestmatch.gen( table( dt$CarBrand), t = <span class="hljs-number"><span class="hljs-number">0.9</span></span> ) s &lt;- c(<span class="hljs-string"><span class="hljs-string">"HONDA"</span></span>,<span class="hljs-string"><span class="hljs-string">"CHRYSLER"</span></span>,<span class="hljs-string"><span class="hljs-string">"VOLVO"</span></span>) sapply(s, bm09)</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## HONDA CHRYSLER VOLVO ## "HONDA" "CHRYSLER" "VOLVO"</span></span></code> </pre>  Everything is good?  Nearly.  Too hard clipping of unlike strings causes the algorithm to consider some erroneous values ‚Äã‚Äãto be correct.  Such errors will have to be corrected manually. <br><pre> <code class="python hljs">s &lt;- c(<span class="hljs-string"><span class="hljs-string">"CEAT"</span></span>, <span class="hljs-string"><span class="hljs-string">"CVEVROLET"</span></span>) sapply(s, bm09)</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## CEAT CVEVROLET ## "CEAT" "CVEVROLET"</span></span></code> </pre>  Now everything is ready for the formation of a file of the dictionary of unique values ‚Äã‚Äãof the brands of cars.  Since the file will need to be edited by hand, it is convenient if it contains additional fields indicating whether the proposed replacement differs from the original value (this is not always obvious), how often the brand name is found, as well as a label that draws attention to the recording depending on some kind of statistical characteristics of the set.  In this case, we want to catch situations in which the algorithm offers infrequent (presumably erroneous) values ‚Äã‚Äãas correct. <br><pre> <code class="python hljs">ncb &lt;- table(dt$CarBrand) scb &lt;- names(ncb) <span class="hljs-comment"><span class="hljs-comment"># Source Car Brands acb &lt;- sapply(scb, bm09) # Auto-generated replacement cbdict_out &lt;- data.table(ncb)[,list( SourceName = scb, AutoName = acb, SourceFreq = as.numeric(ncb), AutoFreq = as.numeric( ncb[acb] ), Action = ordered( scb == acb, labels = c("CHANGE","KEEP")), DictName = acb )] # Add alert flag # Alert when suggested is a low-frequency dictionary word cbdict_out &lt;- cbdict_out[, Alert := ordered( AutoFreq &lt;= quantile(AutoFreq, probs = 0.05, na.rm = TRUE), labels = c("GOOD","ALERT")) ] write.table( cbdict_out[ order(SourceName), list( Alert, Action, SourceName, AutoName, SourceFreq, AutoFreq, DictName) ], "cbdict_out.txt", sep = ";", quote = TRUE, col.names = TRUE, row.name = FALSE, fileEncoding = "UTF-8")</span></span></code> </pre>  You need to check and edit the values ‚Äã‚Äãof the DictName field and save the file as ‚Äúcbdict_in.txt‚Äù for later download. <br>  The analyzed data set has features that you should pay attention to: <br><ul><li>  Some lines do not contain the brand of the car - empty or "NO", and some models are difficult to single-identifier: L1H1, M214;  manually change to UNKNOWN or similar pseudo-value; </li><li>  two spellings are equally used: MERCEDES and MERCEDES-BENZ, leaving one, MERCEDES-BENZ; </li><li>  There are two visually identical independent spellings of ZAZ (in the output there are two lines, and both of the algorithms suggest to save as true, Action = KEEP);  apparently, a letter with another UTF-8 code has crept in somewhere; </li><li>  Some car names do not contain the brand, but only the model: SAMAND (IRAN KHODRO) </li><li>  confusion with brands TAGAZ - VORTEX and JAC;  for simplicity, it is proposed to assign (albeit not quite correctly) the general name TAGAZ to vehicles whose brands were defined as TAGAZ, A21, SUV, SUVT11, VORTEX, JAC. </li></ul>  In addition to the features of the data, there are limitations of the algorithm that need to be corrected manually. <ul><li>  the algorithm suggests some erroneous names as correct alternatives: CEAT, CVEVROLET; </li><li>  stamps consisting of two words are reduced to one: ALFA (ALFA ROMEO), GREAT (GREAT WALL), IRAN (IRAN KHODRO), LAND (LAND ROVER). </li></ul>  The edited data is loaded from the <a href="https://raw.githubusercontent.com/avidclam/mostaxiR/master/cbdict_in.txt">cbdict_in.txt</a> file. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( file.exists(<span class="hljs-string"><span class="hljs-string">"cbdict_in.txt"</span></span>)) url &lt;- <span class="hljs-string"><span class="hljs-string">"cbdict_in.txt"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> url &lt;- <span class="hljs-string"><span class="hljs-string">"cbdict_out.txt"</span></span> cbdict_in &lt;- read.table( url, header = TRUE, sep = <span class="hljs-string"><span class="hljs-string">";"</span></span>, colClasses = c( rep(<span class="hljs-string"><span class="hljs-string">"character"</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-string"><span class="hljs-string">"numeric"</span></span>, <span class="hljs-string"><span class="hljs-string">"numeric"</span></span>, <span class="hljs-string"><span class="hljs-string">"character"</span></span>), encoding = <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>) cbdict &lt;- cbdict_in$DictName names(cbdict) &lt;- cbdict_in$SourceName</code> </pre>  And correct the values ‚Äã‚Äãof the brands of cars in the data table. <br><pre> <code class="python hljs">dt[, CarBrand := cbdict[CarBrand]] dt[<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>.na(CarBrand), CarBrand := <span class="hljs-string"><span class="hljs-string">"UNKNOWN"</span></span>]</code> </pre>  After cleaning the unique values ‚Äã‚Äãof the brands of cars was almost doubled <br><pre> <code class="python hljs">length( unique(dt$CarBrand) )</code> </pre> <pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## [1] 72</span></span></code> </pre><br><h4>  Answers to analytical questions </h4><h5>  1. Top 10 organizations </h5>  We define the 10 largest taxi companies.  In this case, it is necessary to build a rating for one dimension - OGRN. <br><pre> <code class="python hljs">st &lt;- dt[, list( NumCars = length(RegPlate)), by = list(OGRN, LegalName) ] head( st[order( NumCars, decreasing = TRUE)], <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## OGRN LegalName NumCars ## 1: 1137746197104  ¬´¬ª 866 ## 2: 1037727000893  ¬´-¬ª 751 ## 3: 1067746273198  ¬´ ¬ª 547 ## 4: 1037789018849  ¬´¬ª 541 ## 5: 1127746010700  ¬´-24 ¬ª 406 ## 6: 1057748223653  ¬´¬ª 349 ## 7: 5067746596297  ¬´¬ª 288 ## 8: 1027739272175  ¬´14 ¬ª 267 ## 9: 1137746133250  ¬´ ¬ª 255 ## 10: 5077746757688  ¬´¬ª 238</span></span></code> </pre>  Unfortunately, the dataset in question only stores legal information about licensees, not a trademark.  On the Internet, it is possible, by the name of the organization and the OGRN, to find under which brand the taxi fleet operates, but this process is not automatic and rather laborious.  The search results for the largest taxis are collected in the " <a href="">top10orgs.csv</a> " file. <br><pre> <code class="python hljs">top10orgs &lt;- data.table( read.table( <span class="hljs-string"><span class="hljs-string">"top10orgs.csv"</span></span>, header = TRUE, sep = <span class="hljs-string"><span class="hljs-string">";"</span></span>, colClasses = <span class="hljs-string"><span class="hljs-string">"character"</span></span>, encoding = <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>))</code> </pre>  We use the built-in data.table capabilities for the JOIN operation of two tables. <br><pre> <code class="python hljs">setkey(top10orgs,OGRN) setkey(st,OGRN) st[top10orgs][order(NumCars, decreasing = TRUE), list(OrgBrand, EasyPhone, NumCars)]</code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## OrgBrand EasyPhone NumCars ## 1:  781 81 82 866 ## 2: 956 956 8 956 751 ## 3: - 641 11 11 547 ## 4:   500 0 500 541 ## 5: 24 777 66 24 406 ## 6:   777 5 777 349 ## 7:    940 88 88 288 ## 8: 14  707 2 707 267 ## 9: Cabby 21 21 989 255 ## 10:  927 11 11 238</span></span></code> </pre><br><h5>  2. Three most popular cars, depending on the form of legal entity </h5>  What brands of cars are most popular, depending on the legal form of the licensee?  To answer this question, it is necessary to aggregate data in two dimensions - the make of the car and the orgoform. <br>  The process goes in three stages: <br><ol><li>  Calculation of the aggregated indicator (in this case, the number of machines on OGRN). </li><li>  Rank calculation </li><li>  Rank limitation (top 3), sorting, redistributing columns and outputting data. </li></ol><br><pre> <code class="python hljs">st &lt;- dt[, list(AGGR = length(RegPlate)), by = list(OrgType, CarBrand) ] st.r &lt;- st[, list(CarBrand, AGGR, r = ( <span class="hljs-number"><span class="hljs-number">1</span></span> + length(AGGR) - rank(AGGR, ties.method=<span class="hljs-string"><span class="hljs-string">"first"</span></span>))), by = list(OrgType)] <span class="hljs-comment"><span class="hljs-comment"># ranking by one dimension st.out &lt;- st.r[ r &lt;= 3 ][, list(r, OrgType, cval = paste0(CarBrand," (",AGGR,")"))] dcast(st.out, r ~ OrgType, value.var = "cval")[-1] # reshape data and hide r</span></span></code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">##      ## 1 FORD (212) CHEVROLET (2465) VOLVO (1) KIA (192) FORD (3297) ## 2 RENAULT (175) FORD (2238) &lt;NA&gt; CHEVROLET (115) RENAULT (2922) ## 3 HYUNDAI (122) RENAULT (1996) &lt;NA&gt; FORD (53) HYUNDAI (2812)</span></span></code> </pre><br><h4>  Visualization </h4><h5>  1. Displaying data in a pie chart </h5>  The pie (pie) chart, Pie Chart, is very popular in the business environment, but is subject to valid criticism of data analysis professionals.  However, it must be able to "cook." <br>  Suppose you want to display the distribution of the number of taxi licenses, by cars.  In order not to overload the chart, we will show only brands with a number of licenses of at least 1000. <br><pre> <code class="python hljs">st &lt;- dt[, list(N = length(RegPlate)), by = CarBrand ] <span class="hljs-comment"><span class="hljs-comment"># Summary table st &lt;- st[, CarBrand := reorder(CarBrand, N) ] piedata &lt;- rbind( st[ N &gt;= 1000 ][ order(N, decreasing=T) ], data.table( CarBrand = " ", N = sum( st[N &lt; 1000]$N) ) ) piedata</span></span></code> </pre><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section">## CarBrand N ## 1: FORD 5800 ## 2: RENAULT 5093 ## 3: HYUNDAI 4727 ## 4: CHEVROLET 4660 ## 5: KIA 2220 ## 6: SKODA 2073 ## 7: NISSAN 1321 ## 8: VOLKSWAGEN 1298 ## 9: TOYOTA 1075 ## 10: MERCEDES-BENZ 1039 ## 11:   6534</span></span></code> </pre>  To build a graph, I would like to fix just such a sequence of brands.  If this is not done, the automatic sorting will display ‚ÄúOther brands‚Äù from last place to first. <br><pre> <code class="python hljs">piedata &lt;- piedata[, CarBrand := factor(CarBrand, levels = CarBrand, ordered = TRUE)]</code> </pre>  To build a chart, use ggplot2. <br><pre> <code class="python hljs">pie &lt;- ggplot(piedata, aes( x = <span class="hljs-string"><span class="hljs-string">""</span></span>, y = N, fill = CarBrand)) + geom_bar(stat = <span class="hljs-string"><span class="hljs-string">"identity"</span></span>) + coord_polar(theta = <span class="hljs-string"><span class="hljs-string">"y"</span></span>) pie</code> </pre><img src="https://raw.githubusercontent.com/avidclam/mostaxiR/master/figure/pie_1.png" title="plot of chunk pie_1" alt="plot of chunk pie_1"><br>  The conclusion is already quite informative.  However, I would like to make a number of visual improvements: <br><ul><li>  remove gray background, borders, rotary axis, signatures and marks; </li><li>  choose a more distinguishable color scale and circle each ‚Äúpiece of cake‚Äù; </li><li>  next to each sector, put down the number of licenses corresponding to the brand; </li><li>  give the text a name to the legend. </li></ul>  The code below allows you to do all of the following.  To display the labels next to the sectors, we had to add a field with the calculation of the center point of the sector (as found by <a href="http://artelstatistikov.ru/r/krugovaya-diagramma-v-r-c-pomoshh-yu-ggplot-krasny-e-zelyony-e-zolotopogonny-e.html">artelstatistikov.ru</a> ). <br><pre> <code class="python hljs">piedata &lt;- piedata[, pos := cumsum(N) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>*N ] pie &lt;- ggplot(piedata, aes( x = <span class="hljs-string"><span class="hljs-string">""</span></span>, y = N, fill = CarBrand)) + geom_bar( color = <span class="hljs-string"><span class="hljs-string">"black"</span></span>, stat = <span class="hljs-string"><span class="hljs-string">"identity"</span></span>, width = <span class="hljs-number"><span class="hljs-number">0.5</span></span>) + geom_text( aes(label = N, y = pos), x = <span class="hljs-number"><span class="hljs-number">1.4</span></span>, color = <span class="hljs-string"><span class="hljs-string">"black"</span></span>, size = <span class="hljs-number"><span class="hljs-number">5</span></span>) + scale_fill_brewer(palette = <span class="hljs-string"><span class="hljs-string">"Paired"</span></span>, name = <span class="hljs-string"><span class="hljs-string">" "</span></span>) + coord_polar(theta = <span class="hljs-string"><span class="hljs-string">"y"</span></span>) + theme_bw() + theme ( panel.border = element_blank() , panel.grid.major = element_blank() , axis.ticks = element_blank() , axis.title.x = element_blank() , axis.title.y = element_blank() , axis.text.x = element_blank() , legend.title = element_text(face=<span class="hljs-string"><span class="hljs-string">"plain"</span></span>, size=<span class="hljs-number"><span class="hljs-number">16</span></span>) ) pie</code> </pre><img src="https://raw.githubusercontent.com/avidclam/mostaxiR/master/figure/pie_2.png" title="plot of chunk pie_2" alt="plot of chunk pie_2"><h5>  2. Bar graph </h5>  A more informative alternative to the circle is the bar chart, Bar Chart.  Besides the fact that the lengths of the bars are more convenient to compare than the lengths of the arcs or the areas of the sectors of a circle, the bar chart can additionally display, for example, the distribution of the number of licenses by organizational form. <br><pre> <code class="python hljs">st &lt;- dt[, list(N = length(RegPlate)), by = list(OrgType, CarBrand) ] <span class="hljs-comment"><span class="hljs-comment"># Summary table cbsort &lt;- st[, list( S = sum(N) ), keyby = CarBrand ] # Order by total number setkey(st, CarBrand) st &lt;- st[cbsort] # Join topcb &lt;- st[ S &gt;= 1000 ][ order(S) ] bottomcb &lt;- st[S &lt; 1000, list(CarBrand = " ", OrgType, N = sum(N)), by = OrgType] bottomcb &lt;- bottomcb[, list(CarBrand, OrgType, N, S = sum(N))] bardata &lt;- rbind( bottomcb, topcb) bardata &lt;- bardata[, CarBrand := factor(CarBrand, levels = unique(CarBrand), ordered=T)] # bar &lt;- ggplot(bardata, aes(x = CarBrand, weight = N, fill = OrgType)) + geom_bar() + coord_flip() + scale_fill_brewer(palette = "Spectral", name = "") + labs(list(y = " ", x = " ")) + theme_bw() bar</span></span></code> </pre><img src="https://raw.githubusercontent.com/avidclam/mostaxiR/master/figure/bar.png" title="plot of chunk bar" alt="plot of chunk bar"><br><h5>  3. Heat Map Chart </h5>  Suppose you want to get an answer to the question: "Owners of what brands of cars (among taxi drivers) are most susceptible to fashion for" beautiful "numbers?".  Beautiful in this case, we will consider numbers with the same numbers in triples: 111, 222, etc. <br>  The analysis is carried out on two analytical measurements - car brand and troika.  Indicator - the number of cars with a given combination of brand and troika.  For visualization of such a data set, a visual analogue of the table is well suited - a heat map diagram.  The more popular the triple, the more intense the color encodes the value of the cell. <br><pre> <code class="python hljs">ln &lt;- dt[grep( <span class="hljs-string"><span class="hljs-string">"^[^0-9]([0-9])\\1{2}.+$"</span></span> , RegPlate), list(CarBrand, LuckyNum = gsub(<span class="hljs-string"><span class="hljs-string">"^[^0-9]([0-9]{3}).+$"</span></span>,<span class="hljs-string"><span class="hljs-string">"\\1"</span></span>, RegPlate))] ln &lt;- ln[, list( N = .N), by = list(CarBrand, LuckyNum) ] ln &lt;- ln[, Luck := sum(N), by = list(CarBrand) ] <span class="hljs-comment"><span class="hljs-comment"># Total number of lucky regplates per car brand ln &lt;- ln[, CarBrand := reorder(CarBrand, Luck) ] # heatmap &lt;- ggplot(ln, aes(x = CarBrand, y = LuckyNum)) + geom_tile( aes(fill = as.character(N)), color = "black") + scale_fill_brewer(palette = "YlOrRd", name = " ¬´¬ª :") + labs(list(x = " ", y = " ")) + theme_bw() + theme ( panel.grid.major = element_blank() , axis.text.x = element_text(angle = 45, hjust = 1) , axis.title.y = element_text(vjust = 0.3) , legend.position = "top" , legend.title.align = 1 ) heatmap</span></span></code> </pre><img src="https://raw.githubusercontent.com/avidclam/mostaxiR/master/figure/lucky_numbers.png" title="plot of chunk lucky_numbers" alt="plot of chunk lucky_numbers"><br>  All diagrams use scientifically based color palettes of the <a href="http://colorbrewer2.org/">Color Brewer 2.0</a> project. </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/217963/">https://habr.com/ru/post/217963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217945/index.html">The book "Object Oriented Thinking"</a></li>
<li><a href="../217949/index.html">Testing font converters</a></li>
<li><a href="../217951/index.html">Festo has created a new type of wind generator.</a></li>
<li><a href="../217953/index.html">Will China UnionPay replace MasterCard and Visa for Russians?</a></li>
<li><a href="../217959/index.html">Mysterious game from IBM</a></li>
<li><a href="../217965/index.html">Eight tricks that marketers can borrow from Agile programmers</a></li>
<li><a href="../217967/index.html">Converting RAID 10 of 4 drives to RAID 6 of 8 drives on HP Proliant servers</a></li>
<li><a href="../217969/index.html">Loading historical data in SAP using LSMW - we write "macro"</a></li>
<li><a href="../217973/index.html">ZNC bouncer on RPi</a></li>
<li><a href="../217977/index.html">Know How: P-branding as improving the appearance of the site and the desired advertising format</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>