<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autonomous ftp-client with resume files</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share my experience in the development of an autonomous ftp client. 

 There is an ftp-server on which data periodically appears in the form...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autonomous ftp-client with resume files</h1><div class="post__text post__text-html js-mediator-article">  I want to share my experience in the development of an autonomous ftp client. <br><br>  There is an ftp-server on which data periodically appears in the form of graphic images and text files, their size varies from tens of kilobytes to a couple of gigabytes.  Internet access can be through a wire, or it can be through a GSM whistle or even via satellite, that is, stable and unstable, respectively.  In the second case, the probability of loss of connection due to weather conditions, geographical location, etc., increases dramatically. <br><br>  So, the client requirements are as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Poll ftp-server for new files and their subsequent download. </li><li>  In the case of a sudden stop of the download (whether the connection is broken, or the system on which my ftp-client stands), the download should continue as soon as possible. </li><li>  Restriction of download speed (this is due to the cost of traffic over GSM). </li></ol><br>  If my way of solving the problem is interesting, I ask under the cut! <br><a name="habracut"></a><br>  For convenience, you can split the entire article into key stages of the client's work, with code examples and a more detailed description of the subtleties of the work. <br><br><h3>  Formulation of the problem </h3><br>  Having thought it over, I decided to write a client that works as follows: <br><br><ol><li>  We knock on the server, we get a list of files. </li><li>  Look in your download history, if the file is not in the history, then add the file to the download queue. </li><li>  If the file for some reason could not be downloaded, it is sent to the end of the download queue. </li><li>  Successfully uploaded file is added to history. </li></ol><br>  And some features: <br><br><ul><li>  The history is stored in runtime and duplicated in the xml-file, where you can restore the history </li><li>  The client supports downloading multiple files simultaneously in different streams. </li></ul><br><h3>  Periodic polling of the server and getting a list of files </h3><br>  The decision to periodically poll the server comes to mind almost immediately - to start a timer, which will contain a method for obtaining a list of files.  However, the server has a slightly peculiar directory structure.  In short, there are two folders on the server - notify and files.  The <b>files</b> folder contains the data itself that you want to download, and all of them have unique names of the type <b>FILE_ID_xxx</b> , where <b>x</b> is any digit.  The <b>notify</b> folder contains xml-files with the description of files from the <b>files</b> folder, including their real name, date of placement on the server and size. <br><br>  After reading all the xml from the <b>notify</b> folder, I <b>create a</b> collection of a simple <i>FileItem</i> : <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FileItem</span></span> { [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"RemoteUri"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> RemoteUri; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"SavePath"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SavePath; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"Date"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Date; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"RefId"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> RefId; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"Name"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"Extention"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Extention; [XmlAttribute(AttributeName = <span class="hljs-string"><span class="hljs-string">"Size"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Size; }</code> </pre> <br>  And then, going over the collection, we check whether the file is present in the download history, and whether it is currently loading <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> df <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dataFiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FileHistory.FileExists(df) &amp;&amp; !client.AlreadyInProgress(df)) { client.DownloadFile(df); } }</code> </pre><br>  That's all.  Poll server and search for new files is over.  I will write further about who <i>FileHistory</i> and <i>client</i> are. <br><br><h3>  Upload files in multiple streams </h3><br>  The " <i>client</i> " in the code above is an instance of the <i>FTPClient</i> class, which only deals with downloading files from the server.  And in fact <i>FTPClient</i> is my FtpWebRequest wrapper. <br><br>  <i>FTPClient</i> has a thread-safe queue called a ‚Äúdownload queue‚Äù: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentQueue&lt;FileItem&gt; downloadQueue;</code> </pre><br>  So, what happens when you call the <i>DownloadFile</i> method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileItem file</span></span></span><span class="hljs-function">)</span></span> { downloadQueue.Enqueue(file); StartDownloadTask(); }</code> </pre><br>  Everything is quite simple - the file is added to the download queue, and after this the method that creates the task of downloading the file using the TPL is called.  Here's what it looks like: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDownloadTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentActiveDownloads &lt;= Settings.MaximumDownloadThreads) { FileItem file; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!downloadQueue.IsEmpty &amp;&amp; downloadQueue.TryDequeue(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> file)) { Task t; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(file.SavePath)) { FileInfo info = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInfo(file.SavePath); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentSize = info.Length; t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task(() =&gt; DownloadTask(file, currentSize)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task(() =&gt; DownloadTask(file, <span class="hljs-number"><span class="hljs-number">0</span></span>)); } t.ContinueWith(OnTaskComplete); t.Start(); Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentActiveDownloads); <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (inProgressLock) { inProgress.Add(file); } } }</code> </pre><br>  Speaking in Russian, first check how many tasks are already working on downloading a file, and if there is an opportunity to push another one.  Then we try to get the <i>FileItem</i> from the download queue if the queue is not empty.  Then we determine whether the file is already present locally or not.  A locally file may be present if the download is unexpectedly interrupted.  Everything that we managed to download remains on the disk.  So, in this case, we just start the download from the place where we stopped. <br><br>  The <i>OnTaskComplete</i> method that will be called upon completion of <i>DownloadTask</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTaskComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task t</span></span></span><span class="hljs-function">)</span></span> { Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentActiveDownloads); StartDownloadTask(); }</code> </pre><br>  That is, reduce the active download count, and try to start a new download task.  That is, it turns out that a new download task will be created when a new file is added to the download queue and at the end of the current download task. <br><br>  Now the method directly involved in downloading the file from the server: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileItem file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       .  ,      - ,             Thread.Sleep(10 * 1000); Log.Info(string.Format("  {0}", file.Name)); try { if (offset == file.Size) { Log.Info(string.Format(" {0}   .", file.Name)); FileHistory.AddToDownloadHistory(file); return; } using (var readStream = GetResponseStreamFromServer(file.RemoteUri, WebRequestMethods.Ftp.DownloadFile, offset)) { using (var writeStream = new FileStream(file.SavePath, FileMode.Append, FileAccess.Write)) { var bufferSize = 1024; var buffer = new byte[bufferSize]; int second = 1000; int timePassed = 0; var stopWatch = new Stopwatch(); var readCount = readStream.Read(buffer, 0, bufferSize); int downloadedBytes = readCount; while(readCount &gt; 0) { //           stopWatch.Start(); writeStream.Write(buffer, 0, readCount); readCount = readStream.Read(buffer, 0, bufferSize); stopWatch.Stop(); //    (0    ) if (Settings.MaximumDownloadSpeed &gt; 0) { var downloadLimit = (Settings.MaximumDownloadSpeed * 1024 / 8) / currentActiveDownloads; downloadedBytes += readCount; timePassed += (int)stopWatch.ElapsedMilliseconds; if (downloadedBytes &gt;= downloadLimit) { var pause = second - timePassed; if (pause &gt; 0) Thread.Sleep(pause); timePassed = 0; downloadedBytes = 0; stopWatch.Reset(); } if (timePassed &gt; second) { stopWatch.Reset(); timePassed = 0; downloadedBytes = 0; } } } } } lock (inProgressLock) { inProgress.Remove(file); } FileHistory.AddToDownloadHistory(file); Log.Info(string.Format("  - {0}", file.Name)); Interlocked.Add(ref currentLoadedSize, -file.Size); } catch (WebException e) { Log.Error(e); downloadQueue.Enqueue(file); } catch (Exception e) { Log.Error(e); } }</span></span></code> </pre><br>  And the method that generates a request to the server and returns the answer: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Stream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetResponseStreamFromServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uri, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> method, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = (FtpWebRequest)WebRequest.Create(uri); request.UseBinary = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; request.Credentials = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NetworkCredential(Settings.Login, Settings.Password); request.Method = method; request.Proxy = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; request.KeepAlive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; request.ContentOffset = offset; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = request.GetResponse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.GetResponseStream(); }</code> </pre><br>  That is, to start reading the stream not from the beginning, the string is used when forming the query: <br><br><pre> <code class="cs hljs">request.ContentOffset = offset;</code> </pre><br>  And the speed limit works in the following way: first of all we calculate <i>downloadLimit</i> , how many bytes can the current stream download.  The total speed limit and the number of active download threads are taken into account.  Then we read a stream of 1024 bytes.  Noticed how long it took ( <i>TimePassed</i> ).  The total number of bytes read is recorded in <i>downloadedBytes</i> . <br><br>  If the limit is exceeded, we pause the flow for the remaining time until the end of the second: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pause = second - timePassed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pause &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) Thread.Sleep(pause);</code> </pre><br>  After a second the counters are reset. <br><br>  And in the case of <i>WebExeption, the</i> file is added to the download queue again.  And in the history of the file will fall only after successful completion. <br><br><h3>  Download history </h3><br>  Storing the download history in a file is useful in case the application suddenly restarts and the runtime history is lost. <br><br>  Inside the class <i>FileHistory</i> has a collection that contains <i>FileItem</i> , which we have already successfully downloaded: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;FileItem&gt; downloadHistory;</code> </pre><br>  Adding a file is very simple - we add the file to the collection and immediately write the changes to xml: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddToDownloadHistory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileItem file</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (historyLock) { XmlSerializer serializer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlSerializer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(List&lt;FileItem&gt;)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writer = GetXml()) { downloadHistory.Add(file); serializer.Serialize(writer, downloadHistory); } } }</code> </pre><br>  And this is what happens when we want to check for a file in history: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FileExists</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FileItem file</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (historyLock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (downloadHistory.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!TryRestoreHistoryFromXml()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> downloadHistory.Any(f =&gt; f.RefId == file.RefId); } }</code> </pre><br>  Let me explain - here is the verification method.  And the entries in our collection are zero.  Probably, the application fell, and the story was lost.  In this case, try to restore the history of the xml.  If this fails (the file is missing or damaged) - we believe that we have not downloaded this file yet. <br><br><h3>  Completion </h3><br>  I hope that this article will help those who also have to write their ftp-client for the first time, like me.  I do not pretend that the solution is perfect.  And this is my first experience of writing articles on Habr, so I am open to criticism and comments. </div><p>Source: <a href="https://habr.com/ru/post/282600/">https://habr.com/ru/post/282600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282584/index.html">Use Webpack instead of Sprockets in Ruby on Rails</a></li>
<li><a href="../282586/index.html">Non-visual methods to protect the site from spam. Part 1. Statistics</a></li>
<li><a href="../282588/index.html">What are they scolding Golang for and how to fight it?</a></li>
<li><a href="../282590/index.html">Rendering drops with transparency and reflections on OpenGL</a></li>
<li><a href="../282592/index.html">Perl plugin version 1.5 released for IntelliJ IDEA</a></li>
<li><a href="../282602/index.html">(Why) Mail.Ru Mail includes strict DMARC</a></li>
<li><a href="../282604/index.html">Blast Wave in Unity3D (displacement shader)</a></li>
<li><a href="../282606/index.html">Spring Go to Badoo</a></li>
<li><a href="../282608/index.html">Acronis Man: First lecture at MIPT (with online broadcast)</a></li>
<li><a href="../282610/index.html">Haordic Organization Visa (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>