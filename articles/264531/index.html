<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ASR and TTS technologies for an application programmer: theoretical minimum</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the past few years, voice interfaces surround us more and more tightly. What was once shown only in films about the distant future t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ASR and TTS technologies for an application programmer: theoretical minimum</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  In the past few years, voice interfaces surround us more and more tightly.  What was once shown only in films about the distant future turned out to be quite real.  It has already come down to embedding engines for synthesis (Text To Speech - TTS) and recognition (Automatic Speech Recognition - ASR) of speech into mobile phones.  Moreover, quite accessible APIs have appeared for embedding ASR and TTS into applications. <br><br>  Nowadays, anyone can create programs with a voice interface (who did not buy money for the engine).  Our review will focus on the use of existing engines (for example, Nuance) and not the creation of those.  There will also be given general information necessary for every programmer who first encounters speech interfaces.  The article may also be useful to project managers who are trying to assess the feasibility of integrating voice technology into their products. <br>  So, let's begin‚Ä¶ <br><br>  But for the seed - anecdote: <br>  The lesson of the Russian language in the Georgian school. <br>  The teacher says: ‚ÄúChildren, remember: the words of salt, bean and noodles are written with a soft sign, and the words forks, brook, and a plate - without a soft sign.  Children, remember, because it is impossible to understand! ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Previously, this joke seemed funny to me.  Now - rather vital.  Why is that?  Now I will try to explain ... <br><a name="habracut"></a><br><h3>  1. Phonemes </h3><br>  Speaking about speech (already funny), we first of all have to deal with the concept of phonemes.  Simply put - a phoneme is a separate sound that can be pronounced and recognized by a person.  But such a definition is of course not enough, for you can utter a lot of sounds, and the set of phonemes in languages ‚Äã‚Äãis limited.  I want to have a stricter definition.  So - you need to go to the bow to the philologists.  Alas, philologists themselves can not agree on what it is (yes, they don‚Äôt really need it), but they have several approaches.  One links phonemes with meaning.  For example, the English Wiki tells us "The smallest contrastive linguistic unit."  others - with features of perception.  So, our compatriot <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D1%2583%25D0%25B1%25D0%25B5%25D1%2586%25D0%25BA%25D0%25BE%25D0%25B9,_%25D0%259D%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B0%25D0%25B9_%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B3%25D0%25B5%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">N. Trubetskoy</a> wrote ‚ÄúPhonological units that, from the point of view of a given language, cannot be decomposed into shorter phonological units following each other, we call phonemes‚Äù.  Both in that and in another definition there are important clarifications for us.  On the one hand, a change in the phoneme can (but is not required to) change the meaning of a word.  So, "code" and "cat" - will be perceived as two different words.  On the other hand, you can pronounce the ‚Äúmuseum‚Äù or ‚Äúmusei‚Äù and the meaning will not change.  Is that your interlocutors will be able to somehow classify your accent.  The indivisibility of phonemes is also important.  But, as Trubetskoy correctly noted, it may depend on the language.  Where a person of the same nationality hears one sound, someone else can hear two following each other.  It would be desirable, however, to have phonetic invariants suitable for all languages, and not just any one. <br><br><h3>  2. Phonetic alphabet </h3><br>  To somehow settle the definitions back in 1888, the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25B4%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BB%25D1%2584%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2582">international phonetic alphabet</a> (IPA) was created.  This alphabet is good because it <b>does not depend</b> on a particular language.  Those.  calculated as if on a "superman" who can pronounce and recognize the sounds of almost all existing living (and even dead) languages.  The IPA alphabet gradually changed up to the present day (2005).  Since it was created mainly in the pre-computer era, philologists drew symbols denoting sounds as God would put on the soul.  They certainly somehow focused on the Latin alphabet, but very, very conditional.  As a result, the IPA characters are now in Unicode, but typing them from the keyboard is not easy.  Here the reader may ask - why do I need an IPA for ordinary people?  Where can I see at least examples of phonetically written words?  My answer is that the simple IPA is not necessary to know.  But, with all this, you can see it very easily - in many Wiki articles on geographical names, surnames and proper names.  Knowing the IPA, you can always verify the correctness of the pronunciation of a particular name in a language you do not know.  For example, want to say "Paris" as a Frenchman?  Here you are - [pa Åi]. <br><br><h3>  3. Phonetic transcription </h3><br>  An attentive user of a Wiki can really notice that sometimes strange phonetic icons stand inside square brackets - [m…êÀàskva], and sometimes - inside slashes (slashes) - / Ààl ånd…ôn /.  What is the difference?  In square brackets is recorded so-called.  narrow, that is to say ‚Äúnarrow‚Äù transcription.  In Russian literature, it is called phonetic.  In slashes, the word is broad;  "Broad" or phonemic transcription.  The practical meaning is as follows: phonetic transcription gives an extremely precise pronunciation, which is in some sense ideal and independent of the speaker's accent.  In other words - having a phonetic transcription, we can say "Cockney will pronounce this word like that."  Phonemic transcription allows variations.  Thus, Australian and Canadian English pronounced sound with the same recording in // may be different.  In truth, even a narrow transcription is still not straightforward.  Those.  pretty far from waw-file.  Male, female and children's voices will pronounce the same phoneme in different ways.  Also not taken into account the overall speed of speech, its volume and basic pitch of the voice.  Actually, these differences make the task of speech generation and recognition non-trivial.  Hereinafter, I will always use IPA in narrow transcription, unless otherwise specified.  In this case, I will try to reduce the direct use of IPA to a reasonable minimum. <br><br><h3>  4. Languages </h3><br>  Each living natural language has its own set of phonemes.  More precisely, this is a property of speech, because generally speaking, one can know a language without having the ability to pronounce words (how deaf-dumb people learn the language).  The phonetic composition of languages ‚Äã‚Äãis different, about the same way as alphabets are different.  Accordingly, the phonetic complexity of the language varies.  It consists of two components.  First, the complexity of the transformation of graphemes into phonemes (we remember that the English write ‚ÄúManchester‚Äù and read ‚ÄúLiverpool‚Äù) and the difficulty of pronouncing the sounds (phonemes) themselves secondly.  How many phonemes does a language usually contain?  A few dozens.  Since childhood, we have been taught that Russian pronunciation is as simple as three kopecks, and everything reads as spelled, unlike European languages.  Of course we were deceived!  If you read the words literally as they are written, they will understand you, but not always correctly.  But they really won't count Russians.  In addition, it comes in such a terrible thing for a European as stress.  Instead of putting it at the beginning (like the British) or at the end (like the French), it walks around the whole word like a god for the soul, changing the meaning.  D <b>o</b> rogi and dori gi are two different words, and even parts of speech.  How many phonemes in Russian?  Nuance has 54 of them.  For comparison, in English there are only 45 phonemes, and in French even less - 34. No wonder the aristocrats considered it easy to learn the language a couple of centuries ago!  Of course - Russian is not the most difficult language in Europe, but one of (note, I am still silent about grammar). <br><br><h3>  5. X-SAMPA and LH + </h3><br>  Since people wanted to introduce phonetic transcriptions from the keyboard for a long time, even before the widespread use of Unicode, notations were developed that allow them to get along with the characters of the ASCII table.  The two most common of these are <a href="https://en.wikipedia.org/wiki/X-SAMPA">X-SAMPA</a> - the work of Professor John Wells, and LH + - the internal format of <a href="https://en.wikipedia.org/wiki/Lernout_%2526_Hauspie">Lernout &amp; Hauspie</a> , the technologies of which were later purchased by Nuance Communications.  There is a rather significant difference between X-SAMPA and LH +.  Formally, X-SAMPA is just a notation, which allows for certain rules to write the same IPA phonemes, only using ASCII.  Other business LH +.  In a sense, LH + is an analogue of broad (phonemic) transcription.  The fact is that for each language, the same LH + symbol can denote different phonemes IPA.  On the one hand, this is good, because  the record is shortened, and there is no need to encode all possible IPA characters, on the other hand, ambiguity arises.  And each time to broadcast to IPA you need to keep in front of a correspondence table.  However, the saddest thing is that the string recorded in LH + can correctly pronounce only ‚Äúvoice‚Äù for a specific language. <br><br><h3>  6. Voices </h3><br>  No, it will not be about the voices that programmers often hear in their heads, who have written too much bad code in the past.  Rather, those who are so often looking for on trackers and file dumps owners of navigators and other mobile devices.  These voices have even names.  The words "Milena" and "Katerina" say a lot to the experienced user of voice interfaces.  What is it?  Roughly speaking, these are data sets prepared by various companies (such as Nuance) that allow a computer to convert phonemes into sound.  Voices are feminine and masculine, and cost a lot of money.  Depending on the platform and the developer company, you may be required to have 2-5 thousand dollars per voice.  Thus, if you want to create an interface in at least 5 of the most common European languages, then the bill can go to tens of thousands.  Of course, we are talking about the software interface.  So the voice is language specific.  From here also occurs its binding to phonetic transcription.  It is not easy to understand in the first place, but the anecdote at the beginning of the article is true.  People with one native language are usually <b>simply not able to</b> pronounce phonemes of another that are not in their native language.  And, even worse, not only individual phonemes, but also certain combinations of them.  So, if in your language a word never ends with a soft "l", then we will not be able to pronounce it (at first). <br><br>  The same with voices.  The voice is sharpened to pronounce only those phonemes that are available in the language.  Moreover, in a particular dialect of the language.  Those.  Voices for Canadian French and French French will not only differ in sound, but also have a different set of pronounced phonemes.  This, by the way, is convenient for manufacturers of ASR and TTS engines, since  Each language can be sold for some money.  On the other hand - you can understand them.  Voice creation is quite laborious and costly in terms of money.  Perhaps this is why there is still no wider market for open source solutions for most languages. <br><br>  It would seem that nothing prevents to create a ‚Äúuniversal‚Äù voice that will be able to pronounce all the IPA phonemes, and thus will solve the problem of multilingual interfaces.  But for some reason nobody does it.  Most likely, this is impossible.  Those.  he can and will speak, but every native speaker will be dissatisfied with the insufficient ‚Äúnaturalness‚Äù of pronunciation.  It will sound like Russian in the mouth of a little Englishman practicing or English in the mouth of a Frenchman.  So, if you want multilingualism - get ready to fork out. <br><br><h3>  7. Example of using TTS API </h3><br>  To give the reader an idea of ‚Äã‚Äãhow the process of working with TTS looks at the lower level (using C ++), I will give an example of speech synthesis based on the Nuance engine.  Of course, this is an incomplete example, it cannot be not only launched but even compiled, but it gives an idea of ‚Äã‚Äãthe process.  All functions except TTS_Speak () are needed as a ‚Äúbinding‚Äù for it. <br><br>  TTS_Initialize () - used to initialize the engine <br>  TTS_Cleanup () - for deinitialization <br>  TTS_SelectLanguage - selects the language and adjusts the recognition parameters. <br><br>  TTS_Speak () - actually generates sound samples <br>  TTS_Callback () - called when the next portion of audio data is ready to play as well as in the case of other events. <br><br><div class="spoiler">  <b class="spoiler_title">TTS and strapping to it</b> <div class="spoiler_text"><pre><code class="hljs pgsql">static const NUAN_TCHAR * _dataPathList[] = { __TEXT("\\lang\\"), __TEXT("\\tts\\"), }; static VPLATFORM_RESOURCES _stResources = { VPLATFORM_CURRENT_VERSION, sizeof(_dataPathList)/sizeof(_dataPathList[<span class="hljs-number"><span class="hljs-number">0</span></span>]), (NUAN_TCHAR **)&amp;_dataPathList[<span class="hljs-number"><span class="hljs-number">0</span></span>], }; static VAUTO_INSTALL _stInstall = {VAUTO_CURRENT_VERSION}; static VAUTO_HSPEECH _hSpeech = {<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; static VAUTO_HINSTANCE _hTtsInst = {<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; static WaveOut * _waveOut = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static WaveOutBuf * _curBuffer = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static <span class="hljs-type"><span class="hljs-type">int</span></span> _volume = <span class="hljs-number"><span class="hljs-number">100</span></span>; static <span class="hljs-type"><span class="hljs-type">int</span></span> _speechRate = <span class="hljs-number"><span class="hljs-number">0</span></span>; // use <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> speech rate static NUAN_ERROR _Callback (VAUTO_HINSTANCE hTtsInst, VAUTO_OUTDEV_HINSTANCE hOutDevInst, VAUTO_CALLBACKMSG * pcbMessage, VAUTO_USERDATA UserData); static const TCHAR * _szLangTLW = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; static VAUTO_PARAMID _paramID[] = { VAUTO_PARAM_SPEECHRATE, VAUTO_PARAM_VOLUME }; static NUAN_ERROR _TTS_GetFrequency(VAUTO_HINSTANCE hTtsInst, short *pFreq) { NUAN_ERROR Error = NUAN_OK; VAUTO_PARAM TtsParam; <span class="hljs-comment"><span class="hljs-comment">/*-- get frequency used by current voicefont --*/</span></span> TtsParam.eID = VAUTO_PARAM_FREQUENCY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUAN_OK != (Error = vauto_ttsGetParamList (hTtsInst, &amp;TtsParam, <span class="hljs-number"><span class="hljs-number">1</span></span>)) ) { ErrorV(_T("vauto_ttsGetParamList rc=0x%1!x!\n"), Error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error; } switch(TtsParam.uValue.usValue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_8KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">8000</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_11KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">11025</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_16KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">16000</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_FREQ_22KHZ: *pFreq = <span class="hljs-number"><span class="hljs-number">22050</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: break; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_OK; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_SelectLanguage(<span class="hljs-type"><span class="hljs-type">int</span></span> langId) { NUAN_ERROR nrc; VAUTO_LANGUAGE arrLanguages[<span class="hljs-number"><span class="hljs-number">16</span></span>]; VAUTO_VOICEINFO arrVoices[<span class="hljs-number"><span class="hljs-number">4</span></span>]; VAUTO_SPEECHDBINFO arrSpeechDB[<span class="hljs-number"><span class="hljs-number">4</span></span>]; NUAN_U16 nLanguageCount, nVoiceCount, nSpeechDBCount; nLanguageCount = sizeof(arrLanguages)/sizeof(arrLanguages[<span class="hljs-number"><span class="hljs-number">0</span></span>]); nVoiceCount = sizeof(arrVoices) /sizeof(arrVoices[<span class="hljs-number"><span class="hljs-number">0</span></span>]); nSpeechDBCount = sizeof(arrSpeechDB)/sizeof(arrSpeechDB[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-type"><span class="hljs-type">int</span></span> nVoice = <span class="hljs-number"><span class="hljs-number">0</span></span>, nSpeechDB = <span class="hljs-number"><span class="hljs-number">0</span></span>; nrc = vauto_ttsGetLanguageList( _hSpeech, &amp;arrLanguages[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;nLanguageCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ TTS_ErrorV(_T("vauto_ttsGetLanguageList rc=0x%1!x!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nLanguageCount == <span class="hljs-number"><span class="hljs-number">0</span></span> || nLanguageCount&lt;=langId){ TTS_Error(_T("vauto_ttsGetLanguageList: No proper languages found.\n")); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } _szLangTLW = arrLanguages[langId].szLanguageTLW; NUAN_TCHAR* szLanguage = arrLanguages[langId].szLanguage; nVoice = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> first voice; NUAN_TCHAR* szVoiceName = arrVoices[nVoice].szVoiceName; nSpeechDB = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> first speech DB { VAUTO_PARAM stTtsParam[<span class="hljs-number"><span class="hljs-number">7</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> stTtsParam[cnt].eID = VAUTO_PARAM_LANGUAGE; _tcscpy(stTtsParam[cnt].uValue.szStringValue, szLanguage); cnt++; // voice stTtsParam[cnt].eID = VAUTO_PARAM_VOICE; _tcscpy(stTtsParam[cnt].uValue.szStringValue, szVoiceName); cnt++; // speechbase parameter - frequency stTtsParam[cnt].eID = VAUTO_PARAM_FREQUENCY; stTtsParam[cnt].uValue.usValue = arrSpeechDB[nSpeechDB].u16Freq; cnt++; // speechbase parameter - reduction <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stTtsParam[cnt].eID = VAUTO_PARAM_VOICE_MODEL; _tcscpy(stTtsParam[cnt].uValue.szStringValue, arrSpeechDB[nSpeechDB].szVoiceModel); cnt++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_speechRate) { // Speech rate stTtsParam[cnt].eID = VAUTO_PARAM_SPEECHRATE; stTtsParam[cnt].uValue.usValue = _speechRate; cnt++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_volume) { // Speech volume stTtsParam[cnt].eID = VAUTO_PARAM_VOLUME; stTtsParam[cnt].uValue.usValue = _volume; cnt++; } nrc = vauto_ttsSetParamList(_hTtsInst, &amp;stTtsParam[<span class="hljs-number"><span class="hljs-number">0</span></span>], cnt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsSetParamList rc=0x%1!x!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_Initialize(<span class="hljs-type"><span class="hljs-type">int</span></span> defLanguageId) { NUAN_ERROR nrc; nrc = vplatform_GetInterfaces(&amp;_stInstall, &amp;_stResources); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ Error(_T("vplatform_GetInterfaces rc=%1!d!\n"), nrc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } nrc = vauto_ttsInitialize(&amp;_stInstall, &amp;_hSpeech); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ Error(_T("vauto_ttsInitialize rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } nrc = vauto_ttsOpen(_hSpeech, _stInstall.hHeap, _stInstall.hLog, &amp;_hTtsInst, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsOpen rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // Ok, <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!TTS_SelectLanguage(defLanguageId)){ TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // init Wave <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> device { short freq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NUAN_OK != _TTS_GetFrequency(_hTtsInst, &amp;freq)) { TTS_ErrorV(_T("_TTS_GetFrequency rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } _waveOut = WaveOut_Open(freq, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_waveOut == <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>){ TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } // init TTS output { VAUTO_OUTDEVINFO stOutDevInfo; stOutDevInfo.hOutDevInstance = _waveOut; stOutDevInfo.pfOutNotify = TTS_Callback; // <span class="hljs-keyword"><span class="hljs-keyword">Notify</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> callback! nrc = vauto_ttsSetOutDevice(_hTtsInst, &amp;stOutDevInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nrc != NUAN_OK){ ErrorV(_T("vauto_ttsSetOutDevice rc=0x%1!x!\n"), nrc); TTS_Cleanup(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } // OK TTS engine initialized <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> TTS_Cleanup(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hTtsInst.pHandleData){ vauto_ttsStop(_hTtsInst); vauto_ttsClose(_hTtsInst); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hSpeech.pHandleData){ vauto_ttsUnInitialize(_hSpeech); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_waveOut){ WaveOut_Close(_waveOut); _waveOut = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; } vplatform_ReleaseInterfaces(&amp;_stInstall); memset(&amp;_stInstall, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(_stInstall)); _stInstall.fmtVersion = VAUTO_CURRENT_VERSION; } <span class="hljs-type"><span class="hljs-type">int</span></span> TTS_Speak(const TCHAR * const message, <span class="hljs-type"><span class="hljs-type">int</span></span> length) { VAUTO_INTEXT stText; stText.eTextFormat = VAUTO_NORM_TEXT; stText.szInText = (<span class="hljs-type"><span class="hljs-type">void</span></span>*) message; stText.ulTextLength = length * sizeof(NUAN_TCHAR); TraceV(_T("TTS_Speak: %1\n"), message); NUAN_ERROR rc = vauto_ttsProcessText2Speech(_hTtsInst, &amp;stText); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == NUAN_OK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == NUAN_E_TTS_USERSTOP) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } ErrorV(_T("vauto_ttsProcessText2Speech rc=0x%1!x!\n"), rc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static NUAN_ERROR TTS_Callback (VAUTO_HINSTANCE hTtsInst, VAUTO_OUTDEV_HINSTANCE hOutDevInst, VAUTO_CALLBACKMSG * pcbMessage, VAUTO_USERDATA UserData) { VAUTO_OUTDATA * outData; switch(pcbMessage-&gt;eMessage){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_BEGINPROCESS: WaveOut_Start(_waveOut); break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_ENDPROCESS: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_STOP: break; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_OUTBUFREQ: outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; memset(outData, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof(VAUTO_OUTDATA)); { WaveOutBuf * buf = WaveOut_GetBuffer(_waveOut); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buf){ VAUTO_OUTDATA * outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; outData-&gt;eAudioFormat = VAUTO_16LINEAR; outData-&gt;pOutPcmBuf = WaveOutBuf_Data(buf); outData-&gt;ulPcmBufLen = WaveOutBuf_Size(buf); _curBuffer = buf; break; } TTS_Trace(_T("VAUTO_MSG_OUTBUFREQ: processing was stopped\n")); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_E_TTS_USERSTOP; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> VAUTO_MSG_OUTBUFDONE: outData = (VAUTO_OUTDATA *)pcbMessage-&gt;pParam; WaveOutBuf_SetSize(_curBuffer, outData-&gt;ulPcmBufLen); WaveOut_PutBuffer(_waveOut, _curBuffer); _curBuffer = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; break; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: break; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUAN_OK; }</code> </pre> <br></div></div><br><br>  As the reader may notice, the code is rather cumbersome, and simple (seemingly) functionality requires a large number of presets.  Alas, this is the reverse side of the flexibility of the engine.  Of course, the API of other engines and for other languages ‚Äã‚Äãcan be significantly simpler and more compact. <br><br><h3>  8. Again phonemes </h3><br>  Looking at the API, the reader may ask - why do we need phonemes at all if TTS (Text-To-Speech) is able to directly convert text to speech.  He knows how, but there is one "but."  <b>Familiar</b> words are well converted into speech.  The situation is much worse with the words "unfamiliar".  Such as toponyms, proper names, etc.  This is particularly well illustrated by the example of multinational countries, such as, for example, Russia.  The names of cities and villages on the territory of one ever-sixth part of the land were given by different people, in different languages ‚Äã‚Äãand at different times.  The need to write them in Russian letters played a bad joke with the national languages.  The phonemes of Tatars, Nenets, Abkhazians, Kazakhs, Yakuts, Buryats were crammed into the Procrustean bed of the Russian language.  In which, although there are many phonemes, it is still not enough to convey all the languages ‚Äã‚Äãof the peoples of the former Soviet Union.  But then it‚Äôs even worse - if the phonetic record is somehow similar to the original, then reading the TTS engine for the name of the type ‚ÄúKyuchuk-Kaynardzhi‚Äù does not cause anything but laughter. <br><br>  However, it is naive to think that this is only a problem of the Russian language.  Similar difficulties exist in more homogeneous countries.  Thus, in French, the letters p, b, d, t, s at the end of words are usually not read.  But if we take toponyms, then local traditions come into force.  So, in the word Paris 's', in the end, it is not really pronounced, but in the word 'Valluris' - the opposite.  The difference is that Paris is located in the north of France, and Vallauris - in the south, in Provence, where the rules of pronunciation are somewhat different.  That is why it is still desirable to have phonetic transcriptions for words.  Usually cards come with it.  True, unity in the format is not observed.  So, NavTeq traditionally uses X-SAMPA transcription, and TomTom uses LH +.  Well, if your TTS-engine perceives both, and if not?  Here it is necessary to pervert.  For example, to convert one transcription into another, which in itself is not trivial.  If there is no phonetic information at all, the engine has its own methods for obtaining it.  If we talk about the engine, Nuance is ‚ÄúData Driven Grapheme To Phoneme‚Äù (DDG2P) and ‚ÄúCommon Linguistic Component‚Äù (CLC).  However, the use of these options is an extreme measure. <br><br><h3>  9. Special sequences </h3><br>  Nuance provides not only the ability to pronounce text or phonetic recording, but also dynamically switch between them.  To do this, use the escape sequence of the form: &lt;ESC&gt; / + <br><br>  In general, using the escape sequences you can set a lot of parameters.  In general terms, it looks like this: <br><pre>                                          &lt;ESC&gt; \ &lt;param&gt; = &lt;value&gt; \
</pre><br>  For example, <br><br>  \ x1b \ rate = 110 \ - sets the speed of pronunciation <br>  \ x1b \ vol = 5 \ - sets the volume <br>  \ x1b \ audio = "beep.wav" \ - inserts data from a wav file into the audio stream. <br><br>  Similarly, you can force the engine to spell a word, insert pauses, change the voice (for example, from male to female) and much more.  Of course, not all sequences can be useful to you, but in general this is a very useful feature. <br><br><h3>  10. Dictionaries </h3><br>  Sometimes you need to pronounce a set of words in a certain way (abbreviations, abbreviations, proper names, etc), but in each case you want to replace the text with a phonetic transcription (and this is not always possible).  In this case dictionaries come to the rescue.  What is vocabulary in Nuance terminology?  This is a file with a set of pairs: &lt;text&gt; &lt;transcription&gt;.  This file is compiled and then loaded by the engine.  When pronouncing, the engine checks whether the word / text is present in the dictionary and, if so, replaces it with its phonetic transcription.  Here, for example, a dictionary containing the names of streets and squares of the Vatican. <br><br><pre> [Header]
 Name = Vaticano
 Language = ITI
 Content = EDCT_CONTENT_BROAD_NARROWS
 Representation = EDCT_REPR_SZZ_STRING
 [Data]
 "Largo del Colonnato" // 'lar.go_del_ko.lo.'n: a.to
 "Piazza del Governatorato" // 'pja.t &amp; s: a_del_go.ver.na.to.'ra.to
 "Piazza della Stazione" // 'pja.t &amp; s: a_de.l: a_sta.'t &amp; s: jo.ne
 "Piazza di Santa Marta" // 'pja.t &amp; s: a_di_'san.ta_'mar.ta
 "Piazza San Pietro" // 'pja.t &amp; s: a_'sam_'pjE.tro
 "Piazzetta Ch√¢teauneuf Du Pape" // pja.'t &amp; s: et: a_Sa.to.'nef_du_'pap
 "Salita ai Giardini" // sa.'li.ta_aj_d &amp; Zar.'di.ni
 "Stradone dei Giardini" // stra.'do.ne_dej_d &amp; Zar.'di.ni
 "Via dei Pellegrini" // 'vi.a_dej_pe.l: e.'gri.ni
 "Via del Fondamento" // 'vi.a_del_fon.da.'men.to
 "Via del Governatorato" // 'vi.a_del_go.ver.na.to.'ra.to
 "Via della Posta" // 'vi.a_de.l: a_'pOs.ta
 "Via della Stazione Vaticana" // 'vi.a_de.l: a_sta.'t &amp; s: jo.ne_va.ti.'ka.na
 "Via della Tipografia" // 'vi.a_de.l: a_ti.po.gra.'fi.a
 "Via di Porta Angelica" // 'vi.a_di_'pOr.ta_an.'d &amp; ZE.li.ka
 "Via Tunica" // 'vi.a_'tu.ni.ka
 "Viale Centro del Bosco" // vi.'a.le_'t &amp; SEn.tro_del_'bOs.ko
 "Viale del Giardino Quadrato" // vi.'a.le_del_d &amp; Zar.'di.no_kwa.'dra.to
 "Viale Vaticano" // vi.'a.le_va.ti.'ka.no
</pre><br><br><h3>  11. Recognition </h3><br>  Speech recognition is even more challenging than its synthesis.  If synthesizers somehow worked in the good old days, then sensible recognition became available only now.  There are several reasons for this, the first of which is very similar to the problems of an ordinary living person facing an unfamiliar language, the second is a collision with text from an unfamiliar area. <br><br>  Perceiving vibrations of sound that remind us of a voice, we first try to divide it into phonemes, isolate familiar sounds that we have to form into words.  If the language is familiar to us, then it is easy to do; if not, then most likely even ‚Äúcorrectly‚Äù it will not be possible to decompose speech into phonemes (remember the story about ‚ÄúAlla, I'm in the bar!‚Äù).  Where we hear one, the speaker is something completely different.  This happens because over the years our brain has been ‚Äúharassed‚Äù on certain phonemes, and over time, it has become accustomed to perceive only them.  Encountering an unfamiliar sound, he tries to choose the phoneme of his native language [tongues] closest to what he heard.  In a sense, this is similar to the vector quantization method used in speech codecs such as CELP.  Not the fact that such an approximation will be successful.  That is why ‚Äúnative‚Äù phonemes will be ‚Äúconvenient‚Äù for us. <br><br>  Remember, while still in the USSR, while studying at school, and meeting with foreigners, we tried to "transliterate" our name, saying: <br>  <i>"May name of bice ptroff"</i> <br>  The teachers then scolded us, saying - why are you distorting your last name?  Do you think he will be more clear about this?  Speak Russian! <br><br>  Alas, they deceived us or they were mistaken here ... If you could say your name in English / German / Chinese, then a native speaker will really find it easier to understand.  The Chinese understood this a long time ago, and in order to communicate with western partners, they take for themselves special ‚ÄúEuropean‚Äù names.  In machine recognition, a particular language is described by the so-called acoustic model.  Before text recognition, we have to load the acoustic model of a specific language, thus making it clear to the program what phonemes to wait for it at the entrance. <br><br>  The second problem is no less complicated.  Let us return again to our analogy with a living person.  Listening to the interlocutor, we subconsciously build in our head a model of what he will say next, that is, create the context of the conversation.  And if it is SUDDENLY to insert words out of context into the narrative (for example, ‚Äúevolvent‚Äù when it comes to football), one can cause cognitive dissonance in the interlocutor.  Roughly speaking, this dissonance happens all the time at a computer, for it never knows what to expect from a person.  A person is easier - he can ask the interlocutor.  And what should a computer do?  To solve this problem and give the computer the right context, grammar is used. <br><br><h3>  12. Grammar </h3><br>  Grammar (usually defined in the form of BNF) just give the computer (more precisely the ASR engine) an idea of ‚Äã‚Äãwhat to expect from the user at this particular moment.  Usually, these are several alternatives combined by 'or', but more complex grammars are possible.  Here is an example of grammar for choosing Kazan metro stations: <br><br><pre> # BNF + EM V1.0;
 ! grammar test;
 ! start &lt;metro_KAZAN_stations&gt;;
 &lt;metro_KAZAN_stations&gt;:
 "Ametyevo"! Id (0)! Pronounce ("^. M% je.t% jjI.vo-") |
 "Aircraft"! Id (1)! Pronounce ("^ v% jI'astro-'it% jIl% jno-j ^") |
 "Slides"! Id (2)! Pronounce ("'gor.k% jI") |
 "Goat settlement"! Id (3)! Pronounce ("'ko.z% jj ^ _slo-.b ^.' Da") |
 "Kremlin"! Id (4)! Pronounce ("kr% jIm.'l% jof.sko-.j ^") |
 "Gabdulla Tukai Square"! Id (5)! Pronounce ("'plo.S% jIt% j_go-.bdu.'li0_'tu.ko-.j ^") |
 "Victory Avenue"! Id (6)! Pronounce ("pr ^. 'Sp% jekt_p ^.' B% je.di0") |
 "North Station"! Id (7)! Pronounce ("'s% je.v% jIr.ni0j_v ^ g.'zal") |
 "Cloak settlement"! Id (8)! Pronounce ("'su.ko-.no-.j ^ _slo-.b ^.' Da") |
 Yashlek! Id (9)! Pronounce ("ja.'Sl% jek");
</pre><br><br>  As you can see, each line represents one of the alternatives, consisting of the actual text, integer id and phoneme.  A phoneme is not necessary in general, but with it recognition will be more accurate. <br><br>  How big can grammar be?  Big enough.  For example, in our experiments, 37 thousand alternatives are recognized at an acceptable level.  Much worse is the case with complex and branched grammars.  The recognition time increases, and the quality falls, and the dependence on the grammar length is non-linear.  Therefore, my advice is to avoid complex grammars.  Anyway, bye. <br><br>  Grammar (as well as contexts) are static and dynamic.  You have already seen an example of a static grammar; it is compiled in advance and stored in the internal binary representation of the engine.  However, sometimes the context changes during interaction with the user.     ‚Äî     .           , ,     .       .  ,    ¬´ ¬ª         . ,      ,      ,        ( 100 )     . <br><br><h3> 13.   ASR API </h3><br>     ,  .       ‚Äî     .   -  ¬´---¬ª       .   , ASR      (  ).     .   ,       .         (,     )       .  ,    (¬´¬ª|¬´¬ª)        . <br><br>      : <br><br> ConstructRecognizer() ‚Äî  ¬´¬ª     <br> DestroyRecognizer() ‚Äî  ¬´¬ª <br> ASR_Initialize() ‚Äî   ASR <br> ASR_UnInitialize() ‚Äî   ASR <br> evt_HandleEvent ‚Äî    thread- ¬´¬ª <br> ProcessResult() ‚Äî    <br><br><div class="spoiler"> <b class="spoiler_title">ASR    </b> <div class="spoiler_text"><pre> <code class="hljs perl">typedef struct RECOG_OBJECTS_S { void *pHeapInst; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Pointer to the heap. const char *acmod; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to acmod data const char *ddg2p; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to ddg2p data const char *clc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to clc data const char *dct; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to dct data const char *dynctx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to empty dyn ctx data LH_COMPONENT hCompBase; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the base component. LH_COMPONENT hCompAsr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the ASR component. LH_COMPONENT hCompPron; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the pron component (dyn ctx) LH_OBJECT hAcMod; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the AcMod object. LH_OBJECT hRec; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the SingleThreadedRec Object LH_OBJECT hLex; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to lexicon object (dyn ctx) LH_OBJECT hDdg2p; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to ddg2p object (dyn ctx) LH_OBJECT hClc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the CLC (DDG2P backup) LH_OBJECT hDct; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to dictionary object (dyn ctx) LH_OBJECT hCache; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to cache object (dyn ctx) LH_OBJECT hCtx[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the Context object. LH_OBJECT hResults[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the Best results object. ASRResult *results[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> recognition results temporary storage LH_OBJECT hUswCtx; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the UserWord Context object. LH_OBJECT hUswResult; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Handle to the UserWord Result object. unsigned long sampleFreq; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Sampling frequency. unsigned long frameShiftSamples; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Size of one frame in samples <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> requestCancel; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> boolean indicating user wants to cancel recognition // used to generate transcriptions <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx LH_BNF_TERMINAL *pTerminals; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terminals_count; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *terminals_transtype; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> array with same size as pTerminals; <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> value indicates the type of transcription in pTerminal: user-provided, from_ddg2p, from_dct, from_clc SLOT_TERMINAL_LIST *pSlots; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slots_count; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> reco options <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> isNumber; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> set to <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> doing number recognition const char * UswFile; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> path to file where userword should be recorded char * staticCtxID; } RECOG_OBJECTS; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> store ASR objects static RECOG_OBJECTS recogObjects; static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ConstructRecognizer(RECOG_OBJECTS *pRecogObjects, const char *szAcModFN, const char * ddg2p, const char * clc, const char * dct, const char * dynctx) { LH_ERROR lhErr = LH_OK; PH_ERROR phErr = PH_OK; ST_ERROR stErr = ST_OK; LH_ISTREAM_INTERFACE IStreamInterface; void *pIStreamAcMod = NULL; LH_ACMOD_INFO *pAcModInfo; LH_AUDIOCHAINEVENT_INTERFACE EventInterface; <span class="hljs-regexp"><span class="hljs-regexp">/* close old objects */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hAcMod)){ DestroyRecognizer(pRecogObjects); } pRecogObjects-&gt;sampleFreq = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;requestCancel = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;pTerminals = NULL; pRecogObjects-&gt;terminals_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;pSlots = NULL; pRecogObjects-&gt;slots_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; pRecogObjects-&gt;staticCtxID = NULL; pRecogObjects-&gt;acmod = szAcModFN; pRecogObjects-&gt;ddg2p = ddg2p; pRecogObjects-&gt;clc = clc; pRecogObjects-&gt;dct = dct; pRecogObjects-&gt;dynctx = dynctx; EventInterface.pfevent = evt_HandleEvent; EventInterface.pfadvance = evt_Advance; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the input stream <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the acoustic model. stErr = st_CreateStreamReaderFromFile(szAcModFN, &amp;IStreamInterface, &amp;pIStreamAcMod); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ST_OK != stErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the AcMod object. lhErr = lh_CreateAcMod(pRecogObjects-&gt;hCompAsr, &amp;IStreamInterface, pIStreamAcMod, NULL, &amp;(pRecogObjects-&gt;hAcMod)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Retrieve some information from the AcMod object. lhErr = lh_AcModBorrowInfo(pRecogObjects-&gt;hAcMod, &amp;pAcModInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; pRecogObjects-&gt;sampleFreq = pAcModInfo-&gt;sampleFrequency; pRecogObjects-&gt;frameShiftSamples = pAcModInfo-&gt;frameShift * pRecogObjects-&gt;sampleFreq/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create a SingleThreadRec object lhErr = lh_CreateSingleThreadRec(pRecogObjects-&gt;hCompAsr, &amp;EventInterface, pRecogObjects, <span class="hljs-number"><span class="hljs-number">3000</span></span>, pRecogObjects-&gt;sampleFreq, pRecogObjects-&gt;hAcMod, &amp;pRecogObjects-&gt;hRec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> cretae DDG2P &amp; lexicon <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pRecogObjects-&gt;ddg2p) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = InitDDG2P(pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pRecogObjects-&gt;clc) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = InitCLCandDCT(pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO: what now? } // Return without errors. <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Print an error message <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the error comes from the private heap <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> stream component. // Errors from the VoCon320<span class="hljs-number"><span class="hljs-number">0</span></span> component have been printed by the callback. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PH_OK != phErr) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error from the private heap component, error code = %d.\n"</span></span>, phErr); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ST_OK != stErr) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error from the stream component, error code = %d.\n"</span></span>, stErr); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DestroyRecognizer(RECOG_OBJECTS *pRecogObjects) { unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curCtx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hUswResult)){ lh_ObjClose(&amp;pRecogObjects-&gt;hUswResult); pRecogObjects-&gt;hUswResult = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hUswCtx)){ lh_ObjClose(&amp;pRecogObjects-&gt;hUswCtx); pRecogObjects-&gt;hUswCtx = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hDct)){ lh_ObjClose(&amp;pRecogObjects-&gt;hDct); pRecogObjects-&gt;hDct = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hCache)){ lh_ObjClose(&amp;pRecogObjects-&gt;hCache); pRecogObjects-&gt;hCache = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hClc)){ lh_ObjClose(&amp;pRecogObjects-&gt;hClc); pRecogObjects-&gt;hClc = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hLex)){ lh_LexClearG2P(pRecogObjects-&gt;hLex); lh_ObjClose(&amp;pRecogObjects-&gt;hLex); pRecogObjects-&gt;hLex = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hDdg2p)){ lh_DDG2PClearDct (pRecogObjects-&gt;hDdg2p); lh_ObjClose(&amp;pRecogObjects-&gt;hDdg2p); pRecogObjects-&gt;hDdg2p = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(recogObjects.hCtx)/sizeof(recogObjects.hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hCtx[curCtx])){ lh_RecRemoveCtx(pRecogObjects-&gt;hRec, pRecogObjects-&gt;hCtx[curCtx]); lh_ObjClose(&amp;pRecogObjects-&gt;hCtx[curCtx]); pRecogObjects-&gt;hCtx[curCtx] = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hResults[curCtx])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[curCtx]); pRecogObjects-&gt;hResults[curCtx] = lh_GetNullObj(); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hRec)){ lh_ObjClose(&amp;pRecogObjects-&gt;hRec); pRecogObjects-&gt;hRec = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lh_ObjIsNull(pRecogObjects-&gt;hAcMod)){ lh_ObjClose(&amp;pRecogObjects-&gt;hAcMod); pRecogObjects-&gt;hAcMod = lh_GetNullObj(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ASR_Initialize(const char * acmod, const char * ddg2p, const char * clc, const char * dct, const char * dynctx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = <span class="hljs-number"><span class="hljs-number">0</span></span>; size_t curCtx; LH_HEAP_INTERFACE HeapInterface; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Initialization of all handles. recogObjects.pHeapInst = NULL; recogObjects.hCompBase = lh_GetNullComponent(); recogObjects.hCompAsr = lh_GetNullComponent(); recogObjects.hCompPron = lh_GetNullComponent(); recogObjects.hAcMod = lh_GetNullObj(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(recogObjects.hCtx)/sizeof(recogObjects.hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ recogObjects.hCtx[curCtx] = lh_GetNullObj(); recogObjects.hResults[curCtx] = lh_GetNullObj(); } recogObjects.hRec = lh_GetNullObj(); recogObjects.hLex = lh_GetNullObj(); recogObjects.hDdg2p = lh_GetNullObj(); recogObjects.hClc = lh_GetNullObj(); recogObjects.hCache = lh_GetNullObj(); recogObjects.hDct = lh_GetNullObj(); recogObjects.hUswCtx = lh_GetNullObj(); recogObjects.hUswResult = lh_GetNullObj(); recogObjects.sampleFreq = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.requestCancel = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.pTerminals = NULL; recogObjects.terminals_count= <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.pSlots = NULL; recogObjects.slots_count = <span class="hljs-number"><span class="hljs-number">0</span></span>; recogObjects.staticCtxID = NULL; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Construct all components <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> objects needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> recognition. // Connect the audiochain objects. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (acmod) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> initialize components // Create a base <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> an ASR component. (+pron <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dyn ctx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitBase(&amp;HeapInterface, recogObjects.pHeapInst, LhErrorCallBack, NULL, &amp;recogObjects.hCompBase)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitAsr(recogObjects.hCompBase, &amp;HeapInterface, recogObjects.pHeapInst, &amp;recogObjects.hCompAsr)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK != lh_InitPron(recogObjects.hCompBase, &amp;HeapInterface, recogObjects.pHeapInst, &amp;recogObjects.hCompPron)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; rc = ConstructRecognizer(&amp;recogObjects, acmod, ddg2p, clc, dct, dynctx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rc; error: <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> An error occured. Close the engine. CloseOnError(&amp;recogObjects); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ASR_UnInitialize(void) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Disconnects the audiochain objects. // Closes all objects <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> components of the vocon recognizer. rc = DestroyRecognizer(&amp;recogObjects); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Close the PRON component. lh_ComponentTerminate(&amp;recogObjects.hCompPron); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Close the ASR <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Base component. lh_ComponentTerminate(&amp;recogObjects.hCompAsr); lh_ComponentTerminate(&amp;recogObjects.hCompBase); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> evt_HandleEvent(void *pEvtInst, unsigned long type, LH_TIME timeMs) { RECOG_OBJECTS *pRecogObjects = (RECOG_OBJECTS*)pEvtInst; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_BOS ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ask upper level <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> beep <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_BOS at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_TS_FX ) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_TS_FX at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_TS_REC ) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_TS_REC at time %d ms.\n"</span></span>, timeMs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_FX_ABNORMCOND ) { LH_ERROR lhErr = LH_OK; LH_FX_ABNORMCOND abnormCondition; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_FX_ABNORMCOND at time %d ms.\n"</span></span>, timeMs); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Find out what the exact abnormal condition is. lhErr = lh_FxGetAbnormCondition(pRecogObjects-&gt;hRec, &amp;abnormCondition); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; switch (abnormCondition) { case LH_FX_BADSNR: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_BADSNR.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_OVERLOAD: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_OVERLOAD.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_TOOQUIET: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_TOOQUIET.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_NOSIGNAL: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_NOSIGNAL.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_POORMIC: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_POORMIC.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; case LH_FX_NOLEADINGSILENCE: <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Abnormal condition: LH_FX_NOLEADINGSILENCE.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } // LH_AUDIOCHAIN_EVENT_FX_TIMER // It usually is used to get the signal level <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> SNR at regular intervals. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_FX_TIMER ) { LH_ERROR lhErr = LH_OK; LH_FX_SIGNAL_LEVELS SignalLevels; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_FX_TIMER at time %d ms.\n"</span></span>, timeMs); lhErr = lh_FxGetSignalLevels(pRecogObjects-&gt;hRec, &amp;SignalLevels); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK != lhErr) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Signal level: %ddB, SNR: %ddB at time %dms.\n"</span></span>, SignalLevels.energy, SignalLevels.SNR, SignalLevels.timeMs); } // LH_AUDIOCHAIN_EVENT_RESULT <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( type &amp; LH_AUDIOCHAIN_EVENT_RESULT ){ LH_ERROR lhErr = LH_OK; LH_OBJECT hNBestRes = lh_GetNullObj(); LH_OBJECT hCtx = lh_GetNullObj(); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Receiving event LH_AUDIOCHAIN_EVENT_RESULT at time %d ms.\n"</span></span>, timeMs); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get the NBest result object <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> process it. lhErr = lh_RecCreateResult (pRecogObjects-&gt;hRec, &amp;hNBestRes); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lhErr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_ResultBorrowSourceCtx(hNBestRes, &amp;hCtx)){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hCtx[i])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hCtx.pObj == pRecogObjects-&gt;hCtx[i].pObj){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[i]); } pRecogObjects-&gt;hResults[i] = hNBestRes; hNBestRes = lh_GetNullObj(); _ready = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ready) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hCtx[i])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ _ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } ASSERT(lh_ObjIsNull(hNBestRes)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ready) { ProcessResult (pRecogObjects); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;sizeof(pRecogObjects-&gt;hResults)/sizeof(pRecogObjects-&gt;hResults[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[i])){ lh_ObjClose(&amp;pRecogObjects-&gt;hResults[i]); } } } } // Close the NBest result object. } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; error: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ProcessResult (RECOG_OBJECTS *pRecogObjects) { LH_ERROR lhErr = LH_OK; size_t curCtx, i, k, count=<span class="hljs-number"><span class="hljs-number">0</span></span>; size_t nbrHypothesis; ASRResult *r = NULL; long lid; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> get total hyp count <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(curCtx=<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx&lt;sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); curCtx++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(pRecogObjects-&gt;hResults[curCtx])){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK == lh_NBestResultGetNbrHypotheses (pRecogObjects-&gt;hResults[curCtx], &amp;nbrHypothesis)){ count += nbrHypothesis; } } } // traces <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">" __________RESULT %3d items max_______________\n"</span></span>, count); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| | |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| result | confi- | result string [start rule]\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| number | dence |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"|________|________|___________________________\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| | |\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { r = ASRResult_New(count); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get &amp; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> out the result information <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> hypothesis. count = <span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx = sizeof(pRecogObjects-&gt;hCtx)/sizeof(pRecogObjects-&gt;hCtx[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; curCtx&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; curCtx--){ LH_OBJECT hNBestRes = pRecogObjects-&gt;hResults[curCtx-<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lh_ObjIsNull(hNBestRes)){ LH_HYPOTHESIS *pHypothesis; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LH_OK == lh_NBestResultGetNbrHypotheses (hNBestRes, &amp;nbrHypothesis)){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nbrHypothesis; i++) { char *szResultWords; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Retrieve information on the recognition result. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_NBestResultFetchHypothesis (hNBestRes, i, &amp;pHypothesis)){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Get the result string. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LH_OK == lh_NBestResultFetchWords (hNBestRes, i, &amp;szResultWords)){ <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"| %6lu | %6lu | '%s' [%s]\n"</span></span>, i, pHypothesis-&gt;conf, szResultWords, pHypothesis-&gt;szStartRule); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Return the fetched data to the engine. lh_NBestResultReturnWords (hNBestRes, szResultWords); } lh_NBestResultReturnHypothesis (hNBestRes, pHypothesis); } } } } } } // traces <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"|________|________|___________________________\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br><br> ,     TTS,   ,      .       !      .      ,     ,     /    ¬´ ¬ª. <br><br><h3> 14.   () </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last word of technology is now stream recognition, or dictation. </font><font style="vertical-align: inherit;">The technology is already available on modern smartphones for Android and iOS. </font><font style="vertical-align: inherit;">Including - in the form of API. </font><font style="vertical-align: inherit;">Here, the programmer does not need to specify the recognition context when creating grammars. </font><font style="vertical-align: inherit;">At the entrance there is a speech - at the exit, recognized words. </font><font style="vertical-align: inherit;">Unfortunately, the details of how this method works are not available to me yet. </font><font style="vertical-align: inherit;">The recognition process goes not on the device itself, but on the server where the voice is transmitted and from there the result is obtained. </font><font style="vertical-align: inherit;">I would like, however, to believe that after years the technology will be available on the client side as well.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's probably all that I wanted to talk about technologies ASR and TTS. </font><font style="vertical-align: inherit;">I hope it turned out not too boring and informative enough. In any case, questions are welcome.</font></font></div><p>Source: <a href="https://habr.com/ru/post/264531/">https://habr.com/ru/post/264531/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264519/index.html">Tutorial: Interactive SVG Cartogram Component for InstantCMS 2</a></li>
<li><a href="../264521/index.html">Treacherous router or why ports need to open</a></li>
<li><a href="../264523/index.html">How Easter eggs in email helped the company draw attention to its conference</a></li>
<li><a href="../264525/index.html">Free IBM Bluemix Developer Resources</a></li>
<li><a href="../264527/index.html">EXTREME'AL LACP</a></li>
<li><a href="../264535/index.html">Android Devs Meetup 2: videos and presentations from the last meeting</a></li>
<li><a href="../264539/index.html">Check or not check - that is the question</a></li>
<li><a href="../264541/index.html">Kali Linux 2.0</a></li>
<li><a href="../264543/index.html">Work with Queues and other Call Center features</a></li>
<li><a href="../264545/index.html">Deploying Rancher to InfoboxCloud: a portable infrastructure with a web interface for Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>