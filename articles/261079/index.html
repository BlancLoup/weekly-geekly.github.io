<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>D for beginners, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 Let's continue the subject of the previous article . There will be an explanation of such concepts as @ safe, @ trusted, pure, noth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>D for beginners, part 2</h1><div class="post__text post__text-html js-mediator-article">  Good day, Habr! <br><br>  Let's continue the subject of the <a href="http://habrahabr.ru/post/261043/">previous article</a> .  There will be an explanation of such concepts as @ safe, @ trusted, pure, nothrow, some points related to OOP. <br><a name="habracut"></a><br>  All code by default is @ system (with some exceptions), which means that low-level operations are allowed (work with pointers).  In this mode, in D you can do absolutely everything the same as in C / C ++.  It also includes many memory errors that can be made in C / C ++.  There is a way to avoid a large number of errors, if you adhere to some restrictions.  In fact, this is a subset of the D language, it is called SafeD and, according to the logic of working with it, is more like Java and C #.  This mode is enabled by the @ safe attribute and disables all operations in the code that can cause undefined behavior. <br>  SafeD Restrictions: <br><ul><li>  You cannot cast a pointer of some type to a pointer of any other type other than void * </li><li>  you cannot cast any type to a pointer </li><li>  cannot modify pointer value (pointer value can be modified) </li><li>  access to fields of associations containing pointers or references to other types is prohibited </li><li>  calling any @ system code is prohibited </li><li>  you can catch exceptions that are inherited only from Exception (Error is inherited from the base Throwable, therefore, AssertError assertion errors cannot be caught) </li><li>  assembly code inserts are prohibited </li><li>  no explicit casts (cast construction) of mutable types to immutable and vice versa </li><li>  no explicit casting of stream (normal) types to shared and vice versa </li><li>  forbidden to take the address of local variables and function arguments </li><li>  no access to __gshared (‚Äútruly‚Äù global, as in C / C ++) variables </li></ul><br>  The @ trusted attribute allows using the system code inside safe.  But you need to be very cautious about this possibility - check all trusted functions more carefully. <br><br>  The @ nogc attribute prohibits the use of operations using the garbage collector and calling functions that are not @ nogc, more information about disabling the garbage collector can be found <a href="http://habrahabr.ru/post/260151/">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The pure attribute indicates that the function will not use global or static mutable variables.  This allows the compiler to use some optimizations.  There is one exception to this rule ‚Äî the debug block: <br><pre><code class="hljs swift">void <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pure { debug writeln( <span class="hljs-string"><span class="hljs-string">"print from pure"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//      ... }</span></span></code> </pre> <br>  To compile in debug mode, you must specify the dmd -debug flag (trivial, but still). <br>  This attribute is also very useful when writing classes and structures (more on this later). <br><br>  The nothrow attribute ensures that the function will not throw exceptions inherited from Exception.  This does not prevent her from throwing Error exceptions.  As conceived by the developers, the Error exceptions are unrecoverable, so it makes no sense to intercept them.  Also, this does not prevent it from calling non-nothrow functions if they are enclosed in a try-catch block. <br><br>  All functional literals and template functions, by default, have @ safe, @ nogc, pure, and nothrow attributes, if possible.  To automatically assign each of the attributes to such functions, the appropriate conditions must be met. <br><br>  @ Disable disables the function call.  This is useful when writing structures that should not have any default functions, for example: <br><pre> <code class="hljs ruby">struct Foo { @‚Äãdisable this(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    @‚Äãdisable this(this); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     this( int v ){} /<span class="hljs-regexp"><span class="hljs-regexp">/        } void main() { Foo a; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,     auto b = Foo(3); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     auto c = b; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,     }</span></span></code> </pre><br>  This can be used not only with built-in functions: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">B</span></span> { @<span class="hljs-function"><span class="hljs-function">disable </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { auto bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B; bb.bar(); auto cc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C; cc.bar(); <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre><br>  But I do not advise using this approach: it does not prohibit redefining a function in the class inherited from C, but calling it will fail during execution.  There is an exception mechanism for this behavior. <br><br>  The deprecated attribute displays a warning, useful for smoothly changing api, so that users everywhere can remove the call to such a function.  This attribute accepts a string as a message to be displayed during compilation: <br><pre> <code class="hljs cs">deprecated(<span class="hljs-string"><span class="hljs-string">"because it's old"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oldFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre><br>  The attribute can be applied to the code in a different way: ‚Äújust an attribute‚Äù is applied to the declaration following the attribute, when using curly brackets after the attribute, it is applied to the block of the upper levels and inside classes (declaration of blocks with attributes is forbidden and does not make sense within functions) and with a colon, in this case it is applied to the end of the file. <br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class">;</span></span> @‚Äã<span class="hljs-symbol"><span class="hljs-symbol">safe:</span></span> ... /<span class="hljs-regexp"><span class="hljs-regexp">/       pure { int somefunc1() {} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  @‚Äãsafe,  pure int somefunc2() nothrow {} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @‚Äãsafe, pure  nothrow }</span></span></code> </pre><br><br>  With simple things sorted out.  Now it is worth highlighting, apparently, the most obscure topic: shared with immutable with structures and classes. <br><br>  Take a simple example: we want to organize a message queue from one thread to another, using our own data structure. <br>  Let's start with the structure.  Suppose we need a timestamp and some message, and the structure will always be immutable (we don‚Äôt need other options). <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.traits; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.datetime; //  "  ",   ,     <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> isMessage(T) { enum isMessage = <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( Unqual!T == _Message ); } struct _Message { ulong ts; <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>[]) data; //   @<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> this(); //        <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span>: //    <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> ,      <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> this(T)( auto <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> const T val ) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isMessage!T ) { //      ts = val.ts; data = val.data; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //     data       static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isArray!T ) data = val.idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( typeof(val.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) ) ) //  ,   range data = val.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !hasUnsharedAliasing!T ) //    ,   ,      data = [val].idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, "unsupported type" ); //     ts = Clock.currAppTick().length; } } //   auto <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(T)() @property { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isArray!T ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(T)(data.dup); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !hasUnsharedAliasing!T ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (cast(T[])(data.dup))[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, "unsupported type" ); } } <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Message = <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> _Message; //        ,    // ///   -  .          unittest { auto a = Message( "hello" ); auto b = Message( a ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( a.ts == b.ts ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( b.<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>!string == "hello" ); auto c = Message( b.data ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( a.ts != c.ts ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( c.<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>!string == "hello" ); auto d = a; auto e = Message( <span class="hljs-number"><span class="hljs-number">3.14</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( e.<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>!<span class="hljs-type"><span class="hljs-type">double</span></span> == <span class="hljs-number"><span class="hljs-number">3.14</span></span> ); }</code> </pre><br>  ‚ÄúWhy <b>only</b> immutable?‚Äù You may ask?  Here the question is ambiguous.  Do you really need mutable messages in multi-threaded programming (about more serious types a little further)?  The message is the message that it is small, "disposable."  In Rust, for example, all variables are immutable by default.  This further allows you to avoid unnecessary hemorrhoids with synchronization, as a result there are less errors and less code.  But if you still need.  First, the constructor must be pure (pure) - this will allow you to create any type of object using a single constructor (in our example, we use a function that gets time, it is not clean).  Secondly, it is necessary to partially duplicate the code of access methods to the object.  If the constructor cannot be clean, then you will also have to duplicate the code, clearly indicating the cases of its use.  Example: <br><pre> <code class="hljs pgsql">struct CrdMessage { ulong code; <span class="hljs-type"><span class="hljs-type">float</span></span> x, y; this( ulong code, <span class="hljs-type"><span class="hljs-type">float</span></span> x, <span class="hljs-type"><span class="hljs-type">float</span></span> y ) pure //   { this.code = code; this.x = x; this.y = y; } this( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CrdMessage msg ) pure //   { code = msg.code; x = msg.x; y = msg.y; } <span class="hljs-type"><span class="hljs-type">float</span></span> sum() const @property { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } //  <span class="hljs-type"><span class="hljs-type">float</span></span> sum() shared const @property { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } //  <span class="hljs-type"><span class="hljs-type">float</span></span> sum() <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> @property { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } //  }</code> </pre><br>  Duplication could be removed with the help of the mixin template, but it's not just that.  If we do not use shared objects of such a structure, then we can only get along with the const variant of the method (immutable objects will call it).  The shared method is necessary, since we explicitly say that the object can be shared, therefore, we take <b>responsibility for synchronization</b> .  This means that the <b>code in the example contains an error</b> , we did not take into account that the values ‚Äã‚Äãmay change in another thread.  The const and shared const methods are not enough to call a method for an immutable object, since the immutable object can be divided between threads and the type system cannot choose which method to call (const or shared const).  Also, the const method may differ from immutable, since in the case of const we guarantee the immutability of the reference to the object, and in the case of immutable we guarantee the immutability of all fields of the structure throughout its lifetime, so we may need to do some actions in the const method Immutable no need to perform (additional copying for example).  Such a type system makes you think about the actions performed and be more careful when writing shared code, but at first it can cause pain. <br><div class="spoiler">  <b class="spoiler_title">Once upon a time I myself experienced this pain, but I was hard-nosed and illiterate, I wanted everything at once</b> <div class="spoiler_text">  As a result, I got some code that worked as I wanted (with a few reservations) and since then it, in principle, has not changed much: <a href="">here is the</a> structure that stores untyped data, <a href="">here is the</a> message transmitted between threads, using the storage structure data. <br></div></div><br>  Let's return to the creation of our multi-threaded application.  We implement the queue of the simplest queue (we do not think about the optimization of memory allocation). <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">synchronized</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">MsgQueue</span></span> { <span class="hljs-type"><span class="hljs-type">Message</span></span>[] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; //    //  ,       foreach bool empty() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class"> == 0; } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class"> front() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0]; } void popFront() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[1..$]; } void put( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> ) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> ~= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">; } }</span></span></code> </pre><br>  Yes, everything is so simple!  In fact, everything related to structures can be applied to classes (in terms of shared, immutable, etc.).  The synchronized keyword means that the class is shared, but synchronized can only be used with classes and it has an important difference from shared.  In order, as it might be: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MsgQueue</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Message</span></span></span><span class="hljs-class">[] data; import core.sync.mutex; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mutex</span></span></span><span class="hljs-class"> mutex; //   this() shared { mutex = cast(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mutex</span></span></span><span class="hljs-class">)new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mutex</span></span></span><span class="hljs-class">; } // - </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mutex</span></span></span><span class="hljs-class">   shared  ... void popFront() shared // { synchronized(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class">) //  ,   { data = data[1..$]; } } ... }</span></span></code> </pre><br>  You can not mark each method with the shared attribute, but make the entire class shared.  You can also use the object itself of the MsgQueue class (and any other) as a synchronization object: <br><pre> <code class="hljs kotlin">shared <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgQueue</span></span></span><span class="hljs-class"> </span></span>{ Message[] <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; ... void popFront() { synchronized(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>..$]; } } ... }</code> </pre><br>  An object of any class can be a synchronization object due to the fact that from the base class (Object) each object adopts a synchronization object (__monitor) that implements the Object.Monitor interface (Mutex also implements it). <br><br>  If we want to synchronize not the block inside the method, but the entire method, while we want to use the class instance itself as the synchronization object, then we can make the entire method synchronized: <br><pre> <code class="hljs java">shared <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgQueue</span></span></span><span class="hljs-class"> </span></span>{ Message[] data; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">popFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span></span>{ data = data[<span class="hljs-number"><span class="hljs-number">1</span></span>..$]; } ... }</code> </pre><br>  If all class methods must be thread safe, we can render synchronized, like shared, to the class level, then we return to the original spelling. <br><br>  I hope I managed to clarify some non-obvious points.  Again, if you think it's worth paying special attention to something, write about it.  I brought here only what seemed unobvious to me. <br><br><div class="spoiler">  <b class="spoiler_title">Full text messaging program</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.traits; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.datetime; //  "  ",   ,     <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> isMessage(T) { enum isMessage = <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( Unqual!T == _Message ); } struct _Message { ulong ts; <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>[]) data; //   @<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> this(); //        <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span>: //    <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> ,      <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> this(T)( auto <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> const T val ) { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isMessage!T ) { //      ts = val.ts; data = val.data; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //     data       static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isArray!T ) data = val.idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>( typeof(val.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) ) ) //  ,   range data = val.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !hasUnsharedAliasing!T ) //    ,   ,      data = [val].idup; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, "unsupported type" ); //     ts = Clock.currAppTick().length; } } //   auto <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>(T)() @property { static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isArray!T ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cast(T)(data.dup); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !hasUnsharedAliasing!T ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (cast(T[])(data.dup))[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, "unsupported type" ); } } <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Message = <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> _Message; synchronized <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MsgQueue { Message[] data; <span class="hljs-type"><span class="hljs-type">bool</span></span> empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.length == <span class="hljs-number"><span class="hljs-number">0</span></span>; } Message front() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> popFront() { data = data[<span class="hljs-number"><span class="hljs-number">1.</span></span>.$]; } <span class="hljs-type"><span class="hljs-type">void</span></span> put( Message msg ) { data ~= msg; } } unittest { auto mq = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> shared MsgQueue; mq.put( Message( "hello" ) ); mq.put( Message( "habr" ) ); string[] msgs; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( msg; mq ) msgs ~= msg.<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>!string; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>( msgs == ["hello", "habr"] ); } <span class="hljs-type"><span class="hljs-type">void</span></span> randomsleep(uint min=<span class="hljs-number"><span class="hljs-number">1</span></span>,ulong max=<span class="hljs-number"><span class="hljs-number">100</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> core.thread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.random; Thread.sleep( dur!"msecs"(uniform(min,max)) ); } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.string : <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> sender( shared MsgQueue mq, string <span class="hljs-type"><span class="hljs-type">name</span></span> ) { scope(<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>) writefln( "sender %s finish", <span class="hljs-type"><span class="hljs-type">name</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; <span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">15</span></span> ) { mq.put( Message( format( "message #%d from [%s]", i, <span class="hljs-type"><span class="hljs-type">name</span></span> ) ) ); randomsleep; } } <span class="hljs-type"><span class="hljs-type">void</span></span> receiver( shared MsgQueue mq ) { uint empty_mq = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> start_receive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; scope(<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>) writeln( "reciver finish" ); m: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( mq.empty ) empty_mq++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( empty_mq &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> &amp;&amp; start_receive ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( msg; mq ) { writefln( "[%012d]: %s", msg.ts, msg.<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>!string ); randomsleep; start_receive = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.concurrency; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { auto mq = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> shared MsgQueue; spawn( &amp;receiver, mq ); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( i; <span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">10</span></span> ) spawn( &amp;sender, mq, format( "%d", i ) ); writeln( "main finish" ); }</code> </pre><br></div></div><br><br>  Also in the standard library D there is an implementation of "green" threads (this is me just in case), documentation on <a href="http://dlang.org/phobos/core_thread.html">off.sayte</a> . </div><p>Source: <a href="https://habr.com/ru/post/261079/">https://habr.com/ru/post/261079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261065/index.html">3CX WebMeeting 8 web conferencing solution is already available in Australia and Oceania</a></li>
<li><a href="../261069/index.html">Google AI or Data Center in the power of artificial intelligence</a></li>
<li><a href="../261071/index.html">Decoding the upcoming 3CX Phone System update to version 14</a></li>
<li><a href="../261075/index.html">Antiviruses at gunpoint: a big hole in ESET and an attack on Kaspersky</a></li>
<li><a href="../261077/index.html">5 internships for IT professionals abroad</a></li>
<li><a href="../261081/index.html">Hardcore old school: QEMU and reverse floppy image</a></li>
<li><a href="../261083/index.html">GIF, WebP, APNG, BPG animation comparison</a></li>
<li><a href="../261085/index.html">Samsung software can intentionally disable Windows Update</a></li>
<li><a href="../261087/index.html">Microsoft DevOps tools</a></li>
<li><a href="../261089/index.html">Infrastructure: What is behind the pictures on the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>