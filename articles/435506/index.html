<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gameboy based supercomputer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With a speed of more than 1 billion frames per second, this is arguably the fastest of 8-bit console clusters in the world. 


 Distributed Tetris (19...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gameboy based supercomputer</h1><div class="post__text post__text-html js-mediator-article">  With a speed of more than 1 billion frames per second, this is arguably the fastest of 8-bit console clusters in the world. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e7/0fa/97d/4e70fa97d86589ec00f0a570a3835feb.gif"><br>  <i>Distributed Tetris (1989)</i> <br><br><h2>  How to build such a computer? </h2><br><h3>  Recipe </h3><br>  Take a handful of silicon, apply training with reinforcements, experience with supercomputers, a passion for computer architecture, add sweat and tears, stir for 1000 hours until it boils - and voila. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Why would anyone need such a computer? </h2><br>  In short: to move towards enhancing artificial intelligence. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/1bd/3ef/d7f1bd3ef8197d18fc1612235bfbc0df.png"><br>  <i>One of the 48 IBM Neural Computer boards used for experimentation</i> <br><br><h2>  But a more detailed version </h2><br>  2016 year.  Deep learning is everywhere.  Image recognition can be considered a solved problem due to convolutional neural networks, and my research interests tend to neural networks with memory and learning with reinforcement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa6/7e2/2de/aa67e22de1d4c2eb58f415beb61628e9.png"><br><br>  Specifically, Google Deepmind authorship showed that you can reach a person‚Äôs level or even surpass it in various games for the Atari 2600 (a home game console released in 1977) using a simple learning algorithm supported by the Deep Q-Neural Network.  And all this happens just when viewing the gameplay.  It caught my attention. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/dd5/f97/e3edd5f97096170a43b775859b539087.gif"><br>  <i>One of the games with the Atari 2600, Breakout.</i>  <i>The machine was trained using a simple reinforcement learning algorithm.</i>  <i>After millions of iterations, the computer began to play better than humans.</i> <br><br>  I started experimenting with Atari 2600 games. Breakout, while impressive, cannot be called difficult.  Complexity can be determined by the degree of complexity in accordance with your actions (joystick) to your results (points).  The problem appears when the effect must wait for quite some time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/849/950/f41849950d6af5392b78e51f838ec707.gif"><br>  <i>Illustration of the problem on the example of more complex games.</i>  <i>On the left - Breakout (ATARI 2600) [the author was mistaken, this is the game Pong / approx.</i>  <i>trans.] with very fast response and fast feedback.</i>  <i>On the right, Mario Land (Nintendo Game Boy) does not provide instant information about the consequences of an action, and long periods of irrelevant observations may appear between two important events.</i> <br><br>  To make learning more effective, one can imagine attempts to transfer some of the knowledge from simpler games.  This task now remains unsolved, and is an active topic for research.  A recently published <a href="https://contest.openai.com/2018-1/">task</a> from OpenAI is trying to measure just that. <br><br>  The ability to transfer knowledge would not only accelerate training - I believe that some learning problems cannot be solved at all in the absence of basic knowledge.  We need data efficiency.  Take the game Prince of Persia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/139/4d7/aa6/1394d7aa679b5a687d07cd97a5c68d4b.gif"><br><br>  There are no obvious points in it. <br>  To complete the game, it takes 60 minutes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/c4d/5b7/11bc4d5b76ad0a167c31067edd0d30ea.gif"><br><br>  Is it possible to apply the same approach here that was used when writing work on the Atari 2600?  How likely is it that you can get to the end by pressing random keys? <br><br>  This question prompted me to contribute to the community, which was trying to solve this problem.  In fact, we have a chicken and egg task ‚Äî we need a better algorithm that will allow us to transmit a message, but this requires research, and experiments take a lot of time, because we do not have a more efficient algorithm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc9/009/5f1/fc90095f174e9052dfb677996562ac14.png"><br>  <i>Example of knowledge transfer: Imagine that at first we learned how to play a simple game, such as on the left.</i>  <i>Then we save such concepts as ‚Äúrace‚Äù, ‚Äúcar‚Äù, ‚Äútrack‚Äù, ‚Äúwin‚Äù and learn colors or three-dimensional models.</i>  <i>We argue that common concepts can be ‚Äútransferred‚Äù between games.</i>  <i>The similarity of games can be determined by the number of knowledge transferred between them.</i>  <i>For example, the game "Tetris" and F1 will not be similar.</i> <br><br>  Therefore, I decided to use the second best approach, avoiding the initial slowdown, dramatically speeding up the system.  My goals were: <br>  - accelerated environment (imagine that Prince of Persia can be completed 100 times faster) and simultaneous launch of 100,000 games. <br>  - environment, more suitable for research (we concentrate on tasks, but not on preliminary calculations, we have access to various games). <br><br>  Initially, I believed that the bottleneck associated with speed may somehow depend on the complexity of the emulator code (for example, the Stella code base is large, besides, it relies on C ++ abstractions - not the best choice for emulators). <br><br><h2>  Console </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/900/dc8/c32/900dc8c322e070709af65b0f89d55146.jpg"><br><br>  I worked together on several platforms, starting with one of the very first games ever created (along with Pong) - the Space Invaders arcade, Atari 2600, NES and Game Boy.  And all this was written in C. <br><br>  I managed to reach a maximum frame rate of 2000-3000 per second.  To begin to get the results of experiments, we need millions or billions of frames, so the gap was huge. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/677/cd2/ebd/677cd2ebda80be7e5eace8380911c084.gif"><br>  <i>FPGA Space Invaders - Low Speed ‚Äã‚ÄãDebugging Mode.</i>  <i>The counter on the FPGA shows the number of past clock pulses.</i> <br><br>  And then I thought - what if we could speed up the right environment with iron.  For example, the original Space Invaders went to the 8080 CPU with a frequency of 1 MHz.  I managed to emulate an 8080 40 MHz CPU on a 3 GHz Xeon processor.  Not bad, but after I placed all this inside the FPGA, the frequency went up to 400 MHz.  That meant 24,000 FPS from one stream ‚Äî the equivalent of a 30 GHz Xeon!  Did I mention that you can push 100 8080 processors into the average FPGA?  This already gives a FPS of 2.4 million. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/82a/dd1/41582add164c44c52b01fdfec7160e20.gif"><br>  <i>Space Invaders with hard acceleration, 100 MHz, quarter full speed</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/8a8/4e0/90d8a84e0053c30eb4b337b27c15dcfc.png"><br>  <i>More than a hundred cores inside the Xilinx Kintex 7045 FPGA (indicated by bright colors; a blue spot in the middle is the general logic for the demonstration).</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c1/dc9/f93/4c1dc9f93c26391a762466a8216053f9.png"><br>  <i>Uneven execution path</i> <br><br>  You may ask, what about the GPU?  In short, we need <a href="https://ru.wikipedia.org/wiki/MIMD">MIMD</a> type concurrency, not <a href="https://ru.wikipedia.org/wiki/SIMD">SIMD</a> .  As a student, I worked for a while on <a href="http://olab.is.s.u-tokyo.ac.jp/~kamil.rocki/rocki_ipdps11.pdf">implementing a</a> Monte Carlo GPU tree search (this search was used in AlphaGo). <br><br>  At that time, I spent countless hours trying to get the GPU and other hardware that work on the SIMD principle (IBM Cell, Xeon Phi, AVX CPU) to execute such code, and nothing came of it.  A few years ago, I began to think that it would be nice to be able to independently develop iron specifically designed for solving tasks related to reinforcement training. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/730/b57/479730b5758c7bbccecd7be47f8ca310.gif"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d98/4ee/ad9/d984eead9cd837908580a0545210918b.png"><br>  <i>MIMD concurrency</i> <br><br><h2>  ATARI 2600, NES or Game Boy? </h2><br>  On the 8080, I implemented Space Invaders, NES, 2600, and Game Boy.  And here are some facts about them and the advantages of each of them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/475/be6/f26475be6707be383030b9e116222a71.png"><br>  <i>NES Pacman</i> <br><br>  Space Invaders were just warming up.  We managed to make them work, but it was only one game, so the result was not very useful. <br><br>  The Atari 2600 is actually a standard in reinforced learning research.  The MOS 6507 processor is a simplified version of the famous 6502, its design is more elegant and more efficient than that of the 8080. I chose the 2600 not only because of certain limitations associated with games and their graphics. <br><br>  I also implemented the NES (Nintendo Entertainment System), it shares the CPU with 2600. There are much better games than the 2600. But both consoles suffer from an overly complex graphics processing pipeline and several cartridge formats that need to be supported. <br><br>  In the meantime, I re-opened the Nintendo Game Boy.  And that was what I was looking for. <br><br><h2>  Why is the Game Boy so cool? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/447/518/78d/44751878d5be5df4e754fdee7913d224.jpg" alt="image"><br>  <i>1049 classic games and 576 games for Game Boy Color</i> <br><br>  In the amount of more than 1000 games, a very large variety, high quality, some of them are quite complex (Prince), games can be grouped and assigned complexity for research on knowledge transfer and training (for example, there are options for Tetris, racing games, Mario).  To solve the game Prince of Persia, you may need to transfer knowledge from some other similar game in which the points are clearly indicated (there is no such thing in Prince). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ff/f8e/9e7/5fff8e9e75b38f13eb5161b316c76030.gif"><br>  <i>Nintendo Game Boy is my favorite research platform for knowledge transfer.</i>  <i>On the chart, I tried to group games by complexity (subjectively) and similarities (concepts like racing, jumping, shooting, various games like Tetris; did anyone play HATRIS?).</i> <br><br>  The classic Game Boy has a very simple screen (160x144, 2-bit color), thanks to which the preprocessing becomes simple, and you can concentrate on important things.  At 2600 even simple games have many colors.  In addition, on the Game Boy objects are shown much better, without blinking and without having to take a maximum of two consecutive frames. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/9ae/843/7409ae843366b71257755bc7701af3c8.gif"><br><br>  No crazy memory markup like NES or 2600. Most games can be made to work with 2-3 mappers. <br><br>  Compact code - I managed to fit the entire emulator in C with no more than 700 lines of code, and my implementation of Verilog fits in 500 lines. <br><br>  There is the same simple version of Space Invaders, as in the arcade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10f/5d0/838/10f5d0838acb88b453ff82b778389265.gif"><br><br>  And here it is, my 1989 dot-matrix Game Boy and FPGA version working via HDMI on a 4K resolution screen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/dd5/77d/ca2dd577d1711be2ddb2d3426dc07c39.png"><br><br>  And here's what my old Game Boy can't: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/343/e65/d45/343e65d45de2b5bac8bd31ffccb7be6e.gif"><br>  <i>Tetris, accelerated with the help of iron - recording from the screen in real time, the speed is equal to 1/4 of the maximum.</i> <br><br><h2>  Is there any real benefit from this? </h2><br>  Yes there is.  So far, I have been testing the system under simple conditions, with an external network of rules interacting with individual Game Boys.  More specifically, I used the A3C algorithm (Advantage Actor Critic), and I plan to describe it in a separate post.  My colleague connected it to a convolutional network on an FPGA, and it works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/202/75a/cb720275a2f42cf3e17fc28167ec55f0.png"><br>  <i>How FGPA communicates with the neural network</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/f65/160/da4f6516036832a572de98a4bec081e4.png"><br>  <i>Distributed A3C</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/2b2/607/c3c2b26079064aa7ab6fee6f4a7f373e.gif"><br>  <i>Mario land: the initial state.</i>  <i>Accidentally pressing the keys will not take us far.</i>  <i>In the upper right corner shows the remaining time.</i>  <i>If we are lucky, we will quickly finish the game after touching the gumba.</i>  <i>If not, it will take 400 seconds to ‚Äúlose‚Äù.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/088/0a9/618/0880a9618a01a45c6358469604dea92d.gif"><br>  <i>Mario land: after an hour of play, Mario learned to run, jump, and even opened a secret room, climbing into the pipe.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3b/d37/a82/b3bd37a82e9692319784667a7be9c13c.gif"><br>  <i>Pac Man: after about an hour of training, the neural network even managed to finish the whole game once (after eating all the dots).</i> <br><br><h2>  Conclusion </h2><br>  I want to think that the next decade will be a period when supercomputer computing and AI find each other.  I would like to have hardware that allows me to tune myself up to a certain level in order to adjust to the desired AI algorithm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d06/248/162/d062481627eb1e355c5488ead2ca7ef7.png"><br>  <i>Next decade</i> <br><br>  <a href="https://github.com/krocki/gb">Code for Game Boy in C.</a> <br><br><h2>  Debugging </h2><br>  People often ask me: what was the most difficult?  Everything - the whole project was quite painful.  To begin with, there is no specification for the Game Boy.  All that we learned, we got through reverse engineering, that is, we ran an intermediate task, such as a game, and watched how it is performed.  This is very different from standard software debugging, because here we are debugging the hardware that runs the program.  I had to come up with different ways to implement this.  And I talked about how difficult it is to follow the process when it is running at 100 MHz?  Oh, and no printf is there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9df/173/ab1/9df173ab1b05d831461a16152646be72.png"><br>  <i>One approach to implementing a CPU is to group instructions by their functions.</i>  <i>With 6502 it is much easier.</i>  <i>The LR35092 crammed all sorts of "random" nonsense and there are many exceptions.</i>  <i>I used this table when working with the Game Boy CPU.</i>  <i>I used a greedy strategy - I took the largest piece of instructions, implemented them and crossed them out, then repeated them.</i>  <i>1/4 of the instructions are ALU, 1/4 is the loading of registers, which can be implemented fairly quickly.</i>  <i>On the other side of the spectrum, there are all sorts of individual things, such as ‚Äúdownload from HL to signed SP‚Äù, which had to be processed separately.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96b/ec9/38b/96bec938bbac5dbab9b8c71f6024d31b.jpg"><br>  <i>Debugging: run the code on the hardware you are debugging, write a log of your implementation and additional information (this shows a comparison of the Verilog code on the left with my C-emulator on the right).</i>  <i>Then run diff for logs to find inconsistencies (blue).</i>  <i>One of the reasons for using automation is that in many cases I found problems after millions of execution cycles, when a single CPU flag caused a snowball effect.</i>  <i>I tried several approaches, and this one turned out to be the most effective.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/bea/455/e50bea45577d7225024a0aa66174f9bd.png"><br>  <i>You need a lot of coffee!</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/d2e/4eb/196d2e4ebf91bda8e1943dc5e7f81a89.png"><br>  <i>These books are 40 years old.</i>  <i>It was amazing to rummage through them and look at the world of computers through the eyes of the users of that time - I felt like a guest from the future.</i> <br><br><h2>  OpenAI Research Request </h2><br>  At first, I wanted to work with games in terms of memory, as described in a <a href="https://openai.com/requests-for-research/">post</a> from OpenAI. <br><br>  Surprisingly, making Q-learning work well on input data representing memory states was unexpectedly difficult. <br><br>  This project may not have a solution.  It would be unexpected to learn that Q-learning will never succeed at work with memory in Atari, but there are chances that this task will be quite difficult. <br><br>  Given that the Atari games used only 128 bp of memory, it seemed very attractive to process the 128 b instead of full screen frames.  I got mixed results, so I started to deal with it. <br><br>  And although I cannot prove that memory-based learning is impossible, I can show that the assumption that memory represents the full state of the game is not true.  The CPU Atari 2600 (6507) uses 128 bp of memory, but it still has access to additional registers that live on a separate circuit (TIA, TV adapter, something like a GPU).  These registers are used to store and process information about objects (racket, rocket, ball, collisions).  In other words, they will be inaccessible if only memory is considered.  Also, NES and Game Boy have additional registers that are used to control the screen and scroll.  Only one memory does not reflect the full state of the game. <br><br>  Only 8080 directly stores data in video memory, which allows you to extract the full state of the game.  In other cases, the ‚ÄúGPU‚Äù registers are connected between the CPU and the screen buffer, while outside RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b9/d23/019/0b9d2301998c1cc9dcf414c36fe8e1e3.png"><br><br>  An interesting fact: if you study the history of the GPU, then the 8080 may turn out to be the first ‚Äúgraphics accelerator‚Äù - it has an external shift register, which allows the space invaders to be moved using one command, which offloads the CPU. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HyzD8pNlpwI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/16c/2d0/89916c2d015f8b881ec16411906ab2aa.png"><br>  EOF </div><p>Source: <a href="https://habr.com/ru/post/435506/">https://habr.com/ru/post/435506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435496/index.html">Tesla was sued for an accident in which the driver and passenger Model S died</a></li>
<li><a href="../435498/index.html">vCloud Director Extender: Migration</a></li>
<li><a href="../435500/index.html">Biometric Gloves in Motorsport</a></li>
<li><a href="../435502/index.html">The study revealed the pros and cons of makeovers</a></li>
<li><a href="../435504/index.html">Hand monsters in the fight for cleanliness: the choice of hand-held vacuum cleaner Xiaomi</a></li>
<li><a href="../435508/index.html">How to make the best computers in Russia? Interview with Artyom Smirnov from HYPERPC</a></li>
<li><a href="../435510/index.html">Microelectronics, neurophysiology and machine learning, shake up, but do not mix</a></li>
<li><a href="../435512/index.html">Developers from Royole showed a folding flexible smartphone</a></li>
<li><a href="../435514/index.html">Russia is developing a processor to accelerate neural networks</a></li>
<li><a href="../435518/index.html">Paying customs duty for online purchase will be much easier.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>