<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Sberbank Online applications work: Workflow API and frameworks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people use the Sberbank Online application, but few know how it works. It is time to open the veil of secrecy - in this article we will talk abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Sberbank Online applications work: Workflow API and frameworks</h1><div class="post__text post__text-html js-mediator-article">  Many people use the Sberbank Online application, but few know how it works.  It is time to open the veil of secrecy - in this article we will talk about some of the approaches that we use in the development. <br><img src="https://habrastorage.org/webt/84/p0/g6/84p0g657xehugnowyfxm4wfepqg.jpeg"><br><a name="habracut"></a><br>  There will be no big dates, blockchain, ajail and other rocket science.  But API will be described, on which our most popular applications work.  The value of this article is not in breakthrough ideas, but in approaches and practices that work in a large application with one of the most demanding audiences. <br><br>  We hope that our experience will help readers to make their product better, and most importantly scalable, because most of the bumps in the development of the API, we have already caught and fixed. <br><br><h2>  What will be discussed </h2><br>  We will tell you how payment scripts work in Sberbank Online mobile and web applications, namely about API between applications and server-side. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/zf/tz/k2/zftzk2q2hb9crefrojvgo1ulsq0.jpeg"><br><br>  Why focus on the API?  Everything is simple - it is actually the only bridge that connects client applications and the backend.  If the project is small, then we can easily change the API and rewrite applications for it.  But if the project is large-scale (such as ours), then even small API changes require the involvement of a large amount of resources both at the front and at the back end, and become very expensive.  And the second point - the earlier we fixed the API, the earlier front and back commands could start development.  They just need to come together at one point. <br><br>  First, we will talk a little about our capabilities and limitations, so that it is clear why we chose this and not a different solution, and then we will present the API protocol itself at the top level. <br><br><h3>  Specificity and motivation </h3><br>  <b>Applications are large.</b>  When we wrote this article, the Sberbank Online application on Android took about 800,000 lines of code, on iOS - 500,000 lines of code.  And this is just our code, without the link libraries. <br><br>  <b>Backward compatibility and many users.</b>  MAU - 32 million active users of the mobile application.  And if we do not make backward compatibility at the API level, so many users across the country will have to download applications again.  This is very bad.  By the way, this is one of the reasons why we have so much code. <br><br>  <b>Sberbank Online develops many small teams.</b>  You've probably heard about Agile at Sberbank.  It's true, we work on Agile in teams of 9 people. <br><br>  <b>Banking application: in</b> spite of the fact that the functionality of banking applications is growing very quickly, the main thing that happens in remote banking is a sequential process (processing of client applications).  We call these processes workflow.  These applications can be of different kinds and they are processed by a huge number of interrelated services in the perimeter of the bank. <br><br>  <b>Two types of commands.</b>  There are platform - they are responsible for the development of the application kernel.  And there are feature commands - they create application functionality for end users, using the architecture and tools that the platform gives. <br><br>  <b>Omnicanality</b>  An extremely important story.  In order not to develop back-end several times - separately for mobile applications and separately, for example, for the web version and ATMs, you need to make the API as similar as possible for all channels (at least the response structure should be the same). <br><br><h4>  <i>Mobile app</i> </h4><br>  <b>Data changes dynamically.</b>  The most popular operations in the mobile application are payment and transfer.  The requisites of the service providers, the set of fields that the user needs to fill out, is dynamic information that can change frequently. <br><br>  <b>However, users may not update the application</b> after installing it on the device.  Just because they can.  More often there are good reasons for this, for example, to update the application, you need to update the OS version, and to do this, buy a new phone.  Therefore, we need a solution that will allow us to change data without a release of the application. <br><br>  <b>Mobile Internet:</b> our applications should work everywhere, even where the Internet is unstable and slow.  Therefore, we always fight for the size and number of messages between mobile applications and server-side. <br><br>  <b>The best customer experience:</b> we have chosen for ourselves the basic technology of developing mobile applications - the development in native languages.  This is the only way to get the best customer experience. <br><br>  <b>If you summarize all these requirements, applications should be developed in native languages, have reusable components inside, but all business logic should be managed from the server side.</b> <br><br><h3>  How to do not become </h3><br>  After we have defined the boundary conditions, we will describe what existing solutions we analyzed. <br><br>  <i>JSON programming</i> <br><br>  It is easier to describe logic with code imperatively than to invent (and learn!) A new declarative language, which will always be limited more than the native language of the platform.  In addition, it is necessary to provide a sandbox, error handling, some stage of piloting - pseudo-code should gradually spread to user devices and roll back in case of any failures.  All this complicates development without tangible benefits. <br><br>  <i>CSS 3000</i> <br><br>  We do not use the description of component styles, since they can differ from the form factor, platform, and even the mode of operation (portrait / landscape orientation, responsive in the web).  Declaration of styles in the final implementation will always be better, closer to reality and more correct to work with boundary cases.  In addition, it happens that components with similar logic basically work differently on different devices: for example, entering a phone number with the phonebook on a mobile device and without it on the web. <br><br>  <i>Fixing the data model in the application interface</i> <br><br>  This method is also called "nailing."  The idea is that the application interface is built on the unique identifiers of objects that are transmitted from the server.  In this scheme, any changes on the server side lead to rework of the client part.  Cannot reuse code.  Difficult to maintain. <br>  The only reason why you should choose this method on your project is 99% confidence that the API will not change.  Well, or if the project is quite small and designing an API is more expensive than quickly reworking the user interface for API changes. <br><br>  <i>Styles</i> <br><br>  Add to each object a sign of style.  UI applications build on the basis of this feature.  There are a limited number of styles, so it is possible to build an interface dynamically.  But with the increase in functionality, UI has to increase the number of styles. <br>  In this variant, it becomes possible to control the display of individual elements, but the complexity of the implementation of connectedness between different fields increases.  And most importantly - with increasing UI variability, you will have a constant need to extend the API protocol. <br><br>  <i>JSON API</i> <br><br>  The <a href="http://jsonapi.org/format/1.1/">JSON API</a> describes in detail the recommendations for structuring data and describing the relationships between them, but there is nothing that could describe the presentation.  Our task also includes the visual expansion - adding new input fields, so this option does not suit us. <br><br>  <i>Web Components / React Components API</i> <br><br>  The concept of <a href="https://www.webcomponents.org/introduction">web components</a> , which, among other things, greatly influenced the <a href="https://facebook.github.io/react/docs/components-and-props.html">API of React components</a> , is already much better for us: on the one hand, we have control over the display, on the other hand, it is possible to bind data to UI elements. <br>  Unfortunately, everything is too tied to HTML + CSS + JS.  You do not use it directly, but remember, it will come in handy later. <br><br><h3>  How did you decide to do </h3><br>  <i>UI containers</i> <br><br>  Objects are packaged in containers, the presentation logic of the application is built on these containers.  The main advantage is that we can group several simple objects into one container.  This gives the freedom to program UX / UI on the client, for example, we can control the hiding / display of one field when filling in the data in another.  At the same time, the basic types of objects are a limited number, and all business transport is implemented on them. <br><br>  <b>We chose this approach.</b>  <b>First we describe the API protocol, and then how the frameworks within mobile and web applications are arranged.</b> <br><br><h2>  API </h2><br>  To make it clearer, consider the API on the example of a simple process, for example, transfer between your accounts.  How to get to the entry point, do not consider - this is not a process and for this we have our own API (we will also tell about it somehow).  So the process starts at the entry point: <br><img src="https://habrastorage.org/webt/9p/py/ic/9ppyicdvqqlupmuz3x1tp06demc.jpeg"><br><br><h3>  Data transport </h3><br>  To begin, agree on the basic principles - how to transfer data.  We take the simplest approach as a basis - key-value pairs.  The key will be a string of letters of the Latin alphabet, the value is also a string, but arbitrary. <br><br>  Forms to fill in are complex, with nested elements and subsections, which means that nesting should be allowed.  Keys can be named in the camelCase format, but they can be poorly readable (for example, in logs) or even ‚Äúspoil‚Äù in case-insensitive systems.  You must enter a separator. <br><br>  The most obvious separator is a dot - in many languages ‚Äã‚Äãit is used to access the properties of an object.  With careless use, keys with such a separator will create dictionaries (or objects) in which collisions are possible.  For example, ‚Äúfoo.bar‚Äù ‚Äã‚Äã= ‚Äúfoobar‚Äù and ‚Äúfoo.bar.baz‚Äù = ‚Äúfoobarbaz‚Äù in javascript may entail overwriting the property ‚Äúbar‚Äù of the object ‚Äúfoo‚Äù from line to object.  In the end, we agreed on a colon: on the one hand, the obvious visual separation and semantic reflection of nesting, on the other hand, is safe enough for all the languages ‚Äã‚Äãused. <br><br>  What to do with repeated fields?  We introduce an additional rule: between a pair of delimiters can be either Latin letters or numbers.  Constructs of the form: <b>children: 5: name: first</b> . <br><br>  Having lived for some time with such a structure, we find a restriction: the multiple choice turns out to be nontrivial to implement and requires additional tweaks on the backend in order to keep the load high. <br><br>  <b>Solution: the</b> value is either a string or a list of strings.  So the solution looks typical, but at the same time, the overhead is insignificant. <br><br><h3>  Steps </h3><br>  A step is a state of the process.  The first step with us is the selection of the account for debiting and the account for crediting and entering the amount. <br><img src="https://habrastorage.org/webt/c2/cv/cv/c2cvcvlujaoa4apka3prd_9y2so.jpeg"><br><br>  The UI in this picture is not visible, because the step is about the server logic, and not about the presentation logic.  There are two approaches to working with steps: you can transfer only the difference from the server (the cumulative total in the client application) or each step as a whole (the cumulative total on the server). <br><br>  The analysis of the requirements showed that during the process the screen can be formed differently at different steps (branching processes), so instead of adding control commands to convert already transferred entities, each step is easier to pass completely the way the user should see it. <br><br>  Of the additional advantages: when you return to editing, you do not need to play the entire script or pass an additional parameter ‚Äúgive everything‚Äù.  When starting a step, the client application immediately receives all the necessary information for building screens. <br><br><pre><code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"screens"</span></span>: <span class="hljs-string"><span class="hljs-string">"events"</span></span>: <span class="hljs-string"><span class="hljs-string">"references"</span></span>:</code> </pre> <br><h3>  Screens </h3><br>  A screen is a division of a process into stages in a client application.  As a rule, screens are used to make the form easier to read.  In our case, everything is simple: one step - one screen. <br><img src="https://habrastorage.org/webt/_i/zs/sj/_izssjbp2h_iyzgo73ev5lzgnma.jpeg"><br><br>  For screens, we introduced two rules: <br><br><ol><li>  the transition between screens can only be linear, without branches; </li><li>  the transition between screens does not require interactions with the backend. </li></ol><br>  This means that screens, in fact, become simple groups and can be transferred from the backend immediately upon entering the step. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"screens"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"UI Block"</span></span>: <span class="hljs-string"><span class="hljs-string">"properties"</span></span>:</code> </pre> <br><h3>  UI components (blocks) </h3><br>  A UI component is an independent component that implements client logic and fills a document with data.  In essence, this is an association between the management team in the protocol and a piece of code and markup in the application.  The first screen has three components: <br><br><ol><li>  Charge Account </li><li>  The same component for the enrollment account </li><li>  Transfer amount </li></ol><br><img src="https://habrastorage.org/webt/hi/ab/dr/hiabdrptusvwu3tlcq9z-proskg.jpeg"><br>  Sometimes something can go wrong: for example, a new process was transferred to an old version of an application, or an old version of a block was deleted in a client application, but remained in one of the server application processes.  In this case, the application performs a soft degradation: the block is replaced with a system (simple group of fields), which does not have any additional logic, but simply shows the fields in the composition.  More will be below. <br>  In this case, the form will be less beautiful, but at least the user will be able to fill in the data and send them to the server.  The server then validates the input and returns errors that can be corrected. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"UI Block"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: <span class="hljs-string"><span class="hljs-string">"field"</span></span>:</code> </pre> <br><h3>  Fields </h3><br>  Fields are atomic components that act as a transport for individual data elements and process user input in case of block degradation.  The field types are limited and all are supported at the framework level: text, checkbox, select, multiselect. <br><br>  This means that any version of the application can draw an interface based only on field types. <br><br>  Fields in the UI components from our example: <br><br>  1. The field with reference to the reference book in the account of write-off and account of enrollment  Why link to a static directory?  Because the account we choose from the list of cards (accounts), without unnecessary access to the server. <br><img src="https://habrastorage.org/webt/ym/at/wl/ymatwlr8qojepte9bybbevx0ltw.jpeg"><br><br>  2. Two separate fields for the amount and currency in the amount input component <br><img src="https://habrastorage.org/webt/qs/zy/z4/qszyz4kifwm7mz7jjwvh0eaacuw.jpeg"><br><br>  Thus, the format for the fields has the following structure: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"style"</span></span>: <span class="hljs-string"><span class="hljs-string">"validator"</span></span>:</code> </pre><br><h3>  Developments </h3><br>  Since applications do not know anything about the process, it is logical that events (buttons that the user sees) are also part of the response from the server. <br><br>  We divided events into two types. <br><br>  1) Basic - they are on almost every screen in familiar places for the user.  As an example, these are the events ‚Äúback‚Äù and ‚Äúcontinue‚Äù.  The first one goes back one step, and the second collects the completed data from the client form and sends it to the server along with the ‚ÄúGo to the next step‚Äù command. <br><br>  2) And special ones - for non-standard actions that we cannot predict in advance, and there is no point in putting them into the engine part, as they are rarely used. <br>  In our case, only the main events on the screen - ‚Äúcontinue‚Äù and ‚Äúback‚Äù.  They are implemented at the platform level. <br><img src="https://habrastorage.org/webt/dw/ok/bz/dwokbznvoewxkifgn-rf8zlgupk.jpeg"><br><br>  All events have a number of attributes, such as the type of the event itself, the title and the indication of visibility.  And no server side UI like button size, position and color.  This logic is implemented on the front. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"events"</span></span>: <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"description"</span></span>:</code> </pre> <br><h3>  Directories </h3><br>  With reference books everything is standard.  If it is small, then we send it completely in response from the server and call it static.  This is done in order to minimize the number of requests to the server side and the response time to the user action in the interface.  To display it in the form on the screen, add a field with the type - selectList, one of the properties of which is a link to a static reference. <br><br>  If the directory is large, then it is implemented as a separate rest-service.  In the interface, it looks like a text field, as it is filled, a list of possible options is returned from the directory. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"references"</span></span>: <span class="hljs-string"><span class="hljs-string">"referenceId"</span></span>:</code> </pre> <br><h3>  Validation errors on the client and server </h3><br>  Since the main interface element is a data entry field, it is logical to validate it on the client.  Along with the fields, validation rules and messages are displayed, which are displayed if validation fails. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"validator"</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>:</code> </pre> <br>  <b>The structure of the response looks like this:</b> <br><br><img src="https://habrastorage.org/webt/qx/x_/gg/qxx_ggc2khn0-fderg435e7gyoq.jpeg"><br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"screens"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"UI Block"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: <span class="hljs-string"><span class="hljs-string">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"style"</span></span>: <span class="hljs-string"><span class="hljs-string">"validator"</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: <span class="hljs-string"><span class="hljs-string">"events"</span></span>: <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"references"</span></span>: <span class="hljs-string"><span class="hljs-string">"referenceId"</span></span>:</code> </pre> <br><h2>  Frameworks </h2><br>  Now a little about how frameworks inside applications work with this protocol.  Conditionally, frameworks can be divided into two main parts: the workflow engine + UI container handler.  This separation is caused not only by the application architecture, but also by the organizational structure.  The engine is developed and supported by platform commands, and UI containers are actually extension points and they are programmed by feature commands.  Thus, more commands do not need to make changes to the kernel. <br><br><h3>  Workflow engine </h3><br>  The engine inside the application (web and mobile) knows that the process of working with the document has begun and that according to the protocol a number of attributes will come to it: steps, screens, UI containers and field types.  This data draws the basic interface - the lower and upper menus, the main buttons, the UI on simple field types, if used. <br><br>  At the same time, the engine does not know how many steps of the process will be in the script, how the steps will be divided across the screens and what fields there will be. <br><br>  If the script changes, for example, you need to display a new field, it will be enough to add it to the server response, and the client application will display it.  For this release release of the front-end application is not required. <br><br><h3>  How do UI containers work? </h3><br>  An analysis of the needs of designers and business customers showed that all needs cannot be satisfied by simply expanding the attribute composition of the fields. <br><br>  Therefore, expansion points were needed.  With these extension points, UI components are the native implementation of the code in the applications themselves, which is identified by the engine by name.  In essence, this is a grouping of a field / several fields into a logical block that can display a custom UI.  In this case, the protocol data model is used only for data transport to the backend, the entire UX and UI is implemented on the application side. <br><br>  <i>Two modes of the framework</i> <br><br>  When the engine parses the data model, it compares the list of names of the UI containers with the registry that is stored inside the application.  If the application does not find the name of the component, then the interface is built on simple field types.  The process will be fully operational, but on standard UI elements. <br><br><img src="https://habrastorage.org/webt/bp/jt/i9/bpjti9raurmfl84wj9gcpw_mwiu.jpeg"><br><br>  <i>On the left - how a container can be displayed for entering the amount on a list of simple field types.</i>  <i>On the right, if there is a UI container in the application build.</i>  <i>Despite the fact that in the list of simple fields there is no slider and there is a separate field instead of an icon with a choice of currency, we can transfer all data from PL and the process will be working.</i> <br><br>  And here we get one of the main advantages of the engine - to deliver changes to the user without updating the application.  In the assembly there is a mapping of component names to classes, in which the UI of these components is programmed and the user interface is built on it. <br><br>  <i>What rules we try to follow when working with UI-components:</i> <br><br><ul><li>  Maintain functionality in the mode of the list of simple field types.  Any application project has the temptation to turn a dynamic protocol into a static protocol.  Therefore, we ask everyone to first develop the functionality on a standard UI container, and then enrich UX / UI by adding custom containers on this data model.  This will not only allow future updates on older builds, but also automatically maintains the logical integrity of the API. </li><li>  Do not change the data model (JSON) for the UI container if it is already ready (it is undergoing final testing or already in production).  Since the logic on PL is rigidly connected with the data model, changing it will break the functionality on versions of the mobile application that are not updated.  However, the model can be extended while maintaining backward compatibility. </li><li>  Name your UI component by system name.  Since the name of the UI component is a required attribute of the protocol and there must be at least one on each screen, we introduced a special system name that implements a simple list of fields. </li><li>  Do not implement business logic on UI components.  Logic must be implemented on the server, why - written above. </li></ul><br><h2>  Coming soon ... </h2><br>  We tried very hard to write concisely, but this is the first technical article about the Sberbank Online platform and it should have covered a lot. <br><br>  Write in the comments that it is not clear what is interesting - we will try to write less, but more often and on target.  We have many interesting challenges, and therefore a lot of material. <br><br>  The authors: <br><br><ul><li>  <a href="https://habrahabr.ru/users/dmitry_zadorin/" class="user_link">Dmitry_zadorin</a> Dmitry Zadorin, working on Sberbank Online in the team "Integration Platform", Digital Business Platform, Sberbank and Sbertech </li><li>  <a href="https://habrahabr.ru/users/stcherenkov/" class="user_link">Stcherenkov</a> Stas Cherenkov, web application architect Sberbank Online, Sberbank and Sbertech </li></ul></div><p>Source: <a href="https://habr.com/ru/post/353746/">https://habr.com/ru/post/353746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353734/index.html">Concepts of distributed architecture, which I met when building a large payment system</a></li>
<li><a href="../353736/index.html">Digest news from the world of PostgreSQL. Issue number 5</a></li>
<li><a href="../353738/index.html">Secure SOCKS5 proxy for Telegram for 1 Euro and 10 minutes</a></li>
<li><a href="../353740/index.html">Global lighting using voxel cone tracing</a></li>
<li><a href="../353744/index.html">Red Hat is heading for a hybrid cloud with Enterprise Linux 7.5: what does it mean</a></li>
<li><a href="../353748/index.html">It is not Android. Features of the development under Wear OS</a></li>
<li><a href="../353750/index.html">How fraudsters trick cryptocurrency users, and how to protect digital assets: 3 practical tips</a></li>
<li><a href="../353758/index.html">Raise SOCKS proxy for Telegram</a></li>
<li><a href="../353760/index.html">Personalize it. Report with Avito Data Science Meetup: Personalization</a></li>
<li><a href="../353762/index.html">Small laptop for system administrator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>