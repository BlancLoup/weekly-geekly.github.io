<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About UEFI security, part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the conversation begun in the past about UEFI security, about threats and the existing defenses against them. 
 This time it will be about...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About UEFI security, part two</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/8aa/ea6/135/8aaea61356364273b9779501dc8fb2ed.jpg">  We continue the conversation begun in the past about UEFI security, about threats and the existing defenses against them. <br>  This time it will be about SMM, how it works and works, and why it is the desired target for an attack. <br>  I missed <a href="http://habrahabr.ru/post/266935/">zero and the first part of</a> this opus - I recommend reading them first, I humbly ask the rest for kat. <br><a name="habracut"></a><br><h4>  <b>Part two.</b>  <b>SMM</b> </h4><br><h5>  <b>A little bit of educational program</b> </h5>  Thanks to search engine optimization and network marketing specialists (if they are healthy!), It‚Äôs absolutely impossible to find information on SMM on the SMM web site, you constantly come across offers to increase, speed up and improve, so we will conduct educational campaign without departing from projectile. <br>  <i>System Management Mode</i> is one of the most privileged code execution modes for x86 / amd64-compatible processors, which first appeared in the special SL version of the Intel 80386. Starting from 80486, it is supported by all x86 CPUs, including those made by AMD and VIA. <br>  Initially, SMM was used for OS-independent implementation of automatic power management and system devices, since  to teach this OS of the time was more difficult than adding another execution mode to the processor. <br>  The transition to the SMM mode is performed only with the help of a special interrupt - <abbr title="System Management Interrupt">SMI</abbr> , which is generated in various ways: <br>  - hardware, high level output to SMI output # <br>  - by the system itself, as a result of some events <br>  - programmatically, sending a byte to the CPU IO-register with a given number (most often it is register 0xB2) <br><br><h6>  <b>Hardware SMI</b> </h6>  There is nothing special to write about him: we put pressure on the leg - we have an interruption.  Now rarely used, because  almost all systems now have multifunctional GPIOs that can generate events without interrupting the OS, plus no additional logic is needed to determine who specifically generated hardware SMI, because there are many devices and one leg. <br><br><h6>  <b>System SMI</b> </h6>  There are quite a few sources of system SMIs, I will list only those that can be controlled, including disabling them at the request of the firmware developer, taking the system with the eighth series chipset, i.e.  Haswell / Broadwell processor: <br><ul><li>  <abbr title="USB Host Controller Interface">xHCI</abbr> SMI - generated by a USB controller, allows you to implement legacy USB emulation and boot from USB-drives in DOS </li><li>  <abbr title="Management engine">ME</abbr> SMI - generated by ME, allows working with it systems that do not have a native driver for the main ME interface - <abbr title="Host embedded Controller Interface">HECI</abbr> </li><li>  GPIO unlock SMI - generated when removing the Lock bit from the GPIO pin control registers.  On this SMI, the developer of the firmware may hang its own handler in which to decide whether to allow the OS to manage specific GPIOs or not. </li><li>  Periodic SMI is generated by an internal timer chipset with a configurable frequency of 8/16/23/64 seconds, but usually it is disabled completely. </li><li>  TCO SMI - generated by <abbr title="Total Cost of Ownership">TCO-</abbr> timer, if enabled.  A TCO is such an Intel-specific watchdog countdown timer, which the OS should count every few seconds to tell the watchdog that it is OK.  If the timer reaches zero, an SMI is generated, in the handler of which the system restarts most often. </li><li>  EC SMI - generated by the chipset when accessing the CPU IO-ports of the range 0x62-0x66, on which the <abbr title="Environmental controller">EC</abbr> is usually located, which allows you to set up its emulation or protect its firmware from writing, for example.  Most often, this source is disabled and access to the above range is immediately decoded to the LPC bus, to which the physical EC is connected.  And if it doesn‚Äôt exist, the chipset responds with 0xFF to all requests, and that‚Äôs the end of it. </li><li>  <abbr title="APM Control">APMC</abbr> SMI, generated when writing to the CPU IO-port APM_CNT, more about it in the next section. </li><li>  <abbr title="Sleep">SLP</abbr> SMI is generated when transitioning to the ACPI S1-S5 state, more precisely when trying to set the SLP_EN bit.  With this interrupt, Sx traps are implemented, allowing you to execute some platform-specific code before going to sleep or hibernation. </li><li>  <abbr title="Io trap">IOTR</abbr> SMI, generated when accessing the IO CPU ports.  With the help of this interrupt, IO traps are implemented, which allow to emulate legacy hardware that hung earlier on IO ports, i.e.  SuperIO, keyboard, audio chips, MIDI, COM and LPT ports and some other things.  Your USB keyboard works in DOS only because accessing IO ports 0x60 / 0x64 intercepts either SuperIO or IO Trap. </li><li>  And a couple of others, which need to be talked about for too long, I send all those interested in RTFM to <a href="http://www.intel.de/content/dam/www/public/us/en/documents/datasheets/8-series-chipset-pch-datasheet.pdf">datasheet</a> . </li></ul><br><h6>  <b>SMI software</b> </h6>  Software SMIs are most often generated either by firmware or drivers, but nothing prevents an attacker with administrator rights in the OS (more precisely, the rights to execute the <i>out</i> instruction are required) to also generate them. <br>  Software SMI is generated when writing to the CPU IO-port APM_CNT (most often it is port 0xB2), its number is transmitted as a parameter in the AL register.  Thus, the maximum number of different software SMI handlers in the system is 256, but in reality they range from 0-5 on specialized systems prepared for working with RTOS, up to 15-20 on systems with lots of different hardware that need to be managed without OS intervention. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <b>How is SMM implemented</b> </h5>  For the SMM dispatcher code and SMI handlers, 1-3 real memory areas are allocated, which in all ‚Äúnormal‚Äù execution modes the chipset marks as an MMIO area with a non-existent device, i.e.  for the rest of the world, these areas are a continuous series of 0xFF that cannot be rewritten.  The first area, commonly called <i>ASEG</i> (i.e., ‚ÄúSegment A‚Äù), is intended for so-called.  <i>legacy SMM code</i> , i.e.  old 16-bit SMI handlers, which no longer exist on modern systems.  The segment got its name because it is located at fixed physical addresses 0xA0000 - 0xBFFFF.  The second area with fixed addresses is <i>HSEG</i> (i.e., ‚Äúhigh segment‚Äù), previously it was at 0xFEDA0000 - 0xFEDBFFFF, but on modern systems it is not used, because  there is a much more convenient segment with customizable addresses and sizes ‚Äî <i>TSEG</i> (i.e., ‚Äútop segment‚Äù), in which 99% of the code executed in SMM are now located, and in ASEG there is only a small stub for compatibility. <br>  When switching to SMM, the processor retains almost the entire context (i.e. the contents of almost all registers, which ones are not saved ‚Äî depends on the specific micro-architecture), and the SMI handlers have full access to the saved context, and therefore it can communicate with the system through changing saved values. <br>  For an OS, a call to SMM code looks like a magical change in the contents of registers and memory, and although it is still possible to track the length of stay in SMM by indirect signs, and the fact of transition into it is direct, by reading the MSR_SMI_COUNT register before and after calling the program interrupt but it cannot affect the length of the SMI OS handler, so SMM is not very compatible with hard-RTOS (it is worth noting that the entire x86 architecture is compatible with them quite a time, but this is another story). <br>  With the default settings, the code working in SMM has full access to all physical memory for reading and writing, full access to all connected devices, in general, it can do almost everything, and is independent of the OS and is not accessible from it even for reading, which is very makes it difficult to analyze and makes the code of SMI handlers a very attractive target for an attack.  Moreover, if the attacked system is accessible from the SMM record on the SPI chip (and it is available in all cases, except for systems with PFAT enabled, which cannot be found with fire, Read-only BIOS systems, which are even less common, and systems protected by PR registers), then a successful attack can end up writing its code in the BIOS, followed by theft, murder, and lewdness with geese.  That is why protecting the SMM from inserting malicious code there is vital. <br><br><h5>  <b>SMM attacks and protection against them</b> </h5><h6>  <b>Forgotten D_LOCK</b> </h6>  The code in SMRAM does not appear on its own, first you need to configure SMRAM itself, initialize the physical memory, configure TSEG so that all handlers fit in there, copy the code of the SMM dispatcher and handlers there, set up descriptor tables there - in general, establish strict statutory order, after which it is necessary to remove the D_OPEN bit so that no one else spoils anything there, and set the D_LOCK bit so that D_OPEN cannot be put back.  On some older systems, it was forgotten to install D_LOCK, and there the SMM was exposed to all winds, but this is no longer the case in the UEFI era, so this attack vector has gone down in history. <br><br><h6>  <b>SMM cache poisoning</b> </h6> Another historical attack is <a href="http://invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf">SMRAM cache poisoning</a> , which was published in 2009 by Rafal Wojtczuk and Joanna Rutkowska.  The essence of the attack is short - we change the memory type for the SMRAM region to Write-Back, organize our SMRAM code to write to the SMRAM region, do not write to the memory, but our code remains in the second-level cache, after which we generate software SMI and the processor does not read the data from SMRAM, and from the cache, and executes our malicious code.  The problem was solved radically - CPU manufacturers banned the installation of WB mode on SMRAM, and therefore the system with UEFI is not affected by this vulnerability. <br><br><h6>  <b>SMM call-out, she is SMM incursion attack</b> </h6>  But enough history, let's move on to the "modern" attacks.  Let's begin, perhaps, with the very SMM Incursion Attack, about which Comrade.  <a href="https://habr.com/users/maseal/" class="user_link">maseal</a> mentioned in the <a href="http://habrahabr.ru/post/266935/">comments</a> to the first part.  I specifically put the word ‚Äúmodern‚Äù in quotation marks, because this attack was a hundred years old at lunch, it was first reported about it in 2008 as a problem for the then BIOSs, but in 2015 it was <a href="http://www.legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full2.pdf">rediscovered by</a> Corey Kallenberg and Xeno Kovah again.  The attack is as simple as mooing - if an SMI handler calls any code outside of SMRAM, then an attacker with write access to physical memory can replace the called code with his own and execute it in SMM mode this way.  And since  Since UEFI developers are accustomed to the availability of EFI Runtime services, these same services were consistently called from SMI handlers for every other (most often these were calls to GetVariable, SetVariable, and ResetSystem).  Vulnerability has been exposed to so many systems that it is easier to say where they were not.  In my rough estimate, if your UEFI is older than May-June 2015 for build date, it is guaranteed to have a couple of SMI handlers vulnerable to this attack.  Cleaning the system from such buggy handlers is quite difficult, and since  Previously, this behavior was not considered a vulnerability at all (‚ÄúWhat kind of fool would get services to hook that ?!‚Äù) and that it was impossible to do this was not known to simple <abbr title="Independent BIOS Vendor">IBV</abbr> coders ‚Äî even now, updates for runtime drivers are prone to this problem .  All very sad in general. <br>  To protect against calling an external SMRAM code, Intel engineers added a special MSR_SMM_FEATURE_CONTROL, after setting a certain bit in which calling this code generates a non-maskable and unrecoverable <abbr title="Machine Check Exception">MCE</abbr> , but there is such a MSR only in Haswell and newer CPUs, and this feature is enabled only on firmware debugging time, otherwise users may come to the door of the R &amp; D department with forks and dubjees for incomprehensible hangs on level ground - most people need to work now, and this is all your security is overhyped.  For owners of older systems and systems based on AMD processors, Phoenix engineers found an <a href="http://www.uefi.org/sites/default/files/resources/UEFI_Plugfest_May_2015%2520Firmware%2520-%2520Securing%2520SMM.pdf">ingenious solution of their own</a> - to use NX bits, adjusting the memory for the SMM code so that the code call outside SMRAM ends with Page Fault, which can then be processed, and Do not hang tightly on the MCE.  I repent, I haven‚Äôt implemented this decision yet, but when the hands reach, I will definitely do it. <br>  A simple user can be protected from this attack only by not allowing the execution of an incomprehensible code from the root, but this, unfortunately, is almost impossible on modern operating systems - there are options for local elevation of rights, and the sea remains how many such 0day exploits are on hand and turnover is impossible to say.  It remains only to quote the aforementioned Xeno Kovah: <br><blockquote>  Please, please, go apply patches! </blockquote><br><h6>  <b>DMA attack</b> </h6>  Another interesting attack, this time - with the help of its own chipset.  The fact is that modern chipsets have a <abbr title="Direct memory access">DMA</abbr> controller, which is used to unload the CPU from transferring data from memory to memory, both between DRAM and between DRAM and memory of PCIe devices.  Moreover, to initiate such a transfer can both the OS and the PCIe device, which can also have its own DMA controller.  Moreover, in the case of initiation from the OS, the chipset performs the data access operation, i.e.  if any processor settings affect it, it is rather weak.  Those.  An attacker with administrative rights initiates a DMA with a memory area controlled by it on the one hand and SMRAM on the other, and gets full access to it.  The same can be done by the firmware controlled by the attacking PCIe device.  To protect against DMA attacks, Intel's DMA controllers have a TSEGMB register in which the TSEG location information is duplicated, and the Lock bit, which prohibits this content to be changed.  If the authors of the firmware forgot to install (or restore at the start after S3, but this is in the next part) - you can attack.  I do not know if AMD chipsets have protection against DMA attacks, but I will try to find out in the near future. <br><br><h6>  <b>SMM cross-buffer attack</b> </h6>  Introduced by <a href="http://www.intelsecurity.com/advanced-threat-research/about-atr.html">specialists from Intel ATR</a> attack on SMI handlers, which take as a parameter a pointer and buffer size, and write to it.  The attacker can pass the pointer and size so that the buffer crosses the RAM-SMRAM boundary, but since  If the SMI handler has access to SMRAM, then it will overwrite some of the data at the beginning of SMRAM.  With the best of luck (i.e., after about 500 hours of debugging at least), the handler can rewrite the service structures of the SMM dispatcher or other handlers in the desired attacking manner, and he will be able to execute arbitrary SMM code.  The attack is hellishly complex and targeted, but quite possible, so from the beginning of 2015, all SMI handlers that take pointers to the buffer must validate it before use.  On older systems, the attack will work, but the likelihood that you will be hacked through it is low. <br><br><h4>  <b>Conclusion</b> </h4><br>  Well, now we have understood more or less with SMM, in the next part we will <a href="http://habrahabr.ru/post/267237/">talk about attacks on S3 BootScript</a> . <br>  Thank you for your attention, safe for you firmware. <br><br>  <b>PS</b> <br>  I can not thank Comrade.  <a href="https://habr.com/users/d_olex/" class="user_link">d_olex</a> for his articles on SMM and attacks on him - <a href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html">one</a> and <a href="http://blog.cr4.sh/2015/09/breaking-uefi-security-with-software.html">two</a> <a href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html">times</a> .  For those interested in the topic and who can read in English - both are required to read. </div><p>Source: <a href="https://habr.com/ru/post/267197/">https://habr.com/ru/post/267197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267187/index.html">How I became a programmer. The path from St. Petersburg homeless to Senior Developer for 6 years</a></li>
<li><a href="../267189/index.html">IP monitoring in blacklists using Zabbix</a></li>
<li><a href="../267191/index.html">jQuery Autocomplete: passing parameters from one field to another</a></li>
<li><a href="../267193/index.html">News from the front about licensing products JetBrains</a></li>
<li><a href="../267195/index.html">IBM and Xerox: Mobile Devices Will Soon Be Driven By Thought</a></li>
<li><a href="../267199/index.html">Alibaba launches productive and energy efficient data center</a></li>
<li><a href="../267201/index.html">How Netflix Finds Failed Servers</a></li>
<li><a href="../267203/index.html">Rust disciplining programming language</a></li>
<li><a href="../267205/index.html">Regular expressions in Java using the example of an email address</a></li>
<li><a href="../267207/index.html">"Wooden" data center group Inoventica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>