<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Variadic templates. Tuples, unpacking and more</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I will talk about templates with a variable number of parameters. As an example, the simplest implementation of the tuple class will be g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Variadic templates. Tuples, unpacking and more</h1><div class="post__text post__text-html js-mediator-article">  In this post I will talk about templates with a variable number of parameters.  As an example, the simplest implementation of the <i>tuple</i> class will be given.  I will also talk about unpacking <i>tuple</i> 'a and substitutions, the values ‚Äã‚Äãstored there as function arguments.  And finally, I will give an example of using the techniques described above to implement deferred function execution, which can be used, for example, as an analogue of <i>finally</i> blocks in other languages. <br><a name="habracut"></a><br><h4>  Theory </h4><br>  A template with a variable number of parameters ( <i>variadic template</i> ) is a template of a function or class that accepts the so-called <i>parameter pack</i> .  When declaring a template, it looks like this. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>‚Ä¶ Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_type</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  Such a record means that a template can take 0 or more types as its arguments.  In the body of the same template, the syntax for using is slightly different. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>‚Ä¶ Args&gt; <span class="hljs-comment"><span class="hljs-comment">//  void foo(Args‚Ä¶ args); // </span></span></code> </pre><br>  The call <i>foo (1,2.3, ‚Äúabcd‚Äù) is</i> instantiated into <i>foo &lt;int, double, const char *&gt; (1, 2.3, ‚Äúabcd‚Äù)</i> .  The <i>parameter pack</i> has many interesting properties (for example, they can be used in lambda capture sheets or in <i>brace-init-lists</i> ), but now I would like to focus on two properties that I will actively use further on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. A variadic parameter can be used as an argument of a function call, apply caste operations to it, etc.  At the same time, it is revealed depending on the position of the ellipsis, namely, the expression directly adjacent to the ellipsis is revealed.  It sounds incomprehensible, but with an example I think everything will become clear. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } template&lt;typename... Args&gt; void foo2(Args... args) { foo(bar(args)...); }</span></span></code> </pre><br><br>  In this example, in the <i>foo2</i> function, since the ellipse is after calling <i>bar ()</i> , then first for each value from args the function <i>bar () is</i> called, and the values ‚Äã‚Äãreturned by <i>foo ()</i> will fall into <i>bar ()</i> . <br>  Some more examples. <br><br><pre> <code class="cpp hljs">(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args&amp;..) <span class="hljs-comment"><span class="hljs-comment">// -&gt; (const T1&amp; arg1, const T2&amp; arg2, ...) ((f(args) + g(args))...) // -&gt; (f(arg1) + g(arg1), f(arg2) + g(arg2), ...) (f(args...) + g(args...)) // -&gt; (f(arg1, arg2,...) + g(arg1, arg2, ...)) (std::make_tuple(std::forward&lt;Args&gt;(args)...)) // -&gt; (std::make_tuple(std::forward&lt;T1&gt;(arg1), std::forward&lt;T2&gt;(arg2), ...))</span></span></code> </pre><br><br>  2. The number of parameters in the pack can be obtained using the <i>sizeof</i> operator <i>...</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(args) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.3</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre><br><br><h4>  Tuple </h4><br>  The <i>Tuple</i> class is interesting, as it seems to me, not so much so that the <i>variadic templates</i> (you can do without them) are used to write and create auxiliary functions, but rather because the <i>tuple</i> is a recursive data structure, a newcomer from another functional world (hi Haskell), which in turn once again shows how versatile C ++ can be. <br>  I will give you a simplest implementation of this class sketched out on the knee, which, nevertheless, shows the basic technique of working with <i>variadic</i> templates - ‚Äúbiting off the head‚Äù of a package of parameters and recursive processing of the ‚Äútail‚Äù, which, by the way, is also widely distributed in functional languages. <br>  So. <br>  The base class template is never instantiated, therefore without a body. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><br>  The main specialization of the template.  Here we separate the ‚Äúhead‚Äù of the parameter types and the ‚Äúhead‚Äù of the arguments passed to us in the constructor.  We keep this argument in the current class, the rest will be recursively taken up by the base ones.  We can access the base class data to access the base class data. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Tail&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple</span></span></span><span class="hljs-class">&lt;Head, Tail...&gt; :</span></span> tuple&lt;Tail...&gt; { tuple(Head h, Tail... tail) : tuple&lt;Tail...&gt;(tail...), head_(h) {} <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> tuple&lt;Tail...&gt; base_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Head value_type; base_type&amp; base = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;base_type&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Head head_; };</code> </pre><br><br>  The final touch (as usual in functional languages) is to specialize the bottom of the recursion. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple</span></span></span><span class="hljs-class">&lt;&gt; {</span></span>};</code> </pre><br><br>  In general, the required minimum has already been written.  You can use our class as follows: <br><br><pre> <code class="cpp hljs"> tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">2.34</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; t.head_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; t.base.head_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; t.base.base.head_ &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  However, manually counting how many times it is necessary to write .base to get to the element we need is not very convenient, so the standard library has a <i>get ()</i> function template that allows you to get the contents of the Nth element of the object of the <i>tuple</i> class.  We are forced to wrap a function in a structure in order to circumvent the ban on partial specialization of functions.  In this basic pattern, there is also a ‚Äúbiting of the head‚Äù from tupl and redirection to the next type <i>getter</i> with an index value one less than in the case of the type of the element, and, in fact, the function of obtaining this element. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> getter&lt;I<span class="hljs-number"><span class="hljs-number">-1</span></span>, Args...&gt;::return_type return_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple&lt;Head, Args...&gt; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getter&lt;I<span class="hljs-number"><span class="hljs-number">-1</span></span>, Args...&gt;::get(t); } };</code> </pre><br><br>  And only when we hit the bottom of recursion, can the first real actions be done.  The type of the return value, we take this time from stupid and return the same value taken from there. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getter</span></span></span><span class="hljs-class">&lt;0, Head, Args...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple&lt;Head, Args...&gt;::value_type return_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple&lt;Head, Args...&gt; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t.head_; } };</code> </pre><br><br>  Well, as is usually the case, a small helper function is written, which saves us from having to manually write the parameters of the structure template. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Head, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> getter&lt;I, Head, Args...&gt;::<span class="hljs-function"><span class="hljs-function">return_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tuple&lt;Head, Args...&gt; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getter&lt;I, Head, Args...&gt;::get(t); }</code> </pre><br><br>  We use this function. <br><br><pre> <code class="cpp hljs"> test::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">2.34</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; t.head_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; t.base.head_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; t.base.base.head_ &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(t) &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(t) &lt;&lt; ‚Äú ‚Äú &lt;&lt; get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(t) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h4>  Unpacking </h4><br>  Unpacking a <i>tuple</i> in C ++!  What could be cooler =)?  This feature seemed so important to the creators of Python that they even added a special syntax to the language to support this operation.  Now we can use it in C ++.  This can be implemented in different ways (at least outwardly, the principle itself is the same everywhere), but I will show here the simplest solution in my opinion.  In addition, it resembles what we saw above in the implementation of <i>getter</i> 'a to extract stupid elements.  Property number 1, described in the theory above, will help us here.  Our decompression function should look something like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>‚Ä¶ N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, Tuple&amp;&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t))...); }</code> </pre><br><br>  As you remember, <br><pre> <code class="cpp hljs">f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t))...);</code> </pre><br>  unpacked in <br><pre> <code class="cpp hljs"> f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N1&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t)), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N2&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t)), ...)</code> </pre><br><br>  But there is one problem, namely, in such a function you will need to manually specify all the template template arguments, and specify them correctly (in the right order and the right amount).  It would be very good if we could automate this process.  To do this, we proceed in a manner similar to the approach to extracting elements from a blunt way. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Enough, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TotalArgs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, Tuple&amp;&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_impl&lt;F, Tuple, TotalArgs == <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(N), TotalArgs, N..., <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(N) &gt;::call(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t)); } };</code> </pre><br><br>  Here, I think, it is worth explaining in more detail.  Let's start with the template parameters.  With <i>F</i> and <i>Tuple,</i> I think everything is clear.  The first one is responsible for our <i>callable</i> object, the second one, in fact, for tuple, from which we will take objects and <i>slip callable</i> 'as arguments for the call.  Next comes the boolean parameter <i>Enough</i> .  It signals whether enough int parameters were typed in <i>... N</i> and we will further specialize our template.  Finally, <i>TotalArgs</i> - a value equal to the size of a stupid  In the <i>call</i> function, as before, we redirect the call to the next instantiation of the template recursively. <br>  At the same time in the very first call the type will be <pre> <code class="cpp hljs">call_impl&lt;F, Tuple, TotalArgs == <span class="hljs-number"><span class="hljs-number">1</span></span>, TotalArgs, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// (N‚Ä¶ - , sizeof...(N) = 0)</span></span></code> </pre>  in the second <pre> <code class="cpp hljs">call_impl&lt;F, Tuple, TotalArgs == <span class="hljs-number"><span class="hljs-number">2</span></span>, TotalArgs, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// (N‚Ä¶ =0, sizeof...(N) = 1)</span></span></code> </pre>  etc.  that is exactly what we need. <br><br>  Finally, we need specialization, in which real actions will be performed, our function will finally be called with the necessary arguments.  This specialization is as follows <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TotalArgs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>... N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_impl</span></span></span><span class="hljs-class">&lt;F, Tuple, true, TotalArgs, N...&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, Tuple&amp;&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t))...); } };</code> </pre><br><br>  Also auxiliary function will not interfere. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, Tuple&amp;&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;Tuple&gt;::type type; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_impl&lt;F, Tuple, <span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;type&gt;::value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;type&gt;::value &gt;::call(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t)); }</code> </pre><br><br>  Here, I think, everything is transparent. <br>  You can use it as follows. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"foo: "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; d &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; t1(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; call(foo, t1) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h4>  Defer </h4><br>  The above techniques allow you to organize lazy, pending calculations.  As a particular example of such calculations, I will consider here the situation when you need to perform some kind of functional, no matter how we exit the function, regardless of the conditional constructions inside, and whether the exception was caused.  This behavior is similar to finally blocks in pythons and Java or, for example, in the Go language there is a defer operator that provides the behavior described above. <br>  I want to make a reservation right away that, like many other things in C ++, this task can be solved in various ways, for example, using <i>std :: bind</i> or lambda, which collects arguments and returns another lambda, etc.  But also storing the <i>callable</i> object and stupid with the necessary arguments is quite appropriate. <br>  Actually, knowing what we already know, the implementation is trivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">defer</span></span></span><span class="hljs-class"> {</span></span> defer(F f, Args&amp;&amp;... args) : f_(f), args_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)) {} F f_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; args_; ~defer() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { call(f_, args_); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} } };</code> </pre><br><br>  As usual, the helper function <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; defer&lt;F, Args...&gt; make_deferred(F f, Args&amp;&amp;... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defer&lt;F, Args...&gt;(f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); }</code> </pre><br><br>  And use <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d = make_deferred(foo, <span class="hljs-number"><span class="hljs-number">1</span></span> ,<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/228031/">https://habr.com/ru/post/228031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228015/index.html">Pulse Habra</a></li>
<li><a href="../228019/index.html">The world's largest radio telescope completed and working at full capacity</a></li>
<li><a href="../228021/index.html">How I wrote my chat</a></li>
<li><a href="../228023/index.html">Work with geolocations in highload mode</a></li>
<li><a href="../228025/index.html">Discov3ry: extruder nozzle to a conventional 3D printer for working with ... chocolate cream, silicone, polyurethane, clay</a></li>
<li><a href="../228033/index.html">Westone Company History</a></li>
<li><a href="../228035/index.html">Astro Tracker Field Tests</a></li>
<li><a href="../228037/index.html">Inheritance grammars in Sprache (or another customizable expression calculator for .NET)</a></li>
<li><a href="../228039/index.html">What experiments Facebook puts on its users</a></li>
<li><a href="../228041/index.html">Storage Performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>