<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Theory and practice of source code parsing with ANTLR and Roslyn</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our project PT Application Inspector implements several approaches to source code analysis in various programming languages: 


- search by signatures...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Theory and practice of source code parsing with ANTLR and Roslyn</h1><div class="post__text post__text-html js-mediator-article"><p>  Our project <a href="http://www.ptsecurity.ru/appsecurity/application-inspector/">PT Application Inspector</a> implements several approaches to source code analysis in various programming languages: </p><br><ul><li>  search by signatures; </li><li>  study of the properties of mathematical models obtained as a result of static abstract interpretation of code; </li><li>  dynamic analysis of the deployed application and verification of the results of static analysis on it. </li></ul><br><p>  Our series of articles is devoted to the structure and principles of the signature search module (PM, pattern matching).  The advantages of such an analyzer are speed, simplicity of the template description and scalability in other languages.  Among the shortcomings, it is possible to highlight the fact that the module is not able to analyze complex vulnerabilities that require building high-level models of code execution. </p><br><p> <a href="https://habrahabr.ru/post/210772/"><img align="right" src="https://habrastorage.org/files/879/56c/123/87956c123b5248f58393586831153cd4.png"></a> <br>  Among others, the following requirements were formulated for the module being developed: </p><br><ul><li>  support of several programming languages ‚Äã‚Äãand simple addition of new ones; </li><li>  support for analyzing code containing syntactic and semantic errors; </li><li>  The ability to describe templates in a universal language (DSL, domain specific language). </li></ul><br><p>  In our case, all templates describe any vulnerabilities or shortcomings in the source code. </p><br><p>  The entire code analysis process can be broken down into the following steps: </p><br><ol><li>  parsing into a language dependent view (abstract syntax tree, AST); </li><li>  AST to language independent uniform format; </li><li>  direct comparison with the templates described on DSL. </li></ol><br><p>  This article is devoted to the first stage, namely: parsing, comparing the functionality and features of various parsers, applying the theory in practice using the example of Java, PHP, PLSQL, TSQL and even C # grammars.  The remaining stages will be discussed in the following publications. </p><a name="habracut"></a><br><h2 id="soderzhanie">  Content </h2><br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Parsing theory</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Terminology</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Types of formal languages</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">ANTLR</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Roslyn</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Parsing issues</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Keywords as identifiers</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Ambiguity</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Processing spaces, comments</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Parsing error handling</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Errors in ANTLR</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Errors in Roslyn</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">From theory to practice</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Java and Java8 grammar</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Php grammar</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Register-independent keywords</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Lexical modes for PHP, HTML, CSS, JavaScript</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Complex context-dependent constructs</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">T-SQL grammar</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">PL / SQL grammar</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">C # grammar</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Preprocessor directives</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">String interpolation</a> </li></ul></li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Testing</a> <br><ul><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">The correctness of parsers ANTLR</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Speed ‚Äã‚Äãparsers ANTLR and Roslyn</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Error handling mechanisms in ANTLR and Roslyn</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Memory consumption</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Conclusion</a> </li><li>  <a href="https://habr.com/ru/company/pt/blog/210772/">Sources</a> </li></ul><br><a name="parsing-theory"></a><br><h2 id="teoriya-parsinga">  Parsing theory </h2><br><p>  At the beginning, the question may arise: why build a unified AST, develop graph matching algorithms instead of using regular regular expressions?  The fact is that not all patterns can be simply and conveniently described using regular expressions.  It is worth noting that, for example, in C #, regular expressions have the power of context-free grammars thanks to named groups and backlinks (however, the process of writing patterns using such expressions will be <del>  accompanied by other obscene expressions </del>  complex).  On this occasion there is also an <a href="https://habrahabr.ru/company/pvs-studio/blog/109480/">article</a> from the PVS-Studio developers.  In addition, the connectedness of the resulting unified AST will allow it to be used in the future to build more complex code execution representations, such as the <a href="https://user.informatik.uni-goettingen.de/~krieck/docs/2014-ieeesp.pdf">graph of code properties</a> . </p><br><a name="terminology"></a><br><h3 id="terminologiya">  Terminology </h3><br><p>  Those familiar with the theory of parsing may skip this section. </p><br><p>  <strong>Parsing</strong> is the process of transforming source code into a structured form.  A typical parser is a combination of a lexer and a parser.  <strong>Lexer</strong> groups source code symbols into meaningful sequences called lexemes.  After this, the type of the token is determined (identifier, number, string, etc.).  A token is a collection of the value of a token and its type.  In the example in the figure below, the tokens are <em>sp</em> , <em>=</em> , <em>100</em> .  A parser from a stream of tokens builds a coherent tree structure, which is called a parse tree.  In this case, <em>assign</em> is one of the nodes in the tree.  An abstract syntax tree or <strong>AST</strong> is a parse tree at a higher level, from which non-relevant tokens, such as parentheses, commas, are removed.  However, there are parsers in which the lexing and parsing steps are combined. </p><br><p><img src="https://habrastorage.org/files/6c4/385/fbe/6c4385fbe3d8471982c9b2a030106d38.png" alt="Lexer &amp; Parser description"></p><br><p>  Rules are used to describe the various AST nodes.  The union of all the rules is called the <strong>grammar of the</strong> language.  There are tools that generate code for a specific platform (runtime) for parsing languages ‚Äã‚Äãbased on grammars.  They are called parser generators.  For example, <em>ANTLR</em> , <em>Bison</em> , <em>Coco / R.</em>  However, often the parser is written by hand for certain reasons, for example <em>Roslyn</em> .  The advantages of the manual approach are that the parsers, as a rule, are more productive and readable. </p><br><p>  Since the project was originally decided to develop on .NET technologies, it was decided to use Roslyn for analyzing C # code, and for other languages ‚Äã‚Äã- ANTLR, since the latter supports .NET runtime, and other alternatives have fewer features. </p><br><a name="formal-language-types"></a><br><h3 id="vidy-formalnyh-yazykov">  Types of formal languages </h3><br><p>  According to the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B5%25D1%2580%25D0%25B0%25D1%2580%25D1%2585%25D0%25B8%25D1%258F_%25D0%25A5%25D0%25BE%25D0%25BC%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">Chomsky hierarchy</a> , there are 4 types of formal languages: </p><br><ul><li>  regular, example: <strong>a <sup>n</sup></strong> </li><li>  context-free (KS, example: <strong>a <sup>n</sup> b <sup>n</sup></strong> ) </li><li>  context-sensitive (short-circuit, example: <strong>a <sup>n</sup> b <sup>n</sup> c <sup>n</sup></strong> ) </li><li>  turing-full. </li></ul><br><p>  Regular expressions allow to describe only the simplest constructions for matching, which, however, cover most of the tasks in everyday practice.  Another advantage of regular expressions is that their support is included in most modern programming languages.  Turing-complete languages ‚Äã‚Äãhave no practical application because of their complexity both in writing and in parsing (from esoteric one can recall <a href="https://ru.wikipedia.org/wiki/Thue">Thue</a> ). </p><br><p>  At present, almost the entire syntax of modern programming languages ‚Äã‚Äãcan be described with the help of KS grammars.  If we compare the parsers of KS languages ‚Äã‚Äãand regular expressions ‚Äúon fingers‚Äù, then the latter have no memory.  And if we compare the parsers of KZ and KS languages, the latter do not remember the rules visited earlier. </p><br><p>  In addition, the language in one case may be the COP, and in the other - short-circuit.  Given semantics, i.e.  consistency with language definitions, in particular, type consistency, the language can be considered as short-circuit.  For example, <strong>T</strong> a = new <strong>T</strong> ().  Here the type in the constructor on the right should be the same as the one on the left.  It is usually advisable to check the semantics after the parsing stage.  However, there are syntactic constructions that can not be parsed using KS grammars, for example <strong>Heredoc</strong> in PHP: $ x = &lt;&lt;&lt; <strong>EOL</strong> Hello world <strong>EOL</strong> ;  In it, the <strong>EOL</strong> token is a marker of the beginning and end of the discontinuous line, therefore, the value of the visited token is required.  This article focuses on the analysis of such KS- and KZ- languages. </p><br><a name="antlr"></a><br><h3 id="antlr">  ANTLR </h3><br><img align="left" src="https://habrastorage.org/files/3ce/bab/ae6/3cebabae6be0455587bc3a379dc7a4f9.png"><br><p>  This parser generator is <a href="https://ru.wikipedia.org/wiki/LL-%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580">LL (*)</a> , it has existed for more than 20 years, and in 2013 its 4th version was released.  Now its development is conducted on GitHub.  At the moment, it allows you to generate parsers in Java, C #, Python2, Python3, JavaScript.  On the approach of C ++, Swift.  I must say, now in this tool it is quite simple to develop and debug grammars.  Despite the fact that LL grammars do not allow left-recursive rules, in ANTLR, starting with the 4th version, it became possible to record such rules (except for rules with hidden or indirect left-recursion).  When generating a parser, such rules are transformed into ordinary non-left-recursive ones.  This shortens the entry of, for example, arithmetic expressions: </p><br><pre><code class="hljs objectivec">expr : expr <span class="hljs-string"><span class="hljs-string">'*'</span></span> expr | expr <span class="hljs-string"><span class="hljs-string">'+'</span></span> expr | &lt;assoc=right&gt; expr <span class="hljs-string"><span class="hljs-string">'^'</span></span> expr | <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ;</code> </pre> <br><p>  In addition, in the 4th version, the parsing performance is significantly improved due to the use of the Adaptive LL algorithm (*).  This algorithm combines the advantages of relatively slow and unpredictable GLL and <a href="https://en.wikipedia.org/wiki/GLR_parser">GLR</a> algorithms, which, however, are capable of resolving cases with ambiguity (used in parsing natural languages), and standard, fast LL-algorithms of recursive descent, which, in turn, are not capable of resolving all ambiguity problems.  The essence of the algorithm lies in the pseudo-parallel launch of LL parsers on each rule, their caching and the selection of a suitable prediction (unlike GLR, where several alternatives are acceptable).  Thus, the algorithm is dynamic.  Despite the fact that the worst theoretical complexity of the algorithm is O (n <sup>4</sup> ), in fact the speed of parsing for existing programming languages ‚Äã‚Äãis linear.  Also in the fourth version, the possibility of restoring the parsing process after detecting syntax errors has evolved greatly.  Learn more about the ANTLR 4 algorithms and how they differ from other parsing algorithms written in <a href="http://www.antlr.org/papers/allstar-techreport.pdf">Adaptive LL (*) Parsing: The Power of Dynamic Analysis</a> . </p><br><a name="roslyn"></a><br><h3 id="roslyn">  Roslyn </h3><br><img align="left" src="https://habrastorage.org/files/61a/5a4/317/61a5a4317bc345168dd59139e2490ec1.png"><br><p>  Roslyn is not just a parser, but a complete tool for parsing, analyzing and compiling C # code.  It is also being developed on GitHub, but it is much younger than ANTLR.  This article only discusses its ability to parse without semantics.  Roslyn parsit the code into a reliable (fidelity), immutable (immutable) and thread-safe (threadsafe) tree.  The validity lies in the fact that such a tree can be converted back into a character code into a character, including spaces, comments, and preprocessor directives, even if it contains syntax errors.  Immutability makes it easy to process a tree in several threads, because each stream creates a ‚Äúsmart‚Äù copy of the tree, in which only changes are stored.  This tree can contain the following objects: </p><br><ul><li>  <strong>Syntax Node</strong> is a non-terminal tree node containing several other nodes and representing a specific construction.  It may also contain an optional node (for example, ElseClauseSyntax for if); </li><li>  <strong>Syntax Token</strong> - a terminal node that displays a keyword, identifier, literal or punctuation; </li><li>  <strong>Syntax Trivia</strong> is a terminal node that displays a space, comment, or preprocessor directive (can be safely removed without losing any code information).  Trivia cannot have a parent.  These nodes are indispensable for transforming a tree back into code (for example, for refactoring). </li></ul><br><a name="parsing-problems"></a><br><h2 id="problematika-parsinga">  Parsing issues </h2><br><p>  When developing grammars and parsers, there are some problems that need to be solved. </p><br><a name="keywords-as-identifiers"></a><br><h3 id="klyuchevye-slova-kak-identifikatory">  Keywords as identifiers </h3><br><p>  It often happens that when parsing keywords can also be identifiers.  For example, in C #, the <code>async</code> keyword placed before the signature of the <code>async Method()</code> method means that this method is asynchronous.  But if this word will be used as the variable identifier <code>var async = 42;</code>  , the code will also be valid.  In ANTLR, this problem is solved in two ways: </p><br><ol><li>  using the semantic predicate for the syntax rule: <code>async: {_input.LT(1).GetText() == "async"}? ID ;</code> <code>async: {_input.LT(1).GetText() == "async"}? ID ;</code>  ;  while the async token itself will not exist.  This approach is bad because the grammar becomes runtime dependent and looks ugly; </li><li>  inclusion of a token in the id rule itself: <br><pre> <code class="hljs 1c">ASYNC: 'async'; ... id : ID ... <span class="hljs-string"><span class="hljs-string">| ASYNC;</span></span></code> </pre> </li></ol><br><a name="ambiguity"></a><br><h3 id="neodnoznachnost">  Ambiguity </h3><br><p>  In natural language, there are ambiguously interpreted phrases (such as ‚Äúthese types of steel have been in our workshop‚Äù).  In formal languages, such constructions can also occur.  For example, the following snippet: </p><br><pre> <code class="hljs pgsql">stat: expr <span class="hljs-string"><span class="hljs-string">';'</span></span> // expression <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> | ID <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-string"><span class="hljs-string">';'</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span>; ; expr: ID <span class="hljs-string"><span class="hljs-string">'('</span></span> <span class="hljs-string"><span class="hljs-string">')'</span></span> | <span class="hljs-type"><span class="hljs-type">INT</span></span> ;</code> </pre> <br><p>  However, unlike natural languages, they are most likely the result of improperly designed grammars.  ANTLR is not able to detect such ambiguities in the parser generation process, but can detect them directly in the parsing process if the <code>LL_EXACT_AMBIG_DETECTION</code> option is <code>LL_EXACT_AMBIG_DETECTION</code> (because, as already mentioned, ALL is a dynamic algorithm).  Ambiguity can occur both in the lexer and in the parser.  In the lexer for two identical tokens, the token is declared, which is declared above in the file (for example, with identifiers).  However, in languages ‚Äã‚Äãwhere ambiguity is valid (for example, C ++), semantic predicates (code inserts) can be used to resolve it, for example: </p><br><pre> <code class="hljs pgsql">expr: { isfunc(ID) }? ID <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span> // func <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> arg | { istype(ID) }? ID <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span> // ctor-style <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> expr | <span class="hljs-type"><span class="hljs-type">INT</span></span> | <span class="hljs-type"><span class="hljs-type">void</span></span> ;</code> </pre> <br><p>  Also, sometimes ambiguity can be corrected with a little tinkering with grammar.  For example, in C # there is a bitwise right shift operator <code>RIGHT_SHIFT: '&gt;&gt;'</code> ;  Two angle brackets can also be used to describe generic classes: <code>List&lt;List&lt;int&gt;&gt;</code> .  If you define a token <code>&gt;&gt;</code> , then the construction of two lists can never be parsed, because the parser will assume that instead of two closing brackets the <code>&gt;&gt;</code> operator is written.  To solve this problem, simply abandon the <code>RIGHT_SHIFT</code> token.  In this case, the token <code>LEFT_SHIFT: '&lt;&lt;'</code> can be left, since such a sequence of characters when parsing the angle brackets cannot be found in the valid code. </p><br><p>  In our module, we have not yet tested in detail whether there is ambiguity in the developed grammars. </p><br><a name="comments-processing"></a><br><h3 id="obrabotka-probelov-kommentariev">  Handling spaces, comments. </h3><br><p>  Another problem with parsing is the handling of comments.  The inconvenience here is that if you include comments in the grammar, then it will turn out to be overcomplicated, since in essence each node will contain comments in itself.  However, it is also impossible to simply throw out comments, because they may contain important information.  For processing comments in ANTLR, so-called channels are used that isolate a lot of comments from other tokens: <code>Comment: ~[\r\n?]+ -&gt; channel(PhpComments);</code> </p><br><p>  Roslyn comments are included in tree nodes, but they have a special type of Syntax Trivia.  Both ANTLR and Roslyn provide a list of trivial tokens associated with a specific regular token.  In ANTLR, for a token with index i, there is a method in the stream that returns all tokens from a specific channel to the left or right: <code>getHiddenTokensToLeft(int tokenIndex, int channel)</code> , <code>getHiddenTokensToRight(int tokenIndex, int channel)</code> .  In Roslyn, such tokens are immediately included in the terminal Syntax Token. </p><br><p>  In order to receive all comments, you can take all the tokens of a specific channel in ANTLR: <code>lexer.GetAllTokens().Where(t =&gt; t.Channel == PhpComments)</code> , and in Roslyn you can take all the DescendantTrivia for the root node with the following SyntaxKind: <em>SingleLineCommentTrivia</em> , <em>MultiLineCommentTrivia</em> , <em>SingleLineDocumentationCommentTrivia</em> , <em>MultiLineDocumentationCommentTrivia</em> , <em>DocumentationCommentExteriorTrivia</em> , <em>XmlComment</em> . </p><br><p>  Processing spaces and comments is one of the reasons why you cannot use code for analysis, for example, LLVM: they will simply be thrown out in it.  In addition to comments, even the handling of spaces is important.  For example, to detect errors with a single statement in if (an example taken from the article <a href="https://habrahabr.ru/company/pvs-studio/blog/277439/">PVS-Studio rummaged in the FreeBSD kernel</a> ): </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MOD_UNLOAD: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (via_feature_rng &amp; VIA_HAS_RNG) random_nehemiah_deinit(); random_source_deregister(&amp;random_nehemiah);</code> </pre> <br><a name="syntax-errors-processing"></a><br><h3 id="obrabotka-oshibok-parsinga">  Handling parsing errors. </h3><br><img align="right" src="https://habrastorage.org/files/7eb/ac2/95e/7ebac295e2544306ad18a43b363c41fa.png"><br><p>  An important ability of each parser is error handling - for the following reasons: </p><br><ul><li>  The parsing process should not interrupt only because of one error, but should be correctly restored and parse the code further (for example, after a missing semicolon); </li><li>  search for a relevant error and its location, instead of a set of irrelevant ones. </li></ul><br><a name="syntax-errors-processing-antlr"></a><br><h4 id="oshibki-v-antlr">  Errors in ANTLR </h4><br><p>  The following types of parsing errors exist in ANTLR: </p><br><ul><li><p>  <strong>token recognition error</strong> (Lexer no viable alt);  the only existing lexical error, indicating the absence of a rule for the formation of a token from an existing token: <br><br>  class <strong>#</strong> {int i;  } - here such a token is <strong>#</strong> . </p><br></li><li><p>  Missing token  in this case, ANTLR inserts a missing token into the stream of tokens, marks that it is missing, and continues to parse as if it exists. <br><br>  class T {int f (x) {a = 3 4 5;  } <strong>}</strong> - here this token is <code>}</code> at the end; </p><br></li><li><p>  <strong>extra token</strong> (Extraneous token);  ANTLR marks that the token is erroneous and continues the parsing further, as if it is missing: in the example, this is the first token <strong>;</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      class T <strong>;</strong>  {int i;  } </p><br></li><li><p>  <strong>incompatible input chain</strong> (Mismatched input);  this turns on the ‚Äúpanic mode‚Äù, the chain of input tokens is ignored, and the parser waits for the token from the synchronization set.  In the following example, lexemes <strong>4</strong> and <strong>5 are</strong> ignored, and the sync token is <strong>;</strong> <br><br>  class T {int f (x) {a = 3 <strong>4 5</strong> ;  }} </p><br></li><li>  No viable alternative input;  This error describes all other possible errors of parsing. <br><br>  class T { <strong>int;</strong>  } </li></ul><br><p>  In addition, errors can be processed manually by adding alternatives to the rule, for example: </p><br><pre> <code class="hljs objectivec">function_call : ID <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span> | ID <span class="hljs-string"><span class="hljs-string">'('</span></span> expr <span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-string"><span class="hljs-string">')'</span></span> {notifyErrorListeners(<span class="hljs-string"><span class="hljs-string">"Too many parentheses"</span></span>);} | ID <span class="hljs-string"><span class="hljs-string">'('</span></span> expr {notifyErrorListeners(<span class="hljs-string"><span class="hljs-string">"Missing closing ')'"</span></span>);} ;</code> </pre> <br><p>  Moreover, in ANTLR 4 you can use your own error handling mechanism.  This is needed, for example, to increase the performance of the parser: first, the code is parsed using the fast SLL algorithm, which, however, may incorrectly parse the code with ambiguity.  If using this algorithm it turned out that there is at least one error (this can be both an error in the code and ambiguity), the code is parsed with the help of a complete, but less fast ALL-algorithm.  Of course, code with real errors (for example, missed;) will always be parsed using LL, however there are usually less such files than files without errors. </p><br><div class="spoiler">  <b class="spoiler_title">Maximizing the speed of parsing in ANTLR</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// try with simpler/faster SLL(*) parser.getInterpreter().setPredictionMode(PredictionMode.SLL); // we don't want error messages or recovery during first try parser.removeErrorListeners(); parser.setErrorHandler(new BailErrorStrategy()); try { parser.startRule(); // if we get here, there was no syntax error and SLL(*) was enough; // there is no need to try full LL(*) } catch (ParseCancellationException ex) { // thrown by BailErrorStrategy tokens.reset(); // rewind input stream parser.reset(); // back to standard listeners/handlers parser.addErrorListener(ConsoleErrorListener.INSTANCE); parser.setErrorHandler(new DefaultErrorStrategy()); // full now with full LL(*) parser.getInterpreter().setPredictionMode(PredictionMode.LL); parser.startRule(); }</span></span></code> </pre> </div></div><br><a name="syntax-errors-processing-roslyn"></a><br><h4 id="oshibki-v-roslyn">  Errors in Roslyn </h4><br><p>  Roslyn has the following parsing errors: </p><br><ul><li>  <strong>missing syntax</strong> ;  Roslyn completes the corresponding node with the value of the property <code>IsMissing = true</code> (a typical example is the Statement without a semicolon); </li><li>  <strong>incomplete member</strong> ;  a separate <code>IncompleteMember</code> node is created; </li><li>  <strong>incorrect</strong> numeric, string, or character literal value (for example, too large, empty char): separate node with Kind equal to <code>NumericLiteralToken</code> , <code>StringLiteralToken</code> or <code>CharacterLiteralToken</code> ; </li><li>  <strong>extra syntax</strong> (for example, a randomly typed character): a separate node is created with Kind = <code>SkippedTokensTrivia</code> . </li></ul><br><p>  The following code snippet shows all these errors. <br>  (Roslyn is also convenient to feel with the help of the plug-in for Visual Studio <a href="https://visualstudiogallery.msdn.microsoft.com/2ddb7240-5249-4c8c-969e-5d05823bcb89">Syntax Visualizer</a> ): </p><br><div class="spoiler">  <b class="spoiler_title">C # code with all types of syntax errors in Roslyn</b> <div class="spoiler_text"><pre> <code class="hljs ruby">namespace App { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> { ;</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ Skipped Trivia static void Main(string[] args) { a /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Missing ';' ulong ul = 1lu; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Incorrect Numeric string s = """; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Incorrect String char c = ''; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Incorrect Char } } class bControl flow { c /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Incomplete Member } }</span></span></code> </pre> </div></div><br><p>  Thanks to such thoughtful types of syntax errors, Roslyn can convert a tree with any number of errors back to character code into a character. </p><br><a name="practice"></a><br><h2 id="ot-teorii-k-praktike">  From theory to practice </h2><br><img align="left" src="https://habrastorage.org/files/e54/08c/d6d/e5408cd6dc2f422a90287482ec9df95b.png"><br><p>  For PHP parsers, T-SQL has been developed and laid out in the open source grammar <a href="https://github.com/antlr/grammars-v4/tree/master/php">php</a> , <a href="">tsql</a> , <a href="https://github.com/antlr/grammars-v4/tree/master/plsql">plsql</a> , which are visual applications of the above theory.  For Java parsing, ready-made <a href="">java</a> and <a href="">java8</a> grammars were used and compared.  Also, to compare parsers based on Roslyn and ANTLR, we modified the grammar of <a href="https://github.com/antlr/grammars-v4/tree/master/csharp">C #</a> to support versions 5 and 6 of the language.  We described the interesting moments of development and use of these grammars below.  Although SQL-based languages ‚Äã‚Äãare more declarative than imperative, in their T-SQL and PL / SQL dialects there is support for imperative constructs ( <a href="https://msdn.microsoft.com/en-us/library/ms174290.aspx">Control flow</a> ), for which for the most part our analyzer is being developed. </p><br><a name="java-grammars"></a><br><h3 id="java--i-java8-grammatiki">  Java and Java8 grammar </h3><br><p>  For most cases, the parser is based on the Java 7 grammar faster than the parsing code, compared to Java 8, except for cases with deep recursion, for example, in the <a href="https://gist.github.com/KvanTTT/bf20f6a4aac708b49df2">ManyStringConcatenation.java</a> file, when parsing takes an order of magnitude more time and memory.  I want to note that this is not just a synthetic example - we really came across files with such a ‚Äúcode-spaghetti‚Äù.  As it turned out, the whole problem is precisely because of the left-recursive rules in expression.  The Java 8 grammar contains rules with only primitive recursion.  Rules with primitive recursion differ from the rules with the usual fact that they refer to themselves only in the left or right side of any alternative, but not simultaneously in both.  An example of a regular recursive expression: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> (<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-string"><span class="hljs-string">'/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> (<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> | ID ;</code> </pre> <br><p>  And the following rules are obtained after transforming the rules above into primitive left-recursive ones: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> : multExpression | <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> (<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>) multExpression ; multExpression : ID | multExpression (<span class="hljs-string"><span class="hljs-string">'*'</span></span>|<span class="hljs-string"><span class="hljs-string">'/'</span></span>) ID ;</code> </pre> <br><p>  Or non-recursive at all (however, in this case, the expressions after parsing will not be very convenient to process, because they will no longer be binary): </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> : multExpression ((<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>) multExpression)* ;</code> </pre> <br><p>  If the operation has the right associativity (for example, exponentiation), then primitive right-recursive rules are used: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> : &lt;assoc=right&gt; <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> <span class="hljs-string"><span class="hljs-string">'^'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> | ID ;</code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">powExpression</span></span> : ID <span class="hljs-string"><span class="hljs-string">'^'</span></span> powExpression | ID ;</code> </pre> <br><p>  On the one hand, the transformation of the levorcrusive rules eliminates the problem of large memory consumption and poor performance for rarely encountered files with a large number of homogeneous operations, on the other hand it introduces performance problems for the rest of the set of files.  Therefore, it is advisable to use primitive recursion for expressions that can potentially be very deep (for example, string concatenation), and usual recursion for all other cases (for example, comparison of numbers). </p><br><a name="php-grammar"></a><br><h3 id="php-grammatika">  Php grammar </h3><br><p>  For parsing PHP on the .NET platform there is a project <a href="http://www.php-compiler.net/">Phalanger</a> .  However, we were not satisfied with the fact that this project is practically not developed, and also does not provide the Visitor interface for bypassing AST nodes (Walker only).  Thus, it was decided to develop a PHP grammar under ANTLR in-house. </p><br><a name="case-insensitive-keywords"></a><br><h4 id="registro-nezavisimye-klyuchevye-slova">  Register independent keywords. </h4><br><p>  As you know, in PHP all lexemes, with the exception of variable names (which begin with a '$') are case insensitive.  In ANTLR, case insensitivity can be implemented in two ways: </p><br><ol><li><p>  Declaring fragmentary lexical rules for all Latin letters and using them in the following way: </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">Abstract</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">ABSTRACT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">As</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>; BinaryCast: BINARY; BoolType: BOOLEAN | BOOL; BooleanConstant: <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span>; ... fragment A: [aA]; fragment B: [bB]; ... fragment Z: [zZ];</code> </pre> <br><p>  A fragment in ANTLR is a part of a lexeme that can be used in other lexemes, <br>  however, in itself, it is not a lexeme.  This is essentially syntactic sugar for describing tokens.  Without using fragments, for example, the first token can be written like this: <code>Abstract: [Aa] [Bb] [Ss] [Tt] [Rr] [Aa] [Cc] [Tt]</code> .  The advantage of this approach is that the generated lexer is independent of runtime, since the characters in upper and lower case are declared immediately in grammar.  Of the minuses it can be noted that the performance of the lexer with this approach is lower than in the second method. </p><br></li><li>  Reducing the entire input stream of characters to a lower (or upper) register and starting a lexer, in which all tokens are described in this register.  However, such a transformation will have to be done for each runtime (Java, C #, JavaScript, Python) separately, as described in the <a href="https://theantlrguy.atlassian.net/wiki/pages/viewpage.action%3FpageId%3D2687342">Implement a custom File or String Stream and Override LA</a> .  Moreover, with this approach, it is difficult to make some lexemes to be case-sensitive, while others are not. </li></ol><br><p>  In the developed PHP grammar, the first approach was used, since lexical analysis is usually performed in less time than the syntactic one.  And despite the fact that the grammar was still dependent on runtime, this approach potentially simplifies the task of porting the grammar to other runtimes.  Moreover, we created the <a href="https://github.com/antlr/antlr4/pull/1092">Case</a> Request <a href="https://github.com/antlr/antlr4/pull/1092">RFC Case Insensitivity Proof of Concept</a> - to facilitate the description of case-insensitive tokens.  But unfortunately, he did not get much approval from the ANTLR community. </p><br><a name="lexical-modes"></a><br><h4 id="leksicheskie-rezhimy-dlya-php-html-css-javascript">  Lexical modes for PHP, HTML, CSS, JavaScript. </h4><br><p>  As you know, PHP code inserts can be located inside HTML code almost anywhere.  In the same HTML, CSS and JavaScript code inserts can be found (these inserts are also called ‚Äúislands‚Äù).  For example, the following code (using <a href="http://php.net/manual/en/control-structures.alternative-syntax.php">Alternative Syntax</a> ) is valid: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($a): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// without semicolon</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> &lt;br&gt; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> break </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> case 2: </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> &lt;br&gt; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> break;</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> case 3: </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> &lt;br&gt; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> break;</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?php</span></span></span><span class="hljs-comment"> endswitch; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre> <br><p>  or </p><br><pre> <code class="php hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>&gt; document.addEvent(<span class="hljs-string"><span class="hljs-string">'domready'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timers = { timer: <span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>=$timer<span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer = TimeTic.periodical(<span class="hljs-number"><span class="hljs-number">1000</span></span>, timers); functionOne(<span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> implode(<span class="hljs-string"><span class="hljs-string">', '</span></span>, $arrayWithVars); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span>); }); &lt;/script&gt;</code> </pre> <br><p>  Fortunately, ANTLR has a mechanism of so-called modes (mode) that allow you to switch between different sets of tokens under a certain condition.  For example, the <em>SCRIPT</em> and <em>STYLE</em> modes are designed to generate a stream of tokens for JavaScript and CSS, respectively (but in this grammar they are actually simply ignored).  In the default mode <em>DEFAULT_MODE</em> , HTML tokens are generated.  It is worth noting that you can implement <em>Alternative Syntax</em> support in ANTLR without a single insertion of the target code into the lexer.  Namely: <em>nonEmptyStatement</em> includes the <em>inlineHtml</em> rule, which, in turn, includes tokens obtained in the <em>DEFAULT_MODE</em> mode: </p><br><pre> <code class="hljs smalltalk">nonEmptyStatement : identifier <span class="hljs-string"><span class="hljs-string">':'</span></span> | blockStatement | ifStatement | ... | inlineHtml ; ... inlineHtml : <span class="hljs-type"><span class="hljs-type">HtmlComment</span></span>* ((<span class="hljs-type"><span class="hljs-type">HtmlDtd</span></span> | htmlElement) <span class="hljs-type"><span class="hljs-type">HtmlComment</span></span>*)+ ;</code> </pre> <br><a name="complex-context-sensitive-syntax"></a><br><h4 id="slozhnye-kontekstno-zavisimye-konstrukcii">  Complex context-sensitive constructs. </h4><br><p>  It is worth noting that although ANTLR supports only the grammar grammar, there are so-called actions in it, that is, insertions of arbitrary code that extend the admissible set of languages ‚Äã‚Äãat least to context-sensitive ones.  With the help of such inserts, processing of structures such as <a href="http://php.net/manual/en/language.types.string.php">Heredoc</a> and others was implemented: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> foo(&lt;&lt;&lt; HEREDOC Heredoc line <span class="hljs-number"><span class="hljs-number">1.</span></span> Heredoc line <span class="hljs-number"><span class="hljs-number">2.</span></span> HEREDOC ) ; <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br><a name="tsql-grammar"></a><br><h3 id="grammatika-t-sql">  T-SQL grammar </h3><br><p>  Despite the common root ‚ÄúSQL‚Äù, the T-SQL (MSSQL) and PL / SQL grammars are quite different from each other. </p><br><p>  We would be happy not to develop our own parser for this difficult language.  However, the existing parsers did not meet the criteria for completeness of coverage, relevance ( <a href="https://github.com/karlatgit/tsql-grammar">grammar</a> under the abandoned GOLD-parser) and open source code in C # ( <a href="http://www.sqlparser.com/">General SQL Parser</a> ).      TSQL   MSDN.   :       ,  ,       ( SQL-    MSDN).     ,       . ,   .    ,       -     . </p><br><a name="plssql-grammar"></a><br><h3 id="grammatika-plsql">  PL/SQL </h3><br><p>   PL/SQL    ,     <a href="https://github.com/porcelli/plsql-parser">  ANTLR3</a> .    ,      java-runtime.   java   ,    AST     (   ,      ).   ,  </p><br><pre> <code class="hljs pgsql">decimal_key : {<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.LT(<span class="hljs-number"><span class="hljs-number">1</span></span>).getText().equalsIgnoreCase("decimal")}? REGULAR_ID</code> </pre> <br><p>     : <br> <code>decimal_key: DECIMAL</code> ,     . </p><br><a name="csharp-grammar"></a><br><h3 id="c-grammatika"> C#- </h3><br><p>    ,   ,   5  6 ,    .           .         -,          runtime. </p><br><a name="csharp-preprocessor-directives"></a><br><h4 id="direktivy-preprocessora">   </h4><br><p>  C#      (     ,      , . . false   ): </p><br><pre> <code class="hljs swift">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">DEBUG</span></span> &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-type"><span class="hljs-type">Sample</span></span> not compilied wrong code <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> = a + ; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// Compilied code var x = a + b; #endif</span></span></code> </pre> <br><p>           ,    -, <em>COMMENTS_CHANNEL</em>  <em>DIRECTIVE</em> .    <code>codeTokens</code> ,       .          .     ,  ANTLR             .    ‚Äî    <a href="">CSharpPreprocessorParser.g4</a> .  <code>true</code>  <code>false</code>     <code>#if</code> , <code>#elif</code> , <code>else</code> ,        <code>true</code> ,      ,     .        Conditional Symbols (   "DEBUG"). </p><br><p>          <code>true</code> ,      <code>codeTokens</code> ,    ‚Äî .       ( <code>var 42 = a + ;</code>   )    .      : <a href="https://gist.github.com/KvanTTT/d95579de257531a3cc15">CSharpAntlrParser.cs</a> . </p><br><a name="csharp-string-interpolation"></a><br><h4 id="interpolyaciya-strok">   </h4><br><p>      ,  , ,          (interpolation-expression),       .       ,          (, #0.##).  ,       (regular),      (verbatium),        .   <a href="https://msdn.microsoft.com/en-us/library/dn961160.aspx">  MSDN</a> . </p><br><p>       ,     : </p><br><pre> <code class="hljs cs">s = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{p.Name}</span></span></span><span class="hljs-string"> is \"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{p.Age}</span></span></span><span class="hljs-string"> year</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{(p.Age == </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">""</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"s"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string"> old"</span></span>; s = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{(p.Age == </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$"</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new Person { }</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"> }"</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">""</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">"</span></span>; s = <span class="hljs-string"><span class="hljs-string">$@"\</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{p.Name}</span></span></span><span class="hljs-string"> ""\"</span></span>; s = <span class="hljs-string"><span class="hljs-string">$"Color [ R=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{func(b: </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">):#</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0.</span></span></span></span><span class="hljs-string"><span class="hljs-subst">##}</span></span></span><span class="hljs-string">, G=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{G:#</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0.</span></span></span></span><span class="hljs-string"><span class="hljs-subst">##}</span></span></span><span class="hljs-string">, B=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{B:#</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0.</span></span></span></span><span class="hljs-string"><span class="hljs-subst">##}</span></span></span><span class="hljs-string">, A=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{A:#</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0.</span></span></span></span><span class="hljs-string"><span class="hljs-subst">##}</span></span></span><span class="hljs-string"> ]"</span></span>;</code> </pre> <br><p>             ,    .     <a href="">CSharpLexer.g4</a> . </p><br><a name="testing"></a><br><h3 id="testirovanie">  Testing </h3><br><a name="correctness-testing"></a><br><h4 id="korrektnost-parserov-antlr">   ANTLR </h4><br><p>  Roslyn, ,      .    ANTLR    : </p><br><ul><li>  ,     . ,    TSQL     <a href="https://github.com/antlr/grammars-v4/tree/master/tsql/examples">antlr grammars-v4</a> .  C#      <a href="">AllInOne.cs</a> ,   Roslyn. </li><li>          . </li><li>      . PHP   <a href="https://github.com/shivamdixit/WebGoatPHP">WebGoat</a> , <a href="https://github.com/phpbb/">phpbb</a> , <a href="https://github.com/zendframework/zf2">Zend Framework</a> . C#    <a href="https://github.com/dotnet/roslyn">Roslyn-1.1.1</a> , <a href="https://github.com/dotnet/corefx">Corefx-1.0.0-rc2</a> , <a href="https://github.com/JimBobSquarePants/ImageProcessor">ImageProcessor-2.3.0</a> , <a href="">Newtonsoft.Json-8.0.2</a>  . </li></ul><br><a name="performance-testing"></a><br><h3 id="proizvoditelnost-parserov-antlr-i-roslyn">   ANTLR  Roslyn </h3><br><p>       Release   .   ANTLR 4 4.5.0-alpha003  Roslyn (Microsoft.CodeAnalysis) 1.1.1. </p><br><h4 id="webgoatphp"> WebGoat.PHP </h4><br><p>   ‚Äî 885.    ‚Äî 137 248,  ‚Äî 4 461 768. <br>    ‚Äî 00:00:31  ( 55%,  45%). </p><br><h4 id="plsql-samples"> PL/SQL Samples </h4><br><p>   ‚Äî 175.    ‚Äî 1 909,  ‚Äî 55 741. <br>    &lt; 1 . ( 5%,  95%). </p><br><h4 id="corefx-100-rc2"> CoreFX-1.0.0-rc2 </h4><br><p>   ‚Äî 7329.    ‚Äî 2 286 274,  ‚Äî 91 132 116. <br>   : </p><br><ul><li> Roslyn: 00:00:04 ., </li><li> ANTLR: 00:00:24 . ( 12%;  88%). </li></ul><br><h4 id="roslyn-111"> Roslyn-1.1.1 </h4><br><p>   ‚Äî 6527.    ‚Äî 1 967 672,  ‚Äî 74 319 082. <br>   : </p><br><ul><li> Roslyn: 00:00:03 ., </li><li> ANTLR: 00:00:16 . ( 12%;  88%). </li></ul><br><p>     <em>CoreFX</em>  <em>Roslyn</em>   ,    C#  ANTLR     <strong>5</strong>    Roslyn,      . ,   ¬´ ¬ª          ,  Roslyn,         C#-  Java, Python  JavaScript (   ),      . </p><br><p>        ,        ,   .    PHP,      ,  .          ,      ,   T-SQL  PL/SQL (     )     (  20). ,    C#    <code>SHARP: NEW_LINE Whitespace* '#';</code>  <code>SHARP: '#';</code> ,      7  ,   10   <strong>!</strong>   ,       ,          #,      (    ,            ). </p><br><a name="errors-processing-testing"></a><br><h3 id="mehanizmy-obrabotki-oshibok-v-antlr-i-roslyn">     ANTLR  Roslyn </h3><br><p>    C#-,      ANTLR: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { c }</code> </pre> <br><p>  ANTLR </p><br><ul><li> token recognition error at: '' at 3:5 </li><li> mismatched input '4' expecting {'as', 'is', '[', '(', '.', ';', '+', '-', '*', '/', '%', '&amp;', '|', '^', '&lt;', '&gt;', '?', '??', '++', '--', '&amp;&amp;', '||', '-&gt;', '==', '!=', '&lt;=', '&gt;=', '&lt;&lt;'} at 8:19 </li><li> extraneous input '5' expecting {'as', 'is', '[', '(', '.', ';', '+', '-', '*', '/', '%', '&amp;', '|', '^', '&lt;', '&gt;', '?', '??', '++', '--', '&amp;&amp;', '||', '-&gt;', '==', '!=', '&lt;=', '&gt;=', '&lt;&lt;'} at 8:21 </li><li> no viable alternative at input 'c}' at 15:5 </li><li> missing '}' at 'EOF' at 15:6 </li></ul><br><p>  Roslyn </p><br><ul><li> test(3,5): error CS1056: Unexpected character '' </li><li> test(8,19): error CS1002:; expected </li><li> test(8,21): error CS1002:; expected </li><li> test(15,5): error CS1519: Invalid token '}' in class, struct, or interface member declaration </li><li> test(15,6): error CS1513: } expected </li></ul><br><p>  , Roslyn    ,   ANTLR.         .         .  ,  Roslyn    ,    .    ,       (  , ), ANTLR       .  ANTLR   ,        ( ,  ). ,     <code>#if</code>  ,       .              (  - ). </p><br><a name="memory-consumption"></a><br><h3 id="potreblenie-pamyati">   </h3><br><p>    , ANTLR 4   ,     ,      .      (    70000 PHP )          ,          .        <code>lexer.Interpreter.ClearDFA()</code>    <code>parser.Interpreter.ClearDFA()</code>              . </p><br><p>     ,       .   ,    <code>GetAllTokens()</code>    <code>ClearDFA()</code>   (  )           "Object reference not set to an instance of an object".   ,         ANTLR C#,          ( )    ( ) <code>ReadWriterLockSlim</code> . </p><br><p>      Roslyn      .   5  C#  <em>aspnet-mvc-6.0.0-rc1</em> , <em>roslyn-1.1.1</em> , <em>corefx</em> , <em>Newtonsoft.Json-8.0.2</em>  <em>ImageProcessor-2.3.0</em>      200 . </p><br><a name="conclusion"></a><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>          ANTLR  Roslyn.     : </p><br><ul><li>         AST   <strong>Visitor</strong>  <strong>Walker</strong> (Listener); </li><li>  ,          ANTLR 4; </li><li>       .NET; </li><li>      AST; </li><li>    DSL   . </li></ul><br><p>              <a href="https://habrahabr.ru/users/vladimirkochetkov/" class="user_link">VladimirKochetkov</a>  <a href="https://my.webinar.ru/record/649729/%3Fi%3D4dcc5037efe7d0f5a6ce6e001f994bec">¬´ ‚Äé  SAST¬ª</a>   40  60 . </p><br><a name="used-sources"></a><br><h2 id="istochniki">  Sources </h2><br><ul><li> Modeling and Discovering Vulnerabilities with Code Property Graphs; Fabian Yamaguchi; 2014. </li><li> Compilers: Principles, Techniques, and Tools; Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman; 2006. </li><li> The Definitive ANTLR Reference; Terence Parr; 2014. </li><li> Adaptive LL(*) Parsing: The Power of Dynamic Analysis, Terence Parr; Sam Harwell; 2014. </li><li> Roslyn code &amp; docs, <a href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a> </li><li> ANTLR grammars, <a href="https://github.com/antlr/grammars-v4">https://github.com/antlr/grammars-v4</a> </li><li> ANTLR code, <a href="https://github.com/antlr/antlr4">https://github.com/antlr/antlr4</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/210772/">https://habr.com/ru/post/210772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210750/index.html">2.4GHz USB "whistle" with your own hands</a></li>
<li><a href="../210754/index.html">We pump Google Tasks using a third-party service: repetitive tasks, sharing, notifications about deadlines and other features</a></li>
<li><a href="../210760/index.html">How to hash passwords and how not to</a></li>
<li><a href="../210762/index.html">As we were in Canadian accelerators filed and interviews were held</a></li>
<li><a href="../210764/index.html">Phpbrew PHP Version Manager. (+ install and use in Ubuntu 13.10)</a></li>
<li><a href="../210774/index.html">IBM plans to move to a new type of integrated circuit</a></li>
<li><a href="../210776/index.html">Google announced five games for Google Glass</a></li>
<li><a href="../210782/index.html">Undocumented 8086 processor operating codes</a></li>
<li><a href="../210786/index.html">Linux distribution released ROSA Desktop Fresh GNOME R2</a></li>
<li><a href="../210788/index.html">Google sells Lenovo's Motorola Mobility</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>