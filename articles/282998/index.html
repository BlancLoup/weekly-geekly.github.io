<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding errors by calculating virtual values</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During the operation of a static analyzer, the exact values ‚Äã‚Äãor ranges of values ‚Äã‚Äãof some variables and expressions can be calculated at the analysi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding errors by calculating virtual values</h1><div class="post__text post__text-html js-mediator-article">  During the operation of a static analyzer, the exact values ‚Äã‚Äãor ranges of values ‚Äã‚Äãof some variables and expressions can be calculated at the analysis stage.  This is useful information that you can use when searching for errors.  We call such values ‚Äã‚Äãvirtual values, and this article will be about them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e53/3a5/dca/e533a5dcae7c615fa543e2ba68c25783.png" align="left"><br><a name="habracut"></a><br>  If the static analyzer is able to calculate what the expression is equal to, this allows for a deeper analysis of the code and to identify more errors.  Of course, we are talking not only about the exact values ‚Äã‚Äãof expressions, such as 1 + 2, but also about calculating the range of values ‚Äã‚Äãthat a variable can take at a certain place in a program.  In the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer, we call the algorithms responsible for calculating ranges the mechanism of virtual values.  Such a mechanism exists both in the core of the C / C ++ code analyzer and in the core of the C # analyzer.  In this article we will look at the mechanism of virtual values ‚Äã‚Äãusing the example of a C # analyzer. <br><br>  In our PVS-Studio analyzer, we use <a href="https://github.com/dotnet/roslyn">Roslyn</a> to find errors in C # projects to get all the necessary information about the source code.  Roslyn provides us with a syntax tree, type information, dependency searching, and so on.  During the analysis, PVS-Studio performs a syntax tree traversal and applies diagnostics to its nodes.  In addition, during the crawling process, information is collected that can be used by the analyzer later.  Examples of such additional information are virtual values. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Creating virtual values </h2><br>  Virtual values ‚Äã‚Äãare stored for fields, properties, variables, and parameters when first mentioned in the code.  If the first mention is a declaration of a variable or an assignment, then we will try to calculate the virtual value by analyzing the expression to the right of the equal sign.  Otherwise, we usually know nothing about the property / field / parameter and believe that it can take any valid value.  Consider an example: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasElements = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte x, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x; hasElements = (<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.Count &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasElements &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//V3022 { } } }</span></span></code> </pre> <br>  When in the process of traversing the tree, the analyzer reaches the body of the <i>Func</i> function, it will begin to calculate the virtual values ‚Äã‚Äãof the variables.  The first line declares the variable <i>y</i> , which is initialized to <i>x</i> .  Since we know about <i>x</i> only that it is of type <i>byte</i> , it means that it can take any value from 0 to 255. This range of values ‚Äã‚Äãwill be assigned as the virtual value of the variable <i>y</i> .  The same will be done for the <i>hasElements</i> field: the analyzer knows that the <i>Count</i> property on the list cannot accept negative values, therefore, the <i>true</i> value is assigned to the <i>hasElements</i> variable.  Now, when analyzing the condition <i>hasElements</i> &amp;&amp; <i>y</i> &gt; = 0, we know that the left and right sides are true and the whole condition is also always true - this is where the <a href="http://www.viva64.com/ru/d/0391/">V3022</a> diagnostics <a href="http://www.viva64.com/ru/d/0391/">work</a> . <br><br>  Let's take a closer look at how the virtual value of the expression is calculated. <br><br><h2>  Calculating the virtual value of an expression </h2><br>  For variables of different types, the virtual value is calculated differently.  In the case of an integer type variable, the virtual value is stored as a set of value ranges that the variable can accept.  For example, consider the following code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">-10</span></span> &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span> &amp;&amp; x != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">5</span></span>; } }</code> </pre> <br>  At the beginning of the function, nothing is known about the variable <i>x</i> and its range is all valid values ‚Äã‚Äãof type <i>int</i> : [int.MinValue, int.MaxValue].  When entering the <i>if</i> block, we can refine the virtual value based on the condition.  Thus, inside the <i>if</i> block, the variable <i>x</i> will have a range [-10, -1], [1, 10].  If now <i>x</i> will be used when calculating an expression, the analyzer will take into account its virtual value.  In our example, <i>y</i> will get the virtual value [-5, 4], [6, 15]. <br><br>  For expressions of type <i>bool, the</i> virtual value is calculated differently.  Here we have only three options: false, true, or unknown meaning.  Therefore, we simply enumerate a sufficient number of options for all the variables of the expression, and check in all cases whether the expression will take the same value.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//V3022 }</span></span></code> </pre> <br>  Whatever values ‚Äã‚Äãfor the parameter <i>x</i> we take, the expression <i>x</i> &gt; = 0 is always true.  Therefore, substituting several values ‚Äã‚Äãinstead of <i>x</i> , we will make sure of this and assign <i>true</i> as the virtual value for <i>b</i> . <br><br>  Another example from the umbraco project: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Aggregate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] args, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name != <span class="hljs-string"><span class="hljs-string">"Min"</span></span> || name != <span class="hljs-string"><span class="hljs-string">"Max"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//V3022 { throw new ArgumentException("Can only use min or max..."); } .... }</span></span></code> </pre> <br>  To make sure that the condition in the example is always true, the analyzer substitutes the values ‚Äã‚Äã‚ÄúMin‚Äù, ‚ÄúMax‚Äù, ‚Äú‚Äù, <i>null</i> instead of name.  In each of these cases, either the left or the right side of the expression will be true, so the expression in the condition is always true. <br><br>  Virtual values ‚Äã‚Äãcalculated for all variables are stored separately for each block.  When entering a nested block, the analyzer creates its own set of virtual values ‚Äã‚Äãbased on the parent block.  For a simple nested block, this is just a copy of all virtual values.  For conditions, loops, and other blocks, virtual values ‚Äã‚Äãare not just copied, they may be subject to additional restrictions. <br><br><h2>  Refinement of virtual values ‚Äã‚Äãin the if / else block </h2><br>  Consider for example how virtual values ‚Äã‚Äãbehave when processing an if / else block. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//x:[0, int.MaxValue] if (x &lt;= 10) { //x:[0, 10] .... } else { //x:[11, int.MaxValue] .... } } }</span></span></code> </pre> <br>  After analyzing the condition <i>x</i> &gt; = 0, PVS-Studio will limit the range of the variable <i>x</i> for the first <i>if</i> block to the values ‚Äã‚Äã[0, int.MaxValue].  After processing the second condition <i>x</i> &lt;= 10, the analyzer will create two more copies of the virtual values ‚Äã‚Äãof the variable <i>x</i> - one for the <i>if</i> block and the other for the <i>else</i> block.  Moreover, these copies will be subject to restrictions taking into account the virtual value of the same variable from the parent block and the virtual value of the expression in the condition.  That is, for a nested <i>if</i> block, the virtual value of the variable <i>x</i> will be [0, 10], and for the <i>else</i> block, all other values ‚Äã‚Äãwill be [11, int.MaxValue]. <br><br>  After traversing the <i>if</i> / <i>else</i> block, we need to combine the virtual values ‚Äã‚Äãfrom the <i>if</i> and <i>else</i> blocks for each variable.  It should also be noted here that if at the end of the <i>if</i> or <i>else there</i> was a transition operator, for example, <i>return</i> , then it is not necessary to combine the values ‚Äã‚Äãfrom this block.  Examples: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... b1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; b2 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... b1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//  ,  b1  true //  b2     } public void Func2(int x) { if (x &lt; 0) return; //  ,  x   }</span></span></code> </pre> <h2>  Cycle processing </h2><br>  The peculiarity of calculating virtual values ‚Äã‚Äãfor cycles is that the body of the cycle must be bypassed twice.  Consider an example. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">5</span></span>) { .... } i++; } }</code> </pre> <br>  If we simply copy the virtual values ‚Äã‚Äãfrom the parent block to the <i>while</i> block, then when analyzing the condition <i>i</i> == 5 we would get a false positive V3022, since we know that before the cycle, the variable <i>i</i> was zero.  Therefore, before analyzing the body of the loop, you need to calculate what values ‚Äã‚Äãthe variables can take at the end of the iteration, as well as in all the blocks containing the <i>continue</i> statement, and combine all these values ‚Äã‚Äãtogether with the values ‚Äã‚Äãof the variables before entering the loop.  In addition, if we analyze the <i>for</i> loop, we need to take into account the initialization and change blocks of the counter.  After the values ‚Äã‚Äãof all possible points of entry into the loop are combined, it is necessary to apply the loop condition in the same way as for the <i>if</i> block.  So we will get the correct virtual values ‚Äã‚Äãfor the variables and we can perform a second round of the cycle, on which diagnostics will be applied. <br><br>  After traversing the cycle, we need to combine the virtual values ‚Äã‚Äãof the variables from all points from which we can get to the next operator after the cycle.  These are the values ‚Äã‚Äãbefore the beginning of the loop (if no iteration is performed), the values ‚Äã‚Äãof the variables at the end of the loop body, the values ‚Äã‚Äãof the variables in the blocks containing the <i>break</i> or <i>continue</i> statements.  All of these values ‚Äã‚Äãwe have already calculated and remembered at the time of the first round of the cycle.  Now all of them must also be combined and apply the condition opposite to the cycle condition. <br><br>  It was a difficult explanation, so let's look at an example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (condition1) { <span class="hljs-comment"><span class="hljs-comment">//x:[0, 1], [3] if (condition2) { x = 2; break; } if (condition3) { x = 3; continue; } x = 1; } //x:[0, 3] }</span></span></code> </pre> <br>  In this example, the variable <i>x</i> before entering the loop is zero.  Having executed the first pass through the loop, the analyzer will calculate that the variable <i>x</i> can also take the values ‚Äã‚Äã1, 2 in the block with <i>break</i> and 3 in the block with <i>continue</i> .  Since we have three points of transition to the next iteration of the cycle, at the beginning of the cycle, the variable <i>x</i> can take the values ‚Äã‚Äã0, 1 or 3. And we can get into the next operator after the cycle from four points.  Therefore, here <i>x</i> can be 0, 1, 2, or 3. <br><br>  The analyzer also calculates which values ‚Äã‚Äãthe variables can take within the <i>case</i> blocks of the <i>switch statement</i> , within <i>try</i> / <i>catch</i> / <i>finally,</i> and for other language constructs. <br><br><h2>  Division by zero </h2><br>  Dividing by zero is one of the errors that can be found with virtual values.  The peculiarity of this diagnosis is that not every division, in which theoretically there can be a zero in the denominator, should lead to its operation.  Consider an example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBlockCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blockSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataLength / blockSize; }</code> </pre> <br>  In this function, <i>blockSize</i> can theoretically take any value of type <i>int</i> , and zero also falls within this range.  But if you issue warnings to such a code, the diagnosis will lose its meaning, since useful warnings will be lost in hundreds of false positives.  Therefore, we needed to teach the analyzer to identify among all the divisions really suspicious, for example, the following: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDownloadAvgRateString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SecondsDownloading &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetSpeed(Downloaded / SecondsDownloading); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre> <br>  or such: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">-10</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { y = x / i; } }</code> </pre> <br>  As a solution, we divide the ranges of virtual values ‚Äã‚Äãinto accurate and inaccurate.  By default, a range is considered inaccurate until it is refined by explicitly assigning a constant or variable with an exact range, or by limiting the condition of an if statement or a loop.  If the zero gets inside or on the border of the exact range, then in this case the division by zero diagnosis works. <br><br><h2>  Examples </h2><br>  Now let's look at some examples from real projects found by PVS-Studio using virtual values. <br><br>  <b>Example N1 (RavenDB).</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UrlPathEncodeChar</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, Stream result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">33</span></span> || c &gt; <span class="hljs-number"><span class="hljs-number">126</span></span>) { byte [] bIn = Encoding.UTF8.GetBytes (c.ToString ()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bIn.Length; i++) { .... } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//V3022 result.WriteByte ((byte) '%'); result.WriteByte ((byte) '2'); result.WriteByte ((byte) '0'); } else result.WriteByte ((byte) c); }</span></span></code> </pre> <br>  The first condition of the function <i>UrlPathEncodeChar</i> handles special characters, the second condition is a special optimization for the space.  But since the ASCII code space is 32, the space will be processed by the first block.  PVS-Studio finds this error as follows: inside the <i>if</i> block, the virtual value of the variable <i>c</i> will be [0, 32], [127, char.MaxValue], and inside the first <i>else</i> block all other values: [33, 126].  Since the space code does not fall into this range, the analyzer reports error <a href="http://www.viva64.com/ru/d/0391/">V3022</a> - the expression c == '' is always false. <br><br>  <b>Example N2 (ServiceStack).</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override sealed </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RootDirInfo == null) RootDirInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryInfo(WebHostPhysicalPath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RootDirInfo == null || !RootDirInfo.Exists) <span class="hljs-comment"><span class="hljs-comment">//V3063 throw new ApplicationException("..."); .... }</span></span></code> </pre> <br>  At the beginning of the function <i>Initialize</i> about the property <i>RootDirInfo,</i> we do not know anything.  After analyzing the condition <i>RootDirInfo</i> == <i>null</i> , 2 more copies of virtual values ‚Äã‚Äãare created: one for the <i>if</i> block in which <i>RootDirInfo</i> is <i>null</i> , and the second for the <i>else</i> block in which <i>RootDirInfo is</i> not <i>null</i> .  Although there is no <i>else</i> block in our example, virtual values ‚Äã‚Äãare still created for it.  Further inside the <i>if</i> block, a new value is obtained in the <i>RootDirInfo</i> property, which is obtained as a result of calling the constructor.  Since the constructor never returns <i>null</i> , the <i>RootDirInfo</i> value in the <i>if</i> block <i>is</i> now not <i>null</i> .  Since the <i>RootDirInfo</i> for the <i>else</i> block is also not <i>null</i> , when combining these two branches, we get that <i>RootDirInfo</i> after processing the first condition will never be <i>null</i> .  As a result, when analyzing the second condition, PVS-Studio reports an error <a href="http://www.viva64.com/ru/d/0461/">V3063</a> - part of the condition is always false. <br><br>  <b>Example N3 (ServiceStack).</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TextNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseTypeIntoNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeDef)</span></span></span><span class="hljs-function"> </span></span>{ .... var lastBlockPos = typeDef.IndexOf(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastBlockPos &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-comment"><span class="hljs-comment">//V3022 while (lastBlockPos != -1 || blockStartingPos.Count == 0) { var nextPos = typeDef.IndexOfAny(blockChars, lastBlockPos + 1); if (nextPos == -1) break; .... lastBlockPos = nextPos; } } }</span></span></code> </pre> <br>  Consider what happens in this example with the <i>lastBlockPos</i> variable.  First, the result of calling the <i>IndexOf</i> function is assigned to it.  The analyzer knows that the <i>IndexOf</i> , <i>IndexOfAny</i> , <i>LastIndexOf</i> , <i>LastIndexOfAny functions</i> return a non-negative value or -1.  Therefore, the range of the <i>lastBlockPos</i> variable will be [-1, int.MaxValue].  After entering the <i>if</i> block, the range will be limited only by non-negative values ‚Äã‚Äã[0, int.MaxValue].  Next, the analyzer will run through the body of the <i>while loop</i> .  The variable <i>nextPos,</i> when declared, gets the range [-1, int.MaxValue].  After analyzing the condition if ( <i>nextPos</i> == -1), two copies of the virtual values ‚Äã‚Äãof the variable <i>nextPost are created</i> : [-1] for the <i>if</i> branch and [0, int.MaxValue] for the <i>else</i> branch.  Since the if branch contains the <i>break</i> statement, the rest of the loop body for the <i>nextPost</i> variable uses only the virtual values ‚Äã‚Äãof the <i>else</i> branch: [0, int.MaxValue], which are assigned at the end of the <i>lastBlockPos</i> variable. <br><br>  Thus, we have two transition points to the loop body: one at the entrance to the loop, in which <i>lastBlockPos</i> has the value [0, int.MaxValue] and the second when it goes to the next iteration, at which <i>lastBlockPos</i> also has the value [0, int.MaxValue ].  Therefore, <i>lastBlockPos</i> never accepts negative values ‚Äã‚Äãin the loop condition, which means the loop condition is always true, as reported by the <a href="http://www.viva64.com/ru/d/0391/">V3022</a> diagnostic. <br><br>  It is worth noting that finding this error manually is quite difficult, since the body of the cycle contains about forty lines and to trace the passage through all branches is problematic. <br><br>  <b>Example N4 (TransmissionRemoteDotnet).</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Converts an IPv4 address into a long, for reading from geo database long AddressToLong(IPAddress ip) { long num = 0; byte[] bytes = ip.GetAddressBytes(); for (int i = 0; i &lt; 4; ++i) { long y = bytes[i]; if (y &lt; 0) //V3022 y += 256; num += y &lt;&lt; ((3 - i) * 8); } return num; }</span></span></code> </pre> <br>  Here, the variable y of type <i>long is</i> assigned a value of type <i>byte</i> .  Since the <i>byte</i> type is unsigned, checking <i>y</i> &lt;0 is meaningless. <br><br>  <b>Example N5 (MSBuild).</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateTaskNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> foundInvalidNode = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; foreach (XmlNode childNode in _taskNode.ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (childNode.NodeType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> XmlNodeType.Comment: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> XmlNodeType.Whitespace: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> XmlNodeType.Text: <span class="hljs-comment"><span class="hljs-comment">// These are legal, and ignored continue; case XmlNodeType.Element: if (childNode.Name.Equals("Code") || childNode.Name.Equals("Reference") || childNode.Name.Equals("Using")) { continue; } else { foundInvalidNode = true; } break; default: foundInvalidNode = true; break; } if (foundInvalidNode) //V3022 { .... return false; } } return true; }</span></span></code> </pre> <br>  In this example, the loop body contains two statements ‚Äî <i>switch</i> and <i>if</i> .  Consider the <i>switch</i> block.  The first section with three <i>cases</i> contains only the <i>continue</i> operator, so there can be no transition to checking the condition <i>foundInvalidNode</i> .  The second <i>case</i> section either goes to the next iteration of the loop, or sets <i>foundInvalidNode</i> to <i>true</i> and exits the <i>switch</i> .  And finally, the <i>default</i> section also sets <i>foundInvalidNode</i> to <i>true</i> and exits the <i>switch</i> .  Thus, after exiting the <i>switch, the</i> variable <i>foundInvalidNode</i> will always be true, which means the following <i>if is</i> superfluous.  The analyzer took into account that in this <i>switch</i> block there is a branch of <i>default</i> , which means that control cannot proceed immediately to the condition check - one of the <i>switch</i> sections will be necessarily executed. <br><br>  It should be noted that inside this statement, <i>switch continue</i> is related to the loop, and <i>break</i> exits the <i>switch</i> , not the loop! <br><br><h2>  Conclusion </h2><br>  Calculation of variable values ‚Äã‚Äãat the stage of static analysis is a powerful tool for finding errors.  The code may contain complex branches, nested conditions and loops, blocks of hundreds of lines in size.  Tracing manually how a variable changes and finding an error can be very difficult and the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> static analyzer is a good assistant in the search for many errors. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0394/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Ilya Ivanov.  <a href="http://www.viva64.com/en/b/0394/">Search for errors</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/282998/">https://habr.com/ru/post/282998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282978/index.html">Microsoft DevCon 2016 - Introducing the Final Wave of Community Track Speakers</a></li>
<li><a href="../282984/index.html">How to choose a direction for the development of an IT project: 1cloud experience</a></li>
<li><a href="../282986/index.html">Why MIT is no longer studying SICP</a></li>
<li><a href="../282992/index.html">Transparent communication servers on java and nodejs through Vert</a></li>
<li><a href="../282996/index.html">How to hide your real IP address using a VPN server</a></li>
<li><a href="../283000/index.html">In Q1 2016, 227,000 malware samples were identified daily.</a></li>
<li><a href="../283002/index.html">Mouse gesture editor and other new items in the assembly Vivaldi 1.2.470.11</a></li>
<li><a href="../283004/index.html">How to build a competent testing system? Insights from QA experts on May 19 in St. Petersburg</a></li>
<li><a href="../283008/index.html">Differences between Azure Resource Manager and Azure Service Manager - a developer‚Äôs perspective, part two, about Networking</a></li>
<li><a href="../283010/index.html">Viber received end-to-end encryption by default</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>