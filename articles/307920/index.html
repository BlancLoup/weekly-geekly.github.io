<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Not so easy to reset arrays in VC ++ 2015</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the difference between these two definitions of initialized local C / C ++ variables? 



char buffer[32] = { 0 }; char buffer[32] = {};  
 On...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Not so easy to reset arrays in VC ++ 2015</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/677/7b6/1e1/6777b61e12ed41a0854a63a971955e79.jpg" align="left">  What is the difference between these two definitions of initialized local C / C ++ variables? <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">32</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">32</span></span>] = {};</code> </pre> <br>  One difference is that the first is valid in C and C ++, and the second is only in C ++. <br><br>  Well, then let's focus on C ++.  What <i>do</i> these two definitions <i>mean</i> ? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first one says: the compiler must set the value of the first element of the array to zero and then (roughly speaking) initialize the remaining elements of the array to zero.  The second means that the compiler must initialize the entire array with zeros. <br><br>  These definitions are somewhat different, but in fact the result is one ‚Äî the entire array must be initialized with zeros.  Therefore, according to the ‚Äúas-if‚Äù rule in C ++, they are the same.  That is, any sufficiently modern optimizer should generate identical code for each of these fragments.  Right? <a name="habracut"></a><br><br>  But sometimes the differences in these definitions matter.  If (hypothetically) the compiler takes these definitions to the highest degree literally, then for the first case such code will be generated: <br><br><pre> <code class="hljs vhdl"> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; memset(<span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>);</code> </pre> <br>  while for the second case the code will be as follows: <br><br><pre> <code class="hljs cpp"> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>);</code> </pre> <br>  And if the optimizer does not notice that these two statements can be combined, the compiler can generate a less efficient code for the first definition than for the second. <br><br>  If the compiler literally implemented algorithm 1, then the zero value will be assigned to the first data byte, then (if the processor is 64-bit) three write operations of 8 bytes will be performed.  To fill the remaining seven bytes, 3 more write operations may be required: first write 4 bytes, then 2 and then 1 more byte. <br><br>  Well, this is <i>hypothetical</i> .  This is exactly how VC ++ works.  For 64-bit builds, the typical code generated for "= {0}" looks like this: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax mov BYTE PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">1</span></span>], rax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">9</span></span>], rax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">17</span></span>], rax mov DWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">25</span></span>], eax mov WORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">29</span></span>], ax mov BYTE PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">31</span></span>], al</code> </pre> <br>  Graphically, it looks like this (almost all write operations are not aligned): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1fc/2c5/a7a1fc2c5f0f9d1aee8cf3a9427dfe20.png" alt="image"><br><br>  But if you omit zero, VC ++ will generate the following code: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> eax, eax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp], rax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>], rax mov QWORD PTR <span class="hljs-keyword"><span class="hljs-keyword">buffer</span></span>$[rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>], rax</code> </pre> <br>  What looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b6/2dc/78a/6b62dc78a82b3a0fcb7676e95c71fd29.png" alt="image"><br><br>  The second command sequence is shorter and faster.  The speed difference is usually difficult to measure, but in any case you should prefer a more compact and fast code.  Code size affects performance at all levels (network, disk, cache), so extra code bytes are undesirable. <br><br>  This is generally not important, it probably will not even have any noticeable effect on the size of real programs.  But personally, I find the code generated for ‚Äú= {0};‚Äù rather amusing.  Equivalent to the constant use of "uh" in public speaking. <br><br>  I first noticed this behavior and reported it six years ago, and recently discovered that this problem is still present in VC ++ 2015 Update 3. I was curious and I wrote a small Python script to compile the code below using various array sizes and various optimization options for x86 and x64 platforms: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZeroArray1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[BUF_SIZE] = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚Äú   .%s\n‚Äù, buffer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZeroArray2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[BUF_SIZE] = {}; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚Äú   .%s\n‚Äù, buffer); }</code> </pre> <br>  The graph below shows the size of these two functions in one specific platform configuration ‚Äî size optimization for a 64-bit build ‚Äî versus BUF_SIZE values ‚Äã‚Äãranging from 1 to 32 (when BUF_SIZE value exceeds 32, the size of the code variants are the same): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48d/e30/53e/48de3053e11fd9516631838c6105f408.png" alt="image"><br><br>  In cases where the BUF_SIZE value is 4, 8, and 32, the memory savings are impressive ‚Äî the code size decreases by 23.8%, 17.6%, and 20.5%, respectively.  The average amount of saved memory is 5.4%, and this is quite significant, considering that all these functions have a common epilogue code, a prologue and a call to <i>printf</i> . <br><br>  Here I <i>would like to</i> recommend that all C ++ programmers, when initializing structures and arrays, give preference to ‚Äú= {};‚Äù instead of = ‚Äú= {0};‚Äù.  In my opinion, it is better from an aesthetic point of view, and it seems that it almost always generates a shorter code. <br><br>  But it is "almost."  The results above demonstrate that there are several cases in which ‚Äú= {0};‚Äù generates more optimal code.  For single and double-byte formats, ‚Äú= {0};‚Äù immediately writes a zero to the array (according to the command), while ‚Äú= {};‚Äù resets the register and only then creates such a record.  For the 16-byte format, ‚Äú= {0};‚Äù uses the SSE register to zero all bytes at the same time ‚Äî I don‚Äôt know why this method is not used more often in compilers. <br><br>  So, before recommending anything, I considered it my duty to test various optimization settings for 32-bit and 64-bit systems.  Main results: <br><br>  <i>32-bit with / O1 / Oy-: The average memory saving from 1 to 32 is 3.125 bytes, 5.42%.</i> <i><br></i>  <i>32-bit c / O2 / Ou: The average memory saving from 1 to 40 is 2.075 bytes, 3.29%.</i> <i><br></i>  <i>32-bit c / o2: The average memory saving from 1 to 40 is 1,150 bytes, 1.79%.</i> <i><br></i>  <i>64-bit c / o1: The average memory saving from 1 to 32 is 3,844 bytes, 5.45%</i> <i><br></i>  <i>64-bit w / O2: The average memory saving from 1 to 32 is 3.688 bytes, 5.21%.</i> <br><br>  The problem is that the result for 32-bit / O2 / Ou, where "= {};" is an average of 2.075 bytes <i>more</i> than with "= {0};".  This is true for values ‚Äã‚Äãfrom 32 to 40, where the code ‚Äú= {};‚Äù is usually 22 bytes more!  The reason is that the code ‚Äú= {};‚Äù uses the ‚Äúmovaps‚Äù commands instead of the ‚Äúmovups‚Äù to reset the array.  This means that he has to use a lot of commands only to ensure that the stack is aligned to 16 bytes.  Here is bad luck. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e2/c4a/5e0/1e2c4a5e05c97b6fff79fcee6393f4dd.png" alt="image"><br><br><h1>  findings </h1><br>  I still recommend that C ++ programmers give preference to ‚Äú= {};‚Äù, although some somewhat contradictory results show that the advantage provided by this option is insignificant. <br>  It would be nice if the VC ++ optimizer generated identical code for these two components, and it would be <i>great</i> if this code was always perfect.  Maybe someday it will be? <br><br>  I would like to know why the VC ++ optimizer is so inconsistent when deciding when to use 16-byte SSE registers to reset the memory.  On 64-bit systems, this register is used only for 16-byte buffers initialized with ‚Äú= {0};‚Äù, although a more compact code is usually generated with SSE. <br><br>  I think these difficulties with code generation are also characteristic of a more serious problem related to the fact that adjacent initializers of aggregates are not merged.  However, I have already devoted a lot of time to this issue, so I will leave it at the level of theory. <br><br>  <a href="https%253A%252F%252Frandomascii.wordpress.com%252F2016%252F07%252F17%252Fzeroing-memory-is-hard-vc-2015-arrays%252F%26xtz%3D-180">Here</a> I reported this bug, and the Python script can be found <a href="https://github.com/randomascii/blogstuff/tree/master/ZeroingArrays_2016">here</a> . <br><br>  Please note that the code below, which should also be equivalent, in any case generates even worse code than ZeroArray1 and ZeroArray2. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">32</span></span>] = ‚Äú‚Äù;</code> </pre> <br>  Although I did not test it myself, I heard that the gcc and clang compilers <a href="https://twitter.com/areuugee/status/754888773498867712">did not fall for the bait</a> ‚Äú= {0};‚Äù. <br><br>  In earlier versions of VC ++ 2010, the problem was more serious.  In some cases, a memset call was used, and ‚Äú= {0};‚Äù guaranteed incorrect address alignment under any circumstances.  In earlier versions of VC ++ 2010 CRT, with incorrect alignment, the last 128 bytes of data were recorded four times slower (using the command stosb instead of stosd).  This was quickly fixed. <br><br>  <i>Translated by <a href="http://abbyy-ls.ru/">ABBYY LS</a></i> </div><p>Source: <a href="https://habr.com/ru/post/307920/">https://habr.com/ru/post/307920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307904/index.html">Reducing the temperature in the data center - new research of a number of companies</a></li>
<li><a href="../307908/index.html">Cyclic causality diagram as a tool for modeling complex systems</a></li>
<li><a href="../307910/index.html">Monitoring and alerts for Azure Backup</a></li>
<li><a href="../307912/index.html">SMS and new technologies: how the well forgotten old works</a></li>
<li><a href="../307918/index.html">Nagios - monitor vmware, CMC-TC, Synology, UPS, printers and quite a bit of Cisco</a></li>
<li><a href="../307922/index.html">How we shoot videos for YouTube. Office equipment and rollers</a></li>
<li><a href="../307924/index.html">Preliminary patent applications may appear in Russia</a></li>
<li><a href="../307926/index.html">Basics of game design: 20 board games. Part seven and last: Nikoli puzzles, crosswords</a></li>
<li><a href="../307928/index.html">SEO optimization. Start</a></li>
<li><a href="../307930/index.html">Cloud Technology Myths. Part 1: about "useless" technical support and "clever" services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>