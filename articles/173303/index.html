<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Download PNG and JPEG images in Android NDK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings to all readers! 
 This article will discuss how to download PNG and JPEG images from a file or memory into Android NDK, as well as some usef...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Download PNG and JPEG images in Android NDK</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/3a3/514/e91/3a3514e918f61542198d923febc1871b.jpg">  Greetings to all readers! <br>  This article will discuss how to download PNG and JPEG images from a file or memory into Android NDK, as well as some useful code for feeding these OpenGL images. <br><a name="habracut"></a><br><h4>  Download </h4><br>  To upload images we will use the following libraries: <br><ul><li>  <b>zlib</b> - <a href="http://www.zlib.net/">http://www.zlib.net</a> </li><li>  <b>pnglib</b> - <a href="http://www.libpng.org/pub/png/libpng.html">http://www.libpng.org/pub/png/libpng.html</a> </li><li>  <b>libjpeg-turbo</b> - git clone git: //git.linaro.org/people/tomgall/libjpeg-turbo/libjpeg-turbo.git -b linaro-android </li></ul><br><h4>  Unpack </h4><br>  We decompose everything neatly into folders, for example, create a <b>modules</b> folder in the project root, in the same place where the <b>jni</b> folder is <b>located</b> .  Unpack: <br><ul><li>  pnglib to the <i>modules / pn</i> g folder </li><li>  libjpeg-turbo in <i>modules / jpeg</i> </li><li>  zlib in <i>modules / zlib</i> </li></ul>  so  such structure will turn out <br>  <i>PROJECT / jni</i> <i><br></i>  <i>PROJECT / modules / png</i> <i><br></i>  <i>PROJECT / modules / jpeg</i> <i><br></i>  <i>PROJECT / modules / zlib</i> <i><br></i> <br><h4>  Tune </h4><br><ul><li>  Copy <i>PROJECT / modules / png / scripts / pnglibconf.h.prebuilt</i> to <i>PROJECT / modules / png / pnglibconf.h</i> </li><li>  Open the <i>modules / jpeg / Android.mk</i> file and on line 70, after LOCAL_MODULE: = libjpeg, add: <pre><code class="cpp hljs">ifeq ($(notdir $(MAKECMDGOALS)),libjpeg.a) LOCAL_SRC_FILES += $(libsimd_SOURCES_DIST) include $(BUILD_STATIC_LIBRARY) include $(CLEAR_VARS) LOCAL_MODULE := dummy endif</code> </pre> </li><li>  And in the 11th line we correct the line break <br><pre> <code class="cpp hljs">ifeq ($(ARCH_ARM_HAVE_NEON),<span class="hljs-literal"><span class="hljs-literal">true</span></span>) LOCAL_CFLAGS += -D__ARM_HAVE_NEON endif</code> </pre></li><li>  In the terminal, go to the <i>modules / jpeg</i> folder and execute the following commands to compile the libraries for armv6 and armv7 <pre> <code class="cpp hljs">/PATH_TO_NDK/android-ndk-r8/ndk-build NDK_PROJECT_PATH=. LOCAL_ARM_MODE=arm APP_BUILD_SCRIPT=./Android.mk obj/local/armeabi/libjpeg.a /PATH_TO_NDK/android-ndk-r8/ndk-build NDK_PROJECT_PATH=. LOCAL_ARM_MODE=arm APP_BUILD_SCRIPT=./Android.mk APP_ABI=armeabi-v7a obj/local/armeabi-v7a/libjpeg.a</code> </pre></li></ul><br><h4>  Android.mk rule </h4><br><div class="spoiler">  <b class="spoiler_title">In Android.mk we connect all the libraries together</b> <div class="spoiler_text">  LOCAL_PATH: = $ (call my-dir) <br>  HEADERS: = <br>  STATICLIBS: = <br><br>  include $ (CLEAR_VARS) <br>  LOCAL_MODULE: = png <br>  FILE_LIST: = $ (wildcard $ (LOCAL_PATH) /../ modules / png / *. C *) <br>  LOCAL_SRC_FILES: = $ (FILE_LIST: $ (LOCAL_PATH) /% =%) <br>  LOCAL_EXPORT_C_INCLUDES: = $ (LOCAL_PATH) /../ modules / png <br>  HEADERS + = $ (LOCAL_EXPORT_C_INCLUDES) <br>  STATICLIBS + = $ (LOCAL_MODULE) <br>  include $ (BUILD_STATIC_LIBRARY) <br><br>  include $ (CLEAR_VARS) <br>  LOCAL_MODULE: = zlib <br>  FILE_LIST: = $ (wildcard $ (LOCAL_PATH) /../ modules / zlib / *. C *) <br>  LOCAL_SRC_FILES: = $ (FILE_LIST: $ (LOCAL_PATH) /% =%) <br>  LOCAL_EXPORT_C_INCLUDES: = $ (LOCAL_PATH) /../ modules / zlib <br>  HEADERS + = $ (LOCAL_EXPORT_C_INCLUDES) <br>  STATICLIBS + = $ (LOCAL_MODULE) <br>  include $ (BUILD_STATIC_LIBRARY) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      include $ (CLEAR_VARS) <br>  LOCAL_MODULE: = jpeg <br>  LOCAL_SRC_FILES: = ../modules/jpeg/obj/local/$(TARGET_ARCH_ABI)/libjpeg.a <br>  LOCAL_EXPORT_C_INCLUDES: = $ (LOCAL_PATH) /../ modules / jpeg <br>  STATICLIBS + = $ (LOCAL_MODULE) <br>  HEADERS + = $ (LOCAL_EXPORT_C_INCLUDES) <br>  include $ (PREBUILT_STATIC_LIBRARY) <br><br>  # ------------------------------------------------- --------- <br><br>  include $ (CLEAR_VARS) <br>  LOCAL_ARM_MODE: = arm <br>  LOCAL_MODULE: = LoadImage <br>  LOCAL_SRC_FILES: = loadimage.cpp <br>  LOCAL_CFLAGS: = -Werror -DGL_GLEXT_PROTOTYPES = 1 -fsigned-char -Wno-write-strings -Wno-psabi <br>  LOCAL_LDLIBS: = -llog -lGLESv1_CM <br>  LOCAL_STATIC_LIBRARIES: = $ (STATICLIBS) <br>  LOCAL_C_INCLUDES = $ (HEADERS) <br>  include $ (BUILD_SHARED_LIBRARY) <br></div></div><br><h4>  Reading pictures </h4><br>  In your C ++ code (I have this file <i>loadimage.cpp</i> ), do the following: <br><div class="spoiler">  <b class="spoiler_title">Code with comments</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jni.h&gt; #include &lt;android/log.h&gt; #include &lt;GLES/gl.h&gt; #include &lt;GLES/glext.h&gt; //  extern "C" { #include "png.h" #include &lt;setjmp.h&gt; #include "jpeglib.h" } #define LOG(...) __android_log_print(ANDROID_LOG_VERBOSE, "NDK",__VA_ARGS__) //   struct image { png_uint_32 imWidth, imHeight; //   png_uint_32 glWidth, glHeight; //    OpenGL int bit_depth, color_type; char* data; // RGB/RGBA }; //-       OpenGL static int reNpot(int w) { //  OpenGL      //            //String s = gl.glGetString(GL10.GL_EXTENSIONS); //NON_POWER_OF_TWO_SUPPORTED = s.contains("texture_2D_limited_npot") || s.contains("texture_npot") || s.contains("texture_non_power_of_two"); bool NON_POWER_OF_TWO_SUPPORTED = false; if (NON_POWER_OF_TWO_SUPPORTED) { if (w % 2) w++; } else { if (w &lt;= 4) w = 4; else if (w &lt;= 8) w = 8; else if (w &lt;= 16) w = 16; else if (w &lt;= 32) w = 32; else if (w &lt;= 64) w = 64; else if (w &lt;= 128) w = 128; else if (w &lt;= 256) w = 256; else if (w &lt;= 512) w = 512; else if (w &lt;= 1024) w = 1024; else if (w &lt;= 2048) w = 2048; else if (w &lt;= 4096) w = 4096; } return w; } //-  PNG  static image readPng(const char* fileName) { image im; FILE* file = fopen(fileName, "rb"); // ,       PNG   JPEG,  -      fseek(file, 8, SEEK_CUR); png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL); png_infop info_ptr = png_create_info_struct(png_ptr); png_init_io(png_ptr, file); png_set_sig_bytes(png_ptr, 8); png_read_info(png_ptr, info_ptr); //    png_get_IHDR(png_ptr, info_ptr, &amp;im.imWidth, &amp;im.imHeight, &amp;im.bit_depth, &amp;im.color_type, NULL, NULL, NULL); //     OpenGL im.glWidth = reNpot(im.imWidth); im.glHeight = reNpot(im.imHeight); //        4  (RGBA),  3 (RGB) int row = im.glWidth * (im.color_type == PNG_COLOR_TYPE_RGBA ? 4 : 3); im.data = new char[row * im.glHeight]; //         png_bytep * row_pointers = new png_bytep[im.imHeight]; for(int i = 0; i &lt; im.imHeight; ++i) row_pointers[i] = (png_bytep) (im.data + i * row); //  png_read_image(png_ptr, row_pointers); png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, 0); delete[] row_pointers; return im; } //   libjpeg-turbo struct my_error_mgr { struct jpeg_error_mgr pub; jmp_buf setjmp_buffer; }; typedef struct my_error_mgr * my_error_ptr; METHODDEF(void) my_error_exit(j_common_ptr cinfo) { my_error_ptr myerr = (my_error_ptr) cinfo-&gt;err; (*cinfo-&gt;err-&gt;output_message)(cinfo); longjmp(myerr-&gt;setjmp_buffer, 1); } //-  JPEG  static image readJpeg(const char* fileName) { image im; FILE* file = fopen(fileName, "rb"); struct jpeg_decompress_struct cinfo; struct my_error_mgr jerr; cinfo.err = jpeg_std_error(&amp;jerr.pub); jerr.pub.error_exit = my_error_exit; if (setjmp(jerr.setjmp_buffer)) { jpeg_destroy_decompress(&amp;cinfo); return im; } jpeg_create_decompress(&amp;cinfo); jpeg_stdio_src(&amp;cinfo, file); //    jpeg_read_header(&amp;cinfo, TRUE); jpeg_start_decompress(&amp;cinfo); im.imWidth = cinfo.image_width; im.imHeight = cinfo.image_height; im.glWidth = reNpot(im.imWidth); im.glHeight = reNpot(im.imHeight); //JPEG        3- (RGB) int row = im.glWidth * 3; im.data = new char[row * im.glHeight]; //   unsigned char* line = (unsigned char*) (im.data); while (cinfo.output_scanline &lt; cinfo.output_height) { jpeg_read_scanlines(&amp;cinfo, &amp;line, 1); line += row; } // jpeg_finish_decompress(&amp;cinfo); jpeg_destroy_decompress(&amp;cinfo); return im; }</span></span></span></span></code> </pre></div></div><br><h4>  Tests </h4><br>  We are testing the loading of <b>PNG</b> images from the memory card: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// OpenGL  GLuint texture1; glGenTextures(1, &amp;texture1); glBindTexture(GL_TEXTURE_2D, texture1); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // PNG  image im = readPng("/mnt/sdcard/scrrihs.png"); LOG("PNG: %dx%d (%dx%d) bit:%d type:%d", im.imWidth, im.imHeight, im.glWidth, im.glHeight, im.bit_depth, im.color_type); //       OpenGL if (im.color_type == PNG_COLOR_TYPE_RGBA) { glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, im.glWidth, im.glHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, im.data); } else { glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, im.glWidth, im.glHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, im.data); } delete[] im.data;</span></span></code> </pre><br>  Similarly, we do with <b>JPEG</b> , given that JPEG is always without transparency <br><pre> <code class="cpp hljs">GLuint texture2; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture2); glBindTexture(GL_TEXTURE_2D, texture1); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); image imJpeg = readJpeg(<span class="hljs-string"><span class="hljs-string">"/mnt/sdcard/test.jpg"</span></span>); LOG(<span class="hljs-string"><span class="hljs-string">"JPEG: %dx%d (%dx%d)"</span></span>, imJpeg.imWidth, imJpeg.imHeight, imJpeg.glWidth, imJpeg.glHeight); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, imJpeg.glWidth, imJpeg.glHeight, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_UNSIGNED_BYTE, imJpeg.data); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] imJpeg.data;</code> </pre><br><h4>  Reading encrypted pictures </h4><br>  If you need to use simple image encryption, you can insert the decryption function directly into the image reading process: <br><ul><li>  For PNG, you must specify your own function to read: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userReadData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(png_structp png_ptr, png_bytep data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">png_size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      png_init_io(png_ptr, file);           FILE* file=(FILE*)png_get_io_ptr(png_ptr); //  fread(data, 1, length, file); //  ,   for(int i = 0; i &lt; length; i++) data[i] ^= 73; } ... png_init_io(png_ptr, file); png_set_read_fn(png_ptr, png_get_io_ptr(png_ptr), userReadData); ...</span></span></code> </pre><br></div></div></li><li>  For JPEG, it's a little more difficult.  need to recompile the library.  Open <b>jdatasrc.c</b> and change the following <b>function</b> : <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">METHODDEF (boolean) fill_input_buffer (j_decompress_ptr cinfo) { my_src_ptr src = (my_src_ptr) cinfo-&gt;src; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nbytes; nbytes = JFREAD(src-&gt;infile, src-&gt;buffer, INPUT_BUF_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbytes &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (src-&gt;start_of_file) <span class="hljs-comment"><span class="hljs-comment">/* Treat empty input file as fatal error */</span></span> ERREXIT(cinfo, JERR_INPUT_EMPTY); WARNMS(cinfo, JWRN_JPEG_EOF); <span class="hljs-comment"><span class="hljs-comment">/* Insert a fake EOI marker */</span></span> src-&gt;buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = (JOCTET) <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; src-&gt;buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = (JOCTET) JPEG_EOI; nbytes = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     int i; for(i = 0; i &lt; nbytes; i++) src-&gt;buffer[i] ^= 73; } src-&gt;pub.next_input_byte = src-&gt;buffer; src-&gt;pub.bytes_in_buffer = nbytes; src-&gt;start_of_file = FALSE; return TRUE; }</span></span></code> </pre><br></div></div></li></ul><br><h4>  Reading pictures from memory </h4><br>  For example, the application received a picture over the network and the picture hangs entirely in memory. <br><ul><li>  For PNG, we replace the function of reading from a file with the function of copying from an array: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     struct mypng { unsigned int pos;//    unsigned int length;//  const char* data;//    }; static void userReadData(png_structp png_ptr, png_bytep data, png_size_t length) { //    mypng* png = (mypng*) png_get_io_ptr(png_ptr); //       if (png-&gt;pos + length &gt; png-&gt;length) length += png-&gt;pos-png-&gt;length; if (length &gt; 0) { //    memcpy(data, png-&gt;data + png-&gt;pos, length); //   png-&gt;pos += length; } } ... mypng png = { 8, pngLength, pngData }; png_init_io(png_ptr, (FILE*) &amp;png); png_set_read_fn(png_ptr, png_get_io_ptr(png_ptr), userReadData); ...</span></span></code> </pre></div></div></li><li>  For JPEG, replace the <b>jdatasrc.c</b> file <b>with</b> the following and re-compile the library: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * jdatasrc.c * * Copyright (C) 1994-1996, Thomas G. Lane. * Modified 2009-2010 by Guido Vollbeding. * This file is part of the Independent JPEG Group's software. * For conditions of distribution and use, see the accompanying README file. * * This file contains decompression data source routines for the case of * reading JPEG data from memory or from a file (or any stdio stream). * While these routines are sufficient for most applications, * some will want to use a different source manager. * IMPORTANT: we assume that fread() will correctly transcribe an array of * JOCTETs from 8-bit-wide elements on external storage. If char is wider * than 8 bits on your machine, you may need to do some tweaking. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* this is not a core library module, so it doesn't define JPEG_INTERNALS */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jinclude.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jpeglib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jerror.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Expanded data source object for stdio input */</span></span></span><span class="hljs-meta"> typedef struct { unsigned int pos; unsigned int length; const char* data; } pngrd; typedef struct { struct jpeg_source_mgr pub; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* public fields */</span></span></span><span class="hljs-meta"> pngrd* infile; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* source stream */</span></span></span><span class="hljs-meta"> JOCTET * buffer; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* start of buffer */</span></span></span><span class="hljs-meta"> boolean start_of_file; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* have we gotten any data yet? */</span></span></span><span class="hljs-meta"> } my_source_mgr; typedef my_source_mgr * my_src_ptr; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INPUT_BUF_SIZE 4096 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* choose an efficiently fread'able size */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Initialize source --- called by jpeg_read_header * before any data is actually read. */</span></span></span><span class="hljs-meta"> METHODDEF(void) init_source (j_decompress_ptr cinfo) { } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> JPEG_LIB_VERSION &gt;= 80 METHODDEF(void) init_mem_source (j_decompress_ptr cinfo) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no work necessary here */</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Fill the input buffer --- called whenever buffer is emptied. * * In typical applications, this should read fresh data into the buffer * (ignoring the current state of next_input_byte &amp; bytes_in_buffer), * reset the pointer &amp; count to the start of the buffer, and return TRUE * indicating that the buffer has been reloaded. It is not necessary to * fill the buffer entirely, only to obtain at least one more byte. * * There is no such thing as an EOF return. If the end of the file has been * reached, the routine has a choice of ERREXIT() or inserting fake data into * the buffer. In most cases, generating a warning message and inserting a * fake EOI marker is the best course of action --- this will allow the * decompressor to output however much of the image is there. However, * the resulting error message is misleading if the real problem is an empty * input file, so we handle that case specially. * * In applications that need to be able to suspend compression due to input * not being available yet, a FALSE return indicates that no more data can be * obtained right now, but more may be forthcoming later. In this situation, * the decompressor will return to its caller (with an indication of the * number of scanlines it has read, if any). The application should resume * decompression after it has loaded more data into the input buffer. Note * that there are substantial restrictions on the use of suspension --- see * the documentation. * * When suspending, the decompressor will back up to a convenient restart point * (typically the start of the current MCU). next_input_byte &amp; bytes_in_buffer * indicate where the restart point will be if the current call returns FALSE. * Data beyond this point must be rescanned after resumption, so move it to * the front of the buffer rather than discarding it. */</span></span></span><span class="hljs-meta"> METHODDEF(boolean) fill_input_buffer (j_decompress_ptr cinfo) { static JOCTET mybuffer[4]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The whole JPEG data is expected to reside in the supplied memory * buffer, so any request for more data beyond the given buffer size * is treated as an error. */</span></span></span><span class="hljs-meta"> WARNMS(cinfo, JWRN_JPEG_EOF); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Insert a fake EOI marker */</span></span></span><span class="hljs-meta"> mybuffer[0] = (JOCTET) 0xFF; mybuffer[1] = (JOCTET) JPEG_EOI; cinfo-&gt;src-&gt;next_input_byte = mybuffer; cinfo-&gt;src-&gt;bytes_in_buffer = 2; return TRUE; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> JPEG_LIB_VERSION &gt;= 80 METHODDEF(boolean) fill_mem_input_buffer (j_decompress_ptr cinfo) { static JOCTET mybuffer[4]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The whole JPEG data is expected to reside in the supplied memory * buffer, so any request for more data beyond the given buffer size * is treated as an error. */</span></span></span><span class="hljs-meta"> WARNMS(cinfo, JWRN_JPEG_EOF); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Insert a fake EOI marker */</span></span></span><span class="hljs-meta"> mybuffer[0] = (JOCTET) 0xFF; mybuffer[1] = (JOCTET) JPEG_EOI; cinfo-&gt;src-&gt;next_input_byte = mybuffer; cinfo-&gt;src-&gt;bytes_in_buffer = 2; return TRUE; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Skip data --- used to skip over a potentially large amount of * uninteresting data (such as an APPn marker). * * Writers of suspendable-input applications must note that skip_input_data * is not granted the right to give a suspension return. If the skip extends * beyond the data currently in the buffer, the buffer can be marked empty so * that the next read will cause a fill_input_buffer call that can suspend. * Arranging for additional bytes to be discarded before reloading the input * buffer is the application writer's problem. */</span></span></span><span class="hljs-meta"> METHODDEF(void) skip_input_data (j_decompress_ptr cinfo, long num_bytes) { struct jpeg_source_mgr * src = cinfo-&gt;src; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Just a dumb implementation for now. Could use fseek() except * it doesn't work on pipes. Not clear that being smart is worth * any trouble anyway --- large skips are infrequent. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (num_bytes &gt; 0) { while (num_bytes &gt; (long) src-&gt;bytes_in_buffer) { num_bytes -= (long) src-&gt;bytes_in_buffer; (void) (*src-&gt;fill_input_buffer) (cinfo); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* note we assume that fill_input_buffer will never return FALSE, * so suspension need not be handled. */</span></span></span><span class="hljs-meta"> } src-&gt;next_input_byte += (size_t) num_bytes; src-&gt;bytes_in_buffer -= (size_t) num_bytes; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * An additional method that can be provided by data source modules is the * resync_to_restart method for error recovery in the presence of RST markers. * For the moment, this source module just uses the default resync method * provided by the JPEG library. That method assumes that no backtracking * is possible. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Terminate source --- called by jpeg_finish_decompress * after all data has been read. Often a no-op. * * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding * application must deal with any cleanup that should happen even * for error exit. */</span></span></span><span class="hljs-meta"> METHODDEF(void) term_source (j_decompress_ptr cinfo) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no work necessary here */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Prepare for input from a stdio stream. * The caller must have already opened the stream, and is responsible * for closing it after finishing decompression. */</span></span></span><span class="hljs-meta"> GLOBAL(void) jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile) { struct jpeg_source_mgr * src; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The source object is made permanent so that a series of JPEG images * can be read from the same buffer by calling jpeg_mem_src only before * the first one. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cinfo-&gt;src == NULL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* first time for this JPEG object? */</span></span></span><span class="hljs-meta"> cinfo-&gt;src = (struct jpeg_source_mgr *) (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, SIZEOF(struct jpeg_source_mgr)); } src = cinfo-&gt;src; src-&gt;init_source = init_source; src-&gt;fill_input_buffer = fill_input_buffer; src-&gt;skip_input_data = skip_input_data; src-&gt;resync_to_restart = jpeg_resync_to_restart; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* use default method */</span></span></span><span class="hljs-meta"> src-&gt;term_source = term_source; src-&gt;bytes_in_buffer = (size_t) ((pngrd*)infile)-&gt;length; src-&gt;next_input_byte = (JOCTET *) ((pngrd*)infile)-&gt;data; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> JPEG_LIB_VERSION &gt;= 80 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* * Prepare for input from a supplied memory buffer. * The buffer must contain the whole JPEG data. */</span></span></span><span class="hljs-meta"> GLOBAL(void) jpeg_mem_src (j_decompress_ptr cinfo, unsigned char * inbuffer, unsigned long insize) { struct jpeg_source_mgr * src; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (inbuffer == NULL || insize == 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Treat empty input as fatal error */</span></span></span><span class="hljs-meta"> ERREXIT(cinfo, JERR_INPUT_EMPTY); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The source object is made permanent so that a series of JPEG images * can be read from the same buffer by calling jpeg_mem_src only before * the first one. */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cinfo-&gt;src == NULL) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* first time for this JPEG object? */</span></span></span><span class="hljs-meta"> cinfo-&gt;src = (struct jpeg_source_mgr *) (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, SIZEOF(struct jpeg_source_mgr)); } src = cinfo-&gt;src; src-&gt;init_source = init_mem_source; src-&gt;fill_input_buffer = fill_mem_input_buffer; src-&gt;skip_input_data = skip_input_data; src-&gt;resync_to_restart = jpeg_resync_to_restart; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* use default method */</span></span></span><span class="hljs-meta"> src-&gt;term_source = term_source; src-&gt;bytes_in_buffer = (size_t) insize; src-&gt;next_input_byte = (JOCTET *) inbuffer; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre></div></div>  Use this: <pre> <code class="cpp hljs">... mypng jpeg = { <span class="hljs-number"><span class="hljs-number">0</span></span>, jpegLength, jpegData }; jpeg_create_decompress(&amp;cinfo); jpeg_stdio_src(&amp;cinfo, (FILE*) &amp;jpeg); ...</code> </pre></li></ul><br><h4>  Opengl buns </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   RGBA  RGBA4444 int len = im.glWidth * im.glHeight; unsigned short* tmp = (unsigned short*) im.data; for(int i = 0; i &lt; len; i++) tmp[i] = ((im.data[i * 4] &gt;&gt; 4) &lt;&lt; 12) | ((im.data[i * 4 + 1] &gt;&gt; 4) &lt;&lt; 8) | ((im.data[i * 4 + 2] &gt;&gt; 4) &lt;&lt; 4) | (im.data[i * 4 + 3] &gt;&gt; 4); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, im.glWidth, im.glHeight, 0, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4, im.data); // RGB   RGB565 int len = im.glWidth * im.glHeight; unsigned short* tmp = (unsigned short*) im.data; for(int i = 0; i &lt; len; i++) tmp[i] = ((im.data[i * row] &gt;&gt; 3) &lt;&lt; 11) | ((im.data[i * row + 1] &gt;&gt; 2) &lt;&lt; 5) | (im.data[i * row + 2] &gt;&gt; 3); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, im.glWidth, im.glHeight, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, im.data); //  RGB/RGBA   GL_LUMINANCE  GL_ALPHA int row = HAS_ALPHA?4:3; int len = im.glWidth * im.glHeight * row; for(int i = 0, a = 0; i &lt; len; i += row, a++) im.data[a] = im.data[i]; glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, im.glWidth, im.glHeight, 0, GL_ALPHA, GL_UNSIGNED_BYTE, im.data);</span></span></code> </pre><br>  It's okay that in the loop the array writes to itself because  the final array is always smaller than the original array and after creating the OpenGL texture, we no longer need it. <br><br>  I am sure someone these developments will be useful.  In any case, before that, I had to throw downloaded files through JNI to Java, create a Bitmap there, read pixels and give back to the NDK, which was an order of magnitude more expensive both in time and in memory.  In addition, all these functions can be used not only in the Android NDK, but also in iOS / MacOS. <br>  Just in case, here are the commands for compiling libjpeg-turbo (libpng compiles without problems by simply adding a folder to XCode): <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  cd {source_directory} <br>  autoreconf -fiv <br>  mkdir build <br>  cd build <br><br>  MacOS <br>  sh ../configure --host i686-apple-darwin CFLAGS = '- O3 -m32' LDFLAGS = -m32 <br><br>  iOS ARM v7 only <br>  sh ../configure --host arm-apple-darwin10 --enable-static --disable-shared CC = "/ Applications / Xcode.app / Contents / Developer / Platforms / iPhoneOS.platform / Developer / usr / bin / arm -apple-darwin10-llvm-gcc-4.2 "LD =" / Applications / Xcode.app / Contents / Developer / Platforms / iPhoneOS.platform / Developer / usr / bin / arm-apple-darwin10-llvm-gcc-4.2 "CFLAGS = "- mfloat-abi = softfp -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk -O3 -march = armv7 -mcpu = cortex-a8 -mtune = cortex-a8 -mfpu = neon "LDFLAGS =" - mfloat-abi = softfp -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS6.1.sdk -march = armv7 -mcpu = cortex-a8 -mtune = cortex-a8 -mfpu = neon " <br></div></div><br>  <b>Update:</b> <br>  The zlib library can be connected to the native of the NDK.  To do this, in Android.mk, you need to remove the block that concerns zlib and register: <br><pre> <code class="cpp hljs">LOCAL_LDLIBS := -llog -lGLESv1_CM -lz</code> </pre><br></div><p>Source: <a href="https://habr.com/ru/post/173303/">https://habr.com/ru/post/173303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173291/index.html">Re-flashing network storage NS-2502 from Edimax through the console cable</a></li>
<li><a href="../173293/index.html">Installing your own applications without a developer certificate in 7 steps</a></li>
<li><a href="../173295/index.html">Simple rules for accepting payments on the site</a></li>
<li><a href="../173297/index.html">Computing Exchange</a></li>
<li><a href="../173301/index.html">Scanning networks from iOS</a></li>
<li><a href="../173305/index.html">Fujitsu software will detect your pulse in the face</a></li>
<li><a href="../173307/index.html">Who is shorter</a></li>
<li><a href="../173309/index.html">Why does Google think that users will like Google Currents instead of Google Reader?</a></li>
<li><a href="../173311/index.html">Enumeration implementation (Enum) in PHP with type checking</a></li>
<li><a href="../173313/index.html">CMS Koken for photo galleries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>