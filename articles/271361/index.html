<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nim Tutorial (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note from the translator  The first part is here: "Nim Tutorial (Part 1)" 

 The translation was done for myself, that is clumsily and in haste. The w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nim Tutorial (Part 2)</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Note from the translator</b> <div class="spoiler_text">  The first part is here: <a href="http://habrahabr.ru/post/271197/">"Nim Tutorial (Part 1)"</a> <br><br>  The translation was done for myself, that is clumsily and in haste.  The wording of some phrases had to give birth in terrible agony, so that they even remotely resembled Russian.  Who knows how to write better - write in a personal, I will rule. <br></div></div><br><br><h2>  Introduction </h2><br><blockquote>  "Repetition gives absurdity a look of prudence." - Norman Wildberger </blockquote><br>  <em>(Original: "Repetition renders the ridiculous reasonable." - Norman Wildberger)</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This document is a tutorial on the complex constructs of the <em>Nim</em> language <em>.</em>  <strong>Remember that this document is somewhat out of date, and the manual has many more relevant examples on the complex features of the language.</strong> <br><br><a name="habracut"></a><h2>  Pragmas </h2><br>  Pragmas are Nim's way of telling the compiler additional information or commands without entering new keywords.  Pragmas are enclosed in special curly braces with dots <code>{. and .}</code>  <code>{. and .}</code> .  They are not covered in this tutorial.  For a list of available pragmas, refer to the <a href="http://nim-lang.org/docs/manual.html">manual</a> or <a href="http://nim-lang.org/docs/nimc.html">user manual</a> . <br><br><h2>  Object oriented programming </h2><br>  Although support for object-oriented programming (OOP) in Nim is minimalist, powerful OOP techniques can still be used.  OOP is considered to be <em>one of,</em> but not the <em>only</em> way to develop programs.  It happens that the procedural approach simplifies the code and increases its efficiency.  For example, using composition instead of inheritance often leads to a better architecture. <br><br><h3>  Objects </h3><br>  Objects, like tuples, are designed to pack different values ‚Äã‚Äãinto a single structure.  But objects have some features that tuples do not have: inheritance and information hiding.  Since objects encapsulate data, the <code>T()</code> object constructor is usually used only in internal development, and the programmer must provide a special procedure for initialization (it is called a <em>constructor).</em> <br><br>  Objects have access to their type at run time.  There is an operator <code>of</code> , with which you can check the type of an object: <br><br><pre> <code class="ruby hljs">type Person = ref object of RootObj name*: string <span class="hljs-comment"><span class="hljs-comment">#  * ,  `name`      age: int #         Student = ref object of Person # Student   Person id: int #    id var student: Student person: Person assert(student of Student) #  true #  : student = Student(name: "Anton", age: 5, id: 2) echo student[]</span></span></code> </pre><br>  Object fields that should be visible outside the module in which they are defined are marked with an asterisk ( <code>*</code> ).  Unlike tuples, different object types are never <em>equivalent.</em>  New object types can only be defined in the type section. <br><br>  Inheritance is done using <code>object of</code> syntax.  Multiple inheritance is not currently supported.  If there is no suitable ancestor for the object type, then it can be made the <code>RootObj</code> ancestor, but this is just an agreement.  Objects without an ancestor are implicitly declared as <code>final</code> .  To enter a new object that is not inherited from <code>system.RootObj</code> , you can use the <code>inheritable</code> pragma (this is used, for example, in the GTK wrapper). <br><br>  Reference objects can be used regardless of inheritance.  This is not strictly necessary, but if non-reference objects are assigned, for example, <code>let person: Person = Student(id: 123)</code> fields of the child class will be truncated. <br><blockquote>  <strong>Note:</strong> for simple code reuse, composition ( <em>‚Äúpart of‚Äù</em> relation <em>) is</em> often preferable to inheritance ( <em>‚Äúis‚Äù</em> relation <em>).</em>  .  Because objects in Nim are value types, composition is just as effective as inheritance. </blockquote><br><h3>  Mutually Recursive Types </h3><br>  With the help of objects, tuples, and links, you can model rather complex data structures that are dependent on each other and, thus, <em>mutually recursive.</em>  In Nim, such types can only be declared within a single type section.  (Other solutions would require additional character viewing, which slows down compilation.) <br><br>  Example: <br><br><pre> <code class="ruby hljs">type Node = ref NodeObj <span class="hljs-comment"><span class="hljs-comment">#    NodeObj NodeObj = object le, ri: Node #     sym: ref Sym # ,    Sym Sym = object #  name: string #   line: int # ,      code: PNode #    </span></span></code> </pre><br><h3>  Type conversion </h3><br>  Nim distinguishes between type casts and type conversions.  The cast is done using the <code>cast</code> operator and forces the compiler to interpret binary data as the specified type. <br><br>  Type conversion is a more elegant way to turn one type into another: it checks whether types can be converted.  If type conversion is not possible, either the compiler will report this, or an exception will be thrown. <br><br>  The syntax for type conversion is: <code>destination_type(expression_to_convert)</code> (like a normal call). <br><br><pre> <code class="ruby hljs">proc getID(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> Person): int = Student(x).id</code> </pre><br>  If <code>x</code> not an instance of <code>Student</code> , then an <code>InvalidObjectConversionError</code> will be thrown. <br><br><h3>  Variant objects </h3><br>  There are situations for which the object hierarchy is overkill, and everything can be solved by simple variant types. <br><br>  For example: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,        #   Nim type NodeKind = enum #     nkInt, #     nkFloat, #       nkString, #     nkAdd, #  nkSub, #  nkIf #  if Node = ref NodeObj NodeObj = object case kind: NodeKind #  ``kind``   of nkInt: intVal: int of nkFloat: floatVal: float of nkString: strVal: string of nkAdd, nkSub: leftOp, rightOp: PNode of nkIf: condition, thenPart, elsePart: PNode var n = PNode(kind: nkFloat, floatVal: 1.0) #     `FieldError`,   # n.kind  : n.strVal = ""</span></span></code> </pre><br>  As you can see from the example, unlike the object hierarchy, there is no need to do transformations between different object types.  However, accessing the wrong fields of an object raises an exception. <br><br><h3>  Methods </h3><br>  In ordinary object-oriented languages, procedures (also called <em>methods) are</em> tied to a class.  This approach has the following disadvantages: <br><ul><li>  adding a method to the class, the programmer either loses control of it, or makes clumsy workarounds if it is necessary to work with the method separately from the class; </li><li>  it is often unclear what the method should relate to: <code>join</code> is a string or array method? </li></ul><br>  Nim avoids these problems by not associating methods with classes.  All methods in Nim are multi methods.  As we will see later, multimethods differ from procedures only with dynamic binding. <br><br><h3>  Method Call Syntax </h3><br>  For calling subroutines in Nim there is a special syntactic sugar: the construction <code>obj.method(args)</code> means the same as <code>method(obj, args)</code> .  If there are no arguments, then you can skip parentheses: <code>obj.len</code> instead of <code>len(obj)</code> . <br><br>  This method call syntax is not limited to objects, it can be used for any type: <br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>.len) <span class="hljs-comment"><span class="hljs-comment">#  ,   echo(len("abc")) echo("abc".toUpper()) echo({'a', 'b', 'c'}.card) stdout.writeLine("Hallo") #  ,   writeLine(stdout, "Hallo")</span></span></code> </pre><br>  (Another point of view on the method call syntax is that it implements the missing postfix notation.) <br><br>  This makes it easy to write "clean object-oriented code": <br><br><pre> <code class="ruby hljs">import strutils, sequtils stdout.writeLine(<span class="hljs-string"><span class="hljs-string">"Give a list of numbers (separated by spaces): "</span></span>) stdout.write(stdin.readLine.split.map(parseInt).max.<span class="hljs-string"><span class="hljs-string">`$`</span></span>) stdout.writeLine(<span class="hljs-string"><span class="hljs-string">" is the maximum!"</span></span>)</code> </pre><br><h3>  Properties </h3><br>  As you can see from the example above, Nim does not need <em>get-properties:</em> they are replaced by ordinary get-procedures, called using <em>the method call syntax.</em>  But assigning a value is another matter; for this, a special syntax is needed: <br><br><pre> <code class="ruby hljs">type Socket* = ref object of RootObj <span class="hljs-symbol"><span class="hljs-symbol">host:</span></span> int <span class="hljs-comment"><span class="hljs-comment">#  ,   proc `host=`*(s: var Socket, value: int) {.inline.} = ##    s.host = value proc host*(s: Socket): int {.inline.} = ##    s.host var s: Socket new s s.host = 34 #  ,   `host=`(s, 34)</span></span></code> </pre><br>  (The example also shows <code>inline</code> procedures.) <br><br>  To implement array properties, you can overload the array access operator <code>[]</code> : <br><br><pre> <code class="ruby hljs">type Vector* = object x, y, <span class="hljs-symbol"><span class="hljs-symbol">z:</span></span> float proc <span class="hljs-string"><span class="hljs-string">`[]=`</span></span>* (<span class="hljs-symbol"><span class="hljs-symbol">v:</span></span> var Vector, <span class="hljs-symbol"><span class="hljs-symbol">i:</span></span> int, <span class="hljs-symbol"><span class="hljs-symbol">value:</span></span> float) = <span class="hljs-comment"><span class="hljs-comment"># setter case i of 0: vx = value of 1: vy = value of 2: vz = value else: assert(false) proc `[]`* (v: Vector, i: int): float = # getter case i of 0: result = vx of 1: result = vy of 2: result = vz else: assert(false)</span></span></code> </pre><br>  The example is clumsy, since the vector is best modeled by a tuple that already has access to <code>v[]</code> . <br><br><h3>  Dynamic binding (dynamic dispatch) </h3><br>  Procedures always use static binding.  For dynamic binding, replace the <code>proc</code> keyword with <code>method</code> : <br><br><pre> <code class="ruby hljs">type PExpr = ref object of RootObj <span class="hljs-comment"><span class="hljs-comment">##      PLiteral = ref object of PExpr x: int PPlusExpr = ref object of PExpr a, b: PExpr #  : 'eval'     method eval(e: PExpr): int = #    quit "to override!" method eval(e: PLiteral): int = ex method eval(e: PPlusExpr): int = eval(ea) + eval(eb) proc newLit(x: int): PLiteral = PLiteral(x: x) proc newPlus(a, b: PExpr): PPlusExpr = PPlusExpr(a: a, b: b) echo eval(newPlus(newPlus(newLit(1), newLit(2)), newLit(4)))</span></span></code> </pre><br>  Notice that in the example, the constructors <code>newLit</code> and <code>newPlus</code> are procedures, since for them it is better to use static binding, and <code>eval</code> already a method, because it needs dynamic binding. <br><br>  In a multimethod, all parameters that have an object type are used for binding: <br><br><pre> <code class="ruby hljs">type Thing = ref object of RootObj Unit = ref object of Thing <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int method collide(a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> Thing) {.inline.} = quit <span class="hljs-string"><span class="hljs-string">"to override!"</span></span> method collide(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> Thing, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> Unit) {.inline.} = echo <span class="hljs-string"><span class="hljs-string">"1"</span></span> method collide(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> Unit, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> Thing) {.inline.} = echo <span class="hljs-string"><span class="hljs-string">"2"</span></span> var a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> Unit new a new b collide(a, b) <span class="hljs-comment"><span class="hljs-comment">#  : 2</span></span></code> </pre><br>  It can be seen from the example that a multimethod call cannot be ambiguous: <code>collide</code> 2 is preferable to <code>collide</code> 1, since the resolution works from left to right.  Thus, <code>Unit</code> , <code>Thing</code> preferable to <code>Thing</code> , <code>Unit</code> . <br><blockquote>  <strong>Performance note</strong> : Nim does not create a table of virtual methods, but generates dispatch trees.  This avoids costly indirect branching on method calls and allows embedding.  But other optimizations, such as computations at compile time or removing dead code, do not work with methods. </blockquote><br><h2>  Exceptions </h2><br>  In Nim, exceptions are objects.  By convention, exception types end with ‚ÄúError‚Äù.  The <code>system</code> module defines an exception hierarchy to which you can bind.  Exceptions occur from <code>system.Exception</code> , which provides a generic interface. <br><br>  Exceptions should be placed on the heap, since their lifetime is unknown.  The compiler will not allow you to raise an exception placed on the stack.  All excited exceptions should at least indicate the reason for their occurrence in the <code>msg</code> field. <br><br>  It is assumed that exceptions should be raised in <em>exceptional</em> cases: for example, if a file cannot be opened, it should not raise exceptions (the file may not exist). <br><br><h3>  <code>raise</code> command </h3><br>  Exceptions are raised using the <code>raise</code> command: <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">e:</span></span> ref OSError new(e) e.msg = <span class="hljs-string"><span class="hljs-string">"the request to the OS failed"</span></span> raise e</code> </pre><br>  If the <code>raise</code> keyword is not followed by an expression, the last exception is <em>raised again</em> .  In order not to write the above code, you can use the <code>newException</code> template from the <code>system</code> module: <br><br><pre> <code class="ruby hljs">raise newException(OSError, <span class="hljs-string"><span class="hljs-string">"the request to the OS failed"</span></span>)</code> </pre><br><h3>  <code>try</code> command </h3><br>  The <code>try</code> command handles exceptions: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,    ,  #    var f: File if open(f, "numbers.txt"): try: let a = readLine(f) let b = readLine(f) echo "sum: ", parseInt(a) + parseInt(b) except OverflowError: echo "overflow!" except ValueError: echo "could not convert string to integer" except IOError: echo "IO error!" except: echo "Unknown exception!" # reraise the unknown exception: raise finally: close(f)</span></span></code> </pre><br>  Commands after <code>try</code> are executed until an exception occurs.  In this case, the corresponding <code>except</code> branch will be executed. <br><br>  An empty <code>except</code> block is executed if the exception that is thrown is not included in the list of those explicitly listed.  This is similar to the <code>else</code> branch in the <code>if</code> command. <br><br>  If the <code>finally</code> branch is present, then it is always executed after executing exception handlers. <br><br>  The exception is <em>absorbed</em> in the <code>except</code> branch.  If an exception is not handled, it is distributed through the call stack.  This means that if an exception occurs, the rest of the procedure, which is not inside the <code>finally</code> block, will not be executed. <br><br>  If you need to get the current exception object or its message within the <code>except</code> branch, you can use the <code>getCurrentException()</code> and <code>getCurrentExceptionMsg()</code> procedures from the <code>system</code> module.  Example: <br><br><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">try:</span></span> doSomethingHere() <span class="hljs-symbol"><span class="hljs-symbol">except:</span></span> let e = getCurrentException() msg = getCurrentExceptionMsg() echo <span class="hljs-string"><span class="hljs-string">"Got exception "</span></span>, repr(e), <span class="hljs-string"><span class="hljs-string">" with message "</span></span>, msg</code> </pre><br><h3>  Annotation of procedures by exclusions </h3><br>  Using the optional <code>{.raises.}</code> you can specify that the procedure can raise a specific set of exceptions or not raise exceptions at all.  If the <code>{.raises.}</code> Pragma is used, the compiler will verify that it is true.  For example, if you specify that the procedure raises <code>IOError</code> , and at some point it (or one of the called procedures) raises another exception, the compiler will refuse to compile it.  Usage example: <br><br><pre> <code class="ruby hljs">proc complexProc() {.<span class="hljs-symbol"><span class="hljs-symbol">raises:</span></span> [IOError, ArithmeticError].} = ... proc simpleProc() {.<span class="hljs-symbol"><span class="hljs-symbol">raises:</span></span> [].} = ...</code> </pre><br>  After you have such a code, if the list of exceptions changes, the compiler stops with an error indicating the line in the procedure that stopped the pragma validation and the exception that is not in the list.  In addition, there will also be a file and a line where the exception appeared, which will help you find a suspicious code, the change of which led to this. <br><br>  If you want to add the <code>{.raises.}</code> to existing code, the compiler can also help you.  You can add the pragma command <code>{.effects.}</code> To the procedure and the compiler will output all the effects that appear at this point (exception tracking is part of the Nim effect system).  Another workaround for getting the list of exceptions thrown by the procedure is to use the Nim <code>doc2</code> , which generates documentation for the entire module and decorates all the procedures with a list of the exceptions thrown.  You can read more about <a href="http://nim-lang.org/docs/manual.html">the effects system and the corresponding pragmas in the manual</a> . <br><br><h2>  Generalizations </h2><br>  Generalizations are what allow Nim to parameterize procedures, iterators, or types using type parameters.  They are most useful for creating high-performance type safe containers: <br><br><pre> <code class="ruby hljs">type BinaryTreeObj[T] = object <span class="hljs-comment"><span class="hljs-comment"># BinaryTree      #  ``T`` le, ri: BinaryTree[T] #    ;   nil data: T #     BinaryTree*[T] = ref BinaryTreeObj[T] # ,   proc newNode*[T](data: T): BinaryTree[T] = #   new(result) result.data = data proc add*[T](root: var BinaryTree[T], n: BinaryTree[T]) = #     if root == nil: root = n else: var it = root while it != nil: #   ;    ``cmp`` #     ,   ``==``  ``&lt;`` var c = cmp(it.data, n.data) if c &lt; 0: if it.le == nil: it.le = n return it = it.le else: if it.ri == nil: it.ri = n return it = it.ri proc add*[T](root: var BinaryTree[T], data: T) = #  : add(root, newNode(data)) iterator preorder*[T](root: BinaryTree[T]): T = #     .   #    ,    (    # ): var stack: seq[BinaryTree[T]] = @[root] while stack.len &gt; 0: var n = stack.pop() while n != nil: yield n.data add(stack, n.ri) #      n = n.le #      var root: BinaryTree[string] #  BinaryTree  ``string`` add(root, newNode("hello")) #  ``newNode``    add(root, "world") #     for str in preorder(root): stdout.writeLine(str)</span></span></code> </pre><br>  The example shows a generic binary tree.  Depending on the context, square brackets are used either to enter type parameters or to instantiate a generic procedure, an iterator, or a type.  As you can see from the example, generalizations work with overload: the best match is used.  The built-in <code>add</code> procedure for sequences is not hidden and is used in the <code>preorder</code> iterator. <br><br><h2>  Templates </h2><br>  Patterns are a simple substitution mechanism that operates on abstract Nim syntax trees (AST).  Templates are processed on a semantic compilation pass.  They are well integrated with the rest of the language and do not have the usual drawbacks of C-shny preprocessor macros. <br><br>  To <em>call a</em> template, call it as a procedure. <br><br>  Example: <br><br><pre> <code class="ruby hljs">template <span class="hljs-string"><span class="hljs-string">`!=`</span></span> (a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> expr): expr = <span class="hljs-comment"><span class="hljs-comment">#      System not (a == b) assert(5 != 6) #    : assert(not (5 == 6))</span></span></code> </pre><br>  Operators <code>!=</code> , <code>&gt;</code> , <code>&gt;=</code> , <code>in</code> , <code>isnot</code> , <code>isnot</code> are actually templates: as a result, if you overloaded the operator <code>==</code> , then the operator <code>!=</code> Becomes available automatically and works correctly (except for floating-point numbers IEEE - <code>NaN</code> breaks a strict boolean logic). <br><br>  <code>a &gt; b</code> turns into <code>b &lt; a</code> .  <code>a in b</code> transforms into <code>contains(b, a)</code> .  <code>isnot</code> and <code>isnot</code> get the obvious meaning. <br><br>  Patterns are especially useful when it comes to lazy computing.  Consider a simple procedure for logging: <br><br><pre> <code class="ruby hljs">const debug = <span class="hljs-literal"><span class="hljs-literal">true</span></span> proc log(<span class="hljs-symbol"><span class="hljs-symbol">msg:</span></span> string) {.inline.} = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-symbol"><span class="hljs-symbol">debug:</span></span> stdout.writeLine(msg) var x = <span class="hljs-number"><span class="hljs-number">4</span></span> log(<span class="hljs-string"><span class="hljs-string">"x has the value: "</span></span> &amp; $x)</code> </pre><br>  There is a flaw in this code: if <code>debug</code> once set to <code>false</code> , then the rather costly operations <code>$</code> and <code>&amp;</code> will still be executed!  (The calculation of the arguments for the procedures is made "greedy.") <br><br>  Turning the <code>log</code> procedure into a template solves this problem: <br><br><pre> <code class="ruby hljs">const debug = <span class="hljs-literal"><span class="hljs-literal">true</span></span> template log(<span class="hljs-symbol"><span class="hljs-symbol">msg:</span></span> string) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-symbol"><span class="hljs-symbol">debug:</span></span> stdout.writeLine(msg) var x = <span class="hljs-number"><span class="hljs-number">4</span></span> log(<span class="hljs-string"><span class="hljs-string">"x has the value: "</span></span> &amp; $x)</code> </pre><br>  Parameter types can be ordinary types or metatypes <code>expr</code> (for <em>expressions),</em> <code>stmt</code> (for <em>commands)</em> or <code>typedesc</code> (for <em>type</em> <code>typedesc</code> <em>).</em>  If the template does not explicitly indicate the type of the return value, then <code>stmt</code> used for compatibility with procedures and methods. <br><br>  If there is a <code>stmt</code> parameter, then it must be the last in the template declaration.  The reason is that the commands are passed to the template using a special syntax with a colon ( <code>:</code> : <br><br><pre> <code class="ruby hljs">template withFile(<span class="hljs-symbol"><span class="hljs-symbol">f:</span></span> expr, <span class="hljs-symbol"><span class="hljs-symbol">filename:</span></span> string, <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> FileMode, <span class="hljs-symbol"><span class="hljs-symbol">body:</span></span> stmt): stmt {.immediate.} = let fn = filename var <span class="hljs-symbol"><span class="hljs-symbol">f:</span></span> File <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> open(f, fn, mode): <span class="hljs-symbol"><span class="hljs-symbol">try:</span></span> body <span class="hljs-symbol"><span class="hljs-symbol">finally:</span></span> close(f) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> quit(<span class="hljs-string"><span class="hljs-string">"cannot open: "</span></span> &amp; fn) withFile(txt, <span class="hljs-string"><span class="hljs-string">"ttempl3.txt"</span></span>, fmWrite): txt.writeLine(<span class="hljs-string"><span class="hljs-string">"line 1"</span></span>) txt.writeLine(<span class="hljs-string"><span class="hljs-string">"line 2"</span></span>)</code> </pre><br>  In the example, two <code>writeLine</code> commands <code>writeLine</code> bound to the <code>body</code> parameter.  The <code>withFile</code> template contains service code and helps avoid a common problem: forget to close the file.  Note that the <code>let fn = filename</code> command ensures that the <code>filename</code> will be evaluated only once. <br><br><h2>  Macros </h2><br>  Macros allow intensive transformation of the code at the compilation stage, but they cannot change the syntax of Nim.  But this is not a serious limitation, since the syntax of Nim is quite flexible.  Macros must be implemented on pure Nim, since the <a href="http://nim-lang.org/docs/manual.html">interface of external functions (FFI) is</a> not allowed in the compiler, but apart from this restriction (which will be removed sometime in the future) you can write any code on Nim and the compiler will run it at compile time . <br><br>  There are two ways of writing macros: either <em>generating</em> the Nim source code and passing it to the compiler for parsing, or manually creating an abstract syntax tree (AST) that is fed to the compiler.  To build an AST, you need to know how a particular Nim syntax is converted to an abstract syntax tree.  AST is documented in the <code>macros</code> module. <br><br>  When your macro is ready, there are two ways to call it: <br><ol><li>  macro call as a procedure (expression macro) </li><li>  macro call using special <code>macrostmt</code> syntax (command macro) </li></ol><br><h3>  Expression macros </h3><br>  The following example implements a powerful <code>debug</code> command that takes any number of arguments: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#      Nim   API,  #   ``macros``: import macros macro debug(n: varargs[expr]): stmt = # `n`  AST Nim,   ; #     : result = newNimNode(nnkStmtList, n) #  ,   : for i in 0..n.len-1: #     ,   ; # `toStrLit`  AST    : result.add(newCall("write", newIdentNode("stdout"), toStrLit(n[i]))) #     ,   ": " result.add(newCall("write", newIdentNode("stdout"), newStrLitNode(": "))) #     ,    : result.add(newCall("writeLine", newIdentNode("stdout"), n[i])) var a: array[0..10, int] x = "some string" a[0] = 42 a[1] = 45 debug(a[0], a[1], x)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The macro call expands to: </font></font><br><br><pre> <code class="ruby hljs">write(stdout, <span class="hljs-string"><span class="hljs-string">"a[0]"</span></span>) write(stdout, <span class="hljs-string"><span class="hljs-string">": "</span></span>) writeLine(stdout, a[<span class="hljs-number"><span class="hljs-number">0</span></span>]) write(stdout, <span class="hljs-string"><span class="hljs-string">"a[1]"</span></span>) write(stdout, <span class="hljs-string"><span class="hljs-string">": "</span></span>) writeLine(stdout, a[<span class="hljs-number"><span class="hljs-number">1</span></span>]) write(stdout, <span class="hljs-string"><span class="hljs-string">"x"</span></span>) write(stdout, <span class="hljs-string"><span class="hljs-string">": "</span></span>) writeLine(stdout, x)</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Command macros </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command macros are defined in the same way as expression macros. </font><font style="vertical-align: inherit;">But they are called through an expression ending with a colon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following example shows a macro that generates a lexical analyzer for regular expressions:</font></font><br><br><pre> <code class="ruby hljs">macro case_token(<span class="hljs-symbol"><span class="hljs-symbol">n:</span></span> stmt): stmt = <span class="hljs-comment"><span class="hljs-comment">#       # ... ( --    :-) discard case_token: #    ,     of r"[A-Za-z_]+[A-Za-z_0-9]*": return tkIdentifier of r"0-9+": return tkInteger of r"[\+\-\*\?]+": return tkOperator else: return tkUnknown</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create your first macro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To give you directions on how to write macros, we will demonstrate how to turn your typical dynamic code into something that can be compiled statically. </font><font style="vertical-align: inherit;">For example, we use the following code fragment as a starting point:</font></font><br><br><pre> <code class="ruby hljs">import strutils, tables proc readCfgAtRuntime(<span class="hljs-symbol"><span class="hljs-symbol">cfgFilename:</span></span> string): Table[string, string] = let inputString = readFile(cfgFilename) var source = <span class="hljs-string"><span class="hljs-string">""</span></span> result = initTable[string, string]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inputString.<span class="hljs-symbol"><span class="hljs-symbol">splitLines:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    if line.len &lt; 1: continue var chunks = split(line, ',') if chunks.len != 2: quit("Input needs comma split values, got: " &amp; line) result[chunks[0]] = chunks[1] if result.len &lt; 1: quit("Input file empty!") let info = readCfgAtRuntime("data.cfg") when isMainModule: echo info["licenseOwner"] echo info["licenseKey"] echo info["version"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presumably, this code snippet could be used in commercial programs to read the configuration file and display information about who bought the program. </font><font style="vertical-align: inherit;">This external file could be generated at purchase to include licensing information in the program:</font></font><br><br><pre> <code class="ruby hljs">version,<span class="hljs-number"><span class="hljs-number">1.1</span></span> licenseOwner,Hyori Lee licenseKey,M1Tl3PjBWO2CC48m</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The procedure </font></font><code>readCfgAtRuntime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will open the given file name and return </font></font><code>Table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the module </font></font><code>tables</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. File parsing is done (without error handling or boundary cases) using a procedure </font></font><code>splitLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from a module </font></font><code>strutils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. There are many things that can go wrong; Remember that it explains how to run the code at compile time, and not how to implement copy protection correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing this code as a compile stage procedure will allow us to get rid of the file </font></font><code>data.cfg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that would otherwise need to be distributed along with the binary. Plus, if the information is really constant, then from the point of view of logic, there is no sense in keeping it </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changeable.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global variable, better if it is constant. </font><font style="vertical-align: inherit;">Finally, one of the most valuable pieces is that we can implement some checks at the compilation stage. </font><font style="vertical-align: inherit;">You can take it as </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an improved unit test,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which does not allow you to get a binary in which something is not working. </font><font style="vertical-align: inherit;">This prevents users from delivering broken programs that do not start because of a failure in one small critical file.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Source Code Generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to change the program so that at the compilation stage we can create a line with the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generated source code,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which we then pass to the procedure </font></font><code>parseStmt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the module </font></font><code>macros</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is the modified source code that implements the macro:</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> import macros, strutils <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> macro readCfgAndBuildSource(<span class="hljs-symbol"><span class="hljs-symbol">cfgFilename:</span></span> string): stmt = <span class="hljs-number"><span class="hljs-number">4</span></span> let <span class="hljs-number"><span class="hljs-number">5</span></span> inputString = slurp(cfgFilename.strVal) <span class="hljs-number"><span class="hljs-number">6</span></span> var <span class="hljs-number"><span class="hljs-number">7</span></span> source = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inputString.<span class="hljs-symbol"><span class="hljs-symbol">splitLines:</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment"># Ignore empty lines 11 if line.len &lt; 1: continue 12 var chunks = split(line, ',') 13 if chunks.len != 2: 14 error("Input needs comma split values, got: " &amp; line) 15 source &amp;= "const cfg" &amp; chunks[0] &amp; "= \"" &amp; chunks[1] &amp; "\"\n" 16 17 if source.len &lt; 1: error("Input file empty!") 18 result = parseStmt(source) 19 20 readCfgAndBuildSource("data.cfg") 21 22 when isMainModule: 23 echo cfglicenseOwner 24 echo cfglicenseKey 25 echo cfgversion</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is good that almost nothing has changed! First, the processing of the input parameter has changed (line 3). In the dynamic version, the procedure </font></font><code>readCfgAtRuntime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gets a string parameter. However, in the macro version, although it is declared string, it is only the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">external</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interface of the macro. When a macro is run, it actually gets the object </font></font><code>PNimNode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, not the string, and we need to call the procedure </font></font><code>strVal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the module </font></font><code>macros</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(line 5) to get the string passed to the macro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we cannot use the procedure </font></font><code>readFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the module</font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">due to FFI limitations at compile time. If we try to use this procedure (or any other, depending on the FFI), the compiler will generate an error with the message that it cannot calculate the source code dump of the macro and add a stack listing to it showing where the compiler was at the time of the error. We can bypass this restriction by using the procedure </font></font><code>slurp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the module </font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is made specifically for the compilation stage (there is also a similar procedure </font></font><code>gorge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that executes the external program and intercepts its output). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interestingly, our macro does not return a runtime object.</font></font><code>Table</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Instead, it generates the Nim source code in the source variable. For each line of the configuration file, a constant variable will be generated (line 15). To avoid conflicts, we prefix these variables </font></font><code>cfg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In general, all that the compiler does is replace the macro call line with the following code fragment:</font></font><br><br><pre> <code class="ruby hljs">const cfgversion= <span class="hljs-string"><span class="hljs-string">"1.1"</span></span> const cfglicenseOwner= <span class="hljs-string"><span class="hljs-string">"Hyori Lee"</span></span> const cfglicenseKey= <span class="hljs-string"><span class="hljs-string">"M1Tl3PjBWO2CC48m"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can check it yourself by adding a line with the output of the source code to the screen at the end of the macro and compiling the program. </font><font style="vertical-align: inherit;">Another difference is that instead of calling the normal procedure </font></font><code>quit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to exit (which we could call), this version calls the procedure </font></font><code>error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(line 14). </font><font style="vertical-align: inherit;">The procedure </font></font><code>error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does the same as </font></font><code>quit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but also displays the source code and the line number of the file where the error occurred, which helps the programmer to find the error during the compilation. </font><font style="vertical-align: inherit;">In this situation, we would be pointed at the line that calls the macro, and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the line </font></font><code>data.cfg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that we process: we have to control this ourselves.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manual AST generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To generate AST, we, in theory, would need to be perfectly aware of the structures used by the Nim compiler, which are represented in the module </font></font><code>macros</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">At first glance, this seems like a daunting task. </font><font style="vertical-align: inherit;">But we can use the macro </font></font><code>dumpTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, using it as a command macro, not an expression macro. </font><font style="vertical-align: inherit;">Since we know that we want to generate a chunk of characters </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can create the following source file and compile it to see what the compiler </font><em><font style="vertical-align: inherit;">expects</font></em><font style="vertical-align: inherit;"> from us </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></em> <br><br><pre> <code class="ruby hljs">import macros <span class="hljs-symbol"><span class="hljs-symbol">dumpTree:</span></span> const <span class="hljs-symbol"><span class="hljs-symbol">cfgversion:</span></span> string = <span class="hljs-string"><span class="hljs-string">"1.1"</span></span> const cfglicenseOwner= <span class="hljs-string"><span class="hljs-string">"Hyori Lee"</span></span> const cfglicenseKey= <span class="hljs-string"><span class="hljs-string">"M1Tl3PjBWO2CC48m"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the course of compiling the source code, we should see the output of the following lines (since this is a macro, compilation will be enough, no binaries need to be run): </font></font><br><br><pre> <code class="ruby hljs">StmtList ConstSection ConstDef Ident !<span class="hljs-string"><span class="hljs-string">"cfgversion"</span></span> Ident !<span class="hljs-string"><span class="hljs-string">"string"</span></span> StrLit <span class="hljs-number"><span class="hljs-number">1.1</span></span> ConstSection ConstDef Ident !<span class="hljs-string"><span class="hljs-string">"cfglicenseOwner"</span></span> Empty StrLit Hyori Lee ConstSection ConstDef Ident !<span class="hljs-string"><span class="hljs-string">"cfglicenseKey"</span></span> Empty StrLit M1Tl3PjBWO2CC48m</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this information, we already have a better idea of ‚Äã‚Äãwhat data the compiler needs from us. We need to generate a list of commands. For each source code constant generated </font></font><code>ConstSection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>ConstDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If we moved all these constants into a single block </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we would see only one </font></font><code>ConstSection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with three descendants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You may not have noticed, but in the example with the </font></font><code>dumpTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first constant, it explicitly defines the type of the constants. That is why, in the output tree, the two last constants have a second descendant </font></font><code>Empty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the first has a string identifier. So, in general, a definition </font></font><code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consists of an identifier, an optional type (which may be </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an empty</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node), and a value. Armed with this knowledge, let's look at the complete version of the AST macro:</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> import macros, strutils <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> macro readCfgAndBuildAST(<span class="hljs-symbol"><span class="hljs-symbol">cfgFilename:</span></span> string): stmt = <span class="hljs-number"><span class="hljs-number">4</span></span> let <span class="hljs-number"><span class="hljs-number">5</span></span> inputString = slurp(cfgFilename.strVal) <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> result = newNimNode(nnkStmtList) <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inputString.<span class="hljs-symbol"><span class="hljs-symbol">splitLines:</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-comment"><span class="hljs-comment">#    10 if line.len &lt; 1: continue 11 var chunks = split(line, ',') 12 if chunks.len != 2: 13 error("Input needs comma split values, got: " &amp; line) 14 var 15 section = newNimNode(nnkConstSection) 16 constDef = newNimNode(nnkConstDef) 17 constDef.add(newIdentNode("cfg" &amp; chunks[0])) 18 constDef.add(newEmptyNode()) 19 constDef.add(newStrLitNode(chunks[1])) 20 section.add(constDef) 21 result.add(section) 22 23 if result.len &lt; 1: error("Input file empty!") 24 25 readCfgAndBuildAST("data.cfg") 26 27 when isMainModule: 28 echo cfglicenseOwner 29 echo cfglicenseKey 30 echo cfgversion</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we repelled from the previous example of generating the source code, we will note only the differences from it. Instead of creating a temporary type variable </font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and writing the source code into it as if it were written </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manually,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we use the variable directly </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and create a command list node ( </font></font><code>nnkStmtList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) that will contain our descendants (line 7). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each input line, we create a definition for the constant ( </font></font><code>nnkConstDef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and wrap it with a section of constants (</font></font><code>nnkConstSection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Once these variables are created, we fill them hierarchically (line 17), as shown in the previous dump of the AST tree: the definition of a constant is a descendant of the section definition and contains an identifier node, an empty node (let the compiler itself guess what type it is) and the string literal by value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final tip is to write macros: if you are not sure that the AST you built looks fine, you can try using a macro </font></font><code>dumpTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But it cannot be used </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside a</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> macro that you write or debug. Instead, display the line generated </font></font><code>treeRepr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If at the end of this example you add </font></font><code>echo treeRepr(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you will see the same conclusion as when using the macro </font></font><code>dumpTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Call it </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the end</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optionally, you can call it at any point in the macro with which you have problems. </font></font></div><p>Source: <a href="https://habr.com/ru/post/271361/">https://habr.com/ru/post/271361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271349/index.html">Let's Twist: The Path to the Unknown</a></li>
<li><a href="../271351/index.html">How to interview IT professionals</a></li>
<li><a href="../271355/index.html">Manual layout vs Storyboard / Nib</a></li>
<li><a href="../271357/index.html">Custom plugins in javascript games</a></li>
<li><a href="../271359/index.html">PHP developer life</a></li>
<li><a href="../271363/index.html">JS-DOS API: we start DOS in the browser</a></li>
<li><a href="../271365/index.html">Malicious Android software is becoming more sophisticated</a></li>
<li><a href="../271369/index.html">Implementing indoor navigation technology: TechCrunch examples</a></li>
<li><a href="../271371/index.html">How we design and prototype all garbage</a></li>
<li><a href="../271373/index.html">New tweet buttons or goodbye counter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>