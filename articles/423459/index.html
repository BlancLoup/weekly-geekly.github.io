<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Phoenix and Rails Differences through Convert Eyes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What most caught his eye to the avid rubist when he had just begun to study Elixir with Phoenix. 

 Note 


 I am a simple man and I will not go deep....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Phoenix and Rails Differences through Convert Eyes</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/sv/xv/n3/svxvn3p0h86vabqr0a1mxbvxmfs.png" height="70%" width="70%"></div>  What most caught his eye to the avid rubist when he had just begun to study Elixir with Phoenix. <a name="habracut"></a><br><br><h2 id="primechanie">  Note </h2><br><p>  I am a simple man and I will not go deep.  Therefore, there will be differences between workers and peasants, and nothing will be said about the difference at the level of application launch, about the principles of the Erlang virtual machine and the OTP protocol. </p><br><h2 id="glavnoe-vpechatlenie">  Main impression </h2><br><p>  Elixir / Phoenix is ‚Äã‚Äãvery similar to Rails and at the same time does not look like him at all.  Like some English phrases: individually, the words are familiar, but together it is not clear. </p><br><h2 id="erlang-vs-ruby">  Erlang vs Ruby </h2><br><p>  Thinking on ruby ‚Äã‚Äãand trying to write on elixir is hard.  You regularly come to a dead end, because what you want is done not at all like you used to do ... or, in fact, you don‚Äôt want it at all. </p><br><p> And the rest, about the differences between Erlang and Ruby, people write books, so I will be brief.  For me, the main ambushes were replacing rail "locomotives" with a pipe, reorienting thinking to functionalism (since Haskell had an old experience and a common love of <code>inject</code> / <code>foldr</code> ) and, subjectively, more stringent requirements for data types (although, officially , both languages ‚Äã‚Äãwith strict dynamic typing). </p><br><p>  The pattern-matching did not cause any surprise, and I still did not understand why there was so much talk about him.  Just an interesting tool. </p><br><h2 id="obschiy-skoup">  Common scop </h2><br><p>  In Elixir, everything lies in the modules.  No global scoop.  Bounces C #. </p><br><p>  In other words: a flat rail doesn‚Äôt make it possible to create a hierarchy in some places (I remember there were once bugs with controllers lying in modules).  Elixir - on the contrary, all by modules.  In the rail, the object's purpose is guessed by the parent class, and in the elixir - by the full name of the class / module. </p><br><h2 id="kompiliruemost">  Compilability </h2><br><p>  On the one hand, this is what I sometimes lacked in the rail.  Since you can find a good half of the errors right at compilation, and not in runtime on production.  On the other hand, compilation takes time.  But on the third hand, it needs a bit, and I have not yet seen large projects on the elixir (and not according to Erlang‚Äôs covenants to write large monoliths).  Finally, the guys from the elixir did a great job on dynamically reloading the code and page.  And so far, the speed of work, coupled with the lack of godless zeus / spring, warms my soul. </p><br><p>  Of course, this also creates disadvantages, but they come out much later.  Somewhere around the production environment and deployment.  This will be below. </p><br><p>  Immediately, there is an interesting moment that cannot physically happen in the rail: migrations and other things that in rails through <code>rake</code> , in elixir require compilation of the project and something like this could happen: forgot to write the routes, the path-helper in them is referenced, and migrations have fallen off.  At first - wildly unusual. </p><br><h2 id="dokumentaciya">  Documentation </h2><br><p>  The site with the <a href="https://hexdocs.pm/">elixir documentation</a> looks much more cheerful than rubidok and apidok.  But here the volume of documentation and examples is that in what ruby ‚Äã‚Äã/ rails far ahead.  In Elixir there are a lot of examples for everything that is a little more complicated than a stool.  And the description of some methods, in fact, did not go beyond the signature.  I, as accustomed by rubies to an abundance of examples and descriptions, was difficult with some methods of the elixir.  Sometimes I had to poke and experiment for a long time in order to understand how to use one or another method, because I don‚Äôt know the language so well as to read the source code of the packages freely. </p><br><h2 id="nezavisimost-raspolozheniya-fayla-ot-ego-soderzhimogo">  Independence of file location from its content </h2><br><p>  As they say "with great power comes great responsibility".  On the one hand, you can mess up the orgy and decompose objects so that the enemy will not pass.  On the other hand, you can call paths more logically and visually, adding logical levels of directories that are not in the class hierarchy.  In particular, we can recall the trailblazer and his ilk with the idea of ‚Äã‚Äãcombining everything connected with action in one place.  In the elixir, this can be done without third-party libraries and heaps of classes simply by correctly shifting existing files. </p><br><h2 id="prozrachnyy-put-zaprosa">  Transparent query path </h2><br><p>  If in Rails the question about rack is an indispensable attribute of any interview, because the rail is the tip of the iceberg and periodically you want to make your middleware.  Then in the elixir of such a desire does not arise at all (although maybe I'm still young and everything ahead).  There is an explicit set of pipeline through which the request passes.  And there you can clearly see where the session is fetching, where the flash-messge is processed, where the csrf is validated and all this can be managed as it pleases in one place.  In the rail all this farm is partially nailed and partially scattered in different places. </p><br><h2 id="routy-naiznanku">  Routes inside out </h2><br><p>  In Rails, the situation when one action can respond in several formats is the norm.  There even <code>(.:format)</code> laid right into the routes.  In the elixir, due to the above mentioned property with the pipeline, the thought of the analog format does not appear at all.  Different formats go on different pipeline and have different urls.  For me it is so great. </p><br><h2 id="shema-v-modeli">  Scheme in the model </h2><br><p>  This is generally a fairy tale.  How to describe the fields of the model, so be it.  No implicit caste of types.  Plus, there are no crutches to deny access to the field that is in the database, but for some reason it cannot be used in the web application. </p><br><h2 id="validacii-i-kolbeki">  Validations and Callbacks </h2><br><p>  There are no callbacks in the elixir.  There is more and more rectilinear.  And it seems I like it. </p><br><p>  Instead of the rails-way in the <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">changeset</a> elixir, which combines strong_parameters, validations and some callbacks.  And the remnants of callbacks go through <a href="https://hexdocs.pm/ecto/Ecto.Multi.html">Multi</a> , which makes it possible to collect a bunch of operations, execute them transactionally and process the result. </p><br><p>  In short, everything is just different.  At first it is unusual.  Then in places he is wildly annoyed, because you cannot just insert another callback for everything and not think about different business cases.  And then you begin to notice the <a href="">"inexplicable charm"</a> , because you have to do it right, and not as accustomed. </p><br><h2 id="rabota-s-bd">  Work with DB </h2><br><p>  Instead of ActiveRecord, some <a href="https://hexdocs.pm/ecto/Ecto.Repo.html">Ecto.Repo</a> , <a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto.Query</a> and a few of their fellows appeared.  To tell all the differences - this is a separate article.  Therefore, I will say the main subjective feelings. </p><br><p>  In debug it is more convenient than AR.  Since there is a common scoop, the constants from the load path are loaded when they are accessed and you can simply open <code>rails c</code> , write <code>User.where(email: 'Kane@nod.tb').order(:id).first</code> and get the result. </p><br><p>  In Elixir, the console is not enough.  You need to do a number of actions: </p><br><ul><li>  Import a method for building a sql query: <code>import Ecto.Query, only: [from: 2]</code> ; </li><li>  fill classes so as not to write their full names through the dot: <br><ul><li>  <code>alias MyLongApplicationName.User</code> - instead of <code>MyLongApplicationName.User</code> to write just <code>User</code> ; </li><li>  <code>alias MyLongApplicationName.Repo</code> - similarly for accessing a class that can execute sql and give results; </li></ul></li><li>  and only now you can write <code>from(u in User, where: u.email == "Kane@nod.tb") |&gt; Repo.one</code> </li></ul><br><p>  On the other hand, in the application code, these "formalities" give more readable code, plus there is a feeling that you control what is happening, and not it lives its own life.  That is, you yourself choose which methods, models and other objects you need to work with, obviously you load and use them. </p><br><h2 id="nazvanie-prilozheniya">  Application Name </h2><br><p>  In the image of Rails, I thought that the name of the application is used in a couple of configs and that's it.  Therefore, the length of the title did not pay attention.  And in vain.  In Elixir, the module with the name of the application is the top level in the module hierarchy of the web application and it will appear everywhere. </p><br><p>  I've called my sandbox Comindivion.  And now I suffer a little, since this is a rather long title and you need to write it constantly.  Both in class files and in the console when you call anything.  By the way, yes, who cares, <a href="https://github.com/Loriowar/comindivion">here's a sandbox on GitHub</a> . </p><br><h2 id="n1">  N + 1 </h2><br><p>  In Rails, we have it out of the box, and in Elixir there is no such problem out of the box.  There, at the request build stage, you can specify which relays will be needed and they will be loaded during the execution of this request itself.  Did not upload?  You will not have access to this report.  Everything is simple and beautiful. </p><br><h2 id="obrabotka-zaprosa-i-otvet-na-nego">  Request processing and response </h2><br><p>  In short: everything is more obvious in the phoenix than in the rail. </p><br><h3 id="vezde-conn">  Everywhere conn </h3><br><p>  Since the state is not stored in a heap of different objects, it has to be dragged along in one object.  Reminds <code>request</code> from <code>ActionController</code> , only more comprehensive.  He is called in Phoenix <code>connection</code> .  It contains everything: <code>request</code> , <code>flash</code> , <code>session</code> and everything, everything.  He also appears in the call for everything related to the processing of the incoming request. </p><br><p>  Here and minuses, as the first is very lazy to sculpt <code>conn</code> everywhere and not fully understand why.  Rail in this regard corrupts.  You write a render or flash and there is no thought that this is an action with a connection.  And in Phoenix <code>conn</code> constantly reminds of working with a specific connection or socket, and not just methods are invoked and magic happens there inside. </p><br><h3 id="partialtemplate">  Partial &amp; template </h3><br><p>  In Phoenix, there is no separation between partial and template.  Ultimately, all function.  Immediately, there is another delight: the rail, even in the prod environment, constantly climbs behind the views on the disk and generates IO plus an overhead to convert them from erb / haml / etc to html.  And in Elixir everything is a function, including views.  We compiled the view once and that‚Äôs it: it takes arguments, spits out html, it doesn't go to disk. </p><br><h3 id="views">  Views </h3><br><p>  In Rails, view means the partial and templates, while in Phoenix they are in templates, and in views, roughly speaking, there are different ways of presenting data.  In particular, there are "overrides" of the render'a. </p><br><p>  That is, by default, the controller renders nothing.  Everything is called explicitly.  And if you don‚Äôt have a partial and you don‚Äôt need it (for example, in the case of json, when it is easily built by the utility class), you redefine the render like this: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">def</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">render</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">show</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.json</span></span>", %{<span class="hljs-attribute"><span class="hljs-attribute">groups</span></span>: groups}) <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> %{ <span class="hljs-attribute"><span class="hljs-attribute">groups</span></span>: groups } <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br><p>  And the partial is no longer needed. </p><br><h3 id="heplers">  Heplers </h3><br><p>  They are not in Phoenix.  And this is awesome!  For in rail helpers, usually, any rubbish is collected that was either lazy to shove in the corners, or just needed to quickly stuff something. </p><br><p>  However, the methods in the controller, views, and so on.  You can add.  This is done in a special place <code>web/web.ex</code> and looks pretty decent. </p><br><h2 id="statika">  Statics </h2><br><p>  In development, everything is as usual, except that in the phoenix they have also attached a live reload, the first one to cause "Wow!"  Effect.  This is when I changed css, I returned to the browser, and there the changes were already loaded. </p><br><p>  In production in Phoenix, the behavior of statics is slightly different than that of the rails.  By default, there are clearly defined places where you can drag statics and you cannot just add files to assets to distribute them.  There is also a mapping of default assets, so that once again you don‚Äôt wander over the file system, but immediately take the necessary file and give it away. </p><br><h2 id="assety">  Assets </h2><br><p>  Out of the box in Phoenix - <a href="https://brunch.io/">brunch</a> .  You can replace the <a href="https://webpack.js.org/">webpack</a> .  But there is quite a true joke about the fact that many projects are bent at the stage of setting up a webpack. </p><br><p>  In short, js and css are more or less collected, but with the rest of the statics in the brunch is not very.  It is either copy-paste it directly into the project from node_modules (I don‚Äôt like this option at all), or write hooks on the bash.  For example, <a href="">so</a> . </p><br><h2 id="rabota-s-ssl">  Work with SSL </h2><br><p>  Out of the box in Phoenix there is a small http server called <a href="https://github.com/ninenines/cowboy">cowboy</a> .  It looks like ruby <a href="https://github.com/puma/puma">puma</a> .  They even have the same number of stars on GitHub.  But somehow I didn‚Äôt go to the SSL setting in any of the above.  Especially with <a href="https://letsencrypt.org/">Let's Encrypt</a> , an additional file of the web server config and regular certificate renewal.  So, as an http server, it's ok, and for ssl, I take a proxy on localhost via apache / nginx. </p><br><h2 id="deploy">  Depla </h2><br><p>  It is generally different compared to the rail.  In Rails, in its minimal form, he bent his turnip to the server, danced with a tambourine for a bundle, configs, assets, and launched the application.  And the elixir is compiled and <del>  bury the tram </del>  bow turnip is not a ride.  Need to build a package.  And here begins: </p><br><ul><li>  you find out why applications in <code>mix.exs</code> , because without correctly indicating them in the sale of wonderful errors; </li><li>  you learn that environment variables are compiled at the time of package building, and not at the time of its launch, and this is a wild surprise for the first time;  then you learn about <a href="https://github.com/erlware/relx">relx</a> with <code>RELX_REPLACE_OS_VARS=true</code> and lets go a bit; </li><li>  you are surprised that in the assembled package for production there is nothing like rake, in particular, there are no migrations and they need to be somehow separately run, for example, from a girlfriend through the port forwarding to the database (or via <a href="https://github.com/edeliver/edeliver">eDeliver</a> , which does approximately the same thing) . </li></ul><br><p>  And then, as with the above described, you will understand, the advantages begin: </p><br><ul><li>  you can make the package self-sufficient and don‚Äôt put anything at all on the combat machine from dependencies;  just tarball unpack and run the contents;  unless erlang roll out may be needed, since its cross compile version is a bit non-trivial in the assembly; </li><li>  You can do an upgrade release to deploy without downtime. </li></ul><br><h2 id="debag">  Debag </h2><br><p>  Elixir has <a href="https://elixir-lang.org/getting-started/debugging.html">Pry</a> and works like rubies.  There is even an analogue <code>rails c</code> that looks like an <code>iex -S mix</code> . </p><br><p>  But in the production console, you have to use it differently, since the package is assembled and there is no <code>mix</code> in it.  You have to connect to a running process.  This is radically different from the rails and at the beginning you spend a lot of time googling the way to start the elixir-console in production, because you are looking for something similar to the rail.  As a result, you understand what you need to do everything differently and call something like: <code>iex --name trace@127.0.0.1 --cookie 'from_env' --remsh 'my_app_name@127.0.0.1'</code> . </p><br><h2 id="prodolzhenie-sleduet">  To be continued... </h2><br><p>  Fuh, anyway, I forgot something.  Anyway.  Better tell me what surprised you in Elixir, compared to other languages. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/423459/">https://habr.com/ru/post/423459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423445/index.html">Creating an online store structure: category map</a></li>
<li><a href="../423447/index.html">GLPH: New Content Marketing Podcast</a></li>
<li><a href="../423453/index.html">ZFS and disk access speeds in hypervisors</a></li>
<li><a href="../423455/index.html">Correct tablet</a></li>
<li><a href="../423457/index.html">Work as a team leader in the 2018th year</a></li>
<li><a href="../423461/index.html">Suborbital autumn</a></li>
<li><a href="../423463/index.html">As we wrote another RFM analysis algorithm</a></li>
<li><a href="../423465/index.html">What to read about ITSM: books, blogs and recent articles</a></li>
<li><a href="../423467/index.html">Russian developers will release a product compatibility catalog</a></li>
<li><a href="../423469/index.html">The fastest floating point numbers in the wild west</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>