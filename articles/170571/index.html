<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yarr - dataflow framework (image processing) on ‚Äã‚ÄãHaskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sounding of the situation at Reddith showed that hardly anyone is seriously engaged in image processing on Haskell, despite the fact that the fairly p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yarr - dataflow framework (image processing) on ‚Äã‚ÄãHaskell</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/e00/d03/f98/e00d03f98ab7d9b32c19d96e4e3ebcb9.png"><br><br>  Sounding of the situation <a href="http://www.reddit.com/r/haskell/comments/18pi4s/does_anybody_process_images_in_haskell/">at Reddith</a> showed that hardly anyone is seriously engaged in image processing on Haskell, despite the fact that the fairly popular <a href="http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial">Repa</a> library suggests working with images as one of the main applications.  I hope the Yarr library can change the situation ( <a href="http://hackage.haskell.org/package/yarr">documentation</a> , <a href="https://github.com/leventov/yarr">github</a> ). <br><br>  I call the dataflow framework, because it is generalized to handle arrays (from one-dimensional to three-dimensional) elements of any type, including vectors of numbers, such as coordinates, complex numbers.  But the main intended use is the processing of two-dimensional arrays of vectors of color components, i.e. images.  The framework does not directly contain image processing algorithms, but provides a powerful infrastructure for writing them. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The essence </h4><br>  In the framework, a family of types is defined - array representations ( <code>UArray</code> ).  Representations are divided into 2 genders: <br><ul><li>  <i>Explicit</i> , array elements in such representations are indeed somewhere in memory.  There are views based on low-level GHC arrays, based on raw memory blocks from malloc - only for elements from the Storable class. </li><li>  <i>Implicit</i> representations encapsulate a function (index -&gt; element). </li></ul><br><br>  There are also a huge number of functions in three main areas: <br><ul><li>  Mappings (map), combining functions (zipWith) and convolutions by kernel (convolution) take one or several arrays as input and return <i>an implicit</i> array. </li><li>  <i>The calculating</i> ( <code>Load</code> ) functions translate an implicit array into an explicit one, that is, they write the first one into memory in some form. </li><li>  Functions of the passage ( <code>Walk</code> ) on the array, including with the state - convolution (fold). </li></ul><br><br>  Those familiar with the Repa library may notice that Yarr is very similar to her.  The main differences: <br><ul><li>  Most functions have "component-wise" options, which is convenient when working with arrays of vectors, such as images in the RGB format. </li><li>  The possibilities of convolutions are greatly expanded (fold). </li><li>  Yarr is often faster than Repa.  For example, the Canny boundary detector on the Yarr works about 2 times faster than the detector on the Repa. </li></ul><br><br><h4>  Examples </h4><br>  When using the framework, it turns out rather a mixture of imperative and functional than purely functional code, because literally everything is immersed in the <code>IO</code> monad.  This is a high performance charge. <br><br>  The calculation of the histogram based on lightness is one of the stages of equalization (the first arrow in the upper picture). <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Yarr <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Yarr.Walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Yarr.Shape <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> S <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Yarr.Repr.Foreign ... computeHist :: UArray FS L Dim2 Float -&gt; IO (<span class="hljs-type"><span class="hljs-type">UArray</span></span> <span class="hljs-type"><span class="hljs-type">FL</span></span> <span class="hljs-type"><span class="hljs-type">Dim1</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) computeHist pixelValues = walkP caps (<span class="hljs-title"><span class="hljs-title">mutate</span></span> (<span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-title"><span class="hljs-title">unrolledFill</span></span> <span class="hljs-title"><span class="hljs-title">n8</span></span> <span class="hljs-title"><span class="hljs-title">noTouch</span></span>) incHist) (<span class="hljs-title"><span class="hljs-title">newEmpty</span></span> 256) joinHists pixelValues where incHist :: UArray FL Dim1 Int -&gt; Float -&gt; IO () incHist hist value = do let level = truncate (<span class="hljs-title"><span class="hljs-title">value</span></span> * 255.99) c &lt;- index hist level write hist level (<span class="hljs-title"><span class="hljs-title">c</span></span> + 1) joinHists h1 h2 = do loadS S.fill (<span class="hljs-title"><span class="hljs-title">dzip2</span></span> (+) h1 h2) h1 return h1</code> </pre><br><br>  This article provides measurements of the <i>minimum</i> execution time from a variety of launches, <i>calculated per pixel of the image</i> , on a different number of threads.  The unit of measure is the processor clock.  Yarr version - 1.2.3, <a href="">test configuration</a> , <a href="https://github.com/leventov/yarr/blob/fc477d5a206ed0bc8a22eca8a515bbb121b53ce2/tests/Makefile">general Makefile</a> , <a href="">test image</a> (2560 √ó 1600, 6 MB). <br><img src="http://habrastorage.org/storage2/809/d9d/87d/809d9d87dd3500fc6ae6f68b41ba07fe.png"><br><br>  The calculation of the direction and strength of the gradient at a point from the smoothed black and white image is one of the stages of border detection (the second arrow in the upper picture). <br><div class="spoiler">  <b class="spoiler_title">Function gradientMagOrient, code screen</b> <div class="spoiler_text">  I do not think that it makes sense to explain each line, examples are given to show how the code on Yarr looks in general. <br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE QuasiQuotes #-}</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Yarr.Convolution ... noOrient = 0 :: Word8 posDiag = 64 :: Word8 vert = 128 :: Word8 negDiag = 192 :: Word8 horiz = 255 :: Word8 gradientMagOrient :: Word8 -&gt; UArray FL Dim2 Float -&gt; FImage (<span class="hljs-type"><span class="hljs-type">VecTuple</span></span> <span class="hljs-type"><span class="hljs-type">N2</span></span> <span class="hljs-type"><span class="hljs-type">Word8</span></span>) -&gt; IO () gradientMagOrient !threshLow image target = loadP S.fill caps delayedMagOrient target where delayedMagOrient = dzip2 magnitudeAndOrient gradientX gradientY <span class="hljs-comment"><span class="hljs-comment">-- Sobel-X operator application gradientX = dConvolveLinearDim2WithStaticStencil [dim2St| -1 0 1 -2 0 2 -1 0 1 |] image -- Sobel-Y gradientY = dConvolveLinearDim2WithStaticStencil [dim2St| 1 2 1 0 0 0 -1 -2 -1 |] image magnitudeAndOrient :: Float -&gt; Float -&gt; VecTuple N2 Word8 magnitudeAndOrient gX gY = VT_2 (mag, if mag &lt; threshLow then noOrient else orient gX gY) where mag = floatToWord8 $ sqrt (gX * gX + gY * gY) orient :: Float -&gt; Float -&gt; Word8 orient gX gY | atan_1q &lt; 0.33 = horiz | atan_1q &gt; 0.66 = vert | otherwise = posDiag + diagInv where rr = gY / gX (r, diagInv) = if rr &lt; 0 then (negate rr, negDiag - posDiag) else (rr, 0) -- 2nd order Taylor series of atan, -- see http://stackoverflow.com/a/14101194/648955 br = 0.596227 * r num = br + (r * r) atan_1q = num / (1.0 + br + num)</span></span></code> </pre><br></div></div><br><img src="http://habrastorage.org/storage2/3ca/974/054/3ca9740543abb791cee2585eb94d0b15.png"><br><br>  Here is a comparison of the performance of border detectors entirely, on Yarr and OpenCV, the most popular image processing library.  <a href="">Code on Yarr</a> , <a href="">code on OpenCV</a> .  OpenCV does not support parallel processing of a single image. <br><img src="http://habrastorage.org/storage2/dd5/949/c0e/dd5949c0e946fb6eeb50c58391bffead.png"><br>  Conclusion: select borders on a large number of ordinary images will be faster on OpenCV (if scatter images on streams), and on one giant, in a couple of gigapixels, photos - faster on Haskell. <br><br><h4>  Self-help optimizations </h4><br><h5>  Automatic parallelization </h5><br>  In the examples above, you might have paid attention to functions with the suffix <code>-P</code> and the first argument <code>caps</code> : <code>walkP</code> , <code>loadP</code> .  It is they who are responsible for the "magic" acceleration of programs when specifying the number of cores available to the process via the console.  <code>caps</code> is an abbreviation for <code>getNumCapabilities</code> function from the standard <code>Control.Concurrent</code> module.  Instead of <code>caps</code> you can write, for example, <code>(threads 2)</code> , with a clear result. <br><br><h5>  Tools for maximum utilization of the capabilities of a specific processor </h5><br>  If the calculation on the element is quite simple, and the pipeline has a wide target processor, you can <b>turn the cycles</b> into several iterations to get a better conveyor belt.  An example is in the 1st line of the <code>computeHist</code> function (the histogram calculation is expanded over 8 iterations).  The performance of this computation with other parameters of unfolding, and completely without it (the scale is slightly logarithmic): <br><img src="http://habrastorage.org/storage2/37c/ee1/af9/37cee1af9f072eab6a1d1589ed3ab0c1.png"><br>  As you can see, in this case, the deployment allows you to speed up the program about three times.  Intuitively, this is explained by the fact that in the pipeline of my processor there are 3 pipelines.  With a long unfolding, they work to the fullest, and without unfolding - 2 of 3 are idle. <br><br>  Yes, unfortunately, neither the GHC's own backend, nor the LLVM (it is supposed to be used with Yarr) actually do not deploy the cycles themselves, although at least the LLVM theoretically should. <br><br>  On the contrary, when processing arrays of vectors, if the calculations of individual components are independent and at the same time contain a lot of arithmetic, you can try to <b>calculate the components separately in time</b> (in a parallel version, they will also be distributed across different streams) to unload the pipeline and the register file.  For example, on my processor, this gives a performance increment of 15% with Gaussian smoothing of a color image with a 5 √ó 5 core ( <a href="">blur.hs</a> ).  Component-based variants of the functions of calculation and iteration have the infix <code>-Slices-</code> or <code>-SlicesSeparate-</code> . <br><br><h5>  2D unfolding of kernel convolution calculation cycles to reduce read operations </h5><br>  For example, let's take the Gaussian smoothing of a black and white image with a 3 √ó 3 core: <br><br><img src="http://habrastorage.org/storage2/b79/163/9d4/b791639d428a3a22ec55b271d116f07f.gif"><br><br>  If the values ‚Äã‚Äãof 4 neighboring pixels are calculated in a row, the LLVM can prove that the initial values ‚Äã‚Äãof the pixels cannot change during repeated readings (since there are no write operations between them) and reuse the latter. <br><br><img src="http://habrastorage.org/storage2/016/06a/574/01606a574acd94543f8ca12665129dea.png"><br><br>  Above is the original two-dimensional array of pixel intensities, red, blue, yellow, and green rectangles ‚Äî the kernels for calculating smoothed pixel values ‚Äã‚Äãby coordinates (y = 2, x = 2), (2, 3), (3, 2) and (3, 3) respectively.  The multipliers in the core are written only for the first pixel. <br><br>  If there are enough general-purpose registers in the processor, LLVM compiles such a calculation with 16 read operations instead of 36 - the GVN (Global Value Numbering) optimization works. <br><br>  In the example, it is used to expand to 2 indices horizontally and 2 vertically.  Of course, this is not always optimal.  The speed of such smoothing depending on the unfolding steps: <br><img src="http://habrastorage.org/storage2/1be/a66/6b4/1bea666b45cd91a21637c020b0c0b140.png"><br>  In the framework, there is a function for parameterized unfolding of the calculation of two-dimensional arrays in both dimensions, <a href="http://hackage.haskell.org/packages/archive/yarr/1.2.3/doc/html/Data-Yarr-Shape.html">dim2BlockFill</a> . <br><br><h4>  disadvantages </h4><br>  Cycles do not vectorize.  As in the case of deployment, LLVM promises, but in fact, it does not vectorize anything.  LLVM 3.3 <a href="http://llvm.org/docs/ReleaseNotes.html">announced an improvement</a> in this direction, so in the foreseeable future we can hope for even greater acceleration of the framework.  Currently, the stable backend of GHC 7.6.1 is considered to be LLVM 3.1. <br><br>  There is no support for stream filtering and combining arrays (streaming).  This feature will be in Repa 4 (version in development).  It will not be implemented in Yarr, because for this it is necessary to rewrite the library from scratch, to which there are no people willing.  Screw the side with the current architecture will not work.  However, Ben Lippmeier also rewrites Repa 3 from scratch, so the motivation was found :) <br><br><a name="static-double-dispatch"></a><br><h4>  Implementation </h4><br>  Most of the mapping / combining functions (maps, zips) and functions that convert an array from an implicit representation to an explicit ( <code>Load</code> ) are defined in classes with several parameters.  Simplified, in the case of mappings, the 1st parameter is the type of the original array, the 2nd is the type of output implicit array.  In the case of calculations, the 1st parameter is the type of the input implicit array, the 2nd is the type of the resulting calculated explicit array.  As a result, when displaying in implicit arrays, information about the ‚Äúunderlying‚Äù explicit sources is stored.  When calculating the knowledge of the structure of the input and output arrays allows you to choose the best way to iterate. <br><br>  It turns out a kind of static double dispatch.  The topic is <a href="https://github.com/leventov/yarr/blob/master/cg-course-paper.pdf">covered</a> in more detail in the <a href="https://github.com/leventov/yarr/blob/master/cg-course-paper.pdf">curriculum</a> , <i>and</i> most of the notes are given to it. <br><br>  Separate post - <a href="http://habrahabr.ru/post/171425/">on the fight against GHC slowness</a> . <br><br>  Functions with unrolling cycles, for example <code>unrolledFill</code> , take as an <code>unrolledFill</code> step a number not ordinary ( <code>Int</code> ), but raised to the level of types.  In the <code>computeHist</code> function (from the example above), <code>n8</code> is a value of type <code>N8</code> , which belongs to the <code>Arity</code> class from the <a href="http://hackage.haskell.org/package/fixed-vector">fixed-vector</a> library.  In general, the framework is actually based on this library, it is used very actively. <br><br>  Inside functions like <code>unrolledFill</code> , <i>an action vector of a given arity is formed</i> .  GHC completely reduces the vector, after compilation there remains a flat sequence of actions, that is, just an unfolding.  Amazingly, GHC copes even with the reduction of double nesting vectors, with which the <code>dim2BlockFill</code> function is <code>dim2BlockFill</code> ! <br><br><h4>  Development </h4><br>  The most difficult thing when developing a framework was to invent an architecture, a type system.  I drastically changed it about 8 times, looking at my design <a href="http://leventov.livejournal.com/14662.html">note</a> on Haskell through tears of self-irony.  Abstractions flowed, even broke more quickly, the architecture did not allow to implement the necessary functions or was incompatible with the GHC optimizer, and I created a new folder and started writing from the beginning. <br><br>  The first 3-4 approaches were attempts to tie componentwise operations to Repa.  When I finally realized that this was impossible, I specifically moved away from the Repa architecture as far as possible.  The remaining ‚Äúiterations‚Äù again brought the Repa design framework closer to it; as a result, from the outside, it again resembles just the Repa extension. <br><br>  It's funny that Aleksey Khudyakov laid out the fixed-vector library only in November last year, i.e. 2 months after I decided to write the framework (I took the curtain theme).  But since started in December, it turned out without much difference.  You can say I was very lucky :) </div><p>Source: <a href="https://habr.com/ru/post/170571/">https://habr.com/ru/post/170571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../170559/index.html">And about the clock</a></li>
<li><a href="../170561/index.html">Mozilla introduced the commercial version of Firefox OS and plans to promote its OS</a></li>
<li><a href="../170563/index.html">From jQuery to Backbone</a></li>
<li><a href="../170565/index.html">Emmet v1.0 released</a></li>
<li><a href="../170569/index.html">ASUS MeMO Pad ME172V Tablet Review</a></li>
<li><a href="../170575/index.html">ZTE Open - the first official phone on Firefox OS</a></li>
<li><a href="../170577/index.html">HTML5 standards logo or How to put a vector image on a web page</a></li>
<li><a href="../170579/index.html">Android tablet from Hewlett Packard for $ 169</a></li>
<li><a href="../170581/index.html">Atlassian Bamboo in pictures</a></li>
<li><a href="../170583/index.html">The film, funded by Kickstarter, won an Oscar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>