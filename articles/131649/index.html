<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our auto-update service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most developers of stand-alone applications sooner or later face the problem of delivering updates for their application. In this article I will try t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our auto-update service</h1><div class="post__text post__text-html js-mediator-article">  Most developers of stand-alone applications sooner or later face the problem of delivering updates for their application.  In this article I will try to solve this problem in the best, in my opinion, way - to write my own universal auto-update service, which will hang in processes in a single copy and deliver updates for all subscribing applications. <br><br>  There are several ready-made solutions for .NET, but the most relevant is ClickOnce.  This technology can no longer be called new, but, in my opinion, it received serious development not so long ago, and does not have an exhaustive functionality. <br>  If you do not want to reinvent the wheel, then I advise you to carefully explore the possibilities of ClickOnce, and if the functionality offered is sufficient for you, then this is definitely your choice.  However, ClickOnce is not a panacea and it is not always possible to do with it. <br><br>  Now I want to talk about my vision of the mechanism of auto-updates.  I do not pretend to be the last resort, so constructive criticism and suggestions in the comments are welcome. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>UPD:</b> The essence of the implementation is to reduce the number of processes and services that are engaged in updating.  If you have several applications, then all of them will be able to ‚Äúreceive‚Äù updates from a single Windows service.  It will not be necessary for each application to launch a launcher, keep a connection with the update server.  Theoretically, one process can deal with all updates in the system, and it is possible that ClickOnce will soon become this process if developers stop making their ‚Äúbikes‚Äù.  And developers will stop making their bikes when they have enough ClickOnce functionality.  Now, unfortunately, this is not always the case. <br><br><h1>  So the task </h1><br>  Suppose we have several different applications installed on the user's computer.  I would like to write a universal service of auto-updates, so that later I could use it in other applications.  And all applications were updated using only one service, which would save resources with a large amount of software.  It is also desirable that in existing applications I need to make minimal changes to connect and configure auto-updates.  The update process must be customizable for each application. <br><a name="habracut"></a><br><h1>  Implementation </h1><br>  In order to concretely define the problem, I will solve it with reference to Windows, write code in C # .NET, although in this article I will mainly operate on abstractions and give only small snippets of code. <br><br>  My auto-update service consists of 3 modules: <br>  1) Web service with updates themselves, versioning, a database of all supported applications and everything else that can be brought here (for example, some ‚Äúremote‚Äù settings for updating a specific application). <br>  2) A Windows service that connects to a web service and checks for updates for all signed applications, by timer and on demand. <br>  3) A client library that will know how to connect to the Updater's Windows service, as well as provide the callback application with an interface. <br><br>  I blew it all into 3 assemblies and named accordingly. <br><br>  <strong>Updater.Online</strong> - web service <br>  <strong>Updater.Service</strong> - windows-service <br>  <strong>Updater.Client</strong> - client-module <br><br>  I also highlighted another build for general abstractions - <strong>Updater.Domain</strong> . <br><br><h2>  Updater Online </h2><br>  Let's start with the web service.  Everything is simple, everything can be crammed into one CheckForUpdates method, which accepts ApplicationID and CurrentVersion, looks in the database if there are any actual updates for this application, and if there is, returns the path to the .zip file with the update or null if there are no updates.  This is the simplest case, in general, as well as the requested parameters and the query results may be more. <br>  The service may return additional information that may come in handy during the update process.  For example, on the service, you can indicate whether the update is possible in silent-mode for this application, additional data on how to download the update, in what format it is, what size it has, etc. <br><br><h2>  Updater service </h2><br>  This is probably the most voluminous module.  Here is the WCF service UpdaterService, below is the interface that it implements and the callback interface. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ServiceContract(CallbackContract = typeof(IUpdateServiceCallback))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IUpdaterService</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Callback subsctibe/unsibscribe methods [OperationContract(IsOneWay = true)] void Subscribe(SubscribeRequest request); [OperationContract(IsOneWay = true)] void Unsubscribe(UnsubscribeRequest request); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> [OperationContract(IsOneWay = true)] void InstallAvalibleUpdates(InstallAvalibleUpdatesRequst request); [OperationContract(IsOneWay = true)] void DownloadUpdate(Guid applicationId); [OperationContract(IsOneWay = true)] void CheckForUpdates(Guid applicationId); } [ServiceContract] public interface IUpdateServiceCallback { [OperationContract(IsOneWay = true)] void OnUpdateDetected(UpdateDetectedEventArgs eventArgs); [OperationContract(IsOneWay = true)] void OnUpdateDownloaded(UpdateDownloadedEventArgs updateDetectedEventArgs); [OperationContract(IsOneWay = true)] void OnUpdateInstalled(UpdateInstalledEventArgs eventArgs); }</span></span></code> </pre> <br><br>  In the Subscribe method, I add the callback that came from the client to the static Dictionary &lt;TAppID, CallbackList&gt;, where TAppID is the application ID (I have a Guid), for each application there is a separate list of callbacks. <br>  Here is the implementation of the Subscribe method. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SubscribeRequest request</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    calback   IUpdateServiceCallback callback = OperationContext.Current.GetCallbackChannel&lt;IUpdateServiceCallback&gt;(); // lock,       lock (sync) { //      Application   ID.   , //   . /     var app = applicationService.Get(request.ApplicationId); if (app == null) { app = new Application() { Id = request.ApplicationId }; applicationService.Add(app); } app.CurrentVersion = request.Version ?? app.CurrentVersion; app.RootFolderPath = request.RootFolder ?? app.RootFolderPath; app.Name = request.ApplicationName ?? app.Name; } //   callback'      , //     var list = GetEventList(request.ApplicationId) ?? new CallbacksList(); list.OnUpdateDetected += callback.OnUpdateDetected; list.OnUpdateDownloaded += callback.OnUpdateDownloaded; if (registredCallbacks.ContainsKey(request.ApplicationId)) { registredCallbacks[request.ApplicationId] = list; } else { registredCallbacks.Add(request.ApplicationId, list); } //     ,   //       ( //    ) ICommunicationObject obj = (ICommunicationObject)callback; obj.Closing += ClientClosing; obj.Closed += ClientClosed; applicationService.SaveChanges(); }</span></span></code> </pre><br><br>  Also in the implementation of UpdaterService, I added static methods to call Callback to hide the implementation of their call a little.  These methods are invoked on the side of the Updater Service when it is necessary to initiate the corresponding events on the client side. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Guid, CallbacksList&gt; registredCallbacks; <span class="hljs-comment"><span class="hljs-comment">//      callback'   null     private static CallbacksList GetEventList(Guid appId) { CallbacksList result; return registredCallbacks.TryGetValue(appId, out result) ? result : null; } //   callback'    private static void PerformCallback(Guid applicationId, Action&lt;CallbacksList&gt; func) { try { var list = GetEventList(applicationId); if (list != null) { func(list); } } catch { } } //    OnUpdateDetected     //   ApplicatioId public static void OnUpdateDetected(UpdateDetectedEventArgs args) { PerformCallback(args.ApplicationId, callbacks =&gt; callbacks.OnUpdateDetected(args)); }</span></span></code> </pre><br><br>  I also launch a ‚Äútimer‚Äù on the service, which checks for updates for all signed applications after a specified period of time. <br>  I have ApplicationService in the code, although I called it a service, it looks more like a repository of information about signed applications and updates for them. <br>  Here are the app classes and updates. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Application</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Version CurrentVersion { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String RootFolderPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;Update&gt; Updates { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Update</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String UpdateUrl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Version Version { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInstalled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsDownloaded { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UpdateLocalPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><br><h2>  Updater client </h2><br><br>  This assembly is connected in the application and monitors messages from the Service Updater, informing the application about them through an object implementing IUpdateServiceCallback. You can use the same object that was transferred from the application to the Updater Client as a callback to the service, but filter information sent to the client application, rather than pushing it all in a row, which will be returned to the Updater service.  In the implementation given by me, the wrapper is not used.  The client application also transmits data about itself as an object that implements the IUpdatble interface. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IUpdat</span></span><span class="hljs-title"><span class="hljs-title">ble</span></span> { Guid ApplicationId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } String ApplicationName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } String RootFolder { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UpdaterClient</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IUpdaterService client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IUpdateble settings; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DuplexChannelFactory&lt;IUpdaterService&gt; factory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdaterClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IUpdateServiceCallback callback, IUpdateble settings</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.settings = settings; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InstanceContext(callback); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> binding = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NetTcpBinding(); <span class="hljs-comment"><span class="hljs-comment">//     ,    //      , //    IUpdateServiceCallback factory = new DuplexChannelFactory&lt;IUpdaterService&gt;(context, binding, new EndpointAddress(UpdaterSettings.Default.UpdaterServiceUrl)); client = factory.CreateChannel(); } //    ,   //     Iupdateble , //      public void Subscribe() { client.Subscribe(new SubscribeRequest() { ApplicationId = settings.ApplicationId, RootFolder = settings.RootFolder, Version = settings.Version, ApplicationName = settings.ApplicationName }); } public void Unsubscribe() { client.Unsubscribe(new UnsubscribeRequest() { ApplicationId = settings.ApplicationId }); } public void InstallUpdates(bool reopenOnComplete) { InstallUpdates(reopenOnComplete); } public void DownloadUpdate() { client.DownloadUpdate(new DownloadUpdateRequest() { ApplicationId = settings.ApplicationId }); } public void CheckForUpdates() { client.CheckForUpdates(settings.ApplicationId); } public void InstallUpdates(bool reopenOnComplete) { client.InstallAvalibleUpdates(new InstallAvalibleUpdatesRequst() { ApplicationId = settings.ApplicationId, RestartOnComplete = reopenOnComplete }); } }</span></span></code> </pre><br><br>  Well, that's all.  It is used on the client side as follows: we connect the Updater.Client assembly, create an UpdaterClient object, call the Subscribe method, and our application starts receiving messages from the service about new updates. </div><p>Source: <a href="https://habr.com/ru/post/131649/">https://habr.com/ru/post/131649/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131644/index.html">Where did the PDA go?</a></li>
<li><a href="../131645/index.html">MemCache for iOS</a></li>
<li><a href="../131646/index.html">LiveKniga.Ru, or a story about a blog with stories about stories</a></li>
<li><a href="../131647/index.html">We make a macro flash from the built-in flash</a></li>
<li><a href="../131648/index.html">PHP library for working with the Yandex.Money API</a></li>
<li><a href="../131650/index.html">We write a math reference book for Android, we connect the Begun ad</a></li>
<li><a href="../131652/index.html">Design patterns for Android development. Part 3 - User Interface, Testing, AndroidMock</a></li>
<li><a href="../131653/index.html">Ino - working with Arduino from the command line</a></li>
<li><a href="../131654/index.html">Google Map API (custom labels and tooltips)</a></li>
<li><a href="../131656/index.html">Google+ for Android has also been updated.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>