<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>History of one optimization: transmission and processing of the results of the battle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I will tell you about a small part of a large project - World of Tanks . Many of you probably know World of Tanks from the user side, but I sugg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>History of one optimization: transmission and processing of the results of the battle</h1><div class="post__text post__text-html js-mediator-article">  Today I will tell you about a small part of a large project - <a href="http://worldoftanks.ru/">World of Tanks</a> .  Many of you probably know World of Tanks from the user side, but I suggest looking at it from the developer‚Äôs point of view.  This article will discuss the evolution of one of the technical solutions of the project, namely, the transfer and processing of the results of the battle. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/2d7/7bf/a62/2d77bfa62c7644ffbdafab84df0fc5d1.jpg" alt="Post combat"></div><br><a name="habracut"></a><br><h4>  Under the hood </h4><br>  To understand the essence of the problem at hand, I will first describe how the Tanks are arranged.  The project is a distributed client-server application that is represented on the server side by several nodes of different types.  All physics and in-game logic are calculated on the server, and the client is responsible for user interaction ‚Äî handling user input and displaying results.  A simplified cluster diagram looks like this: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/5aa/21e/d66/5aa21ed66fac4f859aa110e77850cc8a.png" alt="Cluster layout"></div><br>  BaseApp nodes are responsible for interaction with the client.  They receive information from the user over the network and transmit it to the inside of the cluster, and also send the user information about events that have occurred within the cluster.  All physical interactions occurring in the arena are calculated on CellApp nodes.  Information about events that occurred with a tank during a battle is also collected there: the number of shots, hits, penetrations, etc. One battle can be served by several CellApps, each of which can be calculated by several users from different battles.  At the end of the battle, packets of statistics on all tanks are sent from CellApps to BaseApp.  It aggregates the packets and processes the results of the battle: it calculates fines and rewards, checks the execution of quests and gives out medals, that is, it forms other data packets that it sends to users.  It is important to note that CellApps and BaseApps are isolated processes.  Some of them may be located on other machines, but within the same cluster.  So data transfer between them takes place via network interfaces, and between the client and the cluster via the Internet. <br>  For the transfer of data packets, a protocol with guaranteed delivery implemented over UDP is used.  Under the hood, for all I \ O and guaranteed delivery on top of UDP, the Mercury library is responsible, which is part of the BigWorld Technology platform.  In fact, we can only affect the data before sending it - prepare it in such a way as to optimize the cost of sending / receiving. <br><br>  For obvious reasons, we want to reduce the amount of data transmitted between nodes to a minimum: this will reduce traffic bursts, delay in reception and transmission, and significantly reduce the amount of data transmitted to the client with information about the results of the battle.  For data pre-processing, one tick equal to 100 ms is allocated, during which other events can also be processed.  Therefore, pre-processing should take as little time as possible.  Ideally, it should not take time at all. <br><br><h4>  Start </h4><br>  Let's take a look at the data preparation process. <br>  Most of the in-game logic World of Tanks is written in Python.  The data sent between CellApp and BaseApp, as well as the data sent to the user at the end of the battle, are dict with a variety of values ‚Äã‚Äãfrom simple (like integer / fractional numbers or True / False values) to composite dictionaries and sequences.  Neither code-object, nor classes, nor instances of user-defined classes are ever passed from one node to another.  This is due to safety and performance requirements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To make it easier to consider further material, we will give an example of the data with which we will work further: <br><pre><code class="python hljs">data = { <span class="hljs-string"><span class="hljs-string">"someIntegerValue"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"someBoolValue"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-string"><span class="hljs-string">"someListOfIntsValue"</span></span> : [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-string"><span class="hljs-string">"someFloatValue"</span></span> : <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-string"><span class="hljs-string">"someDictionaryValue"</span></span> : { <span class="hljs-string"><span class="hljs-string">"innerVal"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"innerVal2"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"listOfVals"</span></span> : [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], }, <span class="hljs-string"><span class="hljs-string">"2dArray"</span></span> : [ [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>], [<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>], [<span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>] ] }</code> </pre> <br>  For direct data transfer between nodes, the dict instance must be converted into a binary data packet of the minimum size.  When making a remote call, the BigWorld engine provides the ability for a programmer to convert Python objects into binary data and vice versa using the cPikcle module. <br>  As long as the amount of data transferred was small, they were simply converted to binary format using the cPickle module (let's call this version 0 exchange protocol) before sending.  It was in this form that the first closed beta version of the 0.1 tanks back in 2010 came out. <br><br>  The advantages of this method include simplicity and sufficient efficiency both in terms of speed and compactness of the final binary representation. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>p = cPickle.dumps(data, <span class="hljs-number"><span class="hljs-number">-1</span></span>) &gt;&gt;&gt; len(p) <span class="hljs-number"><span class="hljs-number">277</span></span></code> </pre><br><br>  Disadvantages result from the advantages, in particular, the simplicity of this method: the string keys from the dictionary are also transferred between the cluster nodes and from the cluster to the user.  In some cases, these string keys may occupy a significant portion of the binary packet being transmitted. <br><br><h4>  <b>We optimize</b> </h4><br>  As time went on, the volume of data and simultaneous online increased significantly, and, consequently, the number of simultaneously completed battles and the amount of information transmitted at the end of the battle increased.  To reduce the traffic, we threw out the string keys from the data being sent and replaced them with indices in the list.  Such an operation did not result in data loss: knowing the order of the keys, restoring the original dict is easy. <br><br>  For carrying out operations of deleting and restoring keys, a template was needed in which all possible keys and corresponding functions would be stored: <br><pre> <code class="python hljs">NAMES = ( <span class="hljs-string"><span class="hljs-string">"2dArray"</span></span>, <span class="hljs-string"><span class="hljs-string">"someListOfIntsValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"someDictionaryValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"someFloatValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"someIntegerValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"someBoolValue"</span></span>, ) INDICES = {x[<span class="hljs-number"><span class="hljs-number">1</span></span>] : x[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(NAMES)} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dictToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(indices, d)</span></span></span><span class="hljs-function">:</span></span> l = [<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, ] * len(indices) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indices.iteritems(): l[index] = d[name] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listToDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(names, l)</span></span></span><span class="hljs-function">:</span></span> d = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(names): d[x[<span class="hljs-number"><span class="hljs-number">1</span></span>]] = l[x[<span class="hljs-number"><span class="hljs-number">0</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d &gt;&gt;&gt; dictToList(INDICES, data) [[[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>], [<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>], [<span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>]], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], {<span class="hljs-string"><span class="hljs-string">'listOfVals'</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-string"><span class="hljs-string">'innerVal2'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'innerVal'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>] &gt;&gt;&gt; &gt;&gt;&gt; len(cPickle.dumps(dictToList(INDICES, data), <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-number"><span class="hljs-number">165</span></span></code> </pre><br>  As you can see from the example, the binary representation has become more compact compared to version 0. But we have paid for the compactness with the time spent on preliminary data processing and adding a new code that needs to be maintained. <br>  This decision was released in version 0.9.5, at the very beginning of 2015.  The protocol with the conversion of dict to list, followed by pickle.dumps (data, -1) is called version 1. <br><br><h4>  <b>Optimize further</b> </h4><br>  With the release of the <a href="http://worldoftanks.ru/ru/news/pc-browser/1/superiority-event/">‚ÄúSuperiority‚Äù</a> mode, the data volume has grown significantly, as they are collected for each tank separately, and in this mode, the user can go into battle and generate data on as many as three vehicles.  Therefore, the need to ram the data even more closely became quite acute. <br>  In order to transmit even less redundant information, we applied the following techniques: <br><br>  1. For each nested dictionary, we applied the same approach as for the main dictionary ‚Äî threw out the keys and converted dict to a list.  Thus, the ‚Äútemplate‚Äù, according to which data is converted from dict to list and back, became recursive. <br><br>  2. Carefully looking at the data before sending, we noticed that in some cases the sequence is enclosed in a container of type set or frozenset.  The binary representation of these containers in the cPickle protocol version 2 takes up much more space: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>l = list(xrange(<span class="hljs-number"><span class="hljs-number">3</span></span>)) &gt;&gt;&gt; cPickle.dumps(set(l), <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-string"><span class="hljs-string">'\x80\x02c__builtin__\nset\nq\x01]q\x02(K\x00K\x01K\x02e\x85Rq\x03.'</span></span> &gt;&gt;&gt; &gt;&gt;&gt; cPickle.dumps(frozenset(l), <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-string"><span class="hljs-string">'\x80\x02c__builtin__\nfrozenset\nq\x01]q\x02(K\x00K\x01K\x02e\x85Rq\x03.'</span></span> &gt;&gt;&gt; &gt;&gt;&gt; cPickle.dumps(l, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-string"><span class="hljs-string">'\x80\x02]q\x01(K\x00K\x01K\x02e.'</span></span></code> </pre><br>  We saved a few more bytes by converting set and frozenset to a list before sending.  Since the receiving side is usually not interested in the specific type of sequence, and only the data is important, such a replacement did not lead to errors. <br><br>  3. Quite often, not all keys in the dictionary are given values.  Some of them may be absent, while others may not differ from the default values, which are known in advance on both the transmitting and receiving sides.  It should also be remembered that the ‚Äúdefault‚Äù values ‚Äã‚Äãfor data of different types have different binary representations.  Rarely enough, but the default values ‚Äã‚Äãare still found, a little more complicated than just an empty value of a certain type.  In our case, these are several counters combined in one field, represented as sequences of zeros.  In these cases, the default values ‚Äã‚Äãcan take up a lot of space in the binary data sent between the nodes.  In order to achieve even greater savings, before sending, we replace the default values ‚Äã‚Äãwith None.  As a result, in all cases the binary representation will become more compact or will not change in length. <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>len(cPickle.dumps(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; len(cPickle.dumps((), <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; len(cPickle.dumps([], <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; len(cPickle.dumps({}, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; len(cPickle.dumps(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; len(cPickle.dumps(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; len(cPickle.dumps(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">12</span></span> &gt;&gt;&gt; len(cPickle.dumps([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre><br>  Considering the examples, it is worth considering that cPickle adds a header and a terminator to a binary package, the total amount of which is 3 bytes, and the actual amount of serialized data is <code>(X - 3)</code> , where X is the value from the example. <br>  Moreover, the replacement of default values ‚Äã‚Äãis also beneficial when compressing binary data with zlib.  In the binary representation, list-elements follow each other without any separators.  Several default values ‚Äã‚Äãin a row, replaced by None, will be represented as a sequence of identical bytes, which can be well archived. <br><br>  4. The data is archived by zlib with a compression level of 1, since this level allows to achieve the optimal ratio of the degree of archiving to the time of work. <br><br>  If we put together steps 1‚Äì3, we‚Äôll get something like this: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DictPacker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *metaData)</span></span></span><span class="hljs-function">:</span></span> self._metaData = tuple(metaData) <span class="hljs-comment"><span class="hljs-comment"># Packs input dataDict into a list. def pack(self, dataDict): metaData = self._metaData l = [None] * len(metaData) for index, metaEntry in enumerate(metaData): try: name, transportType, default, packer = metaEntry default = copy.deepcopy(default) # prevents modification of default. v = dataDict.get(name, default) if v is None: pass elif v == default: v = None elif packer is not None: v = packer.pack(v) elif transportType is not None and type(v) is not transportType: v = transportType(v) if v == default: v = None l[index] = v except Exception as e: LOG_DEBUG_DEV("error while packing:", index, metaEntry, str(e)) return l # Unpacks input dataList into a dict. def unpack(self, dataList): ret = {} for index, meta in enumerate(self._metaData): val = dataList[index] name, _, default, packer = meta default = copy.deepcopy(default) # prevents modification of default. if val is None: val = default elif packer is not None: val = packer.unpack(val) ret[name] = val return ret PACKER = DictPacker( ("2dArray", list, 0, None), ("someListOfIntsValue", list, [], None), ("someDictionaryValue", dict, {}, DictPacker( ("innerVal", int, 0, None), ("innerVal2", int, 0, None), ("listOfVals", list, [], None), ) ), ("someFloatValue", float, 0.0, None), ("someIntegerValue", int, 0, None), ("someBoolValue", bool, False, None), ) &gt;&gt;&gt; PACKER.pack(data) [[[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12], [13, 14, 15, 16, 17, 18], [19, 20, 21, 22, 23, 24]], [1, 2, 3], [1, 2, [1, 2, 3, 4]], 0.5, 1, True] &gt;&gt;&gt; len(cPickle.dumps(PACKER.pack(data), -1)) 126</span></span></code> </pre><br>  As a result, all these techniques were applied in protocol version 2, which was released in version 0.9.8, in May 2015. <br>  Yes, we have further increased the time spent on preliminary training, but the volume of the binary package has decreased significantly. <br><br><h4>  <b>Comparison of results</b> </h4><br>  In order to be able to see what the application of the above techniques on real data has led to, we present a graph of the size of a data package for a single tank, transmitted from CellApp to BaseApp at the end of the battle, in different versions from version. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/870/cc8/c1a/870cc8c1a3b34baaac97d8c660ab8c42.png" alt="Tank information packet size sent from BaseApp to CellApp"></div><br>  Recall that in the "Superiority" version of version 0.9.8, the player can go into battle on three tanks and, accordingly, the total amount of data will increase threefold. <br><br>  And the time spent on processing the same data before sending. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/974/c4a/85b/974c4a85ba7a46d3ae790357448db269.png" alt="Time to pre-process the package with BaseApp to CellApp"></div><br>  Where 0.9.8u is processing without compression by zlib (uncomressed), and 0.9.8c is with using compression (compressed).  The time is indicated in seconds per 10,000 iterations. <br><br>  I note that the data were collected for version 0.9.8 and then approximated for 0.9.5 and 0.1, taking into account the keys used.  Moreover, for each user and tank data will vary significantly, since the amount of data depends on the player's behavior (how many opponents were detected, damaged, etc.).  So the graphs should be treated rather as an illustration of the trend. <br><br><h4>  <b>Conclusion</b> </h4><br>  In our case, it was crucial to reduce the amount of data transferred between nodes.  It was also desirable to reduce the pretreatment time.  Therefore, the protocol of the second version was the best solution for us.  The next logical step is to bring the functionality of serialization into a separate binary module, which will perform all the manipulations on its own, and will not store information describing data in a binary stream, like pickle.  This will allow to shrink the amount of data even more, and, possibly, reduce the time for processing.  But while we work with the solution described above. </div><p>Source: <a href="https://habr.com/ru/post/272265/">https://habr.com/ru/post/272265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272255/index.html">The news called for the road: a super-fast, energy-efficient optical coprocessor for big data</a></li>
<li><a href="../272257/index.html">Access tables from C extensions for Postgres</a></li>
<li><a href="../272259/index.html">Law enforcement authorities dismantled the Dorkbot botnet</a></li>
<li><a href="../272261/index.html">Do you still store 404backup.zip on the server? I'm on 200D</a></li>
<li><a href="../272263/index.html">How to monitor all layers of infrastructure</a></li>
<li><a href="../272267/index.html">Kudu - a new data storage engine in the Hadoop ecosystem</a></li>
<li><a href="../272269/index.html">memset - side of darkness</a></li>
<li><a href="../272275/index.html">We invite speakers to the PHDays VI forum: tell us about your cyberwar</a></li>
<li><a href="../272277/index.html">When people make mistakes</a></li>
<li><a href="../272279/index.html">We get ramlog on distributions with systemd</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>