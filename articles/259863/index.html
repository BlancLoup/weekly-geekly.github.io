<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visual call graph: VTune Amplifier and beyond</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people like the representation of the program structure in the form of a call graph, the ‚Äúfunction call graph‚Äù. It is especially interesting if t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visual call graph: VTune Amplifier and beyond</h1><div class="post__text post__text-html js-mediator-article">  Many people like the representation of the program structure in the form of a call graph, the ‚Äúfunction call graph‚Äù.  It is especially interesting if this graph reflects the performance profile, the most ‚Äúhot‚Äù code branches. <br><br>  The call graph can be obtained using Intel VTune Amplifier XE, but for this we need another pair of utilities. <br><br><img src="https://habrastorage.org/files/3e1/bff/c21/3e1bffc216ad47209cc8e26ced921af6.png"><br><a name="habracut"></a><br>  First, about the basic functionality.  Presentation of performance profile data is one of the most powerful things in the VTune Amplifier arsenal.  You can explore the call tree on the Caller / Callee tab: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/af3/895/4a5/af38954a5a214cb7a413f7dd9581e242.png"><br><br>  On the left is a list of program functions, sorted by CPU time consumed.  Time is divided into total and proper.  The total time includes all called functions.  From this list you can see which functions themselves perform heavy calculations (long self time), and which are on the ‚Äúhot path‚Äù (long total time).  In the panel on the left, each function occurs once, i.e.  if it is called in different branches of the code, then the total and proper time from them is added up.  So you can determine the total contribution of each function. <br><br>  In our example, 12 functions have the largest total time, roughly the same, and zero self time.  This means that they are all on the ‚Äúhot road‚Äù, possibly causing each other.  If we want to explore this ‚Äúhottest way‚Äù, click on any function you like and look at the panels on the right. <br><br>  The top right panel displays a sequence of calls "up" - i.e.  all calling functions.  For each function of the tree also has its own and total time.  The root of the tree (above) is the function selected in the left pane.  If you click on the left to another, the tree will be rebuilt.  We chose the function render_one_pixel, and we see that almost all the other 11 functions with a large total time stand in one common call chain.  On this panel, a tree can branch - if there are several code branches, everything will be shown, with the CPU time distributed to all branches. <br><br>  The bottom right panel, you guessed it, draws a tree of called functions.  Those.  if the node you are interested in has a lot of total time and a little self time, it is worth seeing what it causes.  In the screenshot above, a significant part, 9.5 of 16 seconds, is spent in the function initialize_2D_buffer, the rest comes from the branch of the trace function. <br><br><h1>  We draw the visual call graph </h1><br>  The capabilities of the VTune Amplifier and the Caller / Callee view are enough to navigate the call tree and identify performance-critical functions.  However, some people like to see the whole tree at once, in one picture.  This is how some profilers present these data, as VTune did many years ago. <br>  For fans of the spreading tree of calls to hot functions, there is a way to build it. <br><br><h2>  1. Get the profile VTune Amplifier </h2><br>  Everything is simple here - we collect any result.  One condition - it must have stacks.  Those.  Advanced hotspots with a level of detail of ‚ÄúHotspots‚Äù will not work, there are no stacks there.  A simple analysis of Basic hotspots is quite suitable - you can build it in the GUI or command line: <br><pre><code class="bash hljs">amplxe-cl -collect hotspots -result-dir r000hs -- find_hotspots balls.dat</code> </pre> <br><h2>  2. We print out the result in gprof style. </h2><br>  VTune Amplifier can present data in the gprof profiler format, it will be necessary for further conversions.  Here you will definitely need the command line (the same on Windows and Linux): <br><pre> <code class="bash hljs">amplxe-cl -report gprof-cc -result-dir r000hs -format text -report-output r000hs_gprof_cc.txt</code> </pre> <br><img src="https://habrastorage.org/files/d7a/ff7/8d3/d7aff78d344d4fa7bcf199a1e9ee2cc8.png"><br><br><h2>  3. Convert the result to a graph with Gprof2dot </h2><br>  Now we need the Gprof2dot utility.  This is a python script that can build a graph in DOT format from the results of different profilers.  Thanks to Mr. Jose Fonseca for his creation and support. <br>  The script not only knows how to build a DOT graph from gprof results, but also supports VTune Amplifier - thanks to the community contributors.  The VTune and gprof formats, though similar, but not perfectly matched, had to make patches.  But the main thing is that now everything is working.  Specify ‚Äúax‚Äù as the format and printout from step 2 at the input: <br><pre> <code class="bash hljs">python gprof2dot.py -f axe r000hs_gprof_cc.txt</code> </pre> <br><h2>  4. Convert DOT graph to image </h2><br>  Here one more tool is useful - Graphviz.  He builds a visual image of the graph according to its description in text form: <br><pre> <code class="bash hljs">python gprof2dot.py -f axe r000hs_gprof_cc.txt | <span class="hljs-string"><span class="hljs-string">"c:\Program Files (x86)\Graphviz2.38\bin\dot"</span></span> -Tpng -or000hs_call_graph.png</code> </pre> <br>  Actually, step 4 includes step 3, just described in more detail who does what. <br>  Voila, now you can see the call tree visually (a fragment of the picture is shown): <br><img src="https://habrastorage.org/files/3e1/bff/c21/3e1bffc216ad47209cc8e26ced921af6.png"><br><br>  Such a graph reflects the structure of function calls (not all, the most computationally loaded), and the distribution of processor time, its own and total.  The redder the color, the greater the load on the function.  So you can observe the "hot path".  The disadvantages are the possible large size of the entire tree and its static nature - in the PNG image you can no longer group, filter, view the source code and performance metrics, as you can in VTune Amplifier.  But who likes what. </div><p>Source: <a href="https://habr.com/ru/post/259863/">https://habr.com/ru/post/259863/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259849/index.html">The crash of the satellite Express-MD1 (July 4, 2013)</a></li>
<li><a href="../259853/index.html">Swift 2.0 will be open source at the end of the year.</a></li>
<li><a href="../259855/index.html">Multidimensional Mtree Tree</a></li>
<li><a href="../259857/index.html">Development of a large scalable web 2.0 project from scratch (social network for 100 million users) - an interview with the leading master class at DevConf 2015</a></li>
<li><a href="../259859/index.html">Using junit-quickcheck on a simple example in the practice of TDD</a></li>
<li><a href="../259865/index.html">Mad PHP. Fury code</a></li>
<li><a href="../259867/index.html">Should robots teach children to talk?</a></li>
<li><a href="../259869/index.html">Kubotronic expands horizons</a></li>
<li><a href="../259871/index.html">Graphics Intel Core processors. Quick Reference Guide</a></li>
<li><a href="../259875/index.html">Passing the interview. Amazon's Legendary Books</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>