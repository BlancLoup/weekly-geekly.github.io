<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Money monoid</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mark Seeman talks about functional programming quickly and easily. To do this, he began writing a series of articles on the relationship between desig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Money monoid</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/it/u9/_u/itu9_uqtno_v0dp_vxk24qow2zo.png"></div><br>  Mark Seeman talks about functional programming quickly and easily.  To do this, he began writing a series of articles on the relationship between <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/">design patterns and category theory</a> .  Any OOshnik, which has 15 minutes of free time, will be able to get into their own hands a fundamentally new set of ideas and insights related not only to the functional area, but also to the correct object-oriented design.  The crucial factor is that <b>all the examples are real C #, F #, and Haskell code</b> . <br><br>  This habrapos is the second article in a series of articles about monoids: <br><ul><li>  <a href="https://habrahabr.ru/company/jugru/blog/340178/">Monoids, semigroups and all-all-all</a> </li><li>  <b>Money monoid</b> </li><li>  Convex hull monoid </li><li>  Tuple monoids </li><li>  Function monoids </li><li>  Endomorphism monoid </li><li>  Monoids accumulate </li></ul><br><a name="habracut"></a><br>  Before we begin, I would like to make a small digression regarding the title of the article.  In 2003, Kent Beck‚Äôs book, <a href="https://habrahabr.ru/company/piter/blog/326662/">Extreme Programming: Development Through Testing</a> , which in the original is called Test-Driven Development by example, came out, which had already become a bestseller.  One of such ‚Äúexample‚Äù was ‚ÄúMoney example‚Äù - an example of writing and refactoring an application that can perform multi-currency operations, for example, adding 10 dollars and 10 francs.  The title of this article is a reference to this book, and I strongly recommend that you familiarize yourself with the first part in order to better understand what the article is about. <br><cut></cut><br>  <i>"Money example" Kent Beck has some interesting properties.</i> <br><br>  In short, a monoid is an associative binary operation that has a neutral element (sometimes also called a <i>unit</i> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the first part of his book, Kent Beck explores the possibility of creating a simple and flexible "monetary API" using the principle of "development through testing."  As a result, he gets a solution, the design of which requires further study. <br><br><h4>  Kent Beck API </h4><br>  This article uses the code from Kent Beck‚Äôs book, translated by <a href="http://yawar.blogspot.ru/">Yavar Amin</a> into <a href="https://github.com/yawaramin/TDDMoney">C #</a> (the original code was written in Java), which I <a href="https://github.com/ploeh/TDDMoney">forked and added</a> . <br><br>  Kent Beck, in his book, was engaged in the development of an object-oriented API capable of processing money in several currencies, with the ability to work with expressions, such as "5 USD + 10 CHF".  By the end of the first part, it creates an interface that (translated into C #) looks like this: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExpression</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Money </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bank bank, string to)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IExpression addend)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span></span>; }</code> </pre> <br>  The <code>Reduce</code> method converts an <code>IExpression</code> object to a certain currency (to parameter), represented as a <code>Money</code> object.  This is useful if you have an expression that has multiple currencies. <br><br>  The <code>Plus</code> method adds an <code>IExpression</code> object to the current <code>IExpression</code> object and returns a new <code>IExpression</code> .  It can be money in one currency or in several. <br><br>  The <code>Times</code> method multiplies <code>IExpression</code> by a specific multiplier.  You probably noticed that in all the examples we use integers for the multiplier and the sum.  I think Kent Beck did this in order not to complicate the code, but in real life we ‚Äã‚Äãwould use fractional numbers when working with money (for example, <code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.decimal%3Fview%3Dnetframework-4.7.1">decimal</a></code> ). <br><br>  The metaphor of <i>"expression"</i> is that we can simulate working with money, like working with mathematical expressions.  A simple expression will look like <i>5 USD</i> , but there can also be <i>5 USD + 10 CHF</i> or <i>5 USD + 10 CHF + 10 USD</i> .  Although you can easily calculate ( <i>reduce</i> ) some simple expressions, for example, <i>5 CHF + 7 CHF</i> , you cannot calculate the expression <i>5 USD + 10 CHF</i> if you do not have the exchange rate.  Instead of trying to immediately calculate monetary transactions, in this project we create a tree of expressions, and only then perform its transformation.  Sounds familiar, doesn't it? <br><br>  Kent Beck in his examples implements the <code>IExpression</code> interface <code>IExpression</code> two classes: <br><br><ul><li>  <code>Money</code> represents a certain amount of money in a particular currency.  It contains the properties ‚ÄúAmount‚Äù (quantity) and ‚ÄúCurrency‚Äù (name of currency).  This is a key point: <code>Money</code> is <i>a</i> <i>value object</i> . </li><li>  <code>Sum</code> is the sum of two other <code>IExpression</code> objects.  It contains two terms, called <i>Augend</i> (first term) and <i>Addend</i> (second term). </li></ul><br>  If we want to describe the expression <i>5 USD + 10 CHF</i> , it will look something like this: <br><br><pre> <code class="java hljs">IExpression sum = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sum(Money.Dollar(<span class="hljs-number"><span class="hljs-number">5</span></span>), Money.Franc(<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br>  where <code>Money.Dollar</code> and <code>Money.Franc</code> are two static factory methods that return <code>Money</code> objects. <br><br><h4>  Associativity </h4><br>  Have you noticed that <code>Plus</code> is a binary operation?  Can we consider it a monoid? <br><br>  To be a monoid, it must satisfy the <i>laws of the monoid</i> , the first of which says that the operation must be associative.  This means that for three <code>IExpression</code> objects, <code>x</code> , <code>y</code> and <code>z</code> , the expression <code>x.Plus(y).Plus(z)</code> must be equal to <code>x.Plus(y.Plus(z))</code> .  How should we understand equality here?  The return value of the <code>Plus</code> method is the <code>IExpression</code> interface, and the interfaces have no such thing as equality.  So, either, equality depends on specific implementations ( <code>Money</code> and <code>Sum</code> ), where we can define appropriate methods, or we can use <i>test matching</i> (test pattern, <a href="http://xunitpatterns.com/test-specific%2520equality.html">test-specific equality</a> , - <i>approx. Lane</i> ). <br><br>  The library for testing <a href="https://xunit.github.io/">xUnit.net</a> supports test compliance through the implementation of custom comparators (for a detailed study of the possibilities of unit testing, the author proposes to take his <a href="https://www.pluralsight.com/courses/advanced-unit-testing%3Futm_medium%3Daffiliate%26utm_source%3D1017843">Advanced Unit Testing</a> course at Pluralsight.com).  However, in the original Money API it is already possible to compare objects of type <code>IExpression</code> ! <br><br>  The <code>Reduce</code> method can convert any <code>IExpression</code> to an object of type <code>Money</code> (that is, to a single currency), and since <code>Money</code> is an object-value, it has <i>structural equality</i> (for more information about value objects and their features, you can read, for example, <a href="https://habrahabr.ru/post/268371/">here</a> ).  And we can use this property to compare <code>IExpression</code> objects.  All we need is the exchange rate. <br><br>  In his book, Kent Beck uses a 2: 1 exchange rate between CHF and USD.  At the time of this writing, the exchange rate was CHF 0.96 to the dollar, but since the example code everywhere uses whole numbers for money transactions, I will have to round the rate to 1: 1.  This, however, is a rather foolish example, so instead I will stick to the original 2: 1 exchange rate. <br><br>  Now let's write the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B4%25D0%25B0%25D0%25BF%25D1%2582%25D0%25B5%25D1%2580_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">adapter</a> between <code>Reduce</code> and xUnit.net as the <code>IEqualityComparer&lt;IExpression&gt;</code> class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionEqualityComparer</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEqualityComparer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExpression</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Bank bank; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExpressionEqualityComparer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bank = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bank(); bank.AddRate(<span class="hljs-string"><span class="hljs-string">"CHF"</span></span>, <span class="hljs-string"><span class="hljs-string">"USD"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IExpression x, IExpression y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xm = bank.Reduce(x, <span class="hljs-string"><span class="hljs-string">"USD"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ym = bank.Reduce(y, <span class="hljs-string"><span class="hljs-string">"USD"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.Equals(xm, ym); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IExpression obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bank.Reduce(obj, <span class="hljs-string"><span class="hljs-string">"USD"</span></span>).GetHashCode(); } }</code> </pre> <br>  You have noticed that the comparator uses a <code>Bank</code> object with a 2: 1 exchange rate.  The <code>Bank</code> class is another object from the Kent Beck code.  It itself does not implement any interface, but is used as an argument to the <code>Reduce</code> method. <br><br>  To make our test code more readable, add an auxiliary static class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Compare</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ExpressionEqualityComparer UsingBank = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpressionEqualityComparer(); }</code> </pre> <br>  This will allow us to write an assertion that checks equality for the associativity operation: <br><br><pre> <code class="java hljs">Assert.Equal( x.Plus(y).Plus(z), x.Plus(y.Plus(z)), Compare.UsingBank);</code> </pre> <br>  In my fork of the Yavar Amin code, I added this assertion to the FsCheck test, and it is used for all <code>Sum</code> and <code>Money</code> objects that FsCheck generates. <br><br>  In the current implementation, <code>IExpression.Plus</code> associative, but it's worth noting that this behavior is not guaranteed, and here's why: <code>IExpression</code> is an interface, so someone can easily add a third implementation that will break the associativity.  Conventionally, we will assume that the operation <code>Plus</code> associative, but the situation is delicate. <br><br><h4>  Neutral element </h4><br>  If we agree that <code>IExpression.Plus</code> associative, then this is a candidate for monoids.  If there exists a neutral element, then this is definitely a monoid. <br><br>  Kent Beck did not add a neutral element to his examples, so add it yourself: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExpression Identity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlusIdentity(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlusIdentity</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExpression</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IExpression addend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addend; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Money </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bank bank, string to)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Money(<span class="hljs-number"><span class="hljs-number">0</span></span>, to); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } }</code> </pre> <br>  Since there can be only one neutral element, it makes sense to make it a <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">singleton</a> .  The private class <code>PlusIdentity</code> is a new implementation of <code>IExpression</code> that does nothing. <br><br>  The <code>Plus</code> method simply returns the input value.  This is the same behavior as for adding numbers.  When added, zero is a neutral element, and the same thing happens here.  This is more clearly seen in the <code>Reduce</code> method, where the calculation of a ‚Äúneutral‚Äù currency is simply reduced to zero in the requested currency.  Finally, if you multiply a neutral element by something, you get a neutral element.  Here, interestingly, <code>PlusIdentity</code> behaves like a neutral element for a multiplication operation (1). <br><br>  Now we write tests for any <code>IExpression</code> <code>x</code> : <br><br><pre> <code class="java hljs">Assert.Equal(x, x.Plus(Plus.Identity), Compare.UsingBank); Assert.Equal(x, Plus.Identity.Plus(x), Compare.UsingBank);</code> </pre> <br>  This is a property test, and it is executed for all <code>x</code> generated by FsCheck.  Caution applied to associativity is also applicable here: <code>IExpression</code> is an interface, so you cannot be sure that <code>Plus.Identity</code> will be a neutral element for all implementations of <code>IExpression</code> that anyone can create, but for three existing implementations, monoid laws are preserved. <br><br>  Now we can assert that the operation <code>IExpression.Plus</code> is a monoid. <br><br><h4>  Multiplication </h4><br>  In arithmetic, the multiplication operator is called ‚Äútime‚Äù.  When you write <i>3 * 5</i> , it literally means that you have <code>3</code> five times (or <code>5</code> three times?).  In other words: <br> <code>3 * 5 = 3 + 3 + 3 + 3 + 3</code> <br>  Is there a similar operation for <code>IExpression</code> ? <br><br>  Perhaps we can find a clue in the Haskell language, where monoids and semigroups are part of the main library.  Later you will learn about semigroups, but for the moment just note that the <code>Semigroup</code> class defines the <code>stimes</code> function, which is of type <code>Integral b =&gt; b -&gt; a -&gt; a</code> .  This means that for any integer type (16-bit integer, 32-bit integer, etc.), the <code>stimes</code> function takes an integer and a value <code>a</code> and ‚Äúmultiplies‚Äù the value by a number.  Here <code>a</code> is the type for which there is a binary operation. <br><br>  In C #, the <code>stimes</code> function will look like a method of the <code>Foo</code> class: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span></span></code> </pre> <br>  I called the method <code>Times</code> , not <code>STimes</code> , because I strongly suspect that the letter <code>s</code> in the name <code>stimes</code> means <code>Semigroup</code> .  And note that this method has the same signature as the <code>IExpression.Times</code> method. <br><br>  If you can define a universal implementation of such a function in Haskell, can you do the same in C #?  In the <code>Money</code> class, we can implement <code>Times</code> using the <code>Plus</code> method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable .Repeat((IExpression)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, multiplier) .Aggregate((x, y) =&gt; x.Plus(y)); }</code> </pre> <br>  The static LINQ library's <code>Repeat</code> method returns <code>this</code> as many times as specified in the <code>multiplier</code> .  The return value is an <code>Enumerable&lt;IExpression&gt;</code> , but according to the <code>IExpression</code> interface, <code>IExpression</code> should return one <code>IExpression</code> value.  We use the <code>Aggregate</code> method to repeatedly merge two <code>IExpression</code> values ‚Äã‚Äã( <code>x</code> and <code>y</code> ) into one using the <code>Plus</code> method. <br><br>  This implementation is unlikely to be as effective as the previous, concrete implementation, but here we are not talking about efficiency, but about a common, reusable abstraction.  Exactly the same implementation can be used for the <code>Sum.Times</code> method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable .Repeat((IExpression)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, multiplier) .Aggregate((x, y) =&gt; x.Plus(y)); }</code> </pre><br>  This is the exact same code as for <code>Money.Times</code> .  You can also copy and paste this code into <code>PlusIdentity.Times</code> , but I will not repeat it here because it is the same code as above. <br><br>  This means that you can remove the <code>Times</code> method from <code>IExpression</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IExpression</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Money </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bank bank, string to)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IExpression addend)</span></span></span></span>; }</code> </pre> <br>  instead, by implementing it as an <i>extension method</i> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expression</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Times</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IExpression exp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> multiplier)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Enumerable .Repeat(exp, multiplier) .Aggregate((x, y) =&gt; x.Plus(y)); } }</code> </pre> <br>  This will work because any <code>IExpression</code> object has a <code>Plus</code> method. <br><br>  As I said, this will probably be less effective than specialized implementations of The <code>Times</code> .  In Haskell, this is eliminated by including <code>stimes</code> in the type class ( <i>typeclass</i> ), so developers can implement a more efficient algorithm than the default implementation.  In C #, the same effect can be achieved by reorganizing <code>IExpression</code> into an abstract base class using the <code>Times</code> as a public virtual (overridable) method. <br><br><h4>  Validation check </h4><br>  Since Haskell has a more formal definition of a monoid, we can try to rewrite the Kent Beck API in Haskell, simply as proof of the idea itself.  In my last modification, my fork in C # has three implementations of <code>IExpression</code> : <br><br><ul><li> <code>Money</code> </li> <li> <code>Sum</code> </li> <li> <code>PlusIdentity</code> </li> </ul><br>  Since the interfaces are extensible, we need to take care of this, so in Haskell it seems to me safer to implement these three subtypes as a type of <code>sum</code> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Money</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">amount</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">currency</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> } | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">augend</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addend</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> } | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MoneyIdentity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  More formally, we can do this using <code>Monoid</code> <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> mempty = <span class="hljs-type"><span class="hljs-type">MoneyIdentity</span></span> mappend <span class="hljs-type"><span class="hljs-type">MoneyIdentity</span></span> y = y mappend x <span class="hljs-type"><span class="hljs-type">MoneyIdentity</span></span> = x mappend xy = <span class="hljs-type"><span class="hljs-type">Sum</span></span> xy</code> </pre> <br>  The <code>Plus</code> method from our C # example here is represented by the <code>mappend</code> function.  The only remaining member of the <code>IExpression</code> class is the <code>Reduce</code> method, which can be implemented as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Map.Strict (<span class="hljs-type"><span class="hljs-type">Map</span></span>, (!)) reduce :: Ord a =&gt; Map (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-title"><span class="hljs-title">a</span></span>) Int -&gt; a -&gt; Expression -&gt; Int reduce bank to (<span class="hljs-type"><span class="hljs-type">Money</span></span> <span class="hljs-title"><span class="hljs-title">amt</span></span> <span class="hljs-title"><span class="hljs-title">cur</span></span>) = amt `div` rate where rate = bank ! (<span class="hljs-title"><span class="hljs-title">cur</span></span>, <span class="hljs-title"><span class="hljs-title">to</span></span>) reduce bank to (<span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-title"><span class="hljs-title">xy</span></span>) = reduce bank to x + reduce bank to y reduce _ _ MoneyIdentity = 0</code> </pre><br>  The rest of the timeclass mechanism will take care of the rest, so now we can reproduce one of the Kent Beck tests as follows: <br><br><pre> <code class="haskell hljs">Œª&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bank = fromList [((<span class="hljs-string"><span class="hljs-string">"CHF"</span></span>,<span class="hljs-string"><span class="hljs-string">"USD"</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>), ((<span class="hljs-string"><span class="hljs-string">"USD"</span></span>, <span class="hljs-string"><span class="hljs-string">"USD"</span></span>),<span class="hljs-number"><span class="hljs-number">1</span></span>)] Œª&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = stimesMonoid <span class="hljs-number"><span class="hljs-number">2</span></span> $ <span class="hljs-type"><span class="hljs-type">MoneyPort</span></span>.<span class="hljs-type"><span class="hljs-type">Sum</span></span> (<span class="hljs-type"><span class="hljs-type">Money</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-string"><span class="hljs-string">"USD"</span></span>) (<span class="hljs-type"><span class="hljs-type">Money</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-string"><span class="hljs-string">"CHF"</span></span>) Œª&gt; reduce bank <span class="hljs-string"><span class="hljs-string">"USD"</span></span> sum <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br>  Just as <code>stimes</code> works for any <code>Semigroup</code> , <code>stimesMonoid</code> defined for any <code>Monoid</code> , and therefore we can also use it with <code>Expression</code> . <br><br>  With a historical exchange rate of 2: 1, "5 dollars + 10 Swiss francs multiplied by 2" will be just 20 dollars. <br><br><h4>  Summary </h4><br>  In the 17th chapter of his book, Kent Beck describes how he repeatedly tried to come up with various variants of the Money API before trying to make it ‚Äúon expressions‚Äù, which he eventually used in the book.  In other words, he had a lot of experience, both with this particular problem and with programming as a whole.  Obviously, this work was done by a highly qualified programmer. <br><br>  And it seemed to me curious that he seems to intuitively come to "monoid design."  Perhaps he did it on purpose (he does not speak about it in the book), so I would rather assume that he came to this design simply because he realized its superiority.  It is for this reason that it seems to me interesting to consider <i>this particular</i> example as a monoid, because it gives an idea that there is something highly understandable with regard to API based on a monoid.  Conceptually, this is just a ‚Äúsmall addition.‚Äù <br><br>  In this article, we returned to the code of nine-year-old (actually, 15-year-old) <i>note</i> to identify it as a monoid.  In the next article, I'm going to review the code for 2015. <br><br><h4>  Conclusion </h4><br>  This concludes this article.  There is still a lot of information ahead that will be published in the same way as in the original - in the form of consecutive posts on Habr√©, linked by backward links.  Here and below: originals of articles - <a href="http://blog.ploeh.dk/2017/10/16/money-monoid">Mark Seemann</a> 2017, translations are made by the java-community, the translator is Yevgeny Fedorov. </div><p>Source: <a href="https://habr.com/ru/post/341398/">https://habr.com/ru/post/341398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341384/index.html">Talk with ghosts: Ada Lovelace</a></li>
<li><a href="../341386/index.html">Introducing loghouse - an open source system for working with logs in Kubernetes</a></li>
<li><a href="../341390/index.html">Bid optimization: the relationship between the cost per click and the set rate</a></li>
<li><a href="../341392/index.html">HEIF - a new standard format for storing images in iOS and MacOS</a></li>
<li><a href="../341394/index.html">Announcement of Moscow Spark # 3</a></li>
<li><a href="../341400/index.html">Cryptopolicy: law enforcement agencies on blockchain technology</a></li>
<li><a href="../341402/index.html">Kotlin DSL: Theory and Practice</a></li>
<li><a href="../341404/index.html">On the development of a single desktop application in Python</a></li>
<li><a href="../341406/index.html">Dataset: associations to the words and expressions of the Russian language</a></li>
<li><a href="../341408/index.html">Pediatric Bone Age Challenge. Deep learning and many, many bones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>