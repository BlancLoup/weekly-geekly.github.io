<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Polyglot in production Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Immediately, in order zavlekalochki. Our goal will be to learn how to write polyglot programs that can be interpreted in several programming languages...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Polyglot in production Python</h1><div class="post__text post__text-html js-mediator-article">  Immediately, in order zavlekalochki.  Our goal will be to learn how to write <a href="http://habrahabr.ru/blogs/crazydev/62058/">polyglot</a> programs that can be interpreted in several programming languages ‚Äã‚Äãat once (one of which is ‚Äúbasic‚Äù Python).  In this case, in the case of interpretation on one of them, the program will generate another program, functionally similar (or even equivalent) to that which is performed in the case of interpretation in another language. <br><br>  And the most interesting: the approaches used in writing this program will be interesting not so much academically as practically - when developing a program using these approaches, development will be easier and more convenient (at least a bit unusual at first), and the program will be more efficient than without them. <br><br>  However, it sounds worse than it is. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a>  Go? <br><br><h1>  __debug__ </h1><br>  Let's start with a fairly simple - with code generation.  Python programmers know that in Python there is no preprocessor (as, for example, in C) that would allow you to create macros that, depending on some parameters, generate different code at the compile-time stage.  The ‚Äúdynamism‚Äù of Python, of course, allows you to generate anything and anytime at runtime, but ... sometimes the ability to influence the compile time is also useful, and even necessary. <br><br>  The preprocessor in Python, of course not.  But all Python programmers surely know the directive assert, which allows you to add a check to the program code that in some place the value of an expression is invariant. <br><br>  At the same time, they will surely remember that this directive is ignored when the Python interpreter runs ‚Äúoptimized‚Äù (i.e., the <code>-O</code> key) and is not executed by the interpreter. <br><br>  Compare, for example, <br><table><tbody><tr><td><pre> #! / usr / bin / python<font></font>
<font></font>
 def func (x):
     assert x&gt; 5
     return x<font></font>
<font></font>
 import dis;  dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>
   4 0 LOAD_FAST 0 (x)
               3 LOAD_CONST 1 (5)
               6 COMPARE_OP 4 (&gt;)
               9 JUMP_IF_TRUE 7 (to 19)
              12 POP_TOP
              13 LOAD_GLOBAL 0 (AssertionError)
              16 RAISE_VARARGS 1
         &gt;&gt; 19 POP_TOP<font></font>
<font></font>
   5 20 LOAD_FAST 0 (x)
              23 RETURN_VALUE
</pre></td></tr></tbody></table><br>  and <br><table><tbody><tr><td><pre> #! / usr / bin / python -O<font></font>
<font></font>
 def func (x):
     assert x&gt; 5
     return x<font></font>
<font></font>
 import dis;  dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>   5 0 LOAD_FAST 0 (x)
               3 RETURN_VALUE
</pre></td></tr></tbody></table>  . <br><br>  What follows from this?  That, by varying the value of optimization when starting the generation of byte code, you can get completely different byte code.  Code that behaves differently depending on whether it was run in optimization mode or without it.  What is this if not the germ of a preprocessor? <br>  Why do we need this?  In order to significantly separate the behavior of debug-and release-build-s.  Everything is like ‚Äúin big languages‚Äù - a bunch of checks, logs and informativeness in debug-build, fast and efficient code in release-build.  But is it not enough for this one directive assert? <br><br>  So, assert is different depending on the optimization setting that was at the time of generating the bytecode (I hope everyone remembers / knows that it is not necessary to regenerate the byte code every time? Moreover, Ie files <code>.pyc</code> / <code>.pyo</code> , can be distributed without source codes from which they were generated). <br>  From this it follows quite logically that the information on whether the optimization was enabled at the time of its launch was available to the bytecode generator.  And how, by the way, does he know how to optimize the code? <br><br>  So, this very information is available to him in the form of a constant <code>__debug__</code> .  Pay attention - really constants.  Not so often in an absolutely dynamic Python language, you can find constants :) But since this is a constant, the optimizer is able to generate code differently, depending on its value: <br><br><table><tbody><tr><td><pre> #! / usr / bin / python<font></font>
<font></font>
 def func ():
     if __debug__:
         print<font></font>
<font></font>
 import dis;  dis.dis (func) </pre></td><td>  ‚Üí </td><td><pre>
   5 0 PRINT_NEWLINE
               1 LOAD_CONST 0 (None)
               4 RETURN_VALUE
</pre></td></tr></tbody></table><br><br><table><tbody><tr><td><pre> #! / usr / bin / python -O<font></font>
<font></font>
 def func ():
     if __debug__:
         print<font></font>
<font></font>
 import dis;  dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>   4 0 LOAD_CONST 0 (None)
               3 RETURN_VALUE
</pre></td></tr></tbody></table><br><br>  And this, and, as a special case, optimization of the assert directive (well, plus the removal of docstrings with <code>-OO</code> ) is actually the whole spectrum of skills of the optimizer. <br><br>  This optimizer is so simple that, although it can optimize code generation for the <code>or</code> and <code>and</code> operators on <i>variables</i> (so that the second part of the test will not be <i>performed</i> if unnecessary), but optimize the code generation when the first test is a <i>constant</i> (so that the second part of the check will not be <i>generated</i> if it is not needed); it is no longer able: <br><br><table><tbody><tr><td><pre> #! / usr / bin / python -O<font></font>
<font></font>
 def func (x):
     if __debug__ and x&gt; 5:
         print<font></font>
<font></font>
 import dis
 dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>   4 0 LOAD_GLOBAL 0 (__debug__)
               3 JUMP_IF_FALSE 18 (to 24)
               6 POP_TOP
               7 LOAD_FAST 0 (x)
              10 LOAD_CONST 1 (5)
              13 COMPARE_OP 4 (&gt;)
              16 JUMP_IF_FALSE 5 (to 24)
              19 POP_TOP<font></font>
<font></font>
   5 20 PRINT_NEWLINE
              21 JUMP_FORWARD 1 (to 25)
         &gt;&gt; 24 POP_TOP
         &gt;&gt; 25 LOAD_CONST 0 (None)
              28 RETURN_VALUE
</pre></td></tr></tbody></table><br><br>  Please note: although the optimization has been enabled, even though the generated code can skip the check for <code>x &gt; 5</code> , if after checking it <code>__debug__</code> out that the constant <code>__debug__</code> set to <code>True</code> , it will do the check itself.  Therefore, if you need to get rid of even generating some code in the release-build, you will have to optimize the code ‚Äúin the old manner‚Äù - to do nested checks, first for the <code>__debug__</code> value, and only inside it at <code>x &gt; 5</code> : <br><br><table><tbody><tr><td><pre> #! / usr / bin / python -O<font></font>
<font></font>
 def func (x):
     if __debug__:
         if x&gt; 5:
             print<font></font>
<font></font>
 import dis
 dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>   4 0 LOAD_CONST 0 (None)
               3 RETURN_VALUE
</pre></td></tr></tbody></table><br><br>  By the way, the ternary operator is also not optimized to check for a constant: <br><br><table><tbody><tr><td><pre> #! / usr / bin / python -O<font></font>
<font></font>
 def func (x):
     return 5 if __debug__ else 7<font></font>
<font></font>
 import dis
 dis.dis (func)
</pre></td><td>  ‚Üí </td><td><pre>   4 0 LOAD_GLOBAL 0 (__debug__)
               3 JUMP_IF_FALSE 7 (to 13)
               6 POP_TOP
               7 LOAD_CONST 1 (5)
              10 JUMP_FORWARD 4 (to 17)
         &gt;&gt; 13 POP_TOP
              14 LOAD_CONST 2 (7)
         &gt;&gt; 17 RETURN_VALUE<font></font>
<font></font>
</pre></td></tr></tbody></table><br><br>  Recall why we are doing this: in order to be able in debug-builds to have arbitrarily detailed debugging information (for example, displayed in the service logs) that would be omitted without affecting the performance of release-builds . <br><br>  But now, when we know exactly what and how you can do with the variable <code>__debug__</code> (no composite logical operations, no ternary operations ‚Äî just a clean check of one variable <code>__debug__</code> for validity), we can do, for example, the following: <br><br><table><tbody><tr><td><pre> if __debug__:
     def log (msg):
         __do_some_heavy_logging (msg)
 else:
     def log (msg):
         pass
</pre></td></tr></tbody></table><br><br>  This is already something.  Now we can install a <code>log(-)</code> at least every second line of code - this will not affect the performance of the release-build. <br><br>  Well, to be honest, <i>almost</i> not at all.  Suppose now that we do not write every line of the log on the release-build by terribly slow calling the <code>__do_some_heavy_logging()</code> procedure to print a line on an ancient roll-on ADC - but the call to each <code>log()</code> function, albeit empty, will remain in the release-build.  And the generation of a message for him (if it is also computationally nontrivial).  But there's nothing you can do.  In Python, there is no preprocessor, and we will not be able to completely omit the <code>log()</code> call on debug-build-ah.  However‚Ä¶ <br><br><h1>  GPP: GNU Python Preprocessor </h1><br>  ... However, if the preprocessor is not in the Python itself, why not take it from the outside?  What can you not do in an effort to optimize release-build. <br><br>  Glory to the gods, there is a GPP in the world - the Generic Preprocessor, the General-Purpose Processor, and now the new backronym - the GNU Python Preprocessor.  Why not? <br><br>  Especially to describe it and re-read the man aloud reluctance.  I can only say that its syntax actually repeats the syntax of the preprocessor in C: <code>#define</code> , <code>#if</code> , etc. <br><br>  What is very convenient - in Python, comments begin with a sharp sign.  Do you realize what it means? .. <br><br>  Right.  Now we will write a <a href="http://habrahabr.ru/blogs/crazydev/62058/">polyglot</a> program. <br><br>  Yes.  This is quite a full polyglot.  The program is in two languages ‚Äã‚Äã- the language of Python (not possessing a preprocessor), and the language of GPP. <br><br>  At the same time, these programs are not of the <code>print "Hello world"</code> level <code>print "Hello world"</code> , equally behaving in 4242 different programming languages ‚Äã‚Äãand dialects.  Not at all, our programs will even have different tasks.  A Python program (1) will have to solve the problem for which we are writing it.  A GPP (2) program should generate Python (3) / (4) programs that solve the problem for which we are writing it. <br><br>  Moreover, pay attention to two funny facts.  First, a GPP program will generate not one, but at least (in our case) two different Python programs.  One (3) is the corresponding debug-build, the other (4) is the corresponding release-build.  And secondly, (1) is definitely not at all equal to (4) (in order for the release build to differ from the middleware developer towards higher performance due to discarding the debugging code, we started everything), and it doesn‚Äôt even have to be equal ( 3)!  But it is better, of course, that at least (1) be equal to (3).  Otherwise we will get confused.  Too many levels on which to think at the same time.  A typical problem when writing a polyglot program. <br><br>  Well, let's try? <br><br>  Writing source code on GPP: <br><br><table><tbody><tr><td><pre> #ifdef debug
 #define log (msg) __do_some_heavy_logging (msg)
 #else
 #define log (msg)
 #endif
</pre></td></tr></tbody></table><br><br>  In general, not bad.  If we called GPP with the <code>-Ddebug</code> parameter, then it will replace the function call <code>__do_some_heavy_logging(msg)</code> in each place of the source code where the function call <code>log()</code> <code>__do_some_heavy_logging(msg)</code> .  Compared to code based on <code>__debug__</code> , the direct benefit is already less than one intermediate function call.  If we called GPP without such a parameter, then it will replace every call to the <code>log()</code> function with an empty string ... <br><br>  Hooray!  What we need ... or not? <br><br>  And if we execute this code immediately in the Python interpreter without preprocessing?  Then, for any call to the <code>log()</code> function, the interpreter simply does not find it ‚Äî in our case, it is defined in the preprocessor. <br><br>  So, it is necessary to define it and at the level of Python.  And so as not to interfere with the preprocessor.  The second pancake: <br><br><table><tbody><tr><td><pre> def log (msg):
     __do_some_heavy_logging (msg)
 #ifdef debug
 #define log (msg) __do_some_heavy_logging (msg)
 #else
 #define log (msg)
 #endif
</pre></td></tr></tbody></table><br><br>  Already better.  Without preprocessing, we create the <code>log()</code> function and use it every time we call <code>log()</code> in the code.  With preprocessing, without preprocessor variable <code>debug</code> - <code>log()</code> calls are replaced with an empty string.  With preprocessing, with the <code>debug</code> preprocessor variable: replace <code>log()</code> calls with <code>__do_some_heavy_logging()</code> calls. <br><br>  Good?  Already better.  But there is one caveat: we (1) turned out not equal to (3).  Which, of course, is beautiful, but potentially dangerous during the development process.  It is better to make sure that the <code>debug</code> code preprocessing in the mode is absolutely equivalent to the non-preprocessing code.  And so put it all inside the <code>#ifdef debug</code> check. <br><br><table><tbody><tr><td><pre> #ifdef debug
 def log (msg):
     _do_some_heavy_logging (msg)
 #else
 #define log (msg)
 #endif
</pre></td></tr></tbody></table><br><br>  That's so much better.  In the <code>#ifdef debug</code> section <code>#ifdef debug</code> is only a non-preprocessor code, and therefore the program will behave in the same way with both the preprocessor and the <code>-Ddebug</code> variable, and without the preprocessor.  In the <code>else</code> section, only the preprocessor code (and therefore it will work only in the release-build).  So that.  And even the Python variable <code>__debug__</code> no longer needed. <br><br><h1>  Cython </h1><br>  Now that we have learned how to generate Python code by the preprocessor and at the same time maintain start-up capability without passing the preprocessor, why not take the task more complicated? <br><br>  Why don't we try to write a program that, after passing GPP in release mode (without the <code>-Ddebug</code> variable), generates code <i>in a different</i> programming language?  Well, or <i>almost another</i> ? <br><br>  What for? <br><br>  And, for example, because this language can be Cython.  Based on Python and close to it in syntax, but explicitly typed.  And having a nice and useful feature in the household: a Cython program / module can be translated into C source code, and a module suitable for use from Python code can be created from this source code after compilation. <br><br>  The only thing is that Cython programs are not backwards compatible with Python.  But Python programs are usually correct Cython programs.  On the one hand, this simplifies the task to almost triviality.  On the other - we are not pioneers, in order to create difficulties for ourselves and solve them heroically, we just want to write in Python efficiently. <br><br>  So, the goal: to write a module in Python (1 '), which has a function that performs some kind of calculations.  This module should be safely imported and used by Python itself without any preprocessing - so that it is more convenient to develop.  In addition, this module must be a GPP program (2 ').  Which, in the case of appropriately specifying GPP variables, should generate a Cython program (3 ').  Containing an algorithm that is completely similar to the program (1 '), but typed.  Such that after translating the source code (3 ') into C (4') and compiling, a binary Python library will be created that performs the same as in (1 '), only due to the compiled code, much faster. <br><br>  As a solvable problem, we take, for example, the <a href="http://projecteuler.net/index.php%3Fsection%3Dproblems%26id%3D2">second problem of the Project Euler</a> : <i>find the sum of all even Fibonacci numbers that do not exceed four million</i> .  Imagine that we need to solve it as part of a much larger problem, and we still want to solve the problem in Python.  It's just that we want to optimize this function for performance by rewriting it in Cython.  At the same time, we want to preserve the ability to run the same code without processing by Cython (and GPP), as usual Python code, for reasons of ease of development. <br><br>  The desired process looks like the development: we make the Python module, from which we are in the process of development and debugging and we will import the function calculating our task solution.  When generating a release-build, the same code will be interpreted by means of GPP, which will generate the equivalent Cython program (with the necessary data typing for this task);  later in the release-build build process, the Cython program will be translated by Cython into a C program, which will be compiled into a library available for use by the Python code.  And in the release-build, the calling Python code will import the function not from the Python module, but from the binary library, compiled and very fast. <br><br>  What should the function that solves the second task look like?  Spoiler, of course ... but this is the second task, and any reasonable programmer who has finished reading this line and has not escaped into the realm of Morpheus will surely calmly decide it himself.  Therefore, it will not be a big loss for the educational process if I write this function: <br><br><table><tbody><tr><td><pre> def sum_even_fibo_le (upb):
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  Accordingly, we write the module <code>fibo.py</code> , which contains this function, in the main program we import the function from this module and call it, passing the upper bound for the task. <br><br>  Although this function is even for the upper limit of four million and is performed fairly quickly even in interpreted Python, but in this case it simply demonstrates the capabilities that we can achieve.  Therefore, we will try to optimize it, no matter what.  Rewrite it in Cython. <br><br>  In principle, the Python function we already have is a fully valid Cython function.  Moreover, being compiled by Cython, it will even work faster.  In two or three times.  Because the bytecode processing stage will completely disappear, and instead of it, the machine code will immediately perform the necessary operations on Python objects. <br><br>  But this is not the limit.  If we decide to typify our data (while, unfortunately, having lost the pleasant unboundedness of the Python data type long), then our code will work even faster. <br><br>  What will we (can) type in Cython?  Input arguments to functions.  Output results of functions.  Intermediate variables. <br><br>  So we typify everything.  Let's calculate that 64 bit should be enough for everybody, and we will result in all variables to unsigned long long.  At the same time we will get acquainted with Cython, who does not know him: <br><br><table><tbody><tr><td><pre> cdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
    </pre></td></tr></tbody></table><br><br>  The code is good, quite readable for pythonists, and quite understandable.  It has only two drawbacks: <br><ol><li>  It is no longer valid Python code.  However, we will solve it.  Preprocessor.  But‚Ä¶ </li><li>  He does not work. </li></ol><br><br>  Well, not that it does not work at all.  Just does not solve our problem.  This code perfectly creates, in Cython terminology, the ‚ÄúC function‚Äù.  Which can be called from other Cython code or even C, but which cannot be called from Python code.  What does not suit us. <br>  We'll have to modify this function so that it remains ‚ÄúPython function‚Äù.  A bit slow call (however, the call from Cython code can be saved fast), which returns PyObject (if someone is disturbed by the Python's interpreter interpreter). <br><br><table><tbody><tr><td><pre> cpdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  So, we have a function in Python, which solves our problem, albeit slowly, but it is more convenient to debug the module with it ‚Äî run it for interpretation without intermediate processing.  And the function on Cython, which the usual Python interpreter no longer understands, but which is then the most productive: <br><br><table><tbody><tr><td><pre> def sum_even_fibo_le (upb):
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td><td>  ‚à™ </td><td><pre> cpdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  Let's use our favorite GPP (or what, you haven‚Äôt loved it yet?), Recall the knowledge that we acquired during the creation of the first Python / GPP polyglot program, and first write a GPP program: <br><br><table><tbody><tr><td><pre> #ifdef debug
 def sum_even_fibo_le (upb):
 #else
 cpdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
 #endif
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  Not bad.  But if we try to read it as a Python program, counting the lines with sharps for comments, we will see that this is not a polyglot at all.  And an invalid program in Python - right after the line with <code>def</code> comes the line with <code>cpdef</code> .  Let's think about how to disguise the Python code from Cython interpreter. <br><br>  Previous experience tells us that the <code>#ifdef debug</code> block should contain only Python code, and the <code>#else</code> block should contain only preprocessor code.  Or comments.  But how to hide the <code>#else</code> block from Python interpretation?  If we comment it out - through GPP we will not be able to uncomment it.  If we create any GPP macro that comments on this block in debug-build and decomposes it in release-build, it will be an invalid Python code, without passing GPP. <br><br>  Let's take a closer look at the junction of languages ‚Äã‚Äãand try to do something there.  A hint can be given to us by the way the unwanted Cython lines look and where they interpret the resulting code as Python functions: <br><br><table><tbody><tr><td><pre> def sum_even_fibo_le (upb):
 cpdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  ... They are right under the function signature, in the place where they should be ... docstring-i! <br><br>  Yeah.  The idea is clear.  Let's try to fix this code so that the Cython lines look like docstring (or just free strings) when interpreted by Python.  And with the interpretation of GPP - no. <br><br><table><tbody><tr><td><pre> #ifdef debug
 def sum_even_fibo_le (upb):
     "" "
 #else
 cpdef unsigned long long sum_even_fibo_le (unsigned long long upb):
     cdef unsigned long long f1, f2, res
 #endif
     "" "
     f1, f2 = 1, 2
     res = 2
     while f2 &lt;upb:
         f2, f1 = f1 + f2, f2
         if f2% 2 == 0:
             res + = f2
     return res
</pre></td></tr></tbody></table><br><br>  This is still far from working code, this is just the beginning.  But the idea is clear: from the point of view of Python (and, which is necessary - simultaneously after preprocessing GPP without <code>-Ddebug</code> ), the code in Cython will become a docstring. <br><br>  But now we have a problem: the pass by the preprocessor in the <code>-Ddebug</code> mode generates an empty docstring, and the pass by the preprocessor in the release-mode generates only the final triple of double quotes from the docstring.  Dead end. <br><br>  Something needs to be done to get rid of the triplet quotes in preprocessing, but save it without preprocessing? <br>  Or in general, so that the triplets of quotes disappear in the preprocessing mode, but remain without preprocessing?  No, of course, you can frame each triplet with your own <code>#if debug</code> , or something like that, but this is cumbersome.  Now, if it were possible to hide them in the preprocessing mode ... comment! <br><br>  And for sure.  GPP        .    , ,   C: <code>/* ... */</code> .       Python-  ¬´¬ª (, - ) Cython- ,  C-style      Cython    .  C-style ,      Python-,   Python- . <br><br><table><tbody><tr><td><pre>#!/usr/bin/python<font></font>
<font></font>
#mode comment "/*" "*/"<font></font>
<font></font>
#ifdef debug<font></font>
def sum_even_fibo_le(upb):<font></font>
#else /*<font></font>
    """ */<font></font>
cpdef unsigned long long sum_even_fibo_le(unsigned long long upb):<font></font>
    cdef unsigned long long f1, f2, res<font></font>
#endif /*<font></font>
    """ # */<font></font>
    f1, f2 = 1, 2<font></font>
    res = 2<font></font>
    while f2 &lt; upb:<font></font>
        f2, f1 = f1 + f2, f2<font></font>
        if f2 % 2 == 0:<font></font>
            res += f2<font></font>
     return res
</pre></td></tr></tbody></table><br><br>  Everything is fine.    ,  ,   .          Python-,       Cython-.  . <br><br><h1> Down to Earth </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... Well, I agree, he is not great. Hand on heart, I have to admit - he sucks. It is absolutely impossible to support him. It can only copy-paste. This confusion of punctuation marks is completely unintuitive. If we need to specify this construction for each function, the code will look like Dresden after the bombing. In a real product this should not be. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good. In the best traditions of Dr. House, the first diagnosis and the first treatment turned out to be incorrect and dangerous for the patient. We make a differential diagnosis again, based on what we already know. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to make two preprocessing branches. A branch </font></font><code>#ifdef debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should generate, without preprocessing, non-executing code when interpreting Python. Branch</font></font><code>#else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should contain just working code. It should all look quite understandable and readable, and it should be easy to use. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the variant with commenting on everything and everything and overlapping of the commenting area in different languages ‚Äã‚Äãis dismissed. It was unfit in any case - what if there was a sequence somewhere in Python </font></font><code>/*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good. What are our options? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preprocessor macros. Yes, they are. It makes it all easy. Just as we did in the very first experiment with GPP and logging. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's get a macro</font></font><code>cython()</code> ,      ,      Python-.      Cython-.   GPP       ;        Python- .  Something like this: <br><br><table><tbody><tr><td><pre>#!/usr/bin/python<font></font>
<font></font>
def cython(text):<font></font>
     pass<font></font>
#ifndef debug<font></font>
#define cython(x) x<font></font>
#endif<font></font>
<font></font>
cython("cpdef unsigned long long sum_even_fibo_le(unsigned long long upb):")<font></font>
def sum_even_fibo_le(upb):<font></font>
    cython("cdef unsigned long long f1, f2, res")<font></font>
    f1, f2 = 1, 2<font></font>
    res = 2<font></font>
    while f2 &lt; upb:<font></font>
        f2, f1 = f1 + f2, f2<font></font>
        if f2 % 2 == 0:<font></font>
            res += f2<font></font>
     return res
</pre></td></tr></tbody></table><br><br> ,      .    .       , ,  ,     : <br><br><table><tbody><tr><td><pre>#!/usr/bin/python<font></font>
<font></font>
def cython(text):<font></font>
     pass<font></font>
<font></font>
"cpdef unsigned long long sum_even_fibo_le(unsigned long long upb):"<font></font>
def sum_even_fibo_le(upb):<font></font>
    "cdef unsigned long long f1<font></font>
    f1, f2 = 1, 2<font></font>
    res = 2<font></font>
    while f2 &lt; upb:<font></font>
        f2, f1 = f1 + f2, f2<font></font>
        if f2 % 2 == 0:<font></font>
            res += f2<font></font>
     return res
</pre></td></tr></tbody></table><br><br> -,  Cython-      ,  Python-     .   ‚Äî    ,      Cython- ,         <code>#ifdef debug</code> . <br><br> -, GPP      ¬´¬ª.      <code>cython</code>       ,        ,       GPP.  ‚Ä¶ <br><br><table><tbody><tr><td><pre>#!/usr/bin/python<font></font>
<font></font>
def cython(text):<font></font>
     pass<font></font>
#ifndef debug<font></font>
#mode string QQQ "\"" "\""<font></font>
#define cython(x) x<font></font>
#endif<font></font>
<font></font>
cython("cpdef unsigned long long sum_even_fibo_le(unsigned long long upb):")<font></font>
#ifdef debug<font></font>
def sum_even_fibo_le(upb):<font></font>
#endif<font></font>
    cython("cdef unsigned long long f1, f2, res")<font></font>
    f1, f2 = 1, 2<font></font>
    res = 2<font></font>
    while f2 &lt; upb:<font></font>
        f2, f1 = f1 + f2, f2<font></font>
        if f2 % 2 == 0:<font></font>
            res += f2<font></font>
     return res
</pre></td></tr></tbody></table><br><br>     .       .  ‚Äî         <code>cython()</code> . <br><br><h1>  Total </h1><br>  ,   .    Python  Cython .  debug-  -.      Python-.  ,        all included,   : <br><br><table><tbody><tr><td><pre>#!/usr/bin/python<font></font>
<font></font>
#include debug.py<font></font>
from debug import cython, log<font></font>
<font></font>
cython("cpdef unsigned long long sum_even_fibo_le(unsigned long long upb):")<font></font>
#ifdef debug<font></font>
def sum_even_fibo_le(upb):<font></font>
#endif<font></font>
    cython("cdef unsigned long long f1, f2, res")<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    log ("Calculating sum_even_fibo_le")</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    assert upb&gt; 2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    f1, f2 = 1, 2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    res = 2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    while f2 &lt;upb:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        f2, f1 = f1 + f2, f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        if f2% 2 == 0:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            res + = f2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    log (res)    </font></font><font></font>
     return res
</pre></td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here you can live with it. </font></font></div><p>Source: <a href="https://habr.com/ru/post/63109/">https://habr.com/ru/post/63109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../63100/index.html">Logo rasterization</a></li>
<li><a href="../63101/index.html">IT-radio "PROMOTION": Podcast number 4</a></li>
<li><a href="../63106/index.html">Akiduki box will tell Twitter if you are alive</a></li>
<li><a href="../63107/index.html">Choosing an OS for a home server</a></li>
<li><a href="../63108/index.html">iPhoneDevCamp - Kiev, July 18, 2009</a></li>
<li><a href="../63110/index.html">Mini-Z construction</a></li>
<li><a href="../63112/index.html">Is SEO Good or Bad? from the user's point of view.</a></li>
<li><a href="../63114/index.html">MMS activation on iPhone 2G</a></li>
<li><a href="../63116/index.html">In 2008, Svyazinvest's daughters laundered almost 3 billion rubles. on Oracle</a></li>
<li><a href="../63118/index.html">C # -like events for PHP. Reflection, closures ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>