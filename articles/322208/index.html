<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immunitable data in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Much is said about immotable data, but it is difficult to find something about C ++ implementation. And, therefore, I decided to fill this g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immunitable data in C ++</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  Much is said about immotable data, but it is difficult to find something about C ++ implementation.  And, therefore, I decided to fill this gap in the debut article.  Moreover, the D language is, but not in C ++.  There will be a lot of code and a lot of letters. </p><br><p>  On style - utility classes and metafunctions use names in the STL and boost style, custom classes in the Qt style, which I mostly work with. </p><br><h2>  Introduction </h2><br><p>  What is immutable data?  Immunitable data is our old friend <strong>const</strong> , only more strict.  Ideally, immobility means context-independent immutability under no circumstances. </p><br><p>  Essentially, immutable data should: </p><br><ul><li>  ensure physical and logical constancy; </li><li>  prohibit the assignment of a new value at the compilation stage; <br>  All operations must be performed on the copy, not on the original. </li></ul><br><p>  Immunity data came from functional programming and found a place in parallel programming, because they guarantee the absence of side effects. </p><br><p>  How can i implement immutable data in C ++? <br>  In C ++, we have (very simplistic): </p><br><ul><li>  values ‚Äã‚Äã- objects of fundamental types, instances of classes (structures, unions), enumerations; </li><li>  pointers; <br>  links; <br>  arrays </li></ul><br><p>  Functions and <strong>void</strong> does not make sense to be immutable.  We also will not make links immutable, for this there is a <strong>const reference_wrapper</strong> . </p><br><a name="habracut"></a><br><p>  As for the rest of the types listed above, wrappers can be made for them (or rather, a non-standard protective substitute).  What will be the result?  The goal is to do something like a type modifier, retaining the natural semantics for working with objects of this type. </p><br><pre><code class="cpp hljs">Immutable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b(<span class="hljs-number"><span class="hljs-number">2</span></span>); qDebug() &lt;&lt; (a + b).value() &lt;&lt; (a + <span class="hljs-number"><span class="hljs-number">1</span></span>).value() &lt;&lt; (<span class="hljs-number"><span class="hljs-number">1</span></span> + a).value(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; Immutable&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt; arr(x); qDebug() &lt;&lt; arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br><h2>  Interface </h2><br><p>  The general interface is simple - all work is performed by the base class, which is derived from the characteristics (traits): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Immutable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> immutable::immutable_impl&lt;Type&gt;::type { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>&gt;::value, <span class="hljs-string"><span class="hljs-string">"nullptr_t cannot used for immutable"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_volatile&lt;Type&gt;::value, <span class="hljs-string"><span class="hljs-string">"volatile data cannot used for immutable"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ImplType = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> immutable::immutable_impl&lt;Type&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BaseClass = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ImplType::type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BaseClass::BaseClass; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ImplType::value_type; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Immutable&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Barring the assignment operator, we prohibit the moving assignment operator, but do not prohibit the moving constructor. </p><br><p>  immutable_impl is something like a switch, but by type (I didn‚Äôt do this - it complicates the code too much, and in the simple case it‚Äôs not really needed - IMHO). </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SrcType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">immutable_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_reference_t</span></span>&lt;SrcType&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_array&lt;Type&gt;::value, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Type&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_pointer&lt;Type&gt;::value, pointer&lt;Type&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span> &lt; is_smart_pointer&lt;Type&gt;::value, smart_pointer&lt;Type&gt;, immutable_value&lt;Type&gt; &gt; &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> type::value_type; }; }</code> </pre> <br><p>  As restrictions, explicitly prohibiting all assignment operations (macros help): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RhsType&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Immutable&lt;Type&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Op=(Immutable&lt;Type&gt; &amp;&amp;, RhsType &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Now let's consider how the individual components are implemented. </p><br><h2>  Immunity Values </h2><br><p>  Values ‚Äã‚Äã(hereinafter referred to as value) are objects of fundamental types, instances of classes (structures, unions), and enumerations.  For value, there is no class that determines whether a type is a class, structure, or union: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_class&lt;Type&gt;::value || <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_union&lt;Type&gt;::value&gt; class immutable_value;</code> </pre> <br><p>  If yes, then CRTP is used for implementation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">immutable_value</span></span></span><span class="hljs-class">&lt;Base, true&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = Base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">immutable_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Base &amp;value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base m_value; };</code> </pre> <br><p>  Unfortunately, in C ++ there is no <strong>operator</strong> overload <strong>.</strong>  .  Although it is expected in C ++ 17 ( <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0252r0.pdf">http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0252r0.pdf</a> , <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0252r0.pdf">http://open-std.org/JTC1/SC22/ WG21 / docs / papers / 2016 / p0252r0.pdf</a> , <a href="http://www.open-std.org/JTC1/SC22/wg21/docs/papers/2015/p0060r0.html">http://www.open-std.org/JTC1/SC22/wg21/docs/papers/2015/p0060r0.html</a> ), but the question is still open, because the committee found inconsistencies . <br>  Then you could just write: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>.() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); }</code> </pre> <br><p>  But a decision on this issue is expected in March, so for this purpose we are using the operator (): </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); }</code> </pre> <br><p>  Pay attention to the constructor: ~~ </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">immutable_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Base &amp;value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  both the immutable_value and the base class are initialized there.  This allows you to intelligently manipulate immutable_value through operator ().  For example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QPoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Immutable&lt;QPoint&gt; test(point); test().setX(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     qDebug() &lt;&lt; test().isNull() &lt;&lt; test().x() &lt;&lt; test().y();</span></span></code> </pre> <br><p>  If the type is built-in, the implementation will be one-to-one, with the exception of the base class ( <del>   </del>  to return to comply with DRY, but somehow I didn‚Äôt want to complicate things, especially since immutable_value was done after the rest ...): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">immutable_value</span></span></span><span class="hljs-class">&lt;Type, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = Type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">immutable_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value(); } <span class="hljs-comment"><span class="hljs-comment">// Base operator . () const // { // return value(); // } constexpr Type value() const { return m_value; } private: const Type m_value; };</span></span></code> </pre> <br><h2>  Immunable Arrays </h2><br><p>  So far, it seems to be simple and uninteresting, but now let's take up the arrays.  It is necessary to do something like std :: array while retaining the natural semantics of working with an array, including working with STL (which can weaken immunity). </p><br><p>  The peculiarity of relization is that when the index is addressed to a multidimensional, an array of a lower dimension is returned, also immutable.  The array type is recursively instantiated: see operator [], and specific types for iterators, etc. are inferred using array_traits. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ArrayType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_traits</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array</span></span></span><span class="hljs-class">&lt;Tp[Size]&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Tp* pointer_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tp* const_pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> array_type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Tp[Size]; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> array_traits&lt;array_type&gt;::value_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> size_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> array_traits&lt;array_type&gt;::size_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> iterator = array_iterator&lt;array_type&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_iterator = array_iterator&lt;array_type&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> const_reverse_iterator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::reverse_iterator&lt;const_iterator&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array_type &amp;&amp;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;array_type&gt;(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array_type &amp;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ } ~<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size() == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> const_pointer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data(); } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> value_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](size_type n) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value_type(m_array[n]); } <span class="hljs-comment"><span class="hljs-comment">//       constexpr value_type at(size_type n) const { return n &lt; Size ? operator [](n) : out_of_range(); } const_iterator begin() const noexcept { return const_iterator(m_array.get()); } const_iterator end() const noexcept { return const_iterator(m_array.get() + Size); } const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); } const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); } const_iterator cbegin() const noexcept { return const_iterator(data()); } const_iterator cend() const noexcept { return const_iterator(data() + Size); } const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(end()); } const_reverse_iterator crend() const noexcept { return const_reverse_iterator(begin()); } constexpr value_type front() const noexcept { return *begin(); } constexpr value_type back() const noexcept { return *(end() - 1); } private: constexpr pointer_type data() const noexcept { return m_array.get(); } [[noreturn]] constexpr value_type out_of_range() const { throw std::out_of_range("array: out of range");} private: const std::reference_wrapper&lt;array_type&gt; m_array; }; }</span></span></code> </pre> <br><p>  To determine the type of a smaller dimension, the class of characteristics is used: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ArrayType, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_traits</span></span></span><span class="hljs-class">&lt;ArrayType[Size]&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::rank&lt;ArrayType[Size]&gt;::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, ArrayType, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;ArrayType&gt; <span class="hljs-comment"><span class="hljs-comment">// immutable::array &gt;; using size_type = std::size_t; }; }</span></span></code> </pre> <br><p>  which for multidimensional arrays for indexing returns an immutable array of lower dimension. </p><br><p>  Comparison operators are very simple: </p><br><div class="spoiler">  <b class="spoiler_title">Comparison operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; one, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; two) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::equal(one.begin(), one.end(), two.begin()); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; one, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; two) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(one == two); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end()); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; one, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; two) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> two &lt; one; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; one, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; two) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(one &gt; two); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Size&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; one, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Tp[Size]&gt;&amp; two) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(one &lt; two); }</code> </pre> </div></div><br><h3>  Immunate Iterator </h3><br><p>  To work with an immutable array, an imimiable iterator array_iterator is used: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Array&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_iterator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bidirectional_iterator_tag, Array&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> element_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_extent_t</span></span>&lt;Array&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::rank&lt;Array&gt;::value == <span class="hljs-number"><span class="hljs-number">1</span></span>, element_type, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;element_type&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ptr_to_array_type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element_type *; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_array&lt;Array&gt;::value, <span class="hljs-string"><span class="hljs-string">"Substitution error: template argument must be array"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr_to_array_type ptr)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> value_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> *() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value_type(*m_ptr);} <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> array_iterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { ++m_ptr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> array_iterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--() { --m_ptr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array_iterator &amp;other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_ptr == other.m_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ptr_to_array_type m_ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Array&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> array_iterator&lt;Array&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(array_iterator&lt;Array&gt; &amp;it, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = it; ++it; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Array&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> array_iterator&lt;Array&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(array_iterator&lt;Array&gt; &amp;it, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = it; --it; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Array&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> != (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array_iterator&lt;Array&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array_iterator&lt;Array&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } }      ,     .  ,  - :</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sample code with an immutable array</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[<span class="hljs-number"><span class="hljs-number">5</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y[<span class="hljs-number"><span class="hljs-number">5</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; immutable::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt; a(x); immutable::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(y)&gt; b(y); qDebug() &lt;&lt; (a == b); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[] = <span class="hljs-string"><span class="hljs-string">"abcdef"</span></span>; immutable::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(str)&gt; imstr(str); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = imstr.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*it) qDebug() &lt;&lt; *it++;</code> </pre> </div></div><br><p>  For multidimensional arrays, all the same: </p><br><div class="spoiler">  <b class="spoiler_title">Example with a multidimensional, immutable array</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> } }; immutable::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(y)&gt; b(y); immutable::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(z)&gt; c(z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = b.begin(); row != b.end(); ++row) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"(*row)[0]"</span></span> &lt;&lt; (*row)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; ++j) qDebug() &lt;&lt; b[i][j]; qDebug() &lt;&lt; (b == c); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> row = b.begin(); row != b.end(); ++row) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> col = (*row).begin(); col != (*row).end(); ++col) qDebug() &lt;&lt; *col; }</code> </pre> </div></div><br><h2>  Immunable Pointers </h2><br><p>  Let's try to slightly protect the pointers.  In this section, we will look at regular pointers (raw pointers), and then (much further) we will look at smart pointers.  SFINAE will be used for smart pointers. </p><br><p>  By implementing immutable :: pointer, I‚Äôll say right away that pointer does not delete data, does not count references, but only ensures the immutability of the object.  (If the passed pointer is changed or deleted from outside, then this is a breach of contract that cannot be tracked by means of the language (by standard means)).  In the end, it is impossible to defend against deliberate sabotage or playing with addresses.  The pointer must be correctly initialized. </p><br><p>  The immutable :: pointer can work with pointers to pointers of any degree of reference (let's say). </p><br><p>  For example: </p><br><div class="spoiler">  <b class="spoiler_title">An example of working with immutable index</b> <div class="spoiler_text"><pre> <code class="cpp hljs">immutable::pointer&lt;QApplication*&gt; app(&amp;a); app-&gt;quit(); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-string"><span class="hljs-string">'A'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *pc = &amp;c; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **ppc = &amp;pc; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ***pppc = &amp;ppc; immutable::pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>***&gt; x(pppc); qDebug() &lt;&lt; ***x;</code> </pre> </div></div><br><p>  In addition to the above, immutable :: pointer does not support working with C-style strings: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cstr = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; immutable::pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(str)&gt; p(cstr); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*p++) qDebug() &lt;&lt; *p;</code> </pre> <br><p>  This code will not work as expected, because  immutable :: pointer with increment returns the new immutable :: pointer with a different address, and in the conditional expression the result of the increment will be checked, i.e.  the value of the second character of the string. </p><br><p>  Let's return to the implementation.  The pointer class provides a generic interface and, depending on what Tp is (pointer to pointer or proto pointer), uses a specific implementation of pointer_impl. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_pointer&lt;Tp&gt;::value, <span class="hljs-string"><span class="hljs-string">"Tp must be pointer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_volatile&lt;Tp&gt;::value, <span class="hljs-string"><span class="hljs-string">"Tp must be nonvolatile pointer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_void&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;Tp&gt;&gt;::value, <span class="hljs-string"><span class="hljs-string">"Tp can't be void pointer"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Tp source_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pointer_impl&lt;Tp&gt; pointer_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> pointer_type::value_type value_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tp ptr)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nullptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    0 ~pointer() = default; constexpr const pointer_type value() const { return m_ptr; } /** * @brief operator =  , . const *const  *  . *   ,     , *        , *    " = delete"   ,   *     */ pointer&amp; operator=(const pointer&amp;) = delete; constexpr /*immutable&lt;value_type&gt;*/ value_type operator*() const { return *value(); } constexpr const pointer_type operator-&gt;() const { return value(); } //   template &lt;typename T&gt; constexpr operator T() = delete; template &lt;typename T&gt; constexpr operator T() const = delete; /** * @brief operator []   ,     *  . * *  - -   *         * (  ) * @return */ template &lt;typename Ret = std::remove_pointer_t&lt;Tp&gt;, typename IndexType = ssize_t&gt; constexpr Ret operator[](IndexType) const = delete; constexpr bool operator == (const pointer &amp;other) const { return value() == other.value(); } constexpr bool operator &lt; (const pointer &amp;other) const { return value() &lt; other.value(); } private: const pointer_type m_ptr; };</span></span></code> </pre> <br><p>  The essence is as follows: there was a type T <em>, and for its storage / presentation, a pointer_impl &lt;T</em> , true&gt; <em>implementation is used (template-recursive)</em> , which can be represented as follows: </p><br><pre> <code class="cpp hljs">pointer_impl&lt;T***, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt;{ pointer_impl&lt;T**, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt; { pointer_impl&lt;T*, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> } } }</code> </pre> <br><p>  Total, it turns out: const T <em>const</em> const * const. </p><br><p>  For a simple pointer (which does not point to another pointer), the implementation is as follows: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointer_impl</span></span></span><span class="hljs-class">&lt;Type, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;Type&gt; source_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> source_type *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pointer_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> source_type value_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointer_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> value_type <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_value; <span class="hljs-comment"><span class="hljs-comment">// *    } constexpr bool operator == (const pointer_impl &amp;other) const noexcept { return m_value == other; } constexpr bool operator &lt; (const pointer_impl &amp;other) const noexcept { return m_value &lt; other; } constexpr const pointer_type operator-&gt;() const noexcept { using class_type = std::remove_pointer_t&lt;pointer_type&gt;; static_assert(std::is_class&lt;class_type&gt;::value || std::is_union&lt;class_type&gt;::value , "-&gt; used only for class, union or struct"); return m_value; } private: const pointer_type m_value; };</span></span></code> </pre><br><p>  For nested pointers (pointers to pointers): </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointer_impl</span></span></span><span class="hljs-class">&lt;Type, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;Type&gt; source_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pointer_impl&lt;source_type&gt; pointer_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pointer_impl&lt;source_type&gt; value_type; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-comment"><span class="hljs-comment">/* implicit */</span></span> pointer_impl(Type value) : m_value(*value) { <span class="hljs-comment"><span class="hljs-comment">// /\ remove pointer } constexpr bool operator == (const pointer_impl &amp;other) const { return m_value == other; //   } constexpr bool operator &lt; (const pointer_impl &amp;other) const { return m_value &lt; other; //   } constexpr value_type operator*() const { return value_type(m_value); //   } constexpr const pointer_type operator-&gt;() const { return m_value; } private: const pointer_type m_value; };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">What not to do!</b> <div class="spoiler_text"><p>  For the following types of pointers special meaning should not be done specialization: </p><br><ul><li>  pointer to array (*) []; </li><li>  pointer to the function (*) (Args ... [...]); </li><li>  a pointer to a class variable, Class :: a <em>very specific thing, is needed when "witchcraft" with the class, you need to associate with the object;</em> <em><br></em>  <em>pointer to a class method (Class ::)</em> (Args ... [...]) [const] [volatile]. </li></ul></div></div><br><h2>  Immunable smart pointers </h2><br><p>  How to determine what is in front of us smart pointer?  Smart pointers are implemented by operators * and -&gt;.  To determine their presence, we will use SFINAE (we will consider the implementation of SFINAE later): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-comment"><span class="hljs-comment">// is_base_of&lt;_Class, _Tp&gt; template &lt;typename Tp&gt; class is_smart_pointer { DECLARE_SFINAE_TESTER(unref, T, t, t.operator*()); DECLARE_SFINAE_TESTER(raw, T, t, t.operator-&gt;()); public: static const bool value = std::is_class&lt;Tp&gt;::value &amp;&amp; GET_SFINAE_RESULT(unref, Tp) &amp;&amp; GET_SFINAE_RESULT(raw, Tp); }; }</span></span></code> </pre> <br><p>  I will say right away that through operator -&gt;, alas, using indirect recourse, it is possible to break the immunity, especially if there is mutable data in the class.  In addition, the constancy of the return value can be removed, both by the compiler (at type deduction) and by the user. </p><br><p>  Implementation - everything is simple here: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> immutable { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">smart_pointer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smart_pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type &amp;&amp;ptr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;Type&gt;(ptr))</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smart_pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type &amp;ptr)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = value().<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutable::pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(res)&gt;(res);<span class="hljs-comment"><span class="hljs-comment">// in C++17 immutable::pointer(res); } constexpr const auto operator*() const { return value().operator*(); } constexpr const Type value() const { return m_value; } private: const Type m_value; }; }</span></span></code> </pre> <br><h2>  SFINAE </h2><br><p>  What it is and what it is eaten with is no need to explain.  Using SFINAE, you can determine the presence of methods in the class, member types, etc., even the presence of overloaded functions (if you specify a call to the desired function with the necessary parameters in the testexpr expression).  arg may be empty and not participate in testexpr.  It uses SFINAE with types and SFINAE with expressions: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECLARE_SFINAE_BASE(Name, ArgType, arg, testexpr) \ typedef char SuccessType; \ typedef struct { SuccessType a[2]; } FailureType; \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename ArgType&gt; \ static decltype(auto) test(ArgType &amp;&amp;arg) \ -&gt; decltype(testexpr, SuccessType()); \ static FailureType test(...); #define DECLARE_SFINAE_TESTER(Name, ArgType, arg, testexpr) \ struct Name { \ DECLARE_SFINAE_BASE(Name, ArgType, arg, testexpr) \ }; #define GET_SFINAE_RESULT(Name, Type) (sizeof(Name::test(std::declval&lt;Type&gt;())) == \ sizeof(typename Name::SuccessType))</span></span></span></span></code> </pre> <br><p>  And another thing: overloading can be resolved (find the desired overloaded function) if the signatures match, but differ in the const [volatile] or volatile qualifier together with SFINAE in three phases: </p><br><p>  1) SFINAE - if yes, then OK <br>  2) SFINAE + QNonConstOverload, if not, then <br>  3) SFINAE + QConstOverload </p><br><p>  In the Qt source you can find an interesting and useful thing: </p><br><div class="spoiler">  <b class="spoiler_title">Overload resolution with const</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QNonConstOverload</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (T::*ptr)(Args...))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (T::*ptr)(Args...))</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QConstOverload</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (T::*ptr)(Args...) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (T::*ptr)(Args...) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QOverload</span></span></span><span class="hljs-class"> :</span></span> QConstOverload&lt;Args...&gt;, QNonConstOverload&lt;Args...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> QConstOverload&lt;Args...&gt;::of; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> QConstOverload&lt;Args...&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> QNonConstOverload&lt;Args...&gt;::of; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> QNonConstOverload&lt;Args...&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-function"><span class="hljs-function">Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (*ptr)(Args...))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Q_DECL_CONSTEXPR </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (*ptr)(Args...))</span></span></span><span class="hljs-function"> Q_DECL_NOTHROW -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; } };</code> </pre> </div></div><br><h2>  Total </h2><br><p>  Let's try what happened: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QPoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Immutable&lt;QPoint&gt; test(point); test().setX(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     qDebug() &lt;&lt; test().isNull() &lt;&lt; test().x() &lt;&lt; test().y(); int x[] = { 1, 2, 3, 4, 5 }; Immutable&lt;decltype(x)&gt; arr(x); qDebug() &lt;&lt; arr[0];</span></span></code> </pre> <br><h3>  Operators </h3><br><p>  Let's remember about the operators!  For example, add support for the addition operator: <br>  First, we implement the addition operator of the form <code>Immutable&lt;Type&gt;</code> + Type: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Immutable&lt;Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, Type &amp;&amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Immutable&lt;Type&gt;(a.value() + b); }</code> </pre> <br><p>  In C ++ 17 instead of </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Immutable&lt;Type&gt;(a.value() + b);</code> </pre> <br><p>  can write </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Immutable(a.value() + b);</code> </pre> <br><p>  Since  operator + is commutative, then Type + <code>Immutable&lt;Type&gt;</code> can be implemented in the form: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Immutable&lt;Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Type &amp;&amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Type&gt;(a); }</code> </pre> <br><p>  And again, through the first form, we implement <code>Immutable&lt;Type&gt;</code> + <code>Immutable&lt;Type&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Immutable&lt;Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b.value(); }</code> </pre> <br><p>  Now we can work: </p><br><pre> <code class="cpp hljs">Immutable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a(<span class="hljs-number"><span class="hljs-number">1</span></span>), b(<span class="hljs-number"><span class="hljs-number">2</span></span>); qDebug() &lt;&lt; (a + b).value() &lt;&lt; (a + <span class="hljs-number"><span class="hljs-number">1</span></span>).value() &lt;&lt; (<span class="hljs-number"><span class="hljs-number">1</span></span> + a).value();</code> </pre> <br><p>  Similarly, you can define the remaining operations.  That's just not necessary to overload the operators receiving the address, &amp;&amp;, ||!  Unary +, -,!, ~ Can be useful ... These operations are inherited: (), [], -&gt;, -&gt; <em>,</em> (unary). </p><br><p>  Comparison operators must return values ‚Äã‚Äãof Boolean type: </p><br><div class="spoiler">  <b class="spoiler_title">Comparison operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value() == b.value(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value() &gt; b.value(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b &lt; a; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a &lt; b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Immutable&lt;Type&gt; &amp;b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(b &lt; a); }</code> </pre> </div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322208/">https://habr.com/ru/post/322208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322196/index.html">IBM gives access to the main component of Watson</a></li>
<li><a href="../322198/index.html">Bugs from the USSR</a></li>
<li><a href="../322200/index.html">Go global strategies for startups</a></li>
<li><a href="../322202/index.html">WCF REST services and UWP applications</a></li>
<li><a href="../322206/index.html">61 ways to improve your site's SEO</a></li>
<li><a href="../322212/index.html">Dagaz: Architecture</a></li>
<li><a href="../322214/index.html">Development of transactional microservices using Aggregates, Event Sourcing and CQRS (Part 2)</a></li>
<li><a href="../322216/index.html">How to develop a cross-platform application using only JSON markup</a></li>
<li><a href="../322218/index.html">How to tame autotests</a></li>
<li><a href="../322220/index.html">Is it safe to use the absolute path in * nix systems, as we used to think?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>