<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explore and test queues from Hazelcast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of us have heard of the Hazelcast . This is a convenient product that implements various distributed objects. In particular: storage key-values, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explore and test queues from Hazelcast</h1><div class="post__text post__text-html js-mediator-article"> Many of us have heard of the <a href="http://hazelcast.com/">Hazelcast</a> .  This is a convenient product that implements various distributed objects.  In particular: storage key-values, queues, locks, etc.  As a whole, assertions on distribution, scalability, resiliency and other positive properties are applied to it. <br><br>  Is this true for its implementation of queues?  Where are the limits of their use?  This is what we will try to find out. <br><a name="habracut"></a><br><br>  All tests are available on <a href="https://github.com/romario13/hz-queue">GitHub</a> .  At all, the JVM memory limit was set to 64mb to speed up the achievement of the goal, memory dump during its overflow (OOM) and forced kill the application in case of this trouble 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>-Xms64m -Xmx64m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp -XX:OnOutOfMemoryError="kill -9 %p"</code> <br> <br>  And so, let's go.  The latest stable version of hazelcast is used - 3.2.3. <br>  (The tests provide approximate data on the measurement of speed and quantity. The configuration of the test machine is not published. The data are sufficient to compare the tests with each other, which is the goal) <br><br><h5>  Test 1 - memory is not infinite </h5><br><br>  In the first test, we will use one hazelcast node.  Create a queue and add items there until we fall from a lack of memory. <br><br>  The result is expected.  It was possible to record 460 thousand objects at a speed of 0.026ms per item.  These data will be useful to us further for comparison. <br><br>  We study memory dump: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aaa/c19/b7f/aaac19b7f1094951072101d60d75e825.png" alt="image"><br><br>  We see a large number of objects QueueItem.  This internal object is created for each queue item.  Contains the unique identifier of the element and the data itself (Data object) <br><br><h5>  Test 2 - connect storage </h5><br><br>  In order not to store data in memory and thereby free it, we can connect storage to the queue.  For the test, we prepared MockQueueStore, which does nothing, but regularly depicts the repository, losing all the elements sent to it.  We specify the parameter "memory-limit = 0" in order to completely eliminate the storage of data in memory (by default, 1000 items are stored). <br><br>  Our expectations are in getting rid of OOM, but it was not there.  We managed to write more objects - 980k, but we still fell. <br><br>  We look memory dump: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37a/db5/ba9/37adb5ba959e28412716cb09cc6e068a.png" alt="image"><br><br>  It can be seen that there are no Data objects, but the QueueItem is still in memory.  This is our first discovery.  The implementation of a hazelcast queue (QueueContainer) does not dispose of an auxiliary object if there is a repository.  She always keeps them in the internal queue (LinkedList). <br><br>  This circumstance will not allow the use of queues where potentially their uncontrolled growth in volumes exceeding the availability of free memory is potentially possible.  It does not put a cross, by no means.  At 50 megabytes, there are about a million items.  Not all tasks are possible, so many, and more memory will be in reality.  But remember this restriction is necessary.  Go ahead. <br><br><h5>  Test 3 - a spy feature with transactions </h5><br><br>  Reading the source code, another feature or bug was discovered.  Hazelcast allows us to manipulate our distributed objects in a transaction.  Let's see what happens if we add transactions to the third test while adding items. <br><br>  We get OOM on approximately 250k queue items.  We look at the dump: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/212/009/c6c/212009c6cdd11fc4a59a133ae0cd35e5.png" alt="image"><br><br>  We see that there is data storage in memory (Data), although we have a storage connected.  And instead of QueueItem objects, TxQueueItem is used.  This is all a consequence of the implementation.  When using transactions, data is not reset to the repository.  And since the TxQueueItem object is a QueueItem descendant with additional fields that consumes more memory, we got even fewer items to OMM than in the first test. <br><br>  Conclusion - transactions and storage for queues do not work together. <br><br>  Let's move on.  Let's see how queues work in a cluster. <br><br><h5>  Test 4 - just two nodes </h5><br><br>  We do not use any additional queue settings.  All by default.  Without storage.  We put and read 100k elements.  We put and read in the node owning the queue.  The latter is sometimes important for data access speeds.  The fact is that unlike Map, the implementation of queues is not distributed.  All elements of the queue live on one of the cluster nodes - the owner of the queue.  More specifically, the owner of the partition to which the queue belongs.  We expect that access will be fast - like without a cluster, as we interact with the owner. <br><br>  As a result, we have the following speed: <br> <code>INFO: add 100000 0.255ms <br></code> <br> <code>INFO: poll 100000 0.223ms</code> <br> <br>  The speed dropped by an order of magnitude (compared to 0.026ms in the first test).  The fact is that the default for the queue is one backup.  And hazelcast when adding and reading synchronized data with the second node. <br><br><h5>  Test 4_1 - we try to work not with the owner </h5><br><br>  Is there a difference in speed if you add to the queue and read not from the owner of the partition? <br><br>  It turns out there is no significant difference: <br> <code>INFO: add 100000 0.215ms</code> <br> <code>INFO: poll 100000 0.201ms</code> <br> <br>  See comparable speed.  Like in test 4, both nodes perform a similar set of operations and the result does not change from changing places of the components.  The actual work goes with the owner of the queue through an intermediary containing a backup. <br><br><h5>  Test 5 - kill the owner </h5><br><br>  Let's try after filling the queue to kill the node that owns the queue.  And read the data from the remaining node.  We get the following result: <br><br> <code>INFO: add 100000 0.267ms</code> <br> <code>INFO: poll 100000 0.025ms</code> <br> <br>  One remaining node begins to work much faster.  He remains alone in the cluster and does not spend resources on communications to create backup. <br><br><h5>  Test 6 - turn off backup </h5><br><br>  Let's see what happens if you disable backup in the queue configuration and, as in the previous test, remove the owner. <br><br> <code>INFO: add 100000 0.022ms</code> <br> <br>  The result is a high speed of work with the owner of the queue.  He does not spend resources on a backup.  But after his fall - the whole line is lost. <br><br><h5>  Test 7 - connect the storage to the cluster </h5><br><br>  We don‚Äôt have a backup, and quite rightly we lost all the data after the destruction of the node - the queue owner.  Let's connect the storage to this configuration and see if the data will survive?  We'll store the storage a bit smarter so that it stores and gives data from the memory (MemoryQueueStore). <br><br>  Result: <br><br> <code>INFO: add 100000 0.023ms</code> <br> <code>INFO: poll 100000 0.018ms</code> <br> <br>  We see that the speed is good everywhere - an order of magnitude higher than with backup.  We also see that the queue has recovered on the remaining node. <br><br>  Some details about restoring the queue on the second node.  In this process, all keys from the storage are first read into memory by the implementation of the QueueContainer and the largest value is determined from them for further generation of new ones.  An internal queue on LinkedList is filled at once with all elements of the queue, but without data.  In order to preserve the order of the elements in the queue after recovery from the storage, the storage must issue them in the correct order in the set (Set).  Further, if necessary, load data from the repository.  Loading comes packs.  The default is 250 pieces. <br><br><h5>  Some conclusions </h5><br><br><ul><li>  Using storage does not completely free memory.  It is necessary to predict the amount of data and not get on OOM </li><li>  When using storage, it is necessary to forcibly disable backup.  By default it is enabled and will affect the speed and used memory of other nodes. </li><li>  The implementation of queue recovery from storage is resource-intensive and not optimal.  When restoring a new owner must have no less memory than the previous one. </li><li>  When using transactions not used storage for queues </li></ul><br><br>  And of course the main conclusion is that we must continue to test products before using them for critical tasks. <br><br>  PS: The way to fix the QueueContainer implementation is outside the scope of this document.  I hope there will be time and energy with this too. </div><p>Source: <a href="https://habr.com/ru/post/228445/">https://habr.com/ru/post/228445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228429/index.html">Popularization of technical creativity in China</a></li>
<li><a href="../228431/index.html">How to build a spacecraft without leaving the office</a></li>
<li><a href="../228433/index.html">Computing Graphs, Speculative Locks and Arenas for Tasks at Intel¬Æ Threading Building Blocks</a></li>
<li><a href="../228435/index.html">Spiral Ulam, the area of ‚Äã‚Äãthe prohibition of primes</a></li>
<li><a href="../228437/index.html">Promotional Wars: Search Engines vs. Internet Providers</a></li>
<li><a href="../228447/index.html">Visualization of transatlantic flights in 24 hours</a></li>
<li><a href="../228449/index.html">The smartphone can read the password from the screen from the reflection in your eyes, as well as fingerprints</a></li>
<li><a href="../228451/index.html">The bot for the news feed went to work</a></li>
<li><a href="../228453/index.html">Microsoft, by a court decision, took over the management of the domains of the popular No-IP DDNS service, but was unable to maintain it in working condition.</a></li>
<li><a href="../228455/index.html">Some benchmark performance of network frameworks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>