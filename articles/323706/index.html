<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tips for a novice rocker</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. Functional 


 This article (to be completely honest - a set of notes) is devoted to errors that beginners make when stepping on the path of S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tips for a novice rocker</h1><div class="post__text post__text-html js-mediator-article"><p>  <strong>Part 1. Functional</strong> </p><br><p>  This article (to be completely honest - a set of notes) is devoted to errors that beginners make when stepping on the path of Scala: not only juniors, but also experienced programmers with gray hair in a beard.  Many of them have always worked before only with imperative languages ‚Äã‚Äãsuch as C, C ++ or Java, so the Scala idioms for them are incomprehensible and, moreover, not obvious.  Therefore, I took the liberty of cautioning converts and telling them about their typical mistakes, both completely innocent and those in the Scala world punishable by death. </p><a name="habracut"></a><br><p>  <strong>Publication structure:</strong> </p><br><ul><li>  <a href="https://habr.com/ru/post/323706/">Part 1. Functional</a> </li><li>  <a href="https://habrahabr.ru/post/330816">Part 2. About everything and about anything</a> </li></ul><br><h2 id="vmesto-vstupleniya">  Instead of intro </h2><br><p>  At the very beginning of my career, I found myself in a very interesting situation: I, then still a very young developer, had to explain the fanciful idioms to my senior colleagues.  It so happened - and I am grateful to life for this largely invaluable experience.  Now I help in developing Scala to developers of all levels, from young to old, because in the company where I work, there is an internal system of employee training.  At the moment, I, together with other mentors, are engaged in checking and supporting Scala courses. </p><br><blockquote>  It was originally planned to write this article in English under the sonorous title: ‚ÄúScala for juniors and junior seniors‚Äù.  But working with the Russian text turned out to be much faster and more convenient, so I had to sacrifice an untranslatable pun in the title.  Just keep in mind that the article is designed not only for pure junior programs, but also for everyone who starts their acquaintance with the Scala language, no matter how much experience they have with imperative programming. </blockquote><p>  This article, by and large, is a hodgepodge of practical advice, in view of which it is devoid of any complex multi-level academic structure of the presentation of the material.  Instead, the article is divided into two parts: in the first we will talk about functional programming idioms in Scala, and in the second we will discuss object-oriented idioms.  And we start with the most undervalued possibility of Scala - type aliases (type aliases). </p><br><h3 id="o-psevdonimah-tipov">  About type aliases </h3><br><p> For many novice developers who have never had experience with <code>typedef</code> , this language feature will seem useless.  However, this is not quite the case: in C, type aliases are used by the standard library at every step and are one of the means of ensuring code portability between platforms;  in addition, they markedly improve the readability of code in which pointers of a large degree of indirection are implicated.  An example known to all - the canonical declaration of the <code>signal</code> function is completely unreadable: </p><br><pre> <code class="hljs lisp"> void (<span class="hljs-name"><span class="hljs-name">*signal</span></span>(<span class="hljs-name"><span class="hljs-name">int</span></span> sig, void (<span class="hljs-name"><span class="hljs-name">*func</span></span>)(<span class="hljs-name"><span class="hljs-name">int</span></span>)))(<span class="hljs-name"><span class="hljs-name">int</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  However, adding an alias for pointers to a signal handler function solves this problem: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sighandler_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">sighandler_t</span></span> signal(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signum, <span class="hljs-keyword"><span class="hljs-keyword">sighandler_t</span></span> handler);</code> </pre> <br><p>  In C ++, without type aliases, static metaprogramming is unthinkable; in addition, they make it possible not to go crazy with the full names of template types. </p><br><p>  In languages ‚Äã‚Äãsuch as Ocaml and Haskell, there is the keyword <code>type</code> , the semantics of which is much more complicated than in Scala.  For example, the <code>type</code> keyword allows you to create not only <a href="https://wiki.haskell.org/Type_synonym">synonyms of types</a> , but also <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> : </p><br><pre> <code class="hljs scala">(*   <span class="hljs-type"><span class="hljs-type">Ocaml</span></span>*) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">suit</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Club</span></span> | <span class="hljs-type"><span class="hljs-type">Diamond</span></span> | <span class="hljs-type"><span class="hljs-type">Heart</span></span> | <span class="hljs-type"><span class="hljs-type">Spade</span></span>;;</code> </pre> <br><p>  And this is not limited to this: in Ocaml and SML you can also create <br>  union types (union types): </p><br><pre> <code class="hljs vhdl">(* OCaml *) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> intorstring = Int <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> int | <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>;; (* SML *) datatype intorreal = INT <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> int | REAL <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> real</code> </pre> <br><p>  At the moment (Scala 2.12) it does not know how: the functionality declared with the help of the <code>type</code> keyword is limited to <code>type</code> synonyms, as well as the declaration of path-dependent types.  However, in future versions this feature is planned to be added (thanks to <a href="https://habrahabr.ru/users/senia/" class="user_link">senia</a> for the <a href="https://habrahabr.ru/post/323706/">clarification</a> ).  Why is it generally worth giving other types to already known types?  First, it adds an additional semantic load, and, for example, the meaning of a <code>DateString</code> type becomes clearer than just a <code>String</code> , and the <code>Map[Username, Key]</code> looks better than a <code>Map[String, String]</code> .  Secondly, synonymization allows you to reduce large and complex type signatures: The <code>Map[Username, Key]</code> looks good, but <code>Keystore</code> much shorter and clearer. </p><br><p>  Of course, synonym types have their drawbacks: You see the type of <code>Person</code> , and you cannot understand whether it is an object, a class, or an alias. </p><br><p>  You should definitely not abuse this tool, but there are a number of situations where they will actually be helpful: </p><br><ul><li>  You have a function that can be associated with a specific action, which you can easily name and not frighten the reader with signatures like <code>() =&gt; Unit</code> , associating this type of function with the name <code>Action</code> . </li><li>  you are abstracting the <code>[, []]</code> </li><li>  you add additional semantic information to an existing type </li></ul><br><p>  You can find more examples <a href="http://www.scala-lang.org/files/archive/spec/2.12/04-basic-declarations-and-definitions.html">here</a> , just squander a bit below to the section with examples. </p><br><h3 id="esche-raz-o-prisvaivanii">  Once again about assignment </h3><br><p>  Scala assignment is not exactly what you are used to.  Let's look at this operation and see that it is not as simple as it may seem at first glance: </p><br><pre> <code class="hljs vhdl">//    ,     scala&gt; val address = (<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>) address: (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Int) = (localhost,<span class="hljs-number"><span class="hljs-number">80</span></span>) scala&gt; val (host, <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>) = address host: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = localhost <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>: Int = <span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  We have just decomposed a tuple into two variables, but the process is not limited to tuples: </p><br><pre> <code class="hljs php">scala&gt; val first::rest = <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) first: Int = <span class="hljs-number"><span class="hljs-number">1</span></span> rest: <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>[Int] = <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><p>  We can perform similar operations with the <code>case class</code> : </p><br><pre> <code class="hljs kotlin">case <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(name: String, age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> max = Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-comment"><span class="hljs-comment">// max: Person = Person(Max,36) val Person(n, a) = max // n: String = Max // a: Int = 36</span></span></code> </pre> <br><p>  Moreover: </p><br><pre> <code class="hljs swift">scala&gt; val p @ <span class="hljs-type"><span class="hljs-type">Person</span></span>(n, a) = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> <span class="hljs-comment"><span class="hljs-comment">// p: Person = Person(Max,36) // n: String = Max // a: Int = 36</span></span></code> </pre> <br><p>  In the latter case, by the name of <code>p</code> we will get the record of the <code>case class</code> , and by the name of <code>n</code> we will get the name, by <code>a</code> - the age. </p><br><p>  The sophisticated reader has already noticed that assignment behaves exactly the same way as pattern matching.  Similar functionality is implemented in other languages, for example, Python and Erlang.  Use this functionality primarily to decompress data structures.  But do not abuse: unpacking of complex data structures greatly affects readability. </p><br><h3 id="options">  Options </h3><br><p>  Many of you are already familiar with the <code>Optional</code> type in Java 8. In Scala, the <code>Option</code> type performs the same functions.  And to many Java adepts this type may be known from the Guava library in Google. </p><br><p>  Yes, <code>Optional</code> used to avoid <code>null</code> , and later <code>NullPointerException</code> .  Yes, it has methods <code>isEmpty</code> and <code>nonEmpty</code> .  In the Guava version there is an <code>isPresent</code> method.  And many who used or did not use <code>Optional</code> in Java or other languages, incorrectly use it in Scala. </p><br><blockquote>  However, not everyone is aware that in the same Guava, the <code>Optional</code> define a <code>transform</code> method that behaves similarly to a skalovsky <code>map</code> . </blockquote><p>  <code>Option</code> misuse is a common problem.  <code>Option</code> , <strong>first of all</strong> , is needed to <strong>conceptually</strong> show the likely missing entity, and not to run away from NPE.  Yes, there is a problem, and the problem is serious.  Someone even invents his own language for this.  But let's go back to the misuse of <code>Option</code> in Scala: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.isEmpty) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //   c NoSuchElementException ( ) <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span></code> </pre> <br><p>  We do a check, and we, like, nothing should explode.  Believe me, you can make a mistake in the industrial code, and the condition may turn out to be quite the expression that was expected.  And even tests can be written incorrectly.  Not you, so your predecessors. </p><br><blockquote>  In general, in the example above there is another problem.  Your flow depends on some Boolean, and its integrity is broken. </blockquote><p>  Some developers have the ability to customize tests for already "working" code.  Correct and <strong>shorter the</strong> above code can be written as: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">option</span></span> getOrElse <span class="hljs-keyword"><span class="hljs-keyword">default</span></span></code> </pre> <br><p>  The more compact your code is, the easier it is to find an error in it, and the more difficult this error is to make.  There is a useful <code>orElse</code> method that allows you to concatenate various <code>Option</code> . </p><br><p>  Often you need to transform the value inside Option, if it exists at all.  For this, there is a <code>map</code> method: it takes out a value, converts it, and packs it back into a container. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> messageOpt = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updMessageOpt = messageOpt.map(msg =&gt; <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$mgs</span></span></span><span class="hljs-string"> cruel world!"</span></span>) updMessageOpt: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><p>  And sometimes it happens like this: </p><br><pre> <code class="hljs lisp">val messageOptOpt = Some(<span class="hljs-name"><span class="hljs-name">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>))</code> </pre> <br><p>  <code>Option</code> can be immensely invested in each other.  This problem is solved by the <code>flatMap</code> method or the <code>flatten</code> method.  The first one works like a <code>map</code> ‚Äî it transforms the internal value, but at the same time it flattens the structure, the second simply simplifies the structure. </p><br><p>  Imagine that we have a certain function that returns <code>Option</code> : </p><br><pre> <code class="hljs lisp">def concatOpt (<span class="hljs-name"><span class="hljs-name">s0</span></span>: String, s1: String) = Option(<span class="hljs-name"><span class="hljs-name">s0</span></span> + s1)</code> </pre> <br><p>  then we can get a similar result: </p><br><pre> <code class="hljs pgsql">messageOpt.map(msg =&gt; concatOpt(msg, " cruel world")) res0: <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[String]] = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(Hello cruel world)) //    `flatMap`: messageOpt.flatMap(msg =&gt; concatOpt(msg, " cruel world")) res6: <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[String] = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(Hello cruel world) //   flatten messageOptOpt.flatten == <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>("Hello") res1: <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[String] = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(Hello)</code> </pre> <br><p>  In Scala, there is another mechanism that can visibly facilitate the work with <code>Option</code> , and it may be known to you as "For comprehension". </p><br><pre> <code class="hljs pgsql">val ox = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) val oy = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) val oz = <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { x &lt;- ox; y &lt;- oy; z &lt;- oz } yield x + y + z // res0: <span class="hljs-keyword"><span class="hljs-keyword">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br><p>  If any of the <code>Option</code> types is equal to <code>None</code> , after <code>yield</code> user will receive an empty container, or rather, the value of an empty container.  In the case of <code>Option</code> this is <code>None</code> .  In the case of the list - <code>Nil</code> . </p><br><p>  And most importantly, try to do everything, just not to call the <code>get</code> method.  This leads to potential problems. </p><br><blockquote>  I know that you are well done and have checked everything.  I'm sure your mom thinks so too, but it doesn‚Äôt give you a reason to pull <code>get</code> . </blockquote><br><h3 id="spiski">  Lists </h3><br><p>  <code>Option</code> has <code>get</code> , list has <code>head</code> , and also has <code>init</code> and <code>tail</code> .  Here is what you can get by calling the above methods on an empty list: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//   : init: java.lang.UnsupportedOperationException head: java.lang.NoSuchElementException last: java.lang.NoSuchElementException tail: java.lang.UnsupportedOperationException</span></span></code> </pre> <br><p>  Of course, this will never happen to you if you check a sheet for emptiness. </p><br><blockquote>  The beginning rocker will do this using the notorious <code>if</code> - <code>else</code> in its path. </blockquote><p>  Calling <code>list.head</code> and associates is one of the best ways to deprive yourself <br>  sleep when working with lists. </p><br><blockquote>  Wriggle a rattlesnake, do everything you can to avoid using <code>list.head</code> and his friends. </blockquote><p>  Instead of <code>head</code> good option would be to use the <code>headOption</code> method.  The <code>lastOption</code> method behaves similarly.  If you are in any way tied to indexes, you can use the <code>isDefinedAt</code> method, which takes an integer argument (index) as a parameter.  Everything described above still involves checks that you can forget about.  There is a thousand and one more reasons for you to consciously lower them.  The correct and idiomatic alternative would be to use pattern matching.  The fact that the list is an algebraic type will not let you forget about <code>Nil</code> , you can safely avoid the <code>head</code> and <code>tail</code> calls, saving you a few lines of code: </p><br><pre> <code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printRec</span></span></span></span>(list: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = list <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,     // n,  k ,  . That's the power! case Nil =&gt; () case x::xs =&gt; println(x) printRec(xs) }</span></span></code> </pre> <br><p>  <em>A bit about performance</em> </p><br><blockquote>  From the point of view of performance for a single-linked list, which is a Scalar <code>List</code> (aka <code>scala.collection.immutable.List</code> ), the cheapest operation will be writing to the top of the list, rather than to the end.  To write to the end of the list is required to go through the entire list to the end.  The complexity of writing to the beginning of the list is O (1), to the end of O (n).  Do not forget about it. </blockquote><br><h3 id="optionlist">  Option [List [?]] </h3><br><p>  In the code that just got acquainted with Scala with an enviable periodicity are found <code>Option[List[A]]</code> .  As in the arguments of the function, and as a return type.  Often, those who created such a masterpiece use the following argument: "So we may or may not have a list, what will I use <code>null</code> instead of it?". </p><br><p>  Well, let's imagine another situation: <code>Option</code> represents a conceptually possible unsuccessful outcome, and the list is a set of returned data.  Imagine that we have a server that returns <code>Option[List[Message]]</code> .  If everything is good, we get a list of messages inside <code>Some</code> .  If there are no messages, we get an empty list inside <code>Some</code> .  And if an error occurred on the server, we get <code>None</code> .  Reasonable and viable? </p><br><p>  And no!  If we have an error in the system, we definitely need to know which one.  And for this we need to return or <code>Throwable</code> or some code.  Does <code>Option</code> us to do this?  Not really, but <code>Try</code> and <code>Either</code> can help you with this. </p><br><p>  The list can be empty in the same way as <code>Option</code> , so you can safely pass an empty list if something goes wrong.  I have not yet seen counter-examples where the <code>Option[List]</code> construct could be viable.  I would be very happy if you can find such examples and share them with me. </p><br><h3 id="optiona--optionb">  Option [A] =&gt; Option [B] </h3><br><p>  Most recently, I stumbled upon another interesting use of <code>Option</code> .  Let's look at the signature of the following function: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">item:</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Option[Item])</span></span></span></span>: Option[UpdatedItem] = ???</code> </pre> <br><p>  There is no need to complicate the conversion using an additional container: this makes the function less common and visually clutters up the function signature.  Instead, use the function type <code>A =&gt; B</code>  And if you want to save the type of the source container, wrap the original result in this container and use the <code>map</code> or <code>flatmap</code> for the subsequent data transformation. </p><br><h3 id="kortezhi">  Tuples </h3><br><p>  The presence of tuples (tuples) is an interesting feature of a number of functional (and not only) languages.  In functional languages, tuples may be used in the same way as records.  We describe a tuple with the necessary data and wrap it in a new type, for example, using a <code>newtype</code> in <a href="https://wiki.haskell.org/Newtype">Haskell</a> , resulting in a new type, the implementation of which is not known to the user.  In purely functional languages ‚Äã‚Äãwithout tuples anywhere: they allow you to wonderfully represent dictionaries (dictionaries).  <a href="https://en.wikipedia.org/wiki/Convolution_(computer_science)">Convolution</a> without them would be less obvious. </p><br><blockquote>  In some languages, for example, Erlang, records appeared much later than tuples.  Moreover, records (records) in Erlang are also tuples. </blockquote><p>  Scala is an object-oriented language.  Yes, with support for functional programming elements.  I am sure that many will disagree with me, but let's not forget that everything in Scala is an object.  The presence of <code>case</code> classes largely reduces the need for tuples: we get immutable records, which can also be compared with patterns (we will discuss this later).  Each <code>case</code> class already has its own type. </p><br><p>  Tuples often have to be used by those who come from object-oriented languages: these language tools are unusual for them.  Let's start with the fact that they are not called. </p><br><blockquote>  If the tuple is not used as an anonymous garbage dump, it should be called. <br><br>  If you want to use a tuple to store data, use the <code>case class</code> for this. </blockquote><p>  For the functional style, it is considered to be good use of the previously mentioned aliases for types (type aliasing): </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Double</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  In the future, you refer to quite named types, and you will not have such terrible things: </p><br><pre> <code class="hljs pgsql">//  def drawLine(x: (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>), y: (<span class="hljs-type"><span class="hljs-type">Double</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>)): <span class="hljs-type"><span class="hljs-type">Line</span></span> = ??? //   def drawLine(x: <span class="hljs-type"><span class="hljs-type">Point</span></span>, y: <span class="hljs-type"><span class="hljs-type">Point</span></span>): <span class="hljs-type"><span class="hljs-type">Line</span></span> = ???</code> </pre> <br><p>  In Scala, you can reach the element of a tuple by index.  For example: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// ! val y = point._2 //  </span></span></code> </pre> <br><p>  This is especially sad when working with collections: </p><br><pre> <code class="hljs pgsql">// ! points <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> { <span class="hljs-type"><span class="hljs-type">point</span></span>: <span class="hljs-type"><span class="hljs-type">Point</span></span> =&gt; println(s"x: ${point._1}, y: ${point._2}") }</code> </pre> <br><p>  And so do not.  Of course, there are exceptional cases when this kind of measures increase readability: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  rows.groupBy(_._2)</span></span></code> </pre> <br><p>  But in most cases, the syntax with an underscore is better not to use.  It is generally better to forget about him and not to remember.  In Scala, there are more natural ways to do without this syntax. </p><br><blockquote>  In Scala, you can always do without a <code>pair._2</code> .  And it needs to be done. </blockquote><p>  To understand and understand why this is the case, let's turn to functional languages. </p><br><p>  <strong>Question</strong> : Dear editors, why do indexes of lists in Scala start from zero, and tuples start from one?  Vasily, Pokhabinsk. </p><br><p>  <strong>Answer</strong> : Hello, Vasily.  The answer is simple: because it is historically.  In SML, <a href="https://www.cs.cornell.edu/courses/cs312/2008sp/recitations/rec02.html">functions</a> <code>#1</code> and <code>#2</code> exist to access elements of a tuple.  In <code>Haskell</code> there are only two functions for accessing the elements of a tuple: <code>fst</code> and <code>snd</code> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">-- - .  Haskell        --   .  . fst tuple</span></span></code> </pre> <br><p>  But to get the third or fifth element of the tuple just will not work.  Do not believe?  And <a href="http://stackoverflow.com/questions/15558278/how-to-get-nth-element-from-a-10-tuple-in-haskell">in vain</a> .  And do not believe it if I tell you that the comparison with the sample is the <em>most natural</em> .  And not just in <code>Haskell</code> . </p><br><p>  <strong>Ocaml</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">third</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, _, elem</span></span></span><span class="hljs-function">)</span></span> = elem</code> </pre> <br><p>  <strong>Erlang</strong> </p><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">1&gt; </span></span>Tuple = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}. {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>} <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; Third = fun ({_Fst, _Snd, Thrd}) -&gt; Thrd end. #Fun&lt;erl_eval.<span class="hljs-number"><span class="hljs-number">6.50752066</span></span>&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; Third(Tuple). <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  <strong>Python</strong> <br>  And here is an example from a non-functional language: </p><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span> (ip, hostname) = (<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) &gt;&gt;&gt; ip <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span> &gt;&gt;&gt; hostname <span class="hljs-string"><span class="hljs-string">'localhost'</span></span> &gt;&gt;&gt;</code> </pre> <br><p>  Now let's apply this knowledge to <strong>Scala</strong> </p><br><pre> <code class="hljs perl">// ,     trait Rectangle { def topLeft: Point ... } //      val (<span class="hljs-keyword"><span class="hljs-keyword">x</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">y</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>) = rectangle.topLeft //     : points <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> { case (<span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>) =&gt; println(<span class="hljs-keyword"><span class="hljs-keyword">s</span></span><span class="hljs-string"><span class="hljs-string">"x: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">x</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">, y: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">y</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><p>  Nobody canceled the standard matching mechanism using the <code>match</code> keyword either. </p><br><p>  Also tuples can be used as anonymous garbage cans, and this is sometimes justified.  The fact is that in many functional languages ‚Äã‚Äãthere is pattern matching at the level of function signatures: </p><br><pre> <code class="hljs kotlin">--    haskell --   : map :: (a -&gt; b) -&gt; [a] -&gt; [b] --         --   --     --  : map _ [] = [] --      x:xs , ,   --  Haskell head:tail  . : -   cons --    :: map <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(head:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">tail</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> head : map </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> tail</span></span></code> </pre> <br><p>  A similar mechanism is used in SML and Erlang.  Unfortunately, Scala has no such opportunity.  Therefore, tuples can be used for grouping and subsequent pattern matching: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Haskell,    :<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( def map [A, B] (f: A =&gt; B, l: List[A]): List[B] = (f, l) match { case (f, Nil) =&gt; List.empty case (f, head::tail) =&gt; f(head) :: map(f, tail) }</span></span></span></span></code> </pre> <br><p>  It is often necessary to update the value in one of the elements of the tuple.  The <code>copy</code> method is suitable for this. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dog = (<span class="hljs-string"><span class="hljs-string">"Rex"</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> olderDog = tuple.copy(_2 = <span class="hljs-number"><span class="hljs-number">14</span></span>)</code> </pre> <br><p>  You can read about the <a href="https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples">use of tuples in Haskell</a> and <a href="http://www.cs.cornell.edu/courses/cs312/2004fa/lectures/lecture3.htm">SML</a> if you follow the links. </p><br><p>  In reality, using tuples is not the best way to represent coordinates (at least in Scala).  In Scala, it is better to use <code>case class</code> classes for this.  The need for tuples is mainly dictated by the availability of universal libraries for cases when it is necessary to minimize the composite record in a generalized form.  For example <code>zip</code> or <code>groupBy</code> .  So, if you want to use tuples, use them only when writing generic algorithms.  In all other cases, it is better to have a good old <code>case class</code> . </p><br><h3 id="o-nizhnem-podcherkivanii">  About underscore </h3><br><p>  Can you list all the cases when Scala uses <code>_</code> ?  According to the <a href="https://www.scala-lang.org/old/node/5496">survey</a> results <a href="https://www.scala-lang.org/old/node/5496">,</a> only 7% of Scala-developers can do this.  The underscore is used repeatedly in the language and in different contexts.  <a href="https://www.slideshare.net/normation/scala-dreaded">Here</a> it is well illustrated.  In most cases, you cannot do without underscores: the syntax requires them for multiple imports or imports with exceptions.  There are other reasonable applications (even where you can do without them).  However, they do not add readability inside lambda expressions.  Difficulties in reading lambdas arise when the number of underscore arguments exceeds 2. </p><br><p>  When compared with a sample, they can also ruin your life.  Is it clear what <code>Fork</code> and <code>Leaf</code> ? </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tree: CodeTree</span></span></span><span class="hljs-function">): Int</span></span> = tree match { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, _, _, weight</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-function"><span class="hljs-function">weight </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Leaf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, weight</span></span></span><span class="hljs-function">)</span></span> =&gt; weight }</code> </pre> <br><p>  And so? </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tree: CodeTree</span></span></span><span class="hljs-function">): Int</span></span> = tree match { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left, right, chars, weight</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-function"><span class="hljs-function">weight </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Leaf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">, weight</span></span></span><span class="hljs-function">)</span></span> =&gt; weight }</code> </pre> <br><p>  As you may have noticed, these values ‚Äã‚Äãare not used.  But this is not the case when they need to be overwritten with underscores.  Believe me, the programming speed does not rest on the typing speed: you can write a few extra characters for the sake of readability. </p><br><h2 id="v-zaklyuchenie">  Finally </h2><br><p>  In this article, I tried (and it didn‚Äôt work out, not for me to judge) to tell you about the main functional idioms of Scala and to draw a number of parallels with other functional languages.  In the next part, I will talk about the idioms associated with OOP and collections, and also present my thoughts on infrastructure issues that are tormenting many novice developers.  I really hope that you liked this article.  Thank you for being patient and reading it to the end.  To be continued. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323706/">https://habr.com/ru/post/323706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323692/index.html">Universal grammar analyzer of natural languages ‚Äã‚Äãfrom scratch. Release 1</a></li>
<li><a href="../323694/index.html">How Discord stores billions of messages</a></li>
<li><a href="../323696/index.html">Lectures Technopark. The course "Algorithms and data structures" (autumn 2016)</a></li>
<li><a href="../323702/index.html">Find for spy: AAB-testing as the best option for split-test</a></li>
<li><a href="../323704/index.html">Product Design Digest February 2017</a></li>
<li><a href="../323708/index.html">Install and configure Puppet + Foreman on Ubuntu 14.04 (step-by-step tutorial)</a></li>
<li><a href="../323710/index.html">I gave up on coffee, and that's what happened.</a></li>
<li><a href="../323714/index.html">Reliable authorization for web service in one evening</a></li>
<li><a href="../323716/index.html">A revolution in radio engineering? RF-ARM-FPGA SoC</a></li>
<li><a href="../323718/index.html">The digest of interesting materials for the mobile # 194 developer (March 6-12)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>