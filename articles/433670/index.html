<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Font rendering with cover masks, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we started developing our performance profiler , we knew that we would perform almost the entire UI rendering on our own. Soon we had to decide w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Font rendering with cover masks, part 1</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="image"></div><br>  When we started developing our <a href="http://www.superluminal.eu/">performance profiler</a> , we knew that we would perform almost the entire UI rendering on our own.  Soon we had to decide which approach to use for font rendering.  We had the following requirements: <br><br><ol><li>  We need to be able to render any font of any size in real time in order to adapt to the system fonts and their sizes chosen by Windows users. </li><li>  Font rendering should be very fast, no braking is required when rendering fonts. </li><li>  In our UI, a lot of smooth animations, so the text should be able to smoothly move around the screen. </li><li>  It should be readable with small font sizes. </li></ol><br>  Not being at that time a great specialist in this matter, I searched the information on the Internet and found many techniques used to render fonts.  I also talked to the technical director of Guerrilla Games Michiel van der Leu.  This company experimented with a variety of font rendering methods and their rendering engine was one of the best in the world.  Michil briefly outlined to me his idea of ‚Äã‚Äãa new font rendering technique.  Although the existing techniques would be quite enough for us, I was intrigued by this idea and I started to implement it, not paying attention to the wonderful world of font rendering that opened to me. <br><a name="habracut"></a><br>  In this series of articles, I will describe in detail the technique we use, dividing the description into three parts: <br><br><ul><li>  In the <strong>first part,</strong> we will learn how to render glyphs in real time using 16xAA sampled from a uniform grid. </li><li>  In the <strong>second part,</strong> we will move to a rotated grid, in order to beautifully perform anti-aliasing of horizontal and vertical edges.  We will also see how the finished shader is almost completely reduced to one texture and lookup table. </li><li>  In the <strong>third part,</strong> we learn how to rasterize glyphs in real time using Compute and CPU. </li></ul><br>  You can see the finished results in the profiler, but here is an example of a screen with a Segoe UI font rendered using our font renderer: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Here is an increase in the letter S, rasterized sizes of just 6 √ó 9 texels.  The original vector data is rendered as a contour, and the rotated sampling pattern is rendered from green and red rectangles.  Since it is rendered with a resolution much larger than 6 √ó 9, the shades of gray are not represented in the final pixel hue, it displays the subpixel hue.  This is a very useful debug visualization, making it possible to make sure that all calculations at the subpixel level work correctly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Idea: storing cover instead of shade </h1><br>  The main problem that font renderers need to deal with is the display of scalable font vector data in a fixed grid of pixels.  The way to move from the vector space to the finished pixels in different techniques is very different.  In most of these techniques, the curves before rendering are rasterized into temporary storage (for example, texture) to get a certain size in pixels.  Temporary storage is used as the glyph cache: when the same glyph is rendered several times, the glyphs are taken from the cache and reused to avoid re-rasterization. <br><br>  The difference technician is well marked in how data is stored in an intermediate data format.  For example, the Windows font system rasterizes glyphs to a specific pixel size.  Data is stored as a <strong>hue</strong> per pixel.  The shade describes the best approximation of the coverage of this pixel glyph.  When rendering, pixels are simply copied from the glyph cache to the target pixel grid.  When converting data to a pixel format, they do not scale well, so when zooming out, fuzzy glyphs appear, and when zooming in, glyphs in which blocks are clearly visible.  Therefore, for each finite size, the glyphs are rendered into the glyph cache. <br><br>  The <a href="https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">Signed Distanced Fields</a> technique takes a different approach.  Instead of a hue for a pixel, the <strong>distance</strong> to the nearest edge of the glyph is maintained.  The advantage of this method is that for curved edges, the data is scaled much better than hues.  As the glyph scale increases, the curves remain smooth.  The disadvantage of this approach is that straight and sharp edges are smoothed out.  Far better quality than SDF, are enhanced solutions like <a href="https://www.freetype.org/">FreeType</a> , which store hue data. <br><br>  In cases where a hue is preserved for a pixel, it is necessary to first calculate its coverage.  For example, in stb_truetype there are good <a href="https://nothings.org/gamedev/rasterize">examples</a> of how to calculate the coverage and shade.  Another popular way to approximate coverage is to sample the glyph with greater frequency than the final resolution.  This counts the number of samples that fall into the glyph in the target pixel domain.  The number of hits divided by the maximum number of possible samples determines shade.  Since the coverage has already been converted to tint for a certain resolution of the pixel grid and <strong>alignment</strong> , it is impossible to place glyphs between the target pixels: the tint will not correctly reflect the true coverage with samples of the target pixel window.  For this, as well as some other reasons that we will discuss later, such systems do not support sub-pixel movement. <br><br>  But what if we need to freely move the glyph between pixels?  If the hue is calculated in advance, we cannot find out what the hue should be when moving between pixels in the target pixel region.  However, we can postpone the conversion from coverage to tint at the time of rendering.  To do this, we will not store the shade, but the <strong>coating</strong> .  We sample a glyph with a frequency of 16 target resolution, and for each sample we save a single bit.  When sampling on a 4 √ó 4 grid, it is enough to store only 16 bits per pixel.  This will be our <strong>cover mask</strong> .  During rendering, we need to consider how many bits fall into the target pixel window, which has the same resolution as the texel storage, but is not physically attached to it.  The animation below shows a portion of the glyph (blue) rasterized into four texels.  Each texel is divided into a grid of 4 √ó 4 cells.  The gray rectangle indicates a pixel window dynamically moving along the glyph.  At run time, the number of samples that fall into the pixel window is counted to determine the hue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Briefly about the basic techniques of font rendering </h2><br>  Before discussing the implementation of our font rendering system, I want to briefly describe the main techniques used in this process: font hinting and subpixel rendering (in Windows this technique is called ClearType).  You can skip this section if you are only interested in anti-aliasing technique. <br><br>  During the implementation of the renderer, I learned more and more about the long history of font rendering development.  Research is fully focused on the only aspect of font rendering - readability with small sizes.  Creating an excellent renderer for large fonts is quite simple, but it is incredibly difficult to write a system that retains readability at small sizes.  The study of font rendering has a long history, striking in its depth.  Read, for example, about <a href="http://rastertragedy.com/RTRCh4.htm">raster tragedy</a> .  It is logical that this was a major problem for computer specialists, because at the early stages of computers, the resolution of the screens was rather low.  It must have become one of the first tasks that OS developers needed to cope with: how to make the text readable on devices with a low screen resolution?  To my surprise, high-quality font rendering systems are very pixel-oriented.  For example, the glyph is constructed in such a way that it starts at the border of a pixel, its width is a multiple of the number of pixels, and the content adjusts to the pixels.  This technique is called grid binding.  I am used to working with computer games and 3D graphics, where the world is built from units of measurement and projected into pixels, so I was a little surprised.  I found out that in the field of font rendering it is a very important choice. <br><br>  To show the importance of snapping to a grid, let's look at a possible scenario of rasterizing a glyph.  Imagine that the glyph is rasterized on a pixel grid, but the shape of the glyph imperfectly coincides with the grid structure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  Antialiasing will make the pixels to the right and left of the glyph equally gray.  If the glyph is slightly shifted so that it matches the edges of the pixels better, then only one pixel will be painted, and it will become completely black: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Now that the glyph matches the pixels well, the colors are not so blurry.  The difference in sharpness is very large.  Western fonts have a lot of glyphs with horizontal and vertical lines, and if they do not match well with the pixel grid, then shades of gray make the font blurry.  Even the best antialiasing technique cannot cope with this problem. <br><br>  <a href="https://docs.microsoft.com/en-us/typography/truetype/hinting">Hinting of fonts</a> was proposed as a solution.  Font authors should add to their fonts information about how glyphs should snap to pixels if they do not match perfectly.  The font rendering system distorts these curves to bind them to the pixel grid.  This greatly increases the clarity of the font, but has its price: <br><br><ul><li>  Fonts become slightly <em>distorted</em> .  Fonts do not look exactly as intended. </li><li>  All glyphs must be tied to the pixel grid: the beginning of the glyph and the width of the glyph.  Therefore, it is impossible to animate them between pixels. </li></ul><br>  Interestingly, in solving this problem, Apple and Microsoft went different ways.  Microsoft adheres to absolute clarity, and Apple is committed to a more accurate display of fonts.  On the Internet, you can find people's complaints about the blurring of fonts on Apple machines, but many people like what they see on Apple.  That is partly a matter of taste.  <a href="https://www.joelonsoftware.com/2007/06/12/font-smoothing-anti-aliasing-and-sub-pixel-rendering/">Here is the</a> post of Joel on Software, and <a href="https://www.typotheque.com/articles/hinting">here is</a> <a href="https://www.typotheque.com/authors/peter_bilak">Peter Bilak</a> 's post about this topic, but if you search on the Internet, you can find much more information. <br><br>  Since the DPI resolution in modern screens is rapidly increasing, the question arises as to whether hinting fonts will be needed in the future, like today.  In the current state, I consider font hinting to be a very valuable technique for accurate font rendering.  However, the technique described in my article may in the future become an interesting alternative, because the glyphs can be freely placed on the canvas without distortion.  And since this is essentially an antialiasing technique, it can be used for any purpose, and not just for font rendering. <br><br>  Finally, I will tell you briefly about <a href="https://www.grc.com/cleartype.htm">subpixel rendering</a> .  In the past, people have realized that you can triple the horizontal resolution of a screen using the individual red, green, and blue rays of a computer monitor.  Each pixel is built from these rays, which are physically separated.  Our eye blends their values, creating a single pixel color.  When a glyph covers only part of a pixel, only the ray that overlaps the glyph is included, which triples the horizontal resolution.  If you increase the screen image when using a technique like ClearType, you can see the colors around the edges of the glyph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Interestingly, the approach, which I will discuss in the article, can be extended to sub-pixel rendering.  I have already implemented its prototype.  Its only drawback is that due to the addition of filtering in techniques like ClearType, we need to take more texture samples.  Perhaps I will consider this in the future. <br><br><h1>  Glyph rendering using a uniform grid </h1><br>  Suppose we sampled a glyph with a resolution of 16 times the target and saved it into a texture.  How this is done, I will tell in the third part of the article.  The sampling pattern is a uniform grid, that is, 16 sampling points are evenly distributed over the texel.  Each glyph is rendered with the same resolution as the target resolution, we store 16 bits per texel, and each bit corresponds to a sample.  As we will see in the process of calculating the coverage mask, the order in which samples are stored is important.  In general, the sampling points and their positions for a single texel look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Getting texels </h2><br>  We will shift the pixel window over the bits of the coverage stored in texels.  We need to answer the following question: how many samples will fall into our pixel window?  It is illustrated by the following image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Here we see four texels, on which the glyph is partially superimposed.  One pixel (indicated in blue) covers part of the texels.  We need to determine how many samples cross our pixel window.  First we need the following: <br><br><ul><li>  Calculate the relative position of the pixel window compared to 4 texels. </li><li>  Get the texels with which our pixel window intersects. </li></ul><br>  Our implementation is based on OpenGL, so the origin point of the texture space begins in the lower left corner.  Let's start by calculating the relative position of a pixel window.  The UV coordinate transmitted to the pixel shader is the UV coordinate of the pixel center.  Assuming that UV is normalized, we can first convert UV into texel space by multiplying it by the size of the texture.  Subtracting 0.5 from the center of the pixel, we get the lower left corner of the pixel window.  By rounding this value down (floor), we calculate the bottom left position of the left bottom texel.  The image shows an example of these three points in the texel space: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  The difference between the lower left corner of the pixel and the lower left corner of the texel grid is the relative position of the pixel window in normalized coordinates.  In this image, the position of the pixel window will be [0.69, 0.37].  In the code: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Using the textureGather instruction, we can get four texels at a time.  It is only available in OpenGL 4.0 and higher, so four texelFetch can be executed instead.  If we just pass the textureGather UV coordinates, then if there is a perfect match between the pixel window and the texel, there will be a problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Here we see three horizontal texels with a pixel window (shown in blue) that exactly coincides with the central texel.  The calculated weight is close to 1.0, but instead of textureGather, the center and right texels are selected.  The reason is that calculations performed by textureGather may differ slightly from floating-point weight calculations.  The difference in the rounding of the calculations performed in the GPU, and the calculations of the weight with a floating comma lead to glitches around the centers of the pixels. <br><br>  To solve this problem, you need to make sure that the weight calculations are guaranteed to coincide with the textureGather sampling.  To do this, we will never sample the pixel centers, and instead we will always perform sampling at the center of the 2 √ó 2 grid.  From the computed and already rounded down left bottom position of the texel, we add the full texel to get to the center of the texel grid. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  This image shows that using the center of the texel grid, the four sampling points taken by textureGather will always be in the center of texels.  In the code: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  Horizontal pixel window mask </h2><br>  We got four texels and, together, they form a grid of 8 √ó 8 coverage bits.  To count the bits in a pixel window, we first need to zero the bits that are outside the pixel window.  To do this, we will create a pixel window mask and perform a bitwise AND between the pixel mask and texel cover masks.  Horizontal and vertical masking are performed separately. <br><br>  The horizontal pixel mask should move with the horizontal weight, as shown in this animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  The image shows an 8-bit mask with the value 0x0F0 shifting to the right (zeros are inserted on the left).  In animation, a mask is linearly animated with weight, but in reality, a bit shift is a step by step operation.  The mask changes value when the pixel window crosses the border of the sample.  In the next animation, this is shown in red and green columns, animated step by step.  The value changes only at the intersection of the sample centers: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  For the mask to move only in the center of the cell, but not at its edges, simple rounding will suffice: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Now we have a pixel mask of a full 8-bit string occupying two texels.  If we choose the correct storage type in our 16-bit coverage mask, then there are ways to combine the left and right texel and perform horizontal pixel masking for the full 8-bit line at a time.  However, this becomes problematic with vertical masking when we move to rotated grids.  Therefore, instead of this, we will combine two left texels and two right texels separately to create two 32-bit coverage masks.  We mask the left and right results separately. <br><br>  Masks for left texels use the top 4 bits of the pixel mask, and masks for the right texels use the bottom 4 bits.  In a uniform grid, each row has the same horizontal mask, so we can simply copy the mask for each row, after which the horizontal mask will be ready: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  To do the masking, we combine the two left texels and the two right texels, and then we mask the horizontal lines: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Now the result might look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  We can already calculate the bits of this result using the bitCount instruction.  We should divide not by 16, but by 32, because after vertical masking we can still have 32 potential bits, not 16. Here is the full render of the glyph at this stage: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Here we see an enlarged letter S, rendered on the basis of the initial vector data (white contour), and the visualization of the sampling points.  If the point is green, then it is inside the glyph; if it is red, then no.  Grayscale displays the shades calculated at this stage.  In the process of font rendering, there are many possibilities for errors, ranging from rasterization, the method of storing data in a texture atlas, to calculating the final hue.  Such visualizations are incredibly useful for validating calculations.  They are especially important for debugging artifacts at the sub-pixel level. <br><br><h2>  Vertical masking </h2><br>  Now we are ready to perform the masking of the vertical bits.  For vertical masking, we use a slightly different method.  In order to deal with the vertical shift, it is important to remember how we saved the bits: in a row order.  The bottom line is the four least significant bits, and the top line is the four most significant bits.  We can simply clear one by one, shifting them based on the vertical position of the pixel window. <br><br>  We will create a single mask covering the entire height of the two texels.  As a result, we want to save four <strong>full</strong> lines of texels and mask all the others, that is, the mask will be 4 √ó 4 bits, which is equal to the value 0xFFFF.  Based on the position of the pixel window, we shift the bottom lines and clear the top lines. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  As a result, we also masked vertical bits outside the pixel window: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Now it‚Äôs enough for us to count the bits remaining in texels, which can be done with the bitCount operation, then divide the result by 16 and get the desired shade! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Now the full render of the letter looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  In continuation of ... </h1><br>  In the second part, we will take the next step and see how this technique can be applied to rotated grids.  We will calculate the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  And we will see that almost all of this can be reduced to several tables. <br><br>  Thanks to Sebastian Aaltonen ( <a href="https://twitter.com/SebAaltonen" rel="noopener">@SebAaltonen</a> ) for his help in solving the textureGather problem and, of course, Michael van der Leu ( <a href="https://twitter.com/mvdleeuwgg" rel="noopener">@MvdleeuwGG</a> ) for his ideas and interesting conversations in the evenings. </div><p>Source: <a href="https://habr.com/ru/post/433670/">https://habr.com/ru/post/433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433650/index.html">Istio and Kubernetes in production. Part 2. Tracing</a></li>
<li><a href="../433652/index.html">5G through the eyes of users. Expectations and concerns</a></li>
<li><a href="../433658/index.html">IT in Germany - how to look for work in major cities of Germany</a></li>
<li><a href="../433660/index.html">As I spoke at the fifth time on DefCamp</a></li>
<li><a href="../433666/index.html">FunCorp dictionary</a></li>
<li><a href="../433672/index.html">Boys, so Ruby is dead or not?</a></li>
<li><a href="../433674/index.html">The opening of a test tunnel by the Boring Company took place in California last night</a></li>
<li><a href="../433676/index.html">Who earns more in IT: office or remote employees?</a></li>
<li><a href="../433678/index.html">Crypto-hacking - a new type of data center attacks</a></li>
<li><a href="../433680/index.html">Winter activities in the gaming industry in the HSE and Nastolka gamedev simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>