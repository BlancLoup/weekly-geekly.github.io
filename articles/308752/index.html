<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Computer Science for Postgres Indexes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Friends, PG Day'16 Russia successfully completed, we took a deep breath and are already thinking about how to make upcoming events even more interesti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Computer Science for Postgres Indexes</h1><div class="post__text post__text-html js-mediator-article">  <i>Friends, <a href="http://pgday.ru/ru/2016%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dindex">PG Day'16 Russia</a> successfully completed, we <a href="http://pgday.ru/ru/2016%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dindex">took a deep</a> breath and are already thinking about how to make upcoming events even more interesting and useful for you.</i>  <i>We continue to publish interesting, in our opinion, materials on Postgres and communicate with you in the comments.</i>  <i>Today, we present the translation of Pat Shaughnessy‚Äôs article on what PostgreSQL indexes are.</i> <br><br>  We all know that indexes are one of the most powerful and important functions of relational database servers.  How to quickly find the value?  Create an index.  What you need to remember to do when combining two tables?  Create an index.  How to speed up a SQL query that started to work slowly?  Create an index. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ddf/c76/88c/ddfc7688c26a4890943892b2e1623848.jpg"></div><br>  But what are these indices?  And <i>how</i> do they speed up database searches?  To find out, I decided to read the PostgreSQL C database server source code and follow how it searches for an index for a simple text value.  I expected to find complex algorithms and efficient data structures.  And I found them.  Today, I will show you what the indexes look like inside Postgres, and explain how they work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What I did not expect to find ‚Äî what I first discovered while reading Postgres source code ‚Äî is the computer science theory at the heart of what it does.  Reading the Postgres source code turned into a return to school and the study of the subject for which I never had enough time in my youth.  Comments on C inside Postgres explain not only what he does, but <i>why</i> . <br><a name="habracut"></a><br><h3>  <font color="#000000">Sequential scan: mindless search</font> </h3><br>  When we left the Nautilus team, they were exhausted and almost fainted: the Postgres sequential scanning algorithm thoughtlessly looped through all the entries in the user table!  Remember my <a href="https://habrahabr.ru/post/304258/">previous post</a> in which we executed this simple SQL query to find Captain Nemo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cbb/721/83f/cbb72183f2734b01bc84633fec703eeb.png"></div>  Postgres processed, analyzed and planned the request.  Then <a href="http://doxygen.postgresql.org/nodeSeqscan_8c.html">ExecSeqScan</a> , function C inside Postgres, which performs the Serially Scan plan node (SEQSCAN), quickly found Captain Nemo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a7f/fad/4f4/a7ffad4f4e9549d38758201ba41c558c.png"></div><br>  But then Postgres inexplicably continued to perform a cycle across the entire user table, comparing each name with ‚ÄúCaptain Nemo‚Äù, although we already found what we were looking for! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ed3/e25/5ea/ed3e255eaef94e26a0d18fe5a32e25fd.png"></div><br>  Imagine that there would be millions of records in our table - the process would take a very long time.  Of course, we could avoid this by removing the sort and rewriting our query so that only the first found name is accepted, but the deeper problem is the inefficiency of the way Postgres searches our target string.  Using sequential scanning to compare each value in the user table with ‚ÄúCaptain Nemo‚Äù is slow, inefficient and depends on the random order in which the names appear in the table.  What are we doing wrong?  There must be a better way! <br><br>  The answer is simple: we forgot to create an index.  Let's do it now. <br><br><h3>  <font color="#000000">Create index</font> </h3><br>  Creating an index is very simple - you just need to run this command: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c3c/48b/a14/c3c48ba14a2a400f9a3964443ad04d5d.png"></div><br>  As Ruby developers, we, of course, would instead use ActiveRecord add_index migration, which will run the same CREATE INDEX command ‚Äúunder the hood‚Äù.  When we run our select query again, Postgres will, as usual, create a plan tree, but this time it will be slightly different: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9f9/36e/6f8/9f936e6f86834e59958bf8371a02dc03.png"></div><br>  Notice that the bottom Postgres now uses INDEXSCAN instead of SEQSCAN.  Unlike SEQSCAN, INDEXSCAN will not scan across the entire user table.  Instead, it uses the index that we just created to find and return records about Captain Nemo quickly and efficiently. <br><br>  Creating an index solved our performance problem, but left us with a lot of interesting unanswered questions: <br><br><ul><li>  <i>What</i> exactly is the postgrese index? </li><li>  If I could get into the Postgres database and get a better look at the index, <i>what would it look like</i> ? </li><li> <i>How does the</i> index speed up the search? </li></ul><br>  Let's try to answer these questions by studying the Postgres source code. <br><br><h3>  <font color="#000000">What is the postgres index?</font> </h3><br>  We can start by reviewing the <a href="https://www.postgresql.org/docs/current/static/sql-createindex.html">documentation</a> for the CREATE INDEX command. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/188/65c/ab1/18865cab15c340f7bab64137d657d761.png"></div><br>  Here you see all the options that we can use to create an index, for example, UNIQUE and CONCURRENTLY.  Note that there is an option like the USING method.  It tells Postgres what kind of index we need.  Below on the same page there is information about the method argument to the keyword USING: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/905/95a/874/90595a8748b046a4851ef2132084a09f.png"></div><br>  It turns out Postgres implements four different types of indices [approx.  Lane: now more, the article was written before BRIN and other new index options appeared.]  You can use them for different data types and in different situations.  Since we didn‚Äôt specify USING, our index_users_on_name is ‚Äúbtree‚Äù (or B-Tree) index, the default type. <br><br>  This is our first clue: the Postgres index is the B-Tree.  But what is a B-Tree?  Where can we find it?  Inside Postgres, of course!  Let's look in the source code of the C Postgres files containing ‚Äúbtree:‚Äù <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/24a/b2f/9cf/24ab2f9cfd3e4c6a99311c34c6b447ca.png"></div><br>  The key result is bold: ‚Äú./backend/access/nbtree.‚Äù Inside this directory is a README file.  Let's read it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b01/831/2d6/b018312d6f964ef7bcbcd8cf38147d71.png"></div>  Surprisingly, this README file turned out to be a detailed 12-page document!  Postgres source code contains not only useful and interesting comments on code C, but also documentation on the theory and implementation of the database server.  Reading and understanding code in open source projects is often difficult and scary, but not in PostgreSQL.  The developers behind Postgres have made tremendous efforts so that we can understand their work. <br><br>  The document title README - ‚ÄúBtree Indexing‚Äù - confirms that the directory contains the C code that implements the B-Tree indexes in the Postgrece.  But the first sentence is even more interesting: this is a reference to a scientific paper that explains what a B-Tree is and how postgres indexes work: <a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf">Efficient Locking for Concurrent Operations on B-Trees</a> , authored by Lehman and Yao ). <br><br>  We will try to deal with the fact that such a B-Tree with the help of this scientific work. <br><br><h3>  <font color="#000000">What does the B-Tree index look like?</font> </h3><br>  The work of Lehmann and Yao explains the innovative changes they made to the B-Tree algorithm in 1981.  Let's talk about it a little later.  But they start with a simple introduction to the B-Tree data structure, which was invented 9 years earlier - in 1972.  One of their diagrams shows an example of a simple B-Tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c16/b67/44f/c16b6744f10a42d08db6ee23a4cd123a.png"></div><br>  The term B-Tree is an abbreviation for the English ‚Äúbalanced tree‚Äù - a balanced tree.  Algorithm makes searching easy and fast.  For example, if we wanted to find the value 53 in this example, we would start with the root node containing the value 40: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f8d/073/98b/f8d07398b2554f63be40239058e12de6.png"></div><br>  We compare our sought value 53 with the value we found in the tree node.  53 is more or less than 40?  Since 53 is over 40, we follow the pointer down and to the right.  If we were looking for 29, we would have gone down to the left.  Pointers to the right lead to larger values, and to the left, to smaller ones. <br><br>  Following down the pointer to the next child node of the tree, we encounter a node containing 2 values: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a7/576/72c/1a757672c22c4007bc117efea477673f.png"></div><br>  This time we compare 53 at once with 47 and 62 and find that 47 &lt;53 &lt;62. Note that the values ‚Äã‚Äãin the tree node are sorted, so it will be easy to do.  Now we follow down the central sign. <br><br>  Here we have another tree node, already with three meanings: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b4c/e0a/2e9/b4ce0a2e93d04744a4cbd31e8e8a49bb.png"></div><br>  After reviewing the sorted list of numbers, we find 51 &lt;53 &lt;56 and follow down the second of four pointers. <br><br>  Finally, we arrive at a leaf node of the tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6d9/2e7/59a/6d92e759a19e485ea6f47aa373b943ed.png"></div><br>  And here it is, our desired value of 53! <br><br>  The B-Tree algorithm speeds up the search because: <br><br><ul><li>  it sorts values ‚Äã‚Äã(called keys) within each node; </li><li>  it is balanced: the keys are equally distributed between the nodes, minimizing the number of transitions from one node to another.  Each pointer leads to a child node, which contains approximately the same number of keys as each subsequent child node. </li></ul><br><h3>  <font color="#000000">What does the postgres index look like?</font> </h3><br>  Lehman and Yao drew this diagram over 30 years ago.  What does it have to do with how Postgres works today?  Amazingly, the index index_users_on_name, which we created earlier, is very similar to this very diagram from scientific work: we created in 2014 an index that looks exactly like a diagram from 1981! <br><br>  When we ran the CREATE INDEX command, Postgres saved all the names from our user table in B-Tree.  They became the keys of the tree.  Here is what the node inside the B-Tree index looks like in Postgrese: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/15f/834/9da/15f8349daf3947cba14d923bc04d235d.png"></div><br>  Each entry in the index consists of a structure in the C language called IndexTupleData, followed by a bitmap and a value.  Postgres uses a bitmap to record if any of the index attributes in the key are NULL, to save space.  Actual values ‚Äã‚Äãare in the index after the bitmap. <br><br>  Let's take a closer look at the structure of IndexTupleData: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/80b/cde/2f1/80bcde2f19464727bfa5108b0ab0acd0.png"></div><br>  In the figure above, you can see that each IndexTupleData structure contains: <br><br><ul><li>  t_tid: this is a pointer to either another index tuple or a record in the database.  Notice that this is not a pointer to physical memory in the C language. Instead, it contains numbers that Postgres can use to find the desired value on the memory pages. </li><li>  t_info: it contains information about the elements of the index, for example, how many values ‚Äã‚Äãthere are and whether they are equal to null. </li></ul><br>  To better understand this, let's show some entries from our index index_users_on_name: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/82d/ac4/d8b/82dac4d8bad24bbfa9d6abc0c13fa19c.png"></div><br>  I replaced value with some names from my user table.  The top node of the tree contains the keys ‚ÄúDr.  Edna Kunde ‚Äùand‚Äú Julius Powlowski ‚Äù, and the bottom one is‚Äú Julius Powlowski ‚Äùand‚Äú Juston Quitzon ‚Äù.  Note that unlike the Lehmann and Yao diagrams, Postgres repeats the parent key in each child node.  Here ‚ÄúJulius Powlowski‚Äù is the key in the top and child nodes.  The t_tid pointer in the top node refers to the same name Julius in the bottom node. <br><br>  To learn more about exactly how Postgres saves key values ‚Äã‚Äãto a B-Tree node, refer to the itup.h header file: <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  IndexTupleData </h1>  <a href="http://doxygen.postgresql.org/itup_8h_source.html">view on postgresql.org</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c11/e75/af6/c11e75af68114f788e2b3a3e81228192.png"></div><br><hr><br><h3>  <font color="#000000">Search for a B-Tree node containing Captain Nemo</font> </h3><br>  Let's go back to our original SELECT query: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f7/853/77a/3f785377a1a74a7a9827c0a5d519d0ce.png"></div><br>  How exactly does Postgres look for the value ‚ÄúCaptain Nemo‚Äù in our index index_users_on_name?  Why use the index faster than sequential scanning, which we considered in a previous post?  To find out, let's zoom out a bit and look at some usernames in our index: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d7c/17f/59f/d7c17f59fa6e43e88e4e5ea2170b55bc.png"></div><br>  This is the B-Tree root node index_users_on_name.  I laid the tree on its side so that the names would fit.  You can see 4 names and one NULL value.  Postgres created this root node when I created index_users_on_name.  Notice that in addition to the first NULL value, which indicates the beginning of the index, the remaining 4 values ‚Äã‚Äãare more or less evenly distributed in alphabetical order. <br><br>  Let me remind you that B-Tree is a balanced tree.  In this example, there are 5 child nodes in B-Tree: <br><br><ul><li>  alphabetical names before Dr.  Edna Kunde; </li><li>  names located between Dr.  Edna Kunde and Julius Powlowski; </li><li>  names located between Julius Powlowski and Monte Nicolas; </li><li>  etc. </li></ul><br>  As we search for the name Captain Nemo, Postgres moves along the first upper arrow to the right.  This is because Captain Nemo alphabetically goes before Dr.  Edna Kunde: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9dd/25e/580/9dd25e5800b14bb7b91a6937ccf2c8ad.png"></div><br>  As you can see, on the right Postgres found the B-Tree node, which contains Captain Nemo.  For my test, I added 1000 names to the user table.  This child B-Tree node contains about 200 names (240, to be exact).  So the B-Tree algorithm significantly narrowed our search to the Postgres. <br><br>  To learn more about the specific algorithm used by Postgres to find the target B-Tree node among all its nodes, read the _bt_search function. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  _bt_search </h1>  <a href="http://doxygen.postgresql.org/nbtsearch_8c.html">view on postgresql.org</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/30e/1c2/b9c/30e1c2b9c8874539aad69afb27e8700b.png"></div><br><hr><br><h3>  <font color="#000000">Search for Captain Nemo inside a specific B-Tree site</font> </h3><br>  Now that Postgres has narrowed the search space to a B-Tree node containing about 200 names, he still needs to find Captain Nemo among them.  How does he do it?  Does he apply sequential scanning to this short list? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/340/ee0/5a3/340ee05a302c4260a02a4d1268daa9ed.png"></div><br>  Not.  To search for a key value inside a node of a tree, Postgres switches to using a binary search algorithm.  He starts comparing a key located at a 50% position in a tree node with ‚ÄúCaptain Nemo‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6fa/8dc/8c2/6fa8dc8c2c344f7e9b34e856f1677e85.png"></div><br>  Since Captain Nemo alphabetically goes after Breana Witting, Postgres jumps to the 75% position and makes another comparison: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b43/17b/abb/b4317babbfac472c84f2e7ccabb306c0.png"></div><br>  This time Captain Nemo goes to Curtis Wolf, so Postgres comes back a little.  After a few more iterations (Postgres took 8 comparisons to find Captain Nemo in my example), Postgres finally finds what we were looking for. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e49/b78/7bc/e49b787bcb6c421da827349215c3aee4.png"></div><br>  To learn more about how Postgres searches for a value in a particular B-Tree node, read the _bt_binsrch function: <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/35b/699/c9a/35b699c9ae8b4cc5f6d7437e14115b9c.png" alt="image" align="left"><br><h1>  _bt_binsrch </h1>  <a href="http://doxygen.postgresql.org/nbtsearch_8c.html">view on postgresql.org</a> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bd2/043/6aa/bd20436aabe9451da8748f6c2aa37781.png"></div><br><hr><br><h3>  <font color="#000000">There is still much to learn</font> </h3><br>  I don‚Äôt have enough space in this post to tell about all the exciting details regarding B-Tree, database indexes or Postgres internals ... maybe I should write the <i>Postgres</i> book <i>under a microscope</i> :) In the meantime, here are some interesting theoretical facts that you You can read in <a href="http://www.csd.uoc.gr/~hy460/pdf/p650-lehman.pdf">Efficient Locking for Concurrent Operations on B-Trees</a> or in other scientific work to which it refers. <br><br><ul><li>  Inserts in B-Tree: The most beautiful part of the B-Tree algorithm is adding new keys to the tree.  They are added in sorted order to the appropriate tree node, but what happens when there is no room for new keys?  In this case, Postgres divides the node into two, inserts a new key into one of them, and adds the key from the divided node to the parent node along with a pointer to the new child node.  Of course, there is a possibility that the parent node will also have to be split in order to add a new key, which will lead to a complex recursive operation. <br><br></li><li>  Deleting from B-Tree: the reverse operation is also interesting.  When a key is removed from a node, Postgres merges sibling nodes, if possible, by removing the key from their parent node.  This operation can also be recursive. <br><br></li><li>  B-Link- Tree: The work of Lehman and Yao talks about the innovation that they explored in relation to concurrency and blocking, when several threads use the same B-Tree.  As you remember, the Postgres code and algorithms must be multi-threaded, because many clients can search and modify the same index at the same time.  Adding another pointer from each B-Tree node to the next child node, the so-called ‚Äúright arrow‚Äù, can search one thread in the tree, even if the second thread divides the nodes without blocking the entire index: </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c21/f49/d88/c21f49d88c65444e9b48808b76026fa3.png"></div><br><h3>  <font color="#000000">Do not be afraid to explore the invisible part of the iceberg</font> </h3><br>  Professor Aronnaks risked his life and career to find the elusive Nautilus and join Captain Nemo in a long line of stunning underwater adventures.  We should do the same: do not be afraid to dive under the water - deep into the tools, languages ‚Äã‚Äãand technologies that you use every day.  You may know a lot about Postgres, but do you know how it works from the inside?  Take a look inside, and do not have time to look back, as you find yourself in an underwater adventure. <br><br>  Studying at work the computer science behind our applications is not just entertainment, but an important component of the developer development process.  Software development tools are improving with each passing year, writing websites and mobile applications is simplified, but we must not lose sight of the fundamental computer science we depend on.  We all stand on the shoulders of giants - people like Lehman and Yao, as well as open source developers who used their theories to create a Postgres.  Do not take the tools that you use every day for granted - study their device.  You will become wiser as a developer and find ideas and knowledge that were not even suspected. </div><p>Source: <a href="https://habr.com/ru/post/308752/">https://habr.com/ru/post/308752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308740/index.html">Configuring MongoDB ShardedCluster with X.509 Authentication</a></li>
<li><a href="../308742/index.html">Scalable solutions for EMV and mobile NFC payments in closed networks</a></li>
<li><a href="../308746/index.html">SWEET32 attack: Researchers have discovered a new way to crack the 3DES and Blowfish ciphers</a></li>
<li><a href="../308748/index.html">Published program Droidcon Moscow 2016</a></li>
<li><a href="../308750/index.html">Visual monitoring of the server infrastructure based on Nagios + Grafana</a></li>
<li><a href="../308754/index.html">Java benchmarks: random patterns and regular results</a></li>
<li><a href="../308756/index.html">Project Life in Production: Operational Tips</a></li>
<li><a href="../308762/index.html">Application Performance Management. HPE Recipe</a></li>
<li><a href="../308764/index.html">DDoS: IT Maniacs on the Point of Attack</a></li>
<li><a href="../308766/index.html">Horizon - realtime javascript backend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>