<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Underside client-side physics prediction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 I created a demo showing how to implement prediction on the client side of a player's physical movement in Unity - GitHub . 

 Introduction 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Underside client-side physics prediction</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="image"></div><br><h3>  TL; DR </h3><br>  I created a demo showing how to implement prediction on the client side of a player's physical movement in Unity - <a href="https://github.com/spectre1989/unity_physics_csp">GitHub</a> . <br><br><h3>  Introduction </h3><br>  In early 2012, I wrote a <a href="http://www.codersblock.org/blog//2012/02/client-side-prediction-in-unity.html">post</a> about how-to-implement forecasting on the client side of a player's physical movement in Unity.  Thanks to <a href="https://docs.unity3d.com/ScriptReference/Physics.Simulate.html">Physics.Simulate (),</a> the awkward workaround I described is no longer needed.  The old post is still one of the most popular on my blog, but for modern Unity, this information is already incorrect.  Therefore, I am releasing the 2018 version. <br><br><h3>  What is that on the client side? </h3><br>  In competitive multiplayer games, you should avoid cheating as much as possible.  Usually this means that a network model with an authoritarian server is used: clients send the information entered to the server, and the server turns this information into a player's movement, and then sends a snapshot of the resulting player state back to the client.  This causes a delay between pressing the key and displaying the result, which is unacceptable for any active games.  Client-side prediction is a very popular technique that hides a delay, predicting what the resulting movement will be and immediately showing it to the player.  When the client receives the results from the server, he compares them with what the client predicted, and if they are different, the forecast was wrong and needs to be corrected. <br><a name="habracut"></a><br>  Snapshots received from the server always come from the past regarding the predicted state of the client (for example, if data transfer from the client to the server and back takes 150 ms, then each snapshot will be delayed by at least 150 ms).  As a result of this, when a customer needs to correct an incorrect prediction, he must roll back to this point in the past, and then reproduce all the information entered in between to return to where he is.  If the player‚Äôs movement in the game is based on physics, then Physics.Simulate () is needed to simulate several cycles in one frame.  If the player‚Äôs movement uses only Character Controllers (or capsule cast, etc.), then you can do without Physics.Simulate () - and I assume that the performance will be better. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will use Unity to recreate the <a href="https://gafferongames.com/">Glenn Fiedler</a> <a href="https://code.google.com/archive/p/gamephysics/downloads">Zen of Networked Physics</a> network demo, which I have long liked.  The player has a physical cube to which he can apply forces, pushing him into the scene.  The demo simulates various network conditions, including latency and packet loss. <br><br><h3>  Getting Started </h3><br>  The first thing to do is turn off automatic physics simulation.  Although Physics.Simulate () allows us to tell the physical system when to start the simulation, by default it performs the simulation automatically based on the fixed time delta of the project.  Therefore, we will disable it in <strong>Edit-&gt; Project Settings-&gt; Physics</strong> , by clearing the " <strong>Auto Simulation</strong> " checkbox. <br><br>  To begin, we will create a simple single-user implementation.  Input is sampled (w, a, s, d to move and space to jump), and it all comes down to simple forces applied to the Rigidbody using AddForce (). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Moving a player while the network is not in use.</i> <br><br><h3>  Sending input to the server </h3><br>  Now we need to send input to the server, which also executes this motion code, snapshot the cube state and sends it back to the client. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  There is nothing special here, the only thing I want to draw attention to is adding the variable tick_number.  It is needed so that when the server sends snapshots of the cube's state back to the client, we can find out what client tact this state corresponds to so that we can compare this state with the predicted client (which we will add a little later). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  It's simple - the server is waiting for input messages, when it receives it, it simulates a beat.  Then it takes a snapshot of the resulting cube state and sends it back to the client.  You can see that the tick_number in the status message is one more than the tick_number in the input message.  This is done because it is intuitively more convenient for me personally to think of the ‚Äústate of the player to the beat of 100‚Äù as ‚Äúthe state of the player at the <strong>beginning of the</strong> beat of 100‚Äù.  Therefore, the state of the player in tact 100 in combination with the input of the player in tact 100 creates a new state for the player in tact 101. <br><br><h1>  State <sub>n</sub> + Input <sub>n</sub> = State <sub>n + 1</sub> </h1><br>  I do not say that you should take it the same way, the main thing is the constancy of the approach. <br><br>  You also need to say that I do not <em>send</em> these messages through a real socket, but imitate it by writing them in a queue, simulating delay and packet loss.  The scene contains two physical cubes - one for the client, the other for the server.  When updating the client cube, I disable the GameObject server cube, and vice versa. <br><br>  However, I do not simulate network bounce and packet delivery in the wrong order, and that is why I make the assumption that each input message received is newer than the previous one.  This simulation is needed in order to very easily execute the ‚Äúclient‚Äù and ‚Äúserver‚Äù in the same Unity instance so that we can combine the server and client cubes in the same scene. <br><br>  You can also notice that if the input message is reset and does not reach the server, the server simulates fewer ticks than the client, and therefore will create a different state.  This is true, but even if we simulated these omissions, the input could still be wrong, which would also lead to a different state.  We will deal with this problem later. <br><br>  It should also be added that in this example there is only one client, which simplifies the work.  If we had several clients, we would need a) when calling Physics.Simulate () to check that only one player‚Äôs cube is enabled on the server or b) if the server received input from several cubes, simulate them all together. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>75 ms latency (150 ms both ways)</i> <i><br></i>  <i>0% of lost packages</i> <i><br></i>  <i>Yellow Cube - Server Player</i> <i><br></i>  <i>Blue cube - the last snapshot received by the client</i> <br><br>  Everything looks good so far, but I was a bit selective with what I recorded on the video to hide a rather serious problem. <br><br><h3>  Failure of determinism </h3><br>  Look now at this: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Oh-her ...</i> <br><br>  This video was recorded without packet loss, however, the simulations still differ with absolutely identical input.  I don‚Äôt quite understand why this is happening - PhysX should be quite deterministic, so I find it striking that the simulations diverge so often.  This may be due to the fact that I constantly turn on and off the GameObject cubes, that is, it is possible that the problem will decrease when using two different Unity instances.  This may be a bug, if you see it in the code on GitHub, then let me know. <br><br>  Anyway, incorrect forecasts are an essential fact in client-side forecasting, so let's cope with them. <br><br><h3>  Can I rewind? </h3><br>  The process is quite simple - when a client predicts movement, it saves a state buffer (position and rotation) and input.  After receiving a status message from the server, it compares the received state with the predicted state from the buffer.  If they differ by too much, we redefine the state of the client cube in the past, and then simulate again all intermediate measures. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Buffered input data and status are stored in a very simple circular buffer, where the tick identifier is used as the index.  And I chose the value of 64 Hz for the clock frequency of physics, that is, the buffer for 1024 elements gives us space for 16 seconds, and this is much more than what we might need. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Correction included!</i> <br><br><h3>  Transfer excess input </h3><br>  Input messages are usually very small - the pressed buttons can be combined into a bit field that takes only a few bytes.  In our message, there is still a clock number that takes 4 bytes, but we can easily compress them using the 8-bit value with the carry (perhaps, the 0-255 interval will be too small, we can insure and increase it to 9 or 10 bits).  Anyway, these messages are quite small in size, which means that we can send a lot of input data in each message (in case previous input data was lost).  How far back should we go?  Well, the client knows the clock number of the last status message he received from the server, so there‚Äôs no point going back further than that clock.  We also need to impose a limit on the amount of redundant input data that is sent by the client.  In my demo, I did not do it, but it should be implemented in the finished code. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  This is a simple change; the client simply records the tick number of the last status message received. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  The input message sent by the client now contains a list of input data, not just one item.  The part with the beat number receives a new value - now it is the measure number of the first entry in this list. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  When the server receives an input message, it knows the number of the first input cycle and the amount of input data in the message.  Therefore, it can calculate the time period of the last input in the message.  If this last clock is greater than or equal to the server clock number, then it knows that the message contains at least one input that the server has not yet seen.  If so, it simulates all new input data. <br><br>  You may have noticed that <em>if</em> we limit the amount of redundant input data in the input message, then with a sufficiently large number of lost input messages, we will have a simulation gap between the server and the client.  That is, the server can simulate a cycle of 100, send a status message to start cycle 101, and then receive an input message starting at cycle 105. In the above code, the server will go to 105, it will not try to simulate intermediate cycles based on the latest known input data.  Whether you need this depends on your decision and on what the game should be.  Personally, I would not force the server to speculate and move a player around the map due to the poor network condition.  I think it is better to leave the player in place until the connection is restored. <br><br>  In the ‚ÄúZen of Networked Physics‚Äù demo there is a function for the client to send ‚Äúimportant moves‚Äù, that is, it sends redundant input data only when it is different from the input previously transmitted.  This can be called delta-compression input, and with it, further reduce the size of input messages.  But so far I have not done this, because there is no network load optimization in this demo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Before sending redundant input data: if 25% of packets are lost, the cube movement is slow and jerky, it continues to be thrown back.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>After sending redundant input data: with a loss of 25% of the packets, there is still a jerky correction, but the cubes move at an acceptable speed.</i> <br><br><h3>  Variable snapshot frequency </h3><br>  In this demo, the frequency with which the server sends snapshots to the client varies.  With a reduced frequency, the client will need more time to get a correction from the server.  Therefore, when the client makes a mistake in the forecast, then before receiving the status message, he may deviate even more, which will lead to a more noticeable correction.  With a high frequency of snapshots, the loss of packets is much less important, so the client does not have to wait long to receive the next snapshot. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Snapshot frequency 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Snapshot frequency 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Snapshot frequency 2 Hz</i> <br><br>  Obviously, the higher the frequency of snapshots, the better, so you should send them as often as possible.  But it still depends on the amount of additional traffic, its cost, the availability of dedicated servers, the computational costs of servers, and so on. <br><br><h3>  Smoothing correction </h3><br>  We create incorrect predictions and get a bit of a correction more often than we would like.  Without proper access to the Unity / PhysX integration, I‚Äôm almost unable to debug these erroneous predictions.  I said this before, but I will repeat it again - if you find something related to physics, in which I am mistaken, then let me know about it. <br><br>  I bypassed the solution to this problem, smearing the cracks with the good old smoothing!  When a correction occurs, the client simply smoothes the position and turn of the player towards the correct state for several frames.  The physical cube itself is corrected instantly (it is invisible), but we have a second display-only cube that allows smoothing. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  When an erroneous forecast occurs, the client tracks the difference in position / rotation after correction.  If the total distance of the position correction is more than 2 meters, then the cube just moves with a jerk - the anti-aliasing would still look bad, so let it at least return to the correct state as soon as possible. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  In each frame, the client performs lerp / slerp in the direction of the correct position / rotation of 10%, this is the standard power-law approach to motion averaging.  It depends on the frame rate, but for the purposes of our demo this is quite enough. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms latency</i> <i><br></i>  <i>Loss of 10% of packages</i> <i><br></i>  <i>Without smoothing, the correction is very noticeable.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms latency</i> <i><br></i>  <i>Loss of 10% of packages</i> <i><br></i>  <i>With smoothing, the correction is much more difficult to notice.</i> <br><br>  The end result works quite well, I want to create a version of it that will actually send packets, and not simulate them.  But at the very least, this is a proof of the concept of a client-side forecasting system with real physical objects in Unity without the need to use physical plug-ins and the like. </div><p>Source: <a href="https://habr.com/ru/post/432190/">https://habr.com/ru/post/432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432180/index.html">How to pump your career through GitHub</a></li>
<li><a href="../432182/index.html">We take away mail without sms and registration</a></li>
<li><a href="../432184/index.html">Problem personalities among testers</a></li>
<li><a href="../432186/index.html">Using STP to create p2p channels</a></li>
<li><a href="../432188/index.html">Hackers from the APT28 group attacked email-boxes of hundreds of employees of the Czech ministries</a></li>
<li><a href="../432192/index.html">4 signs that you are not ready to implement a project management solution</a></li>
<li><a href="../432196/index.html">About the composition of functions in JavaScript</a></li>
<li><a href="../432198/index.html">Delivery Manager - a new role in the world of Agile</a></li>
<li><a href="../432200/index.html">How Ivan stand conversion investigated</a></li>
<li><a href="../432202/index.html">Generation of type objects on the fly (or madness with Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>