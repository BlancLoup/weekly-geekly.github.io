<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Signal Practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to capture a little experience with signals in Linux. Below are examples of the use of the most significant structures in this area. I will try...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Signal Practice</h1><div class="post__text post__text-html js-mediator-article">  I want to capture a little experience with signals in Linux.  Below are examples of the use of the most significant structures in this area.  I will try to put everything into separate shelves so that it is always easy to look and remember what to use and how. <br><a name="habracut"></a><br>  Important facts about signals: <br><ul><li>  Signals in Linux play the role of a certain means of interprocess communication (as well as inter-thread communication). </li><li>  Each process has a mask of signals (signals that it ignores). </li><li>  Each thread (thread), as well as the process, has its own mask of signals </li><li>  When a signal is received (if it is not blocked), the process / thread is interrupted, control is transferred to the signal handler function, and if this function does not terminate the process / thread, control is transferred to the point at which the process / thread was interrupted </li><li>  You can set your signal handler function, but only for the process.  This handler will be called for each thread generated from this process. </li></ul><br>  I will not delve into the theory of signals, where from why and where.  I am primarily interested in the mechanism of working with them.  Therefore, SIGUSR1 and SIGUSR2 will be used as the signals used, these are the only two signals put at the user's disposal.  And also I will try to pay more attention to the inter-stream interaction of signals. <br>  So let's go. <br><br><h1>  Function signal handler </h1><br>  This function is called when a process (or thread) receives a non-blocking signal.  The default handler terminates our process (thread).  But we can define the handlers for the signals of interest to us.  It should be very careful about writing a signal handler; it is not just a function that runs on a callback; the current execution flow is interrupted without any preparatory work, so global objects can be in a non-consistent state.  The author does not undertake to give a set of rules, since he does not know them himself, and calls for <a href="http://habrahabr.ru/users/kobolog/" class="user_link">Kobolog to</a> follow the advice (I hope he doesn‚Äôt mind that I refer to him) and to study at least this <a href="http://www.dore.ru/perl/nntp.pl%3Ff%3D1%26gid%3D22%26mid%3D22664">FAQ</a> material. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hdl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  You can install a new signal handler with two functions. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">sighandler_t</span></span> signal(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signum, <span class="hljs-keyword"><span class="hljs-keyword">sighandler_t</span></span> handler);</code> </pre><br>  Which accepts a signal number, a pointer to a handler function (or SIG_IGN (ignore signal) or SIG_DFL (default handler)), and returns the old handler.  SIGKILL and SIGSTOP signals cannot be "intercepted" or ignored.  Using this feature is highly discouraged because: <br><ul><li>  the function does not block receiving other signals while the current handler is running, it will be interrupted and a new handler will be executed </li><li>  after the first receipt of the signal (for which we installed our handler), its handler will be reset to SIG_DFL </li></ul><br>  These shortcomings have no function. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sigaction *act, struct sigaction *oldact)</span></span></span></span>;</code> </pre><br>  Which also accepts a signal number (except SIGKILL and SIGSTOP).  The second argument is the new description for the signal; the third value returns the old value.  The struct sigaction structure has the following fields of interest <br><ul><li>  sa_handler - similar to sighandler_t in the signal function </li><li>  sa_mask - mask of signals that will be blocked while our handler is executed.  + the default is also blocked </li><li>  sa_flags - allows you to specify additional actions when processing a signal about which it is better to read <a href="http://www.opennet.ru/man.shtml%3Ftopic%3Dsigaction%26russian%3D0%26category%3D%26submit%3D%25F0%25CF%25CB%25C1%25DA%25C1%25D4%25D8%2Bman">here</a> </li></ul><br>  Using this function looks completely simple. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">act</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(act)); act.sa_handler = hdl; <span class="hljs-keyword"><span class="hljs-keyword">sigset_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; sigemptyset(&amp;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>); sigaddset(&amp;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, SIGUSR1); sigaddset(&amp;<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>, SIGUSR2); act.sa_mask = <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; sigaction(SIGUSR1, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>); sigaction(SIGUSR2, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Here we set up our handler for SIGUSR1 and SUGUSR2 signals, and also indicated that it is necessary to block the same signals while the handler is running. <br>  With a signal handler there is one not very convenient moment, it is installed on the whole process and all generated threads at once.  We do not have the ability for each thread to set its own signal handler. <br>  But it should be understood that when a signal is addressed to a process, the handler is invoked for the main thread (representing the process).  If the signal is addressed to a thread, then the handler is called from the context of this thread.  <a href="http://pastebin.com/knV8uq2C">See example 1</a> . <br><br><h1>  Signal blocking </h1><br>  In order to block some signals for the process, you need to add them to the signal mask of this process.  To do this, use the function <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigprocmask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> how, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sigset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">set</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sigset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *oldset)</span></span></span></span>;</code> </pre><br>  We can add new signals (SIG_BLOCK) to the already existing signal mask, we can remove some signals from this mask (SIG_UNBLOCK), and also set our signals mask completely (SIG_SETMASK). <br>  To work with the signal mask inside the thread, the function is used. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_sigmask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> how, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sigset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">set</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sigset_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *oset)</span></span></span></span>;</code> </pre><br>  which allows you to do everything too, but for each thread individually. <br>  It is not possible to block SIGKILL or SIGSTOP signals using these functions.  Attempts to do this will be ignored. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  sigwait </h1><br>  This function allows you to pause a process (or thread) until the desired signal (or one of the signal masks) is received.  A feature of this function is that when a signal is received, the signal handler function will not be called.  <a href="http://pastebin.com/QFH1e2K8">See example 2</a> . <br><br><h1>  Signal send </h1><br>  Two functions can be used to send a signal to a process. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">raise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig)</span></span></span></span>;</code> </pre><br>  From the first, everything is clear.  The second is needed in order to send a signal to itself, and in essence is equivalent to kill (getpid (), signal).  The getpid () function returns the PID of the current process. <br>  To send a separate thread signal, use the function <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_kill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thread, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sig)</span></span></span></span>;</code> </pre><br><br><h1>  An example of using signals </h1><br>  Everything that I described above does not answer the question "Why should I use signals?"  Now I would like to give a real example of the use of signals, and where they simply can not do without. <br>  Imagine that you want to read or write some data to a device, but this can lead to blocking.  Well, for example, reading in the case of working with sockets.  Or maybe an entry in the pipe.  You can put it in a separate thread, so as not to block the main work.  But what to do when you need to complete the application?  How to interrupt the blocking operation IO correctly?  It would be possible to set a timeout, but this is not a very good solution.  There are more convenient means for this: the pselect and ppoll functions.  The difference between them is only in usability, their behavior is the same.  First of all, these functions are needed for multiplexing work with IO (select / poll).  The prefix 'p' at the beginning of the function indicates that this function can be correctly interrupted by a signal. <br><br>  So, we formulate the requirement: <br>  It is necessary to develop an application that opens a socket (for UDP simplicity) and performs a read operation in the stream.  This application should be completed without any delay, at the request of the user. <br>  The thread function looks like this. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blocking_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stop) { <span class="hljs-comment"><span class="hljs-comment">//   ,     ? std::cout &lt;&lt; "Thread was aborted\n"; pthread_exit((void *)0); } //   SIGINT sigset_t set, orig; sigemptyset(&amp;set); sigaddset(&amp;set, SIGINT); sigemptyset(&amp;orig); pthread_sigmask(SIG_BLOCK, &amp;set, &amp;orig); if(stop) { //         //       std::cout &lt;&lt; "Thread was aborted\n"; pthread_sigmask(SIG_SETMASK, &amp;orig, 0); pthread_exit((void *)0); } //       SIGINT std::cout &lt;&lt; "Start thread to blocking read\n"; // ... // ,  ,    ppoll ppoll((struct pollfd*) &amp;clients, 1, NULL, &amp;orig); if(stop) { //      std::cout &lt;&lt; "Thread was aborted\n"; close(sockfd); pthread_sigmask(SIG_SETMASK, &amp;orig, 0); //   SIGINT    } //    ,    .     //        " " close(sockfd); pthread_exit((void *)0); }</span></span></code> </pre><br>  <b>stop</b> is a global boolean flag which is set to <b>true by</b> our handler, which tells the thread to terminate. <br>  The logic of work is as follows: <br><ul><li>  check that while the thread started it has not yet been completed </li><li>  block the final signal </li><li>  check that while blocked, we were not willing to complete </li><li>  call ppoll passing as the last parameter the mask of signals by which the signal is waiting </li><li>  after exiting ppoll, we check that it was not due to the completion signal </li></ul><br>  Here is the main function <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">act</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(act)); act.sa_handler = hdl; sigemptyset(&amp;act.sa_mask); sigaddset(&amp;act.sa_mask, SIGINT); sigaction(SIGINT, &amp;act, <span class="hljs-number"><span class="hljs-number">0</span></span>); ... pthread_kill(th1, SIGINT); ... }</code> </pre><br>  We install our handler for SIGINT, and when we need to terminate the child stream, send it a signal. <br>  Full listing, <a href="http://pastebin.com/bTL3Xu2V">see example 3</a> . <br><br>  In my opinion, the disadvantage of this method is that in the case of several threads we can complete them all at once.  There is no possibility to set your own signal handler for each thread.  Thus, it is not possible to implement a full interflow flow through signals.  Linux way it does not provide. <br><br>  Ps.  The source codes are placed on the PasteBin service (I do not give the link, otherwise they will consider it as an advertisement). <br>  Pps.  Please forgive me for the abundance of errors.  Language, my weak side.  Thanks to everyone who helped fix them. <br><br><hr><br>  This article does not claim to have a full (and deep) description of working with signals and is aimed primarily at those who have not come across the concept of "signal" up to this point.  For a more in-depth understanding of the operation of signals, the author calls to contact more competent sources and to get acquainted with constructive criticism in the comments. </div><p>Source: <a href="https://habr.com/ru/post/141206/">https://habr.com/ru/post/141206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141197/index.html">We turn over the Internet on April 1st</a></li>
<li><a href="../141199/index.html">We translate into code 5 really useful templates of adaptive markup.</a></li>
<li><a href="../141200/index.html">Fearless Genius: The Digital Revolution in Silicon Valley 1985-2000 (1-25)</a></li>
<li><a href="../141201/index.html">Android application architecture. Part III - the main parts of the application</a></li>
<li><a href="../141202/index.html">Bmorn V99 Tablet Review</a></li>
<li><a href="../141207/index.html">Designing web applications using Data Management System (based on scaffolding technology)</a></li>
<li><a href="../141208/index.html">Kyiv.py # 6. A small IMHO meeting report</a></li>
<li><a href="../141209/index.html">Mock Module: Dummy Mockups for Testing</a></li>
<li><a href="../141210/index.html">Creative Commons and Databases</a></li>
<li><a href="../141212/index.html">XBOX 360 xk3y. Part 2 - Installation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>