<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Part 2: Using Cypress UDB PSoC Controllers to Reduce the Number of Interrupts in a 3D Printer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time, we looked at the option of generating pulses for stepper motors, partly moved from the software to the microprogram level. In case of compl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Part 2: Using Cypress UDB PSoC Controllers to Reduce the Number of Interrupts in a 3D Printer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/vx/mr/gy/vxmrgyrhaaffninezudmxyiex9c.jpeg"><br><br>  <a href="https://habr.com/post/433800/">Last time,</a> we looked at the option of generating pulses for stepper motors, partly moved from the software to the microprogram level.  In case of complete success, this promises no need to handle interrupts that come in at frequencies up to 40 KHz.  But that option has some obvious flaws.  First, accelerations are not supported there.  Secondly, the granularity of the permissible frequencies of steps in that decision is hundreds of hertz (for example, generation of frequencies of 40,000 Hz and 3,996 Hz is possible, but generation of frequencies with a value between these two values ‚Äã‚Äãis impossible). <br><a name="habracut"></a><br><h2>  Implementation of accelerations </h2><br>  Is it possible to eliminate these shortcomings, using the tools of the same UDB, without complicating the system?  Let's figure it out.  Let's start with the most difficult - with accelerations.  Accelerations are added at the beginning and end of the path.  First, if a high frequency pulse is immediately applied to a stepping motor, it will need more current to start work.  The high current allowed is heat and noise, so it‚Äôs best to limit it.  But then the engine can skip steps at the start.  So accelerate the engine better smoothly.  Secondly, if a heavy head stops abruptly, then transient processes occur due to inertia.  Waves are visible on the plastic.  Therefore, it is necessary to smoothly not only accelerate, but also stop the head.  Classically, the graph of engine speed is represented as a trapezoid.  Here is a snippet from the Marlin ‚Äúfirmware‚Äù source code: <br><br><img src="https://habrastorage.org/webt/wm/gg/ce/wmggcetcc0vy5tfgs3xsr2ewwoc.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will not even try to figure out whether it can be implemented using UDB.  This is due to the fact that another type of acceleration is now coming into fashion: S-Curve, not trapezoidal.  Their schedule looks like this: <br><br><img src="https://habrastorage.org/webt/rs/hy/q9/rshyq94_sz6et-lgsbrpprdmyks.png"><br><br>  This is definitely not for UDB.  Give up  Not at all!  I have already noted that UDB does not implement a hardware interface for me, but simply allows you to transfer a part of the code from the software to the firmware level.  Let the profile calculate the CPU, and the formation of step pulses still performs UDB.  The central processor has a lot of time for calculations.  The task of eliminating frequent interruptions will continue to be quite elegant, and no one has planned to completely remove the process to the firmware level. <br><br>  Of course, the profile will need to be prepared in memory, and the UDB will take data from there using DMA.  But how much memory is required?  One millimeter needs 200 steps.  Now with 24-bit encoding, this is 600 bytes per 1 mm of head movement!  Again, remember about not so frequent, but still constant interruptions to transfer all the fragments?  Not really!  The fact is that the PSoC DMA mechanism is based on descriptors.  After completing the task from one descriptor, the DMA controller proceeds to the next.  And so, along the chain, you can use quite a lot of descriptors.  We illustrate this with some drawing from the official documentation: <br><br><img src="https://habrastorage.org/webt/ju/hv/6b/juhv6bqptp3uagog5bfgxlmxw0q.png"><br><br>  Actually, this mechanism can also be used by building a chain of three descriptors: <br><br><table><tbody><tr><th>  No </th><th>  Explanation </th></tr><tr><td>  one </td><td>  From memory in FIFO with address increment.  Indicates a section with an acceleration profile. </td></tr><tr><td>  2 </td><td>  From memory in FIFO without address increment.  Sends all the time to the same word in memory for constant speed. </td></tr><tr><td>  3 </td><td>  From memory in FIFO with address increment.  Indicates a section with a braking profile. <br></td></tr></tbody></table><br>  It turns out that the main path is described in step 2, and there is physically used the same word that defines a constant speed.  Memory consumption is not great.  In reality, the second descriptor can be physically represented by two or three descriptors.  This is due to the fact that the maximum length of the transfer, according to the statements of TRM, may be 64 kilobytes (the amendment will be lower).  That is, 32767 words.  That at 200 steps per millimeter will correspond to a path of 163 millimeters.  You may have to make a segment of two or three parts, depending on the maximum distance that the engine can go at a time. <br><br>  However, to save memory (and the consumption of UDB blocks), I propose to abandon the 24-bit DatapPath blocks by switching to more economical 16-bit ones. <br><br>  <b>So.</b>  <b>The first sentence for revision.</b> <b><br><br></b>  <b>Arrays encoding step lengths are prepared in memory.</b>  <b>Further, this information goes to UDB using DMA.</b>  <b>The straight-line segment is encoded by an array of one element, the DMA block does not increment the address, all the time choosing the same element.</b>  <b>Acceleration, rectilinear movement and braking are connected by means available in the DMA controller.</b> <br><br><h2>  Fine tuning of the average frequency </h2><br>  Now consider how to overcome the problem of frequency granularity.  Of course, it will not be possible to set it.  But, in fact, the original "firmware" also can not do this.  Instead, they use the Brezenham algorithm.  Some steps add a delay of one cycle.  As a result, the average frequency becomes intermediate, between a smaller and larger value.  By adjusting the ratio of standard and extended periods, you can smoothly change the average frequency.  If the speed we now have is not set via the data register, but is transmitted via the FIFO, and the number of pulses is generally set via the number of words transmitted over the DMA, both data registers in the UDB are released.  In addition, one of the batteries is released, which counted the number of pulses.  Here we build a certain PWM on them. <br><br>  Usually in the ALU registers are compared and assigned to the same index.  When one register has an index of 0, and the other has 1, not any variant of the operation can be implemented.  But I managed to add solitaire from the registers, at which PWM can be done.  It turned out as shown in the figure. <br><br><img src="https://habrastorage.org/webt/nc/yv/vq/ncyvvqcqptj3lm4an82idlrrl-c.png"><br><br>  When the condition A0 &lt;D1 is fulfilled, we will add an extra beat to the given pulse length.  When the condition is not met - we will not. <br><br><h2>  Spherical horse in normal conditions </h2><br>  So, we begin to modify the developed block for UDB, taking into account the new architecture.  Replace Datapath bit: <br><br><img src="https://habrastorage.org/webt/cj/-m/ae/cj-mae3coaxgzro0er5mkraun4q.png"><br><br>  We will need a lot more exits from Datapath than last time. <br><br><img src="https://habrastorage.org/webt/ua/td/hn/uatdhnswe_uzmqinll0wyhsyifg.png"><br><br>  Double-clicking on them, see the details: <br><br><img src="https://habrastorage.org/webt/vq/3p/24/vq3p24frqv0uiumytbvn-ewhi1w.png"><br><br>  The <b>State</b> variable has more discharges, let's not forget to connect the senior !!!  In the old version there was a constant 0. <br><br><img src="https://habrastorage.org/webt/0l/dm/fy/0ldmfyci2byicjdsksvkdkg8k04.png"><br><br>  The transition graph of the machine I have turned out like this: <br><br><img src="https://habrastorage.org/webt/hb/5u/nq/hb5unqu_fmfc6sd9k7m3_x0wr7s.png"><br><br>  We are in the <b>Idle</b> state while FIFO1 is empty.  By the way, working with FIFO1, and not FIFO0, is the result of the very addition of solitaire.  Register A0 is used to implement PWM, so the pulse duration is determined by register A1.  And I can download it only from FIFO1 (perhaps there are other secret methods, but I don‚Äôt know them).  Therefore, DMA downloads the data to FIFO1, and it is exactly as <b>‚ÄúNot Empty‚Äù</b> for FIFO1 that the <b>Idle</b> state will exit. <br><br>  ALU in <b>IDLE</b> state zeros register A0: <br><br><img src="https://habrastorage.org/webt/1r/i5/-i/1ri5-iydlu00cfobufepmiaqucg.png"><br><br>  This is necessary so that at the beginning of work, PWM always starts work from the beginning. <br>  But here in the FIFO data fell.  The machine enters the state <b>LoadData</b> : <br><br><img src="https://habrastorage.org/webt/3v/rf/dx/3vrfdxwme_jw6m69bwrpybhiots.png"><br><br>  In this state, the ALU loads the next word from the FIFO into the register A1.  Along the way, in order not to create unnecessary states, the value of the A0 counter, which is used to work with PWM, increases: <br><br><img src="https://habrastorage.org/webt/t4/ki/je/t4kijee95z-kbmn1n3ikcgtc9qk.png"><br><br>  If the counter A0 has not yet reached the value D0 (that is, the condition A0 &lt;D0 triggers, setting the flag <b>NoNeedReloadA0</b> ), we go to the <b>One</b> state.  Otherwise, the state <b>ClearA0</b> . <br><br>  In the <b>ClearA0</b> ALU state, the value of A0 simply <b>vanishes</b> , starting a new PWM cycle: <br><br><img src="https://habrastorage.org/webt/0_/pj/ah/0_pjahunjhl34izkpv5k9lplxem.png"><br><br>  after which the machine also goes into the <b>One</b> state, just one clock later. <br><br>  State <b>One</b> is familiar to us from the old version of the machine.  ALU does not perform any functions in it. <br><br>  And so - in this state, a unit is generated at the output of <b>Out_Step</b> (here the optimizer worked better when the unit is generated by the condition, it was revealed experimentally). <br><br><img src="https://habrastorage.org/webt/aq/mj/ml/aqmjmluzxutxzq_caddtls15hfc.png"><br><br>  We are in this state until a seven-bit counter already known to us is reset.  But if earlier we came out of this state along the same path, now there can be two paths: a straight line and a delay for a beat. <br><br><img src="https://habrastorage.org/webt/53/fk/qc/53fkqcxnlvsf52sxzb8e1ijnpkk.png"><br><br>  We‚Äôll go to the ExtraTick state if the <b>AddCycle</b> flag is <b>set</b> , which is assigned to the condition A0 &lt;D1.  In this state, the ALU performs no useful actions.  It's just that the loop is executed 1 clock longer.  Then all the ways converge in a state of <b>Delay</b> . <br><br>  This state measures the pulse duration.  Register A1 (loaded while still in the <b>Load</b> state) decreases until it reaches zero. <br><br><img src="https://habrastorage.org/webt/bi/ct/jt/bictjtwgqikkvuz4pqmp7owacii.png"><br><br>  Further, depending on whether there are additional data in the FIFO or not, the machine will go to the next portion of the sample in the <b>Load</b> state or in the <b>Idle</b> state.  Let's see it not in the figure (there are long arrows, everything will be fine), but in the form of a table, double clicking on the <b>Delay</b> state: <br><br><img src="https://habrastorage.org/webt/bb/cr/dq/bbcrdq1jfhxret5vbaoexfsr-iq.png"><br><br>  Now exits from UDB.  I redid the flag in the <b>Idle</b> state for an asynchronous comparison (in the previous version there was a trigger that was cocked and reset in various states), since for it the optimizer showed the best result.  Plus, the <b>Hungry</b> flag was added, signaling the DMA unit to be ready to receive data.  He wound up on the flag <b>"FIFO1 not crowded</b> . <b>"</b>  Once not full, the DMA can load the next data word there. <br><br><img src="https://habrastorage.org/webt/w8/ea/b-/w8eab-2dwdxvtvyr3hfukjrev9w.png"><br><br>  On the machine part - everything. <br><br>  We add DMA blocks to the scheme of the main project.  Interrupt, I still started on the end of DMA flags, but not the fact that this is correct.  When the process of direct memory access is completed, you can start a new process that belongs to the same segment, but you cannot start filling in information about the new segment.  In the FIFO is still from three to four elements.  At this time, it is still impossible to reprogram the registers D0 and D1 of the block based on UDB, they are still needed for operation.  Therefore, it is possible that interrupts will be added later on the basis of the <b>Out_Idle</b> outputs.  But that kitchen will no longer be related to programming UDB blocks, so we will only mention it in passing. <br><br><img src="https://habrastorage.org/webt/4o/g7/y2/4og7y21diqgqr6qn7_iehukiqho.png"><br><br><h2>  Software experiments </h2><br>  Since everything is not known now, we will not write any special functions.  All checks will be carried out "In the forehead."  Then, based on successful experiments, the API functions can be written.  So.  The <b>main ()</b> function is minimalistic.  It simply configures the system and calls the selected test. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CyGlobalIntEnable; <span class="hljs-comment"><span class="hljs-comment">/* Enable global interrupts. */</span></span> <span class="hljs-comment"><span class="hljs-comment">// isr_1_StartEx(StepperFinished); StepperController_X_Start(); StepperController_Y_Start(); StepperController_Z_Start(); StepperController_E0_Start(); StepperController_E1_Start(); // TestShortSteps(); TestWithPacking (); for(;;) { }</span></span></code> </pre> <br>  Let's try to send a burst of pulses by calling the function, checking the fact of inserting an additional pulse.  The function call is simple: <br><br><pre> <code class="plaintext hljs">TestShortSteps();</code> </pre><br>  But the body needs clarification. <div class="spoiler">  <b class="spoiler_title">First I give the whole function.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestShortSteps() { //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Now consider the important parts of it. <br><br>  If the length of the positive part of the pulse is equal to 92 cycles, then the oscilloscope will not see if there is a single-stroke inset in the negative part or not.  The scale will not be the same.  It is necessary to make the positive part as short as possible so that the total impulse would be comparable in scale with the inserted beat.  Therefore, I forcibly change the period of the counter, which sets the duration of the positive part of the pulse: <br><br><pre> <code class="plaintext hljs"> //   ,   //      //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6);</code> </pre><br>  But why as much as six cycles?  Why not three?  Why not two?  Why, in the end, not one?  It is a sad story.  If the positive impulse is shorter than 6 clocks, then the system does not work.  A long debugging on the oscilloscope with the output of test lines outward showed that DMA is not a quick thing.  If an automaton works less than a certain duration, then by the time it exits the <b>Delay</b> state, the FIFO is most often empty.  No new data word can be placed in it yet!  And only when the positive part of the pulse has a duration of 6 cycles, the FIFO is guaranteed to have time to boot ... <br><br><h2>  Lyrical digression about latency </h2><br>  Another fix idea that sits in my head is hardware acceleration of certain functions of the core of our MAXROS.  But alas, all my best ideas are broken about those same latencies. <br><br>  It was the case, I studied the development of Bare Metal applications for Cyclone V SoC.  But it turned out that working with single FPGA registers (when alternately writing into them, then reading from them) reduces the work of the core hundreds of (!!!) times.  You heard right.  It is in the hundreds.  And all this is poorly documented, but I first smelled it, and then I proved from fragments of phrases from the documentation that the latency was at fault when requests passed through a bunch of bridges.  If you need to drive a large array, there will also be latency, but in terms of one pumped word, it will not be significant.  When requests are single (and hardware acceleration of the OS kernel implies them), the slowdown is exactly hundreds of times.  It will be much faster to do everything in a purely program way when the program works with the main memory through the cache at a breakneck speed. <br><br>  I also had some plans for PSoC.  In appearance, you can wonderfully search for data in an array using DMA and UDB.  What is really there!  Due to the DMA descriptor structure of these controllers, it would be possible to conduct a complete hardware search in the linked lists!  But having received the plug described above, I realized that it is also associated with latency.  Here this latency is beautifully described in the documentation.  Both in TRM on the family, and in a separate document <b>AN84810 - PSoC 3 and PSoC 5LP Advanced DMA Topics</b> .  Section 3.2 is devoted to this.  So the next hardware acceleration is canceled.  A pity.  But, as Semen Semenovich Gorbunkov said: "We will search." <br><br><h2>  We continue program experiments </h2><br>  Next, I set the parameters of the Brezenham algorithm: <br><br><pre> <code class="plaintext hljs"> //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2);</code> </pre><br>  Well, the regular code goes further, transmitting an array of words via DMA to FIFO1 of the engine control unit X. <br><br>  The result requires some explanation.  Here he is: <br><br><img src="https://habrastorage.org/webt/bi/hg/ie/bihgiepg_iskg-wor_g4iqnv1ti.png"><br><br>  Red shows the value of the counter A0, when the machine is in the state <b>One</b> .  Green asterisk shows the cases when the delay is inserted due to finding the automaton in the <b>ExtraTick</b> state.  There are still cycles where the delay is due to being in the <b>ClearA0</b> state, they are marked with a blue grid. <br><br>  As you can see, at the first entry, the very first delay is lost.  This is due to the fact that A0 is cleared while in <b>Idle</b> , but increases when entering <b>LoadData</b> .  Therefore, to the analysis point (exit from the <b>One</b> state) it is already equal to one.  The score starts with her.  But in general, it will not affect the average frequency.  It just needs to be kept in mind.  How to keep in mind that when A0 is reset, the beat will also be inserted.  It must be taken into account when calculating the average frequency. <br><br>  But in general, the number of pulses is correct.  Their duration is also believable. <br>  Let's try to program a more real chain of handles, <br><br><div class="spoiler">  <b class="spoiler_title">consisting of a plot of acceleration, linear motion and braking.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void TestWithPacking(int countOnLinearStage) { //   ,   //     . //   ,  DMA    !!! //    ,   !!! StepperController_X_SingleVibrator_WritePeriod (6); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //    static const uint16 accelerate[] = {0x0010,0x0008,0x0004}; //    static const uint16 deccelerate[] = {0x004,0x0008,0x0010}; //  .    . static const uint16 steps[] = {0x0001}; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //   uint8 tdDeccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdDeccelerate, sizeof(deccelerate), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdDeccelerate, LO16((uint32)deccelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //       uint8 tdSteps = CyDmaTdAllocate(); //   !!! //     !!! CyDmaTdSetConfiguration(tdSteps, countOnLinearStage, tdDeccelerate, /*TD_INC_SRC_ADR |*/ TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdSteps, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //   //     !!! uint8 tdAccelerate = CyDmaTdAllocate(); CyDmaTdSetConfiguration(tdAccelerate, sizeof(accelerate), tdSteps, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(tdAccelerate, LO16((uint32)accelerate), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, tdAccelerate); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  First, let's call for the same ten steps (in fact, 20 bytes go to DMA): <br><br><pre> <code class="plaintext hljs">TestWithPacking (20);</code> </pre><br>  The result corresponds to the expectation.  At the beginning is visible acceleration.  And the exit to <b>IDLE</b> (blue ray) occurs with a large delay from the last pulse, it was then that the last step was completely completed, its value is approximately equal to the first one. <br><br><img src="https://habrastorage.org/webt/5y/tb/na/5ytbna9ixcuxv5-i35tinzixy0e.png"><br><br><h2>  Real horse in normal conditions </h2><br>  When reworking the equipment, I somehow famously jumped from a 24-bit pulse width setting to a 16-bit one.  But we found out that it is impossible to do this: the minimum frequency of the pulses will be too high.  I did it intentionally.  The fact is that the technique of expanding the 16-bit counter bit was so complicated that if I began to describe it with the main automaton, it would divert all attention to myself.  Therefore, we consider it separately. <br><br>  The battery is 16-bit.  I decided to add to it the ‚Äúseven-bit counter‚Äù entity in the older bits.  What is this seven-bit counter?  This is a design that exists in each UDB block (the UDB base block has a bit width of all 8-bit registers, the increase in bit depth is determined by the combination of the blocks into groups).  From the same resources the <b>Control / Status</b> registers can be implemented.  Now we have one counter for 16 data bits and not a single <b>Control / Status</b> pair.  So, adding one more counter to the system, we will not pull off extra resources.  We just take what is already allocated to us.  Well, fine!  We make the high byte of the pulse width counter through this mechanism and obtain the total bit width of the pulse width counter, equal to 23 bits. <br><br><img src="https://habrastorage.org/webt/_k/nc/-h/_knc-hzlxwos6a8jdzopy3pj2ww.png"><br><br>  First I will talk about what I was thinking.  I thought that after leaving the <b>Delay</b> state, I would check the fact of the completion of the account of this additional counter.  If he has not yet finished counting, I will decrease its value and again switch to the <b>Delay</b> state.  If I counted, the logic will remain the same, without adding extra clock cycles. <br><br>  Moreover, the documentation on this counter says that I am right.  Literally it says: <br><blockquote>  Period <br>  Defines the initial period register value.  For a period of N clocks, it should be set to the value of N-1.  N-1 down to 0.  <b><i>The terminal count output is not supported at this constant high state.</i></b> </blockquote>  Life has shown that everything is different.  I brought the state of the <b>terminal count</b> line to the oscilloscope and observed its value with the preloaded zero in the <b>Period</b> and during software loading.  Alas and ah.  There was no <b>constant high state</b> ! <br><br>  Through trial and error, I managed to make the system work correctly, but for this, at least one subtraction from the counter should happen!  The new state of <b>"subtraction" is</b> not the side.  He had to wedge in the required path.  It is located in front of the <b>Delay</b> state and is called <b>Next65536</b> . <br><br><img src="https://habrastorage.org/webt/cp/6f/oz/cp6fozy_kflvs6eu6w-ho9ebmcu.png"><br><br>  The ALU in this state does not perform any useful actions.  Actually, only a new counter responds to the fact of being in this state.  Here it is on the diagram: <br><br><img src="https://habrastorage.org/webt/mh/tb/br/mhtbbr8strxue23n6jmg_giocjc.png"><br><br>  Here are its properties in more detail: <br><br><img src="https://habrastorage.org/webt/oo/t5/rs/oot5rs3_cdplwr94gno3poavzkq.png"><br><br>  In general, taking into account the previous articles, the essence of this counter is clear.  Only the string <b>Enable has been</b> gained.  Again, I do not fully understand why it should be turned on when the machine is in the <b>LoadData</b> state (then the counter reloads the period value).  I borrowed this trick from the properties of the meter that controls the LEDs, taken from the English author of the control unit for those LEDs.  Without it, the zero period does not work.  She works with her. <br><br>  In the API code, we add initialization of the new counter.  Now the start function looks like this: <br><br><pre> <code class="plaintext hljs">void `$INSTANCE_NAME`_Start() { `$INSTANCE_NAME`_SingleVibrator_Start(); //"One" Generator start `$INSTANCE_NAME`_Plus65536_Start(); }</code> </pre><br>  Let's check the new system.  Here is the function code for testing. <br><br><div class="spoiler">  <b class="spoiler_title">(only the first line differs from the already known one):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void JustTest(int extra65536s) { //      65536  StepperController_X_Plus65536_WritePeriod((uint8) extra65536s); //     //    ‚Äî   CY_SET_REG16(StepperController_X_Datapath_1_D0_PTR, 4); CY_SET_REG16(StepperController_X_Datapath_1_D1_PTR, 2); //         . //         static const uint16 steps[] = { 0x1000,0x1000,0x1000,0x1000 }; //  DMA  ,      uint8 channel = DMA_X_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(StepperController_X_Datapath_1_F1_PTR)); CyDmaChRoundRobin (channel,true); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)StepperController_X_Datapath_1_F1_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre><br></div></div><br>  Call it like this: <br><br><pre> <code class="plaintext hljs"> JustTest(0);</code> </pre><br>  On the oscilloscope we see the following (yellow beam - STEP output, blue - the value of the TC output of the counter for controlling the process).  The pulse duration is specified in the <b>steps</b> array.  At each step, the duration is 0x1000 cycles. <br><br><img src="https://habrastorage.org/webt/ap/q7/df/apq7dfk6t5kns3qtzjmkuzzw-44.png"><br><br>  Switch to another development so that there is compatibility between different results: <br><br><img src="https://habrastorage.org/webt/zl/6s/2o/zl6s2oop2bft0ndatbawfdrtacw.png"><br><br>  Change the function call to this: <br><br><pre> <code class="plaintext hljs"> JustTest(1);</code> </pre><br>  The result corresponds to the expectation.  First, the TC output is zero for 0x1000 cycles, then - one for 0x10000 (65536d) cycles.  The frequency is approximately 700 Hertz, we found out in the last part of the article, so that's right. <br><br><img src="https://habrastorage.org/webt/nm/5q/6s/nm5q6s73zb7yqxtvuxzrxis4f5i.png"><br><br>  Well, let's try a deuce: <br><br><pre> <code class="plaintext hljs"> JustTest(2);</code> </pre><br>  We get: <br><br><img src="https://habrastorage.org/webt/ah/sp/7y/ahsp7ymdefdyl04acuefc3ufct8.png"><br><br>  That's right.  The TC output is thrown to the unit at the last 65,536 cycles.  Before that, it is at zero for 0x1000 + 0x10000 cycles. <br><br>  Of course, with this approach, all the impulses must go at the same value of the new counter.  It is impossible to make one pulse with a high byte, say, 3, then - 1, then - 0. But in fact, at such low frequencies (less than seven hundred hertz), the accelerations have no physical meaning, so this problem can be neglected.  At this frequency, you can work with the engine linearly. <br><br><h2>  A spoon of tar </h2><br>  The TRM document for the PSoC5LP family reads: <br><blockquote>  Each transaction can be from 1 to 64 KB </blockquote>  But in the already mentioned AN84810 there is such a phrase: <br><blockquote>  1. How can you buffer more than 4095 bytes using DMA? <br>  The TDD is limited to 4095 bytes.  If you need to use the DMA channel by 4095 bytes, it is shown in Example 5. </blockquote>  Who is right?  If experiments are conducted, the results will tend to favor the worst of the statements, but the behavior will be completely incomprehensible.  All the fault of this check in the API: <br><br><img src="https://habrastorage.org/webt/ib/5s/i2/ib5si2yxxn4e_idcohactjo2j-u.png"><br><br><div class="spoiler">  <b class="spoiler_title">The same text.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">cystatus CyDmaTdSetConfiguration(uint8 tdHandle, uint16 transferCount, uint8 nextTd, uint8 configuration) \ { cystatus status = CYRET_BAD_PARAM; if((tdHandle &lt; CY_DMA_NUMBEROF_TDS) &amp;&amp; (0u == (0xF000u &amp; transferCount))) { /* Set 12 bits transfer count. */ reg16 *convert = (reg16 *) &amp;CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[0u]; CY_SET_REG16(convert, transferCount); /* Set Next TD pointer. */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[2u] = nextTd; /* Configure the TD */ CY_DMA_TDMEM_STRUCT_PTR[tdHandle].TD0[3u] = configuration; status = CYRET_SUCCESS; } return(status); }</code> </pre><br></div></div><br>  If a transaction is specified that is longer than 4095 bytes, the previous setting will be used.  Yes, I did not think to check the error codes ... <br><br>  Experiments have shown that if you remove this check, the actual length will be cut off using the 0xfff mask (4096D = 0x1000).  Alas and ah.  All hopes for a pleasant job collapsed.  You can, of course, make chains of related 4K descriptors.  But let's say, 64K is 16 chains.  Three active engines (for extruders steps will be less) - 48 chains.  Exactly so much must be filled in the worst case before each segment.  Perhaps it is acceptable in time.  At a minimum, 127 descriptors are available, so the memory will definitely suffice. <br><br>  You can also send the missing data as needed.  An interruption has come that the DMA channel has completed its work, we are transferring another segment to it.  In this case, no calculations are required, the segment is already formed, everything will be fast.  And there are no speed requirements: when an interrupt request is issued, there will be 4 more elements in the FIFO that will be serviced each for several hundred or even thousands of cycles.  That is, everything is real.  The specific strategy will be easier to choose during the actual work.  But an error in the documentation (TRM) ruined the whole mood.  If it were known in advance, maybe I would not even check the methodology. <br><br><h2>  Conclusion </h2><br>  In appearance, the developed auxiliary firmware tool became acceptable so that on its basis it was possible to make a version of the ‚ÄúFirmware‚Äù, say, Marlin, which is not permanently in the interrupt handler for stepper motors.  As far as I know, this is especially true for Delta printers, where computing resources are quite high.  Perhaps this will eliminate the influxes that occur on my Delta in places where the head stops.  On MZ3D in the same places there are no flows.  Like it or not, time will tell, and the report on this will need to be placed in a completely different branch. <br><br>  In the meantime, we have seen that on the UDB block, for all its simplicity, it is quite possible to implement a coprocessor working in tandem with the main processor and allowing it to be unloaded.  And when there are a lot of these blocks, coprocessors can work in parallel. <br><br>  An error in the documentation for the DMA controller smeared the result.  Interruptions are nevertheless required, but not at all at that frequency and with the time criticality that was in the original version.  So the mood is spoiled, but the use of a "coprocessor" based on UDB still gives a considerable gain compared to purely software work. <br><br>  Along the way, it was revealed that DMA is operating at a fairly low speed.  Based on the results of this, some measurements were made on both the PSoC5LP and the STM32.  The results pull on another article.  Maybe I'll ever do it if the topic turns out to be interesting. <br><br>  As a result of the experiments, two test projects turned out at once.  The first is easier to understand.  It can be taken <a href="https://yadi.sk/d/IHXFCWezNhWO9Q">here</a> .  The second is inherited from the first one, but it is confused when adding a seven-bit counter and its associated logic.  It can be taken <a href="https://yadi.sk/d/oYFgesOTs0tjCg">here</a> .  Of course, these examples are only test.  There is no free time for embedding into real ‚Äúfirmware‚Äù.  But within the framework of these articles, it is more important to practice working with UDB. </div><p>Source: <a href="https://habr.com/ru/post/434742/">https://habr.com/ru/post/434742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434732/index.html">Life at 6200 DPI. HyperX Pulsefire Core Review</a></li>
<li><a href="../434734/index.html">Fourier transform. The fast and the furious</a></li>
<li><a href="../434736/index.html">Using the Mikrotik log database to suppress brute force</a></li>
<li><a href="../434738/index.html">Learning with reinforcement in Python</a></li>
<li><a href="../434740/index.html">The neural network was taught to detect solar panels on satellite images and predict their level of distribution.</a></li>
<li><a href="../434744/index.html">Samsung SSD 860 QVO 1 TB and 4 TB: the first consumer SATA QLC (part 2)</a></li>
<li><a href="../434746/index.html">BLE under the microscope 4</a></li>
<li><a href="../434748/index.html">Mail.ru plans to buy music licensing partner for $ 100 million</a></li>
<li><a href="../434750/index.html">How to take control of network infrastructure. Part two. Cleaning and documentation</a></li>
<li><a href="../434752/index.html">Robomoroz: the future of the main character of the New Year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>