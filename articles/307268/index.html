<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Super slow and super fast benchmark</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a recent Java performance article, a discussion on performance measurement broke out. Looking at it, with sadness we have to realize that many peop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Super slow and super fast benchmark</h1><div class="post__text post__text-html js-mediator-article"><p>  In a recent <a href="https://habrahabr.ru/company/jugru/blog/307178/">Java performance</a> article, a discussion on performance measurement broke out.  Looking at it, with sadness we have to realize that many people still do not understand how difficult it is to correctly measure the execution time of a particular code.  In addition, people are not at all used to the fact that the same code under different conditions can run significantly different times.  For example, here is one of the opinions: </p><br><blockquote>  If I need to find out which language is faster for me on my task, then I will chase away the most primitive benchmark in the world.  If the difference is significant (say, an order of magnitude) - then most likely on the user machine everything will be about the same. </blockquote><p>  Unfortunately, the most primitive benchmark in the world is usually incorrectly written benchmark.  And one should not hope that the wrong benchmark will measure the result at least up to the order.  It can measure something completely different, which will be completely different from the actual performance of a program with similar code.  Let's take an example. </p><a name="habracut"></a><br><p> Let's say we saw the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">Java 8 Stream API</a> and want to check how fast it works for simple math.  For example, for simplicity, we take a stream of integers from 0 to 99999, square each by using the <code>map</code> operation, and that's it, we will not do anything else.  We just want to measure performance, right?  But even a quick overview of the API is enough to see that streams are lazy and <code>IntStream.range(0, 100_000).map(x -&gt; x * x)</code> in fact does not do anything.  Therefore, we add a terminal operation <code>forEach</code> , which somehow uses our result.  For example, increase it by one.  As a result, we get this test: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IntStream.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100_000</span></span>).map(x -&gt; x * x).forEach(x -&gt; x++); }</code> </pre> <br><p>  Fine.  How to measure how much it works?  Everyone knows: take time at the beginning, time at the end and calculate the difference!  Add a method that measures time and returns the result in nanoseconds: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.nanoTime(); test(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end - start; }</code> </pre> <br><p>  Well, now let's just output the result.  On my not the fastest Core i7 and Open JDK 8u91 64bit, in different launches I get a number in the region from 50 to 65 million nanoseconds.  That is 50-65 milliseconds.  One hundred thousand squares in 50 milliseconds?  This is monstrous!  This is only two million times per second.  Twenty-five years ago, computers and then quickly built in a square.  Java shamelessly slows down!  Or not? </p><br><p>  In fact, the first use of lambda and Stream API in the application will always add a delay of 50-70 ms on modern computers.  After all, a lot of things have to be done during this time: </p><br><ul><li>  Load classes to generate lambda runtime views (see <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">LambdaMetafactory</a> ) and everything related to them. </li><li>  Download classes of the Stream API itself (there are a lot of them there) </li><li>  For lambdas that are used in our code (in our case, two) generate a runtime representation. </li><li>  JIT-compile it all good at least somehow. </li></ul><br><p>  All this requires a lot of time and in fact it is even surprising that it manages to keep within 50 ms.  But all this is needed exactly once. </p><br><p>  <strong>Lyrical digression</strong> </p><br><blockquote>  In general, with the presence of dynamic loading and caching for anything, it becomes very difficult to understand what we measured.  This applies not only to Java.  A simple library call can initiate loading from a hard disk and initializing a shared library (and imagine that the hard disk also went to sleep mode).  As a result, the call may take much longer.  Soared about it or not?  Sometimes it is necessary.  For example, at the time of Windows 95, loading the OLE32.DLL shared library took considerable time and would have announced the first program in the brakes that would try to load OLE32.  This forced the developers, if possible, not to load OLE32 as long as possible, so that other programs could become guilty.  In some places, other libraries even implemented functions that duplicate some of the OLE32 functions, just to avoid loading OLE32.  Read more about this story with <a href="https://blogs.msdn.microsoft.com/oldnewthing/20040705-00/%3Fp%3D38573">Raymond Chen</a> . </blockquote><p>  So, we realized that our benchmark is super slow, because in the process a lot of things are done that need to be done exactly once after loading.  If our program plans to work for more than a second, most likely we don‚Äôt care much about it.  So let's "warm up the JVM" - we will measure this 100 thousand times and display the result of the last measurement: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">100000</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> res = measure(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == <span class="hljs-number"><span class="hljs-number">0</span></span>) System.out.println(res); }</code> </pre> <br><p>  This program completes faster than in a second and prints 70-90 nanoseconds on my machine.  That's great!  So, one squaring has 0.7-0.9 picoseconds?  Is Java squaring more than a trillion times a second?  Java is super fast!  Or not? </p><br><p>  Already at the second iteration, much of the above list will be executed and the process will speed up every 100. Further, the JIT compiler will gradually compile different pieces of code (there is a lot of it inside the Stream API), collecting execution profiles and optimizing more and more.  In the end, JIT is smart enough to zainlaynit the entire chain of lambda and understand that the result of multiplication is not used anywhere.  A naive attempt to use it through the increment JIT-compiler is not deceived: this operation still has no side effect.  The JIT compiler didn‚Äôt have enough strength to cut the entire stream at all, but he was able to mow the internal loop, actually making the test performance independent of the number of iterations (replace <code>IntStream.range(0, 100_000)</code> with <code>IntStream.range(0, 1_000_000)</code> - the result will be same). </p><br><p>  By the way, at such times, the execution time and granularity of <code>nanoTime()</code> significant.  Even on the same hardware but in different OS you can get a significantly different answer.  Read more about this - <a href="https://shipilev.net/blog/2014/nanotrusting-nanotime/">Alexei Shipilev</a> . </p><br><p>  So, we wrote "the most primitive benchmark."  At first it turned out to be super-slow, and after a little refinement it was super-fast, almost a million times faster.  We wanted to measure how fast the squaring is done using the Stream API.  But in the first test this mathematical operation sank in a sea of ‚Äã‚Äãother operations, and in the second test it was simply not performed.  Be wary of making hasty conclusions. </p><br><p>  Where is the truth?  The truth is that this test has nothing to do with reality.  It does not produce visible effects in your program, that is, in fact, it does nothing.  In reality, you rarely write code that does nothing, and of course, it hardly brings you money (although there are <a href="https://habrahabr.ru/post/147075/">exceptions</a> ).  Trying to answer the question of how much time squaring is actually performed inside the Stream API is generally not very meaningful: this is a very simple operation and, depending on the surrounding code, the JIT compiler can compile a cycle with multiplication in very different ways.  Remember that performance is not additive: if A is running for x seconds, and B is running for y seconds, then it‚Äôs not at all the fact that performing A and B will take x + y seconds.  It may be completely wrong. </p><br><p>  If you want easy answers, then in real programs the truth will be somewhere in the middle: the overhead of a stream of 100,000 integers that are squared will be about 1000 times more than the super-fast result, and about 1000 times less than super slow  But depending on many factors it can be worse.  Or better. </p><br><p>  At last year's Joker, I <a href="https://www.youtube.com/watch%3Fv%3DobMArSvmhx4">looked at a</a> slightly more interesting example of the performance measurement of the Stream API and dug deeper what was going on there.  Well and the obligatory reference to <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> : it will help not to step on a simple rake when measuring the performance of JVM-languages.  Although, of course, even JMH will not solve all your problems in a magical way: you still have to think. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/307268/">https://habr.com/ru/post/307268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307256/index.html">Interface calculations (and a couple of small tips, how not to screw up, choosing a product)</a></li>
<li><a href="../307258/index.html">Pro shops and introverts: a number of implicit things</a></li>
<li><a href="../307260/index.html">The most important thing about neural networks. Lecture in Yandex</a></li>
<li><a href="../307262/index.html">Cold Storage in the cloud: Amazon, Google, Microsoft are changing the cloud storage services market</a></li>
<li><a href="../307266/index.html">Const and optimization in C</a></li>
<li><a href="../307270/index.html">New technologies CRM integration in 3CX v15</a></li>
<li><a href="../307272/index.html">EA Global 2016 Effective Altruism Conference - Live Broadcast</a></li>
<li><a href="../307278/index.html">Sending and receiving SMS using Laravel and Nexmo</a></li>
<li><a href="../307280/index.html">A bit about VPN: A brief overview of software implementations</a></li>
<li><a href="../307282/index.html">What to do with other people's debts?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>