<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Notes on NLP (Part 6)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(The first parts: 1 2 3 4 5 ). I hope the conversation about the natural language of the readers is not tired yet! In my opinion, the topic is really ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Notes on NLP (Part 6)</h1><div class="post__text post__text-html js-mediator-article">  (The first parts: <a href="http://habrahabr.ru/blogs/artificial_intelligence/79790/">1</a> <a href="http://habrahabr.ru/blogs/artificial_intelligence/79819/">2</a> <a href="http://habrahabr.ru/blogs/artificial_intelligence/79830/">3</a> <a href="http://habrahabr.ru/blogs/artificial_intelligence/79853/">4</a> <a href="http://habrahabr.ru/blogs/artificial_intelligence/79882/">5</a> ).  I hope the conversation about the natural language of the readers is not tired yet!  In my opinion, the topic is really interesting (although the popularity of topics is clearly declining :)).  Well, let's see how many parts I still have enough.  I think we have already passed the equator, but it is still possible to touch on three or four topics. <br><br>  This time, the note is entirely devoted to the XDG / XDK project, which I am trying to study at my leisure.  I cannot call myself an XDG specialist yet.  But slowly moving. <a name="habracut"></a><br><br>  So, we stopped at the fact that we will consider dependency parsing, and, if possible, with non-projective constructions and multiple generation of trees.  This naturally leads us to the XDG / XDK project, which satisfies all these requirements.  I myself came to the "topic" with sympathy for lexicalized dependency parsing, but otherwise I start almost from scratch, and the choice of XDG is dictated by cold sifting of other things.  Studied what is, choose what is best.  Today it turned out that XDG seems to be better (at least within the framework of a given concept). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is it?  XDG stands for <a href="http://www.ps.uni-saarland.de/~rade/xdg.html">Extensible Dependency Grammar</a> , and XDK, respectively, as the XDG Development Kit.  XDG is a formalism for describing admissible connections between words in a sentence.  This is a vocabulary formalism: for each specific word of the language, it is necessary to describe how and with what it can be glued.  XDK includes a set of tools, the most important of which is Solver, also known as a parser.  Solver accepts a grammar of the language and a sentence on it.  The output generates a set of trees corresponding to the parsed sentence.  As you can see, everything is very simple in words :) <br><br><h1>  Grammar writing </h1>  Where to get grammar?  Here I would like to emphasize: yes, in the simplest scenario (although for the developer it is clearly not the easiest :)) the grammar is written by hand.  However, let's not forget that grammatical rules are only an exact formal description of language constructs.  And where they come from - written by experts or derived in some way from existing texts - is the second question.  However, for accurate analysis of sentences, rules are needed, and grammar is just a variation of their record. <br><br>  As for the way these rules are written down, it seems to me quite obvious and adequate.  I believe that using XDG can describe not only natural language, but also, say, Pascal.  Of course, such a parser will be far from perfect, but, in theory, it should work :) <br><br>  I don‚Äôt even know why nobody used to do such work (dependency parser kit).  The project is quite fresh, the current version is dated 2007 (however, I have already said that I don‚Äôt notice much enthusiasm about the XDK yet, and at the moment the project is not developing). <br><br>  Probably, it makes sense to give a little "touch" the language of the proposed grammars.  It is based on three basic principles: <br><br>  <b>Lexicalization</b> .  The grammar elements are the words of the language.  Each word can be assigned a set of attributes, in fact, determining that the word can stick to itself and to which it can stick itself.  Each attribute has a name, type, and value.  The most commonly used types are ‚Äústring‚Äù and ‚Äúmultiple lines‚Äù. <br><br>  <b>Principles of creating a graph</b> .  In addition to the restrictions on the "gluing", set at the level of individual words, you can set restrictions for the whole phrase parsing graph.  Such restrictions are called "principles."  The simplest example of the principle is the tree principle, which requires the generated graph to be a tree.  We will talk about some other useful principles a bit later. <br><br>  <b>Multidimensionality</b> .  Each word attribute is defined in a namespace (user-defined).  The principles of creating a graph are also described in a specific namespace.  Each such space is called a ‚Äúdimension.‚Äù  The phrase analysis graph for each dimension is constructed separately.  Thus, it is possible to obtain several analysis graphs at once, reflecting certain structural features of the proposal (that is, the user can look at the proposal as if from different angles of view).  For example, along with a dependency graph, you can construct a degenerate graph list showing the order of words in a sentence.  Or, say, a graph connecting all the noun phrases. <br><br><h1>  Valence principle </h1>  Now a few words about what the principles are.  First of all, I would like to mention the <i>principle of valence</i> , indicating that the relationship between the two words w1 and w2 can be established only if the <b>out</b> attribute of the word w1 coincides with the in attribute of the word w2.  Let me explain with an example: <br><br><pre> defentry {dim lex {word: "eats"}
            dim syn {in: {root} out: {subj obj adv *}}}
 defentry {dim lex {word: "Peter"}
            dim syn {in: {subj?  obj?} out: {}}}
 defentry {dim lex {word: "spaghetti"}
            dim syn {in: {subj?  obj?} out: {}}}
 defentry {dim lex {word: "today"}
            dim syn {in: {adv?} out: {}}} </pre><br><br>  The <b>out</b> attribute specification of the verb ‚Äúeats‚Äù indicates that a single subject (subj), one object (obj) and an arbitrary number of circumstances (adv *) can attach to itself the word.  The in attribute specification of the word ‚ÄúPeter‚Äù allows the word to be a subject or object.  The same is the specification of the word "spaghetti".  The word "today" is described as a potential circumstance.  Thus, if we feed the parser the phrase ‚ÄúPeter eats spaghetti today‚Äù, the resulting tree will have ‚Äúeats‚Äù as the root, ‚ÄúPeter‚Äù and ‚Äúspaghetti‚Äù will be attached to the root as subject and object, and the word ‚Äútoday‚Äù in as a circumstance. <br><br>  There is also the ‚Äúprinciple of orderliness‚Äù (sacrificing them for the sake of space), with which you can indicate that the earlier word in a sentence takes precedence as a subject (thus, ‚Äúspaghetti‚Äù will not become a subject). <br><br><h1>  The principle of consistency </h1>  This is another important principle, by which I can not pass.  It establishes the following requirement: the words to be linked must agree on an attribute.  For example, you can specify that the verb "eats" as a subject requires a third person, the only number.  At the same time, the verb "eat" will add anything other than a third person, singular: <br><br><pre>  defentry {dim lex {word: "eats"}
            dim syn {agrs: {["3" sg]}
                      agree: {subj}}}
 defentry {dim lex {word: "eat"}
            dim syn {agrs: {["1" sg] ["2" sg]
                        ["1" pl] ["2" pl] ["3" pl]}
                      agree: {subj}} </pre><br><br>  In order for the word "Peter" to join, and now, you will have to specify its attributes of the number and face: <br><br><pre>  defentry {dim lex {word: "Peter"}
            dim syn {agrs: {["3" sg]}
                      agree: {}}} </pre><br><br>  As you can see from these examples, the grammar does not directly support morphology.  So, the words "eat" and "eats" are different for her.  However, I don‚Äôt quite understand how to push the support of ‚Äúmorphology in general‚Äù into universal formalism.  This problem is solved, however, quite simply: it is necessary to drive the input sentence through a morphological analyzer and generate grammar rules (with correct endings and word attributes) automatically, on the fly. <br><br>  The analysis ends when it was possible to assemble the entire structure and attach it to a word that has the attribute ‚Äútree top‚Äù.  For example, as such a word you can describe a point (for the sentence ends with a point): <br><br><pre>  defentry {
   dim lex {word: "."}
   dim syn {in: {}
            out: {root} 
            agrs: top
            }} </pre><br><br><h1>  Start! </h1>  If the resulting grammar (of course, here are only its fragments!) Feed the analyzer along with the input string ‚ÄúPeter eats spaghetti today.‚Äù, The expected tree will be generated at the output: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/52f/95a/5dd/52f95a5dd4906a5de061798289dc9e7c.png"><br><br>  Here I propose to put if not a point, then a semicolon, because ‚Äúbriefly‚Äù it will not be possible to continue.  The next ‚Äúblock of thoughts‚Äù pulls into a separate post (tomorrow, probably? ..) Let's continue about the XDG, most likely. <br><br>  Is that, in order not to return to this issue, I will list the problems XDK, striking.  Firstly, the current build is compiled under ASCII with support for Western European languages.  That is, the Cyrillic alphabet becomes kryakozyblyi (it will still be disassembled, but inconvenient debugging)  However, the problem is small, I think.  Secondly, the author defended his thesis and went to work in the industry, he no longer supports the project, and no one else has yet picked up, in spite of the fact that open source.  Thirdly, ‚Äúentering the project‚Äù is not so simple, because everything is written in the relatively marginal Mozart / Oz programming environment in the constraint programming paradigm.  It‚Äôs difficult to criticize the author for this ‚Äî the task is very specific.  I have already said that a full analysis pulls on the NP-complete task.  The author also considered the parsing as a constraint satisfaction problem: graph nodes are given and a set of conditions limiting edges is given.  It is required to find a graph satisfying the conditions.  That is, the task was set in a more general form, and as a result, it was decided to use a specialized tool for this kind of things.  Properly done.  There is something else that does not suffice me personally, but more on that next time. </div><p>Source: <a href="https://habr.com/ru/post/79923/">https://habr.com/ru/post/79923/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../79913/index.html">All about String.intern ()</a></li>
<li><a href="../79916/index.html">Gamers generation</a></li>
<li><a href="../79917/index.html">The most high-tech ball in history</a></li>
<li><a href="../79919/index.html">Computer in the car</a></li>
<li><a href="../79921/index.html">We print book brochures in * nix</a></li>
<li><a href="../79925/index.html">Visa forum visaforum.org</a></li>
<li><a href="../79926/index.html">ASN GateWay - WiMAX Access Gateway</a></li>
<li><a href="../79930/index.html">Help your business</a></li>
<li><a href="../79931/index.html">From 2012, the world can switch to a new calendar.</a></li>
<li><a href="../79932/index.html">When do you plan to stop supporting Internet Explorer 6?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>