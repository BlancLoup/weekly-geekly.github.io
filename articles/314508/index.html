<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Synthesis of images using deep neural networks. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suppose that this week in the Yandex blog on Habrahabr will be marked by neural networks. As we see, neural networks are now beginning to be used in v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Synthesis of images using deep neural networks. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  Suppose that this week in the Yandex blog on Habrahabr <a href="https://habrahabr.ru/company/yandex/blog/314222/">will be</a> marked by neural networks.  As we see, neural networks are now beginning to be used in very many areas, including search.  It seems that it is ‚Äúfashionable‚Äù to look for new areas of application for them, and in those areas where they have been working for some time, the processes are not so interesting. <br><br>  However, events in the world of the synthesis of visual images prove the opposite.  Yes, companies started using neural networks for image operations a few years ago - but this was not the end of the journey, but its beginning.  Recently, the head of the Skoltech computer vision team and a big friend of Yandex and ShAD, <a href="https://yandexdataschool.ru/edu-process/teachers">Viktor Lempitsky,</a> spoke about several new ways of applying networks to images.  Since today's lecture is about pictures, it is very visual. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_rfmEzb6YP4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Under the cut - the decoding and most of the slides. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><hr><br>  Good evening.  Today I will talk about convolutional neural networks and I will assume that most of you have spent the last four years not on an uninhabited island, therefore, we heard something about convolutional deep neural networks and know approximately how they process data. <br><br><img src="https://habrastorage.org/files/fdc/a53/382/fdca53382b3a4541a2996aae7a00407d.jpg"><br><br>  Therefore, I will spend the first two slides to tell exactly how they are applied to the images.  They represent some architectures ‚Äî complex functions with a large number of adjustable parameters, where elementary operations are of certain types, such as generalized convolutions, image size reduction, so-called pooling, element-wise nonlinearity applied to individual measurements, and multiplication by a matrix.  Such a convolutional neural network takes a sequence of these operations, takes some image, for example, this cat. <br><br><img src="https://habrastorage.org/files/b65/c56/d38/b65c56d38b2045dd88896513b915c546.jpg"><br><br>  Then it transforms a similar set of three images into a set of one hundred images, where each rectangle represents a really significant image specified in the MATLAB format. <br><br>  Next, some non-linearities are applied, and a new set of images is considered using the operations of generalized convolution.  Several iterations occur, and at some point such a set of images is transformed into a multidimensional vector.  After another series of multiplications on the matrix and elementwise non-linearities, this vector turns into a vector of properties of the input image, which we wanted to get to when we trained the neural network.  For example, this vector can correspond to normalized probabilities or unnormalized values, where large values ‚Äã‚Äãindicate that a particular class of objects is present in the image.  In this example, the hump at the top corresponds to different breeds of cats, and the neural network thinks that this image contains a cat of one breed or another. <br><br>  Neural networks that take pictures, process them in this order and get similar intermediate representations, I will call normal, ordinary or traditional convolutional networks. <br><br>  But today I‚Äôll speak mostly not about them, but about the new popular class of models, which I will call inverted or unfolded neural networks. <br><br><img src="https://habrastorage.org/files/6d6/013/4a7/6d60134a729f4321ad71fa06219926bc.jpg"><br><br>  Here is an example of such an inverted neural network.  This is a well-known model of the Freiburg group, Dosovitsky and colleagues, which is trained to take some vector of parameters and to synthesize an image that corresponds to them. <br><br>  More specifically, the vector that encodes the class, a specific type of chair, and another vector that encodes the geometric parameters of the camera is fed to the input of this neural network.  At the output, this neural network synthesizes an image of the chair and a mask separating the chair from the background. <br><br>  As you can see, the difference between such a deployed neural network and the traditional one is that it does everything in the reverse order.  Our image is no longer at the entrance, but at the exit.  And the views that arise in this neural network are at first just vectors, and at some point turn into sets of images.  Gradually, the images are combined with each other with the help of generalized convolutions, and the resulting images are obtained. <br><br><img src="https://habrastorage.org/files/ed7/176/6f3/ed71766f32c64cdfbbadee39f08df231.jpg"><br><br>  In principle, the neural network indicated on the previous slide was trained on the basis of synthetic images of chairs, which were obtained from several hundred CAD models of chairs.  Each image is labeled with a chair class and camera parameters corresponding to the image. <br><br><img src="https://habrastorage.org/files/5e6/ab7/272/5e6ab727215e4d579e6d9dcf9b303f7a.jpg"><br><br>  An ordinary neural network will take a chair image at the entrance, predict the type of chair and the characteristics of the camera. <br><br><img src="https://habrastorage.org/files/0c9/ce3/72f/0c9ce372fa3a445d8798d693423b9a28.jpg"><br><br>  Dosovitsky's neural network does everything the other way around - it generates an image of the chair at the exit.  I hope the difference is clear. <br><br>  Interestingly, the components of an inverted neural network almost exactly repeat the components of a normal neural network.  The only novelty and new module that arises is the module of reverse pooling, anpuling.  This operation takes smaller pictures and converts them to larger pictures.  This can be done in many ways that work about equally.  For example, in their article they took small-sized maps, simply inserted zeros between them, then processed similar images. <br><br>  This model turned out to be very popular, aroused a lot of interest and subsequent work.  In particular, it turned out that such a neural network works very well, despite the seeming unusualness, exoticism and unnaturalness of such an idea - to deploy the neural network upside down, from left to right.  It is capable not only of learning the learning set, but also of very good generalizations. <br><br><img src="https://habrastorage.org/files/5ee/aea/2cb/5eeaea2cbea847ecac68d3eb139d34ea.jpg"><br><br>  They showed that such a neural network can interpolate between two models of chairs and get a model as a mixture of chairs that were in the training set that the neural network had never seen.  And the fact that these mixtures look like chairs, and not as arbitrary mixtures of pixels, says that our neural network is very well generalized. <br><br>  If you ask yourself why this works so well, there are several answers.  Two most convince me.  First, why should it work badly if direct neural networks work well?  Both direct and expanded networks use the same property of natural images that their statistics are local and the appearance of image slices does not depend on which part of the global image we are looking at.  This property allows us to separate, reuse the parameters inside the convolutional layers of ordinary convolutional neural networks, and this property is used by the expanded networks, they are used successfully - it allows them to process and learn large amounts of data with a relatively small number of parameters. <br><br>  The second property is less obvious and absent in direct neural networks: when we train a deployed network, we have much more training data than it seems at first glance.  Each picture contains hundreds of thousands of pixels, and each pixel, although it is not an independent example, imposes restrictions on network parameters in one way or another.  As a consequence, such a developed neural network can be effectively trained in a variety of images, which will be less than would be necessary for a good training of a direct network of a similar architecture with the same number of parameters.  Roughly speaking, we can train a good model for chairs using thousands or tens of thousands of images, but not a million. <br><br>  Today I would like to tell you about three ongoing projects related to deployed neural networks, or at least neural networks that produce an image at the output.  I can hardly go into details - they are available on the links and in the articles of our group - but I hope such a run to the top will show you the flexibility and interestingness of this class of tasks.  Maybe it will lead to some ideas about how neural networks can still be used to synthesize images. <br><br><img src="https://habrastorage.org/files/243/f2a/e4d/243f2ae4db9e457e97def6a34301debe.jpg"><br><br>  The first idea is devoted to the synthesis of textures and image styling.  I will talk about the class of methods that matches what happens in Prisma and similar applications.  All this developed in parallel and even slightly ahead of Prisma and similar applications.  These methods are used in it or not - we probably don‚Äôt know, but we have some assumptions. <br><br>  It all starts with the classic task of texture synthesis.  People in computer graphics have been involved in this task for decades.  Very briefly, it is formulated as follows: a texture sample is given and a method must be proposed that can generate new samples of the same texture for a given sample. <br><br>  The task of texture synthesis in many ways rests on the task of comparing textures.  How to understand that these two images correspond to similar textures, and these two - dissimilar?  It is quite obvious that some simple approaches - for example, to compare three images pixel-by-pixel in pairs or to look at histograms - will not lead us to success, because the similarity of this pair will be the same as this one.  Many researchers puzzled over how to define texture similarity measures, how to define some kind of texture handle, so that some simple measure in such advanced descriptors would say well whether textures are similar or not. <br><br><img src="https://habrastorage.org/files/d69/d36/cc7/d69d36cc767f441c886ad05bd686574c.jpg"><br><br>  A year and a half ago, the group in T√ºbingen achieved a breakthrough.  In fact, they generalized an earlier method based on wavelet statistics, which they replaced with activation statistics.  It creates images and calls in some deep pre-ordinary network. <br><br>  In their usual experiments, they took a large deep neural network trained for classification.  Later it turned out that options are possible here: the network can even be deep with random weights, if they were initialized in a certain way. <br><br>  One way or another, statistics is defined as follows.  Take an image, skip it through the first few convolutional layers of the neural network.  On this layer we get a set of maps, images F <sup>l</sup> (t).  t is a texture pattern.  His set of image maps is on the l-layer. <br><br>  Next, we consider texture statistics - it should somehow exclude from itself the parameters associated with the spatial location of an element.  The natural approach is to take all pairs of cards in this view.  We take all pairs of cards, count all pairwise scalar products between these pairs, take the i-th card and j-th card, then the k-th index goes through all possible spatial positions, we consider a similar scalar product and get the i, j coefficient, member Gram matrices.  The Gram l-matrix, calculated in this way, describes our texture. <br><br>  Further, when it is necessary to compare whether the two images are similar as textures, we simply take a certain set of layers: it can be one layer - then this amount includes one member.  Or we can take several convolutional layers.  Compare the Gram matrix, calculated in this way for these two images.  We can compare them simply element by element. <br><br>  It turns out that such statistics speaks very well about whether the two textures are similar or not - better than anything that was suggested before working on the slide. <br><br><img src="https://habrastorage.org/files/8ac/f3a/b65/8acf3ab650934ec48272d3d6f5b69a4a.jpg"><br><br>  Now that we have a very good measure that allows us to compare textures, we can take some random approximation, random noise.  Let the current image be denoted as x and be some sample t.  we will pass our current state through the neural network, look at its current Gram matrix.  Next, using the back-propagation algorithm, we understand how to change the current propagation so that its Gram matrices inside the neural network become a bit more similar to the Gram matrices of the sample that we want to synthesize.  Gradually, our noisy image will turn into a set of stones. <br><br><img src="https://habrastorage.org/files/3ba/6c8/780/3ba6c8780f6c4adfa8c358fa3da6ba6c.jpg"><br><br>  It works very well.  Here is an example from their article.  On the right is an example that we want to repeat, and on the left is a synthesized texture.  The main problem is the time of work.  For small images, it takes a lot of seconds. <br><br>  The idea of ‚Äã‚Äãthis approach is to radically speed up the process of generating textures through the use of an inverted neural network. <br><br><img src="https://habrastorage.org/files/14b/244/220/14b2442206eb468e81e81faf70d68e4d.jpg"><br><br>  It was proposed to train a new deployed neural network for this texture sample, which would accept some noise at the input and produce new texture samples. <br><br>  Thus, x ‚Äî which in the previous approach was some independent variable and we manipulated it, trying to create textures ‚Äî now becomes a dependent variable, the output of a new neural network.  It has its own parameters Œ∏.  The idea is to transfer training to a separate stage.  Now we take and teach the neural network, adjusting its parameters so that for arbitrary noise vectors the resulting images have Gram matrices corresponding to our sample. <br><br>  The loss functions remain the same, but now we have an additional module that we can pre-train in advance.  The downside is that there is now a long-term learning stage, but the plus is as follows: after learning, we can synthesize new texture samples simply by synthesizing a new noise vector, passing it through a neural network, and it takes several tens of milliseconds. <br><br>  Neural network optimization is also performed using the method of stochastic gradient descent, and our training is as follows: we synthesize the noise vector, pass it through the neural network, consider the Gram matrices, look at discrepancies, and back propagate through this entire path, we understand how to change the parameters of the neural network. <br><br>  Here are some details of the architecture, I'll skip them.  The architecture is fully convolutional, there are no fully connected layers, and the number of parameters is small.  Such a scheme, in particular, does not allow the network to simply memorize the texture example provided to it so that it is issued again and again. <br><br><img src="https://habrastorage.org/files/054/034/35d/05403435d030449187f028da2900bef4.jpg"><br><br>  An example of the work of architecture.  On the left is a specified pattern, and on the right are three examples that each of the three neural networks in the upper, lower and middle row provides for these samples.  And this happens in a few tens of milliseconds, and not in seconds, as before.  The architecture feature allows us to synthesize textures of arbitrary size. <br><br><img src="https://habrastorage.org/files/e73/b01/e94/e73b01e944de4c1fa6a509167a03afcb.jpg"><br><br>  We can compare the result of the initial approach, which required optimization, and the new approach.  We see that the quality of the resulting textures is comparable. <br><br><img src="https://habrastorage.org/files/ed0/454/3d7/ed04543d77be4d44964e997337bfadf2.jpg"><br><br><img src="https://habrastorage.org/files/e3b/f09/2bf/e3bf092bf6564d029c95c6428df30750.jpg"><br><br>  In the middle there is a sample of the texture obtained using the Gotiss method (inaudible - Ed.), Optimization, and on the right are examples of the textures produced by the neural network simply by converting the noise vector. <br><br><img src="https://habrastorage.org/files/74b/588/71f/74b58871f72647648c6fff82c8978a18.jpg"><br><br>  In fact, what happens can be interpreted as follows: the resulting neural network is a pseudo-optimizer and for some noise vectors it generates some good solution, which can then be improved, for example, by using an optimization approach.  But usually this is not required, because the resulting solution visually has a slightly greater loss function, but in visual quality it is not much inferior or superior to what can be obtained by continuing optimization. <br><br><img src="https://habrastorage.org/files/083/2b0/196/0832b0196988471a92d727cc70c73858.jpg"><br><br>  Interestingly, this approach can be summarized for image styling.  We are talking about the processes when for a given photo and a given pattern of visual style, a new image is built that has the same content as the photo and the same visual style as the style sample. <br><br>  The only change: our neural network will accept not only the noise vector, but also the image that needs to be stylized as input.  She is trained for an arbitrary example of style. <br><br><img src="https://habrastorage.org/files/672/061/d58/672061d5868c4474b52b5bef1a296000.jpg"><br><br>  The original article failed to build an architecture that would give results comparable in quality to the optimization approach.  Later, Dmitry Ulyanov, the first author of the article, found an architecture that allowed him to radically improve the quality and achieve a quality of styling comparable to the optimization approach. <br><br>  Here at the top is a photo and an example of the visual style, and below is the result of styling such a neural network, requiring several tens of milliseconds, and the result of the optimization method ‚Äî which, in turn, requires multi-second optimization. <br><br><img src="https://habrastorage.org/files/98a/c58/b14/98ac58b14472449d9f185fcf9131a521.jpg"><br><br>  It is possible to discuss both quality and which stylization is more successful.  But, I think, in this case, this is already an unclear question.  In this example, I personally prefer the left version.  Perhaps I am biased. <br><br><img src="https://habrastorage.org/files/878/5db/152/8785db1520e644289368d3b2c436ea7a.jpg"><br><br>  Here, probably, rather right. <br><br><img src="https://habrastorage.org/files/6bf/b9c/638/6bfb9c638d26455399cf0509361e6381.jpg"><br><br>  But in this embodiment, the result is quite unexpected for me.  It seems that the approach based on an inverted deployed neural network achieves better styling, while the optimization method is stuck somewhere in a poor local minimum or somewhere on a plateau ‚Äî that is, it cannot fully stylize a photo. <br><br>  We‚Äôll go back to styling.  The second project is connected with the neural network, which solves the following problem.  We wanted to build a network that could take a photo of a person‚Äôs face and redirect his view of this photo. <br><br><img src="https://habrastorage.org/files/d28/f86/f53/d28f86f53abc4ec4a4fa4e03c1cd7954.jpg"><br><br>  Why did we need to solve such an exotic problem?  It turns out that there are at least two applications where it is relevant.  The main thing for us - the task of improving eye contact with video conferencing.  Probably, many people noticed that when you are talking on Skype or another video conferencing service, you cannot look at each other with the interlocutor, because the camera and the interlocutor's face are spaced apart by location. <br><br>  Another application is the post-processing of movies.  You have some kind of superstar whose minute of shooting is worth a million dollars.  You shot a double, but this superstar looked the wrong way.  And now it is necessary either to re-take the double, or to edit the direction of the look. <br><br><img src="https://habrastorage.org/files/fcc/b59/02f/fccb5902f86d44948c3650ea1c233a8d.jpg"><br><br>  To solve this problem, we have collected a large number of sequences.  Within them, we recorded the position of the head, the lighting - everything except the direction of the look.  The protocol was such that we could track where the person was looking.  Each frame is announced by the corresponding direction of view. <br><br><img src="https://habrastorage.org/files/e3a/f68/514/e3af6851476a4509897d34b5cad505b9.jpg"><br><br>  This allowed us to extract from this set of data a couple of examples for which we know: the only difference between the left and right images is the direction of gaze.  For example, here in each case the difference is 15 degrees in the vertical direction. <br><br>  We have practically moved from such a complex task to the classical problem of teaching with a teacher.  We have an example on the left, and we need to generate an example on the right.  Unfortunately, simply solving this problem with the help of a black box, as Sergey said, does not work.      ,  - .          ,     ,    .       .     ,   ‚Äî ,              . <br><br><img src="https://habrastorage.org/files/b52/c6b/988/b52c6b988bda47ed99c65ecdf2d4497e.jpg"><br><br>   ,      ,          .       ,   .      .      ,        ,    , .            spatial transformer layer.   , ,  torch    . <br><br>        ,      .     ,  ,  ,    ,               ,         GT. <br><br>     .       ,  ‚Äî   ,   ‚Äî   ,      . ,          ‚Äî       ,       . ,  ,     . <br><br>              .         ,     ,     .         ,    ,     ,     . <br><br><img src="https://habrastorage.org/files/730/2cb/2ff/7302cb2ff9ad4c26a1bde29a379d17ae.jpg"><br><br>    .    - 15    .          . <br><br><img src="https://habrastorage.org/files/d54/cf2/079/d54cf20799864b63af30dee7c3643a9c.jpg"><br><br>    . <br><br><img src="https://habrastorage.org/files/e60/36b/c06/e6036bc0689b4903bb6128a76c353a7f.jpg"><br><br>   .   ,     -,         . <br><br> ,  .    ,     .   ,    . <br><br>         .    ,    ‚Äî     ‚Äî   .            . , ,  .     ,  QR-, -. <br><br>          ,          .  - ,   ,     ,       . <br><br>   ‚Äî                     . <br><br>     .    .      ,    , ,     ,    .     ,  ,       . <br><br>           ,     .  ,         -  .      ‚Äî     , ,   . . <br><br>      .         ,      . <br><br>   ‚Äî   .          .     ,      ,        . <br><br>   ,      .  ,      ,   ‚Äî  . <br><br><img src="https://habrastorage.org/files/0f3/0b3/40b/0f30b340b5df477cb7cb9c6fc5310d7e.jpg"><br><br>      .     , ,   ,    . ,       ,  ,     , -     . <br><br>  ,      ‚Äî - , . <br><br>         .    ,        . <br><br>      ,    ,          . <br><br><img src="https://habrastorage.org/files/b12/5fa/ba2/b125faba2dfc4f88886f5fed04689143.jpg"><br><br>   ,         ,               ‚Äî         . <br><br><img src="https://habrastorage.org/files/f50/77d/dd7/f5077ddd741b45b4be4a6b42ddfdfd3a.jpg"><br><br>             ,  ,   .    ,  ‚Äî     .  :    ,  ,         ,         .      ,    QR-,        ,       ,     .      ‚Äî      . <br><br><img src="https://habrastorage.org/files/e47/34b/a3a/e4734ba3a6e946b4acc98f96c23ab07e.jpg"><br><br>   .   . <br><br>       .  ,    ,    QR-,     ,   -  . <br><br><img src="https://habrastorage.org/files/481/25a/37d/48125a37d9a94f2da07ba1f214448bbb.jpg"><br><br>    .     .   ,        .   ,   , ‚Äî  ,     .         ,     ,         .    .  Thank. </div><p>Source: <a href="https://habr.com/ru/post/314508/">https://habr.com/ru/post/314508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314494/index.html">Implementation of the performance indicator of queries, stored procedures and triggers in MS SQL Server. Autotrace</a></li>
<li><a href="../314496/index.html">How important is mathematical training in promising areas of software development</a></li>
<li><a href="../314500/index.html">Comparing objects by value - 2, or Features of the implementation of the Equals method</a></li>
<li><a href="../314502/index.html">A brief history of the development of game engines</a></li>
<li><a href="../314506/index.html">ZFS on Linux: News from the Field 2017</a></li>
<li><a href="../314510/index.html">6 functional programming concepts. Use and examples of use</a></li>
<li><a href="../314512/index.html">Names of large numbers in idle games</a></li>
<li><a href="../314514/index.html">Sudoku: so how many of them? Part 2/2</a></li>
<li><a href="../314518/index.html">Working with the VKontakte C # API</a></li>
<li><a href="../314520/index.html">Measurement of resistance and inductance of a DC motor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>