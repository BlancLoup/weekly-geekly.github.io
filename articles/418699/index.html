<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating an emulator arcade machine. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts one and two . 

 8080 processor emulator 
 Emulator shell 
 Now you should have all the necessary knowledge to start creating an 8080 emulator. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating an emulator arcade machine. Part 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="image"></div><br>  Parts <a href="https://habr.com/post/418635/">one</a> and <a href="https://habr.com/post/418683/">two</a> . <br><br><h1>  8080 processor emulator </h1><br><h1>  Emulator shell </h1><br>  Now you should have all the necessary knowledge to start creating an 8080 emulator. <br><br>  <em>I will try to make my code as clear as possible, each opcode is implemented separately.</em>  <em>When you get comfortable with it, you may want to rewrite it to optimize performance or reuse code.</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To begin with, I will create a memory structure that will contain fields for everything that I thought was necessary when writing a disassembler.  Also there will be a place for a memory buffer, which will be a RAM. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Now we will create a procedure with an error call that will terminate the program with an error.  It will look something like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Let's implement several opcodes. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  Like this.  For each opcode, we change state and memory, as the command running on the present 8080 would do. <br><br>  The 8080 has about 7 types, depending on how they are classified: <br><br><ul><li>  Data transmission </li><li>  Arithmetic </li><li>  Logical </li><li>  Branching </li><li>  Stack </li><li>  I / O </li><li>  Special </li></ul><br>  Let's look at each one separately. <br><br><h1>  Arithmetic group </h1><br>  Arithmetic commands are many of the 256 opcodes of the 8080 processor, which include various types of summation and subtraction.  Most arithmetic instructions work with register A and store the result in A. (Register A is also called a accumulator). <br><br>  It is interesting to note that these commands affect the condition codes.  State codes (also called flags) are set depending on the result of the executed command.  Not all commands affect flags, and not all commands that affect flags affect all flags at once. <br><br><h3>  Flags 8080 </h3><br>  In the 8080 processor, the flags are called Z, S, P, CY, and AC. <br><br><ul><li>  Z (zero, zero) takes the value 1 when the result is zero </li><li>  S (sign) takes the value 1 when bit 7 (the most significant bit, the most significant bit, MSB) of the mathematical command is set </li><li>  P (parity, parity) is set when the result is even, and is zeroed when it is odd </li><li>  CY (carry, carry) takes the value 1 when as a result of a command transfer or borrowing is performed in a high order bit </li><li>  AC (auxillary carry, auxiliary carry) is used mainly for BCD (binary coded decimal) binary mathematics.  For details, see the reference book; this flag is not used in Space Invaders. </li></ul><br>  State codes are used in conditional branching commands, for example, JZ performs branching only if the Z flag is set. <br><br>  Most instructions have three forms: for registers, for immediate values ‚Äã‚Äãand for memory.  Let's implement a few instructions to understand their forms and see what working with state codes is like.  (Note that I do not implement the auxiliary carry flag, because it is not used. If I implemented it, I would not be able to test it.) <br><br><h4>  Register Form </h4><br>  Here is an example of the implementation of two instructions with a form for the register;  in the first one, I deployed the code to make it clearer, while the second presents a more compact view that does the same. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  I emulate 8-bit math commands with a 16-bit number.  This makes it easier to keep track of when calculations generate a transfer. <br><br><h4>  Form for immediate values </h4><br>  The form for immediate values ‚Äã‚Äãis almost the same, except that the source of the added is a byte after the command.  Since the "opcode" is a pointer to the current instruction in memory, opcode [1] will be the next byte directly. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Memory form </h4><br>  In the form for the memory will be added bytes, which indicates the address stored in a pair of registers HL. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Notes </h3><br>  The remaining arithmetic commands are implemented in a similar way.  Additions: <br><br><ul><li>  In different versions with carry (ADC, ACI, SBB, SUI), we use the carry bits in the calculations according to the reference book. </li><li>  INX and DCX affect register pairs; these commands do not affect flags. </li><li>  DAD is another command of the register pair, it only affects the carry flag </li><li>  INR and DCR do not affect the carry flag </li></ul><br><h1>  Branch group </h1><br>  After you understand the state codes, the branch group will be clear enough for you.  There are two types of branching - transitions (JMP) and calls (CALL).  JMP simply sets the PC to the destination jump address.  CALL is used for routines, it writes the return address to the stack, and then assigns the PC a target address.  RET returns from CALL, getting the address from the stack and writing it to the PC. <br><br>  Both JMP and CALL navigate only to absolute addresses that are encoded in bytes after the opcode. <br><br><h3>  Jmp </h3><br>  The JMP command performs an unconditional branch to the target address.  There are also conditional jump instructions for all state codes (except for AC): <br><br><ul><li>  JNZ and JZ for zero </li><li>  JNC and JC for transfer </li><li>  JPO and JPE for parity </li><li>  JP (plus) and JM (minus) for the mark </li></ul><br>  Here is the implementation of some of them: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  CALL and RET </h3><br>  CALL writes to the stack the address of the instruction after the call, and then goes to the target address.  RET gets the address from the stack and saves it to the PC.  There are conditional versions of CALL and RET for all states. <br><br><ul><li>  CZ, CNZ, RZ, RNZ for zero </li><li>  CNC, CC, RNC, RC for transfer </li><li>  CPO, CPE, RPO, RPE for parity </li><li>  CP, CM, RP, RM for the mark </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Notes </h3><br><ul><li>  The PCHL command performs an unconditional jump to an address in a pair of HL registers. </li><li>  I did not include RST previously reviewed in this group.  It writes the return address to the stack, and then goes to the predefined address at the bottom of the memory. </li></ul><br><h1>  Logical group </h1><br>  This group performs logical operations (see <a href="https://habr.com/post/418635/">first</a> tutorial <a href="https://habr.com/post/418635/">post</a> ).  By their nature, they are similar to an arithmetic group in that most operations work with register A (accumulator), and most operations affect flags.  All operations are performed on 8-bit values, in this group there are no commands that affect pairs of registers. <br><br><h3>  Boolean operations </h3><br>  AND, OR, NOT (CMP) and ‚Äúexclusive or‚Äù (XOR) are called boolean operations.  OR and AND I explained earlier.  The NOT command (for the 8080 processor, it is called CMA, or complement accumulator) simply changes the values ‚Äã‚Äãof the bits ‚Äî all units become zeros and zeros become ones. <br><br>  I see XOR as a ‚Äúdifference recognizer.‚Äù  Its truth table looks like this: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Result </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  one </td><td>  one </td></tr><tr><td>  one </td><td>  0 </td><td>  one </td></tr><tr><td>  one </td><td>  one </td><td>  0 </td></tr></tbody></table><br>  AND, OR, and XOR have a form for registers, memory, and immediate values.  (CMP has only a case-sensitive command).  Here is an implementation of a pair of opcodes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Cyclic shift commands </h3><br>  These commands change the order of the bits in the registers.  A shift to the right moves them to the right by one bit, and a shift to the left ‚Äî to the left by one bits: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  It seems that they are useless, but in reality it is not.  They can be used to multiply and divide by powers of two.  Take for example the shift to the left.  <code>0b00000001</code> is decimal 1, and shifting it to the left makes it <code>0b00000010</code> , that is, decimal 2. If we perform another shift to the left, we will get <code>0b00000100</code> , that is, 4. Another shift to the left, and we multiplied by 8. It will work with any in numbers: 5 ( <code>0b00000101</code> ) when shifting to the left gives 10 ( <code>0b00001010</code> ).  Another left shift gives 20 ( <code>0b00010100</code> ).  Shift to the right does the same, but for division. <br><br>  The 8080 does not have a multiplication command, but it can be implemented using these commands.  If you understand how to do this, you will receive bonus points.  Once such a question I was asked at the interview.  (I managed, although it took me a few minutes.) <br><br>  These commands perform a cyclic shift of the drive and affect only the carry flag.  Here are a couple of commands: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Comparison </h3><br>  The task of the CMP and CPI is only to set the flags (for branching).  They do this by subtracting, setting flags, but not saving the result. <br><br><ul><li>  Equal: if two numbers are equal, then the flag Z is set, since their subtraction from each other gives zero. </li><li>  Greater than: if A is greater than the comparison value, then the CY flag is cleared (since subtraction can be performed without borrowing). </li><li>  Less than: if A is less than the comparison value, then the CY flag is set (because A must borrow to complete the subtraction). </li></ul><br>  There are versions of these commands for registers, memory, and immediate values.  The implementation consists in a simple subtraction without saving the result: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC and STC </h3><br>  They complete the logical group.  They are used to set and reset the carry flag. <br><br><h1>  I / O group and special commands </h1><br>  These commands cannot be assigned to any other category.  I will mention them for completeness, but as it seems to me, we will have to return to them again when we start to emulate the ‚Äúhardware¬ª of Space Invaders. <br><br><ul><li>  EI and DI enable and disable the processor‚Äôs ability to handle interrupts.  I added the interrupt_enabled flag to the processor state structure, and set / reset it with these commands. </li><li>  It seems that RIM and SIM are mainly used for serial I / O.  If you're interested, you can read the directory, but these commands are not used in Space Invaders.  I will not emulate them. </li><li>  HLT is a stop.  I don‚Äôt think we need to emulate it, however you can call your quit code (or exit (0)) when you see this command. </li><li>  IN and OUT are commands that the 8080 processor hardware uses to communicate with external equipment.  For now, we will implement them, but they will not do anything except how to pass their byte of data.  (We will return to them later). </li><li>  NOP is ‚Äúno operation‚Äù.  One of the applications of the NOP is the control panel timing (four CPU cycles are required for execution). </li></ul><br>  Another application of NOP is code modification.  Suppose we need to change the ROM code of the game.  We can‚Äôt just delete unnecessary opcodes, because we don‚Äôt want to change all the CALL and JMP commands (they will be wrong if at least one part of the code moves).  With the help of NOP, we can get rid of the code.  <em>Adding code is much more difficult!</em>  <em>It can be added by finding somewhere in the ROM space and changing the command to JMP.</em> <br><br><h1>  Stack group </h1><br>  We have already completed the mechanics for most of the teams in the stack group.  If you did the work with me, then these commands will be easy to implement. <br><br><h3>  PUSH and POP </h3><br>  PUSH and POP work only with pairs of registers.  PUSH writes a pair of registers to the stack, and POP takes 2 bytes from the top of the stack and writes them into a pair of registers. <br><br>  There are four opcodes for PUSH and POP, one for each pair: BC, DE, HL and PSW.  PSW is a special pair of registers of drive flags and status codes.  Here is my implementation of PUSH and POP for BC and PSW.  There are no comments in it - I do not think that there is anything particularly clever. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL and XTHL </h3><br>  In the stack group there are two more teams - SPHL and XTHL. <br><br><ul><li>  <code>SPHL</code> moves HL to SP (forcing SP to get a new address). </li><li>  <code>XTHL</code> exchanges what is on top of the stack with what is in the pair of HL registers.  Why would it have to do?  I dont know. </li></ul><br><h1>  A little bit more about binary numbers </h1><br>  When writing a computer program, one of the solutions you need to make is the choice of the type of data used for the numbers - whether you want them to be negative and what their maximum size should be.  For a CPU emulator, we need the data type to match the data type of the target CPU. <br><br><h3>  Signed and unsigned </h3><br>  When we started talking about hex numbers, we considered them unsigned ‚Äî that is, each binary digit of a hexadecimal number had a positive value, and each was considered a power of two (one, two, four, etc.). <br><br>  We dealt with the storage of computer negative numbers.  If you know that the data in question has a sign, that is, they can be negative, then you can recognize a negative number by the most significant bit of the number (most significant bit, MSB).  If the data size is one byte, then each number with a specified value of the MSB bit is negative, and each with a zero MSB is positive. <br><br>  The value of a negative number is stored as an additional code.  If we have a sign number, and MSB is one, and we want to know what the number is, then we can convert it as follows: execute a binary "NOT" for hex numbers, and then add one. <br><br>  For example, for a hex number of 0x80, the MSB bit is set, that is, it is negative.  The binary NOT of the number 0x80 is 0x7f, or decimal 127. 127 + 1 = 128. That is, 0x80 in decimal form is -128.  The second example: 0xC5.  Not (0xC5) = 0x3A = decimal 58 +1 = decimal 59. That is, 0xC5 is decimal -59. <br><br>  Surprisingly in numbers with additional code, we can perform calculations with them as with unsigned numbers, and they <em>will</em> still <em>work</em> .  The computer does not need to do anything special with signs.  I will show a couple of examples proving this. <br><br><pre>  Example 1<font></font>
<font></font>
      decimal hex binary    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ This is entered in the carry bit.<font></font>
<font></font>
    Example 2    <font></font>
<font></font>
      decimal hex binary    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  In Example 1, we see that when adding 10 and -3 we get 7. The transfer of the result of addition was performed, therefore the C flag can be set. In Example 2, the result of addition was negative, therefore we decode it: Not (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Brain explosion! <br><br>  If you want, read more about the additional code in <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4">Wikipedia</a> . <br><br><h3>  Data types </h3><br>  In the C language, there is a relationship between data types and the number of bytes used for this type.  In fact, we are only interested in integers.  The standard / old school C data types are char, int and long, as well as their friends unsigned char, unsigned int and unsigned long.  The problem is that on different platforms and in different compilers, these types can have different sizes. <br><br>  Therefore, it would be best to choose a data type for our platform that explicitly declares the size of the data.  If your platform has stdint.h, you can use int8_t, uint8_t, etc. <br><br>  The size of an integer determines the maximum number that can be stored in it.  In the case of unsigned integers in 8 bits, you can store numbers from 0 to 255. If converted to hex, it is from 0x00 to 0xFF.  Since 0xFF "all bits are set," and it corresponds to the decimal 255, it is absolutely logical that the interval of one-byte unsigned integer is 0-255.  Intervals tell us that all the sizes of integers will work exactly the same - the numbers correspond to the number that is obtained by setting all the bits. <br><br><table><tbody><tr><th>  Type of </th><th>  Interval </th><th>  Hex </th></tr><tr><td>  8-bit unsigned </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8-bit signed </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16-bit unsigned </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  16-bit signed </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32-bit unsigned </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFF </td></tr><tr><td>  32-bit signed </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  More interestingly, the -1 in each character data type is a number that has all the bits set (0xFF for the sign byte, 0xFFFF for the sign 16-bit number, and 0xFFFFFFFF for the sign 32-bit number).  If the data is considered unsigned, then for all given bits the maximum possible number for this data type is obtained. <br><br>  To emulate the registers of the processor, we select the data type corresponding to the size of this register.  Probably the default is to select unsigned types and convert them when you need to consider them signed.  For example, we use the uint8_t data type to represent an 8-bit register. <br><br><h3>  Hint: use a debugger to convert data types </h3><br>  If gdb is installed on your platform, it is very convenient to use it for working with binary numbers.  Below I will show an example ‚Äî in the session shown below, the lines beginning with # are comments added by me later. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  When I work with hex numbers, I always do it in gdb - and this happens almost every day.  So much easier than opening a programmer's calculator with a GUI.  On Linux (and Mac OS X) machines, to start a gdb session, simply open the terminal and enter ‚Äúgdb‚Äù.  If you are using Xcode on OS X, then after running the program, you can use the console inside Xcode (the one to which the printf output is output).  On Windows, the gdb debugger is available from Cygwin. <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cpu emulator completion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received all this information, you are ready for a long journey. </font><font style="vertical-align: inherit;">You have to decide for yourself how to implement the emulator ‚Äî either create a full 8080 emulation, or implement only the commands necessary to complete the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you decide to do a full emulation, then you will need a few more tools. </font><font style="vertical-align: inherit;">I will talk about them in the next section. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another way is to emulate only the instructions used by the game. </font><font style="vertical-align: inherit;">We will continue to fill that huge construction of switch, which was created in the "Emulator Shell" section. </font><font style="vertical-align: inherit;">We will repeat the following process until we have not a single unrealized team:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We start the emulator from ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The call </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is exiting if the command is not ready.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We emulate this instruction </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goto 1 </font></font></li></ol><br> ,   ,     ‚Äî     .     ,    : <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br>             . <br><br>  :  ,      50  ,      8080.     ,   : <br><br><table><tbody><tr><th>  </th><th>  Team </th></tr><tr><td> 0x00 </td><td> NOP </td></tr><tr><td> 0x01 </td><td> LXI B,D16 </td></tr><tr><td> 0x05 </td><td> DCR B </td></tr><tr><td> 0x06 </td><td> MVI B,D8 </td></tr><tr><td> 0x09 </td><td> DAD B </td></tr><tr><td> 0x0d </td><td> DCR C </td></tr><tr><td> 0x0e </td><td> MVI C,D8 </td></tr><tr><td> 0x0f </td><td> RRC </td></tr><tr><td> 0x11 </td><td> LXI D,D16 </td></tr><tr><td> 0x13 </td><td> INX D </td></tr><tr><td> 0x19 </td><td> DAD D </td></tr><tr><td> 0x1a </td><td> LDAX D </td></tr><tr><td> 0x21 </td><td> LXI H,D16 </td></tr><tr><td> 0x23 </td><td> INX H </td></tr><tr><td> 0x26 </td><td> MVI H,D8 </td></tr><tr><td> 0x29 </td><td> DAD H </td></tr><tr><td> 0x31 </td><td> LXI SP,D16 </td></tr><tr><td> 0x32 </td><td> STA adr </td></tr><tr><td> 0x36 </td><td> MVI M,D8 </td></tr><tr><td> 0x3a </td><td> LDA adr </td></tr><tr><td> 0x3e </td><td> MVI A,D8 </td></tr><tr><td> 0x56 </td><td> MOV D,M </td></tr><tr><td> 0x5e </td><td> MOV E,M </td></tr><tr><td> 0x66 </td><td> MOV H,M </td></tr><tr><td> 0x6f </td><td> MOV L,A </td></tr><tr><td> 0x77 </td><td> MOV M,A </td></tr><tr><td> 0x7a </td><td> MOV A,D </td></tr><tr><td> 0x7b </td><td> MOV A,E </td></tr><tr><td> 0x7c </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Push b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RET </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Push d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Push h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Push psw </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EI </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These are only 50 instructions, and 10 of them are movements that are implemented trivially. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debugging </font></font></h3><br>       .         ,        .   ,      (   ,    ),     ,   . <br><br>           ‚Äî     ,   .  ,      ,        . ,    .     . ,   ,       ,    : <br><br><ol><li>      </li><li>     </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For the next team </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call your emulator with your status. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call my with my condition </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare our two states </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look for errors in any differences. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goto 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another way is to use </font></font><a href="http://bluishcoder.co.nz/js8080/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> manually </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is an emulator processor 8080 for Javascript, which even has a built-in ROM Space Invaders. </font><font style="vertical-align: inherit;">Here is the process:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Restart Space Invaders emulation by clicking the "Space Invaders" button </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Press the "Run 1" button to execute the command. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We execute the following command in our emulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare the status of the processor with your </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the states match, goto 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the states do not match, then your instruction emulation is wrong. </font><font style="vertical-align: inherit;">Repair it, and then start over from step 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I used this method at the beginning to debug my 8080 emulator. I will not lie - the process can be a long one. Many of my problems resulted in typos and copy-pasting errors, which after detection were very easy to fix. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you step through your code step by step, then most of the first 30 thousand commands are executed in a loop around $ 1a5f. If you look at the </font></font><a href="http://bluishcoder.co.nz/js8080/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emulator in javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can see that this code copies the data to the screen. I am sure that this code is called frequently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the first screen drawing, after 50 thousand commands, the program gets stuck in this infinite loop:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He waits until the value in memory at $ 20c0 changes to zero. </font><font style="vertical-align: inherit;">Since the code in this loop definitely does not change $ 20c0, it must be a signal from somewhere else. </font><font style="vertical-align: inherit;">It's time to talk about the emulation of the "iron" arcade machine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we move on to the next section, make sure your CPU emulator falls into this infinite loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For help, see </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my sources</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8080 full emulation </font></font></h1><br> ,   :   ,    .        .     ,     .         ,     . <br><br>     ,       8080     .   <a href="http://brainwagon.org/2011/09/08/more-on-my-8080-emulator/">  8080</a>   cpudiag.asm,       8080. <br><br>           : <br><br><ol><li>  ,          .  ,   cpudiag.asm    . </li><li>   ,   . ,        ,      . </li></ol><br>         .          . <br><br><h3>   </h3><br>    ,       <a href="http://sensi.org/~svo/i8080/">  </a> .    cpudiag.asm   ,     .   ,  ,   ,     ¬´Make Beautiful Code¬ª  ,      test.bin,    8080.     ,   . <br><br> <a href=""> cpudiag.asm</a>     . <br><br> <a href=""> cpudiag.bin</a> (  8080)   . <br><br><h3>      </h3><br>    invaders.*     . <br><br>    . -,       <code>ORG 00100H</code> ,   ,      ,       0x100 hex.         8080,   ,    .    ,  ,          ,     0x100. <br><br> -,      ,           .       hex- <code>JMP $0100</code> ,    . (     PC   0x100.) <br><br> -,      . ,         <code>STACK EQU TEMPP+256</code> ,    .     ,        $6ad,    PUSH   .  ,        0x100,    ,   ,  ¬´0x7¬ª   ,   . <br><br> ,        DAA   ,   ,     (     JMP). <br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3>     </h3><br> ,        CP/M.  ,   CP/M      $0005,    ,     CALL,    .  ,    ,      ,    .   CALL      : <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this test, I found several problems in my emulator. I'm not sure which of them would be involved in the game, but if they were, then it would be very difficult to find them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I went ahead and implemented all opcodes (except for DAA and his friends). Solving problems in my calls and implementing new ones took me 3-4 hours. It was definitely faster than the manual process I described above ‚Äî before I found this test, I spent more than 4 hours on the manual process. If you can understand this explanation, I recommend using this method instead of comparing manually. However, knowledge of the manual process is also an excellent skill, and if you want to emulate a different processor, you should return to it.</font></font><br><br>            ,                .          ,       . </div><p>Source: <a href="https://habr.com/ru/post/418699/">https://habr.com/ru/post/418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418685/index.html">Procedural level generation</a></li>
<li><a href="../418687/index.html">The 3.5 "revolution: details of a small diskette boom with wavepave music</a></li>
<li><a href="../418689/index.html">How to create a library of components in Figma, saving the budget, for example, an online auction</a></li>
<li><a href="../418691/index.html">Rancher: Kubernetes in 5 minutes on bare iron</a></li>
<li><a href="../418695/index.html">Anti-Piracy Wars - The Empire Strikes Back</a></li>
<li><a href="../418705/index.html">Futex basics</a></li>
<li><a href="../418709/index.html">You need to force yourself: drivers and barriers in interfaces</a></li>
<li><a href="../418711/index.html">Token-Managed Registries 1.0</a></li>
<li><a href="../418713/index.html">Game to improve the quality of Wikipedia</a></li>
<li><a href="../418715/index.html">How effective is the procfs virtual file system and can it be optimized?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>