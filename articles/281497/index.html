<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experiments with malloc</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As is known, in modern x86 (_64) and ARM architectures, the virtual memory of the process is linear and continuous, for, fortunately, the times of cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experiments with malloc</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/d18/73c/a7cd1873c8283ea2c9eefe85b0b5f117.jpg" alt="image"><br><br>  As is known, in modern x86 (_64) and ARM architectures, the virtual memory of the process is linear and continuous, for, fortunately, the times of <code>char near*</code> and <code>int huge*</code> have passed.  Virtual memory is divided into pages, the typical size of which is 4 KiB, and by default they are not mapped to physical memory, so working with them will not work.  To see the current mapped address intervals for a process, on Linux, look at / proc / &lt;pid&gt; / maps, on OS X, vmmap &lt;pid&gt;.  Each address interval has three types of protection: from execution, from writing and from reading.  As you can see, the very first interval, starting with the load address (corresponding to the .text segment of the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> in Linux, __TEXT and <a href="https://en.wikipedia.org/wiki/Mach-O">Mach-O</a> in OS X), is readable and executable - very logical.  You can also see that the stack is essentially no different from other intervals, and you can quickly calculate its size by subtracting the initial address from the end address.  Pages are <a href="http://google.com/search%3Fq%3Dman%2520mmap">displayed</a> using <a href="http://google.com/search%3Fq%3Dman%2520mmap">mmap / munmap</a> , and protection is changed using <a href="http://google.com/search%3Fq%3Dman%2520mprotect">mprotect</a> .  There are also <a href="https://en.wikipedia.org/wiki/Sbrk">brk / sbrk</a> , deprecated ancient remnants of the past, which change the size of a single interval of "data" and are emulated by mmap in modern systems. <br><br>  All malloc POSIX implementations in one way or another run into the functions listed above.  Compared with the naive selection and release of pages, rounding the required size in a big way, malloc has many advantages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  optimally manages already allocated memory; </li><li>  significantly reduces the number of calls to the kernel (after all, mmap / sbrk is <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2">syscall</a> ); </li><li>  generally abstracts the programmer from virtual memory, so many people use malloc without knowing at all about the existence of pages, translation tables, etc. </li></ul><br>  Enough theory!  We will feel malloc in practice.  We will conduct three experiments.  Work will be possible on POSIX-compatible OSes, in particular, work on Linux and OS X was tested. <br><a name="habracut"></a><br><h1>  Null from malloc </h1><br>  Let's start with the banal.  If you override the function from libc (as well as any other library) in your code, then the linker will not mind if libc is dynamically connected (and by default it is), and will not swear at the double definition.  For example, such code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; void* malloc(size_t size) { puts("malloc"); return NULL; } int main() { return (int)malloc(100500); }</span></span></span></span></code> </pre><br>  It will print "malloc" and have a zero return code ( <code>echo $?</code> ).  However, let's check what happens if we call a function in the depths of which malloc is called, for example asprintf. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// program.c #include &lt;stdio.h&gt; #include &lt;stddef.h&gt; void* malloc(size_t size) { puts("malloc"); return NULL; } int main() { char *s = NULL; asprintf(&amp;s, "%d", 0); printf("%p\n", s); return 0; }</span></span></code> </pre><br>  And here it will greatly depend on the linker.  If it is ld / linux then it will print <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (nil)</code> </pre><br>  For malloc will be called ours, redefined, and the glibc implementation of printf does not use malloc.  The redefinition came about because malloc in glibc is declared <a href="https://en.wikipedia.org/wiki/Weak_symbol">weak</a> (__attribute __ ((weak))), and our default definition is strong (ELF specific).  But with dyld / OS X, the behavior is different: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fc1eb403230</span></span></code> </pre><br>  In fact, malloc on the poppy is not overridden!  The point should be in multi-level dyld namespaces.  Well, well ... <br><br><pre> <code class="cpp hljs">DYLD_FORCE_FLAT_NAMESPACE=<span class="hljs-number"><span class="hljs-number">1</span></span> ./program Segmentation fault: <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre><br>  Hryav Baba buddy!  The matter, apparently, did not even reach int main ().  What is the reason? <br><br><pre> <code class="cpp hljs">lldb lldb ./program (lldb) target create <span class="hljs-string"><span class="hljs-string">"./program"</span></span> Current executable <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> to <span class="hljs-string"><span class="hljs-string">'./program'</span></span> (x86_64). (lldb) env DYLD_FORCE_FLAT_NAMESPACE=<span class="hljs-number"><span class="hljs-number">1</span></span> (lldb) r Process <span class="hljs-number"><span class="hljs-number">11956</span></span> launched: <span class="hljs-string"><span class="hljs-string">'./program'</span></span> (x86_64) Process <span class="hljs-number"><span class="hljs-number">11956</span></span> stopped * thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: tid = <span class="hljs-number"><span class="hljs-number">0x12e214</span></span>, <span class="hljs-number"><span class="hljs-number">0x00007fff9ebb9dcb</span></span> libsystem_kernel.dylib`ioctl + <span class="hljs-number"><span class="hljs-number">67</span></span>, stop reason = EXC_BAD_ACCESS (code=<span class="hljs-number"><span class="hljs-number">2</span></span>, address=<span class="hljs-number"><span class="hljs-number">0x7fff5f3ffff8</span></span>) frame #<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9ebb9dcb</span></span> libsystem_kernel.dylib`ioctl + <span class="hljs-number"><span class="hljs-number">67</span></span> libsystem_kernel.dylib`ioctl: -&gt; <span class="hljs-number"><span class="hljs-number">0x7fff9ebb9dcb</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">67</span></span>&gt;: movq %rcx, <span class="hljs-number"><span class="hljs-number">-0xb8</span></span>(%rbp) <span class="hljs-number"><span class="hljs-number">0x7fff9ebb9dd2</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">74</span></span>&gt;: movq %rdx, <span class="hljs-number"><span class="hljs-number">-0xc0</span></span>(%rbp) <span class="hljs-number"><span class="hljs-number">0x7fff9ebb9dd9</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">81</span></span>&gt;: leaq <span class="hljs-number"><span class="hljs-number">-0xd0</span></span>(%rbp), %rax <span class="hljs-number"><span class="hljs-number">0x7fff9ebb9de0</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">88</span></span>&gt;: movq %rax, <span class="hljs-number"><span class="hljs-number">-0x10</span></span>(%rbp) (lldb) bt * thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: tid = <span class="hljs-number"><span class="hljs-number">0x12e214</span></span>, <span class="hljs-number"><span class="hljs-number">0x00007fff9ebb9dcb</span></span> libsystem_kernel.dylib`ioctl + <span class="hljs-number"><span class="hljs-number">67</span></span>, stop reason = EXC_BAD_ACCESS (code=<span class="hljs-number"><span class="hljs-number">2</span></span>, address=<span class="hljs-number"><span class="hljs-number">0x7fff5f3ffff8</span></span>) * frame #<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9ebb9dcb</span></span> libsystem_kernel.dylib`ioctl + <span class="hljs-number"><span class="hljs-number">67</span></span> frame #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a20f2c8</span></span> libsystem_c.dylib`isatty + <span class="hljs-number"><span class="hljs-number">43</span></span> frame #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a222ac6</span></span> libsystem_c.dylib`__smakebuf + <span class="hljs-number"><span class="hljs-number">60</span></span> frame #<span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a237b4a</span></span> libsystem_c.dylib`__swsetup + <span class="hljs-number"><span class="hljs-number">155</span></span> frame #<span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a221d52</span></span> libsystem_c.dylib`__sfvwrite + <span class="hljs-number"><span class="hljs-number">73</span></span> frame #<span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a2264c9</span></span> libsystem_c.dylib`<span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> + <span class="hljs-number"><span class="hljs-number">144</span></span> frame #<span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0x0000000100000f0b</span></span> program`<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size=<span class="hljs-number"><span class="hljs-number">4096</span></span>) + <span class="hljs-number"><span class="hljs-number">27</span></span> at program.c:<span class="hljs-number"><span class="hljs-number">6</span></span> frame #<span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a222af6</span></span> libsystem_c.dylib`__smakebuf + <span class="hljs-number"><span class="hljs-number">108</span></span> frame #<span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a237b4a</span></span> libsystem_c.dylib`__swsetup + <span class="hljs-number"><span class="hljs-number">155</span></span> ... frame #<span class="hljs-number"><span class="hljs-number">130931</span></span>: <span class="hljs-number"><span class="hljs-number">0x0000000100000f0b</span></span> program`<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size=<span class="hljs-number"><span class="hljs-number">4096</span></span>) + <span class="hljs-number"><span class="hljs-number">27</span></span> at program.c:<span class="hljs-number"><span class="hljs-number">6</span></span> frame #<span class="hljs-number"><span class="hljs-number">130932</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a222af6</span></span> libsystem_c.dylib`__smakebuf + <span class="hljs-number"><span class="hljs-number">108</span></span> frame #<span class="hljs-number"><span class="hljs-number">130933</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a237b4a</span></span> libsystem_c.dylib`__swsetup + <span class="hljs-number"><span class="hljs-number">155</span></span> frame #<span class="hljs-number"><span class="hljs-number">130934</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a221d52</span></span> libsystem_c.dylib`__sfvwrite + <span class="hljs-number"><span class="hljs-number">73</span></span> frame #<span class="hljs-number"><span class="hljs-number">130935</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff9a2264c9</span></span> libsystem_c.dylib`<span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> + <span class="hljs-number"><span class="hljs-number">144</span></span> frame #<span class="hljs-number"><span class="hljs-number">130936</span></span>: <span class="hljs-number"><span class="hljs-number">0x0000000100000f0b</span></span> program`<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size=<span class="hljs-number"><span class="hljs-number">8</span></span>) + <span class="hljs-number"><span class="hljs-number">27</span></span> at program.c:<span class="hljs-number"><span class="hljs-number">6</span></span> frame #<span class="hljs-number"><span class="hljs-number">130937</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc1d22e</span></span> dyld`<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) + <span class="hljs-number"><span class="hljs-number">30</span></span> frame #<span class="hljs-number"><span class="hljs-number">130938</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc095a5</span></span> dyld`<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__1::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &gt;::insert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::__1::__wrap_iter, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* (* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)(dyld_image_states, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, dyld_image_info <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*)) + <span class="hljs-number"><span class="hljs-number">343</span></span> frame #<span class="hljs-number"><span class="hljs-number">130939</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc04507</span></span> dyld`dyld::registerImageStateBatchChangeHandler(dyld_image_states, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* (*)(dyld_image_states, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, dyld_image_info <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*)) + <span class="hljs-number"><span class="hljs-number">147</span></span> frame #<span class="hljs-number"><span class="hljs-number">130940</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff8bb8089e</span></span> libdyld.dylib`dyld_register_image_state_change_handler + <span class="hljs-number"><span class="hljs-number">76</span></span> frame #<span class="hljs-number"><span class="hljs-number">130941</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff8bb8065f</span></span> libdyld.dylib`_dyld_initializer + <span class="hljs-number"><span class="hljs-number">47</span></span> frame #<span class="hljs-number"><span class="hljs-number">130942</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff982829fd</span></span> libSystem.B.dylib`libSystem_initializer + <span class="hljs-number"><span class="hljs-number">116</span></span> frame #<span class="hljs-number"><span class="hljs-number">130943</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc12feb</span></span> dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) + <span class="hljs-number"><span class="hljs-number">265</span></span> frame #<span class="hljs-number"><span class="hljs-number">130944</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc13164</span></span> dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) + <span class="hljs-number"><span class="hljs-number">40</span></span> frame #<span class="hljs-number"><span class="hljs-number">130945</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc0f79d</span></span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="hljs-number"><span class="hljs-number">305</span></span> frame #<span class="hljs-number"><span class="hljs-number">130946</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc0f732</span></span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="hljs-number"><span class="hljs-number">198</span></span> frame #<span class="hljs-number"><span class="hljs-number">130947</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc0f623</span></span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="hljs-number"><span class="hljs-number">127</span></span> frame #<span class="hljs-number"><span class="hljs-number">130948</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc0f893</span></span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="hljs-number"><span class="hljs-number">75</span></span> frame #<span class="hljs-number"><span class="hljs-number">130949</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc020f1</span></span> dyld`dyld::initializeMainExecutable() + <span class="hljs-number"><span class="hljs-number">208</span></span> frame #<span class="hljs-number"><span class="hljs-number">130950</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc05e5d</span></span> dyld`dyld::_main(macho_header <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>**, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>**, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>**, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) + <span class="hljs-number"><span class="hljs-number">3793</span></span> frame #<span class="hljs-number"><span class="hljs-number">130951</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc01276</span></span> dyld`dyldbootstrap::start(macho_header <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>**, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, macho_header <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*) + <span class="hljs-number"><span class="hljs-number">512</span></span> frame #<span class="hljs-number"><span class="hljs-number">130952</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc01036</span></span> dyld`_dyld_start + <span class="hljs-number"><span class="hljs-number">54</span></span></code> </pre><br>  What kind of frame?  130952  Yes, it turns out we have Stack Overflow!  And we also learned a few curious things: dyld is written in C ++, and puts for some reason allocates memory thus malloc, creating recursion.  I want to believe that he does this only once when initializing the stdout buffer.  Well, we have to replace it: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stddef.h&gt; #include &lt;unistd.h&gt; void* malloc(size_t size) { write(STDOUT_FILENO, "malloc\n", 7); return NULL; } int main() { char *s = NULL; asprintf(&amp;s, "%d", 0); printf("%p\n", s); return 0; }</span></span></span></span></code> </pre><br>  Run and see: <br><br><pre> <code class="html hljs xml">malloc malloc malloc Segmentation fault: 11</code> </pre><br>  Stack fragment: <br><br><pre> <code class="cpp hljs">* thread #<span class="hljs-number"><span class="hljs-number">1</span></span>: tid = <span class="hljs-number"><span class="hljs-number">0x1309af</span></span>, <span class="hljs-number"><span class="hljs-number">0x00007fff5fc249ce</span></span> dyld`_platform_bzero + <span class="hljs-number"><span class="hljs-number">94</span></span>, stop reason = EXC_BAD_ACCESS (code=<span class="hljs-number"><span class="hljs-number">1</span></span>, address=<span class="hljs-number"><span class="hljs-number">0x8</span></span>) * frame #<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc249ce</span></span> dyld`_platform_bzero + <span class="hljs-number"><span class="hljs-number">94</span></span> frame #<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc14045</span></span> dyld`<span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span> + <span class="hljs-number"><span class="hljs-number">52</span></span> frame #<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc0ce14</span></span> dyld`__cxa_get_globals + <span class="hljs-number"><span class="hljs-number">100</span></span> frame #<span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc1ce7f</span></span> dyld`__cxa_throw + <span class="hljs-number"><span class="hljs-number">25</span></span> frame #<span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0x00007fff5fc1d267</span></span> dyld`<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) + <span class="hljs-number"><span class="hljs-number">87</span></span></code> </pre><br>  So, it is clear that, unlike GNU / Linux, whose ld is made on static allocation, a lot is heavily used when running an application in OS X.  You can also see that throwing an exception about a failed allocation of memory by the operator new calls calloc, which, as we remember, is the combination malloc + zero-fill (bzero).  The calloc implementation got a bold one and did not check the null pointer.  With this knowledge, now I wondered what would happen if OS X truly runs out of memory, ‚Äúto the last byte‚Äù.  Obviously, the correct and logical solution would be to preallocate memory for std :: bad_alloc. <br><br>  Ok, Google, how do we still redefine malloc under OS X so that nothing falls?  We'll have to plunge into the implementation details.  Malloc on Macs allocates memory in zones.  Initially, there is only one zone, by default, and that is what vmmap will show at the end of the output.  Each zone stores pointers to malloc, free and realloc, which allows you to flexibly customize memory management.  You can take the default zone and replace the pointer with malloc in it: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stddef.h&gt; #include &lt;unistd.h&gt; #include &lt;malloc/malloc.h&gt; #include &lt;sys/mman.h&gt; void* zone_malloc(struct _malloc_zone_t *zone, size_t size) { write(STDOUT_FILENO, "malloc\n", 7); return NULL; } int main() { malloc_zone_t* zone = malloc_default_zone(); mprotect(zone, sizeof(*zone), PROT_READ | PROT_WRITE); zone-&gt;malloc = zone_malloc; mprotect(zone, sizeof(*zone), PROT_READ); char *s = NULL; asprintf(&amp;s, "%d", 0); printf("%p\n", s); return 0; }</span></span></span></span></code> </pre><br>  Pay attention to mprotect.  Initially, malloc_default_zone returns a pointer to a memory area that is write-protected.  You can easily verify this by running the program without mprotect and examining the crash in the debugger and vmmap.  Such protection is obtained from playful hands ... Back to PROT_READ, strictly speaking, protection could not be changed, added for the sake of order.  What will be printed: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span></code> </pre><br>  We see that printf used malloc, but then found the strength to do without dynamic memory and still printed out a null pointer. <br><br>  By the way, about the zones.  Malloc in glibc uses a similar approach, called obstacks.  On the one hand, there are <a href="http://www.gnu.org/software/libc/manual/html_node/Obstacks.html">many functions</a> for working with them, on the other hand, there is no possibility to use different memory allocation algorithms in different obstacles. <br><br>  Output: <b>dyld, the OS X loader, is written in C ++ and working with a bunch in programs on this system begins long before int main ().</b>  <b>C ld on Linux this does not happen and there are no calls to the heap.</b> <br><br><h1>  Ineffective malloc </h1><br>  Now let's set a new goal for ourselves: create a dynamic library in which we implement our version of malloc. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// hack_malloc.c #define _GNU_SOURCE #include &lt;stdio.h&gt; #include &lt;stddef.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; void* malloc(size_t size) { write(STDOUT_FILENO, "malloc... ", 10); size += sizeof(size_t); int page_size = getpagesize(); int rem = size % page_size; if (rem &gt; 0) { size += page_size - rem; } void* addr = mmap(0, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); if (addr == MAP_FAILED) { write(STDOUT_FILENO, "fail\n", 5); return NULL; } write(STDOUT_FILENO, "ok\n", 3); *(size_t*)addr = size; return (size_t*)addr + 1; } void free (void *ptr) { write(STDOUT_FILENO, "free... ", 8); size_t* real_ptr = (size_t*)ptr - 1; if (!munmap(real_ptr, *real_ptr)) { write(STDOUT_FILENO, "ok\n", 3); } else { write(STDOUT_FILENO, "fail\n", 5); } }</span></span></code> </pre><br>  Here the simplest approach is implemented when we allocate memory by pages.  It is necessary to store the size at the beginning of the page in order to have something to transfer to unmap.  MAP_ANONYMOUS in mmap flags means that we are not mapping the actual file into memory, but physical memory (usually, mmap maps the files to memory, this gives acceleration in some operations).  In the case of files, MAP_PRIVATE would create an individual copy at write (copy-on-write), but for us, in essence, does nothing, just the documentation requires the presence of either MAP_PRIVATE or MAP_SHARED.  By the way, this code also works great with MAP_SHARED. <br><br>  We will check by example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// test.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { printf("start\n"); void* mem = malloc(100); printf("malloc() -&gt; %p\n", mem); *(int*)mem = 0; free(mem); printf("end\n"); return 0; }</span></span></code> </pre><br>  We will collect so: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#Linux gcc -shared -o libhackmalloc.so -fPIC -std=c99 -O2 hack_malloc.c gcc test.c -std=c99 -L. -Wl,-rpath,. -lhackmalloc -O2 -o test # Mac OS X clang -dynamiclib -undefined suppress -flat_namespace -std=c99 -fPIC -O2 hack_malloc.c -o libhackmalloc.dylib clang test.c -std=c99 -L. -lhackmalloc -O2 -o test</span></span></code> </pre><br>  At startup, we will see: <br><br><pre> <code class="bash hljs">./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> start malloc... ok malloc() -&gt; 0x10935b008 free... ok end</code> </pre><br>  The output for OS X and Linux is identical.  In the case of OS X, we recall the dyld namespaces and make them flat, like the Windows 10 interface. <br><br><pre> <code class="bash hljs">DYLD_FORCE_FLAT_NAMESPACE=1 ./<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> malloc... ok malloc... ok free... ok malloc... ok malloc... ok free... fail free... fail free... fail malloc... ok malloc... ok free... fail malloc... ok 70  free... fail 17  malloc... ok free... ok malloc... ok malloc... ok malloc... ok free... fail malloc... ok start malloc... ok malloc() -&gt; 0x1035d9008 free... ok end</code> </pre><br>  The program has worked, and already well.  What is surprising is the apparent discrepancy between the number of calls to malloc and free before int main ().  Also free failed many times.  Those who are interested can run the test in the debugger, set the breakpoint on free and learn about the dark life of dyld a lot of new things, and we will move on. <br><br>  Conclusion: <b>it is quite possible to write the implementation of malloc "in the forehead" in 30 lines.</b> <br><br><h1>  Spying on malloc </h1><br>  Let's try to use DLL injection technique to inject our malloc into other people's programs.  I do not want to write my own effective implementation of the heap, although there are many interesting algorithms, for example <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">Buddy</a> .  It would be possible to take any of the <a href="https://en.wikipedia.org/wiki/C_dynamic_memory_allocation">ready-made implementations</a> , but we will apply the trick with RTLD_NEXT and refer to the system malloc.  Consider this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// trace_malloc.c #define _GNU_SOURCE #include &lt;dlfcn.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int fd = 0; void* (*__malloc)(size_t) = NULL; void* malloc(size_t size) { if (!__malloc) { __malloc = (void*(*)(size_t)) dlsym(RTLD_NEXT, "malloc"); } if (!fd) { fd = open("malloc.log", O_WRONLY | O_CREAT | O_TRUNC, 0666); } /* ... */ write(fd, record, sprintf(record, "%ld.%06ld\t%zu\n", sec, mcsec, size)); return __malloc(size); }</span></span></code> </pre><br>  A link to the full version of the code will be given at the end of the article.  A half of it was eaten by the cross-platform implementation of clock_gettime, and the second by reference to clock_gettime, so I was forced to shorten it a bit.  All the beauty in one single line: <br><br><pre> <code class="cpp hljs">__malloc = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*(*)(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)) dlsym(RTLD_NEXT, <span class="hljs-string"><span class="hljs-string">"malloc"</span></span>);</code> </pre><br>  In it, we load the ‚Äúprevious‚Äù malloc.  Usually dlsym is used to pull functions from loaded dynamic libraries, but we use magic RTLD_NEXT as a library descriptor.  Strictly speaking, it is not in POSIX, but in fact it is supported by many linkers.  So we get a pointer to true malloc, save it, and call it later, returning its result.  Along the way, log all calls. <br><br>  We build the same way as hack_malloc.c, use on Linux like this: <br><br><pre> <code class="bash hljs">LD_PRELOAD=/path/to/libtracemalloc.so program</code> </pre><br>  The path must be absolute, otherwise the magic will not happen.  LD_PRELOAD is a special environment variable that forcibly loads these libraries before the main ones with which the program is compiled.  Thus, you can override arbitrary functions or solve temporary problems with running incorrectly linked programs (that is the lib * .so: not found message). <br><br>  Ls, for example, creates about 2 KB of log.  And whoami will drop with the message undefined symbol: dlsym, because dlsym is defined in libdl.so, which some load and some do not.  And it makes no sense to build libtracemalloc with -ldl, since LD_PRELOAD will not load the dependencies of the injected libraries.  We'll have to do something like this: <br><br><pre> <code class="bash hljs">LD_PRELOAD=/usr/lib/.../libdl.so:/path/to/libtracemalloc.so whoami</code> </pre><br>  And we will see a kilobyte log of memory allocation even in the case of such an elementary utility. <br><br>  Ok, and what about OS X?  Dyld supports the DYLD_INSERT_LIBRARIES environment variable, which does the same thing.  We try: <br><br><pre> <code class="bash hljs">DYLD_INSERT_LIBRARIES=/path/to/libtracemalloc.dylib ls</code> </pre><br>  ... does not work, remembering the namespace: <br><br><pre> <code class="bash hljs">DYLD_INSERT_LIBRARIES=/path/to/libtracemalloc.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ls</code> </pre><br>  ... and again, bummer.  Already interesting!  It turns out that the case in the protection of system programs <a href="https://en.wikipedia.org/wiki/System_Integrity_Protection">System Integrity Protection</a> .  This mechanism does not allow changing files, injecting code, debugging paths like / System, / usr, etc. using extended file attributes. Fortunately, / usr / local has been pardoned. <br><br><pre> <code class="bash hljs">lldb /bin/ls (lldb) target create <span class="hljs-string"><span class="hljs-string">"/bin/ls"</span></span> Current executable <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> to <span class="hljs-string"><span class="hljs-string">'/bin/ls'</span></span> (x86_64). (lldb) r error: process exited with status -1 (cannot attach to process due to System Integrity Protection)</code> </pre><br>  SIP can be disabled, but we will do it easier - we will copy the programs we are interested in to our directory: <br><br><pre> <code class="bash hljs">cp $(<span class="hljs-built_in"><span class="hljs-built_in">which</span></span> ls) . DYLD_INSERT_LIBRARIES=/path/to/libtracemalloc.dylib DYLD_FORCE_FLAT_NAMESPACE=1 ./ls</code> </pre><br>  This is already working.  In conclusion, we prove the well-known thesis on two types of memory allocation.  Create a malloc log and build a histogram of size distribution using an elementary IPython code: <br><br><pre> <code class="python hljs">%pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas, seaborn log = pandas.DataFrame.from_csv(<span class="hljs-string"><span class="hljs-string">"malloc.log"</span></span>, sep=<span class="hljs-string"><span class="hljs-string">'\t'</span></span>) log[log &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>].hist() log[log &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>].count() / len(log)</code> </pre><br>  A typical picture will be visible on the size histogram (Y is the number of calls, X is the size, the program is clang): <br><br><img src="https://habrastorage.org/files/39e/3c0/075/39e3c00759664404bc7d6094dd921b4f.png"><br><br>  I deliberately cut the tail on 100 bytes, since larger allocations are so rare that they are not visible on the histogram.  So, <b>98% of all memory allocations on the heap are less than 100 bytes, which means that a good malloc should serve at least two separate domains: for large objects and for all others.</b> <br><br>  Note that in order to analyze your program, you can not mess around with the self-assembling library like the one described above, but take the ready one.  For example, <a href="http://goog-perftools.sourceforge.net/doc/heap_profiler.html">tcmalloc</a> allows <a href="http://goog-perftools.sourceforge.net/doc/heap_profiler.html">you</a> to profile a bunch and do many other useful things. <br><br>  The code from the article is available on <a href="https://github.com/vmarkovtsev/hack_malloc">github</a> .  Next time we will take a real, large program, collect a log of memory allocations during its work and try to make predictions based on the LSTM model of the recursive neural network. </div><p>Source: <a href="https://habr.com/ru/post/281497/">https://habr.com/ru/post/281497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281485/index.html">Methods to optimize the reception / transmission in Wi-Fi networks</a></li>
<li><a href="../281487/index.html">Competition "Admin 80 level" from RUVDS</a></li>
<li><a href="../281491/index.html">About extended support and maintenance of IT infrastructures</a></li>
<li><a href="../281493/index.html">From love to hate - one step, or how I stopped loving magic in ActiveRecord</a></li>
<li><a href="../281495/index.html">C # math expression parser - amateur experience</a></li>
<li><a href="../281499/index.html">Macros in Emacs: form teams for processing</a></li>
<li><a href="../281501/index.html">Project Tofino - the new Mozilla browser</a></li>
<li><a href="../281503/index.html">Interfaces: How not to do the option of unsubscribing from the email-list</a></li>
<li><a href="../281505/index.html">How we implemented DevOps: infrastructure-as-code using Microsoft Azure and Azure Resource Manager</a></li>
<li><a href="../281509/index.html">5G core networks: flexibility opens up new business opportunities</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>