<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Top errors from the development side when working with PostgreSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HighLoad ++ has been around for a long time, and we talk about working with PostgreSQL regularly. But developers are still from month to month, from y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Top errors from the development side when working with PostgreSQL</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://www.highload.ru/">HighLoad ++</a> has been <a href="https://www.highload.ru/">around for</a> a long time, and we talk about working with PostgreSQL regularly.  But developers are still from month to month, from year to year there are the same problems.  When in small companies without DBA in the state there are errors in working with databases, this is not surprising.  In large companies, databases are also needed, and even with established processes, errors still occur, and the bases are falling.  It doesn‚Äôt matter what size a company is - errors still happen, the database periodically collapses, collapses. <br><br><img src="https://habrastorage.org/webt/k7/dz/pb/k7dzpbs_rg2wat7ac4awvar2h-e.png"><br><br>  Of course, this will never happen to you, but it is not difficult to check the checklist, and it can save the future nerves very well.  Under the cut, we list the top common mistakes that developers make when working with PostgreSQL, let's figure out why you don‚Äôt need to do this and find out how to do it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/HjLnY0aPQZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>About speaker: Alexey Lesovsky</b> ( <a href="https://habr.com/ru/users/lesovsky/" class="user_link">lesovsky</a> ) started as a Linux system administrator.  From the tasks of virtualization and monitoring systems gradually came to PostgreSQL.  Now PostgreSQL DBA in <a href="https://blog.dataegret.com/">Data Egret</a> is a consulting company that works with a large number of different projects and sees many examples of recurring problems.  This is a <a href="http://www.highload.ru/moscow/2018/abstracts/4018">link</a> to the presentation of the report on HighLoad ++ 2018. <br><a name="habracut"></a><br><h2>  Where the problems come from </h2><br>  For a warm-up, a few stories about how errors occur. <br><br><h3>  Story 1. Features </h3><br>  One of the problems is what features the company uses when working with PostgreSQL.  Everything begins simply: PostgreSQL, data sets, simple queries with JOIN.  We take the data, we do SELECT - everything is simple. <br><br>  Then we start to use additional functionality of PostgreSQL, we add new functions, extensions.  Fitch becomes more.  We connect stream replication, shardirovaniye.  Different utilities and body kits appear around - pgbouncer, pgpool, patroni.  Like that. <br><br><img src="https://habrastorage.org/webt/_i/kr/an/_ikran7pf4ni9e4hyxiwptuhwy4.png"><br><br><blockquote>  Each keyword is an occasion to appear an error. </blockquote><br><h3>  History 2. Data Storage </h3><br>  The way we store data is also a source of errors. <br><br>  When the project has just appeared, there is quite a bit of data and tables in it.  Simple queries are enough to receive and record data.  But then the tables get bigger.  The data is selected from different places, there are JOIN.  Requests are complicated and include CTE constructs, SUBQUERY, IN-lists, LATERAL.  To make a mistake and write a curve request becomes much easier. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff9/37e/620/ff937e6202947bba4393531475868c74.png"><br><br>  And this is only the tip of the iceberg - somewhere on the side there may be another 400 tables, partitions, from which data is also occasionally read. <br><br><h3>  Story 3. Life Cycle </h3><br>  The story of how the product is followed.  Data always needs to be stored somewhere, so there is always a database.  How does a database develop when a product develops? <br><br>  On the one hand, there are <b>developers</b> who are busy with programming languages.  They write their applications and develop skills in software development, not paying attention to the services.  Often they are not interested in how Kafka or PostgreSQL works - they develop new features in their application, and they don‚Äôt care about the rest. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/056/1c3/00a/0561c300abe5623898768ad7d334a334.png"><br><br>  On the other hand - <b>admins</b> .  They bring up new instances in Amazon on Bare-metal and are busy with automation: they set up a layout so that the display works well, and the configs so that the services interact well with each other. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/3f5/8fb/9613f58fb950f69b235d5b80cc29e1b4.png"><br><br>  There is a situation when there is no time or desire for fine tuning of components, including the database.  Bases work with default configs, and then forget about them at all - ‚Äúit works, don't touch‚Äù. <br><br>  As a result, rakes are scattered in various places, which continually fly in front of the developers.  In this article we will try to collect all these rakes into one shed so that you know about them and do not step on them when working with PostgreSQL. <br><br><h2>  Planning and Monitoring </h2><br>  At first we will present that we have a new project - it is always active development, testing hypotheses and implementing new features.  At the moment when the application just appeared and develops, it has little traffic, users and clients, and they all generate small amounts of data.  Simple queries work in the database and are quickly processed.  No need for large amounts of data, there is no problem. <br><br>  But there are more users, traffic comes: new data appears, databases grow and old queries stop working.  It is necessary to complete indexes, rewrite and optimize queries.  There are performance problems.  All this leads to alerts at 4 am, stress for admins and management discontent. <br><br><h3>  What's wrong? </h3><br><blockquote>  In my experience, most often not enough drives. </blockquote><br>  <b>First example</b> .  We open the disk utilization monitoring schedule, and we see that the <b>free space on the disk is running out</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65b/245/c83/65b245c834e20a94ed7e698b08cfabaf.png"><br><br>  We look at how much space and what is eaten - it turns out there is a pg_xlog directory: <br><br><pre><code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 15G /pgdb/9.6/main/base 58G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  Database administrators usually know what this directory is, and do not touch it - it exists and it exists.  But the developer, especially if he looks at staging, scratches his head and thinks: <br><br>  <i>- Some logs ... Let's remove pg_xlog!</i> <br><br>  <b>Removes a directory, the base stops working</b> .  Immediately you have to google how to raise the base after you deleted the transaction logs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b8/1af/30c/2b81af30c865d529e6f7ff3fd66339ce.png"><br><br>  <b>The second example</b> .  Again we open monitoring and see that there is not enough space.  This time the place is occupied by some kind of base. <br><br><pre> <code class="plaintext hljs">$ du -csh -t 100M /pgdb/9.6/main/* 70G /pgdb/9.6/main/base 2G /pgdb/9.6/main/pg_xlog 72G </code> </pre> <br>  We are looking for which database takes up the most space, which tables and indexes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/ffc/4e9/d88ffc4e98ca1fd4648ac7aea1c8d019.png"><br><br>  It turns out that this is a table with historical logs.  We never needed historical logs.  They are written just in case, and if it were not a problem with the place, no one would have looked at them until the second coming: <br><br>  <i>- Let's clean out all that mm ... older than October!</i> <br><br>  Create an update query, run it, it will work out and delete some of the lines. <br><br><pre> <code class="plaintext hljs">=# DELETE FROM history_log -# WHERE created_at &lt; ¬´2018-10-01¬ª; DELETE 165517399 Time: 585478.451 ms</code> </pre> <br>  The query works 10 minutes, but the table still takes the same place. <br><br>  PostgreSQL deletes the rows from the table - everything is correct, but it does not return space to the operating system.  This behavior of PostgreSQL is unknown to most developers and can be very surprising. <br><br>  <b>The third example</b> .  For example, ORM made an interesting query.  Usually everyone blames the ORM for making ‚Äúbad‚Äù queries that read several tables. <br><br>  Suppose there are several JOIN operations that read tables in parallel in several threads.  PostgreSQL can parallel data manipulation operations and can read tables in several threads.  But, given that we have several application servers, this query reads all the tables several thousand times per second.  It turns out that the database server is overloaded, the disks do not cope, and all this leads to error <b>502 Bad Gateway</b> from the backend - the database is unavailable. <br><br>  But that is not all.  We can recall the other features of PostgerSQL. <br><br><ul><li>  <b>Brakes of background processes of a DBMS</b> - in PostgreSQL there are all sorts of checkpoints, vacuumes, replication. <br></li><li>  <b>Overhead from virtualization</b> .  When the database is running on a virtual machine, there are still virtual machines on the same piece of hardware on the side, and they may conflict for resources. <br></li><li>  <b>The storage from the Chinese manufacturer NoName</b> , whose performance depends on the Moon in Capricorn or the position of Saturn, and to understand why it works that way, there is no possibility.  The base suffers. <br></li><li>  <b>Default configurations</b> .  This is my favorite topic: the customer says that his base is slowing down - you look, and he has a default config.  The fact is that the default PostgreSQL config is designed to <b>run on the weakest teapot</b> .  The base starts, it works, but when it already works on a medium-level hardware, this config is not enough, it needs to be tyunted. <br></li></ul><br><blockquote>  Most often, PostgreSQL lacks either disk space or disk performance.  Fortunately, with processors, memory, network, as a rule, everything is more or less in order. </blockquote><br>  How to be?  Need monitoring and planning!  It would seem obvious, but for some reason in most cases no one plans a base, and monitoring does not cover everything that needs to be monitored during the operation of PostgreSQL.  There is a set of clear rules, under which everything will work well, and not ‚Äúat random‚Äù. <br><br><h3>  Planning </h3><br>  <b>Place the database on the SSD without hesitation</b> .  SSDs have long been reliable, stable and productive.  Enterprise SSD models have been around for years. <br><br>  <b>Always plan your data schema</b> .  Do not write in the database that you doubt what is needed - guaranteed not needed.  A simple example is a slightly modified table of one of our clients. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/56f/9ec/9e156f9ec534a11c5e80180c1c72a987.png"><br><br>  This is a log table, in which there is a data column with a json type.  Relatively speaking, anything can be written in this column.  From the last entry of this table it is clear that the logs occupy 8 MB.  PostgreSQL has no problem storing records of this length.  PostgreSQL has very good storage that chews such records. <br><br>  But the problem is that when the application servers read data from this table, they will easily clog up the entire bandwidth of the network, and other requests will suffer.  This is the problem of scheduling data. <br><br>  <b>Use partitioning for any hints on history that need to be stored for more than two years</b> .  Partitioning sometimes seems difficult - you need to bother with triggers, with functions that will create partitions.  In the new versions of PostgreSQL, the situation is better and now the setting of partitioning is much easier - once done, and it works. <br><br>  In the above example of deleting data in 10 minutes, <code>DELETE</code> can be replaced with <code>DROP TABLE</code> - such an operation in similar circumstances will take only a few milliseconds. <br><br>  When the data is sorted into partitions, the partition is deleted in just a few milliseconds, and the OS is given immediately.  Managing historical data is easier, easier and safer. <br><br><h3>  Monitoring </h3><br>  Monitoring is a separate large topic, but from the point of view of the database, there are recommendations that can fit in one section of the article. <br><br>  By default, many monitoring systems provide monitoring of processors, memory, network, disk space, but, as a rule, <b>there is no utilization of disk devices</b> .  Information about how loaded the disks are, how much bandwidth is currently on the disks and the latency value should always be added to the monitoring.  This will help to quickly assess how the discs are loaded. <br><br>  There are a lot of PostgreSQL monitoring options for every taste.  Here are some points that must be present. <br><br><ul><li>  <b>Connected clients</b> .  It is necessary to keep track of what statuses they work with, quickly find ‚Äúharmful‚Äù clients that harm the database, and turn them off. </li><li>  <b>Errors</b> .  It is necessary to monitor errors in order to track how well the database works: there are no errors ‚Äî great, errors appeared ‚Äî an excuse to look at the logs and start to figure out what is going wrong. </li><li>  <b>Queries (statements)</b> .  We monitor the quantitative and qualitative characteristics of requests in order to roughly assess whether we have slow, long or resource-intensive requests. </li></ul><br>  For more information, see the <a href="https://youtu.be/Hbi2AFhd4nY">PostgreSQL Monitoring Basics</a> report from HighLoad ++ Siberia and the <a href="https://wiki.postgresql.org/wiki/Monitoring">Monitoring</a> page in the PostgreSQL Wiki. <br><br>  When we planned and monitored everything, we could still face some problems. <br><br><h3>  Scaling </h3><br>  Usually the developer sees the database line in the config.  He is not particularly interested in how it is arranged inside - how checkpoint, replication, and scheduler work.  A developer already has something to do - there are many interesting things in todo that he wants to try. <br><br><blockquote>  "Give me the address of the base, then I myself."  ¬© Anonymous developer. </blockquote><br>  Ignorance of the subject leads to quite interesting consequences when the developer starts writing queries that work in this database.  Fantasies when writing queries sometimes give stunning effects. <br><br>  There are two types of transactions.  <b>OLTP transactions</b> are fast, short, lightweight, and can be performed in fractions of milliseconds.  They work very quickly, and there are a lot of them.  <b>OLAP - analytical queries</b> - slow, long, heavy, read large arrays of tables and count statistics. <br><br>  The last 2-3 years often sounds abbreviation <b>HTAP</b> - Hybrid Transaction / Analytical Processing or <b>hybrid transaction-analytical processing</b> .  If you have no time to think about scaling and separation of OLAP and OLTP requests, you can say: ‚ÄúWe have HTAP!‚Äù But experience and the pain of errors show that, after all, different types of requests should live separately from each other, because long OLAP requests are blocked by light OLTP requests. <br><br>  So we come to the question of how to scale PostgreSQL so that the load is spread, and everyone was happy. <br><br>  <b>Streaming replication</b> .  The easiest option is <b>stream replication</b> .  When the application works with the database, we connect several replicas to this database and distribute the load.  Recording still goes to the master database, and reading replicas.  This method allows you to scale very widely. <br><br>  Plus, to individual replicas, you can connect more replicas and get <b>cascade replication</b> .  Individual groups of users or applications that, for example, read analytics, can be put on a separate replica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/5b3/2d7/7f45b32d7eeb8dfcd7e19cfb38210134.png"><br><br>  <b>Logical publications, subscriptions</b> - the mechanism of logical publications and subscriptions assumes the existence of several independent PostgreSQL-servers with separate databases and sets of tables.  These sets of tables can be connected to neighboring databases, they will be visible to applications that can use them normally.  That is, all changes that occur in the source are replicated to the destination base and visible there.  Works great with PostgreSQL 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13a/4aa/068/13a4aa06893b4ae9f1a1b7523c407b06.png"><br><br>  <b>Foreign tables, Declarative Partitioning - declarative partitioning and external tables</b> .  You can take several PostgreSQL and create there several sets of tables that will store the desired ranges of data.  This may be data for a particular year or data collected over any range. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/929/cb9/109929cb936d0c040651ad30c130258b.png"><br><br>  Using the mechanism of external tables, you can combine all these databases in the form of a partitioned table in a separate PostgreSQL.  An application may already work with this partitioned table, but in fact it will read data from remote partitions.  When data volumes are more than the capabilities of a single server, then this is a sharding. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/446/d13/a39/446d13a394143b988ec04f60e645ea21.png"><br><br>  All this can be combined into spread configurations, come up with different PostgreSQL replication topologies, but how it will work and how to manage it is a topic for a separate report. <br><br><h3>  Where to begin? </h3><br>  The easiest option is <b>with replication</b> .  The first step is to spread the load on the read and write.  That is, write to the master, and read from the replicas.  So we scale the load and take out reading from the master.  In addition, do not forget about analysts.  Analytical queries work for a long time, they need a separate replica with separate settings, so that long analytical queries can not interfere with the rest. <br><br>  The next step is <b>balancing</b> .  We still have the same line in the config that the developer operates on.  He needs a place where he will write and read.  There are several options here. <br><br>  Ideal - implement balancing <b>at the application level</b> , when the application itself knows where to read data from, and knows how to choose a replica.  Suppose an account balance always needs an up-to-date one and needs to be read from a master, and a picture of a product or information about it can be read with some delay and done with a replica. <br><br><ul><li>  <b>DNS Round Robin</b> , in my opinion, is not a very convenient implementation, because sometimes it takes a long time and does not give the required time when switching master roles between servers in failover cases. </li><li>  A more interesting option is to use <b>Keepalived and HAProxy</b> .  Virtual addresses for the master and the replica set are swapped between the HAProxy servers, and HAProxy is already balancing traffic. </li><li>  <b>Patroni, DCS</b> in conjunction with something like ZooKeeper, etcd, Consul - the most interesting option, in my opinion.  That is, service discovery is responsible for the information, who is now the master, and who is the replica.  Patroni manages the PostgreSQL cluster, performs the switch ‚Äî if the topology has changed, this information will appear in the service discovery, and applications can quickly find out the current topology. </li></ul><br>  And with replication there are nuances, the most frequent of them is the <b>lag of replication</b> .  You can do it like GitLab, and when lag has accumulated, just drop the base.  But we have a comprehensive monitoring - we watch it and see long transactions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/9a0/fae/6199a0fae7ed88fb1646e232cc1f2953.png"><br><br><h3>  Applications and DBMS Transactions </h3><br>  In general, transactions that are slow and do nothing result in: <br><br><ul><li>  <b>decrease in productivity</b> - not to a sharp jump, but smooth; <br></li><li>  <b>locks and deadlocks</b> , because long transactions hold locks on rows and prevent other transactions from working; <br></li><li>  <b>HTTP 50 * errors on the backend</b> , to errors in the interface or somewhere else. <br></li></ul><br><br>  Let's consider a little theory about how these problems arise, and why the mechanism of long and idle transactions (idle transactions) is harmful. <br><br>  In PostgreSQL there is MVCC - relatively speaking, the database engine.  It allows customers to work competitively with data without interfering with each other: readers do not interfere with readers, and writers do not interfere with writers.  Of course, there are some exceptions, but in this case they are not important. <br><br>  It turns out that in the database for one line there can be several versions for different transactions.  Clients connect, the database gives them snapshots of data, and within these snapshots there may be different versions of the same row.  Accordingly, in the life cycle of the database, transactions are shifted, replace each other, and versions of strings appear that are no longer needed by anyone. <br><br>  So there is a <b>need for a garbage collector - auto vacuum</b> .  Long transactions exist and prevent the auto vacuum from cleaning up unnecessary versions of rows.  This garbage data starts to migrate from memory to disk, from disk to memory.  It takes CPU and memory resources to store this garbage. <br><br><blockquote>  The longer the transaction - the more debris and lower productivity. </blockquote><br>  From the point of view of ‚ÄúWho is to blame?‚Äù, It is the application that is responsible for the appearance of long transactions.  If the base will exist by itself, the long, doing nothing transactions will not take anywhere.  In practice, there are the following options for the emergence of idle transactions. <br><br>  <b>"Let's go to an external source</b> . <b>"</b>  The application opens a transaction, does something in the database, then decides to contact an external source, for example, Memcached or Redis, in the hope that it will then return to the database, continue work and close the transaction.  But if an error occurs in the external source, the application crashes and the transaction remains open until someone notices and kills it. <br><br>  <b>No error handling</b> .  On the other hand, there may be an error handling problem.  When, again, the application opened a transaction, solved some problems in the database, returned to code execution, performed some functions and calculations, in order to continue working in the transaction and close it.  When the application was interrupted with an error on these calculations, the code returned to the beginning of the cycle, and the transaction again remained unclosed. <br><br>  <b>The human factor</b> .  For example, admin, developer, analyst, works in some pgAdmin or in DBeaver - opened a transaction, does something in it.  Then the person was distracted, he switched to another task, then the third, forgot about the transaction, left for the weekend, and the transaction continues to hang.  Base performance suffers. <br><br>  Let's take a look at what to do in these cases. <br><br><ul><li>  We have monitoring, respectively, we need <b>alerts in monitoring</b> .  Any transaction that hangs for more than an hour and does nothing - a reason to see where it came from, and to understand what is wrong. </li><li>  The next step is to <b>shoot such transactions through a task in the crown</b> (pg_terminate_backend (pid)) or setting in the PostgreSQL config.  Thresholds of 10‚Äì30 minutes are needed, after which transactions are automatically completed. </li><li>  <b>Refactoring the application</b> .  Of course, you need to figure out where idle transactions come from, why they are happening and eliminate such places. </li></ul><br><blockquote>  Avoid long transactions at any cost, because they have a huge impact on database performance. </blockquote><br>  Everything becomes even more interesting when there are pending tasks, for example, you need to carefully calculate the units.  And we come to the issue of cycling. <br><br><h3>  Cycling </h3><br>  Sensitive subject.  The business of the application needs to perform background event processing.  For example, counting aggregates: minimum, maximum, average, send notifications to users, bill customers, set up a user account after registration, or register with neighboring services ‚Äî do deferred processing. <br><br>  The essence of such tasks is the same - they are postponed for later.  In the database there are tables that just carry out the queue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/bfa/f20/ef4bfaf20634c6d43941c9c8325a09ff.png"><br><br>  There is a task identifier, the time when the task was created, when it was updated, the handler that took it, the number of attempts to perform it.  If you have a table that even remotely resembles this, it means that you have <b>samopisnye queues</b> . <br><br>  It all works fine until long transactions appear.  After this, the <b>tables that work with queues swell in size</b> .  New jobs are added all the time, old ones are deleted, updates occur - a table with an intensive record is obtained.  It should be regularly cleaned from obsolete versions of the lines so that performance does not suffer. <br><br>  <b>Processing time grows</b> - a long transaction keeps the lock on obsolete versions of rows or prevents vacuum from cleaning it.  When the table grows in size, the processing time also increases, since you need to read many pages of garbage.  Time increases, and the <b>queue at some point stops working altogether</b> . <br><br>  Below is an example of the top of one of our customers, who had a handwritten queue.  All requests are related to the queue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/203/7ac/3442037ac837daec02ee89a83bd53dd7.png"><br><br>  Pay attention to the execution time of these requests - all but one work for more than twenty seconds. <br><br>  To solve these problems, <b>Skytools PgQ</b> , the queue manager for PostgreSQL, was invented long ago.  Do not reinvent your bike - take PgQ, set up once and forget the queues. <br><br>  True, and he has features.  Skytools PgQ has <b>little documentation</b> .  After reading the official page, it seems that I did not understand anything.  The feeling grows when you try to do something.  Everything works, but <b>how it works is not clear</b> .  Some kind of Jedi magic.  But a lot of information can be obtained in <b>Mailing-lists</b> .  This is not a very convenient format, but many interesting things are there, and these sheets will have to be read. <br><br>  Despite the disadvantages, Skytools PgQ works on the principle of "set up and forget."   ,    ,     ,    .   PgQ ,        .  PgQ ,      . <br><br><blockquote>    ,   -     ‚Äî  ,   .     . </blockquote><br>              PgQ. ,    PostgreSQL, ,  ,   PgQ  .    ,   . <br><br><h3>  Automation </h3><br>        ,          .   ,    , ,     - ,   , ,      . ,       ,       ,   alter. <br><br>     <b>auto-failover</b> ‚Äî       PostgreSQL  - ,       ,        .      ,    auto-failover. <br><br> <b>Split-brain</b> .    PostgreSQL     ,     ,  ‚Äî  .   ,   .   PostgreSQL     fencing,     Kubernets    .     -    ,         .   Split-brain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/327/239/97e/32723997e13e8427e4cddc59ea7c964f.png"><br><br>           .  GitHub   Split-brain,       . <br><br> <b>Cascade failover</b> . ,     .  ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea9/864/d63/ea9864d63b7cebd46ff8b185ddb5d639.png"><br><br>        ,       .    ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81d/243/fc1/81d243fc1500011f0f3c24576f81786a.png"><br><br>         ‚Äî   failover. <br><br>      auto-failover,    . <br><br> <b>Bash </b> ‚Äî  ,      .   ,     ,   .   - ,   ,   .     . <br><br> <b>Ansible playbooks</b> ‚Äî bash-  .    ,   ,    . <br><br> <a href="https://github.com/zalando/patroni"><b>Patroni</b></a> ‚Äî   ,    ,      auto-failover,   ,       service discovery. <br><br> <a href="https://github.com/clusterlabs/PAF"><b>PAF</b></a> ‚Äî <b>  Pacemaker</b> .     auto-failover  PostgreSQL,        Pacemaker. <br><br> <a href="https://github.com/sorintlab/stolon"><b>Stolon</b></a>     .  Kubernetes, . Stolon  Patroni,        . <br><br><h3>    </h3><br>    Docker  Kubernetes .    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/aba/8c4/b99aba8c4f9c959cd96840bfcd3359b2.png"><br><br>        ,       . <i> ¬´      Kubernetes...¬ª</i>    . <br><br> <b> ‚Äî   stateful</b> ,   - .  Where?      .   Open Source: CEPH, GlusterFS, LinStor DRBD.    ,       , ,     . <br><br>       ‚Äî <b>    </b> . ,      Kubernetes,     CEPH.         ‚Äî    .           ,       . <br><br><ul><li> <b>  </b> ,           . </li><li> <b>     latency</b> .  latency        ‚Äî    . </li><li> <b>   </b> . Kubernetes ,    - . ,    shared storage  Kubernetes,       .  -         . </li></ul><br>     ,    Kubernetes  Docker    staging  dev-     .    ,   , Kubernetes      . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/8dd/fd0/b048ddfd0b6212ef2d1eb49eda02386b.png"><br><br>    ,     <b>local volumes ‚Äî  </b>     , <b>streaming replication ‚Äî   </b> ,       <b>PostgreSQL-</b> ,       ‚Äî ,   .       : <a href="https://github.com/zalando-incubator/postgres-operator">Zalando</a>  <a href="https://github.com/CrunchyData/postgres-operator">Crunchy</a> . <br><br>    ,     .    issues  pull requests.   ,     ,     . <br><br><h2>  Results </h2><br> <b>         SSD</b> ‚Äî          ,    . <br><br> <b>     </b> .   JSON  8  ‚Äî  ,   . <br><br> <b> </b> ,        .  PostgreSQL,   . <br><br> <b>  ‚Äî Postgres is ready</b> .          . PostgreSQL   ,        .    : <b>streaming replication; publications, subscriptions; foreign Tables; declarative partitioning</b> . <br><br> <b>    </b> .      ,    . <br><br>    -,      ,   ‚Äî <b>   </b> .    .    ,  Skytools PgQ! <br><br> <b>     Kubernetes,  local volumes, streaming replication  PostgreSQL </b> .     - ,   ,      . <br><br><blockquote>               .     ,   24  25   <a href="https://www.highload.ru/siberia/2019/">HighLoad++ Siberia</a>     <a href="https://www.highload.ru/siberia/2019/abstracts/5425"></a>  ,    ,           .   38    <a href="https://www.highload.ru/siberia/2019/schedule"></a> ‚Äî     ! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/455248/">https://habr.com/ru/post/455248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45524/index.html">Announced the release of Linux distribution Fedora 10</a></li>
<li><a href="../455240/index.html">Using the rejected defect rate to improve the error report</a></li>
<li><a href="../455242/index.html">Minus ears or how not to spoil the sound in the game from the very beginning</a></li>
<li><a href="../455244/index.html">Comics "easy soldering" in the updated version (2019)</a></li>
<li><a href="../455246/index.html">Registration for the Customer Experience Day in St. Petersburg June 20</a></li>
<li><a href="../455256/index.html">Habr Weekly # 4 / Computex, like Apple‚Äôs Beta Apple, Durov is starving, BadComedian cat, why did the neural network look for pornacteres</a></li>
<li><a href="../455258/index.html">Voting began for the reports of the Backend section at the anniversary DevConfX, which will be held June 21-22 in Moscow</a></li>
<li><a href="../455260/index.html">Merkle Tree: rusty and fast</a></li>
<li><a href="../455268/index.html">How it all began: flexible and foldable displays - the story of the emergence and exit "in people"</a></li>
<li><a href="../455272/index.html">TheOutloud - voice and share your favorite articles and stories</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>