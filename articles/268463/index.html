<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin ‚ù§ FP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of "Habrakhabr" a free translation of the article "Functional programming in Kotlin" . Publication author - Mike Hearn. 



 Those...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin ‚ù§ FP</h1><div class="post__text post__text-html js-mediator-article">  <i>I offer the readers of "Habrakhabr" a free translation of the article <a href="https://medium.com/%40octskyward/kotlin-fp-3bf63a17d64a">"Functional programming in Kotlin"</a> .</i>  <i>Publication author - Mike Hearn.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f8/85e/fc0/2f885efc0d315929cb17cdd725ec5e16.png" alt="image"><br><br>  Those who use .NET have probably heard about F #, the universal functional programming language for CLR.  Programmers outside the .NET community are most likely aware of functional programming in connection with the Haskell language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Anyway, I suspect that many would have liked a similar language, but for JVM, with advanced tools and without having to do everything in a functional style. <br><br>  The Kotlin language ( <a href="http://kotlinlang.org/">kotlinlang.org</a> ) from <a href="http://jetbrains.ru/">JetBrains</a> may seem like only sweetened Java: syntax conventions, type inference, and similar trivialities.  But under the plain shell in it you can find all the most popular and progressive constructions of functional languages. <br><a name="habracut"></a><br>  Let's start with simple examples of typical functional structures. <br><br><h3>  Algebraic data types </h3><br>  This syntax is quite typical for most functional languages: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  This is Haskell, and there is defined the type ‚ÄúMaybe‚Äù, which has two constructors: ‚ÄúNothing‚Äù and ‚ÄúJust‚Äù.  The Just constructor takes a single parameter of undefined type.  The keyword "deriving" autogenerates the code to compare type objects and check them for equality. <br><br>  In Kotlin, the Maybe class is not needed, since the ability to return or not return a value is initially incorporated into its type system.  Optionality of the result is so often found in programs that it makes sense to support it at the very core of the language.  This adds both convenience and performance: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: String? = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.random() &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-string"><span class="hljs-string">"Yay!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> println(<span class="hljs-string"><span class="hljs-string">"length of string is .... </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ s.length() }</span></span></span><span class="hljs-string">"</span></span>)</code> </pre><br>  It does not compile the second line, since we are trying to calculate the length of the line, which we may not have.  It is easy to repair: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: String? = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.random() &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-string"><span class="hljs-string">"Yay!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> println(<span class="hljs-string"><span class="hljs-string">"length of string is .... </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ s?.length() ?: </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">-1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">"</span></span>)</code> </pre><br>  The "s? .Length ()" construction will return `null` if the string was` null`, and the "?:" Operator will return its right-hand side when `null` is on the left.  That is, the code prints `-1`, if the line suddenly does not exist. <br><br>  Kotlin has a full set of tools for working with `null` types, you can be sure.  But let's not talk about this for the sake of brevity. <br><br>  Instead, let's define the equivalent of Maybe in Kotlin, just for illustration. <br><br><pre> <code class="hljs ruby">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Maybe</span></span></span><span class="hljs-class">&lt;out </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">None</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Maybe</span></span></span><span class="hljs-class">&lt;Nothing&gt;() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Just</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Maybe</span></span></span><span class="hljs-class">&lt;T&gt;() }</span></span></code> </pre><br>  The syntax is certainly not as short as in Haskell, but also quite acceptable.  The ‚Äúdata‚Äù modifier is optional, but it adds some useful buns. <br><br>  Everything works without surprises: <br><br><pre> <code class="hljs matlab">val <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = Maybe.Just(<span class="hljs-number"><span class="hljs-number">1</span></span>) val (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">j</span></span></code> </pre><br>  Here we define Just containing the number (Int) inside, and then retrieve the number back.  Note, no type is ever mentioned: they are all output automatically.  If there were just a few fields in Just, it would be possible to extract them all, which is in fact the purpose of this construction: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> alice = Pet(<span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, age) = alice</code> </pre><br>  But what about pattern matching?  This is exactly what we needed the keyword "sealed".  With it, the compiler knows that there are no other Maybe subclasses except Just and None, and branching all options does not require the ‚Äúelse‚Äù branch: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookupFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Maybe&lt;User&gt; = Maybe.None <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rec = lookupFromDB(username) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (rec) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Maybe.None -&gt; println(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Maybe.Just&lt;User&gt; -&gt; println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${rec.t.age}</span></span></span><span class="hljs-string"> years old"</span></span>) } }</code> </pre><br>  Above is defined a simple class with a single immutable field ¬´age¬ª.  The ‚ÄúlookupFromDB‚Äù method simulates database access and returns `Maybe`.  In our case, always None, but this is nothing more than an example. <br><br>  After that, the returned value is compared with the types using the "when" operator.  The `when` construct allows you to do many things.  In particular, after successfully matching an argument with a type, inside the right-hand side, the argument changes its type accordingly.  That is why in the right part of the second branch we can use the ‚Äút‚Äù field of the `User` class without unnecessary ceremonies. <br><br><h3>  Immutability data (Immutability) </h3><br>  Kotlin is not a purely functional language, therefore immutable objects coexist with mutable on equal rights.  The design unobtrusively pushes the programmer to use immutable objects, but in general, the choice is always left to the developer. <br><br>  For example, like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = Person(<span class="hljs-string"><span class="hljs-string">"Mike"</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>) p.name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span></code> </pre><br>  Here "p" is the immutable value ( <u>val</u> ue).  Similar to `final variable` in Java, or` let` in Haskell / F #.  But the contents of this object consist of variable variables ( <u>var</u> iable), so they can be reassigned.  Highlighting in the IDE helps distinguish between changeable and immutable fields. <br><br>  The same example, but now all links are unchangeable: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mike = Person(<span class="hljs-string"><span class="hljs-string">"Mike"</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> olderMike = mike.copy(age = <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre><br>  The copy method for the `data` classes is created automatically.  For each class field it has a named parameter, by default equal to the current value.  As a result, it is convenient to use it to create new "corrected" objects. <br><br>  Default lists are immutable: <br><br><pre> <code class="hljs pgsql">val people = listOf(mike, olderMike) people.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Person("Bob", <span class="hljs-number"><span class="hljs-number">50</span></span>)) // ERROR val peopleDB = arrayListOf(mike, olderMike) peopleDB.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Person("Bob", <span class="hljs-number"><span class="hljs-number">50</span></span>)) val <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>: List&lt;Person&gt; = peopleDB val <span class="hljs-keyword"><span class="hljs-keyword">snapshot</span></span> = peopleDB.toList()</code> </pre><br>  The second line will not compile: `listOf ()` returns an immutable list.  But in the fourth line, everything is in order, since we specifically asked for `ArrayList`, which can be changed.  Of course, any list can always be made unchangeable by the `List` interface and create a‚Äú read-only view ‚Äù. <br><br>  At the moment, there is no built-in syntax for lists in the language, so functions with a variable number of arguments are used to create them. <br><br><h3>  Mapping, filtering, reducing and other goodies </h3><br>  Kotlin supports lambda expressions and extends standard JDK collections with popular methods from the functional world.  This can be used up to Java 6, and therefore on any Android device: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nums = listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = nums.map { it * <span class="hljs-number"><span class="hljs-number">2</span></span> }.sum() <span class="hljs-comment"><span class="hljs-comment">// r == 20</span></span></code> </pre><br>  Note that ‚Äúit‚Äù is the automatic name for the lyabmda parameter, which appears if lambda takes exactly one argument.  Of course, you can always set a more informative name yourself.  So for example it is recommended to do in nested lambdas. <br><br>  Here `map` is an extension function.  Kotlin allows you to add such functions to an arbitrary class, improving the external API.  This is similar to the java-based `FooUtils` with static methods, but much more convenient.  Function extensions are actively used in the standard library, adding functionality to classes from Java and reducing the amount of interfaces of Kotlin itself. <br><br>  More advanced example: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strs = listOf(<span class="hljs-string"><span class="hljs-string">"fish"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>, <span class="hljs-string"><span class="hljs-string">"dog"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>, <span class="hljs-string"><span class="hljs-string">"fish"</span></span>, <span class="hljs-string"><span class="hljs-string">"fish"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> freqs = strs.groupBy { it }.mapValues { it.value.size() } println(freqs) <span class="hljs-comment"><span class="hljs-comment">// {fish=3, tree=2, dog=1}</span></span></code> </pre><br><h3>  Recursion </h3><br>  In the functional programming paradigm, cyclic code is often conveniently expressed as recursive function calls.  In order not to lose in performance, compilers of languages ‚Äã‚Äãlike Haskell use the so-called tail recursion optimization (tail call optimization).  This optimization can only work if the recursive call is the last operation in the function, and the Kotlin compiler will even check it for you. <br><br>  The simplest example: a <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0">fixed point of a</a> mathematical function is a value at which the result of a function is equal to its argument.  If you want to find a fixed cosine point, then you can transfer the result of the cosine to it in the loop until everything is stabilized.  Procedural implementation: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cosFixpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = Math.cos(x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y x = y } }</code> </pre><br>  Very simple: starting from 1.0, we calculate the cosine until the result is equal to the argument. <br><br>  The same, but through recursion: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cosFixpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Math.cos(x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == r) x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cosFixpoint(r) }</code> </pre><br>  Or even in one line: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.Math.cos <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == cos(x)) x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f(cos(x)))</code> </pre><br>  This version should work as fast as the other two, provided that the JIT will guess to optimize the re-call of `Math.cos (x)`. <br><br><h3>  Currying, partial application and composition </h3><br>  These are the things that necessarily exist in any functional language, although I cannot say that they are very necessary for everyday tasks.  Currying splits the function of many variables into a chain of several functions of the same argument.  Partial application (partial application) allows you to fix some parameters of the function and get the function with a smaller number of arguments. <br><br>  Kotlin does not provide such delights ‚Äúout of the box‚Äù, but it is flexible enough so that all this can be elegantly implemented in the funKtionale library: <br><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.funktionale.currying.* val sum2ints = { x: Int, y: Int -&gt; x + y } val curried: (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Int = sum2ints.curried() assertEquals(<span class="hljs-title"><span class="hljs-title">curried</span></span>(2)(4), 6) val add5 = curried(5) assertEquals(<span class="hljs-title"><span class="hljs-title">add5</span></span>(7), 12)</code> </pre><br>  ‚Ä¶ and‚Ä¶ <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.funktionale.partials.* <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> format = { prefix: String, x: String, postfix: String -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${x}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${postfix}</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> prefixAndBang = format(p3 = <span class="hljs-string"><span class="hljs-string">"!"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Passing just the first parameter will return a new function val hello = prefixAndBang(p1 = "Hello, ") println(hello("world"))</span></span></code> </pre><br><h3>  Delayed execution (lazyness) </h3><br>  Kotlin does not belong to the "lazy" languages, that is, the calculations occur where they are described (oops, but it happens in another way!).  As far as I know, no common language other than Haskell uses lazy computations by default (lazy-by-default). <br><br>  Of course, lazy calculations are available through the library.  Consider a real example: how not to build a log line, if logging is disabled? <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loggingEnabled = System.getProperty(<span class="hljs-string"><span class="hljs-string">"log"</span></span>) != <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loggingEnabled) println(s) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ls: ()</span></span></span></span> -&gt; String): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loggingEnabled) println(ls())</code> </pre><br>  Here the logging function `log` is overloaded - either a string or a function that calculates the string on demand can be passed to it: <br><br><pre> <code class="hljs pgsql">log("now!") <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> { "calculate me later" }</code> </pre><br>  In functional programming, it is often convenient to have lists of infinite length, and to work with them "as lazier as possible and parallel".  The simplicity of such operations is one of the key features of functional programming in general. <br><br>  From version 8, Java can also do this, and with it Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ONE = BigInteger.ONE <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Stream .iterate(ONE) { it + ONE } .filter { it.isProbablePrime(<span class="hljs-number"><span class="hljs-number">16</span></span>) } .limit(n) .toList()</code> </pre><br>  In Java, endless lists are called streams.  We construct a lazy list of all positive integers;  then choose from them only those that are simple with probability (1 - (1/4) ^ 16) in accordance with the Miller-Rabin test;  after that we return the first `n` of them in the form of a regular list.  Classic functional programming. <br><br>  But how fast does it all work? <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">val</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimeMillis</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">println</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Took $t msec"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  On my laptop from the second run (with a heated JIT) the calculations took 1.5 seconds. <br><br>  But the whole point of creating chains of functions without side effects lies in the ease of parallelizing them.  Easy movement of the arm pants are turning ... <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Stream .iterate(ONE) { it + ONE } .parallel() .filter { it.isProbablePrime(<span class="hljs-number"><span class="hljs-number">16</span></span>) } .limit(n) .toArray()</code> </pre><br>  All we did was put a call to `parallel ()` in our stream.  Due to this, all subsequent operations are launched in several threads.  Measurements show a threefold increase in performance: just 0.5 seconds.  It's not so bad for me! <br><br><h3>  Software Transactional Memory </h3><br>  Software transactional memory (software transactional memory), or STM, is one way to write parallel code.  This technique is well explained in the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf">article by</a> Simon Peyton-Jones, one of the progenitors of Haskell. <br><br>  Instead of using locks, you write something like: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> account1 = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> account2 = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { atomic { account1 -= amount account2 += amount } }</code> </pre><br>  From the programmer's point of view, everything that happens inside the `atomic` block is executed instantly in one transaction, and there is never a race condition inside.  But at the same time, nothing prohibits multiple threads from being in this block at the same time.  Very elegant. <br><br>  The simplest implementation could use one global lock, but that would be incredibly slow.  So in reality, the system records all data changes for one stream, and catches conflict situations.  In the event of a conflict, the block is restarted.  This is well implemented in Haskell. <br><br>  Kotlin, again, does not directly support STM.  But this is never a problem, because through the JVM it has at its disposal such libraries as Scala STM, and even cooler: low-level transaction memory (hardware transactional memory).  Wow. <br><br>  Modern (very modern) Intel chips support a set of extensions called TSX.  TSX allows you to create atomic transactions at the level of iron.  Changes in RAM are recorded in the cache and the conflicts between threads are monitored by the CPU itself.  In the event of a conflict, the CPU cancels the transaction in the calculation that the program will either try again, or use the usual locks.  If everything went according to plan, then the caches are synchronized with RAM at once. <br><br>  Starting with Java 8 ‚ÄúUpdate 40‚Äù, the so-called ‚ÄúRTM locking‚Äù is <i>enabled by default <sup>[1]</sup></i> for compatible processors.  It magically transforms every synchronized block in Java into a low-level transaction with TSX.  And this means that now your code is actually executed in parallel.  The JVM additionally profiles the application to find blocks that are often restarted, and converts them back to standard locks.  Since Kotlin works on the JVM, it all works automatically. <br><br>  This allows you to write all the critical code in one large block of synchronization and not feel significant problems with speed.  If you have the latest iron, of course. <br><br>  But there are limitations - STM provides additional software features, such as stopping / restarting / canceling a block.  TSX cannot, or more precisely, the JVM doesn‚Äôt support it at the moment.  So if you need more control, you will have to connect transactional variables: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.stm.japi.STM.* val counter = newRef(<span class="hljs-number"><span class="hljs-number">10</span></span>) try { atomic { <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span>(counter, <span class="hljs-number"><span class="hljs-number">1</span></span>) println("counter is ${counter.get()}") // -&gt; <span class="hljs-number"><span class="hljs-number">11</span></span> throw <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>("roll back!!") } } catch(e: <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>) { println("counter is ${counter.get()}") // -&gt; <span class="hljs-number"><span class="hljs-number">10</span></span> }</code> </pre><br>  Haskell has another elegant focus - its type system ensures that transaction variables are available exclusively inside the synchronization block, which will not let you forget about multithreading, no matter how much you want it.  Something similar can be done in Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadBox</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>(v: T) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = v <span class="hljs-meta"><span class="hljs-meta">@Synchronized</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> locked</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; R): R = value.f() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bank = ThreadBox(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> accounts = intArrayOf(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transfer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bank.locked { accounts[from] -= amount accounts[to] += amount } }</code> </pre><br>  "ThreadBox" is a class that stores a `private` pointer to an arbitrary object" value ".  Thus, if there are no external links to this object, it can only be used via the TreadBox.  When declaring the object ‚Äúbank‚Äù, ‚Äúobject-expresion‚Äù is used to create a nameless object and transfer it to the ThreadBox constructor, which guarantees the absence of external references to the object.  And ThreadBox, in turn, returns a pointer only inside the ‚Äúlocked‚Äù method, protected by the `@ Synchronized` annotation. <br><br>  Kotlin syntax does not provide a way to use the ‚Äúaccounts‚Äù array outside the synchronization block ... only if the link to it has not gone out.  So this is not such a harsh defense as in Haskell, but after all, it only takes three lines of code. <br><br>  On Github, I laid out a <a href="https://gist.github.com/mikehearn/1ad4a9c375e59e52b8cf">more sophisticated version of</a> the same idea, preventing more errors. <br><br><h3>  What is not in Kotlin </h3><br>  At the moment the development of the language (M14) there is no way to control the side effects, which may be important when creating some classes of applications. <br><br>  Also, there is still no ‚Äúnative‚Äù library for high-performance, immutable data structures.  This contrasts with Clojure and Scala, where such structures are embedded in the languages ‚Äã‚Äãthemselves.  The most interesting thing would be to make a much more productive implementation for Kotlin (compared to Scala / Clojure), if we use the recently published <a href="http://michael.steindorfer.name/publications/oopsla15.pdf">CHAMP</a> algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">UPD 1</b> <div class="spoiler_text">  As noted by <a href="https://habrahabr.ru/users/grossws/" class="user_link">grossws</a> , the phrase in the <u>original</u> article <br><blockquote>  Starting with Java 8 Update 40, so-called ‚ÄúRTM locking‚Äù is enabled by default when the CPU supports it. </blockquote><br>  does not comply with official documentation from the Oracle website: <br><blockquote>  -XX: UseRTMLocking Generate Restricted Transactional Memory (RTM) for the fallback handler.  This option is disabled by default. </blockquote><br>  I do not presume to judge what is right and what is not from this, but I ask you to treat this moment with a certain degree of skepticism. <br><br>  <a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> <br>  <a href="http://www.oracle.com/technetwork/java/javase/8u40-relnotes-2389089.html">oracle.com/technetwork/java/javase/8u40-relnotes-2389089.html</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/268463/">https://habr.com/ru/post/268463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268451/index.html">Unwanted Android AdDisplay software specializes in circumventing Google Bouncer checks</a></li>
<li><a href="../268453/index.html">Basic information security certificates for IT professionals and enterprises</a></li>
<li><a href="../268455/index.html">Trends of the global e-commerce market in 2015-2016</a></li>
<li><a href="../268459/index.html">NGINX - Acceleration or Detective for the programmer "Optimization for Windows"</a></li>
<li><a href="../268461/index.html">Checklist: How to load pages faster</a></li>
<li><a href="../268467/index.html">4 rules of content management interfaces that no one observes</a></li>
<li><a href="../268469/index.html">Battle for time: how the upgrade of the processor, software and video card affects the acceleration of video post-processing</a></li>
<li><a href="../268471/index.html">Microsoft will soon close support for outdated versions of Internet Explorer</a></li>
<li><a href="../268473/index.html">NutanixOS 4.5: Important Update and Big Plans</a></li>
<li><a href="../268483/index.html">VII Hi-Tech Tour Inoventica Cloud Center: "Cloud Oktoberfest"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>