<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplest triangulation in java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all! 
 I want to talk about one interesting problem and its solution, which I applied in one of my projects. 
 The essence of the problem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplest triangulation in java</h1><div class="post__text post__text-html js-mediator-article">  Good day to all! <br>  I want to talk about one interesting problem and its solution, which I applied in one of my projects. <br>  The essence of the problem is as follows: <br>  There are several signal detectors (for example, GSM base stations).  And these detectors send to the server the signal level for a certain source.  It is necessary to calculate and display on the map the coordinates of the source <br>  If you are interested in how to do this, welcome under cat. <br><a name="habracut"></a><br><h5>  Part 1. Theory and some geometry </h5><br>  Let A (xa, ya), B (xb, yb), C (xc, yc) be signal detectors with given coordinates in a certain rectangular coordinate system.  O (xo, yo) - signal source. <br>  We recall from the school textbook of physics that the amplitude of the signal is inversely proportional to the square of the distance to the source.  Thus, the distance Ra from the source O to the detector A will be equal to <br><img src="https://habrastorage.org/storage2/389/98f/a72/38998fa7246a9c5b293b1bc1d76e50a8.png"><br>  where ka is some coefficient that we can get when calibrating devices. <br>  The formula for calculating the distance a1 is taken from the school course of geometry (it is embarrassing to give it here, but let it be for completeness). <br><img src="https://habrastorage.org/storage2/216/7d6/c80/2167d6c80caf6f72fd3ea463b345ce04.png"><br>  The heterogeneity of the environment is neglected.  Yes, it will give some error, but the solution to this problem is beyond the scope of the problem.  We assume that the constant factors affecting the propagation of the signal (the presence and material of the walls, for example) are already embedded in the coefficient ka.  Temporary factors - interference, signal re-reflection, etc.  - will affect the result, but in practice, even indoors they do not interfere very much. <br>  Thus, we have dependency formulas for distance from all sources. <br>  If we solve the problem "in the forehead" - we have a system of quadratic equations, the solution of which will give us a point with coordinates xo, yo.  The problem is that the university course of linear algebra I forgot a little.  After a week of thinking, I stumbled upon this method. <br>  Let's draw around each detector a circle whose radius is inversely proportional to the signal level.  The area of ‚Äã‚Äãintersection of all circles and will contain the signal source.  For simplicity, we can assume that the source is in the center of this area. <br>  We build a drawing for a case with three detectors and one source. <br><img src="https://habrastorage.org/storage2/088/d36/e68/088d36e68a6428ee3a4a97e2c9540c6f.png"><br>  Here B and A are closest to the signal source, so the diameter of the circle is smaller.  C farthest, diameter larger.  The dependence of the diameter of the circle on the signal level is determined experimentally.  This drawing is built in real coordinates (say, meters), in order to go to practice, we translate them into pixels in the most usual way.  You just need to know the size of the map (width, height) in pixels and in meters.  The nonlinearity of the projection (if it is a satellite image) is as before neglected.  It is better to use a large-scale scheme, in my project it was a floor plan. <br><h5>  Part 2. We proceed to practice. </h5><br>  So, a simple solution is found, we will try to put it into practice.  The server part of my project was developed in Java, receives data from TCP detectors with SSL encryption in json format.  This part of the code is independent, it is executed in a separate thread.  Received events are stored in the mysql database. <br>  Triangulation works in its stream, selects events that have not yet been processed from the mysql database (no later than 3 seconds before the current time - in order to receive information about the same signal from all sources). <br>  Although the solution turned out to be simple and does not require any mathematics, it is also somehow necessary to short-cut the intersection of the circles.  Fortunately, Java has an AWT library that will do everything for us.  The absence of the window interface does not confuse her, and some of its classes work fine on the server in the backend. <br>  I cite a bit simplified code from the project. <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TriangulationPoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">triangulate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AlertDbo sourceAlert, AlertDbo[] children, MapFileDbo map)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ppx = map.getWidth() / map.getRealWidth(); <span class="hljs-comment"><span class="hljs-comment">//pixels per feet horizontal double ppy = map.getHeight() / map.getRealHeight(); //pixels per feet vertical</span></span></code> </pre> <br>  So, as you understand, ppx / ppy are coefficients for converting real coordinates to pixels. <br>  We take the signal level for the first detector, calculate the distance to the source, build a circle using coordinates known to us with the obtained radius. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> strength = sourceAlert.getSignalStrength(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> distance = calculateDistance(strength *sourceAlert.getDetector().getKoef()); MapCoordDbo coord = sourceAlert.getCoords(); ‚Ä¶ Area area = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Area(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ellipse2D.Double(coord.getX(), coord.getY(), distance*<span class="hljs-number"><span class="hljs-number">2</span></span>, distance*<span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Now we go through all the remaining sources and do the same.  We intersect the first circle with the result; we use the result in the cycle for the remaining detectors.  An additional trick - we intersect with the rectangle of the room, otherwise it may happen that the result will go beyond it, that we do not need. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;children.length;j++) { ‚Ä¶ strength = children[j].getSignalStrength(); distance = calculateDistance(strength * children[j].getDetector().getKoef()); coord = children[j].getCoords(); area.intersect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Area( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ellipse2D.Double(coord.getX(), coord.getY(), distance*<span class="hljs-number"><span class="hljs-number">2</span></span>, distance*<span class="hljs-number"><span class="hljs-number">2</span></span>) )); area.intersect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Area(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, map.getWidth(), map.getHeight()))); }</code> </pre><br><br>  Well, in the end we check that we have at least something left as a result, plus we calculate the calculation error (like half the diagonal of the rectangle in which the resulting area is inscribed). <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(area.getBounds().getWidth()&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; area.getBounds().getHeight()&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) { TriangulationPoint tp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TriangulationPoint(); tp.x = area.getBounds().getCenterX(); tp.y = area.getBounds().getCenterY(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = area.getBounds().getWidth() / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dy = area.getBounds().getHeight() / <span class="hljs-number"><span class="hljs-number">2</span></span>; tp.err = Math.sqrt(dx*dx + dy*dy) /<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br>  This is the function to calculate the distance. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateDistance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> db)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] dbs = {‚Ä¶}; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] fts = {‚Ä¶}; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> koef = -‚Ä¶; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> prevDb = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> prevDist = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;dbs.length;i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dbs[i]&lt;db) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } koef = (dbs[i] - prevDb) / (fts[i] - prevDist); prevDb = dbs[i]; prevDist = fts[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prevDist + koef * (db - prevDb); }</code> </pre><br>  Previously, it was a logarithmic function, but, unfortunately, the attenuation of a real signal is different, we had to look at the signal level at several points in the laboratory and record the signal level and the corresponding distance in two arrays. <br>  I removed the real numbers just in case so as not to disturb the NDA. <br>  By the way, absolutely the same solution is possible on C #.  Instead of Area, you need to use GraphicsPath, there is an Intersect method.  The only difficulty is finding the center of the intersection obtained.  Here is the code to find the center of the region in C #: <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PointF </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegionCentroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Region region, Matrix transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> my = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> total_weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (RectangleF rect <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> region.GetRegionScans(transform)) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rect_weight = rect.Width * rect.Height; mx += rect_weight * (rect.Left + rect.Width / <span class="hljs-number"><span class="hljs-number">2f</span></span>); my += rect_weight * (rect.Top + rect.Height / <span class="hljs-number"><span class="hljs-number">2f</span></span>); total_weight += rect_weight; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PointF(mx / total_weight, my / total_weight); }</code> </pre><br>  So, not having sufficient knowledge in mathematics and physics, with certain assumptions, it is possible to solve a rather complicated problem. <br>  Thanks for attention! </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/161195/">https://habr.com/ru/post/161195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161173/index.html">Video review tablet Lenovo IdeaTab A2109</a></li>
<li><a href="../161177/index.html">With (unofficial) computer graphics day!</a></li>
<li><a href="../161181/index.html">Yii 1.1.13 RC</a></li>
<li><a href="../161183/index.html">Sales of iPhone 5 in Russia will begin on December 14</a></li>
<li><a href="../161185/index.html">Course lectures "Startup". Peter Thiel. Stanford 2012. Session 8</a></li>
<li><a href="../161197/index.html">Site conversion. Turn visitors into buyers</a></li>
<li><a href="../161201/index.html">Digital elevation model using SRTM data</a></li>
<li><a href="../161203/index.html">MSP430 Launchpad as a signaling of the state of server hardware</a></li>
<li><a href="../161205/index.html">Likbez on typing in programming languages</a></li>
<li><a href="../161207/index.html">Building a social network graph using Drupal and Feeds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>