<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GPS and side bow. Multifunctional GPS Logger. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Some time ago I got the idea to upgrade my faithful and beloved GPS logger Holux M241. One could look for something interesting in the market t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GPS and side bow. Multifunctional GPS Logger. Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/geektimes/post_images/23c/d47/e0f/23cd47e0f2c8676913e23a1541d4833e.jpg" alt="image"><br><br>  Hello!  Some time ago I got the idea to upgrade my faithful and beloved GPS logger Holux M241.  One could look for something interesting in the market that could satisfy my needs.  But it was more interesting for me to dig in the direction of microcontrollers, NMEA GPS protocol, USB and SD Card intricacies, thereby building the device of your dreams. <br><br>  What exactly I build <a href="https://geektimes.ru/post/286348/">I described in detail in the first part</a> .  At that stage, I was targeting technology - I felt the Arduino in the context of a relatively large project.  It turned out there are a lot of nuances that are not particularly affected in ordinary tutorials.  In the comments I received a lot of interesting information, for which I am very grateful to the readers.  Hopefully today you will find something interesting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is the second article in the series.  Like the previous one, it is a kind of construction magazine.  I try to describe the technical solutions that I take in the course of work on the project.  Today we will connect the GPS.  And also switch to more mature technologies - FreeRTOS and STM32 microcontroller.  Well, as always, we will disassemble the firmware and see what is written there. <br><br>  I ask under the cat. <br><a name="habracut"></a><br><h2>  Gps </h2><br>  By this time, I already had an application framework.  Everything spun on the Arduino Nano on the ATMega328 controller.  It's time to connect my <a href="https://www.aliexpress.com/item/Best-seller-High-quality-Beitian-BN-880-GLONASS-Flight-Control-Dual-GPS-Module-With-Cable-for/32758938693.html">Beitan BN-880</a> GPS receiver. <br><br><div class="spoiler">  <b class="spoiler_title">Thoughts about UART</b> <div class="spoiler_text">  I have some bias towards UART as a low-speed protocol from the last century.  Mind, of course, I understand - the interface is as simple as 3 kopecks, it works on everything that moves.  What else is needed?  I also have a biased attitude to text protocols - messages should also be parsed.  Why not to drive the data in binary form?  Yes, even the packages?  Anyway, people do not read them.  And binary packages could greatly simplify processing.  Well then, I'm so buzzing. <br></div></div><br>  Seeing the legs of SDA and SCK sticking out of the module, I wanted to cling to them.  Hooked on and ...  I realized that the data is not so easy to get.  I don't even know how.  If a UART is used, the GPS receiver simply spills messages, and the recipient needs it.  I2C transmission is initiated only by the host.  Those.  you need to create some kind of request to get an answer.  But which one? <br><br>  Guglezh on the topic of BN-880 I2C for a couple of hours did not give anything useful.  The people simply use the UART, and most of the links led to quadcopter forums and mostly quadroopter problems were discussed there. <br><br>  It was not so easy to get to datasheets.  Those.  it was not at all clear what module to look for datasheet.  By indirect evidence, I found out that the UBlox NEO-M8N module is responsible for the GPS.  It turned out that this thing can do so many features that the mother does not worry (there is even a built-in odometer and logger there).  But it was necessary to read as many as 350 pages. <br><br>  Looking through the datasheet, I realized that with a hitch this module is not taken.  I had to step on my throat and connect to the already proven UART.  And then enter into another problem: on the UART Arduin, there is only one, and it sticks out in the direction of the computer (fill in the firmware).  I had to look towards the SoftwareSerial library. <br><br>  I wrote the simplest ‚Äúrebirth‚Äù of messages from the GPS port to the UART. <br><br><div class="spoiler">  <b class="spoiler_title">Translucer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">SoftwareSerial </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gpsSerial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">11</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// RX, TX void setup() { Serial.begin(9600); gpsSerial.begin(9600); } void loop() { if (gpsSerial.available()) { Serial.write(gpsSerial.read()); } }</span></span></code> </pre> <br></div></div><br>  Messages poured in, but I could not catch satellites.  Although the time was right. <br><br><pre> <code class="hljs perl">$GNRMC,<span class="hljs-number"><span class="hljs-number">203954.00</span></span>,V,,,,,,,,,,N*<span class="hljs-number"><span class="hljs-number">6</span></span>A $GNVTG,,,,,,,,,N*<span class="hljs-number"><span class="hljs-number">2</span></span>E $GNGGA,<span class="hljs-number"><span class="hljs-number">203954.00</span></span>,,,,,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">00</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,,,,,,*<span class="hljs-number"><span class="hljs-number">71</span></span> $GNGSA,A,<span class="hljs-number"><span class="hljs-number">1</span></span>,,,,,,,,,,,,,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>E $GNGSA,A,<span class="hljs-number"><span class="hljs-number">1</span></span>,,,,,,,,,,,,,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>E $GPGSV,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">02</span></span>,<span class="hljs-number"><span class="hljs-number">02</span></span>,,,<span class="hljs-number"><span class="hljs-number">21</span></span>,08,,,09*<span class="hljs-number"><span class="hljs-number">7</span></span>B $GLGSV,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">00</span></span>*<span class="hljs-number"><span class="hljs-number">65</span></span> $GNGLL,,,,,<span class="hljs-number"><span class="hljs-number">203954.00</span></span>,V,N*<span class="hljs-number"><span class="hljs-number">5</span></span>D</code> </pre><br>  The GPS lay for more than an hour at the window of the 21st floor before it gave sane coordinates.  And most of my review is not covered by high-rise buildings.  There is a suspicion that some spraying has been applied to the windows, which degrades the signal quality.  In any case, near the open window, the satellites, as if, are caught faster. <br><br>  Once there is a signal, then you can parse.  On the open spaces of the Internet, the TinyGPSPlus library first came across.  Not connected without hacks.  At ArduinoIDE, everything worked, but at Atmel Studio did not want to.  I had to manually register the path to the library. <br><br>  But then the problem got out.  On simple sketches from the examples of TinyGPS + everything worked.  But when I connected it to my project with a display and buttons, everything broke.  The device noticeably stupid, clearly skipping the screen rendering.  In the port monitor, I began to notice the crumpled messages from the GPS. <br><br>  The first assumption was that the SoftwareSerial very seriously ate processor resources.  So SoftwareSerial needs to be sent to a fire chamber since  for reliable communication with GPS, it is not suitable (at least in the form in which it is in the examples).  I even wanted to turn the scheme inside out: GPS is connected to the Arduin‚Äôs hardware UART, and the software series is used for debug (although it may not even be necessary to debug through UART if you have a screen).  But with such a scheme to download the firmware via UART will not work.  I had to get a USBAsp programmer. <br><br>  But a little later, I realized that SoftwareSerial is a voracious thing, but in this case the problem is not in it at all, but in the drawing function.  Drawing the current screen takes 50-75ms (plus a bit more overhead).  SoftwareSerial is working on interrupt reception on the controller's foot and should not consume much.  But his receiving buffer is only 64 bytes, which even at 9600 are filled for 60ms.  It turns out, while the program is engaged in drawing the screen, part of the message from the GPS has time to pass by. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b21/737/5db/b217375db6c812b7249db603d0b670d2.jpg" alt="image"><br>  <i>In the first half of the article I get a lot of text.</i>  <i>I dilute them with pictures.</i>  <i>This screen displays the current altitude and vertical speed.</i> <br><br><h2>  ARM </h2><br>  So.  With the current approach, I rested on several limitations at once: <br><br><ul><li>  Flash and RAM.  Not so much was busy, but you had to constantly remember this </li><li>  Only one UART.  Additional SoftwareSerial significantly consumes processor resources. </li><li>  In one thread, it is obviously impossible to do everything.  We need to think about parallelizing tasks. </li></ul><br>  And it was also necessary to design with the expectation of the future - I still have a USB connection and an SD card. <br><br>  After the release of the previous part, I received a lot of comments that Arduino sucks and the future of ARM and STM32 controllers.  I didn‚Äôt really want to leave the Arduino platform.  As I said, the framework is fairly simple and straightforward, and I also know ATMega controllers well. <br><br>  At the same time, switching to STM32 would most likely mean a change of the platform as a whole, a microcontroller, a compiler, a framework, libraries, an IDE, and who knows what else.  Those.  almost all at once.  For a project, this would mean stopping completely, studying documentation for a long time, studying various examples, and only then starting to rewrite everything from scratch. <br><br>  I began to feel the ways out of the situation, listening to the commentators of the first part.  I wanted to find a solution that solved the limitations, gave some groundwork for the future, but it did not require huge resources to move everything at once.  Here are a few (in general, independent) things with which I poked around. <br><br><ul><li>  Connect the Sparkfun Pro Micro clone to ATMega32u4 (3.3V, 8MHz).  In it, I wanted to touch USB hardware.  It took me quite a bit of time to get this thing at all.  The staff bootloader didn‚Äôt really want to wind up like an Arduino, and the fuse bits were put up in some mysterious way.  As a result, with the help of USBAsp, a bootloader from Arduino Leonardo was sewn and everything started up. <br><br></li><li>  The debug board came to ATMega64.  It has 2 times more memory (both flash and RAM) and 2 uart.  Basically removes restrictions.  Unfortunately, the circuit is not attached to the circuit and what kind of quartz there is also not clear.  Until postponed. <br><br></li><li>  I tried to feel the FreeRTOS port under the AVR.  But then Kaku planted Atmel Studio.  It turned out that she has 2 types of projects.  In one studio works in the Arduino mode, but in this case practically nothing can be changed in the project settings.  Those.  trite you can not even put FreeRTOS in a subdirectory and include the include path.  It can only add all the files in one pile, which personally would annoy me. <br><br>  The second option is the Generic C ++ Executable project type.  The implication is that you need to write on bare C ++.  Here you can configure as you please.  But first, you need to screw the Arduinov framework, and secondly, it is not clear how to screw the firmware float into the controller.  Avrdude stubbornly did not want to overload the microcontroller into the bootloader (although I had a look at the command line from ArduinoIDE using ProcessMonitor).  I have a USBasp, but if there is a USB port right on the board, it is not programmable through the programmer. <br><br></li><li>  Finally, I decoupled the comb on the <a href="http://www.ebay.com/itm/STM32F103C8T6-ARM-STM32-Minimum-System-Development-Board-Module-For-Arduino-/201529768817">board with the STM32F103C8T6</a> and installed the <a href="https://github.com/rogerclarkmelbourne/Arduino_STM32">STM32duino</a> <a href="https://geektimes.ru/post/277928/">according to the instructions</a> .  To my surprise, the LED blinker immediately started working.  To even more surprise, it took less than 10 minutes to port my project to the new controller !!!  Just a couple of inclusives change and pin numbers correct. </li></ul><br>  It was what you need.  I received the power of STM32 (yes! The drawing function now took only 18ms!) And at the same time I could continue to use the arduino framework.  This made it possible to continue working on the project, while necessarily smoothly plunging into a new platform, reading the datasheet on the microcontroller in the metro. <br><br>  Flash gain is, in fact, a very ghostly improvement.  The project both occupied a half flush on ATmega32, and takes up almost half on the new STM32 (ok, 26k out of 64k).  So it was not worth relaxing.  Especially (as they say on the Internet) the compiled code is a bit more sweeping and fills up the flash faster than on the AVR.  So just in case I ordered a handkerchief with a 128k flash. <br><br>  True, there was another surprise waiting for me.  The people <a href="https://www.google.com.ua/webhp%3Fsourceid%3Dchrome-instant%26ion%3D1%26espv%3D2%26ie%3DUTF-8">on the Internet write</a> that although the controller on the datasheet has 64k flash on board, in fact you can use 128k.  Those.  it seems the ST produces the same chip, only part of it is labeled as STM32F103C8T6, and the other as STM32F103CBT6 (the same controller, but with 128k flash). <br><br>  By the way (follow up after the previous article).  In the ARM architecture, both flash and RAM are in the same address space and are read in the same way.  Therefore, dancing with a tambourine and the declaration of constants using PROGMEM are no longer needed.  Picked up for the sake of purity of the code.  Tables of virtual functions, too, do not need to copy anywhere, because  they are also in the same address space. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/36a/2cf/56c/36a2cf56cafd7f7ed87c8905cc05a8bf.jpg" alt="image"><br>  <i>Another picture to dilute the text.</i>  <i>From left to right: direction of motion (now we are not going anywhere), current speed, current altitude.</i>  <i>The screen is honestly lapped with the same for Holux M241</i> <br><br><h2>  FreeRTOS </h2><br>  The STM32duino bundle also showed up a FreeRTOS port for my controller (and as many as two - 7.0.1 and 8.2.1).  Examples with minimal edits also earned.  So it was possible to switch to FreeRTOS without rewriting a significant part of the project. <br><br>  After reading a couple of articles ( <a href="https://habrahabr.ru/post/249273/">one</a> , <a href="https://habrahabr.ru/post/261807/">two</a> ), I realized what power is now available to me - streams, mutexes, queues, semaphores, and other synchronization.  Everything is like on large computers.  The main thing is to design everything correctly. <br><br>  Despite the fact that the main problem I had was GPS, I still decided to start with something simpler - buttons.  In a sense, FreeRTOS makes the code much easier - each thread can do some specific task, and, if necessary, notify other threads.  So, the task of servicing the buttons fit perfectly into this ideology - listen to your buttons and do not get distracted by anything.  And as something will click - notify. <br><br><div class="spoiler">  <b class="spoiler_title">Step aside</b> <div class="spoiler_text">  Although the threads and message queues are cool, it seemed to me that the approach of polling the buttons in the loop was not entirely correct - there are interruptions to changing the value on the leg!  Well, I also wanted to just try how it works on STM32 :) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selButtonPinHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint32 lastInterruptTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(digitalRead(SEL_BUTTON_PIN)) <span class="hljs-comment"><span class="hljs-comment">// Falling edge { uint32 cur = millis(); uint32 pressDuration = cur - lastInterruptTime; Serial.print("DePressed at "); Serial.println(lastInterruptTime); if(pressDuration &gt; LONG_PRESS_TIMEOUT) Serial.println("Sel Long Press"); else if(pressDuration &gt; SHORT_CLICK_TIMEOUT) Serial.println("Sel Short Click"); else { Serial.print("Click was too short: "); Serial.println((int)pressDuration); } } lastInterruptTime = millis(); if(!digitalRead(SEL_BUTTON_PIN)) // Raising edge { Serial.print("Pressed at "); Serial.println(lastInterruptTime); } } void initButtons() { // Set up button pins pinMode(SEL_BUTTON_PIN, INPUT_PULLUP); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> using PullUps is an AVR legacy. Consider changing this to pull down pinMode(OK_BUTTON_PIN, INPUT_PULLUP); // so pin state match human logic expectations attachInterrupt(SEL_BUTTON_PIN, selButtonPinHandler, CHANGE); }</span></span></code> </pre><br>  Instead of prints should have been sending messages about the pressed button. <br><br>  But to be honest, it turned out cumbersome (this is processing only one button) and even terribly buggy.  Some kind of false positives were observed, or vice versa, non-positives.  It seems that the millis () function did not work as expected and could return the same values ‚Äã‚Äãfor a fairly long period of time. <br></div></div><br>  I will remind you.  In the main program loop, I had a large state machine that controlled the display and listened to the buttons.  Adding some sort of logic was accompanied by redrawing half the code, and only the guru of programming state machines was able to understand how it works by simply looking at the code.  But since I have an RTOS, everything turned out much easier. <br><br><div class="spoiler">  <b class="spoiler_title">Button handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Pins assignment const uint8 SEL_BUTTON_PIN = PC14; const uint8 OK_BUTTON_PIN = PC15; // Timing constants const uint32 DEBOUNCE_DURATION = 1 / portTICK_PERIOD_MS; const uint32 LONG_PRESS_DURATION = 500 / portTICK_PERIOD_MS; const uint32 VERY_LONG_PRESS_DURATION = 1000 / portTICK_PERIOD_MS; const uint32 POWER_OFF_POLL_PERIOD = 1000 / portTICK_PERIOD_MS; // Polling very rare when power is off const uint32 IDLE_POLL_PERIOD = 100 / portTICK_PERIOD_MS; // And little more frequent if we are on const uint32 ACTIVE_POLL_PERIOD = 10 / portTICK_PERIOD_MS; // And very often when user actively pressing buttons QueueHandle_t buttonsQueue; // Reading button state (perform debounce first) inline bool getButtonState(uint8 pin) { if(digitalRead(pin)) { // dobouncing vTaskDelay(DEBOUNCE_DURATION); if(digitalRead(pin)) return true; } return false; } /// Return ID of the pressed button (perform debounce first) ButtonID getPressedButtonID() { if(getButtonState(SEL_BUTTON_PIN)) return SEL_BUTTON; if(getButtonState(OK_BUTTON_PIN)) return OK_BUTTON; return NO_BUTTON; } // Initialize buttons related stuff void initButtons() { // Set up button pins pinMode(SEL_BUTTON_PIN, INPUT_PULLDOWN); pinMode(OK_BUTTON_PIN, INPUT_PULLDOWN); // Initialize buttons queue buttonsQueue = xQueueCreate(3, sizeof(ButtonMessage)); // 3 clicks more than enough } // Buttons polling thread function void vButtonsTask(void *pvParameters) { for (;;) { // Wait for a button ButtonID btn = getPressedButtonID(); if (btn != NO_BUTTON) { // Button pressed. Waiting for release TickType_t startTime = xTaskGetTickCount(); while(getPressedButtonID() != NO_BUTTON) vTaskDelay(ACTIVE_POLL_PERIOD); // Prepare message to send ButtonMessage msg; msg.button = btn; // calc duration TickType_t duration = xTaskGetTickCount() - startTime; if(duration &gt; VERY_LONG_PRESS_DURATION) msg.event = BUTTON_VERY_LONG_PRESS; else if(duration &gt; LONG_PRESS_DURATION) msg.event = BUTTON_LONG_PRESS; else msg.event = BUTTON_CLICK; // Send the message xQueueSend(buttonsQueue, &amp;msg, 0); } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Use different polling periods depending on global system state (off/idle/active) vTaskDelay(ACTIVE_POLL_PERIOD); } }</span></span></code> </pre> </div></div><br>  It turned out very compact and clear.  The functions are all very linear.  Just loop through the buttons and, based on the length of the press, send the corresponding message. <br><br>  I decided that I would have 3 types of pressing durations: <br><br><ul><li>  Short to select the corresponding menu item </li><li>  Long for a special action (for example, resetting the selected parameter) </li><li>  Very long press to turn the device on and off </li></ul><br>  Incidentally, I decided to connect the buttons not to a plus, but to a minus.  Naturally pull-up resistors replaced by pull-down.  I am not good at electronics and can be mistaken here, but in general I was guided by the following considerations: <br><br><ul><li>  In the released position of the pin button is pressed to zero, which means the current does not flow (even if it is scanty) </li><li>  When reading a value from a pin, the value is obtained non-inverted: 1 if the button is pressed, 0 is released </li></ul><br>  ScreenManager is also greatly simplified.  No more need for global display status.  The rendering stream deals exclusively with rendering and is controlled by the messages from the buttons.  He simply waited for messages in the queue and practiced the received commands.  And the wait loop itself was also made through a queue using a timeout in the xQueueReceive function.  Those.  the function waits for the message, and if nothing happens for a long time, it simply draws the screen as it is <br><br><div class="spoiler">  <b class="spoiler_title">Display stream</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vUserInteractionTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-comment"><span class="hljs-comment">// Poll the buttons queue for an event. Process button if pressed, or show current screen as usual if no button pressed ButtonMessage msg; if(xQueueReceive(buttonsQueue, &amp;msg, DISPLAY_CYCLE)) processButton(msg); // Do what we need for current state drawDisplay(); } }</span></span></code> </pre> </div></div><br>  It turned out, in my opinion, very elegant.  Later I added turning off the screen here after a certain timeout (saving the battery), but the code was not significantly complicated. <br><br>  Handling buttons is also trivial - just parse the message and call the necessary function. <br><br><div class="spoiler">  <b class="spoiler_title">Button handling</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ButtonMessage &amp;msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(msg.button == SEL_BUTTON &amp;&amp; msg.event == BUTTON_CLICK) getCurrentScreen()-&gt;onSelButton(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(msg.button == OK_BUTTON &amp;&amp; msg.event == BUTTON_CLICK) getCurrentScreen()-&gt;onOkButton(); <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> process long press here }</span></span></code> </pre> <br></div></div><br>  The showMessageBox () function is also greatly simplified and is now completely linear. <br><br><div class="spoiler">  <b class="spoiler_title">message box</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showMessageBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Center text uint8_t x = 128/2 - strlen_P(text)*6/2; // Draw the message display.clearDisplay(); display.setFont(NULL); display.drawRect(2, 2, 126, 30, 1); display.setCursor(x, 12); display.print(text); display.display(); // Wait required duration vTaskDelay(MESSAGE_BOX_DURATION); }</span></span></code> </pre> <br></div></div><br>  And finally.  What kind of device is it if it does not have a blinking light bulb?  Need to fix.  No matter how ridiculous it was, but it is convenient to monitor whether the device is still working on the blinking diode, or it has hung long ago. <br><br><div class="spoiler">  <b class="spoiler_title">Hello FreeRTOS World!</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vLEDFlashTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { vTaskDelay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); digitalWrite(PC13, LOW); vTaskDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>); digitalWrite(PC13, HIGH); } }</code> </pre> <br></div></div><br><h2>  Again gps </h2><br>  Finally, it is time to gnaw at the GPS.  Now there is no problem at the same time listening to GPS and doing the rest.  To begin, I again wrote a retrofit: <br><br><div class="spoiler">  <b class="spoiler_title">Translucer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initGPS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// GPS is attached to Serial1 Serial1.begin(9600); } void vGPSTask(void *pvParameters) { for (;;) { while(Serial1.available()) { int c = Serial1.read(); gps.encode(c); Serial.write(c); } vTaskDelay(5); } }</span></span></code> </pre> </div></div><br>  But there was a problem.  The messages were formally parsed, only now there was not even time to bite out.  Smoking the TinyGPS sources and receiver documentation showed a slight discrepancy between the messages from the GPS module and the fact that it can parse the library. <br><br>  The UBlox module implements some kind of NMEA protocol extension.  Each message begins with a five-letter message identifier. <br><br><pre> <code class="hljs perl">$GNGGA,<span class="hljs-number"><span class="hljs-number">181220.00</span></span>,,,,,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">00</span></span>,<span class="hljs-number"><span class="hljs-number">99.99</span></span>,,,,,,*<span class="hljs-number"><span class="hljs-number">70</span></span></code> </pre> <br>  The first 2 letters encode the subsystem that prepared the data: GP for GPS, GL for GLONASS, GA for GALILLEO.  But if you use a combination of positioning systems, the messages will begin with GN. <br><br>  The TinyGPS + library was not designed for this - it could only parse the GP messages.  I had to tweak it a bit - I changed the corresponding line in the parser and the time on the screen ran.  Only here it all smacked some sort of hack. <br><br>  Fellow suggested an alternative - the <a href="https://github.com/SlashDevin/NeoGPS">library NeoGPS</a> .  This is a much more feature-rich library.  Besides the fact that she can parse messages with different prefixes, she also allows parsing information about satellites (I personally like these things in GPS receivers).  It is also worth noting that the library is terribly configurable - you can turn on / off the parsing of individual messages and thereby adjust the memory consumption depending on the tasks. <br><br>  It was not difficult to connect the library to stm32duino, although it was nevertheless necessary to file a bit.  But as always in the examples everything is simple and clear, but in a real project it did not work right away.  In particular, it was unclear at what point in time to read correctly from the GPS.  Here, for example, an attempt to deduct data on satellites. <br><br><div class="spoiler">  <b class="spoiler_title">Retrieving satellite information</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Serial1.available()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = Serial1.read(); Serial.write(c); gpsParser.handle(c); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gpsParser.available()) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(satellites, gpsParser.satellites, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(satellites)); sat_count = gpsParser.sat_count; } vTaskDelay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> </div></div><br>  From time to time, the parser says that the profit data - take it.  Coordinates always come normally, but with satellites trouble.  I take, and there are zeros.  Or not zeros.  If we get lucky. <br><br>  It turned out it was necessary to carefully read the documentation.  It's all about the design of the library.  In the name of saving memory, the data is expanded in the course of parsing.  With that byte byte - came bytes, updated the variable.  Data comes in batches of several messages.  The NeoGPS library needs to know when a new package starts, in order to zero out internal variables.  The configuration parameter LAST_SENTENCE_IN_INTERVAL is responsible for this. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------ // Select which sentence is sent *last* by your GPS device // in each update interval. This can be used by your sketch // to determine when the GPS quiet time begins, and thus // when you can perform "some" time-consuming operations. #define LAST_SENTENCE_IN_INTERVAL NMEAGPS::NMEA_RMC</span></span></code> </pre><br>  So the RMC message from me comes the very first in the message pack.  It turns out that my code could read partially parsed data (Perhaps it was the data from previous packages that had not yet been reset).  Or read zeroes if read at the wrong time.  It is treated quite simply: we indicate that in each package from the GPS module the last message is GLL. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f0d/caf/b49/f0dcafb49da1d4aee8d3876f1b09d071.jpg" alt="image"><br>  <i>There are many satellites, but there is no fixation and no.</i>  <i>From top to bottom: the number of satellites (monitored vs untraceable - I don‚Äôt know what that means), HDOP / VDOP, GPS signal status (word / word)</i> <br><br>  By the way, with the library in the bundle, quite convenient functions for working with date and time were found.  For example, it was very easy to fasten the time zone.  I only store the time offset in minutes, and the rest is easy to calculate along the way. <br><br><div class="spoiler">  <b class="spoiler_title">Correction of time according to the selected time zone</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TimeZoneScreen::drawScreen() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Get the date/time adjusted by selected timezone value gps_fix gpsFix = gpsDataModel.getGPSFix(); int16 timeZone = getCurrentTimeZone(); NeoGPS::time_t dateTime = gpsFix.dateTime + timeZone * 60; //timeZone is in minutes ... printNumber(dateBuf, dateTime.date, 2); printNumber(dateBuf+3, dateTime.month, 2); printNumber(dateBuf+6, dateTime.year, 2);</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/getpro/geektimes/post_images/99c/806/ae6/99c806ae6d026cdeef5514bae7f0ffde.jpg" alt="image"><br>  <i>The time zone selection screen is honestly lapped with Hulux</i> <br><br><h2>  Model-View </h2><br>  When writing code, we must not forget now that we are working in a multithreaded environment.  So, I have a stream that serves GPS: it listens to the Serial port, parsit data from it byte-by-byte.  Packages come once a second.  The library knows when the next packet starts and resets internal variables before accepting.  When a packet is fully accepted, the available flag is set.  Data arrives for about half a second (there is 600 bytes at 9600).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We still have half a second to pick them up before the next packet starts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second thread deals with the maintenance of the display. The cycle of drawing occurs every 100-120ms. At each iteration, the program takes the actual data from the GPS and renders what the user wants to see now - coordinates, speed, altitude, or something else. And here a contradiction arises: the flow of the display always wants to receive data, whereas in the library they are only available for half a second, and then they are overwritten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The solution is quite obvious: copy the data to itself in an intermediate buffer. Naturally, the data in this buffer must be protected by a mutex ( </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), otherwise data may not be read correctly. But that's the problem. The data in the GPS stream appears, albeit rarely, but you can quickly subtract it (there are only one and a half hundred bytes after parsing); you do not need to block the mutex for a long time. But the drawing function can work for quite a long time (up to 20ms). Blocking a mutex for such a long time is generally not very good. Although not fatal, in this particular project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can, of course, quickly block the mutex, take the data into a local variable and release the mutex. But it is fraught with memory overruns. Another fifteen hundred bytes with 20 kilobytes is garbage, but personally the very fact of triple buffering strains me.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The buffer, by the way, had to be declared a global variable because it is very large and causes a stack overflow if you declare it as a function. </font><font style="vertical-align: inherit;">Just in case the drawing thread wrote out a bigger stack.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proof of satellite data in the drawing function</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">NMEAGPS::<span class="hljs-keyword"><span class="hljs-keyword">satellite_view_t</span></span> l_satellites[ NMEAGPS_MAX_SATELLITES ]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l_sat_count; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SatellitesScreen::drawScreen() { xSemaphoreTake(xGPSDataMutex, portMAX_DELAY); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(l_satellites, satellites, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(l_satellites)); l_sat_count = sat_count; xSemaphoreGive(xGPSDataMutex); display.draw(....) ... }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With instantaneous values ‚Äã‚Äãthat can be obtained directly from the NMEA stream, everything is simple - the NeoGPS library reads them out and decomposes them into variables. </font><font style="vertical-align: inherit;">Each screen can simply read the corresponding variable (not forgetting the synchronization, of course) and display it on the screen. </font><font style="vertical-align: inherit;">But with the variables that need to be calculated so simply did not work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a long thought, I came to the classic model-view scheme.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objects that inherit screen are views - they display various data from the model, but the data itself does not produce. </font><font style="vertical-align: inherit;">All logic lies in the GPSDataModel class. </font><font style="vertical-align: inherit;">He is responsible for storing instant GPS data (until new data arrives from NeoGPS). </font><font style="vertical-align: inherit;">He is also responsible for calculating new data, such as odometers or vertical speed. </font><font style="vertical-align: inherit;">And last but not least, this class itself deals with all the synchronization for its data.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model class</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 ODOMERTERS_COUNT = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * GPS data model. Encapsulates all the knowledge about various GPS related data in the device */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPSDataModel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GPSDataModel(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processNewGPSFix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gps_fix &amp; fix)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processNewSatellitesData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NMEAGPS::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">satellite_view_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * sattelites, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">gps_fix </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGPSFix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">GPSSatellitesData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSattelitesData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVerticalSpeed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeDifference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Odometers GPSOdometerData getOdometerData(uint8 idx) const; void resumeOdometer(uint8 idx); void pauseOdometer(uint8 idx); void resetOdometer(uint8 idx); void resumeAllOdometers(); void pauseAllOdometers(); void resetAllOdometers(); private: gps_fix cur_fix; /// most recent fix data gps_fix prev_fix; /// previously set fix data GPSSatellitesData sattelitesData; // Sattelites count and signal power GPSOdometer * odometers[ODOMERTERS_COUNT]; bool odometerWasActive[ODOMERTERS_COUNT]; SemaphoreHandle_t xGPSDataMutex; GPSDataModel( const GPSDataModel &amp;c ); GPSDataModel&amp; operator=( const GPSDataModel &amp;c ); }; //GPSDataModel /// A single instance of GPS data model extern GPSDataModel gpsDataModel;</span></span></code> </pre> <br></div></div><br>  Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the class of the model is responsible for synchronizing data between the streams, then the mutex lives in it, which governs access to the internal fields of the class. </font><font style="vertical-align: inherit;">I was terribly uncomfortable (and ugly) to use bare xSemaphoreTake () / xSemaphoreGive (), so I drew a classic auto grabber (more precisely, even an autosolder).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mutex locker</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(SemaphoreHandle_t mtx) { mutex = mtx; xSemaphoreTake(mutex, portMAX_DELAY); } ~MutexLocker() { xSemaphoreGive(mutex); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: SemaphoreHandle_t mutex; };</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pick up the current value is very simple. </font><font style="vertical-align: inherit;">You just need to call the getGPSFix () function, which simply returns a copy of the data.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data retriever</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">gps_fix GPSDataModel::getGPSFix() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xGPSDataMutex)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur_fix; }</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client does not need to be soared about locks and all that. </font><font style="vertical-align: inherit;">Just take the data and draw as needed.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client code</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpeedScreen::drawScreen() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Get the gps fix data gps_fix gpsFix = gpsDataModel.getGPSFix(); // Draw speed ... printNumber(buf, gpsFix.speed_kph(), 4, true);</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model class stores not only the most recent data (cur_fix), but also the previous value (prev_fix). </font><font style="vertical-align: inherit;">So, calculating the vertical velocity becomes a trivial task.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical Speed ‚Äã‚ÄãCalculator</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> GPSDataModel::getVerticalSpeed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xGPSDataMutex)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Return NAN to indicate vertical speed not available if(!cur_fix.valid.altitude || !prev_fix.valid.altitude) return NAN; return cur_fix.altitude() - prev_fix.altitude(); // Assuming that time difference between cur and prev fix is 1 second }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the data about the satellites turned out very interesting. </font><font style="vertical-align: inherit;">Data about satellites live in an array of NMEAGPS :: satellite_view_t structures. </font><font style="vertical-align: inherit;">The array weighs 150 bytes and, as I already wrote, it needs to be copied several times. </font><font style="vertical-align: inherit;">Not so critical in the presence of 20kb operatives, but still it is three times 150 bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, I realized that I didn‚Äôt need all the data, it‚Äôs enough to copy for myself only what is actually used. </font><font style="vertical-align: inherit;">As a result, such a class was born.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satellite data storage</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPSSatellitesData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Partial copy of NMEAGPS::satellite_view_t trimmed to used data struct SatteliteData { uint8_t snr; bool tracked; }; SatteliteData satellitesData[SAT_ARRAY_SIZE]; uint8_t sat_count; public: GPSSatellitesData(); void parseSatellitesData(NMEAGPS::satellite_view_t * sattelites, uint8_t count); uint8_t getSattelitesCount() const {return sat_count;} uint8_t getSatteliteSNR(uint8_t sat) const {return satellitesData[sat].snr;} bool isSatteliteTracked(uint8_t sat) const {return satellitesData[sat].tracked;} };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This class is no longer so offensive to copy once again - it takes only 40 bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most difficult part of the scheme is the GPSOdometer class. </font><font style="vertical-align: inherit;">As the name implies, he is responsible for all calculations related to the functionality of the odometer.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classes of odometer and its data</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// This class represents a single odometer data with no logic around class GPSOdometerData { // GPSOdometer and its data are basically a single object. The difference is only that data can be easily copied // while GPS odometer object is not supposed to. Additionally access to Odometer object is protected with a mutex // in the model object // In order not to overcomplicte design I am allowing GPS Odometer to operate its data members directly. friend class GPSOdometer; bool active; NeoGPS::Location_t startLocation; NeoGPS::Location_t lastLocation; float odometer; int16 startAltitude; int16 curAltitude; clock_t startTime; ///! When odometer was turned on for the first time clock_t sessionStartTime; ///! When odometer was resumed for the current session clock_t totalTime; ///! Total time for the odometer (difference between now and startTime) clock_t activeTime; ///! Duration of the current session (difference between now and sessionStartTime) clock_t activeTimeAccumulator; ///! Sum of all active session duration (not including current one) float maxSpeed; public: GPSOdometerData(); void reset(); // getters bool isActive() const {return active;} float getOdometerValue() const {return odometer;} int16 getAltitudeDifference() const {return (curAltitude - startAltitude) / 100.;} // altitude is in cm clock_t getTotalTime() const {return totalTime;} clock_t getActiveTime() const {return activeTimeAccumulator + activeTime;} float getMaxSpeed() const {return maxSpeed;} float getAvgSpeed() const; float getDirectDistance() const; }; // This is an active odometer object that operates on its odometer data class GPSOdometer { GPSOdometerData data; public: GPSOdometer(); // odometer control void processNewFix(const gps_fix &amp; fix); void startOdometer(); void pauseOdometer(); void resetOdometer(); // Some data getters GPSOdometerData getData() {return data;} bool isActive() const {return data.isActive();} }; //GPSOdometer</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The difficulty is this. </font><font style="vertical-align: inherit;">The gps_fix object, which comes to us from GPS, may contain some data, and some may not. </font><font style="vertical-align: inherit;">For example, the coordinate will arrive, but the height is not. </font><font style="vertical-align: inherit;">And in the next fix may be the opposite. </font><font style="vertical-align: inherit;">So just save gps_fix will not work. </font><font style="vertical-align: inherit;">It is necessary to watch every time what is available in the new fix and what is not. </font><font style="vertical-align: inherit;">Therefore, it was necessary to fence a very complex algorithm, to memorize the coordinates, heights and time stamps separately.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Every second odometer data update</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GPSOdometer::processNewFix(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gps_fix &amp; fix) { Serial.print(<span class="hljs-string"><span class="hljs-string">"GPSOdometer: Processing new fix "</span></span>); Serial.println((int32)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.active) { Serial.println(<span class="hljs-string"><span class="hljs-string">"Active odometer: Processing new fix"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Fill starting position if needed if(fix.valid.location &amp;&amp; !isValid(data.startLocation)) data.startLocation = fix.location; // Fill starting altitude if neede if(fix.valid.altitude &amp;&amp; !data.startAltitude) // I know altitude can be zero, but real zero cm altutude would be very rare condition. Hope this is not a big deal data.startAltitude = fix.altitude_cm(); // Fill starting times if needed if(fix.valid.time) { if(!data.startTime) data.startTime = fix.dateTime; if(!data.sessionStartTime) data.sessionStartTime = fix.dateTime; } // Increment the odometer if(fix.valid.location) { // but only if previous location is really valid if(isValid(data.lastLocation)) data.odometer += NeoGPS::Location_t::DistanceKm(fix.location, data.lastLocation); // In any case store current (valid) fix data.lastLocation = fix.location; } // Store current altitude if(fix.valid.altitude) data.curAltitude = fix.altitude_cm(); // update active time values if(fix.valid.time) data.activeTime = fix.dateTime - data.sessionStartTime; // update max speed value if(fix.valid.speed &amp;&amp; fix.speed_kph() &gt; data.maxSpeed) data.maxSpeed = fix.speed_kph(); } //Total time can be updated regardless of active state if(fix.valid.time &amp;&amp; data.startTime) data.totalTime = fix.dateTime - data.startTime; }</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this place my flash size has increased dramatically - by almost 10kb. </font><font style="vertical-align: inherit;">A lot of mathematical code crawled into the project - sines, cosines, tangents, square roots and all that jazz. </font><font style="vertical-align: inherit;">It turned out that the legs grow </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the NeoGPS :: Location_t :: DistanceKm () function</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - all this is used in distance calculation based on coordinates. </font><font style="vertical-align: inherit;">Gritting his teeth had to agree, but thought about the controller on the Cortex M4 - there it must be calculated hardwired.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odometer control</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GPSOdometer::startOdometer() { data.active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Reset session values data.sessionStartTime = 0; data.activeTime = 0; } void GPSOdometer::pauseOdometer() { data.active = false; data.activeTimeAccumulator += data.activeTime; data.activeTime = 0; } void GPSOdometer::resetOdometer() { data.reset(); }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that there is no synchronization in the odometer class. This is because all synchronization takes place in the GPSDataModel class. I just did not want to make a mutex in every object. But because of this, I had to complicate the odometer class itself and divide it into 2 classes: an object with data (GPSOdometerData) can be copied at the request of customers, whereas a control object (GPSOdometer) is created once per odometer. Because of this, I also had to make one class a friend to another. Maybe I will revise this design in the future. </font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/009/34a/1ad/00934a1ad064fef2fc850b7208ca6361.jpg" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the main odometer screen. The character point in the font has not yet added - should show 0.42 km. It also displays the elevation difference - lying on the spot on the window sill, you can easily drop 18 or more meters.</font></font></i> <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/06c/b41/fd7/06cb41fd7e4a78c0bdfc5c5ab911d072.jpg" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other useful options that can be displayed by odometer. </font><font style="vertical-align: inherit;">On one screen, everything did not even fit - I will do 2 or even 3 screens. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPSDataModel can manage all odometers at once. </font><font style="vertical-align: inherit;">This feature was proposed in the comments and should be convenient - went to the cafe, turned off all odometers at once. </font><font style="vertical-align: inherit;">Came out - turned them on again.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odometer control all at once</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GPSDataModel::resumeAllOdometers() { <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xGPSDataMutex)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(odometerWasActive[<span class="hljs-number"><span class="hljs-number">0</span></span>]) odometers[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;startOdometer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(odometerWasActive[<span class="hljs-number"><span class="hljs-number">1</span></span>]) odometers[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;startOdometer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(odometerWasActive[<span class="hljs-number"><span class="hljs-number">2</span></span>]) odometers[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;startOdometer(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GPSDataModel::pauseAllOdometers() { <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xGPSDataMutex)</span></span></span></span>; odometerWasActive[<span class="hljs-number"><span class="hljs-number">0</span></span>] = odometers[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;isActive(); odometerWasActive[<span class="hljs-number"><span class="hljs-number">1</span></span>] = odometers[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;isActive(); odometerWasActive[<span class="hljs-number"><span class="hljs-number">2</span></span>] = odometers[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;isActive(); odometers[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;pauseOdometer(); odometers[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;pauseOdometer(); odometers[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;pauseOdometer(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GPSDataModel::resetAllOdometers() { <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xGPSDataMutex)</span></span></span></span>; odometers[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;resetOdometer(); odometers[<span class="hljs-number"><span class="hljs-number">1</span></span>]-&gt;resetOdometer(); odometers[<span class="hljs-number"><span class="hljs-number">2</span></span>]-&gt;resetOdometer(); odometerWasActive[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; odometerWasActive[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; odometerWasActive[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Again FreeRTOS'im </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to study the possibilities of FreeRTOS, I tried to see how much time the processor actually spends in calculations. You can use </font></font><a href="http://www.freertos.org/RTOS-idle-task.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ApplicationIdleHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for evaluation </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any RTOS has a so-called idle stream. If the processor has nothing to occupy itself - a certain infinite loop turns in a separate task with the lowest priority. FreeRTOS allows you to add some usefulness to this infinite loop and run this hook. The idea of ‚Äã‚Äãmeasuring the CPU load is that the more the processor spends time in the idle stream, the less it is loaded with other (useful) work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the Internet, I found several approaches on how to measure CPU usage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some guys offered to twist a certain counter in the Idle Hook function and measure the speed with which it ‚Äúpulls‚Äù. To translate this into percentages, you need to divide the resulting speed into some reference value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But where to get this reference speed? To do this, you need to extinguish all other flows and measure only the speed of the counter in the unloaded system. You can, for example, at the start, make a delay of 1-2 seconds for measurements, but personally it terribly enrages me when simple devices are ‚Äúloaded‚Äù for 5-10 seconds (for example, cameras, soap boxes, grrrr). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In another variant, it was proposed to start a separate timer from the Internet and reload the entry and exit macros into the flow context. The idea is to measure the difference in the values ‚Äã‚Äãof the timer at the input and at the output in each stream and from this draw a conclusion about the processor load.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, I heard about Run Time Stats on FreeRTOS. </font><font style="vertical-align: inherit;">But, as stated in the instructions, it is intended for another. </font><font style="vertical-align: inherit;">This function allows </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to get a download for each individual stream and for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entire</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> period of the application operation. </font><font style="vertical-align: inherit;">I wanted to measure instant processor load. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to try the next one. </font><font style="vertical-align: inherit;">I do not know how correct it is and whether it will work at all when I screw up sleep mode. </font><font style="vertical-align: inherit;">But at this stage it works well.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">load measurement</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint8 periodLen = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 2^periodLen ticks - 512 x 1ms ticks volatile TickType_t curIdleTicks = 0; volatile TickType_t lastCountedTick = 0; volatile TickType_t lastCountedPeriod = 0; volatile TickType_t lastPeriodIdleValue = 0; volatile TickType_t minIdleValue = 1 &lt;&lt; periodLen; extern "C" void vApplicationIdleHook( void ) { // Process idle tick counter volatile TickType_t curTick = xTaskGetTickCount(); if(curTick != lastCountedTick) { curIdleTicks++; lastCountedTick = curTick; } // Store idle metrics each ~0.5 seconds (512 ticks) curTick &gt;&gt;= periodLen; if(curTick &gt; lastCountedPeriod) { lastPeriodIdleValue = curIdleTicks; curIdleTicks = 0; lastCountedPeriod = curTick; // Store the max value if(lastPeriodIdleValue &lt; minIdleValue) minIdleValue = lastPeriodIdleValue; } }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A function can be called very often, many times in one system tick (system tick is 1ms). </font><font style="vertical-align: inherit;">Therefore, the first block is responsible for counting ticks (and not calls) in which the hook was called. </font><font style="vertical-align: inherit;">The second block stores a counter every 512 system ticks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU utilization is the ratio of the number of non-idle ticks to the total number of ticks in the measured interval.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculation of values</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCPULoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100.</span></span> - <span class="hljs-number"><span class="hljs-number">100.</span></span> * lastPeriodIdleValue / (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; periodLen); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxCPULoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100.</span></span> - <span class="hljs-number"><span class="hljs-number">100.</span></span> * minIdleValue / (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; periodLen); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, it may not be entirely accurate. </font><font style="vertical-align: inherit;">But in general, to get a certain rough estimate of the system load, it will completely roll. </font><font style="vertical-align: inherit;">I'm going to use these indicators to lower the frequency of the controller to reduce consumption. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, in normal mode, the load was about 12.5% ‚Äã‚Äãand jumps up to 15.5% when the data comes from the GPS and they need to be parsed. </font><font style="vertical-align: inherit;">When the display is off (although the GPS continues to be parsed), the download drops to 0. This is strange. </font><font style="vertical-align: inherit;">Apparently GPS parsing actually takes less than a tick, so every tick after that falls into the idle task. </font><font style="vertical-align: inherit;">The 3% load spike is probably not due to the data parsing itself, but by sending it to another stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although maybe I'm somewhere here just nakosyachil.</font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/39a/a6e/c58/39aa6ec5813957451dd92bedcf1190db.jpg" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indications of current and maximum CPU usage. </font><font style="vertical-align: inherit;">The screen itself will be hidden somewhere in the depths of the settings menu.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Different </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, I have collected individual problems that I solved at different stages of the project. </font><font style="vertical-align: inherit;">Without any particular sequence.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library implementation of sprintf takes as much as 13k. </font><font style="vertical-align: inherit;">I had to write my own implementation. </font><font style="vertical-align: inherit;">I wrote a little classic that implements the Printable interface. </font><font style="vertical-align: inherit;">So you can ‚Äúprint‚Äù numbers with the necessary formatting on the screen and even in Serial. </font><font style="vertical-align: inherit;">It turned out very nice and just a couple of screens of code.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floating point formatter</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Helper class to print float numbers according to specified options class FloatPrinter : public Printable { char buf[8]; // Print numbers no longer than 7 digits including sign and point symbols uint8 pos; // position in the buffer with the first meaningful char public: FloatPrinter(float value, uint8 width, bool leadingZeros = false, bool alwaysPrintSign = false); virtual size_t printTo(Print&amp; p) const; }; FloatPrinter::FloatPrinter(float value, uint8 width, bool leadingZeros, bool alwaysPrintSign) { // reserve a space for sign uint8 minpos = 0; if(alwaysPrintSign || value &lt; 0) minpos++; // absolute value to print, deal with sign later float v = value; if(v &lt; 0) v = 0. - v; // floating point position will depend on the value uint8 precision = 0; if(v &lt; 100) { v *= 10; precision++; } if(v &lt; 100) // doing this twice { v *= 10; precision++; } uint32 iv = v + 0.5; // we will be operating with integers // Filling the buffer starting from the right pos = width; buf[pos] = '\0'; bool onceMore = true; // Print at least one zero before dot while((iv &gt; 0 || onceMore) &amp;&amp; (pos &gt; minpos)) { pos--; onceMore = false; // Fill one digit buf[pos] = iv % 10 + '0'; iv /= 10; // Special case for printing point // Trick used: if precision is 0 here it will become 255 and dot will never be printed (assuming the buffer size is less than 255) if(--precision == 0) { buf[--pos] = '.'; onceMore = true; } } //Print sign if(value &lt; 0) buf[--pos] = '-'; else if (alwaysPrintSign) buf[--pos] = '+'; } size_t FloatPrinter::printTo(Print&amp; p) const { return p.print(buf+pos); }</span></span></code> </pre> </div></div><br></li><li>           . -  ,            IDE   ( Atmel Studio).        <a href="http://cpp.sh/">cpp.sh</a> .       ,         .      ,     ,         . <br><br>     .      ‚Äú‚Äù   -.       . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; typedef unsigned char uint8; typedef unsigned int uint32; // This is some kind of a unit test for float value print helper. Code under the test is injected into a test function below via simple copy/paste from FloatPrinter constructor. // This allows executing the code right at C++-in-browser service (such as http://cpp.sh) // I just did not want to set up a development toolchain, create a project file, deal with external libraries, do a dependency injection into tested class, etc :) void test(const char * expectedValue, float value, uint8 width, bool leadingZeros = false, bool alwaysPrintSign = false) { char buf[9]; uint8 pos; printf("Printing %f... ", value); //////////////////////////////////////////////////////// // Begin copy from FloatPrinter //////////////////////////////////////////////////////// &lt;Place Function Body Here&gt; //////////////////////////////////////////////////////// // End copy from FloatPrinter //////////////////////////////////////////////////////// if(strcmp(expectedValue, buf+pos) == 0) { printf("%s - PASSED\n", buf+pos); } else { printf("%s - FAILED\n", expectedValue); printf("Got: %s\n", buf+pos); printf("Buffer: "); for(int i=0; i&lt;9; i++) printf("%2x ", buf[i]); printf("\npos=%d\n\n", pos); } } int main() { test("0", 0., 4); test("0.10", 0.1, 4); test("0.23", 0.23, 4); test("4.00", 4., 4); test("5.60", 5.6, 4); test("7.89", 7.89, 4); test("1.23", 1.234, 4); test("56.8", 56.78, 4); test("56.8", 56.78, 5); test("123", 123.4, 4); test("568", 567.8, 5); test("12345", 12345., 6); test("-0.10", -0.1, 5); test("-0.23", -0.23, 5); test("-4.00", -4., 5); test("-5.60", -5.6, 5); test("-7.89", -7.89, 5); test("-1.23", -1.234, 5); test("-56.8", -56.78, 5); test("-56.8", -56.78, 6); test("-123", -123.4, 5); test("-568", -567.8, 6); test("-12345", -12345., 7); }</span></span></span></span></code> </pre> <br></div></div><br></li><li>  Serial.print    ‚Äî     .   USB Serial       . -    . <br><br></li><li>          ,    .  40!    ,  type info,    C++ ABI            . <br><br><div class="spoiler"> <b class="spoiler_title">,   </b> <div class="spoiler_text"><pre> <code class="cpp hljs">GPSDataModel &amp; GPSDataModel::instance() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GPSDataModel inst; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst; }</code> </pre> <br></div></div><br>    ,       ,      extern. <br><br></li><li> .      ,     .    ,      .          ,        .   ,    ,     . <br><br> ,  812   850  732 ,   1622 (   Bodoni MT)   474  408.     ,     . <br><br></li><li>           .     cpp-     .  , ,      .     cpp        9. 9     ! 9 , !       ! <br><br></li><li>   ,   HardwareSerial   attachInterrupt.    , ,  .   NeoSWSerial,     NeoGPS,        UART     . <br><br>       STM32 ‚Äî DMA   . ,          .      sleep()',       ‚Äú      GPS?‚Äù <br><br></li><li>    UX .       ,     .          3   21 . <br><br> ,          .   2 .          .    ,              . <br><br></li><li> GPS.  NeoGPS    .   ‚Äú ‚Äù -&gt; ‚Äú  ‚Äù -&gt; ‚Äú 2D Fix‚Äù -&gt; ‚Äú 3D Fix‚Äù.        GPS ,    .        . <br><br></li><li> GPS.      .   - .       ,  HDOP/VDOP     .         . <br><br></li><li>    .      65000,       -500.             . <br><br></li><li>     .   Time To First Fix &lt; 30 ,  ,   ,    ,    .      .       .  GPS    . <br><br>      ¬´ ¬ª       .    . <br><br></li><li>    .   : +-50,       .      <br><br></li><li>          150/,        7  .       . <br><br></li></ul><br><h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally a few words about the optimization of consumption. </font><font style="vertical-align: inherit;">Yes, the controller is more powerful, but the problems are the same. </font><font style="vertical-align: inherit;">You need to carefully monitor the memory consumption for one careless movement can add a couple of kilos to the firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As expected, the same problems as the AVR got out on the STM32.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Constants that have forgotten to write the word const are still placed in RAM (there will be such constants per half a kilo. Mostly USB descriptors) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 512 bytes adafruit pictures, which is loaded into the display buffer and never shown. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functions for working with SPI, although nothing on SPI is connected to me - 512 bytes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any NeoGPS stuff is a leap year calculation and so on. </font><font style="vertical-align: inherit;">Someone indirectly uses - 300 bytes</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TwoWire class (I2C manual implementation). </font><font style="vertical-align: inherit;">This is definitely not used, but the linker still sniffs it ‚Äî 650 bytes.</font></font></li><li>     .   ,   -    .  Did not touch yet. </li></ul><br>  The list is far from complete.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems that if some object (the same TwoWire) is declared in the header, then the linker attracts it to the project, regardless of whether it is actually used or not. Perhaps this can be adjusted by the settings of the linker, but the Arduino build system does not allow to configure anything. In the end, I just commented out the TwoWire class in the Wire library and everything compiled without problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SPI code is a bit more complicated. The fact is that the creators of the Adafruit_SSD1306 library </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not know anything about C ++ interfaces</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wrote code for both SPI and I2C. And the choice of the necessary happens in. Therefore, the compiler has nothing left but to stick both implementations into the code. Solved a little more intelligent commenting code in the library.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything else on the little things. </font><font style="vertical-align: inherit;">Where I could - patch the library, put const where needed. </font><font style="vertical-align: inherit;">But mostly left everything as is. </font><font style="vertical-align: inherit;">At the moment, 55kb flash is occupied, of which my code is slightly less than 7k - the rest of the library. </font><font style="vertical-align: inherit;">Here's a little more detail, if anyone is interested</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory consumption by section</font></font></b> <div class="spoiler_text"><table><tbody><tr><td>  <b>Name</b> </td><td> <b>Size</b> </td></tr><tr><td> <b>.text section (Code in ROM)</b> </td><td></td></tr><tr><td> System stuff </td><td>  320 </td></tr><tr><td> My code </td><td>  212 </td></tr><tr><td> NeoGPS </td><td> 4056 </td></tr><tr><td> Adafruit SSD1306 </td><td> 3108 </td></tr><tr><td>  FreeRTOS </td><td> 3452 </td></tr><tr><td> Arduino: Wire Library (I2C) </td><td> 296 </td></tr><tr><td> My Code </td><td> 6744 </td></tr><tr><td> Board init / system stuff </td><td>  788 </td></tr><tr><td> libmaple </td><td> 3778 </td></tr><tr><td> Arduino (HardwareSerial, Print) </td><td>  1978 </td></tr><tr><td> libmaple </td><td>  280 </td></tr><tr><td> libmaple USB CDC </td><td> 2216 </td></tr><tr><td> libmaple USB CoreLib </td><td> 2388 </td></tr><tr><td> math </td><td> 12556 </td></tr><tr><td> libc (malloc/free, memcpy, strcmp) </td><td> 3456 </td></tr><tr><td> <b>Total:</b> </td><td> <b>45628</b> </td></tr><tr><td></td><td></td></tr><tr><td> <b>.data section (RAM)</b> </td><td></td></tr><tr><td> libmaple constants &amp; tables </td><td>  820 </td></tr><tr><td> USB stuff &amp; descriptors (after cleanup) </td><td>  84 </td></tr><tr><td> Impure data (WTF? Used in FreeRTOS) </td><td>  1068 </td></tr><tr><td> malloc stuff </td><td>  1044 </td></tr><tr><td> <b>Total:</b> </td><td> <b>3016</b> </td></tr><tr><td></td><td></td></tr><tr><td> <b>.rodata section (constants in ROM)</b> </td><td></td></tr><tr><td> NeoGPS constants </td><td>  140 </td></tr><tr><td> Adafruit_SSD1306 constants </td><td>  76 </td></tr><tr><td> default font </td><td> 1280 </td></tr><tr><td> vtables </td><td>  120 </td></tr><tr><td> Monospace8x12 font </td><td>  1512 </td></tr><tr><td> vtables </td><td>  42 </td></tr><tr><td> My classes data + vtables </td><td> 886 </td></tr><tr><td> TimeFont </td><td>  528 </td></tr><tr><td> My classes data + vtables </td><td>  168 </td></tr><tr><td> Arduino + libmaple stuff </td><td>  792 </td></tr><tr><td> USB descriptors </td><td>  260 </td></tr><tr><td> Math constants </td><td>  552 </td></tr><tr><td> <b>Total:</b> </td><td> <b>6356</b> </td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td> <b>.bss section (Zeroed variables in RAM)</b> </td><td></td></tr><tr><td> stuff </td><td>  28 </td></tr><tr><td> display buffer </td><td>  512 </td></tr><tr><td> Heap </td><td>  8288 </td></tr><tr><td>  FreeRTOS </td><td>  192 </td></tr><tr><td> My data </td><td>  868 </td></tr><tr><td> libmaple + arduino </td><td>  168 </td></tr><tr><td>  usb </td><td>  548 </td></tr><tr><td> malloc stuff </td><td>  56 </td></tr><tr><td>  usb </td><td>  60 </td></tr><tr><td> <b>Total</b> : </td><td> <b>10720</b> </td></tr></tbody></table><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumption of RAM by my classes and variables</font></font></b> <div class="spoiler_text"><table><tbody><tr><td> <b>name</b> </td><td> <b>Size</b> </td></tr><tr><td> CurrentPositionScreen::drawScreen() const::longtitudeString </td><td>  17 </td></tr><tr><td> CurrentPositionScreen::drawScreen() const::latitudeString </td><td>  nineteen </td></tr><tr><td> timeZoneScreen </td><td>  12 </td></tr><tr><td> odometer1 </td><td>  52 </td></tr><tr><td> odometer0 </td><td>  52 </td></tr><tr><td> gpsDataModel </td><td>  192 </td></tr><tr><td> odometer2 </td><td>  52 </td></tr><tr><td> gpsParser </td><td> 292 </td></tr><tr><td> lastPeriodIdleValue </td><td>  four </td></tr><tr><td> curIdleTicks </td><td>  four </td></tr><tr><td> lastCountedTick </td><td>  four </td></tr><tr><td> lastCountedPeriod </td><td>  four </td></tr><tr><td> debugScreen </td><td>  12 </td></tr><tr><td> speedScreen </td><td>  12 </td></tr><tr><td> positionScreen </td><td>  eight </td></tr><tr><td> timeScreen </td><td>  12 </td></tr><tr><td> screenStack </td><td>  20 </td></tr><tr><td> rootSettingsScreen </td><td>  eight </td></tr><tr><td>  display </td><td>  40 </td></tr><tr><td> satellitesScreen </td><td>  12 </td></tr><tr><td> screenIdx </td><td>  four </td></tr><tr><td> odometerScreen </td><td>  24 </td></tr><tr><td> altitudeScreen </td><td>  eight </td></tr></tbody></table><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that the generated code itself is quite compact (albeit more sweeping than on the AVR). I do not know the ARM assembler, but it looks like this. The optimizer, by the way, is not as famously mixing the code as in the case of AVR. All functions are grouped by their original location - this makes reading much easier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But libc library functions occupy indecently a lot. I already wrote about 12k on sprintf. That's not all. Functions such as strcmp or memset occupy several screens of assembler code. I would like to see what they are doing there. I even downloaded the source code of newlib, where these functions are implemented. But there in the assembler and written. With a minimum of comments. So it did not become clearer. It would be possible to rewrite independently, but, in my opinion, to rewrite such pieces is sacrilege.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of all, of course, are trigonometric functions and floating-point math. </font><font style="vertical-align: inherit;">But if you consider that all sorts of calculations this is the essence of the device, you will have to accept. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only major and incomprehensible part for me is malloc / free. </font><font style="vertical-align: inherit;">I obviously don't use it in my code. </font><font style="vertical-align: inherit;">FreeRTOS has its own implementation. </font><font style="vertical-align: inherit;">Where it climbs is unclear. </font><font style="vertical-align: inherit;">I did not find calls. </font><font style="vertical-align: inherit;">I tried to roll back to the very first commit when I sped up my project on STM32 - this code was already in the firmware.</font></font> I will say more.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If in the empty project to connect Adafruit_GFX there will already be malloc. </font><font style="vertical-align: inherit;">The library is hardly to blame here - I connected a completely innocent heading with taypdefami. </font><font style="vertical-align: inherit;">Most likely these are some kind of building system jambs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, everything looks pretty decent.</font></font><br><br><h2>  Afterword </h2><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I put a bottle to someone who has read the student bike up to this point.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The project is slowly but surely moving towards the goal. In this part, I moved to a more powerful ARM / STM32 platform and, honestly, I liked it damn well. There are still a lot of misunderstandings about how everything works, the datasheet has been read by 20 percent. But this does not prevent us from moving further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another major step I took was moving to FreeRTOS. The code has become much simpler and more structured. And most importantly it is easy to expand further. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, I connected the GPS receiver. With the help of the NeoGPS library, I was able to get all the necessary data and display it on the appropriate screens. It was necessary, however, to tinker with the invention of the internal data model.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I have rested in problems with the build system arduino. She is good for small projects, but she presses me literally from all sides. The system is practically not configured and many things happen without my knowledge. In addition, I have a lot of questions from the configuration management: how to version the changes in the libraries? How to decompose your source in directories, so that it is convenient? How to upload it to the repository so that allies can work with it? In general, this will be the first priority in further work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It just feels like my chuik, that changing the build of the system will entail other things. Most likely, you will have to move from Atmel Studio to CooCox or another IDE. Perhaps the compiler will change. You may have to give up the Arduino framework. While it is difficult to say that it will pull.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, and then there will be an SD card connection, power management, USB Mass Storage Device and many other interesting things. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If someone liked - invite to join the project. </font><font style="vertical-align: inherit;">I will also be happy for constructive comments - they really help me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://github.com/grafalex82/GPSLogger"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Page on gitkhab</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/370337/">https://habr.com/ru/post/370337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../370321/index.html">Evolution is an opportunist</a></li>
<li><a href="../370323/index.html">Overview of the two-chamber smartphone ASUS ZenFone 3 Zoom</a></li>
<li><a href="../370329/index.html">Female space landing in Australia?</a></li>
<li><a href="../370331/index.html">Westinghouse Electric Company filed for bankruptcy</a></li>
<li><a href="../370333/index.html">What if a designer learns to program</a></li>
<li><a href="../370339/index.html">The most discussed, interesting and unusual on MIPS / Securika 2017</a></li>
<li><a href="../370341/index.html">Blizzard sued the manufacturer of cheats and hacks for their games $ 8.5 million</a></li>
<li><a href="../370343/index.html">The launch of the module "Science" to the ISS may cancel due to problems</a></li>
<li><a href="../370345/index.html">Scientists to explore West Nile virus carrier genome with IBM Power Systems</a></li>
<li><a href="../370347/index.html">Invisible radiation of the universe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>