<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Statically safe dynamic typing √† la Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. 


 The other day in one of my hobby project, the task arose of writing a repository of metrics. 


 The task itself is solved very simply, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Statically safe dynamic typing √† la Python</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr. </p><br><p>  The other day in one of my hobby project, the task arose of writing a repository of metrics. </p><br><p>  The task itself is solved very simply, but my problem with Haskel (especially in projects for my own entertainment) is that it is impossible to simply take and solve the problem.  It is necessary to decide, expand, abstract, abstract and then further expand.  Therefore, I wanted to make the storage of metrics extensible so as not to specify in advance what they will be there.  In itself, this is a topic for a separate article, and today we will look at one small ingredient: writing a type-safe wrapper for unknown types in advance.  Something like dynamic typing, but with static guarantees that we won‚Äôt do nonsense. </p><br><p>  The article, I think, will not reveal anything new for experienced Haskelists, but now at least we will put this ingredient right away and will not be distracted by it in subsequent articles.  Well, or you can not be so modest and say that I have already invented a whole design pattern. </p><a name="habracut"></a><br><p>  So, first we formulate the problem.  We need to be able to associate any objects with values ‚Äã‚Äãof previously unknown types.  Or, in other words, it is necessary that the values ‚Äã‚Äãof previously unknown types act as keys in some map. </p><br><p> Naturally, we are not mad and we will not demand the support of values ‚Äã‚Äãof absolutely any type.  We require that the type (even if unknown) support comparison in the sense of ordering.  In terms of Haskel, this means that we support such types <code>a</code> , which implement the <code>Ord a</code> class. </p><br><p>  Note that we could demand support for taking a hash and checking for equality, but for several reasons, it will be more convenient and clearer to limit ourselves to comparison. </p><br><p>  When it comes to storing values ‚Äã‚Äãabout which it is known that they implement a certain time class, existential types are usually used in Haskel: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  So, if we are given an object of type <code>SomeOrd</code> and we did pattern matching on it: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  then at point <code>(1)</code> we don‚Äôt know what type <code>val</code> has, but we know (and, most importantly, the type checker also knows) that <code>val</code> implements the <code>Ord</code> class. </p><br><p>  However, if the function of the type class implies two (or more) arguments, then there is little use for such a record: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  To use the <code>Ord</code> methods, it is necessary that both <code>val</code> and <code>val2</code> the same type, but this is absolutely not necessary!  So, our <code>SomeOrd</code> useless.  What to do? </p><br><p>  In spite of the fact that Haskel is a compiled language with aggressive type erasure (after compilation there are generally none), the compiler can still generate type runtime if asked for it.  The role of the representative of type <code>a</code> is the value of type <code>TypeRep a</code> , and <del>  a request </del>  The typeable responds to the <code>Typeable</code> . </p><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text"><p>  By the way, <code>a</code> does not have to be a type in the usual sense, that is, belong to a grade <code>*</code> .  It can be any other sort of <code>k</code> , which theoretically allows you to do some cool things with storing rantaym representatives of jammed types and similar nonsense, but I have not yet figured out what it was. </p></div></div><br><p>  In addition, if we have two different instances of <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , then we can compare them and check whether they represent the same type or not.  Moreover, if they actually represent the same type, then, obviously, <code>a</code> coincides with <code>b</code> .  And, most importantly, the function of checking the representations of types for equality returns a result that can convince the type taker of this: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  What kind of nonsense is this? </p><br><p>  First, <code>eqTypeRep</code> is a function. </p><br><p>  Secondly, it is polymorphic, but not only by type, but also by the varieties of these types.  This is indicated by the part <code>forall k1 k2 (a :: k1) (b :: k2)</code> - this means that <code>a</code> and <code>b</code> can be not only ordinary types like <code>Int</code> or <code>[String]</code> , but also, for example, zapromouchennymi designers (see DataKinds and other attempts to make Haskel seized).  But we do not need all this. </p><br><p>  Third, it takes two runtime views of potentially different types, <code>TypeRep a</code> and <code>TypeRep b</code> . </p><br><p>  Fourth, it returns a value of type <code>Maybe (a :~~: b)</code> .  Here is the most interesting. </p><br><p>  If the types do not match, then the function returns a normal <code>Nothing</code> , and everything is in order.  If the types are the same, the function returns <code>Just val</code> , where <code>val</code> is of the type <code>a :~~: b</code> .  Let's see what this type is: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Now let's reason.  Suppose we get a <code>val</code> value of type <code>a :~~: b</code> .  How could it be built?  The only way is with the help of the <code>HRefl</code> constructor, and this constructor requires that on both sides of the icon <code>:~~:</code> stand for the same thing.  Therefore, <code>a</code> coincides with <code>b</code> .  Moreover, if we zapattern match on <code>val</code> , then the tick checker will also know about it.  Therefore, yes, the <code>eqTypeRep</code> function returns proof that two potentially different types are the same if they are actually equal. </p><br><p>  However, in the paragraph above, I lied.  No one bothers us <em>to</em> write something like </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  or </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  or break the system in a bunch of slightly less obvious ways.  This is one of the manifestations of the well-known in narrow circles of the statement that Haskel is inconsistent as logic.  In languages ‚Äã‚Äãwith stronger type systems, such definitions are not invoked. </p><br><p>  That is why in the piece of documentation cited just above, the <em>terminating value is</em> mentioned.  Both variants of the implementation of <code>wrong</code> above do not produce this same terminating value, which returns us a bit of reason and confidence: if our program has <em>finished</em> on Haskell (and did not encounter <code>undefined</code> ), then its result corresponds to the written types.  Here, however, there are some details related to laziness, but we will not open this topic. </p><br><p>  And, by the way, the second manifestation of the weakness of Haskel in the code above is the type of the function <code>eqTypeRep</code> .  In stronger languages, it would return a value of a stronger type, which would not only prove the equality of types, if they are in fact equal, but also give evidence of their <em>inequality</em> , if they are in fact unequal.  The inconsistency of Haskel logic, however, makes such functions a bit meaningless: it is all important when you use the language as a prover theorem, and not as a programming language, but haskel as a prover is not particularly used. </p><br><p>  Well, okay, enough of the matrix and type theory, back to our metrics. <del>  Now just draw an owl. </del>  The discussion above hints that it is enough to keep in our existential type also this most runtime representation of the type, and everything will be fine. </p><br><p>  This leads us to the next implementation of our wrapper type: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Now we write a function that accepts the following: </p><br><ol><li>  two values ‚Äã‚Äãof type <code>Dyn</code> ; </li><li>  a function that produces something for two values ‚Äã‚Äãof <em>any type</em> , <br>  based only on the constraints mentioned when creating <code>Dyn</code> ( <code>forall</code> is responsible for this), <br>  and which is called if both <code>Dyn</code> store values ‚Äã‚Äãof the same type; </li><li>  and the fallback function, which is called instead of the previous one, if the types are different: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> is an existential wrapper over <code>TypeRep a</code> for any <code>a</code> . </p><br><p>  Now we can implement, for example, a test for equality and comparison: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Here we used the fact that <code>SomeTypeRep</code> can be compared with each other, so the fallback function for ordering is also <code>compare</code> . </p><br><p>  Is done. </p><br><p>  Only now it‚Äôs a sin not to generalize: note that inside <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> we don‚Äôt use <code>Ord</code> specifically, and it could be any other set of constraints, so we can enable the <code>ConstraintKinds</code> extension and <em>generalize</em> by parameterizing <code>Dyn</code> specific set of constraints that needed in our particular task: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Then <code>Dyn Ord</code> will be our desired type, and, say, <code>Dyn Monoid</code> will allow you to store arbitrary monoids and do something monoidal with them. </p><br><p>  Let's write the instances we need for our new <code>Dyn</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... only it does not work.  Typchecker doesn't know that <code>Dyn Ord</code> also implements <code>Eq</code> , <br>  so you have to copy the entire hierarchy: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Well, now everything is exactly. </p><br><p>  ... unless, in modern haskel it is possible to make so that taypcheker himself would display instances of a type </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  for there comes out something prologonlike, but I haven‚Äôt done it yet, I‚Äôll have to sit around.  Stay tuned. </p><br><p>  And also, if you carefully squint, you will notice that our <code>Dyn</code> suspiciously similar to a dependent pair of the form <code>(ty : Type ** val : ty)</code> from over-the-top languages.  But only in languages ‚Äã‚Äãknown to me it is impossible to match the type, for parametricity (which in this case, IMHO, is interpreted too widely), and here it seems that it is possible. </p><br><p>  But the most important thing is that now you can safely have something like <code>Map (Dyn Ord) SomeValue</code> and use any values ‚Äã‚Äãas keys, as long as they support the comparison.  For example, identifiers with the description of metrics can be used as keys, but this is a topic for the next article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457930/">https://habr.com/ru/post/457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45792/index.html">Consumers low cost sites ... who are they?</a></li>
<li><a href="../457920/index.html">Jet World: open free access to Joker 2018 conference reports + review of the top ten</a></li>
<li><a href="../457926/index.html">Comparing Agile Certification Part 1 - ICAgile, Scrum.org, ScrumAlliance and PMI</a></li>
<li><a href="../457928/index.html">Deep ranking for comparing two images</a></li>
<li><a href="../45793/index.html">A collection of nonsense about my country</a></li>
<li><a href="../457932/index.html">Reviewing the IDS Bypass Competition at Positive Hack Days 9</a></li>
<li><a href="../457936/index.html">We invite you to the first Zabbix conference in Russia</a></li>
<li><a href="../45794/index.html">ExtJS extensions for the Adobe AIR platform</a></li>
<li><a href="../457940/index.html">How to peek into the counterparty</a></li>
<li><a href="../457942/index.html">What I learned about optimization in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>