<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we hunted for two weeks on the NFS bug in the Linux kernel</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Detailed description of the bug search from the GitLab task that led to the patch for the Linux kernel 


 On September 14, the GitLab support service...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we hunted for two weeks on the NFS bug in the Linux kernel</h1><div class="post__text post__text-html js-mediator-article"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Detailed description of the bug search from the GitLab task that led to the patch for the Linux kernel </h3><br><p> On September 14, the GitLab support service reported a critical problem that occurred to one of our clients: first, GitLab works fine, and then the users get an error.  They tried to clone some repositories via Git, and suddenly there was an incomprehensible message about an obsolete file: <code>Stale file error</code> .  The error persisted for a long time and did not allow to work until the system administrator manually started <code>ls</code> in the directory itself. </p><br><p>  I had to study the internal mechanisms of Git and the NFS network file system.  As a result, we found a bug in the Linux v4.0 NFS client, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/%3Fh%3Dbe189f7e7f03de35887e5a85ddcf39b91b5d7fc1">Trond Myklebust wrote a patch for the kernel</a> , and since October 26 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/%3Fh%3Dc7a2c49ea6c9eebbe44ff2c08b663b2905ee2c13">this patch is included in the main Linux kernel</a> . </p><br><p>  In this post I will tell you how we studied the problem, in which direction we thought and what tools we used to track the bug.  We were inspired by the excellent detective work of Oleg Dashevsky, described in the post <a href="http://www.be9.io/2015/09/21/memory-leak/">‚ÄúHow I have been hunting for a memory leak in Ruby for two weeks‚Äù</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  This is also a great example of that debugging open source software is a team sport in which many people, companies and countries participate.  The GitLab motto ‚Äú <a href="https://about.gitlab.com/company/strategy/">Everyone can contribute</a> ‚Äù is valid not only for GitLab itself, but also for other open source projects, for example, for the Linux kernel. </p><br><h3 id="vosproizvedenie-baga">  Replay bug </h3><br><p>  We kept NFS on GitLab.com for many years, but then we stopped using it to access repository data on machines with applications.  <a href="https://about.gitlab.com/2018/09/12/the-road-to-gitaly-1-0/">We moved all the Git calls to Gitaly</a> .  We support NFS for clients who manage their installations on GitLab, but have never encountered a problem like that of the above client. </p><br><p>  <a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/51437">The client gave some helpful hints</a> : </p><br><ol><li>  Full text of the error: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Apparently, the problem arose when the client manually started garbage collection in Git with the <code>git gc</code> command. </li><li>  The error disappeared when the system administrator ran the <code>ls</code> utility in a directory. </li><li>  The error disappeared when the <code>git gc</code> process terminated. </li></ol><br><p>  It is clear that the first two points are related.  When you send changes to a Git branch, Git creates a weak link ‚Äî a long file name that indicates the name of the branch for a commit.  For example, when sending to <code>master</code> , a file will be created with the name <code>refs/heads/master</code> in the repository: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  The <code>git gc</code> command performs several tasks.  For example, it collects these weak links (refs) and packs them into a single file called <code>packed-refs</code> .  This speeds up the work a bit, because reading one large file is easier than many small ones.  For example, after running the <code>git gc</code> command, the <code>packed-refs</code> file might look something like this: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  How is the file <code>packed-refs</code> ?  To find out, we ran the command <code>strace git gc</code> where we had a weak link.  Here are the lines that are relevant: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  System calls have shown that the <code>git gc</code> command: </p><br><ol><li>  Opened the <code>packed-refs.lock</code> .  This tells other processes that the <code>packed-refs</code> file is locked and cannot change. </li><li>  <code>packed-refs.new</code> opened <code>packed-refs.new</code> . </li><li>  Recorded weak links in <code>packed-refs.new</code> . </li><li>  Renamed <code>packed-refs.new</code> to <code>packed-refs</code> . </li><li>  Removed <code>packed-refs.lock</code> . </li><li>  Removed weak links. </li></ol><br><p>  The key point here is the fourth, that is, the renaming, where Git enters the file <code>packed-refs</code> .  <code>git gc</code> not only collects weak links, but also performs a much more resource-intensive task - it searches for and removes unused objects.  In large repositories this can take more than an hour. </p><br><p>  And we asked ourselves: does the large gos repository keep the <code>git gc</code> file open during the cleanup?  We studied the <code>strace</code> logs, launched the <code>lsof</code> utility, and here is what we learned about the <code>git gc</code> process: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="image"></p><br><p>  As you can see, the file <code>packed-refs</code> closes at the very end, after the potentially long process of <code>Garbage collect objects</code> . </p><br><p>  So the following question arose: how does NFS behave when the <code>packed-refs</code> file is opened on one node and the other renames it at this time? </p><br><p>  "For scientific purposes" we asked the client to conduct one experiment on two different machines (Alice and Bob): <br>  1) In an NFS shared volume, create two files: <code>test1.txt</code> and <code>test2.txt</code> with different contents, to make them easier to distinguish: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) On the Alice machine, the <code>test1.txt</code> file must be open: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) On Alice's machine, continuously display the contents of <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) Then, on the Bob machine, execute the command: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  The last step reproduces what <code>git gc</code> does with the <code>packed-refs</code> file when overwriting an existing file. <br>  By client machine, the result looked like this: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  There is!  It seems we controlled the problem in a controlled way.  But in the same experiment on a Linux NFS server, this problem did not arise.  The result was expected - after renaming, new content was accepted: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  Where does this difference in behavior come from?  It turns out that the client used the <a href="https://www.dellemc.com/en-us/storage/isilon/index.htm">Isilon NFS</a> storage, which only supported NFS v4.0.  When we changed the connection parameters to v4.0 using the <code>vers=4.0</code> parameter in <code>/etc/fstab</code> , the test showed a different result for the Linux NFS server: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  Instead of the outdated <code>Stale file handle</code> Linux NFS v4.0 server showed obsolete <em>content</em> .  It turns out that the difference in behavior can be explained by the NFS specifications.  From <a href="https://tools.ietf.org/html/rfc3010">RFC 3010</a> : </p><br><blockquote>  A file descriptor may become obsolete or expire when renamed, but not always.  Server implementers are advised to take steps so that file descriptors are not outdated and do not expire in this way. </blockquote><p>  In other words, NFS servers can choose how to behave when the file is renamed, and the NFS server rightly returns a <code>Stale file error</code> in such cases.  We assumed that the cause of the problem was the same, although the results were different.  We suspected that it was a cache check, because the <code>ls</code> utility in the directory cleared the error.  Now we had a reproducible test script, and we turned to the experts - Linux NFS maintainers. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  False trail: delegation to the NFS server </h2><br><p>  When we managed to reproduce the error step by step, I <a href="https://marc.info/%3Fl%3Dlinux-nfs%26m%3D153721785231614%26w%3D2">wrote to the Linux NFS contacts</a> about what we learned.  For a week, I corresponded with Bruce Fields, the Linux Maintainer of the NFS server, and he suggested that the bug in NFS should be examined for network traffic.  He thought the problem was delegating tasks to the NFS server. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  What is delegation to the NFS server? </h3><br><p>  In a nutshell, the NFS v4 version introduced a delegation function to speed up file access.  The server can delegate read or write access to the client so that the client does not have to constantly ask the server whether the file has been changed by another client.  Simply put, delegation of a record is how to lend your notebook to someone and say: ‚ÄúYou are still writing here, and I will take it when I'm ready.‚Äù  And a person will not have to ask for a notebook every time they need to write something down - he has complete freedom of action, until the notebook is taken away.  In NFS, please return the notebook is called a revocation of delegation. </p><br><p>  A bug in the NFS delegation recall could explain the problem of the <code>Stale file handle</code> .  Remember how in our experiment Alice opened <code>test1.txt</code> , and then replaced it with <code>test2.txt</code> .  Maybe the server failed to revoke the delegation for <code>test1.txt</code> , and this led to an invalid status.  To test this theory, we recorded the NFC traffic with the <code>tcpdump</code> utility and visualized it with Wireshark. </p><br><p>  <a href="https://www.wireshark.org/">Wireshark</a> is a great open source tool for analyzing network traffic, especially for exploring NFS in action.  We recorded the trace using the following command on the NFS server: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  This command records all NFS traffic that usually passes through TCP port 2049. Since our experiment was successful with NFS v4.1, but not with NFS v4.0, we could compare the behavior of NFS in the working and non-working cases.  With Wireshark, we saw the following behavior: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (obsolete file) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="image"></p><br><p>  In this diagram, you can see that in step 1, Alice opens <code>test1.txt</code> and obtains an NFS file descriptor with the identifier <code>stateid</code> 0x3000.  When Bob tries to rename the file, the NFS server asks to try again by sending the <code>NFS4ERR_DELAY</code> message, and he himself withdraws the delegation from Alice via the <code>CB_RECALL</code> message (step 3).  Alice returns the delegation (DELEGRETURN in step 4), and Bob tries to send the message <code>RENAME</code> again (step 5).  <code>RENAME</code> is executed in both cases, but Alice continues to read the file using the same descriptor. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (working case) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="image"></p><br><p>  Here the difference is visible in step 6. In NFS v4.0 (with an obsolete file), Alice tries to use the same <code>stateid</code> .  In NFS v4.1 (working case), Alice performs additional <code>LOOKUP</code> and <code>OPEN</code> operations, so the server returns a different <code>stateid</code> .  In v4.0, it does not send any additional messages.  This explains why Alice sees obsolete content ‚Äî she uses the old descriptor. </p><br><p>  Why does Alice suddenly decide on an additional <code>LOOKUP</code> ?  Apparently, the delegation recall was a success, but some problem apparently remained.  For example, the invalidation step is missed.  To check this, we excluded the NFS delegation on the NFS server itself with this command: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  We repeated the experiment, but the problem did not disappear.  We made sure that the problem is not in the NFS server or delegation, and decided to look at the NFS client in the kernel. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Digging deeper: Linux NFS client </h2><br><p>  The first question we had to answer to the NFS maintainers was: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  Does this problem persist in the latest kernel version? </h3><br><p>  The problem occurred in CentOS 7.2 and Ubuntu 16.04 kernels with versions 3.10.0-862.11.6 and 4.4.0-130, respectively.  But both cores lagged behind the latest version, which at that time was 4.19-rc2. </p><br><p>  We deployed a new Ubuntu 16.04 virtual machine on the Google Cloud Platform (GCP), cloned the latest Linux kernel, and set up a kernel development environment.  We created a <code>.config</code> file using <code>menuconfig</code> and checked that: </p><br><ol><li>  The NFS driver is compiled as a module ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://cloud.google.com/compute/docs/images/building-custom-os">The required GCP core parameters</a> are correct. </li></ol><br><p>  Genetics track the evolution in real time of fruit flies, and using the first item, we could quickly make changes to the NFS client without restarting the kernel.  The second point guaranteed that the kernel would start after installation.  Fortunately, we were satisfied with the default kernel parameters. </p><br><p>  We made sure that the problem of the obsolete file has not disappeared in the latest version of the kernel.  We asked ourselves: </p><br><ol><li>  Where exactly is the problem? </li><li>  Why does this happen in NFS v4.0, but not in v4.1? </li></ol><br><p>  To answer these questions, we delved into the NFS source code.  We did not have a kernel debugger, so we sent two types of calls to the source code: </p><br><ol><li>  <code>pr_info()</code> ( <a href="https://lwn.net/Articles/487437/"><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : it shows the stack trace for the current function call. </li></ol><br><p>  For example, first of all, we connected to the <code>nfs4_file_open()</code> function in <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Of course, we could <a href="https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html"><code>  dprintk</code> with dynamic Linux debugging</a> or use <a href="https://www.thegeekdiary.com/how-to-enable-nfs-debug-logging-using-rpcdebug/"><code>rpcdebug</code></a> , but we wanted to add our own messages to check for changes. </p><br><p>  After each change, we recompiled the module and reinstalled it into the kernel using the commands: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  With the NFS module, we could repeat the experiments and receive messages to understand the NFS code.  For example, you can immediately see what happens when an application calls <code>open()</code> : </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  What are the <code>do_dentry_open</code> and <code>vfs_open</code> ?  Linux has a virtual filesystem ( <a href="https://www.kernel.org/doc/Documentation/filesystems/vfs.txt">virtual filesystem, VFS</a> ), an abstraction layer that provides a common interface for all file systems.  The VFS documentation states: </p><br><blockquote>  VFS implements open (2), stat (2), chmod (2) and other system calls.  VFS uses the pathname argument passed to them to search the directory entry cache (dentry cache, or dcache).  This provides a very fast search mechanism that converts the path name (or file name) to a specific dentry.  Dentry are in RAM and never stored on disk - they exist only for performance. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  And it dawned on us - what if the problem is in the dentry cache? </h3><br><p>  We noticed that the dentry cache is usually checked in <code>fs/nfs/dir.c</code>  We were especially interested in the <code>nfs4_lookup_revalidate()</code> function, and as an experiment we made it work earlier: </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  And in this experiment, the problem of an obsolete file did not arise!  Finally, we attacked the trail. </p><br><p>  To find out why the problem did not occur in NFS v4.1, we added <code>pr_info()</code> calls to each <code>if</code> block in this function.  We experimented with NFS v4.0 and v4.1 and found a special condition in version v4.1: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  What is <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  This <a href="https://patchwork.kernel.org/patch/2300511/">kernel patch</a> says that this is a feature of the NFS v4.1 version, and the code in <code>fs/nfs/nfs4proc.c</code> confirmed that this parameter is in v4.1, but is missing in v4.0: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Therefore, the versions behaved differently - in v4.1 <code>goto no_open</code> causes more checks in the <code>nfs_lookup_revalidate()</code> function, and in v4.0 the function <code>nfs4_lookup_revalidate()</code> returns earlier.  And how did we finally solve the problem? </p><br><h2 id="reshenie">  Decision </h2><br><p>  I talked about our <a href="https://marc.info/%3Fl%3Dlinux-nfs%26m%3D153782129412452%26w%3D2">findings on the NFS mailing list</a> and suggested a <a href="https://marc.info/%3Fl%3Dlinux-nfs%26m%3D153807208928650%26w%3D2">primitive patch</a> .  A week later, Trond Myklebust <a href="https://marc.info/%3Fl%3Dlinux-nfs%26m%3D153816500525563%26w%3D2">sent a series of patches to fix the bug and found another related problem in NFS v4.1</a> . </p><br><p>  It turns out that the fix for the NFS v4.0 bug was deeper in the code base than we thought.  Trond described it well in the <a href="https://marc.info/%3Fl%3Dlinux-nfs%26m%3D153816500525564%26w%3D2">patch</a> : </p><br><blockquote>  It is necessary to make inode and dentry correctly rechecked when an already opened file is opened.  Now we do not recheck either one or the other in NFSv4.0, because the open file is cached.  Let's fix this and we will cache open files only in special cases - to restore open files and return delegations. </blockquote><p>  We made sure that this fix solved the obsolete file problem, and sent bug reports to the <a href="https://bugs.launchpad.net/ubuntu/%2Bsource/linux/%2Bbug/1802585">Ubuntu</a> and <a href="https://bugzilla.redhat.com/show_bug.cgi%3Fid%3D1648482">RedHat</a> teams. </p><br><p>  We were well aware that the changes would not be in a stable version of the kernel soon, so we added a <a href="https://gitlab.com/gitlab-org/gitaly/merge_requests/924">temporary solution to this problem in Gitaly</a> .  We experimented and verified that calling <code>stat()</code> in the <code>packed-refs</code> file causes the kernel to recheck the renamed file in the dentry cache.  For simplicity, we implemented this in Gitaly for any file systems, not just NFS.  The check is performed only once before Gitaly opens the repository, and for other files there are already other <code>stat()</code> calls. </p><br><h2 id="chemu-my-nauchilis">  What we have learned </h2><br><p>  A bug can hide in any corner of the software stack, and sometimes you need to look for it outside the application.  If you have useful links in the open source world, it will ease your work. </p><br><p>  Many thanks to Trond M√ºklebust for correcting the problem, and to Bruce Fields for answering our questions and helping to figure out NFS.  It is for such responsiveness and professionalism that we value the open source community. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432922/">https://habr.com/ru/post/432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432910/index.html">It is dangerous to consider virtual reality as an empathy machine.</a></li>
<li><a href="../432912/index.html">How to get an internship at Google</a></li>
<li><a href="../432914/index.html">Very simple chat bot for Telegram for the little ones</a></li>
<li><a href="../432918/index.html">Sorry, I broke your recovery.conf</a></li>
<li><a href="../432920/index.html">The human factor in the company: is it dangerous?</a></li>
<li><a href="../432924/index.html">Run, Gecko, run: hybrid mechanism of movement on the water at geckos</a></li>
<li><a href="../432926/index.html">24 recipes for a startup to succeed at a huge global exhibition, using the example of Web Summit 2018</a></li>
<li><a href="../432928/index.html">What Intel is doing and why Amazon will not transfer AWS entirely to its chips despite loud headers</a></li>
<li><a href="../432930/index.html">Exploit Wednesday December 2018: for tests of new patches of time to spare - drove ...</a></li>
<li><a href="../432932/index.html">Ecosystem of the digital procurement world (to steal less)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>