<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transaction Isolation Levels with PostgreSQL Examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 The SQL standard describes four transaction isolation levels ‚Äî Read uncommited, Read committed, Repeatable read, and Serializable. Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transaction Isolation Levels with PostgreSQL Examples</h1><div class="post__text post__text-html js-mediator-article"><h2 id="vstuplenie">  Introduction </h2><br><p>  The SQL standard describes four transaction isolation levels ‚Äî Read uncommited, Read committed, Repeatable read, and Serializable.  This article will look at the life cycle of four concurrently running transactions with <strong>Read committed</strong> and <strong>Serializable</strong> isolation levels. </p><br><p>  For the Read committed isolation level, the following special data reading conditions are allowed: </p><br><p>  <em>Non-Repeatable Read</em> ‚Äî A transaction rereads the same data as before and finds that it was modified by another transaction (which ended after the first read). </p><br><p>  <em>Phantom read</em> ‚Äî A transaction re-executes a query that returns a rowset for a condition, and detects that the rowset that satisfies the condition has changed because of a transaction that has completed during this time. </p><br><p>  As for Serializable, this isolation level is the strictest and has no data reading phenomena. </p><a name="habracut"></a><br><h2 id="acid-ili-4-svoystva-tranzakciy">  ACID or 4 transaction properties </h2><br><p>  Before we begin to consider the isolation levels of a transaction in a couple of words, we‚Äôll recall the basic requirements for a transaction system. </p><br><p>  <strong>Atomicity</strong> - is expressed in the fact that the transaction must be completed as a whole or not executed at all. </p><br><p>  <strong>Consistency</strong> - ensures that as transactions are completed, data moves from one consistent state to another, that is, a transaction cannot destroy the mutual consistency of data. </p><br><p>  <strong>Isolation</strong> - localization of user processes means that competing for access to the database transactions are physically processed sequentially, in isolation from each other, but for users it looks as if they are executed in parallel. </p><br><p>  <strong>Durability</strong> - error tolerance - if a transaction is completed successfully, then the changes in the data that it has made cannot be lost under any circumstances. </p><br><h2 id="uroven-izolyacii-read-committed">  Isolation level Read Committed </h2><br><p>  PostgreSQL's default isolation level is Read Committed.  This isolation level always allows you to see the changes made by successfully completed transactions in the remaining open transactions in parallel.  In a transaction running at this level, the SELECT query (without the FOR UPDATE / SHARE clause) sees only the data that was recorded before the query started;  he will never see uncommitted data or changes made during the execution of a query by parallel transactions.  Essentially, a SELECT query sees a snapshot of the database at the time the query starts.  However, SELECT sees the results of changes made earlier in the same transaction, even if they are not yet fixed.  Also note that two consecutive SELECT statements can see different data even within the same transaction if some other transactions commit changes after the first SELECT has been executed. </p><br><p>  The essence of the Read Committed isolation level is shown in diagram 1. </p><br><p>  <em>Note: The table already contains an entry with the first version of the data (v1).</em>  <em>Please take the command SELECT v1;</em>  <em>- as a command that returns data versions v1, and UPDATE v1 to v2;</em>  <em>- as a command to update data from the first version to the second.</em> </p><br><div class="spoiler">  <b class="spoiler_title">We will create 4 connections to the database and open them in each of the transaction connections with the Read Committed isolation level.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/730/c02/1de/730c021dea0e45daa9ed66288886df1a.png" alt="Read Committed"></p></div></div><br><p><img src="https://habrastorage.org/files/92a/d78/ac7/92ad78ac7f6c49eeb386d9bea943e3e6.png" alt="Read Committed"></p><br><div class="spoiler">  <b class="spoiler_title">Step 1. At the initial moment of time before any data changes, the initial version of the data (v1) is available to all transactions;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/304/397/1bd/3043971bd1a1439caa1eabaf89ccfa09.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 2. During the operation of the First transaction, the data without any locks is successfully updated to the ‚Äúsecond version‚Äù (v2);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/711/259/982/71125998260842239feabb15518a9e91.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 3. Changes made in the First transaction will be visible only to itself (SELECT returns v2), and will not be available to other transactions (SELECT query in the Second and Fourth transactions returns v1);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/c59/ea0/7e2/c59ea07e28bf4000b73a1a717c6d3c58.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 4. Closing the First Transaction.</b>  <b class="spoiler_title">All changes made during her work are successfully recorded;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/713/aa1/89c/713aa189ce5c45b59891a6917b107176.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 5. After closing the First transaction (previous step), changes made during its execution over the data (update from v1 to v2) were propagated to the remaining transactions, a SELECT query in the remaining 3 open transactions returns v2 (‚ÄúNonrepeatable reading‚Äù, distinguish the level isolation Read Committed from Serializable);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/e8f/af6/cc2/e8faf6cc26cb4f5dad35a83bbc392ab2.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 6. The request to update the data in the Second transaction to the ‚Äúthird version‚Äù is successfully completed, but the requests to update the data block the rows to be modified to change them further, until the completion of the Second transaction;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/f46/6aa/8c4/f466aa8c455b4c92a46d5d8ab4c42ef8.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 7. Due to the lock imposed on the data in the previous step, the Third transaction goes into standby mode with a request to delete the data.</b>  <b class="spoiler_title">Waiting for the Third Transaction will occur until the closure of the Second Transaction;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/f31/f68/f1c/f31f68f1ca794eb6b43673e073a10057.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 8. In spite of the fact that the Third Transaction is awaiting the closure of the Second, both the Second and Fourth transactions continue their work without any problems, returning data according to their versions.</b>  <b class="spoiler_title">The second returns v3; the fourth returns v2;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/a9a/d06/f68/a9ad06f6808f4d5a9876a958c8099b2e.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 9. Closing the Second Transaction causes the data to be unlocked for modification.</b>  <b class="spoiler_title">The isolation level Read Committed allows you to continue the work of the Third transaction without causing an error.</b>  <b class="spoiler_title">Having access to change a new version of data (v3) The third transaction SUCCESSFULLY immediately ‚Äúdeletes‚Äù them (the difference Read Committed from Serializable);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/762/2ce/267/7622ce26763d4a5198b320f4c4cf54de.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 10. Before closing the Third transaction, the data will be deleted only within the Third transaction.</b>  <b class="spoiler_title">The fourth transaction before closing the third data is available (SELECT query in the fourth transaction returns v3);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/a39/4d2/16a/a394d216a371422e8af5d512d62bf1c2.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 11. Closing the Third Transaction.</b>  <b class="spoiler_title">All changes made during her work are successfully recorded;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/261/101/476/26110147614344aaa3657fe2f26921b6.png" alt="Read Committed"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 12. The request for receiving data in the fourth transaction returns nothing (‚ÄúPhantom read‚Äù, SELECT query returns 0 records).</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/013/868/e2d/013868e2d3084488b64922a431f2231d.png" alt="Read Committed"></p></div></div><br><p>  <em>Note.</em>  <em>The diagram does not show the action of the INSERT query.</em>  <em>Within this isolation level, the rows added, for example in step 3, in the First transaction, would be SEEED to the remaining transactions after the completion of the First transaction.</em> </p><br><p>  Partial transaction isolation, provided in Read Committed mode, is acceptable for many applications.  This mode is quick and easy to use, but it is not suitable for all occasions.  Applications that perform complex queries and changes may require a more strictly consistent presentation of data, such as Serializable. </p><br><h2 id="uroven-izolyacii-serializable">  Isolation level Serializable </h2><br><p>  The isolation level of Serializable provides unhindered access to the database of transactions with SELECT queries.  But for transactions with UPDATE and DELETE requests, the isolation level Serializable does not allow modification of the same row within different transactions.  When isolating such a level, all transactions are processed as if they are all running sequentially (one after another).  If two simultaneous transactions try to update one and the same line, it will not be possible.  In this case, PostgreSQL will force the transaction, the second, and all subsequent ones that tried to change the line to cancel (rollback - ROLLBACK). </p><br><p>  The essence of the Serializable isolation level is shown in diagram 2. </p><br><div class="spoiler">  <b class="spoiler_title">Create 4 connections to the database and open in each of the connections under the transaction with the isolation level Serializable</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/2bd/ee8/06e/2bdee806e4364a30a7a6135165e80e2e.png" alt="Serializable"></p></div></div><br><p><img src="https://habrastorage.org/files/5cc/363/d97/5cc363d97a434cb0bc775cf76969c00c.png" alt="Serializable"></p><br><div class="spoiler">  <b class="spoiler_title">Step 1. The initial version of the data is available to all transactions (v1);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/7a1/13d/859/7a113d8598c14e3fb0eb735bfc9ce091.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 2. During the operation of the First transaction, the data without any locks is successfully updated to the ‚Äúsecond version‚Äù (v2);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/894/285/259/894285259e64434fb8c2cfe5c707ceb4.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 3. Changes made in the First transaction will be visible only to itself (SELECT returns v2), and will not be available to other transactions (SELECT query in the Second and Fourth transactions returns v1);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/63b/74f/682/63b74f6827c14a71ba6ab14524794a37.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 4. A request to update the data in the first transaction (step 2), locks the updated rows, and puts into standby mode the second transaction with the request to delete the data.</b>  <b class="spoiler_title">Blocking transactions on the updated data will occur before the closure of the First transaction;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/ae0/0cb/0f3/ae00cb0f313b44f9af30e672833bdb19.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 5. In spite of the fact that the Second transaction is waiting for the closure of the First, both the Third and Fourth transactions continue their work without any problems, returning data according to their versions;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/e99/fc2/3e4/e99fc23e49aa4426a5e4ae73d89f1f66.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 6. Completion of the First transaction removes blocking from the updated data, but within the limits of the Serializable isolation level, the repeated updating of data in parallel transactions is prohibited, and therefore an error occurs during the execution of the Second transaction (Serializable differs from Read Committed);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/37d/b23/bcb/37db23bcb5894712b1534e210bb477e3.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 7. The SELECT query in the Second transaction becomes impossible, since the error that occurred in the previous step cancels (‚Äúblocks‚Äù) the transaction.</b>  <b class="spoiler_title">The SELECT query in the Third and Fourth transactions returns the initial version of the data (v1).</b>  <b class="spoiler_title">Although the first transaction was completed successfully, the changes were not visible to the rest of the open transactions (the difference between Serializable and Read Committed).</b>  <b class="spoiler_title">Opening of the Fifth transaction in the upper left window;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/7e6/ead/e89/7e6eade899ff406b99a0780c643c0ceb.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 8. Closing the Second Transaction.</b>  <b class="spoiler_title">All changes made by this transaction will be canceled due to an error during its operation;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/1cf/a2b/9c9/1cfa2b9c9c4f49de910909d5598b9049.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 9. A SELECT query in the Fifth transaction returns the new version of the data (v2).</b>  <b class="spoiler_title">The SELECT query in the Third and Fourth transactions returns the initial version of the data (v1);</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/b75/e10/f7e/b75e10f7ec684b7ab53ba627b5b5e2af.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 10. The isolation level of Serializable still does not allow updating the data, the UPDATE request in the Third transaction is not completed successfully, with consequent consequences for the progress of the entire transaction (although the First transaction has already been successfully completed and all changes made to it are saved in the database ).</b>  <b class="spoiler_title">But the UPDATE request in the Fifth transaction is completed successfully, since it is open after the completion of the First transaction, and works with the new version of the data;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/ae5/8c6/977/ae58c697772847eea4cc9b833618cc63.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 11. Closing the Third Transaction.</b>  <b class="spoiler_title">All changes made by this transaction will be canceled due to an error during its operation;</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/65d/273/240/65d273240773421892ecf35bdfe0a842.png" alt="Serializable"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Step 12. Transaction Four also shows that transactions with SELECT queries have no problems, and the Fifth transaction receives the same updated data (v5).</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/33d/92a/051/33d92a051337405c9866f54399b2c97b.png" alt="Serializable"></p></div></div><br><p>  <em>Note.</em>  <em>The diagram does not show the action of the INSERT query.</em>  <em>Within this isolation level, the rows added, for example in step 3, in the First transaction, would be NOT AVAILABLE for the Second, Third and Fourth transactions after the completion of the First transaction.</em>  <em>Also, the diagram does not show the result of ROLLBACK (Steps 8 and 11).</em>  <em>If the Second and Third transactions made any changes to the unlocked data, then all these changes would not be recorded, since the transactions fail (the essence of the property is Atomicity).</em> </p><br><p>  The isolation level of Serializable ensures that all data affected by the transaction will not be altered by other transactions.  At this level, the emergence of "phantoms" is excluded, therefore complex competitive operations become possible.  In practice, this level of isolation is required in accounting systems. </p><br><p>  For transactions containing only SELECT queries, the use of the Serializable isolation level is justified when you do not want to see the changes made in parallel with completed transactions during the course of the current transaction. </p><br><h2 id="anomaliya-serializacii-poteryannoe-obnovlenie">  Serialization Anomaly (Lost Update) </h2><br><p>  Another phenomenon of reading data is described by the fact that the result of a successful fixation of a group of transactions is inconsistent with all sorts of options for executing these transactions in turn. </p><br><p>  Orient me, please, in the comments, if I am mistaken about the fact that the anomaly of serialization and the lost update related phenomena. </p><br><p>  The documentation on the PostgreSQL PRO website writes that Read Committed allows for <a href="https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso.html">‚ÄúSerialization Anomaly‚Äù</a> .  Domestic Wikipedia, without insisting that the table refers specifically to PostgreSQL, writes that Read Commited prevents <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BD%25D1%258C_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B9">serialization anomaly</a> .  English Wikipedia about such a phenomenon of reading data is <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">silent</a> .  But German Wikipedia cites the <a href="https://de.wikipedia.org/wiki/Isolation_(Datenbank)">‚ÄúLost Updates‚Äù</a> phenomenon in its version of the table, indicating that Read Committed may not be susceptible to the loss of updates with Cursor Stability.  Ukrainian Wikipedia supports the Russian version of the article; Spanish Wikipedia supports the English version of the article.  The English-language PostgreSQL documentation is <a href="https://www.postgresql.org/docs/9.6/static/transaction-iso.html">no different</a> from the documentation from the PostgreSQL PRO site. </p><br><blockquote>  Cursor Stability extends the blocking behavior of the READ COMMITED level for SQL cursors by adding a new read operation (Fetch) on the rc cursor (meaning read cursor, that is, reading on the cursor) and requiring the lock to be set on the current cursor element.  The lock is held until the cursor is moved (until its current element is changed) or closed, possibly by a commit operation.  Naturally, a transaction reading on the cursor can change the current line (wc is a record on the cursor), in which case the lock on the record of this line will be maintained until the transaction is committed, even after moving the cursor, followed by selecting the next line. </blockquote><br><div class="spoiler">  <b class="spoiler_title">This is the result in PostgreSQL 9.6.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/c94/4b9/915/c944b99159b94b3e828193dcb63a6e4d.png" alt="Serialization Anomaly, Lost Updates"></p><br><p>  Outcome: 149. </p></div></div><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Understanding transaction isolation levels is an important aspect of data processing in any multi-user DBMS.  Insulation levels have well-defined characteristics and behavior.  Higher isolation levels reduce parallel processing and increase the risk of interlocking processes.  Therefore, the correct use of levels depending on the tasks of the applications is always the choice of the developer depending on the requirements for ensuring the logical integrity of the data, speed and the possibility of parallel multi-user processing. </p><br><h2 id="literatura">  Literature </h2><br><p>  ¬ª <a href="http://momjian.us/main/writings/pgsql/mvcc.pdf">MVCC Unmasked</a> <br>  " <a href="https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso">13.2.</a>  <a href="https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso">Transaction isolation</a> <br>  ¬ª <a href="http://citforum.ru/database/classics/SQL_critiques/">Criticism of isolation levels</a> <br>  ¬ª <a href="http://arbinada.com/en/node/619">Transaction isolation levels in SQL.</a>  <a href="http://arbinada.com/en/node/619">Crib</a> <br>  ¬ª <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BD%25D1%258C_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B9">Transaction Isolation Level</a> <br>  " <a href="https://vladmihalcea.com/2014/09/14/a-beginners-guide-to-database-locking-and-the-lost-update-phenomena/">... the lost update phenomena</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/317884/">https://habr.com/ru/post/317884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317874/index.html">Storage System for Billions of Records with Key Access</a></li>
<li><a href="../317876/index.html">FPGA Debug Board - Frankenstein. Sounds and music</a></li>
<li><a href="../317878/index.html">VulnHub Analysis of tasks with CTF SkyDog: 2016 - Catch Me If You Can</a></li>
<li><a href="../317880/index.html">Why are we angry?</a></li>
<li><a href="../317882/index.html">Lock-free data structures. Iterable list</a></li>
<li><a href="../317886/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ241 (December 12 - 18, 2016)</a></li>
<li><a href="../317892/index.html">SwiftLint - clean and tidy iOS project</a></li>
<li><a href="../317894/index.html">Alameda, Bower and NPM integration in the CleverStyle Framework</a></li>
<li><a href="../317896/index.html">WPF - Floppy Pages</a></li>
<li><a href="../317900/index.html">Check Umbraco source code again</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>