<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Connecting a color LCD touch screen to a microcontroller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, Habr. Today I would like to share some experiences regarding the connection of color LCD-indicators to the microcontroller. This topic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Connecting a color LCD touch screen to a microcontroller</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, Habr.  Today I would like to share some experiences regarding the connection of color LCD-indicators to the microcontroller.  This topic has already been raised on Habr√© ( <a href="http://habrahabr.ru/post/139384/">http://habrahabr.ru/post/139384/</a> ), so this post can be considered as a supplement to the one already written by my distinguished colleagues. <br><img src="https://habrastorage.org/storage2/f21/bfc/ffe/f21bfcffe32a1e178b39307776f62b42.jpg"><br><a name="habracut"></a><br>  In the post, which is a link at the beginning, are considered LCD-indicators connected via the SPI interface.  This method of connection is simple, but not the only one.  Many indicators have ‚Äúon board‚Äù only a simplified controller that does not have a memory for storing an image, and therefore, requires continuous updating of the image.  Such indicators are used everywhere in electronic gadgets, and their operation requires a special LCD controller built into the microcontroller.  An example of such an indicator is MI0350CT-3 manufactured by Multi-Inno Technology.  This is a fairly typical representative of color LCD, having a resolution of 320 * 240 and a resistive sensor. <br>  So, we have some problem.  Suppose each pixel is represented in memory by a 32-bit value (of which only 24 are used, but the data is aligned on 4-byte boundaries).  So, for one video page, we need 320 * 240 * 4 = 307200 bytes = 300 KB of RAM.  Not every microcontroller has this amount of memory.  Therefore, as a rule, for the LCD to work, external memory is needed, and hence the external memory controller on the microcontroller chip. <br>  To be fair, it should be noted that memory requirements can be reduced if you use not 24-bits per pixel, but less color depth, but, on the other hand, we may want to place several video pages in the system's memory in order to be able to quickly switch between them .  We will return to this topic later. <br>  For example, consider connecting an LCD to an LPC2478 microcontroller.  This is a slightly outdated representative of NXP microcontrollers (on the ARM7 core, and not on the modern Cortex M3), but for our purposes this is not essential.  This microcontroller contains everything you need: an external memory controller (with the ability to connect both SRAM and SDRAM), and an LCD controller with the possibility of very flexible configuration. <br>  For the experiments, I used the SK-MLPC2478 board, which had, in addition to the LPC2478 microcontroller, a static memory chip (CMOS SRAM) K6R4008V1D-TI10 of 512Kx8 bit.  The above-mentioned indicator MI0350CT-3 is connected to the board. <br>  There is another underwater stone: this indicator requires a source with an output current of 20 mA at a voltage of about 20 V to power the backlight. For example, a pulsed boost converter that is powered by an input voltage of + 5V and feeds the load with a stabilized current 20 can be used as such a source. mA  If the load is not connected, the converter operates in the stabilization mode of the output voltage (U out = 20 V).  The converter circuit is shown in Fig. 1. The principle of operation and the calculation of the boost converter will not be considered here; those interested in this topic can refer to the documentation for the MC34063A chip. <br><br><img src="https://habrastorage.org/storage2/85e/20f/aa9/85e20faa9ae769df207254e0dfef04ce.jpg"><br><br>  Fig.  1. Voltage converter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider briefly the connection and operation of this type of LCD.  The LCD uses 24 signals for color information, CLK for pixel sync, HSINK and VSINC for horizontal and vertical sync pulses.  In addition, the indicator has an SPI interface for setting the auxiliary registers, the #RESET signal and the DEN signal (data enable).  The SPI interface in this case is not intended to transmit the image to the display controller, but to configure auxiliary registers.  These registers allow you to select the mode of the indicator, adjust the brightness, contrast and other parameters.  However, the default control registers of the indicator are set to the state we need, and if we are not going to change them, the SPI signals can simply be ignored.  The #RESET signal can simply be set to the inactive (single) state.  In the future, we will not need it. <br>  So, the main signals necessary for the operation of this type of indicator are: data signals that carry information about the current pixel color in the RGB format, a clock signal CLK, vertical and horizontal synchronization signals, and a data resolution signal.  Consider timing charts. <br><br><img src="https://habrastorage.org/storage2/7da/1fd/489/7da1fd48980d95bad9035e76efb6be0e.gif"><br><br>  Fig.  2. Timing diagram of data transfer in LCD. <br><br>  In fig.  Figure 2 shows the most "large-scale" timeline of data transfer, depicting the transfer of data of one line of the image.  Transmission occurs on the front of the CLK signal, and is accompanied by a high level of DEN data resolution signal.  The transfer takes place in the RGB format, while the Data0 - Data7 bits correspond to blue, Data8 - Data15 - to green, Data16-Data23 - to red. <br>  Before sending data to the line and after transferring data, ‚Äúempty‚Äù CLK pulses are inserted, which do not carry information.  The transmission line is preceded by a horizontal synchronization pulse HSYNC (LCD_LP). <br>  The clock frequency of the indicator is 6.4 MHz (it can be reduced, but then the flickering of frames becomes noticeable). <br><br><img src="https://habrastorage.org/storage2/69d/109/30c/69d10930ce11b4a859360ffe61fa3449.gif"><br><br>  Fig.  3. Timing diagram of frame transmission in LCD <br><br>  The timing diagram of the full frame transmission in the LCD is shown in Fig.  3. The frame transmission begins with 13 ‚Äúempty‚Äù lines, followed by 240 lines with an image, followed by ‚Äúempty‚Äù lines again.  Frame transmission begins with a vertical synchronization pulse. <br>  Also connect to the microcontroller resistive sensor.  A description of this connection will be given below. <br>  I will not give a complete diagram of connecting the indicator to the microcontroller, because of its obviousness, I will give only a table of correspondence between the indicator and the controller pins. <br><br>  Table 1. Correspondence between LCD signals and controller pins <br><br><table><tbody><tr><td width="86">  <b>Signal</b> </td><td width="86">  <b>SK-MLPC2478 (connector X6)</b> </td><td width="86">  <b>LCD pin</b> </td><td width="86">  <b>Microcontroller port</b> </td><td width="86">  <b>Note</b> </td></tr><tr><td>  GND </td><td>  one </td><td>  53, 54 </td><td></td><td>  land </td></tr><tr><td>  + 5V </td><td>  2 </td><td>  - </td><td></td><td>  not used </td></tr><tr><td>  DATA6 </td><td>  3 </td><td>  18 </td><td></td><td>  data </td></tr><tr><td>  +3.3 V </td><td>  four </td><td>  41, 42 </td><td></td><td>  nutrition </td></tr><tr><td>  LCD CLK IN </td><td>  five </td><td>  - </td><td></td><td>  not used </td></tr><tr><td>  DATA 7 </td><td>  6 </td><td>  nineteen </td><td></td><td>  data </td></tr><tr><td>  DATA 19 </td><td>  7 </td><td>  31 </td><td></td><td>  data </td></tr><tr><td>  DATA 18 </td><td>  eight </td><td>  thirty </td><td></td><td>  data </td></tr><tr><td>  DATA 22 </td><td>  9 </td><td>  34 </td><td></td><td>  data </td></tr><tr><td>  DATA 23 </td><td>  ten </td><td>  35 </td><td></td><td>  data </td></tr><tr><td>  DATA 20 </td><td>  eleven </td><td>  32 </td><td></td><td>  data </td></tr><tr><td>  DATA 21 </td><td>  12 </td><td>  33 </td><td></td><td>  data </td></tr><tr><td>  DATA 14 </td><td>  13 </td><td>  26 </td><td></td><td>  data </td></tr><tr><td>  DATA 15 </td><td>  14 </td><td>  27 </td><td></td><td>  data </td></tr><tr><td>  DATA 12 </td><td>  15 </td><td>  24 </td><td></td><td>  data </td></tr><tr><td>  DATA 13 </td><td>  sixteen </td><td>  25 </td><td></td><td>  data </td></tr><tr><td>  DATA 11 </td><td>  17 </td><td>  23 </td><td></td><td>  data </td></tr><tr><td>  DATA 10 </td><td>  18 </td><td>  22 </td><td></td><td>  data </td></tr><tr><td>  DATA 1 </td><td>  nineteen </td><td>  13 </td><td></td><td>  data </td></tr><tr><td>  DATA 0 </td><td>  20 </td><td>  12 </td><td></td><td>  data </td></tr><tr><td>  DATA 9 </td><td>  21 </td><td>  21 </td><td></td><td>  data </td></tr><tr><td>  DATA 8 </td><td>  22 </td><td>  20 </td><td></td><td>  data </td></tr><tr><td>  DATA 17 </td><td>  23 </td><td>  29 </td><td></td><td>  data </td></tr><tr><td>  DATA 16 </td><td>  24 </td><td>  28 </td><td></td><td>  data </td></tr><tr><td>  LCD LE </td><td>  25 </td><td>  - </td><td></td><td>  not used </td></tr><tr><td>  LCD PWR </td><td>  26 </td><td>  - </td><td></td><td>  not used </td></tr><tr><td>  LCD FP </td><td>  27 </td><td>  37 </td><td></td><td>  Vertical sync </td></tr><tr><td>  LCD CLK </td><td>  28 </td><td>  38 </td><td></td><td>  Clock indicator </td></tr><tr><td>  LCD LP </td><td>  29 </td><td>  36 </td><td></td><td>  Horizontal sync </td></tr><tr><td>  LCD ENAB </td><td>  thirty </td><td>  52 </td><td></td><td>  Data resolution </td></tr><tr><td>  DATA 5 </td><td>  31 </td><td>  17 </td><td></td><td>  data </td></tr><tr><td>  DATA 4 </td><td>  32 </td><td>  sixteen </td><td></td><td>  data </td></tr><tr><td>  DATA 3 </td><td>  33 </td><td>  15 </td><td></td><td>  data </td></tr><tr><td>  DATA 2 </td><td>  34 </td><td>  14 </td><td></td><td>  data </td></tr><tr><td>  SPENA </td><td>  35 </td><td>  43 </td><td>  P0.20 </td><td>  SPI interface, serial port data enable </td></tr><tr><td>  - </td><td>  36 </td><td>  - </td><td></td><td>  Not used </td></tr><tr><td>  #RESET </td><td>  37 </td><td>  6 </td><td>  P0.19 </td><td>  reset </td></tr><tr><td>  - </td><td>  38 </td><td>  - </td><td></td><td>  Not used </td></tr><tr><td>  SPCK </td><td>  39 </td><td>  49 </td><td>  P0.17 </td><td>  SPI interface, serial port clock </td></tr><tr><td>  SPDA </td><td>  40 </td><td>  50 </td><td>  P0.18 </td><td>  SPI interface, serial data </td></tr><tr><td>  Yu </td><td>  Connector X7.15 </td><td>  eight </td><td>  AD0 / P0.23 </td><td>  Resistive sensor </td></tr><tr><td>  XR </td><td>  Connector X7.13 </td><td>  9 </td><td>  AD1 / P0.24 </td><td>  Resistive sensor </td></tr><tr><td>  YD </td><td>  Connector X7.10 </td><td>  ten </td><td>  P0.26 </td><td>  Resistive sensor </td></tr><tr><td>  XL </td><td>  Connector X7.12 </td><td>  eleven </td><td>  P0.25 </td><td>  Resistive sensor </td></tr></tbody></table><br>  We assemble the device layout (fig. 4 - 6): <br><br><img src="https://habrastorage.org/storage2/fec/d49/b44/fecd49b44ffccaeb94790c2c4743b78f.jpg"><br><br>  Fig.  4. Layouts of the device layout <br><br><img src="https://habrastorage.org/storage2/8eb/4a3/16d/8eb4a316d3da41159a9545a0857f1eaf.jpg"><br><br>  Fig.  5. Layout of the device (partially assembled) <br><br><img src="https://habrastorage.org/storage2/387/9e6/34c/3879e634ce1f8ad979d8be1406f8e824.jpg"><br><br>  Fig.  6. Layout device assembly <br><br>  Now that everything is connected, you can start writing the code.  The first thing to do is configure and test external SRAM memory: <br><br><pre><code class="hljs pgsql">// Init SDRAM controller // <span class="hljs-keyword"><span class="hljs-keyword">Enable</span></span> EMC clock PCONP_bit.PCEMC = <span class="hljs-number"><span class="hljs-number">1</span></span>; EMCSTATICWAITRD0 = <span class="hljs-number"><span class="hljs-number">0x00000001</span></span>; EMCSTATICWAITPG0 = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>; EMCSTATICWAITWR0 = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>; EMCSTATICWAITTURN0 = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>; EMCCONTROL = <span class="hljs-number"><span class="hljs-number">1</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> EMC</code> </pre> <br>  SRAM test: <br><pre> <code class="hljs perl">char SRAM_Test(void) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> bits access <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32U i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x80000</span></span>; i+=sizeof(Int32U)) { *(Int32U*)(((Int32U)SRAM_BASE_ADDR)+i) = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32U i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x80000</span></span>; i+=sizeof(Int32U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(Int32U*)(((Int32U)SRAM_BASE_ADDR)+i) != i) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Verification error on address : 0x%x\n"</span></span>,(Int32U)SRAM_BASE_ADDR+i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(FALSE); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre><br>  It should be understood that the speed of external memory is an important factor.  In fact, the data stream in our case is Fclk * N, where Fclk is the clock frequency of the indicator, N is the number of bytes in memory allocated for 1 pixel.  Total we get 6.4 * 10 ^ 6 * 4 = 25.6 MB / s.  For memory with an 8-bit interface, this means a maximum allowed access time of 39 ns.  Memory speed requirements can be reduced by using memory with a 16 or 32-bit interface and / or reducing the color depth used. <br>  Configuring the LCD in, setting the duration of the signals in accordance with the documentation of the indicator: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ Init GLCD cotroller PCONP_bit.PCLCD = 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ enable LCD controller clock CRSR_CTRL_bit.CrsrOn = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Disable cursor LCD_CTRL_bit.LcdEn = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ disable GLCD controller LCD_CTRL_bit.LcdBpp= 5; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/2bpp /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 24 bpp LCD_CTRL_bit.LcdTFT= 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ TFT panel LCD_CTRL_bit.LcdDual=0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ single panel LCD_CTRL_bit.BGR = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ normal output LCD_CTRL_bit.BEBO = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ little endian byte order LCD_CTRL_bit.BEPO = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ little endian pix order LCD_CTRL_bit.LcdPwr= 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ disable power /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ init pixel clock LCD_CFG_bit.CLKDIV = SYS_GetFsclk() /</span></span> (Int32U)C_GLCD_PIX_CLK; LCD_POL_bit.BCD = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> bypass inrenal clk divider LCD_POL_bit.CLKSEL = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> clock source <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the LCD block is HCLK LCD_POL_bit.IVS = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> LCDFP pin is active LOW <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> inactive HIGH LCD_POL_bit.IHS = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> LCDLP pin is active LOW <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> inactive HIGH /<span class="hljs-regexp"><span class="hljs-regexp">/ LCD_POL_bit.IPC = 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ data is driven out into the LCD on the falling edge LCD_POL_bit.IPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ data is driven out into the LCD on the rising edge LCD_POL_bit.PCD_HI = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ LCD_POL_bit.PCD_LO = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ LCD_POL_bit.IOE = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ active high LCD_POL_bit.CPL = C_GLCD_H_SIZE-1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ init Horizontal Timing LCD_TIMH_bit.HBP = C_GLCD_H_BACK_PORCH - 1; LCD_TIMH_bit.HFP = C_GLCD_H_FRONT_PORCH - 1; LCD_TIMH_bit.HSW = C_GLCD_H_PULSE - 1; LCD_TIMH_bit.PPL = (C_GLCD_H_SIZE/</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> init Vertical Timing LCD_TIMV_bit.VBP = C_GLCD_V_BACK_PORCH; LCD_TIMV_bit.VFP = C_GLCD_V_FRONT_PORCH; LCD_TIMV_bit.VSW = C_GLCD_V_PULSE; LCD_TIMV_bit.LPP = C_GLCD_V_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Frame Base Address doubleword aligned LCD_UPBASE = (Int32U)GetVramAddr() &amp; ~<span class="hljs-number"><span class="hljs-number">7</span></span>UL;</code> </pre><br>  Now we write a test picture in ROM and copy it into RAM: <br><br><img src="http://habrastorage.org/storage2/875/65a/6b3/87565a6b379ab2559288768fe0b3812b.gif"><br><br>  Figure 7. Test picture <br><br>  The picture is recorded as an array of unsigned int [240] [320], and copied to the base address of external memory (0x80000000). <br>  The operation of the LCD support mechanism built into the microcontroller is that the data is read from the RAM by the DMA controller and fed to the LCD controller, where the cursor image is superimposed and the data is fed to the LCD input.  The LCD controller can also provide support for palettes for modes from 1 to 8 bits per pixel.  The palette is implemented in the microcontroller as 256 16-bit registers and, thus, provides the display of 8-bit color to 16-bit (5 bits / color + 1 bit of total intensity). <br>  The cursor has a separate palette of two 32-bit registers; it provides the display of a monochrome image of the cursor in a 24-bit color space.  The cursor can be 64x64 pixels or 32x32 pixels in size, and contains both the cursor image itself and the image inversion mask. <br>  Now you can run a test program and look at the result. <br><br><img src="http://habrastorage.org/storage2/be3/129/9e9/be31299e91c596f76b02439cf5f6b760.jpg"><br><br>  Fig.  8. The result of the work. <br><br><h5>  Resistive Sensor Connection </h5><br><br>  The principle of operation of a resistive sensor is widely known (those to whom it is unknown can familiarize themselves with it, for example, here <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BD%25D1%2581%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9%2520%25D1%258D%25D0%25BA%25D1%2580%25D0%25B0%25D0%25BD">http://ru.wikipedia.org/wiki/Touch screen</a> ).  Therefore, we proceed immediately to the description of the connection of the sensor to the microcontroller.  This device uses a sensor with a four-wire connection scheme.  Connection diagram is shown in Fig.  9. <br><img src="http://habrastorage.org/storage2/753/4d4/d4f/7534d4d4fd079d7718e66b42177c3d23.png"><br><br>  Fig.  9. Connection diagram of the resistive sensor to the microcontroller. <br><br>  The idea behind this connection is as follows.  Each output of the microcontroller can be in one of the following states: output with a logical 0, output with a log.  1, an input (i.e., in fact, an unconnected output), and an input pulled to the supply voltage through a resistor.  Conclusions YU and XL can also serve as inputs to the ADC. <br>  The whole procedure of determining the coordinates of pressing can be divided into three phases.  In the first phase, the outputs to which the sensor is connected are in the following state: (Fig. 10). <br><br><img src="http://habrastorage.org/storage2/b44/7e1/84a/b447e184a6833b0e1cc517ed5b4f599c.png"><br><br>  Fig.  10. Determination of coordinates.  Phase 1. <br><br>  With the closure of the sensor film to the input of the microcontroller, the signal log.  0, and the program proceeds to phase 2, determining the x-coordinate of the pressure (Fig. 11).  Then comes phase 3, the definition of the y-coordinate.  (Fig. 12). <br><br><img src="http://habrastorage.org/storage2/94e/aee/6e9/94eaee6e985839b8e1fe6edb39d90bd3.png"><br><br>  Fig.  11. Determination of x-coordinates of clicking. <br><br><img src="http://habrastorage.org/storage2/4e3/451/64d/4e345164d0c4314a81725def3a888763.png"><br><br>  Fig.  12. Determine the y-coordinate of the click. <br><br>  Of course, the algorithm for calculating the coordinates of pressing should include the suppression of the bounce of "contacts" (sensor films). <br>  With a single measurement, the accuracy of determining the coordinates will be too low, the measurement noise will cause the cursor to oscillate strongly in the vicinity of the tangency point.  Therefore, it is highly desirable to use any filtering algorithm, such as a median filter ( <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2584%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580">http://ru.wikipedia.org/wiki/Median_Filter</a> ). <br>  After receiving the result in ADC codes, it is recalculated to the coordinates of the screen using conventional linear transformations (ax + b), where the coefficients a and b must be found by calibrating the sensor and stored in the nonvolatile memory of the controller.  In fig.  13. shows an example of a calibration screen. <br><br><img src="http://habrastorage.org/storage2/e5b/410/c02/e5b410c025b496fb59b381d3df6dc515.gif"><br><br>  Fig.  13. Screen calibration. <br><br><img src="http://habrastorage.org/storage2/8d5/2a2/64a/8d52a264a2d9177d09bb8303d10c298d.jpg"><br><br>  Fig.  14. Calibration screen on LCD. <br><br>  It is also possible to connect the touch screen using an external controller, for example, XPT2046. <br>  The complete source code for the sample program can be downloaded from here: <a href="https://bitbucket.org/arktur04/lcd-demo">https://bitbucket.org/arktur04/lcd-demo</a> (IAR development environment). <br><br>  Links to the documentation mentioned in the post: <br>  1.Display Multi-Inno MI0350CT-3 <a href="http://www.displayfuture.com/engineering/specs/TFT/MI0350CT-3.pdf">http://www.displayfuture.com/engineering/specs/TFT/MI0350CT-3.pdf</a> <br>  2. MC34063A Pulse Voltage Converter <a href="http://www.fairchildsemi.com/ds/MC/MC33063A.pdf">http://www.fairchildsemi.com/ds/MC/MC33063A.pdf</a> <br>  3. Microcontroller LPC2478 <a href="http://www.ru.nxp.com/products/microcontrollers/arm7/lpc2400/LPC2478.html">http://www.ru.nxp.com/products/microcontrollers/arm7/lpc2400/LPC2478.html</a> <br>  4. XPT2046 Resistive Sensor Controller <a href="http://www.dzsc.com/uploadfile/company/785710/20111014212155973.pdf">http://www.dzsc.com/uploadfile/company/785710/20111014212155973.pdf</a> </div><p>Source: <a href="https://habr.com/ru/post/140415/">https://habr.com/ru/post/140415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140405/index.html">Bitcasa has started!</a></li>
<li><a href="../140409/index.html">Django Admin Actions - actions with an intermediate page</a></li>
<li><a href="../140411/index.html">Create moving pictures with Processing</a></li>
<li><a href="../140412/index.html">Muz.ru gives audio for free</a></li>
<li><a href="../140414/index.html">Caching in Yii using tags</a></li>
<li><a href="../140417/index.html">Intellect cards as a good way to systematize any activity.</a></li>
<li><a href="../140418/index.html">AtContent.com. Internal structure and architecture</a></li>
<li><a href="../140421/index.html">The history of one community or how to change thinking</a></li>
<li><a href="../140422/index.html">Production control</a></li>
<li><a href="../140423/index.html">Image Control do it yourself in Visual C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>