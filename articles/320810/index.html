<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New SQLite ORM for C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. I write on Habr√© for the first time, do not judge strictly. I want to share my experience in finding a universal SQLite ORM library in C ++ and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New SQLite ORM for C ++</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello.  I write on Habr√© for the first time, do not judge strictly.  I want to share my experience in finding a universal SQLite ORM library in C ++ and my new development of my own library for working with SQLite in C ++ <a href="https://github.com/fnc12/sqlite_orm">sqlite_orm</a> . </p><br><p>  When I was looking for ORM, I was repelled by several key points: </p><br><ul><li>  library must have both CRUD and non CRUD </li><li> there must be flexible WHERE conditions, not stupid <code>WHERE id = ?</code> </li><li>  there should be a migration functionality (schema synchronization) in case of application updates </li><li>  Features like ORDER BY and LIMIT should also be </li><li>  serialization of classes should not be written in their classes.  This is a very important point for me since I got acquainted with Java and with Android-development in particular.  Android developers are trying to adhere to the principle of the sole responsible (single responsibility principle), which is very important if the application is assembled from different heaps of libraries and modules that can change over time.  And therefore the most popular on github SQLite ORM'ka in C ++ <a href="https://github.com/paulftw/hiberlite">hiberlite</a> did not suit me in the way of serialization - the class of the model should have a static <code>serialize</code> function with a direct serialization code.  I was looking for a module on which the code of my data model would not depend.  After all, I can have several serializers (JSON, XML, SQLite), and, in a good way, everyone should be attached to the data model, but not to change it, otherwise it will turn out to be a mess in the model code. <br><a name="habracut"></a></li><li>  code in the style of the standard library - recently this trend is gaining popularity (in general I was impressed by this <a href="https://github.com/nlohmann/json">library</a> ) </li><li>  support for both the database on the file system and in memory </li><li>  leave the ability to name tables and columns to the developer regardless of the class names and their fields in case you still need to get into the database through the SQLite client so that everything is obvious </li><li>  transactions </li></ul><br><p>  In addition to <code>hiberlite</code> there are also a bunch of different libraries, but for some reason they have a small functionality.  In other words, working with them it turns out that the developer will still have to write direct connection code to the database via <code>libsqlite3</code> , then why is this ORM necessary? </p><br><p>  It seems that I delayed the introduction, I will go directly to the possibilities that the library <a href="https://github.com/fnc12/sqlite_orm">sqlite_orm</a> gives. </p><br><p>  1) CRUD </p><br><p>  Example: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> firstName; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> lastName; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> birthDate; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; imageUrl; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> typeId; };</code> </pre> <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; };</code> </pre> <br><p>  Two classes means two tables. </p><br><p>  The interaction takes place through the <code>storage</code> object which is a service object with an interface to the database.  <code>storage</code> is created by the <code>make_storage</code> function.  At creation the scheme is underlined. </p><br><pre> <code class="hljs php">using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">sqlite_orm</span></span>; auto storage = make_storage(<span class="hljs-string"><span class="hljs-string">"db.sqlite"</span></span>, make_table(<span class="hljs-string"><span class="hljs-string">"users"</span></span>, make_column(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, &amp;User::id, autoincrement(), primary_key()), make_column(<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>, &amp;User::firstName), make_column(<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>, &amp;User::lastName), make_column(<span class="hljs-string"><span class="hljs-string">"birth_date"</span></span>, &amp;User::birthDate), make_column(<span class="hljs-string"><span class="hljs-string">"image_url"</span></span>, &amp;User::imageUrl), make_column(<span class="hljs-string"><span class="hljs-string">"type_id"</span></span>, &amp;User::typeId)), make_table(<span class="hljs-string"><span class="hljs-string">"user_types"</span></span>, make_column(<span class="hljs-string"><span class="hljs-string">"id"</span></span>, &amp;UserType::id, autoincrement(), primary_key()), make_column(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, &amp;UserType::name, default_value(<span class="hljs-string"><span class="hljs-string">"name_placeholder"</span></span>))));</code> </pre> <br><p>  Note that the data model is "not up to date" about the repository.  Also the name of the column and the name of the class field are independent of each other  This allows you to write Camel-case code, for example, and the database schema through underscores as I do. </p><br><p>  In <code>make_storage</code> first parameter is the file name, then the tables go.  To create a table, we specify the name of the table (it has nothing to do with the class, because if you make an automatic naming, the implementation will not be very: you must either use <code>typeid(T).name()</code> , which returns not always a clear name, but rather a system name, either cheat with macros, which I generally disapprove), then indicate the columns.  To create a single column, you need at least two parameters: the name of the column and a link to the class field.  This link will determine the type of column and address for assignment in the future.  You can also <code>AUTOINCREMENT</code> and / or <code>PRIMARY KEY</code> with <code>DEFAULT</code> . </p><br><p>  Now you can send queries to the database through calls to the <code>storage</code> object functions.  For example, let's create a user and make an <code>INSERT</code> . </p><br><pre> <code class="hljs cpp">User user{<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"Jonh"</span></span>, <span class="hljs-string"><span class="hljs-string">"Doe"</span></span>, <span class="hljs-number"><span class="hljs-number">664416000</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"url_to_heaven"</span></span>), <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> insertedId = storage.insert(user); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"insertedId = "</span></span> &lt;&lt; insertedId &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; user.id = insertedId;</code> </pre> <br><p>  Now we have sent <code>INSERT INTO users(first_name, last_name, birth_date, image_url, type_id) VALUES('Jonh', 'Doe', 664416000, 'url_to_heaven', 3)</code> . </p><br><p>  The first argument -1 we specified when creating the user object is id.  It is ignored during creation, as the id is the PRIMARY KEY column.  <code>sqlite_orm</code> ignores the PRIMARY KEY column at INSERT and returns the id of the newly created object.  Therefore, after INSERT, we do <code>user.id = insertedId;</code>  - after that, the user is full and can be used further in the code. </p><br><p>  To get the same user, use the <code>get</code> function: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = storage.get&lt;User&gt;(insertedId); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"user = "</span></span> &lt;&lt; user.firstName &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; user.lastName &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(sqlite_orm::not_found_exception) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"user not found with id "</span></span> &lt;&lt; insertedId &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...){ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"unknown exeption"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  <code>get</code> returns an object of class <code>User</code> (which we passed as a template parameter).  If the user with such id is not thrown, the exception <code>sqlite_orm::not_found_exception</code> .  Such an interface with an exception may be inconvenient.  The reason for this is that in C ++ just an object cannot be set to zero as it can be done in Java, C # or Objective-C.  You can use <code>std::shared_ptr&lt;T&gt;</code> as the type to be <code>std::shared_ptr&lt;T&gt;</code> .  For such a case, there is a second version of the <code>get</code> - <code>get_no_throw</code> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(auto <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_no_throw&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(insertedId)){ cout &lt;&lt; "user = " &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-&gt;firstName &lt;&lt; " " &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-&gt;lastName &lt;&lt; endl; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ cout &lt;&lt; "no user with id " &lt;&lt; insertedId &lt;&lt; endl; }</code> </pre> <br><p>  Here, user is <code>std::shared_ptr&lt;User&gt;</code> and may be equal to <code>nullptr</code> , or it may store the user. </p><br><p>  Next we may want to make the <code>UPDATE</code> user.  To do this, we will change the fields we want to change and call the <code>update</code> function: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.firstName = "Nicholas"; <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.imageUrl = "https://cdn1.iconfinder.com/data/icons/man-icon-set/100/man_icon-21-512.png" <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>);</code> </pre> <br><p>  It works like this: <code>UPDATE users SET ...    primary key... WHERE id = % ,    ,   primary key%</code> is called <code>UPDATE users SET ...    primary key... WHERE id = % ,    ,   primary key%</code> . </p><br><p>  It's simple.  Note that there are no proxy objects for interacting with the repository ‚Äî the repository accepts and returns "clean" model objects.  This simplifies the work and lowers the threshold of entry. </p><br><p>  Deleting an object by id is implemented like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.remove&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(insertedId);</code> </pre> <br><p>  Here you need to explicitly specify the type as a template parameter, since there is no way to guess the compiler. </p><br><p>  This CRUD ends.  But the functionality is not limited to this.  CRUD functions in <code>sqlite_orm</code> are functions that work only with objects that have one column with <code>PRIMARY KEY</code> .  There are also non-CRUD functions. </p><br><p>  For example, let's do <code>SELECT * FROM users</code> . </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> allUsers = storage.get_all&lt;User&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"allUsers ("</span></span> &lt;&lt; allUsers.size() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"):"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;user : allUsers) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; storage.dump(user) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  The variable <code>allUsers</code> is of type <code>std::vector&lt;User&gt;</code> .  Pay attention to the <code>dump</code> function - it takes a class object that is associated with the storage, and returns information about it in the json-style in the form of <code>std::string</code> .  For example, "{id: '1', first_name: 'Jonh', last_name: 'Doe', birth_date: '664416000', image_url: '0x10090c3d8', type_id: '3'}". </p><br><p>  But this is not enough.  The ORM library cannot be considered complete without WHERE conditions.  Therefore, they also exist in <code>sqlite_orm</code> they are very powerful. </p><br><p>  The above-mentioned <code>get_all</code> function can take as its argument the result of a <code>where</code> function with conditions.  For example, let's select users whose id is less than 10. The query should look like this: <code>SELECT * FROM users WHERE id &lt; 10</code> .  In code, it looks like this: </p><br><pre> <code class="hljs pgsql">auto idLesserThan10 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(lesser_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">10</span></span>)));</code> </pre> <br><p>  Or select users whose firstName field is not equal to "John".  Query - <code>SELECT * FROM users WHERE first_name != 'John'</code> </p><br><pre> <code class="hljs pgsql">auto notJohn = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(is_not_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "John")));</code> </pre> <br><p>  Moreover, you can "mix" the operators <code>&amp;&amp;</code> , <code>||</code>  and <code>!</code>  (for greater clarity, it is better to use the literal versions of these operators <code>and</code> , <code>or</code> and <code>not</code> ). </p><br><pre> <code class="hljs pgsql">auto notJohn2 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "John")));</code> </pre> <br><p>  <code>notJohn2</code> equivalent to <code>notJohn</code> . </p><br><p>  And another example with linked conditions: </p><br><pre> <code class="hljs pgsql">auto id5and7 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(lesser_or_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> greater_or_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">6</span></span>)));</code> </pre> <br><p>  We implemented this query <code>SELECT * FROM users WHERE where id &gt;= 5 and id &lt;= 7 and not id = 6</code> . </p><br><p>  Or <code>SELECT * FROM users WHERE id = 10 or id = 16</code> : </p><br><pre> <code class="hljs pgsql">auto id10or16 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">16</span></span>)));</code> </pre> <br><p>  So you can "glue" any combination of conditions.  Moreover, you can specify the priority of conditions using parentheses as in raw queries in SQLite.  For example, these two queries differ in the returned results: </p><br><pre> <code class="hljs pgsql">auto cuteConditions = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>((is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "John") <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "Alex")) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">4</span></span>))); cuteConditions = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "John") <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, "Alex") <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">4</span></span>))));</code> </pre> <br><p>  In the first condition <code>WHERE (first_name = 'John' or first_name = 'Alex') and id = 4</code> , in the second - <code>WHERE first_name = 'John' or (first_name = 'Alex' and id = 4)</code> . </p><br><p>  This magic works by virtue of the fact that in C ++ brackets have the same function of explicitly defining the priority of operations.  Plus, the <code>sqlite_orm</code> itself is only a convenient <code>sqlite_orm</code> for working with SQLite in C ++, it (the library) does not itself execute queries, but only transforms them into text and sends them to the sqlite3 engine. </p><br><p>  There is also an <code>IN</code> operator: </p><br><pre> <code class="hljs pgsql">auto evenLesserTen10 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>})));</code> </pre> <br><p>  It turned out <code>SELECT * FROM users WHERE id IN (2, 4, 6, 8, 10)</code> .  Or for the lines: </p><br><pre> <code class="hljs pgsql">auto doesAndWhites = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::lastName, {"Doe", "White"})));</code> </pre> <br><p>  Here we sent a <code>SELECT * FROM users WHERE last_name IN ("Doe", "White")</code> query to the database. </p><br><p>  The <code>in</code> function takes two arguments: a pointer to the class field and a vector / initialization list.  The type of the contents of the vector / initialization list is the same as the pointer field to which we passed as the first parameter. </p><br><p>  The condition functions <code>is_equal</code> , <code>is_not_equal</code> , <code>greater_than</code> , <code>greater_or_equal</code> , <code>lesser_than</code> , <code>lesser_or_equal</code> take two arguments each.  Arguments can be both pointers to class fields, and constants / variables.  Pointers to the fields are parsed into the query in the column names, and the literals are as they are, only the strings are still quoted around the edges. </p><br><p>  You may have a question: what if I pass in a condition a pointer to a class field that is not listed in any column?  In this case, an exception <code>std::runtime_error</code> with an explanatory text will be thrown.  The same will happen if you specify a type that is not bound to the repository. </p><br><p>  By the way, <code>WHERE</code> conditions can be used in <code>DELETE</code> queries.  For this there is a function <code>remove_all</code> .  For example, let's delete all users whose id is less than 100: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.remove_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(lesser_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">100</span></span>)));</code> </pre> <br><p>  All examples above operate with full-fledged objects.  And what if we want to call a single column <code>SELECT</code> ?  This, too, is: </p><br><pre> <code class="hljs pgsql">auto allIds = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id);</code> </pre> <br><p>  We called this <code>SELECT id FROM users</code> .  <code>allIds</code> is of type <code>std::vector&lt;decltype(User::id)&gt;</code> or <code>std::vector&lt;int&gt;</code> . </p><br><p>  You can add conditions: </p><br><pre> <code class="hljs pgsql">auto doeIds = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(is_equal(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::lastName, "Doe")));</code> </pre> <br><p>  You guessed it <code>SELECT id FROM users WHERE last_name = 'Doe'</code> . </p><br><p>  There may be many options.  For example, you can request all surnames where id is less than 300: </p><br><pre> <code class="hljs pgsql">auto allLastNames = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::lastName, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(lesser_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">300</span></span>)));</code> </pre> <br><h1 id="order-by">  ORDER BY </h1><br><p>  ORM or ORM without ordering.  <code>ORDER BY</code> used in many projects, and <code>sqlite_orm</code> has an interface for it. </p><br><p>  The simplest example is let's choose users sorted by id: </p><br><pre> <code class="hljs pgsql">auto orderedUsers = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id));</code> </pre> <br><p>  This turns into a <code>SELECT * FROM users ORDER BY id</code> .  Or let's mix <code>where</code> and <code>order_by</code> : <code>SELECT * FROM users WHERE id &lt; 250 ORDER BY first_name</code> </p><br><pre> <code class="hljs pgsql">auto orderedUsers2 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(lesser_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">250</span></span>)), order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName));</code> </pre> <br><p>  You can also explicitly specify <code>ASC</code> and <code>DESC</code> .  For example: <code>SELECT * FROM users WHERE id &gt; 100 ORDER BY first_name ASC</code> : </p><br><pre> <code class="hljs pgsql">auto orderedUsers3 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(greater_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">100</span></span>)), order_by(<span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName)));</code> </pre> <br><p>  Or here: </p><br><pre> <code class="hljs pgsql">auto orderedUsers4 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(order_by(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id)));</code> </pre> <br><p>  It turned out <code>SELECT * FROM users ORDER BY id DESC</code> . </p><br><p>  And of course, just <code>select</code> also works with <code>order_by</code> : </p><br><pre> <code class="hljs pgsql">auto orderedFirstNames = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, order_by(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id)));</code> </pre> <br><p>  It turned out <code>SELECT first_name FROM users ORDER BY ID DESC</code> . </p><br><h1 id="migracii">  Migrations </h1><br><p>  There are no migrations per se in the library, but there is a function <code>sync_schema</code> .  Calling this function asks the DB for the current scheme, compares it with the one specified when creating the repository, and if something does not match, rules it.  At the same time, this call does not guarantee the safety of already existing data.  It only guarantees that the scheme will become identical (or <code>std::runtime_error</code> will be thrown. For more information about the rules for synchronizing the scheme, see the repository page on <a href="https://github.com/fnc12/sqlite_orm">github</a> . </p><br><h1 id="tranzakcii">  Transactions </h1><br><p>  The library has two options for the implementation of transactions: explicit and implicit.  Explicit implies a direct call to the <code>begin_transaction</code> and <code>commit</code> or <code>rollback</code> functions.  Example: </p><br><pre> <code class="hljs pgsql">auto secondUser = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.begin_transaction(); secondUser.typeId = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(secondUser); <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">rollback</span></span>(); //  <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>(); secondUser = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;decltype(secondUser)&gt;(secondUser.id); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(secondUser.typeId != <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  The second method is a bit more cunning.  First the code: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>([&amp;] () mutable { auto secondUser = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>); secondUser.typeId = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(secondUser); auto gottaRollback = <span class="hljs-type"><span class="hljs-type">bool</span></span>(rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gottaRollback){ //     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span> });</code> </pre> <br><p>  The <code>transaction</code> function calls <code>BEGIN TRANSACTION</code> immediately and takes a lambda expression as an argument, which is returned by <code>bool</code> .  If you return <code>true</code> , then <code>COMMIT</code> will be executed, if <code>false</code> - <code>ROLLBACK</code> .  This method ensures that you do not forget to call the end of transaction function (like <code>std::lock_guard</code> in a mutex in the standard library). </p><br><p>  There are also aggregate functions <code>AVG</code> , <code>MAX</code> , <code>MIN</code> , <code>COUNT</code> , <code>GROUP_CONCAT</code> : </p><br><pre> <code class="hljs sql">auto averageId = storage.avg(&amp;User::id); // '<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AVG</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto averageBirthDate = storage.avg(&amp;User::birthDate); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AVG</span></span>(birth_date) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto usersCount = storage.count&lt;User&gt;(); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto countId = storage.count(&amp;User::id); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto countImageUrl = storage.count(&amp;User::imageUrl); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(image_url) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto concatedUserId = storage.group_concat(&amp;User::id); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP_CONCAT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto concatedUserIdWithDashes = storage.group_concat(&amp;User::id, "---"); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP_CONCAT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-string"><span class="hljs-string">"---"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto maxId = storage.max(&amp;User::id); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto maxFirstName = storage.max(&amp;User::firstName); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(first_name) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto minId = storage.min(&amp;User::id); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MIN</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">' auto minLastName = storage.min(&amp;User::lastName); // '</span></span><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MIN</span></span>(last_name) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span><span class="hljs-string"><span class="hljs-string">'</span></span></code> </pre> <br><p>  More details can be found <a href="https://github.com/fnc12/sqlite_orm">here</a> .  Contributing is welcome as much as criticism. </p><br><h1 id="edit-1">  EDIT 1 </h1><br><p>  In the last commit, the "raw" select of several columns is added to the vector of tuples (tuples).  For example: </p><br><pre> <code class="hljs pgsql">// `<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> first_name, last_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &gt; <span class="hljs-number"><span class="hljs-number">250</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id` auto partialSelect = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::firstName, &amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::lastName), <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(greater_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">250</span></span>)), order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id)); cout &lt;&lt; "partialSelect count = " &lt;&lt; partialSelect.size() &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto &amp;t : partialSelect) { auto &amp;firstName = std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(t); auto &amp;lastName = std::<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(t); cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; lastName &lt;&lt; endl; }</code> </pre> <br><h1 id="edit-2">  EDIT 2 </h1><br><p>  The last commit adds support for <code>LIMIT</code> and <code>OFFSET</code> .  There are three options for using <code>LIMIT</code> and <code>OFFSET</code> : </p><br><ol><li>  LIMIT% limit% </li><li>  LIMIT% limit% OFFSET% offset% </li><li>  LIMIT% offset%,% limit% </li></ol><br><p>  Examples: </p><br><pre> <code class="hljs pgsql">// `<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> first_name, last_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &gt; <span class="hljs-number"><span class="hljs-number">250</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>` auto limited5 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(greater_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">250</span></span>)), order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id), <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)); cout &lt;&lt; "limited5 count = " &lt;&lt; limited5.size() &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto &amp;<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> : limited5) { cout &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.dump(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) &lt;&lt; endl; } // `<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> first_name, last_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &gt; <span class="hljs-number"><span class="hljs-number">250</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>` auto limited5comma10 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(greater_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">250</span></span>)), order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id), <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); cout &lt;&lt; "limited5comma10 count = " &lt;&lt; limited5comma10.size() &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto &amp;<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> : limited5comma10) { cout &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.dump(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) &lt;&lt; endl; } // `<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> first_name, last_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &gt; <span class="hljs-number"><span class="hljs-number">250</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFFSET</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>` auto limit5offset10 = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_all&lt;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(greater_than(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id, <span class="hljs-number"><span class="hljs-number">250</span></span>)), order_by(&amp;<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>::id), <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>))); cout &lt;&lt; "limit5offset10 count = " &lt;&lt; limit5offset10.size() &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto &amp;<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> : limit5offset10) { cout &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.dump(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>) &lt;&lt; endl; }</code> </pre> <br><p>  Please do not forget that <code>LIMIT 5, 10</code> and <code>LIMIT 5 OFFSET 10</code> have different meanings.  If exactly, then <code>LIMIT 5, 10</code> is <code>LIMIT 10 OFFSET 5</code> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320810/">https://habr.com/ru/post/320810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320798/index.html">The first Russian motherboard of the mass segment</a></li>
<li><a href="../320800/index.html">Creating a realistic chat in the game Mr. Robot: 1.51exfiltrati0n</a></li>
<li><a href="../320802/index.html">How IT professionals work. Anton Charchenko, Technical Lead at EnglishDom</a></li>
<li><a href="../320806/index.html">Oracle Cloud Machine in the enterprise data center</a></li>
<li><a href="../320808/index.html">Development for Sailfish OS: QML Components Testing</a></li>
<li><a href="../320812/index.html">Using the interview method to develop IT products: is it possible to conduct qualitative research on your own?</a></li>
<li><a href="../320814/index.html">Features of the development of mobile MMO RTS. Part 3</a></li>
<li><a href="../320818/index.html">Shooting article: marketing and PR in IT</a></li>
<li><a href="../320824/index.html">Free SSL for CP Vesta - easy. And SSL for Laravel</a></li>
<li><a href="../320826/index.html">Salaries of "top" IT companies again hit the top</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>