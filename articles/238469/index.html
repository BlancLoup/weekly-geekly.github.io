<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We trace removal of files on PowerShell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! The topic of my post has already been raised here, but I have something to add. 

 When our file storage changed the third terabyte, more an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We trace removal of files on PowerShell</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  The topic of my post has already been raised here, but I have something to add. <br><br>  When our file storage changed the third terabyte, more and more often our department began to receive requests to find out who deleted an important document or a whole folder with documents.  Often this happens by someone else's malicious intent.  Backups are good, but the country should know its heroes.  And milk is doubly delicious when we can write it on PowerShell. <br><br>  While I understood, I decided to write it down for my colleagues, and then I thought that it might be useful to someone else.  The material turned out to be mixed.  Someone will find a ready-made solution for themselves, some non-obvious methods of working with PowerShell or task scheduler will be useful to someone, and someone will check their scripts for speed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the process of finding a solution to the problem, I read <a href="http://habrahabr.ru/post/150149/">an article</a> written by <a href="http://habrahabr.ru/users/deks/" class="user_link">Deks</a> .  I decided to take it as a basis, but some moments did not suit me. <br><ul><li>  Firstly, the time of generating a four-hour report on a 2-terabyte storage, which about 200 people work with at the same time, was about five minutes.  And despite the fact that we don‚Äôt write too much logs.  This is less than the Deks, but more than he would like, because ... </li><li>  Secondly, all the same thing needed to be implemented on another twenty servers, much less productive than the main one. </li><li>  Thirdly, the schedule for generating report generation raised questions. </li><li>  And fourth, I wanted to exclude myself from the process of delivering the collected information to end users (read: automate, so that I would not be called again with this question). </li></ul><br><h5>  <b>But I liked the way of thinking Deks ...</b> </h5><a name="habracut"></a><br>  Concise discourse: When file system auditing is enabled, two events are created in the security log at the time the file is deleted, with codes 4663 and then 4660. The first records the attempt to request access to delete, the user data and the path to the file to be deleted. the fact of removal.  Events have a unique EventRecordID, which differs by one for these two events. <br><br>  Below is the original script that collects information about deleted files and users who deleted them. <br><br><pre><code class="cs hljs">$time = (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>-date) - (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-timespan -min <span class="hljs-number"><span class="hljs-number">240</span></span>) $Events = Get-WinEvent -FilterHashtable @{LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4660</span></span>;StartTime=$time} | Select TimeCreated,@{n=<span class="hljs-string"><span class="hljs-string">""</span></span>;e={([xml]$_.ToXml()).Event.System.EventRecordID}} |sort  $BodyL = <span class="hljs-string"><span class="hljs-string">""</span></span> $TimeSpan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-TimeSpan -sec <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($<span class="hljs-keyword"><span class="hljs-keyword">event</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $events){ $PrevEvent = $Event. $PrevEvent = $PrevEvent - <span class="hljs-number"><span class="hljs-number">1</span></span> $TimeEvent = $Event.TimeCreated $TimeEventEnd = $TimeEvent+$TimeSpan $TimeEventStart = $TimeEvent- (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-timespan -sec <span class="hljs-number"><span class="hljs-number">1</span></span>) $Body = Get-WinEvent -FilterHashtable @{LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4663</span></span>;StartTime=$TimeEventStart;EndTime=$TimeEventEnd} |<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {([xml]$_.ToXml()).Event.System.EventRecordID -match <span class="hljs-string"><span class="hljs-string">"$PrevEvent"</span></span>}|<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>{ ([xml]$_.ToXml()).Event.EventData.Data |<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {$_.name -eq <span class="hljs-string"><span class="hljs-string">"ObjectName"</span></span>}|<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {($_<span class="hljs-number"><span class="hljs-number">.'</span></span><span class="hljs-meta"><span class="hljs-meta">#text') -notmatch ".*tmp"} |where {($_.'#text') -notmatch ".*~lock*"}|where {($_.'#text') -notmatch ".*~$*"}} |select TimeCreated, @{n="_";e={([xml]$_.ToXml()).Event.EventData.Data | ? {$_.Name -eq "ObjectName"} | %{$_.'#text'}}},@{n="_";e={([xml]$_.ToXml()).Event.EventData.Data | ? {$_.Name -eq "SubjectUserName"} | %{$_.'#text'}}} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ($Body -match ".*Secret*"){ $BodyL=$BodyL+$Body.TimeCreated+"`t"+$Body._+"`t"+$Body._+"`n" } } $Month = $Time.Month $Year = $Time.Year $name = "DeletedFiles-"+$Month+"-"+$Year+".txt" $Outfile = "\serverServerLogFilesDeletedFilesLog"+$name $BodyL | out-file $Outfile -append</span></span></code> </pre> <br>  Using the command Measure-Command received the following: <br><br><pre> <code class="cs hljs">Measure-Command { ... } | Select-Object TotalSeconds | Format-List ... TotalSeconds : <span class="hljs-number"><span class="hljs-number">313</span></span>,<span class="hljs-number"><span class="hljs-number">6251476</span></span></code> </pre> <br>  Too much, secondary FS will take longer.  Immediately I didn‚Äôt like the 10-floor pipe, so for a start I structured it: <br><br><pre> <code class="cs hljs">Get-WinEvent -FilterHashtable @{ LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4663</span></span>;StartTime=$TimeEventStart;EndTime=$TimeEventEnd } ` | Where-Object {([xml]$_.ToXml()).Event.System.EventRecordID -match <span class="hljs-string"><span class="hljs-string">"$PrevEvent"</span></span>} ` | Where-Object {([xml]$_.ToXml()).Event.EventData.Data ` | Where-Object {$_.name -eq <span class="hljs-string"><span class="hljs-string">"ObjectName"</span></span>} ` | Where-Object {($_<span class="hljs-number"><span class="hljs-number">.'</span></span><span class="hljs-meta"><span class="hljs-meta">#text') -notmatch ".*tmp"} ` | Where-Object {($_.'#text') -notmatch ".*~lock*"} ` | Where-Object {($_.'#text') -notmatch ".*~$*"} } | Select-Object TimeCreated, @{ n="_"; e={([xml]$_.ToXml()).Event.EventData.Data ` | Where-Object {$_.Name -eq "ObjectName"} ` | ForEach-Object {$_.'#text'} } }, @{ n="_"; e={([xml]$_.ToXml()).Event.EventData.Data ` | Where-Object {$_.Name -eq "SubjectUserName"} ` | ForEach-Object {$_.'#text'} } }</span></span></code> </pre> <br>  It turned out to reduce the number of floors of the pipe and remove Foreach transfers, and at the same time make the code more readable, but it didn‚Äôt give much effect, the difference is within the margin of error: <br><br><pre> <code class="cs hljs">Measure-Command { $time = (Get-Date) - (New-TimeSpan -min <span class="hljs-number"><span class="hljs-number">240</span></span>) $Events = Get-WinEvent -FilterHashtable @{LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4660</span></span>;StartTime=$time}` | Select TimeCreated,@{n=<span class="hljs-string"><span class="hljs-string">"EventID"</span></span>;e={([xml]$_.ToXml()).Event.System.EventRecordID}}` | Sort-Object EventID $DeletedFiles = @() $TimeSpan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-TimeSpan -sec <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($Event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $Events){ $PrevEvent = $Event.EventID $PrevEvent = $PrevEvent - <span class="hljs-number"><span class="hljs-number">1</span></span> $TimeEvent = $Event.TimeCreated $TimeEventEnd = $TimeEvent+$TimeSpan $TimeEventStart = $TimeEvent- (New-TimeSpan -sec <span class="hljs-number"><span class="hljs-number">1</span></span>) $DeletedFiles += Get-WinEvent -FilterHashtable @{LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4663</span></span>;StartTime=$TimeEventStart;EndTime=$TimeEventEnd} ` | Where-Object {` ([xml]$_.ToXml()).Event.System.EventRecordID -match <span class="hljs-string"><span class="hljs-string">"$PrevEvent"</span></span> ` -and (([xml]$_.ToXml()).Event.EventData.Data ` | <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {$_.name -eq <span class="hljs-string"><span class="hljs-string">"ObjectName"</span></span>})<span class="hljs-number"><span class="hljs-number">.'</span></span><span class="hljs-meta"><span class="hljs-meta">#text' ` -notmatch ".*tmp$|.*~lock$|.*~$*" } ` | Select-Object TimeCreated, @{n="FilePath";e={ (([xml]$_.ToXml()).Event.EventData.Data ` | Where-Object {$_.Name -eq "ObjectName"}).'#text' } }, @{n="UserName";e={ (([xml]$_.ToXml()).Event.EventData.Data ` | Where-Object {$_.Name -eq "SubjectUserName"}).'#text' } } ` } } | Select-Object TotalSeconds | Format-List $DeletedFiles | Format-Table UserName,FilePath -AutoSize ... TotalSeconds : 302,6915627</span></span></code> </pre> <br>  I had to think a little head.  What operations take the most time?  It would be possible to stumble a dozen more Measure-Command, but in general, in this case, it is obvious that most of the time is spent on requests to the log (this is not the fastest procedure even in MMC) and on repeated conversions to XML ( however, in the case of EventRecordID, this is not at all necessary).  Let's try to do both one at a time, and at the same time eliminate intermediate variables: <br><br><pre> <code class="cs hljs">Measure-Command { $time = (Get-Date) - (New-TimeSpan -min <span class="hljs-number"><span class="hljs-number">240</span></span>) $Events = Get-WinEvent -FilterHashtable @{LogName=<span class="hljs-string"><span class="hljs-string">"Security"</span></span>;ID=<span class="hljs-number"><span class="hljs-number">4660</span></span>,<span class="hljs-number"><span class="hljs-number">4663</span></span>;StartTime=$time}` | Select TimeCreated,ID,RecordID,@{n=<span class="hljs-string"><span class="hljs-string">"EventXML"</span></span>;e={([xml]$_.ToXml()).Event.EventData.Data}}` | Sort-Object RecordID $DeletedFiles = @() <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($<span class="hljs-function"><span class="hljs-function">Event </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$Events | Where-Object {$_.Id -EQ </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4660</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">))</span></span>{ $DeletedFiles += $Events ` | Where-Object {` $_.Id -eq <span class="hljs-number"><span class="hljs-number">4663</span></span> ` -and $_.RecordID -eq ($Event.RecordID - <span class="hljs-number"><span class="hljs-number">1</span></span>) ` -and ($_.EventXML | <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Name -eq <span class="hljs-string"><span class="hljs-string">"ObjectName"</span></span>)<span class="hljs-number"><span class="hljs-number">.'</span></span><span class="hljs-meta"><span class="hljs-meta">#text'` -notmatch ".*tmp$|.*~lock$|.*~$" } ` | Select-Object ` @{n="RecordID";e={$Event.RecordID}}, TimeCreated, @{n="ObjectName";e={($_.EventXML | where Name -eq "ObjectName").'#text'}}, @{n="UserName";e={($_.EventXML | where Name -eq "SubjectUserName").'#text'}} } } | Select-Object TotalSeconds | Format-List $DeletedFiles | Sort-Object UserName,TimeDeleted | Format-Table -AutoSize -HideTableHeaders ... TotalSeconds : 167,7099384</span></span></code> </pre> <br>  But this is the result.  Acceleration almost doubled! <br><br><h4>  <b>Automating</b> </h4><br>  Glad, and that's enough.  Three minutes is better than five, but what is the best way to run the script?  Once an hour?  So, the entries that appear simultaneously with the launch of the script can slip away.  Make a request not in an hour, but in 65 minutes?  Then the records can be repeated.  And then look for a record of the desired file among the thousands of logs - mutator.  Write once a day?  Rotation of logs will forget half.  Need something more reliable.  In the comments on the Deks article, someone spoke about the application on the dotnet working in the service mode, but this, you know, from the category "There are 14 competing standards" ... <br><br>  In Windows Task Scheduler, you can create a trigger for an event in the system log.  Like this: <br><br><img src="https://habrastorage.org/files/bb9/292/1a0/bb92921a0bde4a9a8e965abc9cb8c56b.png"><br><br>  Fine!  The script will run exactly when the file is deleted, and our log will be created in real time!  But our joy will be incomplete if we can not determine which event we need to record at the time of launch.  We need a trick.  We have them!  A short googling showed that, by the ‚ÄúEvent‚Äù trigger, the scheduler can transmit event information to the executable file.  But this is done, to put it mildly, it is not obvious.  The sequence of actions is as follows: <br><br><ol><li>  Create a task with a trigger of type "Event"; </li><li>  Export task to XML format (via MMC console); </li><li>  Add a new ‚ÄúValueQueries‚Äù branch to the EventTrigger branch with elements describing variables: <br><br><pre> <code class="cs hljs"> &lt;EventTrigger&gt; ... &lt;ValueQueries&gt; &lt;Value name=<span class="hljs-string"><span class="hljs-string">"eventRecordID"</span></span>&gt;Event/System/EventRecordID&lt;/Value&gt; &lt;/ValueQueries&gt; &lt;/EventTrigger&gt;</code> </pre><br>  where ‚ÄúeventRecordID‚Äù is the name of the variable that can be passed to the script, and ‚ÄúEvent / System / EventRecordID‚Äù is the element of the Windows log scheme, which can be found at the link at the bottom of the article.  In this case, it is an element with a unique event number. </li><li>  Import the job back to the scheduler. </li></ol><br>  But we do not want to stumble it all on 20 servers with the mouse, right?  Need to automate.  Unfortunately, PowerShell is not omnipotent, and the New-ScheduledTaskTrigger cmdlet does not yet know how to create triggers like Event.  Therefore, let's apply the cheat code and create the task via the COM object (for now, quite often you have to resort to COM, although the regular cmdlets are able to more and more with each new version of PS): <br><br><pre> <code class="cs hljs">$scheduler = New-Object -ComObject <span class="hljs-string"><span class="hljs-string">"Schedule.Service"</span></span> $scheduler.Connect(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) $rootFolder = $scheduler.GetFolder(<span class="hljs-string"><span class="hljs-string">"\") $taskDefinition = $scheduler.NewTask(0)</span></span></code> </pre> <br>  It is necessary to allow simultaneous start of several instances, and also, it seems to me, it is necessary to prohibit manual start and set the time limit for execution: <br><br><pre> <code class="cs hljs">$taskDefinition.Settings.Enabled = $True $taskDefinition.Settings.Hidden = $False $taskDefinition.Principal.RunLevel = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta"># 0 -  , 1 -   $taskDefinition.Settings.MultipleInstances = $True $taskDefinition.Settings.AllowDemandStart = $False $taskDefinition.Settings.ExecutionTimeLimit = "PT5M"</span></span></code> </pre> <br>  Create a type 0 trigger (Event).  Next, set the XML request to get the events we need.  The XML request code can be obtained in the MMC "Event log" by selecting the necessary parameters and switching to the "XML" tab: <br><br><img src="https://habrastorage.org/files/68e/2ca/102/68e2ca102c3e4edab57c963dacdcef0b.png"><br><br><pre> <code class="cs hljs">$Trigger = $taskDefinition.Triggers.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>) $Trigger.Subscription = <span class="hljs-string"><span class="hljs-string">'&lt;QueryList&gt; &lt;Query Id="0" Path="Security"&gt; &lt;Select Path="Security"&gt; *[System[Provider[@Name="Microsoft-Windows-Security-Auditing"] and EventID=4660]] &lt;/Select&gt; &lt;/Query&gt; &lt;/QueryList&gt;'</span></span></code> </pre> <br>  The main trick: specify the variable that you want to pass to the script. <br><br><pre> <code class="cs hljs">$Trigger.ValueQueries.Create(<span class="hljs-string"><span class="hljs-string">"eventRecordID"</span></span>, <span class="hljs-string"><span class="hljs-string">"Event/System/EventRecordID"</span></span>)</code> </pre> <br>  Actually, the description of the command being executed: <br><br><pre> <code class="cs hljs">$Action = $taskDefinition.Actions.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>) $Action.Path = <span class="hljs-string"><span class="hljs-string">'PowerShell.exe'</span></span> $Action.WorkingDirectory = <span class="hljs-string"><span class="hljs-string">'C:\Temp'</span></span> $Action.Arguments = <span class="hljs-string"><span class="hljs-string">'.\ParseDeleted.ps1 $(eventRecordID) C:\Temp\DeletionLog.log'</span></span></code> </pre> <br>  And - we take off! <br><br><pre> <code class="cs hljs">$rootFolder.RegisterTaskDefinition(<span class="hljs-string"><span class="hljs-string">"Log Deleted Files"</span></span>, $taskDefinition, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'SYSTEM'</span></span>, $<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre> <br><h4>  <b>"The concept has changed"</b> </h4><br>  Let's return to the script for logging.  Now we do not need to receive all the events, but we need to get one and only, and also passed as an argument.  To do this, we will add headers that turn the script into a cmdlet with parameters.  Before the heap, we will make it possible to change the path to the log on the fly, or maybe it will come in handy: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CmdletBinding()</span></span>] Param( [Parameter(Mandatory=$True,Position=<span class="hljs-number"><span class="hljs-number">1</span></span>)]$RecordID, [Parameter(Mandatory=$False,Position=<span class="hljs-number"><span class="hljs-number">2</span></span>)]$LogPath = <span class="hljs-string"><span class="hljs-string">"C:\DeletedFiles.log"</span></span> )</code> </pre> <br>  Then there is a nuance: until now we received events using the Get-WinEvent cmdlet and filtered with the -FilterHashtable parameter.  It understands a limited set of attributes that does not include an EventRecordID.  Therefore, we will be filtering through the -FilterXml parameter, and now we can do it! <br><br><pre> <code class="cs hljs">$XmlQuery=<span class="hljs-string"><span class="hljs-string">"&lt;QueryList&gt; &lt;Query Id='0' Path='Security'&gt; &lt;Select Path='Security'&gt;*[System[(EventID=4663) and (EventRecordID=$($RecordID - 1))]]&lt;/Select&gt; &lt;/Query&gt; &lt;/QueryList&gt;"</span></span> $Event = Get-WinEvent -FilterXml $XmlQuery ` | Select TimeCreated,ID,RecordID,@{n=<span class="hljs-string"><span class="hljs-string">"EventXML"</span></span>;e={([xml]$_.ToXml()).Event.EventData.Data}}`</code> </pre> <br>  Now we no longer need the Foreach-Object enumeration, since only one event is processed.  Not two, because the event with the code 4660 is used only to initiate the script, it does not carry any useful information. <br>  Remember, in the beginning, I wanted users to get to know the villain without my participation?  So, if the file is deleted in the documents folder of any department, we also write the log to the root of the department folder. <br><br><pre> <code class="cs hljs">$EventLine = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (($Event.EventXML | <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Name -eq <span class="hljs-string"><span class="hljs-string">"ObjectName"</span></span>)<span class="hljs-number"><span class="hljs-number">.'</span></span><span class="hljs-meta"><span class="hljs-meta">#text' -notmatch ".*tmp$|.*~lock$|.*~$"){ $EventLine += "$($Event.TimeCreated)`t" $EventLine += "$($Event.RecordID)`t" $EventLine += ($Event.EventXML | where Name -eq "SubjectUserName").'#text' + "`t" $EventLine += ($ObjectName = ($Event.EventXML | where Name -eq "ObjectName").'#text') </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ($ObjectName -match "Documents\"){ $OULogPath = $ObjectName ` -replace "(.*Documents\\\\[^\\]*\\)(.*)",'$1\DeletedFiles.log' </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(Test-Path $OULogPath)){ "DeletionDate`tEventID`tUserName`tObjectPath"| Out-File -FilePath $OULogPath } $EventLine | Out-File -FilePath $OULogPath -Append } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!(Test-Path $LogPath)){ "DeletionDate`tEventID`tUserName`tObjectPath" | Out-File -FilePath $LogPath } $EventLine | Out-File -FilePath $LogPath -Append }</span></span></code> </pre> <br><h5>  <b>Summary cmdlet</b> </h5><br>  Well, the slices are cut, it remains to put everything together and optimize a little more.  It turns out something like this: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CmdletBinding()</span></span>] Param( [Parameter(Mandatory=$True,Position=<span class="hljs-number"><span class="hljs-number">1</span></span>,ParameterSetName=<span class="hljs-string"><span class="hljs-string">'logEvent'</span></span>)][<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]$RecordID, [Parameter(Mandatory=$False,Position=<span class="hljs-number"><span class="hljs-number">2</span></span>,ParameterSetName=<span class="hljs-string"><span class="hljs-string">'logEvent'</span></span>)] [<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]$LogPath = <span class="hljs-string"><span class="hljs-string">"$PSScriptRoot\DeletedFiles.log"</span></span>, [Parameter(ParameterSetName=<span class="hljs-string"><span class="hljs-string">'install'</span></span>)][<span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>]$Install ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($Install) { $service = New-Object -ComObject <span class="hljs-string"><span class="hljs-string">"Schedule.Service"</span></span> $service.Connect(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) $rootFolder = $service.GetFolder(<span class="hljs-string"><span class="hljs-string">"\") $taskDefinition = $service.NewTask(0) $taskDefinition.Settings.Enabled = $True $taskDefinition.Settings.Hidden = $False $taskDefinition.Settings.MultipleInstances = $True $taskDefinition.Settings.AllowDemandStart = $False $taskDefinition.Settings.ExecutionTimeLimit = "</span></span>PT5M<span class="hljs-string"><span class="hljs-string">" $taskDefinition.Principal.RunLevel = 0 $trigger = $taskDefinition.Triggers.Create(0) $trigger.Subscription = ' &lt;QueryList&gt; &lt;Query Id="</span></span><span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-string"><span class="hljs-string">" Path="</span></span>Security<span class="hljs-string"><span class="hljs-string">"&gt; &lt;Select Path="</span></span>Security<span class="hljs-string"><span class="hljs-string">"&gt; *[System[Provider[@Name="</span></span>Microsoft-Windows-Security-Auditing<span class="hljs-string"><span class="hljs-string">"] and EventID=4660]] &lt;/Select&gt; &lt;/Query&gt; &lt;/QueryList&gt;' $trigger.ValueQueries.Create("</span></span>eventRecordID<span class="hljs-string"><span class="hljs-string">", "</span></span>Event/System/EventRecordID<span class="hljs-string"><span class="hljs-string">") $Action = $taskDefinition.Actions.Create(0) $Action.Path = 'PowerShell.exe' $Action.WorkingDirectory = $PSScriptRoot $Action.Arguments = '.\' + $MyInvocation.MyCommand.Name + ' $(eventRecordID) ' + $LogPath $rootFolder.RegisterTaskDefinition("</span></span>Log Deleted Files<span class="hljs-string"><span class="hljs-string">", $taskDefinition, 6, 'SYSTEM', $null, 5) } else { $XmlQuery="</span></span>&lt;QueryList&gt; &lt;Query Id=<span class="hljs-string"><span class="hljs-string">'0'</span></span> Path=<span class="hljs-string"><span class="hljs-string">'Security'</span></span>&gt; &lt;Select Path=<span class="hljs-string"><span class="hljs-string">'Security'</span></span>&gt;*[System[(EventID=<span class="hljs-number"><span class="hljs-number">4663</span></span>) and (EventRecordID=$($RecordID - <span class="hljs-number"><span class="hljs-number">1</span></span>))]]&lt;/Select&gt; &lt;/Query&gt; &lt;/QueryList&gt;<span class="hljs-string"><span class="hljs-string">" $Event = Get-WinEvent -FilterXml $XmlQuery ` | Select TimeCreated,ID,RecordID,@{n="</span></span>EventXML<span class="hljs-string"><span class="hljs-string">";e={([xml]$_.ToXml()).Event.EventData.Data}} if (($ObjectName = ($Event.EventXML | where Name -eq "</span></span>ObjectName<span class="hljs-string"><span class="hljs-string">").'#text') ` -notmatch "</span></span>.*tmp$|.*~<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>$|.*~<span class="hljs-string"><span class="hljs-string">$")</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ $EventLine = </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"$($Event.TimeCreated)`t"</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"$($Event.RecordID)`t"</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> ` + ($Event.EventXML | </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">where</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> Name -eq </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"SubjectUserName"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">.'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">#text</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">' + "`t" ` + $ObjectName if ($ObjectName -match ".*Documents\\\\[^\\]*\\"){ $OULogPath = $Matches[0] + '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">\DeletedFiles.log</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">' if (!(Test-Path $OULogPath)){ "DeletionDate`tEventID`tUserName`tObjectPath"| Out-File -FilePath $OULogPath } $EventLine | Out-File -FilePath $OULogPath -Append } if (!(Test-Path $LogPath)){ "DeletionDate`tEventID`tUserName`tObjectPath" | Out-File -FilePath $LogPath } $EventLine | Out-File -FilePath $LogPath -Append } }</span></span></span></span></span></span></code> </pre> <br>  It remains to place the script in a convenient place for you and run it with the -Install key. <br><br>  Now, employees of any department can see in real time who deleted what and when from their directories.  I note that I did not consider here the right of access to the log files (so that the villain could not remove them) and rotation.  The structure and access rights to the directories on our filer are pulled to a separate article, and the rotation will in some degree complicate the search for the desired line. <br><br><h5>  <b>Used materials:</b> </h5><br>  - The <a href="http://www.powershellcookbook.com/recipe/qAxK/appendix-b-regular-expression-reference">finest reference for regular expressions</a> <br>  - <a href="http://blogs.technet.com/b/otto/archive/2011/08/24/trigger-a-powershell-script-from-a-windows-event.aspx">Tutorial on creating a task associated with an event</a> <br>  - <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383607(v%3Dvs.85).aspx">Description of the task scheduler script API</a> <br><br>  <b>UPD:</b> There was a typo in the final script, after line 41 there was an extra gravis.  For the discovery of gratitude to the reader Habr <b>Ruslan Sultanov</b> . </div><p>Source: <a href="https://habr.com/ru/post/238469/">https://habr.com/ru/post/238469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238453/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 127 (September 22 - 28, 2014)</a></li>
<li><a href="../238457/index.html">The main types of search queries that online store users use, is your website ready for them? (Part 3)</a></li>
<li><a href="../238461/index.html">Why do normal boys need the company's mission - and some cybernetics?</a></li>
<li><a href="../238463/index.html">In search of free tickets, the study of the game Aeroflot</a></li>
<li><a href="../238467/index.html">OpenCL 2.0 and drivers from AMD and Intel</a></li>
<li><a href="../238471/index.html">The new release of ReadyScript introduces the functionality of warehouses.</a></li>
<li><a href="../238473/index.html">Deploying Go Servers with Docker</a></li>
<li><a href="../238475/index.html">Everything you wanted to know about Shellshock vulnerability (but were afraid to ask)</a></li>
<li><a href="../238479/index.html">Automatic Radio Secretary, or ARS, or Arsik (1966)</a></li>
<li><a href="../238481/index.html">Why are quantum mechanics and relativity incompatible?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>