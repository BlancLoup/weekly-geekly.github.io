<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Traveling from Moscow to Kazan through St. Petersburg or the process of developing an algorithm for finding all paths</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This material is published with the expectation of novice programmers and non-specialists ... 

 One evening, after reading books about traveling, it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Traveling from Moscow to Kazan through St. Petersburg or the process of developing an algorithm for finding all paths</h1><div class="post__text post__text-html js-mediator-article">  <i>This material is published with the expectation of novice programmers and non-specialists ...</i> <br><br>  One evening, after reading books about traveling, it seems that it was the famous ‚ÄúJourney from St. Petersburg to Moscow‚Äù by Radishchev and ‚ÄúTarantas‚Äù by Vladimir Sollogub - I sat down to watch a lecture on the Dijkstra algorithm.  I watched, drew something on a piece of paper and drew a oriented graph.  After some thinking, I wondered how I would implement an algorithm for finding all paths from one starting point (a) to some other unique end point (f) on a directed graph. <a name="habracut"></a>  I already began to read about the <a href="https://studfiles.net/preview/5920852/page:3/">search</a> algorithms <a href="https://studfiles.net/preview/5920852/page:3/">in depth and width</a> , but I thought that it would be more interesting to try to "invent" the algorithm again, often because with this approach you can get an interesting modification of the already known algorithm.  At the same time I set myself several conditions: 1) not to use literature;  2) use a non-recursive approach;  3) to store edges in separate arrays, without nesting.  Next, I will try to describe the process of finding the algorithm and its implementation, as usual in PHP. <br><br>  The graph itself turned out like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/6f3/873/34f/6f387334f60d2a7c0195d301e8a4cc13.gif" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general: the input is an oriented graph with six vertices, the task is to find all the paths from <b>a</b> to <b>f</b> without recursion and with minimal expenditures. <br><br>  Edges are stored in several arrays, the name of the array is the top: <br><br><pre><code class="php hljs">$a=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>); $b=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $c=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $d=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $e=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'f'</span></span>);</code> </pre> <br>  To get the first path, I decided to go through the zero indices of each array and merge them into one line <b>x</b> (the found path will be stored in this variable at each stage).  But how to do it with minimal cost?  It seemed to me that the simplest option would be to introduce another array - initializing. <br>  In the array of int all the elements that are in the graph in reverse order. <br><br><pre> <code class="php hljs">$int=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'f'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'a'</span></span>);</code> </pre><br>  Then getting the first path is very simple, just cycle through all the arrays, <br>  add a new value to <b>x</b> using concatenation, and at each stage <b>use an element from the previous array as a pointer to the next array.</b> <br><br>  This style is a bit like bash, but the code looks pretty straightforward: <br><br><pre> <code class="php hljs">$x=<span class="hljs-string"><span class="hljs-string">'a'</span></span>; $z=$a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { $x.=$z; $z=${$z}[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($z == <span class="hljs-string"><span class="hljs-string">'f'</span></span>) {$x.=$z; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ;} }</code> </pre><br>  And so, we got the first path <b>x = abdef</b> . <br><br>  We can bring it to the screen and deal directly with the algorithm itself, since everything that was higher is only a preparatory part.  In theory, it would be possible to get rid of it, but I leave it and publish it so that the train of thought is better understood. <br><br>  We display the first path and run the first function. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $x; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;br&gt;'</span></span>; search_el ($x,$a,$b,$c,$d,$e);</code> </pre><br>  The algorithm itself is actually reduced to two cycles, which are made into separate functions. <br>  The first function takes the previously received first path <b>x</b> .  Further in the loop, the traversal <b>x is</b> performed from right to left.  We are looking for two elements, one of which will be <br>  work as a pointer to an array, another (right, it‚Äôs only worth remembering that the array is upside down) as a pointer to an array element.  Using array_search, find the key of the element and check if there is anything in this array after it.  If there is, then we replace the element with the one found, but before that we cut off the tail (for this, substr is needed).  The replacement can be organized in another way: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search_el</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x, $a, $b, $c, $d, $e)</span></span></span><span class="hljs-function"> </span></span>{ $j = strlen($x); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($j != <span class="hljs-number"><span class="hljs-number">0</span></span>) { $j--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>(${$x[$j - <span class="hljs-number"><span class="hljs-number">1</span></span>]})) $key = array_search($x[$j], ${$x[$j - <span class="hljs-number"><span class="hljs-number">1</span></span>]}); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (${$x[$j - <span class="hljs-number"><span class="hljs-number">1</span></span>]}[$key + <span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">''</span></span>) { $x = substr($x, <span class="hljs-number"><span class="hljs-number">0</span></span>, $j); $x.= ${$x[$j - <span class="hljs-number"><span class="hljs-number">1</span></span>]}[$key + <span class="hljs-number"><span class="hljs-number">1</span></span>]; new_way_search($x, $a, $b, $c, $d, $e); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br>  A condition with isset needs the interpreter not to throw a warning.  It has nothing to do with the algorithm itself.  If no elements were found in the arrays, the algorithm will end, but if the miracle did happen, then we move to a new function, the essence of which is extremely simple - add the tail to <b>x</b> , display it and ... ‚Äúdraw eight‚Äù or loop - return to the function from which we came, but with the new value of <b>x</b> : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_way_search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x, $a, $b, $c, $d, $e)</span></span></span><span class="hljs-function"> </span></span>{ $z = $x[strlen($x) - <span class="hljs-number"><span class="hljs-number">1</span></span>]; $z = ${$z}[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { $x.= $z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($x[strlen($x) - <span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'f'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($z == <span class="hljs-string"><span class="hljs-string">'f'</span></span>) { $x.= $z; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } $z = ${$z}[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $x; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;br /&gt;'</span></span>; search_el($x, $a, $b, $c, $d, $e); }</code> </pre><br>  The result of the algorithm for the graph, which is shown in the figure above: <br><br>  abdef <br>  abdf <br>  abef <br>  abf <br>  acdef <br>  acdf <br>  acef <br>  acf <br>  adef <br>  adf <br><br>  <b>UPDATE:</b> <br>  As a supplement, I will give a brief description of the algorithm obtained: <br>  The edges of the oriented graph are written out in separate arrays in ascending order. <br>  Those.  the vertices of the graph and the edges are ordered.  This is a prerequisite. <br>  Before the start of the algorithm, we find the first path, which, taking into account the first condition, will be with the smallest names of the vertices.  The way of finding is not particularly important. <br><br>  Description for verification on paper: <br>  At the entrance, the first found path is x = abdef: <br><br>  1) Moving from right to left through the array x, select two adjacent elements <br>  (except the last) ab <b>d [e]</b> f, the left (d) is used as a pointer to an array <br>  with vertex, right (e) as a pointer to an element of this array. <br>  We look for an element in d after e, if it exists, remove all elements in x to the right of e.  We get in x = abde.  Replace the right element (e) with the found element. <br><br>  2) We add (by the second cycle) the right side of the element (or the index of the right element), which was replaced before the last element (f).  In this cycle, it is always necessary to take arrays with a 0 index, since arrays are ordered by condition.  In this case, we immediately got on the right side the last element x = abdf, so the second cycle will be idling. <br><br>  3) After the formation of the right side, we return to traversing the array from right to left. <br>  The absence of elements in the first vertex (array a) is the condition of exit from the algorithm. <br><br>  The same code without functions and recursion, the first path in x is given: <br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  $a=array('b','c','d'); $b=array('d','e','f'); $c=array('d','e','f'); $d=array('e'); $e=array('f'); //  $x='abdef'; print $x; print '&lt;br&gt;'; $j=strlen($x); while($j !=0) { //   $key = array_search($x[$j], ${$x[$j-1]}); // ,       if (${$x[$j-1]}[$key+1] != '') { $x=substr($x, 0, $j); $x.= ${$x[$j-1]}[$key+1]; $z=$x[strlen($x)-1]; $z=${$z}[0]; //    c    while (1) { //    f,     if ($x[strlen($x)-1]=='f') {$x.=$z; break ;} $x.=$z; $z=${$z}[0]; } // $j=strlen($x); echo $x; echo '&lt;br&gt;'; } $j--; } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br><br></div></div><br>  PS <br>  Array option: <br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> error_reporting(<span class="hljs-number"><span class="hljs-number">0</span></span>); $a=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'c'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>); $b=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $c=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $d=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'e'</span></span>); $e=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'f'</span></span>); $x=<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,<span class="hljs-string"><span class="hljs-string">'d'</span></span>,<span class="hljs-string"><span class="hljs-string">'e'</span></span>,<span class="hljs-string"><span class="hljs-string">'f'</span></span>); print_r ( $x ); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $j=count($x)<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($j !=<span class="hljs-number"><span class="hljs-number">0</span></span>) { $key = array_search($x[$j], ${$x[$j<span class="hljs-number"><span class="hljs-number">-1</span></span>]}); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (${$x[$j<span class="hljs-number"><span class="hljs-number">-1</span></span>]}[$key+<span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-string"><span class="hljs-string">''</span></span>) { $x=array_slice($x, <span class="hljs-number"><span class="hljs-number">0</span></span>, $j); array_push($x, ${$x[$j<span class="hljs-number"><span class="hljs-number">-1</span></span>]}[$key+<span class="hljs-number"><span class="hljs-number">1</span></span>]); $z=$x[count($x)<span class="hljs-number"><span class="hljs-number">-1</span></span>]; $z=${$z}[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($x[count($x)<span class="hljs-number"><span class="hljs-number">-1</span></span>]==<span class="hljs-string"><span class="hljs-string">'f'</span></span>) { array_push($x, $z); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ;} array_push($x, $z); $z=${$z}[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } $j=count($x); print_r ( $x ); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } $j--; } <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br></div></div><br>  A little about the methodology instead of the conclusion. <br><br>  As a result, the development of such algorithms has turned out to be a rather simple method that can be useful in working with dynamic arrays. <br>  Its general essence is to carry out preparatory actions before launching the main algorithm, in order to simplify the implementation.  This should also make the algorithm more transparent and understandable, which in turn should further contribute to its optimization and simplification. <br><br>  In this case, the technique is divided into three preparatory steps: <br>  1) Determine the presence of order in the data.  Ordering, if necessary. <br>  2) Introduction of an intsializing (vector) array on ordered data. <br>  3) Getting the initial path based on the previous step, the meaning of which also consists in simplifying the basic algorithm.  In this case, the initial path must also be built taking into account the order of the data so that it does not allow any path to pass. <br>  If there is no order on the vertices of the graph, then an additional step may be necessary, redefining the names of the vertices, actually building an isomorphic graph and creating an array of matches (for example, between real city names and letters of the alphabet).  For other cases of algorithmization, the removal of the original path (vector) beyond the limits of cycles was borrowed by me from my past articles on the generation of combinatorial objects: <a href="https://habrahabr.ru/post/330690/">permutations</a> , <a href="https://habrahabr.ru/post/329948/">partitions / compositions</a> , <a href="https://habrahabr.ru/post/311934/">combinations, allocations</a> . <br><br>  If we talk about specific working implementations, then of course, you should carefully study the possibilities of a particular language for working with dynamic data.  In this situation, the use of "variables" to determine the value of one variable as a name for another is only a way to demonstrate the correctness of the algorithm itself.  What are the risks of using this approach in the working environment, the author is unknown. </div><p>Source: <a href="https://habr.com/ru/post/340646/">https://habr.com/ru/post/340646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340630/index.html">Work with Arduino's COM port from a Java application</a></li>
<li><a href="../340632/index.html">Chess for common development: the history of the development program</a></li>
<li><a href="../340634/index.html">We write a simple counter of unique words in Python with a GUI on Tkinter</a></li>
<li><a href="../340638/index.html">Purchase of a modern Intel server with NVMe P4800X</a></li>
<li><a href="../340642/index.html">Add Basic Auth to a SOAP request using ksoap2-android</a></li>
<li><a href="../340650/index.html">Environment for developing TypeScript and React web applications: from 'hello world' to modern SPA. Part 1</a></li>
<li><a href="../340652/index.html">"Star dealer" or computer training in the era of mini-computers</a></li>
<li><a href="../340654/index.html">State Library</a></li>
<li><a href="../340660/index.html">Pixel adventure: create a clone of Lemmings in Unity</a></li>
<li><a href="../340664/index.html">Combination of labor in software development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>