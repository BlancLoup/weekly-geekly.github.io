<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing the k-means algorithm on c # (with a generalized metric)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Continuing the topic that Andrew Ng did not have time to tell in the course on machine learning , I will give an example of my own implementati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing the k-means algorithm on c # (with a generalized metric)</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Continuing the <a href="http://habrahabr.ru/post/146236/">topic</a> that Andrew Ng did not have time to tell in the course on <a href="http://class.coursera.org/ml">machine learning</a> , I will give an example of my own implementation of the <a href="http://ru.wikipedia.org/wiki/K-means">k-means</a> algorithm.  My task was to implement the clustering algorithm, but I needed to take into account the degree of correlation between the quantities.  I decided to use the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259C%25D0%25B0%25D1%2585%25D0%25B0%25D0%25BB%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B1%25D0%25B8%25D1%2581%25D0%25B0">Mahalanobis distance</a> as a metric, I note that the size of the data for clustering is not so large, and there was no need to do caching of clusters to disk.  For implementation, please under the cat. <br><br><a name="habracut"></a><br><br><h4>  Problem </h4><br>  To begin, consider the problem, why not just replace the Euclidean distance with any other metric.  The k-means algorithm uses two parameters for input: the data for clustering and the number of clusters into which the data should be split.  The algorithm consists of the following steps. <br><ol><li>  Initial initialization of cluster centroids in some way (for example, you can set initial values ‚Äã‚Äãby randomly selected points from the space in which data is defined; random points can be selected from the input data array, etc.). </li><li>  E-step ( <a href="http://ru.wikipedia.org/wiki/EM-%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">expectation</a> ): an association occurs between data elements and clusters, which are represented as their centers (centroids). </li><li>  M-step ( <a href="http://ru.wikipedia.org/wiki/EM-%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">maximization</a> ): centers of clusters are recalculated as average values ‚Äã‚Äãof data that were included with the corresponding cluster (or, in other words, the model parameters are modified in such a way as to maximize the probability that the element will fall into the selected cluster).  If the cluster after step 2 was empty, then it is reinitialized in some other way. </li><li>  Steps 2-3 are repeated until convergence, or until another criterion for stopping the algorithm is reached (for example, if a certain number of iterations is exceeded). </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For understanding mathematics, which is behind this simple algorithm, I advise you to read articles on <a href="https://www.google.ru/search%3Fq%3Dbayes%2Bclustering">Bayesian clustering</a> and <a href="http://ru.wikipedia.org/wiki/EM-%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">the expectation-maximization algorithm</a> . <br><br>  The problem of replacing the Euclidean distance by another metric is in the M-step.  For example, if we have textual data and use <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein distance</a> as a metric, then finding the average value is not an entirely trivial task.  For me, even finding the Mahalanobis average was not a quickly solvable problem, but I was lucky and I came across <a href="http://infolab.stanford.edu/~ullman/mmds/ch7.pdf">an article</a> that described a very simple way to select the ‚Äúcentroid‚Äù, and I did not have to puzzle over the Mahalanobis average value.  In quotation marks, because the exact value of the centroid is not searched for, but its approximate value is chosen, which in that article is called clusteroid (or, by analogy with <a href="http://en.wikipedia.org/wiki/K-medoids">k-medoids,</a> it can be called a medoid).  Thus, the maximization step is replaced by the following algorithm. <br><br><ul><li>  M-step: among all data elements that were assigned to the centroid, the element is selected for which the sum of the distances to all other cluster elements is minimal;  this element becomes the new cluster center. </li></ul><br>  <i>By the way, for me the question of convergence is still open, but the good, there are many ways to stop the algorithm at some suboptimal solution.</i>  <i>In this implementation, we will stop the algorithm if the cost function begins to grow.</i> <br><br>  The cost function for the current partition will use the following formula: <img src="https://habrastorage.org/getpro/habr/post_images/daa/b5a/94e/daab5a94ea2dbe47c36ac402e82ef434.gif" alt="image">  where K is the number of clusters, <img src="https://habrastorage.org/getpro/habr/post_images/c62/187/246/c62187246dff3580f950dce639244afe.gif" alt="image">  - the current center of the cluster, <img src="https://habrastorage.org/getpro/habr/post_images/e44/856/f3a/e44856f3aed591308df330bed19e0c01.gif" alt="image">  - the set of elements assigned to cluster k, and <img src="https://habrastorage.org/getpro/habr/post_images/ae5/4de/1df/ae54de1df116da549cdeb83b01066200.gif" alt="image">  - i-th element of the cluster k. <br><br>  Regarding the search for the average distance, it is worth noting that if the metric function is continuous and differentiable, then to search for the clusteroid you can use <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA">the gradient descent algorithm</a> , which minimizes the following cost function: <img src="https://habrastorage.org/getpro/habr/post_images/823/1ea/c72/8231eac7277a5843dde8c5e69c9f44cb.gif" alt="image">  , where X's are elements related to the current cluster.  I plan to consider this option in the next article, but for now in the implementation we will take into account that some method will soon add its own way to search for a centroid / clusteroid. <br><br><h4>  Metrics </h4><br>  First, let's create a general metric representation and then implement the common logic and concrete implementation of several metrics. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMetrics</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] v1, T[] v2</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">T[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCentroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;T[]&gt; data</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><br>  Thus, the metric is abstracted from the data type and we will be able to implement it both the Euclidean distance between the numerical vectors and the Levenshtein distance between the lines and sentences. <br><br>  Now we will create a base class for metrics in which we implement the function of searching for the clusteroid using a simple method described above. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MetricsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IMetrics</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] v1, T[] v2</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCentroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;T[]&gt; data</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Data is null"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Data is empty"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] dist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[data.Count][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { dist[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[data.Count]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; data.Count; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == j) { dist[i][j] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dist[i][j] = Math.Pow(Calculate(data[i], data[j]), <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist[j] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { dist[j] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[data.Count]; } dist[j][i] = dist[i][j]; } } } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minSum = Double.PositiveInfinity; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestIdx = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; data.Count; j++) { dSum += dist[i][j]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dSum &lt; minSum) { minSum = dSum; bestIdx = i; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data[bestIdx]; } }</code> </pre><br><br>  In the GetCentroid method, we are looking for an element for which the sum of squares of distances to the remaining data elements is minimal.  First we create a symmetric matrix, in which the elements contain the distances between the corresponding data elements.  Using the properties of metrics: d (x, x) = 0 and d (x, y) = d (y, x), we can safely fill the diagonal with zeros and reflect the matrix along the main diagonal.  Then we sum up in the lines and we look for the minimum value. <br><br>  For example, let's create an implementation of the distances of Mahalanobis and Euclid. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MahalanobisDistanse</span></span> : <span class="hljs-title"><span class="hljs-title">MetricsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">double</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[][] _covMatrixInv = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MahalanobisDistanse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] covMatrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isInversed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isInversed) { _covMatrixInv = LinearAlgebra.InverseMatrixGJ(covMatrix); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _covMatrixInv = covMatrix; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Calculate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] v2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v1.Length != v2.Length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Vectors dimensions are not same"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || v2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"Vector dimension can't be 0"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v1.Length != _covMatrixInv.Length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"CovMatrix and vectors have different size"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] delta = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[v1.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v1.Length; i++) { delta[i] = v1[i] - v2[i]; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] deltaS = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[v1.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; deltaS.Length; i++) { deltaS[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; v1.Length; j++) { deltaS[i] += delta[j]*_covMatrixInv[j][i]; } } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v1.Length; i++) { d += deltaS[i]*delta[i]; } d = Math.Sqrt(d); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; } }</code> </pre><br><br>  As you can see from the code, the GetCentroid method is not redefined, although in the next article I will try to override this method with a gradient descent algorithm. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EuclideanDistance</span></span> : <span class="hljs-title"><span class="hljs-title">MetricsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">double</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EuclideanDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> IMetrics Members public override double Calculate(double[] v1, double[] v2) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (v1.Length != v2.Length) { throw new ArgumentException("Vectors dimensions are not same"); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (v1.Length == 0 || v2.Length == 0) { throw new ArgumentException("Vector dimension can't be 0"); } double d = 0; for (int i = 0; i &lt; v1.Length; i++) { d += (v1[i] - v2[i]) * (v1[i] - v2[i]); } return Math.Sqrt(d); } public override double[] GetCentroid(IList&lt;double[]&gt; data) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (data.Count == 0) { throw new ArgumentException("Data is empty"); } double[] mean = new double[data.First().Length]; for (int i = 0; i &lt; mean.Length; i++) { mean[i] = 0; } foreach (double[] item in data) { for (int i = 0; i &lt; item.Length; i++) { mean[i] += item[i]; } } for (int i = 0; i &lt; mean.Length; i++) { mean[i] = mean[i]/data.Count; } return mean; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><br>  In the implementation of the Euclidean distance, the GetCentroid method is redefined, and searches for the exact centroid value: the average values ‚Äã‚Äãof each of the coordinates are calculated. <br><br><h4>  Clustering </h4><br><br>  Let's proceed to the implementation of the clustering algorithm.  Again, first create an interface for clustering algorithms. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClusterization</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">ClusterizationResult&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeClusterization</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;DataItem&lt;T&gt;&gt; data</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><br>  Where the result of clustering is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClusterizationResult</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;T[]&gt; Centroids { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;T[], IList&lt;DataItem&lt;T&gt;&gt;&gt; Clusterization { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Cost { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><br>  And the item class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataItem</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[] _input = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[] _output = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] input, T[] output</span></span></span><span class="hljs-function">)</span></span> { _input = input; _output = output; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T[] Input { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _input; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T[] Output { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _output; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _output = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br><br>  We are interested only in the Input property, since  it is learning without a teacher. <br><br>  Let us turn to the implementation of the k-means algorithm using the above interfaces. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">KMeans</span></span> : <span class="hljs-title"><span class="hljs-title">IClusterization</span></span>&lt;<span class="hljs-title"><span class="hljs-title">double</span></span>&gt;</code> </pre><br><br>  The following data is fed into the clustering algorithm (I have reduced my code a little so as not to bother with the initialization methods of the initial centroids, we will use random initialization of points, we can afford it here, because we cluster the <code><code>IClusterization): <br> clusterCount -        <code>IMetrics metrics -   </code> <br></code></code> numerical data <code><code>IClusterization): <br> clusterCount -        <code>IMetrics metrics -   </code> <br></code></code> <code><code>IClusterization): <br> clusterCount -        <code>IMetrics metrics -   </code> <br></code></code> <ul><li> <code><code>IClusterization): <br> clusterCount</code> -        <code>IMetrics metrics -   </code> <br></code> </li> <li> <code><code>IClusterization): <br> clusterCount</code> -        <code>IMetrics metrics -   </code> <br></code> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/146556/">https://habr.com/ru/post/146556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146551/index.html">Wired vs Wireless Firewall, Hole196, marketing versus common sense and all-all</a></li>
<li><a href="../146552/index.html">Implement TDD with django and postgres</a></li>
<li><a href="../146553/index.html">The taskbar is locked to your operating system.</a></li>
<li><a href="../146554/index.html">Mojolicious 3.0</a></li>
<li><a href="../146555/index.html">"Board of shame" with users, issuing private information</a></li>
<li><a href="../146557/index.html">Samsung Apps Screenshots</a></li>
<li><a href="../146560/index.html">Node v0.8.0</a></li>
<li><a href="../146561/index.html">RIM: We are creating a brand new product. And we are ready to conquer the world with him again</a></li>
<li><a href="../146562/index.html">Poster "Modern Web Standards"</a></li>
<li><a href="../146563/index.html">Brackets - Open Source IDE for web development from Adobe.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>