<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to get convenient access to XAML-resources from Code-Behind</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to tell you how to work with XAML-resources from Code-Behind as much as possible. In this article, we will understand how XAML namespaces work,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to get convenient access to XAML-resources from Code-Behind</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4f2/144/897/4f2144897c874c2da9e3dc53095b5e50.png"><br><br>  I want to tell you how to work with XAML-resources from Code-Behind as much as possible.  In this article, we will understand how XAML namespaces work, learn about the <i>XmlnsDefinitionAttribute</i> , use the T4 templates, and generate a static class to access the XAML resources. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  When working with XAML, <i>ResourceDictionary</i> is widely used to organize resources: styles, brushes, converters.  Consider a resource declared in App.xaml: <br><br><pre><code class="cs hljs">&lt;Application.Resources&gt; &lt;SolidColorBrush x:Key=<span class="hljs-string"><span class="hljs-string">"HeaderBrush"</span></span> Color=<span class="hljs-string"><span class="hljs-string">"Black"</span></span> /&gt; &lt;Application.Resources&gt;</code> </pre> <br>  When the layout of the View this resource will be used as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs">&lt;TextBlock x:Name=<span class="hljs-string"><span class="hljs-string">"header"</span></span> Foreground=<span class="hljs-string"><span class="hljs-string">"{StaticResource HeaderBrush}"</span></span> /&gt;</code> </pre><br>  When it is necessary to use the same resource from Code-Behind, the following is usually applied: <br><br><pre> <code class="cs hljs">header.Foreground = (SolidColorBrush)Application.Current.Resources[<span class="hljs-string"><span class="hljs-string">"HeaderBrush"</span></span>];</code> </pre><br>  There are a number of flaws in it: a string identifier (key) of a resource increases the likelihood of an error, and with a large number of resources, you will most likely have to go into xaml and recall this key.  Another unpleasant trifle is the cast to SolidColorBrush.  all resources are stored as object. <br><br>  These shortcomings can be eliminated with the help of code generation, eventually this construction will turn out: <br><br><pre> <code class="cs hljs">header.Foreground = AppResources.HeaderBrush;</code> </pre><br>  Immediately, I‚Äôll make a reservation that since the purpose of the article is to show the approach itself, for simplicity, I focus on a single App.xaml file, but if you like, simple modifications will allow you to process all XAML resources in a project and even decompose them into separate files. <br><br>  Create a T4 template: <br><br><img src="https://habrastorage.org/files/9f1/1f8/16f/9f11f816f4b94c20b38cda1fdf26b01e.png"><br><br>  If you are not very familiar with T4, you can read <a href="http://habrahabr.ru/post/64895/">this article</a> . <br><br>  We use the standard for T4 header: <br><br><pre> <code class="cs hljs">&lt;<span class="hljs-meta"><span class="hljs-meta">#@ template debug="false" hostSpecific="true" language="C#" #&gt; &lt;#@ output extension=".cs" #&gt;</span></span></code> </pre><br>  Setting <i>hostSpecific = true is</i> necessary in order to have access to the <i>Host</i> property of the <i>TextTransformation</i> class, from which the class of the T4 template is inherited.  With the help of <i>Host, the</i> project file structure and some other necessary data will be accessed. <br><br>  All resources will be collected in one static class with static readonly Property.  The main skeleton of the template looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> &lt;#=ProjectDefaultNamespace<span class="hljs-meta"><span class="hljs-meta">#&gt; { public static class AppResources { &lt;# foreach (var resource in ResourcesFromFile("/App.xaml")) { OutputPropery(resource); } #&gt; } }</span></span></code> </pre><br>  All auxiliary functions and properties involved in the script are declared in the <i>&lt;# + #&gt;</i> section after the main body of the script. <br><br>  The first property <i>VsProject</i> selects a project from Solution, in which the script itself lies: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> VSProject _vsProject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> VSProject VSProject { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_vsProject == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceProvider = (IServiceProvider) Host; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dte = (DTE)serviceProvider.GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (DTE)); _vsProject = (VSProject)dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject.Object; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _vsProject; } }</code> </pre><br>  <i>ProjectDefaultNamespace</i> - project namespace: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _projectDefaultNamespace; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ProjectDefaultNamespace { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_projectDefaultNamespace == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) _projectDefaultNamespace = VSProject.Project.Properties.Item(<span class="hljs-string"><span class="hljs-string">"DefaultNamespace"</span></span>).Value.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _projectDefaultNamespace; } }</code> </pre><br>  All the basic work of collecting resources from XAML is done by <i>ResourcesFromFile (string filename)</i> .  In order to understand how it works, let's take a closer look at how namespaces, prefixes, and how they are used are arranged in XAML. <br><br><h4>  Namespaces and Prefixes in XAML </h4><br>  To uniquely identify a specific type in C #, you must fully specify the name of the type along with the namespace in which it is declared: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> control = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomNamespace.CustomControl();</code> </pre><br>  Using using the above construction can be written shorter: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CustomNamespace; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> control = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomControl();</code> </pre><br>  XAML namespaces work in the same way.  XAML is a subset of XML and uses namespace declaration rules from XML. <br><br>  The <i>CustomControl</i> type in XAML will be declared like this: <br><br><pre> <code class="cs hljs">&lt;local:CustomControl /&gt;</code> </pre><br>  In this case, the XAML parser looks at the <i>local</i> prefix when parsing the document, which describes where to look for the given type. <br><br><pre> <code class="cs hljs">xmlns:local=<span class="hljs-string"><span class="hljs-string">"clr-namespace:CustomNamespace"</span></span></code> </pre><br>  The reserved attribute name, <i>xmlns</i> , indicates that it is an XML namespace declaration.  The prefix name (in this case ‚Äú <i>local</i> ‚Äù) can be anything within the rules of the XML markup.  And also it may be absent altogether, then the namespace declaration takes the form: <br><br><pre> <code class="cs hljs">xmlns=<span class="hljs-string"><span class="hljs-string">"clr-namespace:CustomNamespace"</span></span></code> </pre><br>  This entry sets the default namespace for elements declared without prefixes.  If, for example, the <i>CustomNamespace</i> namespace is declared by default, then <i>CustomControl</i> can be used without the prefix: <br><br><pre> <code class="cs hljs">&lt;CustomControl /&gt;</code> </pre><br>  In the example above, the value of the <i>xmlns</i> attribute contains the <i>clr-namespace</i> tag, immediately followed by a reference to the .net namespace.  Thanks to this, the XAML parser understands that he needs to look for <i>CustomControl</i> in the <i>CustomNamespace</i> namespace. <br><br>  Types that are included in the SDK, for example, <i>SolidColorBrush</i> are declared without a prefix. <br><br><pre> <code class="cs hljs">&lt;SolidColorBrush Color=<span class="hljs-string"><span class="hljs-string">"Red"</span></span> /&gt;</code> </pre><br>  This is possible because the default namespace is declared in the root element of the XAML document: <br><br><pre> <code class="cs hljs">xmlns=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></code> </pre><br>  This is the second way to declare a namespace in XAML.  The value of the <i>xmlns</i> attribute is some unique alias string, it does not contain a <i>clr-namespace</i> .  When the XAML parser encounters such an entry, it checks the project's .net assembly for the <i>XmlnsDefinitionAttribute</i> attribute. <br><br>  The <i>XmlnsDefinitionAttribute</i> attribute changes to an assembly many times describing the namespaces corresponding to the alias string: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: XmlnsDefinition(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"System.Windows"</span></span></span><span class="hljs-meta">)</span></span>] [assembly: XmlnsDefinition(<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.Windows.Media"</span></span>)] [assembly: XmlnsDefinition(<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span>, <span class="hljs-string"><span class="hljs-string">"System.Windows.Shapes"</span></span>)]</code> </pre><br>  The <i>System.WIndows</i> assembly is tagged with many such attributes, so alias <i><a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation">schemas.microsoft.com/winfx/2006/xaml/presentation</a></i> includes many namespaces from the standard SDK such as System.Windows, System.Windows.Media, etc. .  This allows you to map an XML namespace to a set of namespaces from .net <br><br>  It is worth noting that if there are types with the same name in two namespaces combined under one alias, a collision will occur, and the XAML analyzer will not be able to make out where it will take the desired type. <br><br>  So now we know that XAML namespaces are mapped to .net namespaces in two different ways: one to one when using <i>clr-namespace</i> and one to many when using alias. <br><br>  The <i>xmlns</i> construct is usually found in the root element of a XAML document, but in fact it is enough for <i>xmlns to</i> be declared at least at the same level at which it is used.  In the case of <i>CustomControl, the</i> following entry is possible: <br><br><pre> <code class="cs hljs">&lt;local:CustomControl xmlns:local=<span class="hljs-string"><span class="hljs-string">"clr-namespace:CustomNamespace"</span></span> /&gt;</code> </pre><br>  All of the above will be needed to create a script that can correctly understand the <i>ReosurceDictionary</i> XAML markup, which can contain heterogeneous objects included in the SDK, as well as components of third-party libraries that use different namespace declarations. <br><br><h4>  Let's start the main part </h4><br>  The task of determining the full type name from a XAML tag is assigned to the <i>ITypeResolver</i> interface: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITypeResolver</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveTypeFullName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> localTagName</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Since there are two types of namespace declarations, there are two implementations of this interface: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExplicitNamespaceResolver</span></span> : <span class="hljs-title"><span class="hljs-title">ITypeResolver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _singleNamespace; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExplicitNamespaceResolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleNamespace</span></span></span><span class="hljs-function">)</span></span> { _singleNamespace = singleNamespace; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveTypeFullName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> localTagName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _singleNamespace + <span class="hljs-string"><span class="hljs-string">"."</span></span> + localTagName; } }</code> </pre><br>  This implementation handles the case where the .net namespace is specified explicitly using clr-namespace. <br><br>  The other case is the <i>XmlnsAliasResolver</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">XmlnsAliasResolver</span></span> : <span class="hljs-title"><span class="hljs-title">ITypeResolver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Assembly&gt;&gt; _registeredNamespaces = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Assembly&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlnsAliasResolver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VSProject project, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">alias</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> project.References.OfType&lt;Reference&gt;() .Where(r =&gt; r.Path.EndsWith(<span class="hljs-string"><span class="hljs-string">".dll"</span></span>, StringComparison.InvariantCultureIgnoreCase))) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.ReflectionOnlyLoadFrom(reference.Path); _registeredNamespaces.AddRange(assembly.GetCustomAttributesData() .Where(attr =&gt; attr.AttributeType.Name == <span class="hljs-string"><span class="hljs-string">"XmlnsDefinitionAttribute"</span></span> &amp;&amp; attr.ConstructorArguments[<span class="hljs-number"><span class="hljs-number">0</span></span>].Value.Equals(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>)) .Select(attr =&gt; Tuple.Create(attr.ConstructorArguments[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value.ToString(), assembly))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveTypeFullName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> localTagName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _registeredNamespaces.Select(i =&gt; i.Item2.GetType(i.Item1 + <span class="hljs-string"><span class="hljs-string">"."</span></span> + localTagName)).First(i =&gt; i != <span class="hljs-literal"><span class="hljs-literal">null</span></span>).FullName; } }</code> </pre><br>  <i>The XmlnsAliasResolver</i> registers within itself the namespaces marked with the <i>XmlnsDefinitionAttribute</i> attribute with a specific alias, and the assemblies in which they are declared.  Searches are performed in each registered namespace until a result is found. <br><br>  Optionally, you can add caching of found types to the implementation of <i>ResolveTypeFullName</i> . <br><br>  The <i>TypeResolvers</i> helper method parses the XAML document, finds all namespaces and maps them to the XML prefix, and the output is the dictionary <i>Dictionary &lt;string, ITypeResolver&gt;</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Dictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">, ITypeResolver&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TypeResolvers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">XmlDocument xmlDocument</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resolvers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, ITypeResolver&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> namespaces = xmlDocument.SelectNodes(<span class="hljs-string"><span class="hljs-string">"//namespace::*"</span></span>).OfType&lt;XmlNode&gt;().Distinct().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nmsp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> namespaces) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = Regex.Match(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"{0}=\"{1}\""</span></span>, nmsp.Name, nmsp.Value), <span class="hljs-string"><span class="hljs-string">@"xmlns:(?&lt;prefix&gt;\w*)=""((clr-namespace:(?&lt;namespace&gt;[\w.]*))|([^""]))*"""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> namespaceGroup = match.Groups[<span class="hljs-string"><span class="hljs-string">"namespace"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefix = match.Groups[<span class="hljs-string"><span class="hljs-string">"prefix"</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(prefix)) prefix = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resolvers.ContainsKey(prefix)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (namespaceGroup != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; namespaceGroup.Success) { <span class="hljs-comment"><span class="hljs-comment">//  namespace resolvers.Add(prefix, new ExplicitNamespaceResolver(namespaceGroup.Value)); } else { //Alias    XmlnsDefinitionAttribute resolvers.Add(prefix, new XmlnsAliasResolver(VSProject, nmsp.Value)); } } return resolvers; }</span></span></code> </pre><br>  Using xpath - <i>"// namespace :: *"</i> selects all namespaces declared at any levels of the document.  Then each namespace is parsed by the regular expression into the prefix and the .net namespace, specified after <i>clr-namespace</i> , if it exists.  According to the results, either <i>ExplicitNamespaceResolver</i> or <i>XmlnsAliasResolver is created</i> and mapped to a prefix or default prefix. <br><br>  The <i>ResourcesFromFile</i> method puts everything together: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Resource[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResourcesFromFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xmlDocument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlDocument(); xmlDocument.Load(Path.GetDirectoryName(VSProject.Project.FileName) + filename); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeResolvers = TypeResolvers(xmlDocument); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nsmgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlNamespaceManager(xmlDocument.NameTable); nsmgr.AddNamespace(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceNodes = xmlDocument.SelectNodes(<span class="hljs-string"><span class="hljs-string">"//*[@x:Key]"</span></span>, nsmgr).OfType&lt;XmlNode&gt;().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Resource&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> resourceNodes) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefix = GetPrefix(resourceNode.Name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localName = GetLocalName(resourceNode.Name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resourceName = resourceNode.SelectSingleNode(<span class="hljs-string"><span class="hljs-string">"./@x:Key"</span></span>, nsmgr).Value; result.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Resource(resourceName, typeResolvers[prefix].ResolveTypeFullName(localName))); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.ToArray(); }</code> </pre><br><br>  After the XAML document is loaded and typeResolvers are initialized, the <i>namespace</i> <i>schemas.microsoft.com/winfx/2006/xaml is</i> added to the xpath to work properly in the <i><a href="http://schemas.microsoft.com/winfx/2006/xaml">XmlNamespaceManager</a></i> , which all attribute attributes point to in the <i>ResourceDictionary</i> . <br><br>  When using xpath - <i>"// * [@ x: Key]"</i> , objects with an attribute-key are selected from all levels of the XAML document.  Next, the script runs over all the objects found and using the ‚Äúdictionary‚Äù <i>typeResolvers</i> assigns the full name of the .net type to each. <br><br>  The output is an array of <i>Resource</i> structures that contain all the necessary data for code generation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Resource { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Key { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Type { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resource</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Key = key; Type = type; } }</code> </pre><br>  And finally, a method that displays the resulting <i>Resource</i> as text: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutputPropery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Resource resource</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#&gt; private static bool _&lt;#=resource.Key #&gt;IsLoaded; private static &lt;#=resource.Type #&gt; _&lt;#=resource.Key #&gt;; public static &lt;#=resource.Type #&gt; &lt;#=resource.Key #&gt; { get { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!_&lt;#=resource.Key #&gt;IsLoaded) { _&lt;#=resource.Key #&gt; = (&lt;#=resource.Type #&gt;)Application.Current.Resources["&lt;#=resource.Key #&gt;"]; _&lt;#=resource.Key #&gt;IsLoaded = true; } return _&lt;#=resource.Key #&gt;; } } &lt;#+ }</span></span></code> </pre><br>  It is worth noting that the <i>Key</i> property returns the value of the key attribute from XAML as is, and using keys with characters that are not valid for declaring properties in C # will result in an error.  In order not to complicate the already large pieces of code, I deliberately leave the implementation of getting safe for Property names at your discretion. <br><br><h4>  Conclusion </h4><br>  This script works in WPF-, Silverlight-, WindowsPhone-projects.  As for the WindowsRT family, UniversalApps, in the next articles we will take a look at <i>XamlTypeInfo.g.cs</i> , talk about <i>IXamlMetadataProvider</i> , which replaced the <i>XmlnsDefinitionAttribute</i> and let the script work with UniversalApps. <br><br>  Under the spoiler you can find the full script code, copy to your project, use it with pleasure. <br><br><div class="spoiler">  <b class="spoiler_title">Full script code</b> <div class="spoiler_text"><pre> <code class="cs hljs">&lt;<span class="hljs-meta"><span class="hljs-meta">#@ template debug="false" hostSpecific="true" language="C#" #&gt; &lt;#@ assembly name="System.Windows" #&gt; &lt;#@ assembly name="System.Core" #&gt; &lt;#@ assembly name="System.Linq" #&gt; &lt;#@ assembly name="System.Core" #&gt; &lt;#@ assembly name="System.Xml" #&gt; &lt;#@ assembly name="System.Xml.Linq" #&gt; &lt;#@ assembly name="EnvDTE" #&gt; &lt;#@ assembly name="VSLangProj" #&gt; &lt;#@ import namespace="EnvDTE" #&gt; &lt;#@ import namespace="System.IO" #&gt; &lt;#@ import namespace="System.Linq" #&gt; &lt;#@ import namespace="System.Reflection" #&gt; &lt;#@ import namespace="System.Collections.Generic" #&gt; &lt;#@ import namespace="System.Xml" #&gt; &lt;#@ import namespace="System.Text.RegularExpressions" #&gt; &lt;#@ import namespace="VSLangProj" #&gt; &lt;#@ output extension=".cs" #&gt; using System.Windows; namespace &lt;#=ProjectDefaultNamespace#&gt; { public static class AppResourcess { &lt;# foreach (var resource in ResourcesFromFile("/App.xaml")) { OutputPropery(resource); } #&gt; } } &lt;#+ public void OutputPropery(Resource resource) { #&gt; private static bool _&lt;#=resource.Key #&gt;IsLoaded; private static &lt;#=resource.Type #&gt; _&lt;#=resource.Key #&gt;; public static &lt;#=resource.Type #&gt; &lt;#=resource.Key #&gt; { get { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!_&lt;#=resource.Key #&gt;IsLoaded) { _&lt;#=resource.Key #&gt; = (&lt;#=resource.Type #&gt;)Application.Current.Resources["&lt;#=resource.Key #&gt;"]; _&lt;#=resource.Key #&gt;IsLoaded = true; } return _&lt;#=resource.Key #&gt;; } } &lt;#+ } private VSProject _vsProject; public VSProject VSProject { get { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_vsProject == null) { var serviceProvider = (IServiceProvider) Host; var dte = (DTE)serviceProvider.GetService(typeof (DTE)); _vsProject = (VSProject)dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject.Object; } return _vsProject; } } private string _projectDefaultNamespace; public string ProjectDefaultNamespace { get { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_projectDefaultNamespace == null) _projectDefaultNamespace = VSProject.Project.Properties.Item("DefaultNamespace").Value.ToString(); return _projectDefaultNamespace; } } public struct Resource { public string Key { get; private set; } public string Type { get; private set; } public Resource(string key, string type) : this() { Key = key; Type = type; } } public Resource[] ResourcesFromFile(string filename) { var xmlDocument = new XmlDocument(); xmlDocument.Load(Path.GetDirectoryName(VSProject.Project.FileName) + filename); var typeResolvers = TypeResolvers(xmlDocument); var nsmgr = new XmlNamespaceManager(xmlDocument.NameTable); nsmgr.AddNamespace("x", "http://schemas.microsoft.com/winfx/2006/xaml"); var resourceNodes = xmlDocument.SelectNodes("//*[@x:Key]", nsmgr).OfType&lt;XmlNode&gt;().ToArray(); var result = new List&lt;Resource&gt;(); foreach (var resourceNode in resourceNodes) { var prefix = GetPrefix(resourceNode.Name); var localName = GetLocalName(resourceNode.Name); var resourceName = resourceNode.SelectSingleNode("./@x:Key", nsmgr).Value; result.Add(new Resource(resourceName, typeResolvers[prefix].ResolveTypeFullName(localName))); } return result.ToArray(); } public Dictionary&lt;string, ITypeResolver&gt; TypeResolvers(XmlDocument xmlDocument) { var resolvers = new Dictionary&lt;string, ITypeResolver&gt;(); var namespaces = xmlDocument.SelectNodes("//namespace::*").OfType&lt;XmlNode&gt;().Distinct().ToArray(); foreach (var nmsp in namespaces) { var match = Regex.Match(string.Format("{0}=\"{1}\"", nmsp.Name, nmsp.Value), @"xmlns:(?&lt;prefix&gt;\w*)=""((clr-namespace:(?&lt;namespace&gt;[\w.]*))|([^""]))*"""); var namespaceGroup = match.Groups["namespace"]; var prefix = match.Groups["prefix"].Value; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (string.IsNullOrEmpty(prefix)) prefix = ""; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (resolvers.ContainsKey(prefix)) continue; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (namespaceGroup != null &amp;&amp; namespaceGroup.Success) { //  namespace resolvers.Add(prefix, new ExplicitNamespaceResolver(namespaceGroup.Value)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { //Alias    XmlnsDefinitionAttribute resolvers.Add(prefix, new XmlnsAliasResolver(VSProject, nmsp.Value)); } } return resolvers; } public interface ITypeResolver { string ResolveTypeFullName(string localTagName); } public class ExplicitNamespaceResolver : ITypeResolver { private string _singleNamespace; public ExplicitNamespaceResolver(string singleNamespace) { _singleNamespace = singleNamespace; } public string ResolveTypeFullName(string localTagName) { return _singleNamespace + "." + localTagName; } } public class XmlnsAliasResolver : ITypeResolver { private readonly List&lt;Tuple&lt;string, Assembly&gt;&gt; _registeredNamespaces = new List&lt;Tuple&lt;string, Assembly&gt;&gt;(); public XmlnsAliasResolver(VSProject project, string alias) { foreach (var reference in project.References.OfType&lt;Reference&gt;() .Where(r =&gt; r.Path.EndsWith(".dll", StringComparison.InvariantCultureIgnoreCase))) { try { var assembly = Assembly.ReflectionOnlyLoadFrom(reference.Path); _registeredNamespaces.AddRange(assembly.GetCustomAttributesData() .Where(attr =&gt; attr.AttributeType.Name == "XmlnsDefinitionAttribute" &amp;&amp; attr.ConstructorArguments[0].Value.Equals(alias)) .Select(attr =&gt; Tuple.Create(attr.ConstructorArguments[1].Value.ToString(), assembly))); } catch {} } } public string ResolveTypeFullName(string localTagName) { return _registeredNamespaces.Select(i =&gt; i.Item2.GetType(i.Item1 + "." + localTagName)).First(i =&gt; i != null).FullName; } } string GetPrefix(string xamlTag) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (string.IsNullOrEmpty(xamlTag)) throw new ArgumentException("xamlTag is null or empty", "xamlTag"); var strings = xamlTag.Split(new[] {":"}, StringSplitOptions.RemoveEmptyEntries); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(strings.Length &lt;2) return ""; return strings[0]; } string GetLocalName(string xamlTag) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (string.IsNullOrEmpty(xamlTag)) throw new ArgumentException("xamlTag is null or empty", "xamlTag"); var strings = xamlTag.Split(new[] {":"}, StringSplitOptions.RemoveEmptyEntries); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(strings.Length &lt;2) return xamlTag; return strings[1]; } #&gt;</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/249105/">https://habr.com/ru/post/249105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249095/index.html">Data Center per billion or "Super Ring" for the "Wild West"</a></li>
<li><a href="../249097/index.html">New GHOST vulnerability threatens popular Linux distributions</a></li>
<li><a href="../249099/index.html">Warming data centers</a></li>
<li><a href="../249101/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.14 of 6</a></li>
<li><a href="../249103/index.html">Curves Beziers de Castelgio. HTML5 Canvas</a></li>
<li><a href="../249107/index.html">ReactJS for stupid people</a></li>
<li><a href="../249113/index.html">Categories</a></li>
<li><a href="../249115/index.html">How we made a mod under the Oculus Rift for World of Tanks</a></li>
<li><a href="../249117/index.html">Proxy server for free internet</a></li>
<li><a href="../249119/index.html">Xclaim - ‚Äúnoisy‚Äù * Wi-Fi invasion of small business</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>