<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GO Download Manager Development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multi-threaded download manager for GO. 

 http://loafter.github.io/godownloader/ 
 https://github.com/Loafter/godownloader 


 Introduction 
 Long ag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GO Download Manager Development</h1><div class="post__text post__text-html js-mediator-article">  Multi-threaded download manager for GO. <br><br>  <a href="http://loafter.github.io/godownloader">http://loafter.github.io/godownloader/</a> <br>  <a href="https://github.com/Loafter/godownloader">https://github.com/Loafter/godownloader</a> <br><img src="https://habrastorage.org/files/6a6/364/894/6a636489487a42f1810e10d61b0a91e8.jpeg"><br><br><h4>  Introduction </h4><br>  Long ago, in the year 1998, I used a modem at my father‚Äôs work to access the Internet.  He turned it on in the evening after work and I could enjoy the Internet at a speed of 31.2 kbit / s.  At that time there were no hysterical bloggers, the pages were not weighed in megabytes, and in news sites they spoke only the truth.  Naturally, the main interest was resources.  Pictures, programs, any additions to games, like machines.  As I remember now, downloading via IE was a real hell.  Download file weighing more than 500 kb was simply impossible, the ancient donkey was much more stubborn. <br><a name="habracut"></a><br>  At that time there were a lot of download managers like Getright, Go! Zilla, Download Accelerator and, of course, FlashGet.  At that time, 90% of them were overloaded with advertising shit, the best was FlashGet.  He could beat the downloadable file and worked smartly.  As I remember, version 1.7 was the last.  I used this version in those days. <br>  15 years have passed and it took me to download a large amount of data via vpn from overseas. <br>  And what has changed in 15 years? <br>  Never mind.  Still there are all the same managers with minimal changes.  Even flashget left version 1.7 along with the newfangled 3.xx. <br>  After the wxfast download failed to download a 50 gigabyte file, I decided to try to write my download manager, which would include many multithreaded tasks with the ability to control the degree of execution, stop at any time, and save the state of downloads between application launches.  All this is a great challenge for the GO language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Wrapper </h4><br>  Where to begin?  The first thing we need is to be able to stop the download and receive information about the download at any time.  GO has lightweight streams that can be used in our program.  That is, at least one stream will be with us for downloading, another for managing the process (stopping, starting download, getting information on the progress).  If there are no problems with the process of obtaining information about the downloaded data (we can get them by reference through the streams), then with the process of stopping the download, everything is a little more complicated, we cannot stop or kill another goroutine.  But we can send her a signal to exit the stream.  Actually so we will do.  We implement a simple wrapper, which would allow to create arbitrary discrete work with the possibility of pause and obtain information about the status of work. <br>  In order to wrap any structure, it is necessary that it support the following interface: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DiscretWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { DoWork() (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, error) GetProgress() <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} BeforeRun() error AfterStop() error }</code> </pre> <br>  The wrapper itself: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mw *MonitoredWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wgoroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"info: work start"</span></span>, mw.GetId()) mw.wgrun.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Print(<span class="hljs-string"><span class="hljs-string">"info: release work guid "</span></span>, mw.GetId()) mw.wgrun.Done() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> newState := &lt;-mw.chsig: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newState == Stopped { mw.state = newState log.Println(<span class="hljs-string"><span class="hljs-string">"info: work stopped"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { isdone, err := mw.Itw.DoWork() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"error: guid"</span></span>, mw.guid, <span class="hljs-string"><span class="hljs-string">" work failed"</span></span>, err) mw.state = Failed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isdone { mw.state = Completed log.Println(<span class="hljs-string"><span class="hljs-string">"info: work done"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mw *MonitoredWorker)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mw.lc.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> mw.lc.Unlock() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mw.state == Completed { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"error: try run completed job"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mw.state == Running { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"error: try run runing job"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := mw.Itw.BeforeRun(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { mw.state = Failed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } mw.chsig = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) mw.state = Running <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> mw.wgoroute() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  After starting the stream, wgoroute (), in the loop, the function executes each iteration step by step by calling the DoWork () method. If an error occurs during the execution of the work, the function exits the loop and ends the stream.  Also in the loop sampling from the channel. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> newState := &lt;-mw.chsig: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newState == Stopped { mw.state = newState log.Println(<span class="hljs-string"><span class="hljs-string">"info: work stopped"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br>  If a Stopped message arrives, the algorithm exits the stream and sets the appropriate state. <br>  We use the test tools built into the language to test the wrapper: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">package</span></span> dtest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( "<span class="hljs-title"><span class="hljs-title">errors</span></span>" "<span class="hljs-title"><span class="hljs-title">fmt</span></span>" "<span class="hljs-title"><span class="hljs-title">godownloader</span></span>/<span class="hljs-title"><span class="hljs-title">monitor</span></span>" "<span class="hljs-title"><span class="hljs-title">log</span></span>" "<span class="hljs-title"><span class="hljs-title">math</span></span>/<span class="hljs-title"><span class="hljs-title">rand</span></span>" "<span class="hljs-title"><span class="hljs-title">testing</span></span>" "<span class="hljs-title"><span class="hljs-title">time</span></span>" ) type TestWorkPool struct { From, id, To int32 } func (<span class="hljs-title"><span class="hljs-title">tw</span></span> <span class="hljs-type"><span class="hljs-type">TestWorkPool</span></span>) GetProgress() interface{} { return tw.From } func (<span class="hljs-title"><span class="hljs-title">tw</span></span> *<span class="hljs-type"><span class="hljs-type">TestWorkPool</span></span>) BeforeRun() error { log.Println("<span class="hljs-title"><span class="hljs-title">info</span></span>: <span class="hljs-title"><span class="hljs-title">exec</span></span> <span class="hljs-title"><span class="hljs-title">before</span></span> <span class="hljs-title"><span class="hljs-title">run</span></span>") return nil } func (<span class="hljs-title"><span class="hljs-title">tw</span></span> *<span class="hljs-type"><span class="hljs-type">TestWorkPool</span></span>) AfterStop() error { log.Println("<span class="hljs-title"><span class="hljs-title">info</span></span>: <span class="hljs-title"><span class="hljs-title">after</span></span> <span class="hljs-title"><span class="hljs-title">stop</span></span>") return nil } func (<span class="hljs-title"><span class="hljs-title">tw</span></span> *<span class="hljs-type"><span class="hljs-type">TestWorkPool</span></span>) DoWork() (<span class="hljs-title"><span class="hljs-title">bool</span></span>, <span class="hljs-title"><span class="hljs-title">error</span></span>) { time.Sleep(<span class="hljs-title"><span class="hljs-title">time</span></span>.<span class="hljs-type"><span class="hljs-type">Millisecond</span></span> * 300) tw.From += 1 log.Print(<span class="hljs-title"><span class="hljs-title">tw</span></span>.<span class="hljs-type"><span class="hljs-type">From</span></span>) if tw.From == tw.To { fmt.Println("<span class="hljs-title"><span class="hljs-title">done</span></span>") return true, nil } if tw.From &gt; tw.To { return false, errors.New("<span class="hljs-title"><span class="hljs-title">tw</span></span>.<span class="hljs-type"><span class="hljs-type">From</span></span> &gt; <span class="hljs-title"><span class="hljs-title">tw</span></span>.<span class="hljs-type"><span class="hljs-type">To</span></span>") } return false, nil } func TestWorkerPool(<span class="hljs-title"><span class="hljs-title">t</span></span> *<span class="hljs-title"><span class="hljs-title">testing</span></span>.<span class="hljs-type"><span class="hljs-type">T</span></span>) { wp := monitor.WorkerPool{} for i := 0; i &lt; 20; i++ { mw := &amp;monitor.MonitoredWorker{Itw: &amp;TestWorkPool{From: 0, To: 20, id: rand.Int31()}} wp.AppendWork(<span class="hljs-title"><span class="hljs-title">mw</span></span>) } wp.StartAll() time.Sleep(<span class="hljs-title"><span class="hljs-title">time</span></span>.<span class="hljs-type"><span class="hljs-type">Second</span></span>) log.Println("<span class="hljs-comment"><span class="hljs-comment">------------------Work Started------------------") log.Println(wp.GetAllProgress()) log.Println("------------------Get All Progress--------------") time.Sleep(time.Second) wp.StopAll() log.Println("------------------Work Stop-------------------") time.Sleep(time.Second) wp.StartAll() time.Sleep(time.Second * 5) wp.StopAll() wp.StartAll() wp.StopAll() }</span></span></code> </pre><br><h4>  Data loading </h4><br>  After we have created a working wrapper for tasks, we can proceed to the main function - download data via http.  Probably the main problem of the http protocol is low speed when loading data into one stream.  That is why, when the Internet was slow, there were so many download managers who knew how to split the downloaded file into fragments and download them into several http connections, thereby achieving a speed gain.  Naturally, our download manager is not an exception, he should also be able to take a file in several streams.  For normal operation of this scheme, it is necessary that the server supports resuming. <br><br>  On the client side, a request must be formed that has a Range field in the header.  The whole raw request looks like this: <br><br><pre> <code class="html hljs xml">GET /PinegrowLinux64.2.2.zip HTTP/1.1 Host: pinegrow.s3.amazonaws.com User-Agent: Go-http-client/1.1 Range: bytes=34010904-42513630</code> </pre><br>  My first implementation worked extremely slowly.  The thing is that for each small portion of the data a request was prepared;  if it was necessary to download a segment from 1 to 2 megabytes in blocks of 100 kb.  this meant that 10 requests for each block were executed successively.  I quickly realized that something was wrong. <br>  In the wireshark program, I checked how the download is performed by another program - download master.  The correct scheme of work was different.  If we need to download 10 segments, we first prepared 10 http-requests for each segment, and the division into blocks was implemented by sequential reading from the body block within one http-response. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pd *PartialDownloader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeforeDownload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//create new req r, err := http.NewRequest("GET", pd.url, nil) if err != nil { return err } r.Header.Add("Range", "bytes="+strconv.FormatInt(pd.dp.Pos, 10)+"-"+strconv.FormatInt(pd.dp.To, 10)) f,_:=iotools.CreateSafeFile("test") r.Write(f) f.Close() resp, err := pd.client.Do(r) if err != nil { log.Printf("error: error download part file%v \n", err) return err } //check response if resp.StatusCode != 206 { log.Printf("error: file not found or moved status:", resp.StatusCode) return errors.New("error: file not found or moved") } pd.req = *resp return nil } ‚Ä¶. func (pd *PartialDownloader) DownloadSergment() (bool, error) { //write flush data to disk buffer := make([]byte, FlushDiskSize, FlushDiskSize) count, err := pd.req.Body.Read(buffer) if (err != nil) &amp;&amp; (err.Error() != "EOF") { pd.req.Body.Close() pd.file.Sync() return true, err } //log.Printf("returned from server %v bytes", count) if pd.dp.Pos+int64(count) &gt; pd.dp.To { count = int(pd.dp.To - pd.dp.Pos) log.Printf("warning: server return to much for me i give only %v bytes", count) } realc, err := pd.file.WriteAt(buffer[:count], pd.dp.Pos) if err != nil { pd.file.Sync() pd.req.Body.Close() return true, err } pd.dp.Pos = pd.dp.Pos + int64(realc) pd.messureSpeed(realc) //log.Printf("writed %v pos %v to %v", realc, pd.dp.Pos, pd.dp.To) if pd.dp.Pos == pd.dp.To { //ok download part complete normal pd.file.Sync() pd.req.Body.Close() pd.dp.Speed = 0 log.Printf("info: download complete normal") return true, nil } //not full download next segment return false, nil }</span></span></code> </pre><br>  By wrapping the bootloader class in the DiscretWork interface from the previous part of the note, we can try to test its work: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestDownload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { dl, err := httpclient.CreateDownloader(<span class="hljs-string"><span class="hljs-string">"http://pinegrow.s3.amazonaws.com/PinegrowLinux64.2.2.zip"</span></span>, <span class="hljs-string"><span class="hljs-string">"PinegrowLinux64.2.2.zip"</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Error(<span class="hljs-string"><span class="hljs-string">"failed: can't create downloader"</span></span>) } errs := dl.StartAll() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(errs)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> { t.Error(<span class="hljs-string"><span class="hljs-string">"failed: can't start downloader"</span></span>) } ‚Ä¶..wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> finish download }</code> </pre><br><h4>  Interface </h4><br>  For quite a long time, I have been doing all my services on go in the same way.  As a rule, a web-interface through which the user interacts with the json-service through http-requests.  Such a scheme of work gives a number of advantages over the traditional graphic interests listed below. <br><ul><li>  Ability to automatically add new downloads; </li><li>  No binding to a specific operating system, just a browser is enough. </li></ul><br><br>  The interface is updated every 500 milliseconds.  The pseudo-file <a href="">localhost / progress.json is</a> used as the data source for the download table.  If you open it in the browser, it will open dynamically updated json-data.  The jgrid is used as a table component.  Due to its simplicity, the code takes up very little space. <br><br><img src="http://loafter.github.io/godownloader/images/new.png" alt="image"><br><img src="https://habrastorage.org/files/6a6/364/894/6a636489487a42f1810e10d61b0a91e8.jpeg"><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">"#jqGrid"</span></span>) .jqGrid({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'http://localhost:9981/progress.json'</span></span>, <span class="hljs-attr"><span class="hljs-attr">mtype</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">ajaxSubgridOptions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">async</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">styleUI</span></span>: <span class="hljs-string"><span class="hljs-string">'Bootstrap'</span></span>, <span class="hljs-attr"><span class="hljs-attr">datatype</span></span>: <span class="hljs-string"><span class="hljs-string">"json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">colModel</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Id'</span></span>, <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, ‚Ä¶.. { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'Speed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Speed'</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">formatter</span></span>: FormatByte }, { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'Progress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Progress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">formatter</span></span>: FormatProgressBar }], <span class="hljs-attr"><span class="hljs-attr">viewrecords</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">rowNum</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">pager</span></span>: <span class="hljs-string"><span class="hljs-string">"#jqGridPager"</span></span> }); }</code> </pre><br><h4>  Finishing the service and saving the settings </h4><br>  There is another interesting feature of the service about which I would like to tell.  This is how the web service ends.  The fact is that when the http service starts, the program hangs on the start function and hangs until we finish the application.  But Go has the ability to subscribe to signals sent by the operating system.  Thus, we can intercept the moment when our process terminates, even if we do it through the kill command and perform some final actions.  For example, this is the preservation of settings and the current progress of downloads. <br><br><pre> <code class="go hljs">c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> os.Signal, <span class="hljs-number"><span class="hljs-number">1</span></span>) signal.Notify(c, os.Interrupt) signal.Notify(c, syscall.SIGTERM) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-c <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { gdownsrv.StopAllTask() log.Println(<span class="hljs-string"><span class="hljs-string">"info: save setting "</span></span>, gdownsrv.SaveSettings(getSetPath())) }() os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) }()</code> </pre><br>  There are many extensions to the standard go implementation of the http service that allow you to perform any actions after the service is completed.  In my opinion, the method described above is the most simple and reliable, this method works even if we kill the service. <br><br>  In principle, this is probably all that I wanted to convey to readers. <br><br>  I don‚Äôt know how relevant the download manager is for others, but I‚Äôm already downloading the distributions and images of virtual machines with the help of my download manager. <br>  But I check the checksums from time to time. <br><br>  Download release for Mac, Windows, Linux: <a href="http://loafter.github.io/godownloader/">http://loafter.github.io/godownloader/</a> <br><br>  Git: <a href="https://github.com/Loafter/godownloader">https://github.com/Loafter/godownloader</a> </div><p>Source: <a href="https://habr.com/ru/post/267943/">https://habr.com/ru/post/267943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267929/index.html">Macroscop video surveillance and analytics in detail</a></li>
<li><a href="../267931/index.html">Cybercriminals kidnapped fingerprints 5.6 million US civil servants</a></li>
<li><a href="../267933/index.html">Microsoft Speech and Streaming Audio</a></li>
<li><a href="../267935/index.html">How to monitor the appearance of inappropriate content on your site</a></li>
<li><a href="../267939/index.html">The continuation of the candy problem (or, once again, the Central Limit Theorem)</a></li>
<li><a href="../267945/index.html">Google mobile tips and resources</a></li>
<li><a href="../267947/index.html">DDoS attacks and e-commerce: modern approaches to protection</a></li>
<li><a href="../267949/index.html">Practical training in pentest laboratories. Part 4</a></li>
<li><a href="../267951/index.html">Blocks. Inside the Cach√© database file</a></li>
<li><a href="../267953/index.html">About UEFI security, part five</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>