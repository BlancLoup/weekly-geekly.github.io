<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional programming and c ++ in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Functional programming (further OP) is now in fashion. Articles, books, blogs. At each conference there are necessarily presentations where people tal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional programming and c ++ in practice</h1><div class="post__text post__text-html js-mediator-article">  Functional programming (further OP) is now in fashion.  Articles, books, blogs.  At each conference there are necessarily presentations where people talk about the beauty and convenience of the functional approach.  For a long time I looked at him from afar, but it was time to try to put it into practice.  After reading a fair amount of theory and putting the big picture in my head, I decided to write a small application in a functional style.  Since at the moment I am a c ++ programmer, I will use this wonderful language.  I will take as a basis the code from my <a href="https://habrahabr.ru/post/321106/">previous article</a> , i.e.  My example would be a simplified 2D simulation of physical bodies. <br><a name="habracut"></a><br><h3>  Statement </h3><br>  I am by no means an expert.  My goal was to try to understand the OP and its scope.  In this article, I will describe step by step how I turned OOP code into a kind of functional using c ++.  Of the functional programming languages, I had experience only with Erlang.  In other words, here I will describe the process of my training - perhaps it will help someone.  And of course, I welcome constructive criticism and comments.  I even insist that you leave comments - what I did wrong, what can be improved. <br><br><h3>  Introduction </h3><br>  In the article, I will not tell the theory of FP - there is a great variety of material in the network, including on the habr.  Although I tried to bring the program closer to a pure OP, I could not do it 100%.  In some cases, due to inexpediency, in some - due to lack of experience.  For example, the render is made in the usual OOP style.  Why?  Because one of the principles of FP is immutable data (immutable data) and the lack of state.  But for DirectX (the API I use) you need to store buffers, textures, devices.  Of course, it is possible to create everything anew each frame, but it will be damn long (we‚Äôll talk about performance at the end of the article).  Another example is that in LF, lazy evaluation is often used.  But I did not find a place in the program to use them, so you will not find them. <br><br><h3>  Main </h3><br>  The source code is in <a href="https://github.com/nikitablack/cpp-tests/tree/c442af0ac5c5e6cc297adc5482614f05d777b81a/functional">this commit</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything starts in the <code>main()</code> function - here we create the shapes ( <code>struct Shape</code> ) and run an infinite loop, where we will update the simulation.  Immediately you should pay attention to the design of the code - I write the function in a separate cpp file and declare it <code>extern</code> in the place of use - so I don‚Äôt need to create a separate header file or even a separate type, which positively affects the compilation time and generally makes the code more readable: one function - one file. <br><br>  So, in the main function, we created a data set and now we need to pass it on to the <code>updateSimulation()</code> function. <br><br><h3>  Update Simulation </h3><br>  This is the heart of our program and precisely the part to which the FP was applied.  The signature looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; updateSimulation(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shapes, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height);</code> </pre> <br>  We accept a copy of the original data and return the new vector with the modified data.  But why a copy, and not a constant link?  After all, I wrote above that one of the principles of FP is the immutability of data and <code>const reference</code> guarantees this.  This is true, but the next most important principle is the purity of functions (pure function) - i.e.  no side effects and a guarantee that the function will return the same values ‚Äã‚Äãwith the same input data.  But, receiving the link, we cannot guarantee this.  Let us consider an example.  Suppose we have some function that accepts a constant link: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> accumulate(data.begin(), data.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  And call this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result{foo(data)};</code> </pre> <br>  Although <code>foo()</code> accepts <code>const &amp;</code> , the data itself is not constant, which means that it can be changed before and at the time of the call to <code>accumulate()</code> , for example, by another thread.  That is why all the data should come as a copy. <br><br>  In addition, in order to maintain the principle of data immutability, all fields of all user types must be constants.  This is, for example, the class of a vector: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y; Vec2(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> y = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : x{ x }, y{ y } {} <span class="hljs-comment"><span class="hljs-comment">// member functions }</span></span></code> </pre> <br>  As you can see, the state is set when the object is created and never changes!  Those.  even a state can be called a stretch - just a data set. <br><br>  Let's go back to our <code>updateSimulation()</code> function.  It is called as follows: <br><br><pre> <code class="cpp hljs">shapes = updateSimulation(dtStep, move(shapes), wSize.x, wSize.y);</code> </pre> <br>  It uses the semantics of the move ( <code>std::move()</code> ) - this allows you to get rid of unnecessary copies.  In our case, however, this has no effect, since  we operate on primitive types, and moving is equivalent to copying. <br><br>  There is another interesting point - our function returns a new data set, which we assign to the old variable <code>shapes</code> , which, in fact, is a violation of the principle of lack of state.  However, I believe that we can change the local variable without fear - it will not affect the result of the function, since  this change remains encapsulated inside this function. <br><br>  The function body looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">updateSimulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; updateSimulation(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shapes, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> height) { <span class="hljs-comment"><span class="hljs-comment">// step 1 - update calculate current positions vector&lt;Shape&gt; const updatedShapes1{ calculatePositionsAndBounds(dt, move(shapes)) }; // step 2 - for each shape calculate cells it fits in uint32_t rows; uint32_t columns; tie(rows, columns) = getNumberOfCells(width, height); // auto [rows, columns] = getNumberOfCells(width, height); - c++17 structured bindings - not supported in vs2017 at the moment of writing vector&lt;Shape&gt; const updatedShapes2{ calculateCellsRanges(width, height, rows, columns, move(updatedShapes1)) }; // step 3 - put shapes in corresponding cells vector&lt;vector&lt;Shape&gt;&gt; const cellsWithShapes{ fillGrid(width, height, rows, columns, updatedShapes2) }; // step 4 - calculate collisions vector&lt;VelocityAfterImpact&gt; const velocityAfterImpact{ solveCollisions(move(cellsWithShapes), columns) }; // step 5- apply velocities vector&lt;Shape&gt; const updatedShapes3{ applyVelocities(move(updatedShapes2), velocityAfterImpact) }; return updatedShapes3; }</span></span></code> </pre> <br></div></div><br>  Here we again receive copies of the data and return a copy of the changed data.  In my opinion, the code looks very clear and easy to understand - here we call function by function, passing modified data like a pipeline. <br><br>  Next, I will describe the simulation algorithm itself and how I had to modify it to fit into the functional style, but without formulas.  Therefore it should be interesting. <br><br><h3>  Calculate Positions And Bounds </h3><br>  Another clean function that works with a copy of the data and returns new ones.  As follows: <br><br><div class="spoiler">  <b class="spoiler_title">calculatePositionsAndBounds</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; calculatePositionsAndBounds(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shapes) { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; updatedShapes; updatedShapes.reserve(shapes.size()); for_each(shapes.begin(), shapes.end(), [dt, &amp;updatedShapes](Shape <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shape) { Shape <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newShape{ shape.id, shape.vertices, calculatePosition(shape, dt), shape.velocity, shape.bounds, shape.cellsRange, shape.color, shape.massInverse }; updatedShapes.emplace_back(newShape.id, newShape.vertices, newShape.position, newShape.velocity, calculateBounds(newShape), newShape.cellsRange, newShape.color, newShape.massInverse); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatedShapes; }</code> </pre> <br></div></div><br>  The standard library has been supporting the OP for many years.  The <code>for_each</code> algorithm is a higher order function, i.e.  function that accepts other functions.  In general, <code>stl</code> very rich in algorithms, so knowledge of the library is very important if you write in a functional style. <br><br>  In the following code there are a couple of interesting points.  The first is a link to a vector in the lambda capture list.  Yes, I tried to do without links at all, but in this place it is just necessary.  And, as I wrote above, this should not violate the principles, since  the link is taken to a local vector, i.e.  closed to the outside world.  Here one could do without it, using the <code>for</code> loop, but I went in the direction of visualization and readability. <br><br>  The second point is related to the cycle itself.  Again, since there should be no states, there should be no cycles, because the loop counter is a state.  There are no cycles in pure FP; they are replaced by recursion.  Let's try rewriting a function using it: <br><br><div class="spoiler">  <b class="spoiler_title">calculatePositionsAndBounds</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; updateOne(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; shapes, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; updatedShapes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shapes.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Shape shape{ shapes.back() }; shapes.pop_back(); Shape <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newShape{ shape.id, shape.vertices, calculatePosition(shape, dt), shape.velocity, shape.bounds, shape.cellsRange, shape.color, shape.massInverse }; updatedShapes.emplace_back(newShape.id, newShape.vertices, newShape.position, newShape.velocity, calculateBounds(newShape), newShape.cellsRange, newShape.color, newShape.massInverse); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updatedShapes; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updateOne(dt, move(shapes), move(updatedShapes)); } <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; calculatePositionsAndBounds(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dt, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Shape&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shapes) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> updateOne(dt, move(shapes), {}); }</code> </pre> <br></div></div><br>  We got rid of the links!  But instead of one function, there are two.  And, most importantly, readability has deteriorated (at least, for me - a man who grew up in a traditional PLO).  An interesting point - here we use the so-called tail recursion (tail recursion) - in theory, in this case, the stack should be cleared.  However, I did not find in the c ++ standard records of such behavior, so I can not guarantee the absence of stack overflow.  Considering all the above, I decided to dwell on cycles and you will not see more recursion in this article. <br><br><h3>  Calculate Cells Ranges and Fill Grid </h3><br>  To speed up the calculations, I use a 2D grid divided into cells.  Being in this grid, an object can occupy several cells, as shown in the picture: <br><br><img src="https://habrastorage.org/files/c5d/dac/9ec/c5ddac9ecf1f4329a519ca6ad3d27855.png" alt="image"><br><br>  The function <code>calculateCellsRanges()</code> calculates the cells occupied by the figure and returns the changed data. <br><br>  In the <code>fillGrid()</code> function, we fill each cell (in our example, the cell is just <code>std::vector</code> ) with corresponding shapes.  Those.  if the cell contains nothing, an empty vector will be returned.  Later in the code, we will run through each cell, and check inside it every figure with each other for intersection.  But in the figure you can see that figure <code>a</code> and figure <code>b</code> are (besides other cells) both in cell 2 and cell 5. This means that the check will be performed twice.  Therefore, we will add logic that will say whether verification is necessary.  Knowing the rows and columns make it trivial. <br><br><h3>  Solve collisions </h3><br>  In my <a href="https://habrahabr.ru/post/321106/">previous article</a> I used the following technique - if it turned out that the objects overlapped, we moved them away from each other. <br><br><img src="https://habrastorage.org/files/ca9/63b/aca/ca963baca42f4a43999e272e250566a5.png" alt="image"><br><br>  Those.  we made it so that the objects <code>a</code> and <code>b</code> ceased to touch.  This added a lot of complexity - you had to re-calculate the bounding box every time we moved an object.  To avoid multiple rearrangements, we introduced a special battery, into which we put all the permutations, and later used this battery only once.  One way or another, we had to introduce mutexes for synchronization, the code was complicated and in this form was not suitable for a functional approach.  In a new attempt, we will not move objects at all, moreover, we will produce calculations only if they are really necessary.  In the picture, for example, calculations are not needed, because  figure <code>b</code> moves faster than figure <code>a</code> , i.e.  they move away from each other, and sooner or later they will no longer come into contact without our participation.  Of course, this is physically implausible, but if the speeds are small and / or a small simulation step is used, then it looks quite normal.  If calculations are needed, we consider the changes in the velocities that occurred during the collision and return these speeds together with the figure identifier. <br><br><h3>  Apply Velocities </h3><br>  With speed changes in hand, the <code>applyVelocities()</code> function simply summarizes them and applies them to the object.  Again, the plausibility is not in question and, quite possibly, artifacts will appear under certain conditions, but I did not notice problems with this approach on my test data.  And the goal of the experiment was not at all plausible. <br><br><h3>  Result </h3><br>  After these simple steps we will have new data that we will pass on to the renderer.  Then all over again, and so on to infinity.  As proof, it all works here is a short video: <br><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/mhhjrqtw8_8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  The code is in <a href="https://github.com/nikitablack/cpp-tests/tree/c442af0ac5c5e6cc297adc5482614f05d777b81a/functional">this commit</a> . <br><br><h3>  Conclusion </h3><br>  AF requires a restructuring of thinking.  But is it worth it?  Here are my pros and cons. <br><br>  Behind: <br><br><ul><li>  Readability code.  Together with <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP, the</a> code is very easy to understand. </li><li>  Testability  Since the result of the function does not depend on the environment, we already have everything necessary for testing. </li><li>  In my opinion - the most important point.  Great parallelization capability.  Each (yes, every!) Function in our example can be called multiple threads safely!  No synchronization tools! </li></ul><br>  Vs: <br><br><ul><li>  Only one fly in the ointment ‚Äî not even a spoon, a ladle.  Performance.  Remember, in the <a href="https://habrahabr.ru/post/321106/">last article</a> in one stream with a 2D grid, we could simulate 8000 figures.  Now only 330. Three hundred and thirty, Karl! </li></ul><br>  I worked for ten years in game devise, trying to squeeze the maximum out of each line.  For the 3D engine, a functional approach in the form in which suicide was undoubtedly presented today.  However, c ++ is not only game dev.  I can not say for sure, but intuition suggests that for most applications, the AF will prove to be quite a competitive technique. <br><br>  With a few techniques in hand, why not try to combine them?  In my next article I will try to cross the OOP, DOD and OP.  I do not know the result, but I already see places where you can significantly increase productivity.  So stay in touch - it should be interesting. </div><p>Source: <a href="https://habr.com/ru/post/324518/">https://habr.com/ru/post/324518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324508/index.html">Machine learning in Avito. Video recordings from the Data Science Case Club meeting on March 14</a></li>
<li><a href="../324510/index.html">Badoo time-series storage: so she was called Cassandra</a></li>
<li><a href="../324512/index.html">Fighting beaver with donkey, or Adapting MSVC code under gcc</a></li>
<li><a href="../324514/index.html">Parametric modeling in CAD SolveSpace: Sketch</a></li>
<li><a href="../324516/index.html">Event for Unity-developers in Kharkov</a></li>
<li><a href="../324522/index.html">Guess the filter by impulse response</a></li>
<li><a href="../324524/index.html">Spring aggravation: design school in Innopolis, methodological intensive and informational information meeting</a></li>
<li><a href="../324528/index.html">Yandex.Money staged a vote for the abolition of the commission for transfers between wallets</a></li>
<li><a href="../324530/index.html">A little bit about the privacy of real Git repositories.</a></li>
<li><a href="../324532/index.html">Unpredictable effects of Chrome performance optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>