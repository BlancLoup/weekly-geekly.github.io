<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Webshell on TCL, for Cisco IOS, and more</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to put into practice the Cisco IOS capabilities that hide behind the tclsh command and are present in almost every router and switc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Webshell on TCL, for Cisco IOS, and more</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to put into practice the Cisco IOS capabilities that hide behind the <i>tclsh</i> command and are present in almost every router and switch.  But unfortunately, or maybe fortunately, I didn‚Äôt have to solve problems where the use of automation by the means of the device itself could somehow help, but there were never too many devices from Cisco under my control.  Finally, fate threw me on a business trip from where it was necessary to manage the network, and in the hands of only a tablet with Wi-Fi and the 80th TCP port.  This time I had to dictate commands by voice through the phone, but on arrival the task was solved using <a href="http://www.cisco.com/en/US/docs/ios/12_3t/12_3t2/feature/guide/gt_tcl.html">Cisco IOS Scripting with Tcl</a> . <a name="habracut"></a>  Fortunately, TCL implementation in Cisco IOS is functional enough to solve this problem. <br>  At first I went in search of a ready-made solution.  Actually, Cisco itself offers access to its devices through a web interface, but such access does not have all the features of the console interface (as Cisco itself indicates), requires preliminary configuration (for example, Java for SDM), affects security, is not convenient for use ( for me) - in general, on all devices <i>no ip http server</i> .  It was also possible to pamper the SSH / telnet port on HTTP, but here‚Äôs the problem with the tablet: telnet hasn't been there for a long time in Windows, and ssh.  We take into account that we may need to go as quickly as possible from any device where there is a web browser, let it be the phone of the beginning / mid-2000s. <br>  We look at third-party ready-made solutions for remote access to the Cisco console - <a href="http://www.xakep.ru/post/54328/default.asp">this is probably the most popular article on this topic</a> , but remember that we need at least telnet.  As a result, we will form requirements: access via the web-interface, as simple as possible to run on the device (ideally with one team) - and we will write everything ourselves. <br>  First, what happened - by the link at the end of the post, you can pick up a script that should be run on a remote device.  Due to the fact that the implementation of TCL is for very many systems, so you can get access to Cisco IOS, Windows, Linux, FreeBSD (this is just what I checked myself).  In the parameters, you must specify the address at which we will listen to incoming requests, and the port.  If the parameters are not specified, then we listen to all the addresses and the first free port allocated to us by the system.  There is a semblance of a hint (as in Cisco) when a question mark is in the parameters, the irony is that the hint does not work in the Cisco console, the question mark is intercepted by the Cisco console.  The first line does not contain the standard <i>#! &lt;Script path&gt;</i> , so we explicitly call <i>tclsh</i> (for Cisco, it is impossible to do otherwise): <br><blockquote><pre><code class="bash hljs">win&gt;tclsh cws.tcl ? ABCD or * Listen ip address &lt;cr&gt; win&gt;tclsh cws.tcl * ? &lt;0-65535&gt; Listen tcp port, 0 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> first free &lt;cr&gt; win&gt;tclsh cws.tcl * 8181 Listen on http://0.0.0.0:8181</code> </pre> </blockquote><br>  For the Cisco console, we write the full path (via tftp), and you need to be in privileged mode.  In tclsh mode, call the script through <i>source</i> , but the command line parameters cannot be passed to the script: <br><blockquote><pre> <code class="bash hljs">cisco<span class="hljs-comment"><span class="hljs-comment">#tclsh tftp://192.0.2.1/cws.tcl * 8181 Listen on http://0.0.0.0:8181 cisco#tclsh cisco(tcl)#source tftp://192.0.2.1/cws.tcl Listen on http://0.0.0.0:43012</span></span></code> </pre></blockquote><br>  For nix consoles, the parameter "*" is perceived as a wildcard parameter (wildcard), therefore it is necessary to screen it with "\ *" or enclose it in quotes. <br>  After launch, you can enter the browser at the address you are listening to.  The ascetic interface is a line for entering commands, a button for executing and stopping a script, and also a tclsh mode switch. <img src="https://habrastorage.org/storage2/eaf/74f/1f7/eaf74f1f78aac15a50a466ea627c304c.jpg"><br>  If the command being executed has something to output, then the output of the command will be shown at the beginning of the page.  The tclsh mode executes the command as a TCL script ‚Äî you can use the entire set of language commands.  The input field is limited to 160 characters, the size is 40 characters (convenient for the tablet).  The script stop button will finish its work on the device, we will not need to ask anyone for this when we finish our actions.  Execution errors of the command itself are processed and output back to the web interface, communication and script errors are not caught at all, so standard console interpreter errors TCL can get out of the console (I tried to catch everything as much as possible, but maybe that‚Äôs left).  It is also worth remembering that the script processes only one request at a time, and if you execute a command that requires interactive actions or a long execution period, then access for further control of the script will be lost.  You can terminate the command being executed with the "&amp;" character separated by a space, which will launch it in the background and return control back to the script, does not work for Cisco IOS. <br>  The main feature of tclsh on Cisco is that all Cisco commands are interpreted as native by the interpreter, that is, in fact, we supplement the TCL language with all the functionality that a particular device command interface has - we don‚Äôt need to explicitly call commands using <i>exec</i> , they are already are performed.  Also, we will not be able to switch to configuration mode from the <i>conf t</i> terminal, for this we need to use the command TCL addition from Cisco - <i>ios_config</i> .  For example, turn off the interface: <br><blockquote><pre> <code class="bash hljs">cisco<span class="hljs-comment"><span class="hljs-comment">#conf t cisco(config)#int fa0/0 cisco(config-if)#shutdown cisco#tclsh cisco(tcl)#ios_config "int fa 0/0" "shutdown"</span></span></code> </pre></blockquote><br>  In great detail about this as always on <a href="http://www.cisco.com/en/US/docs/ios/12_3t/12_3t2/feature/guide/gt_tcl.html">cisco.com</a> . <br>  On the contrary, in Windows all commands are not executed in the console, that is, they are perceived only as a separate executable file, so in order to execute, for example, <i>dir,</i> you must explicitly call the console: <br><blockquote><pre> <code class="bash hljs">win&gt;cmd /c dir c:\    C   SYSTEM   : A073-3CE1   c:\</code> </pre></blockquote><br>  With the functionality finished, now a little about implementation.  To accept TCP connections, use the <i>socket</i> command in server mode, the <i>-server</i> key.  If necessary, we transfer the address to listen to (if it is not then all addresses will be listened to) the <i>-myaddr</i> key.  Required parameters is the name of the callback procedure that will be called when the data is transmitted in the established connection, in our case it is <i>get_http</i> .  As I already wrote, errors when creating a connection are not checked, if something goes wrong the script will swear at the console.  The open socket is saved to the <i>wsh</i> variable, from which we get its parameters with the command <i>fconfigure $ wsh -sockname</i> - the listened address and port to display them on the screen. <br><blockquote><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { <span class="hljs-variable"><span class="hljs-variable">$argc</span></span> == <span class="hljs-variable"><span class="hljs-variable">$i</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [string length <span class="hljs-variable"><span class="hljs-variable">$listenaddr</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> wsh [socket -server get_http -myaddr <span class="hljs-variable"><span class="hljs-variable">$listenaddr</span></span> <span class="hljs-variable"><span class="hljs-variable">$listenport</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> wsh [socket -server get_http <span class="hljs-variable"><span class="hljs-variable">$listenport</span></span>] } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> sockparam [fconfigure <span class="hljs-variable"><span class="hljs-variable">$wsh</span></span> -sockname] puts <span class="hljs-string"><span class="hljs-string">"Listen on http://[lindex </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sockparam</span></span></span><span class="hljs-string"> 0]:[lindex </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sockparam</span></span></span><span class="hljs-string"> 2]"</span></span> after <span class="hljs-variable"><span class="hljs-variable">$connwait</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> stopsrv 1 vwait stopsrv close <span class="hljs-variable"><span class="hljs-variable">$wsh</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> retcode <span class="hljs-variable"><span class="hljs-variable">$stopsrv</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> retcode [expr <span class="hljs-variable"><span class="hljs-variable">$i</span></span> + 100] } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$retcode</span></span></code> </pre></blockquote><br>  Then we call <i>vwait</i> which is waiting for the change in the variable <i>stopsrv</i> .  Without this callback command, the procedure will not accept connections, the server as such will not listen on the port at all.  In fact, only after calling this command, we switch to server mode: TCL goes into the internal loop where the connection requests are processed.  The <i>stopsrvv</i> variable <i>is</i> needed to stop handling connections - stop the server, we will set it when you click the stop button in the web interface - TCL will exit the listening cycle, complete the callback procedure <i>get_http</i> and only then execute the <i>close</i> command following <i>vwait</i> that closes the open socket  Before <i>vwait</i> , a protective mechanism: if we change our mind to go in or do not take any action for a long time, then after the time set in the variable <i>connwait</i> = 15 minutes, <i>stopsrv</i> will be installed and <i>vwait</i> will continue to run.  If we logged in, the <i>after is</i> reinitialized again in the <i>get_http</i> procedure. <br>  A wrapper from <i>if is</i> needed to correctly transfer the command line parameters to this block, the parameters themselves are checked earlier, that there and how you can see in the script itself. <br>  We remember about the Cisco tclsh feature that Cisco commands are native to it, so instead of <i>exit</i> which belongs specifically to Cisco and not TCL, we use <i>return</i> - after executing the script on Cisco, a completion code will be issued to the console. <br>  All the main work is done in the <i>get_http</i> procedure, where the input parameters of HTTP requests are analyzed and the procedures for generating HTTP responses are called: <br><blockquote><pre> <code class="bash hljs">proc get_http { sockaddr ipaddr portaddr } { global stopsrv global connwait gets <span class="hljs-variable"><span class="hljs-variable">$sockaddr</span></span> r flush <span class="hljs-variable"><span class="hljs-variable">$sockaddr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rs [string tolower [string trim <span class="hljs-variable"><span class="hljs-variable">$r</span></span>]] after cancel <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> stopsrv 2 after <span class="hljs-variable"><span class="hljs-variable">$connwait</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> stopsrv 2 switch -regexp -- <span class="hljs-variable"><span class="hljs-variable">$rs</span></span> { {^get\s*/close} { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> body 1; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> stopsrv 0 } {^get\s*/\s+} { puts <span class="hljs-string"><span class="hljs-string">"GET from </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ipaddr</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$portaddr</span></span></span><span class="hljs-string">"</span></span>; after cancel <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> stopsrv 1 } {^get\s*/\?cmd=} { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { [regexp {/\?cmd=([^[:space:]^\&amp;]*)(&amp;tclsh)?} <span class="hljs-variable"><span class="hljs-variable">$r</span></span> opt cmdline checked] &amp;&amp; [string length <span class="hljs-variable"><span class="hljs-variable">$cmdline</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> cmdline [expandPercent <span class="hljs-variable"><span class="hljs-variable">$cmdline</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> { ! [string length <span class="hljs-variable"><span class="hljs-variable">$checked</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> { catch <span class="hljs-string"><span class="hljs-string">"exec </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cmdline</span></span></span><span class="hljs-string">"</span></span> msgout } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { catch <span class="hljs-variable"><span class="hljs-variable">$cmdline</span></span> msgout <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> checked {checked} } } } default {<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> mode 1; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> body 2 } } response_http <span class="hljs-variable"><span class="hljs-variable">$sockaddr</span></span> <span class="hljs-variable"><span class="hljs-variable">$mode</span></span> response_html <span class="hljs-variable"><span class="hljs-variable">$sockaddr</span></span> <span class="hljs-variable"><span class="hljs-variable">$body</span></span> <span class="hljs-variable"><span class="hljs-variable">$cmdline</span></span> <span class="hljs-variable"><span class="hljs-variable">$msgout</span></span> <span class="hljs-variable"><span class="hljs-variable">$checked</span></span> close <span class="hljs-variable"><span class="hljs-variable">$sockaddr</span></span> }</code> </pre></blockquote><br>  The parameters of this procedure are: an open socket <i>sockaddr</i> , where we will read from and where we will write, as well as the port <i>portaddr</i> and the address of the <i>ipaddr</i> client that has joined.  We define the global variable <i>stopsrv</i> to see it outside this procedure, it is necessary for <i>vwait</i> .  We read only the first line (we do not need the rest - <i>flush</i> ), we expect that there will be a GET request.  We check it in <i>switch</i> and act in accordance with what the client gives us.  If we do not know something, then we will return ‚ÄúHTTP / 1.0 501‚Äù (we cannot display the requested content).  We respond to the correct request with "HTTP / 1.0 200". <br>  All HTTP responses are generated in the <i>response_http</i> procedure, and the HTML page is in <i>response_html</i> .  I will not describe these procedures, in them the linear code for outputting page markup - just a few lines of <i>puts $ sockaddr &lt;text&gt;</i> and checking the conditions for what to output. <br>  We respond to the following requested data: <br><ul><li>  <b>/ - root</b> - we print our page, and write to the device console who came to us - the address and port.  Also cancel the pause <i>after</i> ; </li><li>  <b>/ close - terminate the script</b> - set the <i>stopsrv</i> variable (in fact, "/ close?" flies from the client, as a request from a form without parameters); </li><li>  <b>/ cmd = &lt;command&gt; &amp; tclsh</b> - first open the text from the HTTP request - the processed line arrives to us where all spaces are replaced with "+", all non-standard characters (almost all characters except letters and numbers) are represented as% XX.  To do this, we use <i>expandPercent</i> , almost invariably with <a href="http://wiki.tcl.tk/14144">TCL Wiki</a> .  Next, we execute the cleared command via <i>catch</i> and save the execution results in <i>msgout</i> , for output on our page.  Calling the team in this way we catch possible errors of its execution.  If the ‚Äútclsh‚Äù parameter is present, then we execute as is, if not, then we execute via <i>exec</i> - which gives us the effect of executing the command in the device console. </li></ul><br>  Right after we send the answers, we close the socket.  The fact that we do not support ‚Äúkeep-alive‚Äù connections is reported in each HTTP response with the option ‚ÄúConnection: close‚Äù and indicating the version of ‚ÄúHTTP / 1.0‚Äù.  The script in no way tries to meet the standards, I made the minimum possible processing, so that those browsers that were at hand (Opera 12, IE7, Chrome) reacted to the transmitted data normally, there could be surprises in those that were not at hand. <br>  The language syntax feature directly on Cisco IOS is more related to the implementation of TCL version 8.3.4, and the latest version 8.5.12.  For example, the convenient <i>switch</i> , <i>-matchvar,</i> and <i>-nocase options are</i> not implemented.  In any case, you can write on any platform, just more strictly related to syntax and then there will be no problems with the transfer. <br>  In the code, I could screw up a little, went overboard with the style somewhere, on the contrary, on some devices it might not start because of the features of these devices, but on the whole I looked pretty stable.  The main thing when using is to remember that this is just a tool, and how to attach the head to it depends only on the one who applies this head. <br><br>  The script can be <a href="http://yadi.sk/d/zjOyrCkF0_McK">picked</a> up by reference - <a href="http://yadi.sk/d/zjOyrCkF0_McK">cws.tcl</a> <br>  TCL on Cisco - <a href="http://www.cisco.com/en/US/docs/ios/12_3t/12_3t2/feature/guide/gt_tcl.html">www.cisco.com/en/US/docs/ios/12_3t/12_3t2/feature/guide/gt_tcl.html</a> <br>  TCL Commands - <a href="http://www.tcl.tk/man/tcl8.5/TclCmd/contents.htm">www.tcl.tk/man/tcl8.5/TclCmd/contents.htm</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/157371/">https://habr.com/ru/post/157371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157359/index.html">Google turns off background images in search</a></li>
<li><a href="../157361/index.html">Android Phishing</a></li>
<li><a href="../157363/index.html">Qt signal / slot implementation on Android</a></li>
<li><a href="../157367/index.html">On intellectual property with a cool head. Part 2</a></li>
<li><a href="../157369/index.html">Kim Dotcom promises $ 400 million fiber and free internet to all New Zealand residents</a></li>
<li><a href="../157373/index.html">Anonymous merged VMware ESX kernel source</a></li>
<li><a href="../157377/index.html">School crafts: Battlecruiser & DeathCraft</a></li>
<li><a href="../157379/index.html">Application recovery when starting from the start screen without losing the previous state in WP8</a></li>
<li><a href="../157383/index.html">Advantages of arbitrary tags, or how I abandoned HTML markup</a></li>
<li><a href="../157385/index.html">The advantages of Check Point centralized security over network competitors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>