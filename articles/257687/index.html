<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Write on Rust - run everywhere. Rust and C interaction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of "Habrakhabr" the translation of the post "Rust Once, Run Everywhere" from the blog Rust by Alex Crichton. I myself have been in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Write on Rust - run everywhere. Rust and C interaction</h1><div class="post__text post__text-html js-mediator-article">  <i>I offer the readers of "Habrakhabr" the translation of the post <a href="http://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">"Rust Once, Run Everywhere"</a> from the blog Rust by Alex Crichton.</i>  <i>I myself have been interested in this language for some time, and in connection with the imminent release of version 1.0 I would like to promote it according to my modest possibilities.</i>  <i>Unfortunately, I don‚Äôt write anything of my own now, but once I was engaged in translations, so I decided to recall a long-standing business.</i>  <i>I did not find the translation of this post on Habr√©, so I decided to make my own.</i> <i><br></i>  <i>Some terms that designate unique concepts for Rust (ownership, borrowing, lifetime parameter), I did not know how best to translate into Russian, so I tried to find the most appropriate and more or less understandable words for the Russian-speaking audience.</i>  <i>Any improvement suggestions are accepted.</i> <br><br>  There have never been plans to achieve Rust's world domination overnight, so there is a great need for the ability to interact with already existing code as easily as with native code at Rust itself.  That is why Rust makes it very easy to use the C API without overhead, and at the same time ensures strict security of memory management, thanks to its control system of ownership and borrowing pointers. <br><a name="habracut"></a><br>  For interfacing with other languages, Rust provides FFI (foreign function interface).  Following the basic principles of Rust, FFI provides an abstraction with zero price, so the cost of calling functions between Rust and C is the same as the cost of calling C functions from code in C. You can use language properties such as control of ownership and borrowing to create a secure protocol for managing pointers and other resources.  Usually such protocols exist only in the form of documentation for the C API (this is at best), Rust makes such requirements explicit (and their implementation is guaranteed by the compiler itself - approx. Transl.) <br><br>  In this post, we will look at how you can encapsulate an insecure C function call interface into a safe abstraction. <br>  And although the main conversation about interaction with C, the integration of Rust with other languages ‚Äã‚Äã(such as Ruby and Python) is just as simple. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Rust works with C </h4><br>  Let's start with a simple example: calling a code on C from Rust, and then show that Rust does not impose any additional costs.  Here is a simple C program that doubles any number on input: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input * <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  To call this function from Rust, you can write this code: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> libc; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_input</span></span></span></span>(input: libc::c_int) -&gt; libc::c_int; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { double_input(input) }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} * 2 = {}"</span></span>, input, output); }</code> </pre><br>  And that's it!  You can try this example yourself <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/rust-to-c">with the code from GitHub</a> - just check it out and execute the <code>cargo run</code> from the project directory.  From the code it is clear that no additional gestures are required to call the C function, just to describe its signature.  Soon we will see that the generated machine code also does not contain any additional costs.  However, there are several small (but insidious - approx. Transl.) Details in this program on Rust, so we first analyze each part in more detail. <br><br>  First, we see <code>extern crate libc</code> .  <a href="https://crates.io/crates/libc">The libc rack</a> contains many type definitions for FFI, which are useful for working with C, and it is guaranteed that the types on the call boundary between Rust and C are consistent with each other. <br><br>  Go ahead: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_input</span></span></span></span>(input: libc::c_int) -&gt; libc::c_int; }</code> </pre><br>  In Rust, this is an external function declaration.  You can think of this code as an analog of the header file in C. Here the compiler learns about the input and output parameters of the function.  As you can see, this signature coincides with the definition of a function on C. <br><br>  Next we have the main program code: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { double_input(input) }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} * 2 = {}"</span></span>, input, output); }</code> </pre><br>  Here you can see one of the most important aspects of FFI in Rust, the <code>unsafe</code> block.  The compiler does not know anything about the implementation of the <code>double_input()</code> function, so that it initially assumes that when any external function is called, the memory management security may be impaired.  The <code>unsafe</code> block gives the programmer the opportunity to take responsibility for ensuring the safety of working with memory: in this way, you promise that the call to this function will not violate the integrity of the memory, so that the basic guarantees of Rust will remain fulfilled.  It seems that these restrictions are too strict, but Rust provides enough resources for API users not to worry about unsafe blocks (this point will be revealed a bit later). <br><br>  Now that we have seen how to make a C function call from Rust, let's see if Rust really does not impose any additional costs on this call.  Almost all programming languages ‚Äã‚Äãcan somehow call C code, but often this is accompanied by at least additional type conversions, and sometimes more complex operations, during program execution.  To see what Rust actually does, let's look at the assembler code issued by the Rust compiler to call the <code>double_input()</code> function: <br><br><pre> <code class="hljs perl">mov $0x4,%edi callq <span class="hljs-number"><span class="hljs-number">3</span></span>bc3<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;double_input&gt;</code> </pre><br>  And it's all!  As you can see here, the C-function call from Rust only requires the placement of arguments and one call introduction, just as if the call were from code C. <br><br><h4>  Safe abstractions </h4><br>  Most of Rust's capabilities are tied to the concept of data ownership, and FFI is no exception.  When you create a binding for the C library in Rust, you not only get zero overhead, but you can guarantee greater security of working with memory than in C!  Bindings can use Rust's owning and borrowing principles for strict control over the rules using the API, which are usually described only in the C header files in the form of comments. <br><br>  For example, imagine a library for working with tar archives.  This library provides a function to read the contents of each archive file, something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Gets the data for a file in the tarball at the given index, returning NULL if // it does not exist. The `size` pointer is filled in with the size of the file // if successful. const char *tarball_file_data(tarball_t *tarball, unsigned index, size_t *size);</span></span></code> </pre><br><br>  This function makes implicit assumptions about how it will be used: the returned <code>char*</code> pointer cannot survive the <code>tarball_t *tarball</code> input parameter.  Bindings to this API on Rust can look like this: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tarball</span></span></span></span> { raw: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> tarball_t } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Tarball { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">file</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;&amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]&gt; { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = tarball_file_data(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.raw, index <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> libc::c_uint, &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data.is_null() { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(slice::from_raw_parts(data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>)) } } } }</code> </pre><br><br>  Here, the pointer <code>*mut tarball_t</code> owns the <code>Tarball</code> structure, which is responsible for clearing the memory and resources, so that we already have full knowledge of the lifetime of the memory allocated for the tar archive.  In addition, the <code>file()</code> method returns a borrowed slice, the lifetime of which is implicitly related to the lifetime of the <code>Tarball</code> structure <code>Tarball</code> ( <code>&amp;self</code> argument).  Thus, Rust shows that the returned slice can be used only as long as the structure with the archive is alive, statically ensuring that there will be no bugs with trailing pointers (which is easy to admit in C itself).  (If you are not familiar with borrowing in Rust, I advise you to read <a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">the possession of the post Yehuda Katz</a> .) <br><br>  Here the main feature of bindings in Rust is their security, that is, the user of this API in Rust should not use the <code>unsafe</code> block to call them!  Although the implementation itself is not safe here (due to the use of FFI), the interface to it, thanks to borrowed pointers, guarantees the safety of working with memory for any code on Rust that uses it.  That is, the Rust compiler statically guarantees that it is simply impossible to call segfault when using this API from Rust code.  And do not forget: all this does not bear any additional overhead costs!  All types of C in Rust-e are presented without any additional memory requirements. <br><br>  The Rust community has already created a decent set of secure bindings for existing C libraries, including <a href="https://crates.io/crates/openssl">OpenSSL</a> , <a href="https://crates.io/crates/git2">libgit2</a> , <a href="https://crates.io/crates/dispatch">libdispatch</a> , <a href="https://crates.io/crates/curl">libcurl</a> , <a href="https://crates.io/crates/sdl2">sdl2</a> , <a href="https://crates.io/crates/nix">Unix APIs,</a> and <a href="https://crates.io/crates/sodiumoxide">libsodium</a> .  And this list on <a href="https://crates.io/">crates.io</a> is replenished very quickly, so it may very well be that your favorite C-library either already has bindings on Rust, or they will be written soon. <br><br><h4>  C works with Rust </h4><br>  Despite guarantees for the safety of memory, Rust does not use the garbage collector or the runtime environment, Rust code can be called from C without any special training.  That is, there is no overhead for not only C calls from Rust, but also Rust calls from C! <br><br>  Take the example opposite to the previous one.  As before, all the code <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/c-to-rust">is available on GitHub</a> .  First, the code on Rust-e: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_input</span></span></span></span>(input: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { input * <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  As before, there is nothing complicated here, but some intricate features are worth considering.  First, we marked our function with the <code>#[no_mangle]</code> attribute.  This is a signal to the compiler that you do not need to distort the function name <code>double_input</code> .  Rust uses name decoration similar to what is used in C ++ to guarantee the uniqueness of names between different libraries, and this attribute will allow us not to guess what name the compiler gave the function when it is called from C (and the decorated name can be like this: <code>double_input::h485dee7f568bebafeaa</code> ). <br><br>  Next we have the definition of a function, and the most interesting thing here is the keyword <code>extern</code> .  This is a special form for specifying an <a href="http://doc.rust-lang.org/reference.html">ABI function</a> , which makes it compatible with calling functions from C. <br><br>  Finally, if you <a href="">look at <code>Cargo.toml</code></a> , you will see that this library is not assembled as a regular Rust library (rlib), but as a static one, which in Rust is called ‚Äústaticlib‚Äù.  All this makes it possible to statically link the code on Rust with the C program. <br><br>  Now that we have understood the library on Rust, let's write a C program that will use it. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; extern int32_t double_input(int32_t input); int main() { int input = 4; int output = double_input(input); printf("%d * 2 = %d\n", input, output); return 0; }</span></span></span></span></code> </pre><br>  Here you can see that in C, as in Rust, you need to declare the external function <code>double_input()</code> , now written in Rust. <br><br>  Apart from this detail, everything else is already working!  If you run <code>make</code> from a directory <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/c-to-rust">from GitHub</a> , then this example will be compiled and assembled into one static executable file, which will launch <code>4 * 2 = 8</code> to the console. <br><br>  The absence of a garbage collector and runtime environment makes it very easy to integrate C with Rust.  The external C-code should not make any gestures for setting up the Rust's environment, so the transitions between the Rust-code and C are very cheap. <br><br><h4>  After C </h4><br>  FFI in Rust, as we have seen, does not give almost any overhead, and the system of ownership allows you to write memory-safe bindings to C-libraries for Rust.  However, even if you do not use C, you are still lucky!  The same principles allow you to call Rust code from <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/python-to-rust">Python</a> , <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/ruby-to-rust">Ruby</a> , <a href="https://github.com/alexcrichton/rust-ffi-examples/tree/master/node-to-rust">JavaScript,</a> and many other languages. <br><br>  Sometimes, programming in these languages, it becomes necessary to speed up critical components, but earlier it had to go down to C, thereby abandoning the security of memory management, high-level abstractions and the ergonomics of these languages. <br><br>  However, the fact that Rust easily integrates with C means that it is also well suited for this use.  One of the first companies to use Rust in production, <a href="https://www.skylight.io/">Skylight</a> , was able to almost instantly improve performance and reduce memory usage by data collections, simply by switching to Rust, while the entire Rust code was published as Ruby-gem. <br><br>  The transition from Python and Ruby to C languages ‚Äã‚Äãto optimize performance is often a rather laborious process, and it is difficult to guarantee that the program will not crash so hard to debug.  Rust not only provides FFI with zero costs, but it also makes it possible to keep the same security guarantees as the original language.  In the long run, this should enable programmers in these languages ‚Äã‚Äãto descend closer to the hardware and add a bit of system programming to increase performance where it is needed. <br><br>  FFI is just one of many tools in Rust's money-box, but it is the main component to transition to Rust, since it makes it very easy to integrate with the existing code.  I personally will be very happy to see how the merits of Rust come in as many projects as possible! </div><p>Source: <a href="https://habr.com/ru/post/257687/">https://habr.com/ru/post/257687/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257677/index.html">Low Blood Application Architecture</a></li>
<li><a href="../257679/index.html">Analysis of CPL malware, part 1</a></li>
<li><a href="../257681/index.html">Trojan-Downloader.Win32.Cabby.cemx - Part Two - Functional</a></li>
<li><a href="../257683/index.html">Likbez - how to become a programmer</a></li>
<li><a href="../257685/index.html">Product design digest, April 2015</a></li>
<li><a href="../257689/index.html">Practical experience with little-known European cloud hosting</a></li>
<li><a href="../257691/index.html">PHP Digest number 62 - interesting news, materials and tools (April 26 - May 11, 2015)</a></li>
<li><a href="../257693/index.html">Interview with hidnplayr</a></li>
<li><a href="../257695/index.html">Azure cache</a></li>
<li><a href="../257697/index.html">Start options and other improvements in the new assembly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>