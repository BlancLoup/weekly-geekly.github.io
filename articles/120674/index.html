<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET Micro Framework: Porting in Brief</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last article caused a certain interest. Many different questions were asked, but most of them touched porting. This topic is worthy of a separate ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET Micro Framework: Porting in Brief</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/controllers/120220/">The last article</a> caused a certain interest.  Many different questions were asked, but most of them touched porting.  This topic is worthy of a separate full-fledged book and briefly illuminate it is not easy.  But I'll try. <br><a name="habracut"></a><br><h4>  1. Introduction </h4><br>  For people who decide to do porting, Microsoft supplies a special tool: <a href="http://www.microsoft.com/downloads/en/details.aspx%3FFamilyID%3Dccdd5eac-04b1-4ecb-bad9-3ac78fb0452b">.Net Micro Framework Porting Kit</a> .  It is a set of source codes and configuration files from which you can compile the CLR.  The build system is based on MSBuild.  At the moment compilation is started only from the command line.  Virtually no graphic tools are provided.  The only exception is the SolutionWizard utility, which allows you to configure port projects.  There is also no support for development environments.  Roughly speaking, the ports are written almost in a notebook.  But in the near future the situation should change for the better. <br><br><h4>  2. Architecture .NET Micro Framework </h4><br>  Before talking about porting, it‚Äôs very important to understand how the .Net Micro Framework is built inside.  In the <a href="http://habrahabr.ru/blogs/controllers/120220/">last article,</a> I briefly talked about the .Net Micro Framework architecture, and here I‚Äôll look at it in more detail.  In the documentation for .Net Micro Framework Porting Kit there is such a picture: <br><br><img src="https://habrastorage.org/storage/59e6ba65/1fa9560f/dd47c3b3/17274cf0.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is a 4-layer architecture. Net Micro Framework.  The same documentation says (in my free translation) the following: <br><br><h5>  Hardware layer </h5><br>  This layer contains the microprocessor and other components that make up your hardware platform.  Currently, the .NET Micro Framework can be run on processors such as ARM7, ARM9, Cortex, XScale, ARC, and ADI Blackfin. <br><br>  In addition, it is possible to run the .Net Micro Framework on top of the operating system.  Of course, in this case the ‚Äúiron‚Äù does not disappear anywhere.  Simply interaction with the hardware will occur through the operating system API.  This is how the emulator, which is part of the <a href="http://www.microsoft.com/downloads/en/details.aspx%3FFamilyID%3Dcff5a7b7-c21c-4127-ac65-5516384da3a0">.NET Micro Framework Platform SDK</a> , works.  It is nothing like the .NET Micro Framework port for Windows. <br><br><h5>  Runtime Component Layer </h5><br>  This layer consists of 3 components: <br><br>  ‚Ä¢ .NET Micro Framework common language runtime (CLR); <br>  ‚Ä¢ Hardware abstraction layer (HAL); <br>  ‚Ä¢ Platform abstraction layer (PAL). <br><br><h6>  CLR </h6><br>  The .NET Micro Framework CLR (TinyCLR) runtime is a subset of the .NET Framework CLR.  TinyCLR differs from the ‚Äúbig‚Äù CLR in that it has been specially redesigned for use in small embedded devices. <br><br>  The .Net Micro Framework Porting Kit comes with TinyCLR source codes.  These codes are a hardware-independent library that can be compiled by different compilers for different architectures. <br><br><h6>  HAL and PAL </h6><br>  TinyCLR interacts with the underlying hardware through HAL and PAL.  Both HAL and PAL consist of a set of functions called from TinyCLR.  These functions are written in C ++.  It is clear that the functions of HAL are very closely related to the "iron".  The functions included in PAL, on the contrary, are designed so as not to depend on the hardware implementation. <br><br>  Many functions of HAL and PAL form pairs.  They are used together to perform a specific task.  TinyCLR calls the PAL function, which in turn uses the HAL function to access the hardware. <br><br>  In addition, the so-called Bootstrap code is included in the HAL.  After power-up, this code initializes the hardware and then launches TinyCLR. <br>  TinyCLR continues to load and is engaged in high-level initialization.  Bootstrap code performs its tasks using functions from HAL and special assembler inserts. <br><br><h5>  Class Library Layer </h5><br>  The .NET Micro Framework class library is an object-oriented type collection that developers use when writing embedded applications.  This may include third-party types.  For example, developers of debug boards add classes to work with peripheral devices located on these boards. <br><br><h5>  Application layer </h5><br>  This level contains the applications you create for your devices.  To date, the only language for developing such applications is C #. <br><br>  Thus, the main task of porting is to write functions and configurations of the HAL level.  Now let's see how this is done. <br><br><h4>  3. Solutions in the .NET Micro Framework Porting Kit </h4><br>  Each port within the .Net Micro Framework Porting Kit is a Solution.  Solution in turn consists of several Projects.  In total there are 5 types of Projects: <br><br>  ‚Ä¢ NativeSample <br>  ‚Ä¢ PortBooter <br>  ‚Ä¢ TinyBooter <br>  ‚Ä¢ TinyBooterDecompressor <br>  ‚Ä¢ TinyCLR <br><br>  <i>NativeSample</i> is a simple ‚ÄúHello World‚Äù project.  The main task in its implementation is to write a sufficient number of HAL functions in order to output the string ‚ÄúHello, World‚Äù to the debugging console. <br><br>  <i>PortBooter</i> - port loader.  It allows you to flash new versions of TinyCLR during the port development and debugging process.  Implementing this project requires adding new HAL functions to those already written for NativeSample.  This is a transitional project to prepare for the implementation of the following projects. <br><br>  <i>TinyBooter</i> is a .NET Micro Framework loader.  At the time of power-up, it performs all the necessary initialization and launches TinyCLR.  In addition, it allows you to flash new versions of TinyCLR.  In the process of implementing this project, several new features are added to HAL. <br><br>  <i>TinyBooterDecompressor</i> is a special add-on designed to minimize the physical size of TinyBooter.  TinyBooter is stored in an archived form and when turned on, it is unpacked and loaded using TinyBooterDecompressor. <br><br>  <i>TinyCLR</i> is actually the execution environment itself.  Getting a working TinyCLR is the goal of porting.  In the process of working on this project, the remaining HAL functions are added.  TinyCLR includes TinyBooter. <br><br>  Thus, implementing these projects in turn, you create a HAL layer. <br><br><h4>  4. Solution Wizard and Project Components </h4><br>  Creating a new Solution begins with SolutionWizard.  This utility allows you to create a Solution from scratch, make a new Solution based on an existing (clone) and edit an existing one. <br>  In the process, SolutionWizard allows you to select the so-called <i>Features</i> that will be included in the Solution.  <i>Features</i> are functional properties of the .Net Micro Framework.  For example, there are features such as I2C, UART, SD, etc.  Thus, if you do not need some features of the .Net Micro Framework, then you can simply not include them in the project, thereby reducing the physical size of TinyCLR. <br><br>  Each <i>Feature</i> is implemented by a set of <i>Libraries</i> , which are combined into <i>Library Categories</i> .  <i>Library</i> is a separate MSBuild project that implements its task.  Actually, the <i>Library</i> and include the source code.  Since there can be many implementations of the same task (for example, for different processors), there can also be many <i>libraries</i> .  That is why they are integrated into the <i>Library Categories</i> .  The default implementation of the <i>Library Category</i> is the <i>stub Library</i> .  This is such a <i>Library</i> , in which there are stubs in place of all functions.  It does not carry any functions and is only needed to ensure the work of the linker, even if there is no normal implementation.  All these components can refer to each other. <br><br>  Thus, it turns out the following bunch: <br>  <i>Feature</i> -&gt; <i>Library</i> Kit <i>Categories</i> -&gt; One <i>Library</i> that implements each category. <br>  To understand this "mess" is not easy.  To at least somehow be clear, look at this picture: <br><br><img src="https://habrastorage.org/storage/89ee6c09/da235d46/ff97b288/563e2315.png"><br><br>  At first glance it does not become clearer.  Let's try to figure it out. <br><br>  Here is the implementation of <i>Feature</i> I2C.  <i>Feature are</i> colored yellow, the <i>Library Category</i> is green, the <i>Library</i> is blue, and the <i>Stub Library</i> is black.  Also on the diagram there are the following types of links: <br><br>  ‚Ä¢ Depend - depends on; <br>  ‚Ä¢ Associate - associated with; <br>  ‚Ä¢ Realize - implements; <br>  ‚Ä¢ Stub - <i>Library</i> with stubs. <br><br>  This picture shows that <i>Feature</i> I2C is implemented by three <i>Library Category</i> : I2C_CLR, I2C_PAL, I2C_HAL.  In addition, it still depends on another <i>Feature</i> Hardware.  Each <i>Library Category</i> corresponds to one of the levels in the <b>Runtime Component Layer</b> . <br><br>  The I2C_CLR category is implemented by the <i>Library</i> I2C and I2C_Stub.  The I2C_PAL category is implemented by the <i>Library</i> I2C_pal and I2C_pal_stubs.  The most interesting thing we see in the implementation of I2C_HAL.  Here, besides the <i>stub Library</i> , there are 5 more <i>Library</i> for different processors. <br><br>  So, for each <i>Library Category</i> associated with the previously selected <i>Feature</i> , SolutionWizard allows you to select one <i>Library</i> .  You can choose one of the existing ones, choose a <i>stub</i> if it is not needed at the moment, or you can generate a template for the new <i>Library</i> . <br><br>  Since the number of <i>Library Category is on the</i> order of hundreds, most of the selection SolutionWizard takes on.  However, you can correct this choice.  In addition, you can select projects that will be included in the Solution. <br><br>  The result of SolutionWizard is either a new Solution or a change in an existing Solution. <br><br>  Next begins writing code and compilation. <br><br><h4>  5. Conclusion </h4><br>  I reviewed the most common concepts and principles for creating .Net Micro Framework ports.  Next come the particulars that go beyond the scope of this article.  For example, working with MSBuild, memory allocation, features of the implementation of specific functions, etc.  I will write about this to all in the following articles. </div><p>Source: <a href="https://habr.com/ru/post/120674/">https://habr.com/ru/post/120674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120668/index.html">PyGTK: threads and magic wrappers</a></li>
<li><a href="../120669/index.html">QIWI Wallet today is 5 years old</a></li>
<li><a href="../120670/index.html">Automation of highways through the eyes of an IT person</a></li>
<li><a href="../120671/index.html">Android Emulator and local web server (Denwer)</a></li>
<li><a href="../120673/index.html">Creating a private NuGet package tape using an online service</a></li>
<li><a href="../120675/index.html">Free books in Russian - Windows Phone, Visual Studio, Small Basic</a></li>
<li><a href="../120676/index.html">TileMill - cartographic design studio</a></li>
<li><a href="../120678/index.html">Do not miss SharePoint Conference 2011 Russia</a></li>
<li><a href="../120681/index.html">Myths about SaaS, cloud platforms and cloud computing</a></li>
<li><a href="../120684/index.html">We are friends with AirPlaySDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>